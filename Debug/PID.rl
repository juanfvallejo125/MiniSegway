L 1 "../PID.cpp"
N/*
N * PID.cpp
N *
N *  Created on: Jun 21, 2020
N *      Author: Juan Francisco Valle
N */
N
N#include "PID.h"
L 1 "..\PID.h" 1
N/*
N * PID.h
N *
N *  Created on: Jun 21, 2020
N *      Author: Juan Francisco Vallejo
N */
N
N#ifndef PID_H_
N#define PID_H_
N
N#include <string>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/string" 1
N// -*- C++ -*-
N//===--------------------------- string -----------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is distributed under the University of Illinois Open Source
N// License. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP_STRING
N#define _LIBCPP_STRING
N
N/*
N    string synopsis
N
Nnamespace std
N{
N
Ntemplate <class stateT>
Nclass fpos
N{
Nprivate:
N    stateT st;
Npublic:
N    fpos(streamoff = streamoff());
N
N    operator streamoff() const;
N
N    stateT state() const;
N    void state(stateT);
N
N    fpos& operator+=(streamoff);
N    fpos  operator+ (streamoff) const;
N    fpos& operator-=(streamoff);
N    fpos  operator- (streamoff) const;
N};
N
Ntemplate <class stateT> streamoff operator-(const fpos<stateT>& x, const fpos<stateT>& y);
N
Ntemplate <class stateT> bool operator==(const fpos<stateT>& x, const fpos<stateT>& y);
Ntemplate <class stateT> bool operator!=(const fpos<stateT>& x, const fpos<stateT>& y);
N
Ntemplate <class charT>
Nstruct char_traits
N{
N    typedef charT     char_type;
N    typedef ...       int_type;
N    typedef streamoff off_type;
N    typedef streampos pos_type;
N    typedef mbstate_t state_type;
N
N    static void assign(char_type& c1, const char_type& c2) noexcept;
N    static constexpr bool eq(char_type c1, char_type c2) noexcept;
N    static constexpr bool lt(char_type c1, char_type c2) noexcept;
N
N    static int              compare(const char_type* s1, const char_type* s2, size_t n);
N    static size_t           length(const char_type* s);
N    static const char_type* find(const char_type* s, size_t n, const char_type& a);
N    static char_type*       move(char_type* s1, const char_type* s2, size_t n);
N    static char_type*       copy(char_type* s1, const char_type* s2, size_t n);
N    static char_type*       assign(char_type* s, size_t n, char_type a);
N
N    static constexpr int_type  not_eof(int_type c) noexcept;
N    static constexpr char_type to_char_type(int_type c) noexcept;
N    static constexpr int_type  to_int_type(char_type c) noexcept;
N    static constexpr bool      eq_int_type(int_type c1, int_type c2) noexcept;
N    static constexpr int_type  eof() noexcept;
N};
N
Ntemplate <> struct char_traits<char>;
Ntemplate <> struct char_traits<wchar_t>;
N
Ntemplate<class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >
Nclass basic_string
N{
Npublic:
N// types:
N    typedef traits traits_type;
N    typedef typename traits_type::char_type value_type;
N    typedef Allocator allocator_type;
N    typedef typename allocator_type::size_type size_type;
N    typedef typename allocator_type::difference_type difference_type;
N    typedef typename allocator_type::reference reference;
N    typedef typename allocator_type::const_reference const_reference;
N    typedef typename allocator_type::pointer pointer;
N    typedef typename allocator_type::const_pointer const_pointer;
N    typedef implementation-defined iterator;
N    typedef implementation-defined const_iterator;
N    typedef std::reverse_iterator<iterator> reverse_iterator;
N    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
N
N    static const size_type npos = -1;
N
N    basic_string()
N        noexcept(is_nothrow_default_constructible<allocator_type>::value);
N    explicit basic_string(const allocator_type& a);
N    basic_string(const basic_string& str);
N    basic_string(basic_string&& str)
N        noexcept(is_nothrow_move_constructible<allocator_type>::value);
N    basic_string(const basic_string& str, size_type pos,
N                 const allocator_type& a = allocator_type());
N    basic_string(const basic_string& str, size_type pos, size_type n,
N                 const Allocator& a = Allocator());
N    template<class T>
N        basic_string(const T& t, size_type pos, size_type n, const Allocator& a = Allocator()); // C++17
N    explicit basic_string(const basic_string_view<charT, traits> sv, const Allocator& a = Allocator());
N    basic_string(const value_type* s, const allocator_type& a = allocator_type());
N    basic_string(const value_type* s, size_type n, const allocator_type& a = allocator_type());
N    basic_string(size_type n, value_type c, const allocator_type& a = allocator_type());
N    template<class InputIterator>
N        basic_string(InputIterator begin, InputIterator end,
N                     const allocator_type& a = allocator_type());
N    basic_string(initializer_list<value_type>, const Allocator& = Allocator());
N    basic_string(const basic_string&, const Allocator&);
N    basic_string(basic_string&&, const Allocator&);
N
N    ~basic_string();
N
N    operator basic_string_view<charT, traits>() const noexcept;
N
N    basic_string& operator=(const basic_string& str);
N    basic_string& operator=(basic_string_view<charT, traits> sv);
N    basic_string& operator=(basic_string&& str)
N        noexcept(
N             allocator_type::propagate_on_container_move_assignment::value ||
N             allocator_type::is_always_equal::value ); // C++17
N    basic_string& operator=(const value_type* s);
N    basic_string& operator=(value_type c);
N    basic_string& operator=(initializer_list<value_type>);
N
N    iterator       begin() noexcept;
N    const_iterator begin() const noexcept;
N    iterator       end() noexcept;
N    const_iterator end() const noexcept;
N
N    reverse_iterator       rbegin() noexcept;
N    const_reverse_iterator rbegin() const noexcept;
N    reverse_iterator       rend() noexcept;
N    const_reverse_iterator rend() const noexcept;
N
N    const_iterator         cbegin() const noexcept;
N    const_iterator         cend() const noexcept;
N    const_reverse_iterator crbegin() const noexcept;
N    const_reverse_iterator crend() const noexcept;
N
N    size_type size() const noexcept;
N    size_type length() const noexcept;
N    size_type max_size() const noexcept;
N    size_type capacity() const noexcept;
N
N    void resize(size_type n, value_type c);
N    void resize(size_type n);
N
N    void reserve(size_type res_arg = 0);
N    void shrink_to_fit();
N    void clear() noexcept;
N    bool empty() const noexcept;
N
N    const_reference operator[](size_type pos) const;
N    reference       operator[](size_type pos);
N
N    const_reference at(size_type n) const;
N    reference       at(size_type n);
N
N    basic_string& operator+=(const basic_string& str);
N    basic_string& operator+=(basic_string_view<charT, traits> sv);
N    basic_string& operator+=(const value_type* s);
N    basic_string& operator+=(value_type c);
N    basic_string& operator+=(initializer_list<value_type>);
N
N    basic_string& append(const basic_string& str);
N    basic_string& append(basic_string_view<charT, traits> sv);
N    basic_string& append(const basic_string& str, size_type pos, size_type n=npos); //C++14
N    template <class T>
N        basic_string& append(const T& t, size_type pos, size_type n=npos); // C++17
N    basic_string& append(const value_type* s, size_type n);
N    basic_string& append(const value_type* s);
N    basic_string& append(size_type n, value_type c);
N    template<class InputIterator>
N        basic_string& append(InputIterator first, InputIterator last);
N    basic_string& append(initializer_list<value_type>);
N
N    void push_back(value_type c);
N    void pop_back();
N    reference       front();
N    const_reference front() const;
N    reference       back();
N    const_reference back() const;
N
N    basic_string& assign(const basic_string& str);
N    basic_string& assign(basic_string_view<charT, traits> sv);
N    basic_string& assign(basic_string&& str);
N    basic_string& assign(const basic_string& str, size_type pos, size_type n=npos); // C++14
N    template <class T>
N        basic_string& assign(const T& t, size_type pos, size_type n=npos); // C++17
N    basic_string& assign(const value_type* s, size_type n);
N    basic_string& assign(const value_type* s);
N    basic_string& assign(size_type n, value_type c);
N    template<class InputIterator>
N        basic_string& assign(InputIterator first, InputIterator last);
N    basic_string& assign(initializer_list<value_type>);
N
N    basic_string& insert(size_type pos1, const basic_string& str);
N    basic_string& insert(size_type pos1, basic_string_view<charT, traits> sv);
N    basic_string& insert(size_type pos1, const basic_string& str,
N                         size_type pos2, size_type n);
N    template <class T>
N        basic_string& insert(size_type pos1, const T& t, size_type pos2, size_type n); // C++17
N    basic_string& insert(size_type pos, const value_type* s, size_type n=npos); //C++14
N    basic_string& insert(size_type pos, const value_type* s);
N    basic_string& insert(size_type pos, size_type n, value_type c);
N    iterator      insert(const_iterator p, value_type c);
N    iterator      insert(const_iterator p, size_type n, value_type c);
N    template<class InputIterator>
N        iterator insert(const_iterator p, InputIterator first, InputIterator last);
N    iterator      insert(const_iterator p, initializer_list<value_type>);
N
N    basic_string& erase(size_type pos = 0, size_type n = npos);
N    iterator      erase(const_iterator position);
N    iterator      erase(const_iterator first, const_iterator last);
N
N    basic_string& replace(size_type pos1, size_type n1, const basic_string& str);
N    basic_string& replace(size_type pos1, size_type n1, basic_string_view<charT, traits> sv);
N    basic_string& replace(size_type pos1, size_type n1, const basic_string& str,
N                          size_type pos2, size_type n2=npos); // C++14
N    template <class T>
N        basic_string& replace(size_type pos1, size_type n1, const T& t,
N                              size_type pos2, size_type n); // C++17
N    basic_string& replace(size_type pos, size_type n1, const value_type* s, size_type n2);
N    basic_string& replace(size_type pos, size_type n1, const value_type* s);
N    basic_string& replace(size_type pos, size_type n1, size_type n2, value_type c);
N    basic_string& replace(const_iterator i1, const_iterator i2, const basic_string& str);
N    basic_string& replace(const_iterator i1, const_iterator i2, basic_string_view<charT, traits> sv);
N    basic_string& replace(const_iterator i1, const_iterator i2, const value_type* s, size_type n);
N    basic_string& replace(const_iterator i1, const_iterator i2, const value_type* s);
N    basic_string& replace(const_iterator i1, const_iterator i2, size_type n, value_type c);
N    template<class InputIterator>
N        basic_string& replace(const_iterator i1, const_iterator i2, InputIterator j1, InputIterator j2);
N    basic_string& replace(const_iterator i1, const_iterator i2, initializer_list<value_type>);
N
N    size_type copy(value_type* s, size_type n, size_type pos = 0) const;
N    basic_string substr(size_type pos = 0, size_type n = npos) const;
N
N    void swap(basic_string& str)
N        noexcept(allocator_traits<allocator_type>::propagate_on_container_swap::value ||
N                 allocator_traits<allocator_type>::is_always_equal::value);  // C++17
N
N    const value_type* c_str() const noexcept;
N    const value_type* data() const noexcept;
N          value_type* data()       noexcept;   // C++17
N
N    allocator_type get_allocator() const noexcept;
N
N    size_type find(const basic_string& str, size_type pos = 0) const noexcept;
N    size_type find(basic_string_view<charT, traits> sv, size_type pos = 0) const noexcept;
N    size_type find(const value_type* s, size_type pos, size_type n) const noexcept;
N    size_type find(const value_type* s, size_type pos = 0) const noexcept;
N    size_type find(value_type c, size_type pos = 0) const noexcept;
N
N    size_type rfind(const basic_string& str, size_type pos = npos) const noexcept;
N    size_type rfind(basic_string_view<charT, traits> sv, size_type pos = npos) const noexcept;
N    size_type rfind(const value_type* s, size_type pos, size_type n) const noexcept;
N    size_type rfind(const value_type* s, size_type pos = npos) const noexcept;
N    size_type rfind(value_type c, size_type pos = npos) const noexcept;
N
N    size_type find_first_of(const basic_string& str, size_type pos = 0) const noexcept;
N    size_type find_first_of(basic_string_view<charT, traits> sv, size_type pos = 0) const noexcept;
N    size_type find_first_of(const value_type* s, size_type pos, size_type n) const noexcept;
N    size_type find_first_of(const value_type* s, size_type pos = 0) const noexcept;
N    size_type find_first_of(value_type c, size_type pos = 0) const noexcept;
N
N    size_type find_last_of(const basic_string& str, size_type pos = npos) const noexcept;
N    size_type find_last_of(basic_string_view<charT, traits> sv, size_type pos = npos) const noexcept;
N    size_type find_last_of(const value_type* s, size_type pos, size_type n) const noexcept;
N    size_type find_last_of(const value_type* s, size_type pos = npos) const noexcept;
N    size_type find_last_of(value_type c, size_type pos = npos) const noexcept;
N
N    size_type find_first_not_of(const basic_string& str, size_type pos = 0) const noexcept;
N    size_type find_first_not_of(basic_string_view<charT, traits> sv, size_type pos = 0) const noexcept;
N    size_type find_first_not_of(const value_type* s, size_type pos, size_type n) const noexcept;
N    size_type find_first_not_of(const value_type* s, size_type pos = 0) const noexcept;
N    size_type find_first_not_of(value_type c, size_type pos = 0) const noexcept;
N
N    size_type find_last_not_of(const basic_string& str, size_type pos = npos) const noexcept;
N    size_type find_last_not_of(basic_string_view<charT, traits> sv, size_type pos = npos) const noexcept;
N    size_type find_last_not_of(const value_type* s, size_type pos, size_type n) const noexcept;
N    size_type find_last_not_of(const value_type* s, size_type pos = npos) const noexcept;
N    size_type find_last_not_of(value_type c, size_type pos = npos) const noexcept;
N
N    int compare(const basic_string& str) const noexcept;
N    int compare(basic_string_view<charT, traits> sv) const noexcept;
N    int compare(size_type pos1, size_type n1, const basic_string& str) const;
N    int compare(size_type pos1, size_type n1, basic_string_view<charT, traits> sv) const;
N    int compare(size_type pos1, size_type n1, const basic_string& str,
N                size_type pos2, size_type n2=npos) const; // C++14
N    template <class T>
N        int compare(size_type pos1, size_type n1, const T& t,
N                    size_type pos2, size_type n2=npos) const; // C++17
N    int compare(const value_type* s) const noexcept;
N    int compare(size_type pos1, size_type n1, const value_type* s) const;
N    int compare(size_type pos1, size_type n1, const value_type* s, size_type n2) const;
N
N    bool __invariants() const;
N};
N
Ntemplate<class charT, class traits, class Allocator>
Nbasic_string<charT, traits, Allocator>
Noperator+(const basic_string<charT, traits, Allocator>& lhs,
N          const basic_string<charT, traits, Allocator>& rhs);
N
Ntemplate<class charT, class traits, class Allocator>
Nbasic_string<charT, traits, Allocator>
Noperator+(const charT* lhs , const basic_string<charT,traits,Allocator>&rhs);
N
Ntemplate<class charT, class traits, class Allocator>
Nbasic_string<charT, traits, Allocator>
Noperator+(charT lhs, const basic_string<charT,traits,Allocator>& rhs);
N
Ntemplate<class charT, class traits, class Allocator>
Nbasic_string<charT, traits, Allocator>
Noperator+(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs);
N
Ntemplate<class charT, class traits, class Allocator>
Nbasic_string<charT, traits, Allocator>
Noperator+(const basic_string<charT, traits, Allocator>& lhs, charT rhs);
N
Ntemplate<class charT, class traits, class Allocator>
Nbool operator==(const basic_string<charT, traits, Allocator>& lhs,
N                const basic_string<charT, traits, Allocator>& rhs) noexcept;
N
Ntemplate<class charT, class traits, class Allocator>
Nbool operator==(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;
N
Ntemplate<class charT, class traits, class Allocator>
Nbool operator==(const basic_string<charT,traits,Allocator>& lhs, const charT* rhs) noexcept;
N
Ntemplate<class charT, class traits, class Allocator>
Nbool operator!=(const basic_string<charT,traits,Allocator>& lhs,
N                const basic_string<charT, traits, Allocator>& rhs) noexcept;
N
Ntemplate<class charT, class traits, class Allocator>
Nbool operator!=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;
N
Ntemplate<class charT, class traits, class Allocator>
Nbool operator!=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;
N
Ntemplate<class charT, class traits, class Allocator>
Nbool operator< (const basic_string<charT, traits, Allocator>& lhs,
N                const basic_string<charT, traits, Allocator>& rhs) noexcept;
N
Ntemplate<class charT, class traits, class Allocator>
Nbool operator< (const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;
N
Ntemplate<class charT, class traits, class Allocator>
Nbool operator< (const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;
N
Ntemplate<class charT, class traits, class Allocator>
Nbool operator> (const basic_string<charT, traits, Allocator>& lhs,
N                const basic_string<charT, traits, Allocator>& rhs) noexcept;
N
Ntemplate<class charT, class traits, class Allocator>
Nbool operator> (const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;
N
Ntemplate<class charT, class traits, class Allocator>
Nbool operator> (const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;
N
Ntemplate<class charT, class traits, class Allocator>
Nbool operator<=(const basic_string<charT, traits, Allocator>& lhs,
N                const basic_string<charT, traits, Allocator>& rhs) noexcept;
N
Ntemplate<class charT, class traits, class Allocator>
Nbool operator<=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;
N
Ntemplate<class charT, class traits, class Allocator>
Nbool operator<=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;
N
Ntemplate<class charT, class traits, class Allocator>
Nbool operator>=(const basic_string<charT, traits, Allocator>& lhs,
N                const basic_string<charT, traits, Allocator>& rhs) noexcept;
N
Ntemplate<class charT, class traits, class Allocator>
Nbool operator>=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;
N
Ntemplate<class charT, class traits, class Allocator>
Nbool operator>=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;
N
Ntemplate<class charT, class traits, class Allocator>
Nvoid swap(basic_string<charT, traits, Allocator>& lhs,
N          basic_string<charT, traits, Allocator>& rhs)
N            noexcept(noexcept(lhs.swap(rhs)));
N
Ntemplate<class charT, class traits, class Allocator>
Nbasic_istream<charT, traits>&
Noperator>>(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str);
N
Ntemplate<class charT, class traits, class Allocator>
Nbasic_ostream<charT, traits>&
Noperator<<(basic_ostream<charT, traits>& os, const basic_string<charT, traits, Allocator>& str);
N
Ntemplate<class charT, class traits, class Allocator>
Nbasic_istream<charT, traits>&
Ngetline(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str,
N        charT delim);
N
Ntemplate<class charT, class traits, class Allocator>
Nbasic_istream<charT, traits>&
Ngetline(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str);
N
Ntypedef basic_string<char>    string;
Ntypedef basic_string<wchar_t> wstring;
Ntypedef basic_string<char16_t> u16string;
Ntypedef basic_string<char32_t> u32string;
N
Nint                stoi  (const string& str, size_t* idx = 0, int base = 10);
Nlong               stol  (const string& str, size_t* idx = 0, int base = 10);
Nunsigned long      stoul (const string& str, size_t* idx = 0, int base = 10);
Nlong long          stoll (const string& str, size_t* idx = 0, int base = 10);
Nunsigned long long stoull(const string& str, size_t* idx = 0, int base = 10);
N
Nfloat       stof (const string& str, size_t* idx = 0);
Ndouble      stod (const string& str, size_t* idx = 0);
Nlong double stold(const string& str, size_t* idx = 0);
N
Nstring to_string(int val);
Nstring to_string(unsigned val);
Nstring to_string(long val);
Nstring to_string(unsigned long val);
Nstring to_string(long long val);
Nstring to_string(unsigned long long val);
Nstring to_string(float val);
Nstring to_string(double val);
Nstring to_string(long double val);
N
Nint                stoi  (const wstring& str, size_t* idx = 0, int base = 10);
Nlong               stol  (const wstring& str, size_t* idx = 0, int base = 10);
Nunsigned long      stoul (const wstring& str, size_t* idx = 0, int base = 10);
Nlong long          stoll (const wstring& str, size_t* idx = 0, int base = 10);
Nunsigned long long stoull(const wstring& str, size_t* idx = 0, int base = 10);
N
Nfloat       stof (const wstring& str, size_t* idx = 0);
Ndouble      stod (const wstring& str, size_t* idx = 0);
Nlong double stold(const wstring& str, size_t* idx = 0);
N
Nwstring to_wstring(int val);
Nwstring to_wstring(unsigned val);
Nwstring to_wstring(long val);
Nwstring to_wstring(unsigned long val);
Nwstring to_wstring(long long val);
Nwstring to_wstring(unsigned long long val);
Nwstring to_wstring(float val);
Nwstring to_wstring(double val);
Nwstring to_wstring(long double val);
N
Ntemplate <> struct hash<string>;
Ntemplate <> struct hash<u16string>;
Ntemplate <> struct hash<u32string>;
Ntemplate <> struct hash<wstring>;
N
Nbasic_string<char>     operator "" s( const char *str,     size_t len ); // C++14
Nbasic_string<wchar_t>  operator "" s( const wchar_t *str,  size_t len ); // C++14
Nbasic_string<char16_t> operator "" s( const char16_t *str, size_t len ); // C++14
Nbasic_string<char32_t> operator "" s( const char32_t *str, size_t len ); // C++14
N
N}  // std
N
N*/
N
N#include <__config>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/__config" 1
N/* -*- C++ -*- */
N/*===--------------------------- complex.h --------------------------------===*/
N/*                                                                            */
N/*                     The LLVM Compiler Infrastructure                       */
N/*                                                                            */
N/* This file is dual licensed under the MIT and the University of Illinois Open
N** Source Licenses. See LICENSE.TXT for details.
N*/
N/*===----------------------------------------------------------------------===*/
N
N#ifndef _LIBCPP_CONFIG
N#define _LIBCPP_CONFIG
N
N#pragma diag_push
N/* Avoid warning on C++ comments in this file */
N#pragma diag_suppress 2581
N#pragma CHECK_MISRA("-2.2")
N#pragma CHECK_MISRA("-19.4")
N#pragma CHECK_MISRA("-19.10")
N
N// The libc++ cmake build system expects to preinclude __config site during
N// library builds (_LIBCPP_BUILDING_LIBRARY defined). Then, as part of
N// installation, will prepend the contents of __config_site to __config and
N// install the result as __config. __config_site does not exist as part of the
N// cmake installation.
N//
N// The TI mkrts system follows the same behavior while bulding the library.
N// However, it does not support prepending as part of installation, and so must
N// have __config_site exist separately as a pre-generated file.
N//
N// To ensure that the cmake system still works, we only include __config_site
N// when it exists as part of an installation. That is: If a TI compiler is
N// being used, the library has been built/installed, and __config_site exists.
N#if defined(__TI_COMPILER_VERSION__) && !defined(_LIBCPP_BUILDING_LIBRARY) && \
N    __has_include("__config_site")
X#if 1L && !0L &&     1
N#include "__config_site"
L 1 "C:\ti\ccs930\ccs\tools\compiler\ti-cgt-arm_18.12.5.LTS\include\libcxx\__config_site" 1
N//===----------------------------------------------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is dual licensed under the MIT and the University of Illinois Open
N// Source Licenses. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP_CONFIG_SITE
N#define _LIBCPP_CONFIG_SITE
N
N#define _LIBCPP_ABI_VERSION 2
N/* #undef _LIBCPP_ABI_UNSTABLE */
N/* #undef _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE */
N/* #undef _LIBCPP_HAS_NO_STDIN */
N/* #undef _LIBCPP_HAS_NO_STDOUT */
N#define _LIBCPP_HAS_NO_THREADS
N/* #undef _LIBCPP_HAS_NO_MONOTONIC_CLOCK */
N/* #undef _LIBCPP_HAS_NO_THREAD_UNSAFE_C_FUNCTIONS */
N/* #undef _LIBCPP_HAS_MUSL_LIBC */
N/* #undef _LIBCPP_HAS_THREAD_API_PTHREAD */
N/* #undef _LIBCPP_HAS_THREAD_API_EXTERNAL */
N/* #undef _LIBCPP_HAS_THREAD_LIBRARY_EXTERNAL */
N#define _LIBCPP_DISABLE_VISIBILITY_ANNOTATIONS
N
N#include "__libcxx_extra.h"
L 1 "C:\ti\ccs930\ccs\tools\compiler\ti-cgt-arm_18.12.5.LTS\include\libcxx\__libcxx_extra.h" 1
N/*****************************************************************************/
N/* LIBCXX_EXTRA.H                                                            */
N/*                                                                           */
N/* Copyright (c) 2017 Texas Instruments Incorporated                         */
N/* http://www.ti.com/                                                        */
N/*                                                                           */
N/*  Redistribution and  use in source  and binary forms, with  or without    */
N/*  modification,  are permitted provided  that the  following conditions    */
N/*  are met:                                                                 */
N/*                                                                           */
N/*     Redistributions  of source  code must  retain the  above copyright    */
N/*     notice, this list of conditions and the following disclaimer.         */
N/*                                                                           */
N/*     Redistributions in binary form  must reproduce the above copyright    */
N/*     notice, this  list of conditions  and the following  disclaimer in    */
N/*     the  documentation  and/or   other  materials  provided  with  the    */
N/*     distribution.                                                         */
N/*                                                                           */
N/*     Neither the  name of Texas Instruments Incorporated  nor the names    */
N/*     of its  contributors may  be used to  endorse or  promote products    */
N/*     derived  from   this  software  without   specific  prior  written    */
N/*     permission.                                                           */
N/*                                                                           */
N/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS    */
N/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT    */
N/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    */
N/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT    */
N/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    */
N/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT    */
N/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    */
N/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    */
N/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT    */
N/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    */
N/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     */
N/*                                                                           */
N/*****************************************************************************/
N#ifndef __LIBCXX_EXTRA_H__
N#define __LIBCXX_EXTRA_H__
N
N/*
NChanges made to this file affect how TI libc++ is BOTH built and used in
Nproduction environments.
N*/
N
N/*
NThe TI RTS has all source and header files flattened into a single directory.
N*/
N#define _LIBCPP_SOURCE_IS_FLATTENED
N
N/* #pragma diag_suppress 1585,2866 */
N
N#endif /* __LIBCXX_EXTRA_H__ */
L 28 "C:\ti\ccs930\ccs\tools\compiler\ti-cgt-arm_18.12.5.LTS\include\libcxx\__config_site" 2
N
N#endif // _LIBCPP_CONFIG_SITE
L 37 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/__config" 2
N#endif
N
N#if defined(_MSC_VER) && !defined(__clang__)
X#if 0L && !0L
S#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
S#define _LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER
S#endif
N#endif
N
N#ifndef _LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER
N#pragma GCC system_header
N#endif
N
N#ifdef __cplusplus
N
N#ifdef __GNUC__
S#define _GNUC_VER (__GNUC__ * 100 + __GNUC_MINOR__)
S// The _GNUC_VER_NEW macro better represents the new GCC versioning scheme
S// introduced in GCC 5.0.
S#define _GNUC_VER_NEW (_GNUC_VER * 10 + __GNUC_PATCHLEVEL__)
N#else
N#define _GNUC_VER 0
N#define _GNUC_VER_NEW 0
N#endif
N
N#define _LIBCPP_VERSION 6000
N
N#ifndef _LIBCPP_ABI_VERSION
S#define _LIBCPP_ABI_VERSION 1
N#endif
N
N#if defined(__ELF__)
X#if 1L
N#define _LIBCPP_OBJECT_FORMAT_ELF   1
N#elif defined(__MACH__)
S#define _LIBCPP_OBJECT_FORMAT_MACHO 1
S#elif defined(_WIN32)
S#define _LIBCPP_OBJECT_FORMAT_COFF  1
S#else
S#error Unknown object file format
N#endif
N
N#if defined(_LIBCPP_ABI_UNSTABLE) || _LIBCPP_ABI_VERSION >= 2
X#if 0L || 2 >= 2
N// Change short string representation so that string data starts at offset 0,
N// improving its alignment in some cases.
N#define _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT
N// Fix deque iterator type in order to support incomplete types.
N#define _LIBCPP_ABI_INCOMPLETE_TYPES_IN_DEQUE
N// Fix undefined behavior in how std::list stores its linked nodes.
N#define _LIBCPP_ABI_LIST_REMOVE_NODE_POINTER_UB
N// Fix undefined behavior in  how __tree stores its end and parent nodes.
N#define _LIBCPP_ABI_TREE_REMOVE_NODE_POINTER_UB
N// Fix undefined behavior in how __hash_table stores its pointer types.
N#define _LIBCPP_ABI_FIX_UNORDERED_NODE_POINTER_UB
N#define _LIBCPP_ABI_FORWARD_LIST_REMOVE_NODE_POINTER_UB
N#define _LIBCPP_ABI_FIX_UNORDERED_CONTAINER_SIZE_TYPE
N// Don't use a nullptr_t simulation type in C++03 instead using C++11 nullptr
N// provided under the alternate keyword __nullptr, which changes the mangling
N// of nullptr_t. This option is ABI incompatible with GCC in C++03 mode.
N#define _LIBCPP_ABI_ALWAYS_USE_CXX11_NULLPTR
N// Define the `pointer_safety` enum as a C++11 strongly typed enumeration
N// instead of as a class simulating an enum. If this option is enabled
N// `pointer_safety` and `get_pointer_safety()` will no longer be available
N// in C++03.
N#define _LIBCPP_ABI_POINTER_SAFETY_ENUM_TYPE
N// Define a key function for `bad_function_call` in the library, to centralize
N// its vtable and typeinfo to libc++ rather than having all other libraries
N// using that class define their own copies.
N#define _LIBCPP_ABI_BAD_FUNCTION_CALL_KEY_FUNCTION
N
N// Enable optimized version of __do_get_(un)signed which avoids redundant copies.
N#define _LIBCPP_ABI_OPTIMIZED_LOCALE_NUM_GET
N#elif _LIBCPP_ABI_VERSION == 1
S#if !defined(_LIBCPP_OBJECT_FORMAT_COFF)
S// Enable compiling copies of now inline methods into the dylib to support
S// applications compiled against older libraries. This is unnecessary with
S// COFF dllexport semantics, since dllexport forces a non-inline definition
S// of inline functions to be emitted anyway. Our own non-inline copy would
S// conflict with the dllexport-emitted copy, so we disable it.
S#define _LIBCPP_DEPRECATED_ABI_LEGACY_LIBRARY_DEFINITIONS_FOR_INLINE_FUNCTIONS
S#endif
S// Feature macros for disabling pre ABI v1 features. All of these options
S// are deprecated.
S#if defined(__FreeBSD__)
S#define _LIBCPP_DEPRECATED_ABI_DISABLE_PAIR_TRIVIAL_COPY_CTOR
S#endif
N#endif
N
N#ifdef _LIBCPP_TRIVIAL_PAIR_COPY_CTOR
S#error "_LIBCPP_TRIVIAL_PAIR_COPY_CTOR" is no longer supported. \
S       use _LIBCPP_DEPRECATED_ABI_DISABLE_PAIR_TRIVIAL_COPY_CTOR instead
X#error "_LIBCPP_TRIVIAL_PAIR_COPY_CTOR" is no longer supported.        use _LIBCPP_DEPRECATED_ABI_DISABLE_PAIR_TRIVIAL_COPY_CTOR instead
N#endif
N
N#define _LIBCPP_CONCAT1(_LIBCPP_X,_LIBCPP_Y) _LIBCPP_X##_LIBCPP_Y
N#define _LIBCPP_CONCAT(_LIBCPP_X,_LIBCPP_Y) _LIBCPP_CONCAT1(_LIBCPP_X,_LIBCPP_Y)
N
N#define _LIBCPP_NAMESPACE _LIBCPP_CONCAT(__,_LIBCPP_ABI_VERSION)
N
N#if __cplusplus < 201103L
X#if 201402L < 201103L
S#define _LIBCPP_CXX03_LANG
N#endif
N
N#ifndef __has_attribute
S#define __has_attribute(__x) 0
N#endif
N#ifndef __has_builtin
S#define __has_builtin(__x) 0
N#endif
N#ifndef __has_extension
S#define __has_extension(__x) 0
N#endif
N#ifndef __has_feature
S#define __has_feature(__x) 0
N#endif
N// '__is_identifier' returns '0' if '__x' is a reserved identifier provided by
N// the compiler and '1' otherwise.
N#ifndef __is_identifier
N#define __is_identifier(__x) 1
N#endif
N#ifndef __has_declspec_attribute
N#define __has_declspec_attribute(__x) 0
N#endif
N
N#define __has_keyword(__x) !(__is_identifier(__x))
N
N#ifdef __has_include
N#define __libcpp_has_include(__x) __has_include(__x)
N#else
S#define __libcpp_has_include(__x) 0
N#endif
N
N#if defined(__clang__)
X#if 0L
S#define _LIBCPP_COMPILER_CLANG
S# ifndef __apple_build_version__
S#   define _LIBCPP_CLANG_VER (__clang_major__ * 100 + __clang_minor__)
S# endif
S#elif defined(__GNUC__)
X#elif 0L
S#define _LIBCPP_COMPILER_GCC
S#elif defined(_MSC_VER)
X#elif 0L
S#define _LIBCPP_COMPILER_MSVC
S#elif defined(__IBMCPP__)
X#elif 0L
S#define _LIBCPP_COMPILER_IBM
N#elif defined(__TI_COMPILER_VERSION__)
X#elif 1L
N#define _LIBCPP_COMPILER_TI
N#endif
N
N#ifndef _LIBCPP_CLANG_VER
N#define _LIBCPP_CLANG_VER 0
N#endif
N
N// FIXME: ABI detection should be done via compiler builtin macros. This
N// is just a placeholder until Clang implements such macros. For now assume
N// that Windows compilers pretending to be MSVC++ target the Microsoft ABI,
N// and allow the user to explicitly specify the ABI to handle cases where this
N// heuristic falls short.
N#if defined(_LIBCPP_ABI_FORCE_ITANIUM) && defined(_LIBCPP_ABI_FORCE_MICROSOFT)
X#if 0L && 0L
S# error "Only one of _LIBCPP_ABI_FORCE_ITANIUM and _LIBCPP_ABI_FORCE_MICROSOFT can be defined"
S#elif defined(_LIBCPP_ABI_FORCE_ITANIUM)
X#elif 0L
S# define _LIBCPP_ABI_ITANIUM
S#elif defined(_LIBCPP_ABI_FORCE_MICROSOFT)
X#elif 0L
S# define _LIBCPP_ABI_MICROSOFT
N#else
N# if defined(_WIN32) && defined(_MSC_VER)
X# if 0L && 0L
S#  define _LIBCPP_ABI_MICROSOFT
N# else
N#  define _LIBCPP_ABI_ITANIUM
N# endif
N#endif
N
N// Need to detect which libc we're using if we're on Linux.
N#if defined(__linux__)
X#if 0L
S#include <features.h>
S#if !defined(__GLIBC_PREREQ)
S#define __GLIBC_PREREQ(a, b) 0
S#endif // !defined(__GLIBC_PREREQ)
N#endif // defined(__linux__)
N
N#ifdef __LITTLE_ENDIAN__
N#if __LITTLE_ENDIAN__
X#if 1
N#define _LIBCPP_LITTLE_ENDIAN
N#endif  // __LITTLE_ENDIAN__
N#endif  // __LITTLE_ENDIAN__
N
N#ifdef __BIG_ENDIAN__
S#if __BIG_ENDIAN__
S#define _LIBCPP_BIG_ENDIAN
S#endif  // __BIG_ENDIAN__
N#endif  // __BIG_ENDIAN__
N
N#ifdef __BYTE_ORDER__
S#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
S#define _LIBCPP_LITTLE_ENDIAN
S#elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
S#define _LIBCPP_BIG_ENDIAN
S#endif // __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
N#endif // __BYTE_ORDER__
N
N#ifdef __FreeBSD__
S# include <sys/endian.h>
S#  if _BYTE_ORDER == _LITTLE_ENDIAN
S#   define _LIBCPP_LITTLE_ENDIAN
S# else  // _BYTE_ORDER == _LITTLE_ENDIAN
S#   define _LIBCPP_BIG_ENDIAN
S# endif  // _BYTE_ORDER == _LITTLE_ENDIAN
S# ifndef __LONG_LONG_SUPPORTED
S#  define _LIBCPP_HAS_NO_LONG_LONG
S# endif  // __LONG_LONG_SUPPORTED
N#endif  // __FreeBSD__
N
N#ifdef __NetBSD__
S# include <sys/endian.h>
S#  if _BYTE_ORDER == _LITTLE_ENDIAN
S#   define _LIBCPP_LITTLE_ENDIAN
S# else  // _BYTE_ORDER == _LITTLE_ENDIAN
S#   define _LIBCPP_BIG_ENDIAN
S# endif  // _BYTE_ORDER == _LITTLE_ENDIAN
S# define _LIBCPP_HAS_QUICK_EXIT
N#endif  // __NetBSD__
N
N#if defined(_WIN32)
X#if 0L
S#  define _LIBCPP_WIN32API
S#  define _LIBCPP_LITTLE_ENDIAN
S#  define _LIBCPP_SHORT_WCHAR   1
S// Both MinGW and native MSVC provide a "MSVC"-like enviroment
S#  define _LIBCPP_MSVCRT_LIKE
S// If mingw not explicitly detected, assume using MS C runtime only if
S// a MS compatibility version is specified.
S#  if defined(_MSC_VER) && !defined(__MINGW32__)
S#    define _LIBCPP_MSVCRT // Using Microsoft's C Runtime library
S#  endif
S#  if (defined(_M_AMD64) || defined(__x86_64__)) || (defined(_M_ARM) || defined(__arm__))
S#    define _LIBCPP_HAS_BITSCAN64
S#  endif
S# if defined(_LIBCPP_MSVCRT)
S#   define _LIBCPP_HAS_QUICK_EXIT
S# endif
S
S// Some CRT APIs are unavailable to store apps
S#if defined(WINAPI_FAMILY)
S#include <winapifamily.h>
S#if !WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) &&                      \
S    (!defined(WINAPI_PARTITION_SYSTEM) ||                                      \
S     !WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_SYSTEM))
X#if !WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) &&                          (!defined(WINAPI_PARTITION_SYSTEM) ||                                           !WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_SYSTEM))
S#define _LIBCPP_WINDOWS_STORE_APP
S#endif
S#endif
N#endif // defined(_WIN32)
N
N#ifdef __sun__
S# include <sys/isa_defs.h>
S# ifdef _LITTLE_ENDIAN
S#   define _LIBCPP_LITTLE_ENDIAN
S# else
S#   define _LIBCPP_BIG_ENDIAN
S# endif
N#endif // __sun__
N
N#if defined(__CloudABI__)
X#if 0L
S  // Certain architectures provide arc4random(). Prefer using
S  // arc4random() over /dev/{u,}random to make it possible to obtain
S  // random data even when using sandboxing mechanisms such as chroots,
S  // Capsicum, etc.
S# define _LIBCPP_USING_ARC4_RANDOM
S#elif defined(__native_client__)
X#elif 0L
S  // NaCl's sandbox (which PNaCl also runs in) doesn't allow filesystem access,
S  // including accesses to the special files under /dev. C++11's
S  // std::random_device is instead exposed through a NaCl syscall.
S# define _LIBCPP_USING_NACL_RANDOM
S#elif defined(_LIBCPP_WIN32API)
X#elif 0L
S# define _LIBCPP_USING_WIN32_RANDOM
N#elif defined(_LIBCPP_COMPILER_TI)
X#elif 1L
N# define _LIBCPP_USING_MERSENNE_RANDOM
N#else
S# define _LIBCPP_USING_DEV_RANDOM
N#endif
N
N#if !defined(_LIBCPP_LITTLE_ENDIAN) && !defined(_LIBCPP_BIG_ENDIAN)
X#if !1L && !0L
S# include <endian.h>
S# if __BYTE_ORDER == __LITTLE_ENDIAN
S#  define _LIBCPP_LITTLE_ENDIAN
S# elif __BYTE_ORDER == __BIG_ENDIAN
S#  define _LIBCPP_BIG_ENDIAN
S# else  // __BYTE_ORDER == __BIG_ENDIAN
S#  error unable to determine endian
S# endif
N#endif  // !defined(_LIBCPP_LITTLE_ENDIAN) && !defined(_LIBCPP_BIG_ENDIAN)
N
N#if __has_attribute(__no_sanitize__) && !defined(_LIBCPP_COMPILER_GCC)
X#if 0 && !0L
S#define _LIBCPP_NO_CFI __attribute__((__no_sanitize__("cfi")))
N#else
N#define _LIBCPP_NO_CFI
N#endif
N
N#if defined(_LIBCPP_COMPILER_CLANG)
X#if 0L
S
S// _LIBCPP_ALTERNATE_STRING_LAYOUT is an old name for
S// _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT left here for backward compatibility.
S#if (defined(__APPLE__) && !defined(__i386__) && !defined(__x86_64__) &&       \
S     (!defined(__arm__) || __ARM_ARCH_7K__ >= 2)) ||                           \
S    defined(_LIBCPP_ALTERNATE_STRING_LAYOUT)
X#if (defined(__APPLE__) && !defined(__i386__) && !defined(__x86_64__) &&            (!defined(__arm__) || __ARM_ARCH_7K__ >= 2)) ||                               defined(_LIBCPP_ALTERNATE_STRING_LAYOUT)
S#define _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT
S#endif
S
S#if __has_feature(cxx_alignas)
S#  define _ALIGNAS_TYPE(x) alignas(x)
S#  define _ALIGNAS(x) alignas(x)
S#else
S#  define _ALIGNAS_TYPE(x) __attribute__((__aligned__(__alignof(x))))
S#  define _ALIGNAS(x) __attribute__((__aligned__(x)))
S#endif
S
S#if __cplusplus < 201103L
Stypedef __char16_t char16_t;
Stypedef __char32_t char32_t;
S#endif
S
S#if !(__has_feature(cxx_exceptions)) && !defined(_LIBCPP_NO_EXCEPTIONS)
S#define _LIBCPP_NO_EXCEPTIONS
S#endif
S
S#if !(__has_feature(cxx_rtti)) && !defined(_LIBCPP_NO_RTTI)
S#define _LIBCPP_NO_RTTI
S#endif
S
S#if !(__has_feature(cxx_strong_enums))
S#define _LIBCPP_HAS_NO_STRONG_ENUMS
S#endif
S
S#if !(__has_feature(cxx_decltype))
S#define _LIBCPP_HAS_NO_DECLTYPE
S#endif
S
S#if __has_feature(cxx_attributes)
S#  define _LIBCPP_NORETURN [[noreturn]]
S#else
S#  define _LIBCPP_NORETURN __attribute__ ((noreturn))
S#endif
S
S#if !(__has_feature(cxx_lambdas))
S#define _LIBCPP_HAS_NO_LAMBDAS
S#endif
S
S#if !(__has_feature(cxx_nullptr))
S# if (__has_extension(cxx_nullptr) || __has_keyword(__nullptr)) && defined(_LIBCPP_ABI_ALWAYS_USE_CXX11_NULLPTR)
S#   define nullptr __nullptr
S# else
S#   define _LIBCPP_HAS_NO_NULLPTR
S# endif
S#endif
S
S#if !(__has_feature(cxx_rvalue_references))
S#define _LIBCPP_HAS_NO_RVALUE_REFERENCES
S#endif
S
S#if !(__has_feature(cxx_auto_type))
S#define _LIBCPP_HAS_NO_AUTO_TYPE
S#endif
S
S#if !(__has_feature(cxx_variadic_templates))
S#define _LIBCPP_HAS_NO_VARIADICS
S#endif
S
S#if !(__has_feature(cxx_generalized_initializers))
S#define _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS
S#endif
S
S#if __has_feature(is_base_of)
S#  define _LIBCPP_HAS_IS_BASE_OF
S#endif
S
S#if __has_feature(is_final)
S#  define _LIBCPP_HAS_IS_FINAL
S#endif
S
S// Objective-C++ features (opt-in)
S#if __has_feature(objc_arc)
S#define _LIBCPP_HAS_OBJC_ARC
S#endif
S
S#if __has_feature(objc_arc_weak)
S#define _LIBCPP_HAS_OBJC_ARC_WEAK
S#endif
S
S#if !(__has_feature(cxx_constexpr))
S#define _LIBCPP_HAS_NO_CONSTEXPR
S#endif
S
S#if !(__has_feature(cxx_relaxed_constexpr))
S#define _LIBCPP_HAS_NO_CXX14_CONSTEXPR
S#endif
S
S#if !(__has_feature(cxx_variable_templates))
S#define _LIBCPP_HAS_NO_VARIABLE_TEMPLATES
S#endif
S
S#if __ISO_C_VISIBLE >= 2011 || __cplusplus >= 201103L
S#if defined(__FreeBSD__)
S#define _LIBCPP_HAS_QUICK_EXIT
S#define _LIBCPP_HAS_C11_FEATURES
S#elif defined(__Fuchsia__)
S#define _LIBCPP_HAS_QUICK_EXIT
S#define _LIBCPP_HAS_C11_FEATURES
S#elif defined(__linux__)
S#if !defined(_LIBCPP_HAS_MUSL_LIBC)
S#if __GLIBC_PREREQ(2, 15) || defined(__BIONIC__)
S#define _LIBCPP_HAS_QUICK_EXIT
S#endif
S#if __GLIBC_PREREQ(2, 17)
S#define _LIBCPP_HAS_C11_FEATURES
S#endif
S#else // defined(_LIBCPP_HAS_MUSL_LIBC)
S#define _LIBCPP_HAS_QUICK_EXIT
S#define _LIBCPP_HAS_C11_FEATURES
S#endif
S#endif // __linux__
S#endif
S
S#if !(__has_feature(cxx_noexcept))
S#define _LIBCPP_HAS_NO_NOEXCEPT
S#endif
S
S#if __has_feature(underlying_type)
S#  define _LIBCPP_UNDERLYING_TYPE(T) __underlying_type(T)
S#endif
S
S#if __has_feature(is_literal)
S#  define _LIBCPP_IS_LITERAL(T) __is_literal(T)
S#endif
S
S// Inline namespaces are available in Clang regardless of C++ dialect.
S#define _LIBCPP_BEGIN_NAMESPACE_STD namespace std {inline namespace _LIBCPP_NAMESPACE {
S#define _LIBCPP_END_NAMESPACE_STD  } }
S#define _VSTD std::_LIBCPP_NAMESPACE
S
Snamespace std {
S  inline namespace _LIBCPP_NAMESPACE {
S  }
S}
S
S#if !defined(_LIBCPP_HAS_NO_ASAN) && !__has_feature(address_sanitizer)
S#define _LIBCPP_HAS_NO_ASAN
S#endif
S
S// Allow for build-time disabling of unsigned integer sanitization
S#if !defined(_LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK) && __has_attribute(no_sanitize)
S#define _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK __attribute__((__no_sanitize__("unsigned-integer-overflow")))
S#endif 
S
S#elif defined(_LIBCPP_COMPILER_GCC)
X#elif 0L
S
S#define _ALIGNAS(x) __attribute__((__aligned__(x)))
S#define _ALIGNAS_TYPE(x) __attribute__((__aligned__(__alignof(x))))
S
S#define _LIBCPP_NORETURN __attribute__((noreturn))
S
S#if _GNUC_VER >= 407
S#define _LIBCPP_UNDERLYING_TYPE(T) __underlying_type(T)
S#define _LIBCPP_IS_LITERAL(T) __is_literal_type(T)
S#define _LIBCPP_HAS_IS_FINAL
S#endif
S
S#if defined(__GNUC__) && _GNUC_VER >= 403
S#  define _LIBCPP_HAS_IS_BASE_OF
S#endif
S
S#if !__EXCEPTIONS
S#define _LIBCPP_NO_EXCEPTIONS
S#endif
S
S// constexpr was added to GCC in 4.6.
S#if _GNUC_VER < 406
S#define _LIBCPP_HAS_NO_CONSTEXPR
S// Can only use constexpr in c++11 mode.
S#elif !defined(__GXX_EXPERIMENTAL_CXX0X__) && __cplusplus < 201103L
S#define _LIBCPP_HAS_NO_CONSTEXPR
S#endif
S
S// Determine if GCC supports relaxed constexpr
S#if !defined(__cpp_constexpr) || __cpp_constexpr < 201304L
S#define _LIBCPP_HAS_NO_CXX14_CONSTEXPR
S#endif
S
S// GCC 5 will support variable templates
S#if !defined(__cpp_variable_templates) || __cpp_variable_templates < 201304L
S#define _LIBCPP_HAS_NO_VARIABLE_TEMPLATES
S#endif
S
S#ifndef __GXX_EXPERIMENTAL_CXX0X__
S#define _LIBCPP_HAS_NO_DECLTYPE
S#define _LIBCPP_HAS_NO_NULLPTR
S#define _LIBCPP_HAS_NO_UNICODE_CHARS
S#define _LIBCPP_HAS_NO_VARIADICS
S#define _LIBCPP_HAS_NO_RVALUE_REFERENCES
S#define _LIBCPP_HAS_NO_STRONG_ENUMS
S#define _LIBCPP_HAS_NO_NOEXCEPT
S
S#else  // __GXX_EXPERIMENTAL_CXX0X__
S
S#if _GNUC_VER < 403
S#define _LIBCPP_HAS_NO_RVALUE_REFERENCES
S#endif
S
S
S#if _GNUC_VER < 404
S#define _LIBCPP_HAS_NO_DECLTYPE
S#define _LIBCPP_HAS_NO_UNICODE_CHARS
S#define _LIBCPP_HAS_NO_VARIADICS
S#define _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS
S#endif  // _GNUC_VER < 404
S
S#if _GNUC_VER < 406
S#define _LIBCPP_HAS_NO_NOEXCEPT
S#define _LIBCPP_HAS_NO_NULLPTR
S#endif
S
S#endif  // __GXX_EXPERIMENTAL_CXX0X__
S
S#define _LIBCPP_BEGIN_NAMESPACE_STD namespace std { inline namespace _LIBCPP_NAMESPACE {
S#define _LIBCPP_END_NAMESPACE_STD  } }
S#define _VSTD std::_LIBCPP_NAMESPACE
S
Snamespace std {
S  inline namespace _LIBCPP_NAMESPACE {
S  }
S}
S
S#if !defined(_LIBCPP_HAS_NO_ASAN) && !defined(__SANITIZE_ADDRESS__)
S#define _LIBCPP_HAS_NO_ASAN
S#endif
S
S#elif defined(_LIBCPP_COMPILER_MSVC)
X#elif 0L
S
S#define _LIBCPP_TOSTRING2(x) #x
S#define _LIBCPP_TOSTRING(x) _LIBCPP_TOSTRING2(x)
S#define _LIBCPP_WARNING(x) __pragma(message(__FILE__ "(" _LIBCPP_TOSTRING(__LINE__) ") : warning note: " x))
S
S#if _MSC_VER < 1900
S#error "MSVC versions prior to Visual Studio 2015 are not supported"
S#endif
S
S#define _LIBCPP_HAS_IS_BASE_OF
S#define _LIBCPP_HAS_NO_CONSTEXPR
S#define _LIBCPP_HAS_NO_CXX14_CONSTEXPR
S#define _LIBCPP_HAS_NO_VARIABLE_TEMPLATES
S#if _MSC_VER <= 1800
S#define _LIBCPP_HAS_NO_UNICODE_CHARS
S#endif
S#define _LIBCPP_HAS_NO_NOEXCEPT
S#define __alignof__ __alignof
S#define _LIBCPP_NORETURN __declspec(noreturn)
S#define _ALIGNAS(x) __declspec(align(x))
S#define _LIBCPP_HAS_NO_VARIADICS
S
S#define _LIBCPP_BEGIN_NAMESPACE_STD namespace std {
S#define _LIBCPP_END_NAMESPACE_STD  }
S#define _VSTD std
S
S#  define _LIBCPP_WEAK
Snamespace std {
S}
S
S#define _LIBCPP_HAS_NO_ASAN
S
S#elif defined(_LIBCPP_COMPILER_IBM)
X#elif 0L
S
S#define _ALIGNAS(x) __attribute__((__aligned__(x)))
S#define _ALIGNAS_TYPE(x) __attribute__((__aligned__(__alignof(x))))
S#define _ATTRIBUTE(x) __attribute__((x))
S#define _LIBCPP_NORETURN __attribute__((noreturn))
S
S#define _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS
S#define _LIBCPP_HAS_NO_NOEXCEPT
S#define _LIBCPP_HAS_NO_NULLPTR
S#define _LIBCPP_HAS_NO_UNICODE_CHARS
S#define _LIBCPP_HAS_IS_BASE_OF
S#define _LIBCPP_HAS_IS_FINAL
S#define _LIBCPP_HAS_NO_VARIABLE_TEMPLATES
S
S#if defined(_AIX)
S#define __MULTILOCALE_API
S#endif
S
S#define _LIBCPP_BEGIN_NAMESPACE_STD namespace std {inline namespace _LIBCPP_NAMESPACE {
S#define _LIBCPP_END_NAMESPACE_STD  } }
S#define _VSTD std::_LIBCPP_NAMESPACE
S
Snamespace std {
S  inline namespace _LIBCPP_NAMESPACE {
S  }
S}
S
S#define _LIBCPP_HAS_NO_ASAN
S
N#elif defined(_LIBCPP_COMPILER_TI)
X#elif 1L
N
N// Add a defined(__TARGET__) in the following check for each TARGET
N// that supports LIBCPP atomics
N#if defined(__TMS470__) || defined(__MSP430__)
X#if 1L || 0L
N#define _LIBCPP_TI_HAS_ATOMIC_HEADER
N#endif
N
N// __builtin_strlen can be trivially replaced, but with a hefty runtime cost
N#define __builtin_strlen strlen
N
N// TI targets do not support aligned operator new()
N#define _LIBCPP_HAS_NO_ALIGNED_ALLOCATION
N
N// Currently a dummy value. std::strerror will return "Unknown" for errors that
N// are out of the range of those we can print.
N#define ELAST 4095
N
N#if __has_feature(cxx_alignas)
X#if 1
N#  define _ALIGNAS_TYPE(x) alignas(x)
N#  define _ALIGNAS(x) alignas(x)
N#else
S#  define _ALIGNAS_TYPE(x) __attribute__((__aligned__(__alignof(x))))
S#  define _ALIGNAS(x) __attribute__((__aligned__(x)))
N#endif
N
N#if !(__has_feature(cxx_exceptions)) && !defined(_LIBCPP_NO_EXCEPTIONS)
X#if !(0) && !0L
N#define _LIBCPP_NO_EXCEPTIONS
N#endif
N
N#if !(__has_feature(cxx_rtti)) && !defined(_LIBCPP_NO_RTTI)
X#if !(1) && !0L
S#define _LIBCPP_NO_RTTI
N#endif
N
N#if !(__has_feature(cxx_strong_enums))
X#if !(1)
S#define _LIBCPP_HAS_NO_STRONG_ENUMS
N#endif
N
N#if !(__has_feature(cxx_decltype))
X#if !(1)
S#define _LIBCPP_HAS_NO_DECLTYPE
N#endif
N
N#if __has_feature(cxx_attributes)
X#if 1
N#  define _LIBCPP_NORETURN [[noreturn]]
N#else
S#  define _LIBCPP_NORETURN __attribute__ ((noreturn))
N#endif
N
N#if !(__has_feature(cxx_lambdas))
X#if !(1)
S#define _LIBCPP_HAS_NO_LAMBDAS
N#endif
N
N#if !(__has_feature(cxx_nullptr))
X#if !(1)
S# if (__has_extension(cxx_nullptr) || __has_keyword(__nullptr)) && defined(_LIBCPP_ABI_ALWAYS_USE_CXX11_NULLPTR)
S#   define nullptr __nullptr
S# else
S#   define _LIBCPP_HAS_NO_NULLPTR
S# endif
N#endif
N
N#if !(__has_feature(cxx_rvalue_references))
X#if !(1)
S#define _LIBCPP_HAS_NO_RVALUE_REFERENCES
N#endif
N
N#if !(__has_feature(cxx_auto_type))
X#if !(1)
S#define _LIBCPP_HAS_NO_AUTO_TYPE
N#endif
N
N#if !(__has_feature(cxx_variadic_templates))
X#if !(1)
S#define _LIBCPP_HAS_NO_VARIADICS
N#endif
N
N#if !(__has_feature(cxx_generalized_initializers))
X#if !(1)
S#define _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS
N#endif
N
N#if __has_feature(is_base_of)
X#if 1
N#  define _LIBCPP_HAS_IS_BASE_OF
N#endif
N
N#if __has_feature(is_final)
X#if 1
N#  define _LIBCPP_HAS_IS_FINAL
N#endif
N
N#if !(__has_feature(cxx_constexpr))
X#if !(1)
S#define _LIBCPP_HAS_NO_CONSTEXPR
N#endif
N
N#if !(__has_feature(cxx_relaxed_constexpr))
X#if !(1)
S#define _LIBCPP_HAS_NO_CXX14_CONSTEXPR
N#endif
N
N#if !(__has_feature(cxx_variable_templates))
X#if !(1)
S#define _LIBCPP_HAS_NO_VARIABLE_TEMPLATES
N#endif
N
N#if !(__has_feature(cxx_noexcept))
X#if !(1)
S#define _LIBCPP_HAS_NO_NOEXCEPT
N#endif
N
N#if __has_feature(underlying_type)
X#if 1
N#  define _LIBCPP_UNDERLYING_TYPE(T) __underlying_type(T)
N#endif
N
N#if __has_feature(is_literal)
X#if 0
S#  define _LIBCPP_IS_LITERAL(T) __is_literal(T)
N#else
N// EDG supports __is_literal_type, which is analagous to __is_literal
N#  define _LIBCPP_IS_LITERAL(T) __is_literal_type(T)
N#endif
N
N// TI compilers using libc++ always accept inline namespaces
N#define _LIBCPP_BEGIN_NAMESPACE_STD namespace std { inline namespace _LIBCPP_NAMESPACE {
N#define _LIBCPP_END_NAMESPACE_STD  } }
N#define _VSTD std::_LIBCPP_NAMESPACE
N
Nnamespace std {
N  inline namespace _LIBCPP_NAMESPACE {
X  inline namespace __2 {
N  }
N}
N
N#if !defined(_LIBCPP_HAS_NO_ASAN) && !__has_feature(address_sanitizer)
X#if !0L && !0
N#define _LIBCPP_HAS_NO_ASAN
N#endif
N
N// Allow for build-time disabling of unsigned integer sanitization
N#if !defined(_LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK) && __has_attribute(no_sanitize)
X#if !0L && 0
S#define _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK __attribute__((__no_sanitize__("unsigned-integer-overflow")))
N#endif 
N
N// The TI compiler is strict about the difference between extern "C" and
N// extern "C++" functions. One cannot be conflated with the other, even if
N// the types are otherwise the same.
N#define _LIBCPP_C_AND_CPP_FUNCS_ARE_DISTINCT
N
N#endif // _LIBCPP_COMPILER_[CLANG|GCC|MSVC|IBM|TI]
N
N#if defined(_LIBCPP_OBJECT_FORMAT_COFF)
X#if 0L
S#if defined(_LIBCPP_DISABLE_VISIBILITY_ANNOTATIONS)
S# define _LIBCPP_DLL_VIS
S# define _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS
S# define _LIBCPP_CLASS_TEMPLATE_INSTANTIATION_VIS
S# define _LIBCPP_OVERRIDABLE_FUNC_VIS
S#elif defined(_LIBCPP_BUILDING_LIBRARY)
S# define _LIBCPP_DLL_VIS __declspec(dllexport)
S# define _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS
S# define _LIBCPP_CLASS_TEMPLATE_INSTANTIATION_VIS _LIBCPP_DLL_VIS
S# define _LIBCPP_OVERRIDABLE_FUNC_VIS _LIBCPP_DLL_VIS
S#else
S# define _LIBCPP_DLL_VIS __declspec(dllimport)
S# define _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS _LIBCPP_DLL_VIS
S# define _LIBCPP_CLASS_TEMPLATE_INSTANTIATION_VIS
S# define _LIBCPP_OVERRIDABLE_FUNC_VIS
S#endif
S
S#define _LIBCPP_TYPE_VIS            _LIBCPP_DLL_VIS
S#define _LIBCPP_FUNC_VIS            _LIBCPP_DLL_VIS
S#define _LIBCPP_EXTERN_VIS          _LIBCPP_DLL_VIS
S#define _LIBCPP_EXCEPTION_ABI       _LIBCPP_DLL_VIS
S#define _LIBCPP_HIDDEN
S#define _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
S#define _LIBCPP_TEMPLATE_VIS
S#define _LIBCPP_ENUM_VIS
S
S#if defined(_LIBCPP_COMPILER_MSVC)
S# define _LIBCPP_INLINE_VISIBILITY __forceinline
S# define _LIBCPP_ALWAYS_INLINE     __forceinline
S# define _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY __forceinline
S#else
S# define _LIBCPP_INLINE_VISIBILITY __attribute__ ((__always_inline__))
S# define _LIBCPP_ALWAYS_INLINE     __attribute__ ((__always_inline__))
S# define _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY __attribute__ ((__always_inline__))
S#endif
N#endif // defined(_LIBCPP_OBJECT_FORMAT_COFF)
N
N#ifndef _LIBCPP_HIDDEN
N#if !defined(_LIBCPP_DISABLE_VISIBILITY_ANNOTATIONS)
X#if !1L
S#define _LIBCPP_HIDDEN __attribute__ ((__visibility__("hidden")))
N#else
N#define _LIBCPP_HIDDEN
N#endif
N#endif
N
N#ifndef _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
N#if !defined(_LIBCPP_DISABLE_VISIBILITY_ANNOTATIONS)
X#if !1L
S// The inline should be removed once PR32114 is resolved
S#define _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS inline _LIBCPP_HIDDEN
N#else
N#define _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
N#endif
N#endif
N
N#ifndef _LIBCPP_FUNC_VIS
N#if !defined(_LIBCPP_DISABLE_VISIBILITY_ANNOTATIONS)
X#if !1L
S#define _LIBCPP_FUNC_VIS __attribute__ ((__visibility__("default")))
N#else
N#define _LIBCPP_FUNC_VIS
N#endif
N#endif
N
N#ifndef _LIBCPP_TYPE_VIS
N#  if !defined(_LIBCPP_DISABLE_VISIBILITY_ANNOTATIONS)
X#  if !1L
S#    define _LIBCPP_TYPE_VIS __attribute__ ((__visibility__("default")))
N#  else
N#    define _LIBCPP_TYPE_VIS
N#  endif
N#endif
N
N#ifndef _LIBCPP_TEMPLATE_VIS
N#  if !defined(_LIBCPP_DISABLE_VISIBILITY_ANNOTATIONS)
X#  if !1L
S#    if __has_attribute(__type_visibility__)
S#      define _LIBCPP_TEMPLATE_VIS __attribute__ ((__type_visibility__("default")))
S#    else
S#      define _LIBCPP_TEMPLATE_VIS __attribute__ ((__visibility__("default")))
S#    endif
N#  else
N#    define _LIBCPP_TEMPLATE_VIS
N#  endif
N#endif
N
N#ifndef _LIBCPP_EXTERN_VIS
N# define _LIBCPP_EXTERN_VIS
N#endif
N
N#ifndef _LIBCPP_OVERRIDABLE_FUNC_VIS
N# define _LIBCPP_OVERRIDABLE_FUNC_VIS _LIBCPP_FUNC_VIS
N#endif
N
N#ifndef _LIBCPP_EXCEPTION_ABI
N#if !defined(_LIBCPP_DISABLE_VISIBILITY_ANNOTATIONS)
X#if !1L
S#define _LIBCPP_EXCEPTION_ABI __attribute__ ((__visibility__("default")))
N#else
N#define _LIBCPP_EXCEPTION_ABI
N#endif
N#endif
N
N#ifndef _LIBCPP_ENUM_VIS
N#  if !defined(_LIBCPP_DISABLE_VISIBILITY_ANNOTATIONS) && __has_attribute(__type_visibility__)
X#  if !1L && 0
S#    define _LIBCPP_ENUM_VIS __attribute__ ((__type_visibility__("default")))
N#  else
N#    define _LIBCPP_ENUM_VIS
N#  endif
N#endif
N
N#ifndef _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS
N#  if !defined(_LIBCPP_DISABLE_VISIBILITY_ANNOTATIONS) && __has_attribute(__type_visibility__)
X#  if !1L && 0
S#    define _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __attribute__ ((__visibility__("default")))
N#  else
N#    define _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS
N#  endif
N#endif
N
N#ifndef _LIBCPP_CLASS_TEMPLATE_INSTANTIATION_VIS
N#  define _LIBCPP_CLASS_TEMPLATE_INSTANTIATION_VIS
N#endif
N
N#ifndef _LIBCPP_INLINE_VISIBILITY
N#if !defined(_LIBCPP_DISABLE_VISIBILITY_ANNOTATIONS)
X#if !1L
S#define _LIBCPP_INLINE_VISIBILITY __attribute__ ((__visibility__("hidden"), __always_inline__))
N#else
N#define _LIBCPP_INLINE_VISIBILITY __attribute__ ((__always_inline__))
N#endif
N#endif
N
N#ifndef _LIBCPP_ALWAYS_INLINE
N#if !defined(_LIBCPP_DISABLE_VISIBILITY_ANNOTATIONS)
X#if !1L
S#define _LIBCPP_ALWAYS_INLINE  __attribute__ ((__visibility__("hidden"), __always_inline__))
N#else
N#define _LIBCPP_ALWAYS_INLINE  __attribute__ ((__always_inline__))
N#endif
N#endif
N
N#ifndef _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY
N# if !defined(_LIBCPP_DISABLE_VISIBILITY_ANNOTATIONS)
X# if !1L
S#  define _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY __attribute__((__visibility__("default"), __always_inline__))
N# else
N#  define _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY __attribute__((__always_inline__))
N# endif
N#endif
N
N#ifndef _LIBCPP_PREFERRED_OVERLOAD
N#  if __has_attribute(__enable_if__)
X#  if 0
S#    define _LIBCPP_PREFERRED_OVERLOAD __attribute__ ((__enable_if__(true, "")))
N#  endif
N#endif
N
N#ifndef _LIBCPP_HAS_NO_NOEXCEPT
N#  define _NOEXCEPT noexcept
N#  define _NOEXCEPT_(x) noexcept(x)
N#else
S#  define _NOEXCEPT throw()
S#  define _NOEXCEPT_(x)
N#endif
N
N#if defined(_LIBCPP_DEBUG_USE_EXCEPTIONS)
X#if 0L
S# if !defined(_LIBCPP_DEBUG)
S#   error cannot use _LIBCPP_DEBUG_USE_EXCEPTIONS unless _LIBCPP_DEBUG is defined
S# endif
S# define _NOEXCEPT_DEBUG noexcept(false)
S# define _NOEXCEPT_DEBUG_(x) noexcept(false)
N#else
N# define _NOEXCEPT_DEBUG _NOEXCEPT
N# define _NOEXCEPT_DEBUG_(x) _NOEXCEPT_(x)
N#endif
N
N#ifdef _LIBCPP_HAS_NO_UNICODE_CHARS
Stypedef unsigned short char16_t;
Stypedef unsigned int   char32_t;
N#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS
N
N#ifndef __SIZEOF_INT128__
N#define _LIBCPP_HAS_NO_INT128
N#endif
N
N#ifdef _LIBCPP_CXX03_LANG
S# if __has_extension(c_static_assert)
S#   define static_assert(__b, __m) _Static_assert(__b, __m)
S# else
Sextern "C++" {
Stemplate <bool> struct __static_assert_test;
Stemplate <> struct __static_assert_test<true> {};
Stemplate <unsigned> struct __static_assert_check {};
S}
S#define static_assert(__b, __m) \
S    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
S    _LIBCPP_CONCAT(__t, __LINE__)
X#define static_assert(__b, __m)     typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)>     _LIBCPP_CONCAT(__t, __LINE__)
S# endif // __has_extension(c_static_assert)
N#endif  // _LIBCPP_CXX03_LANG
N
N#ifdef _LIBCPP_HAS_NO_DECLTYPE
S// GCC 4.6 provides __decltype in all standard modes.
S#if __has_keyword(__decltype) || _LIBCPP_CLANG_VER >= 304 || _GNUC_VER >= 406
S#  define decltype(__x) __decltype(__x)
S#else
S#  define decltype(__x) __typeof__(__x)
S#endif
N#endif
N
N#ifdef _LIBCPP_HAS_NO_CONSTEXPR
S#define _LIBCPP_CONSTEXPR
N#else
N#define _LIBCPP_CONSTEXPR constexpr
N#endif
N
N#ifdef _LIBCPP_CXX03_LANG
S#define _LIBCPP_DEFAULT {}
N#else
N#define _LIBCPP_DEFAULT = default;
N#endif
N
N#ifdef _LIBCPP_CXX03_LANG
S#define _LIBCPP_EQUAL_DELETE
N#else
N#define _LIBCPP_EQUAL_DELETE = delete
N#endif
N
N#ifdef __GNUC__
S#define _NOALIAS __attribute__((__malloc__))
N#else
N#define _NOALIAS
N#endif
N
N#if __has_feature(cxx_explicit_conversions) || defined(__IBMCPP__) || \
N    (!defined(_LIBCPP_CXX03_LANG) && defined(__GNUC__)) // All supported GCC versions
X#if 1 || 0L ||     (!0L && 0L) 
N#   define _LIBCPP_EXPLICIT explicit
N#else
S#   define _LIBCPP_EXPLICIT
N#endif
N
N#if !__has_builtin(__builtin_operator_new) || !__has_builtin(__builtin_operator_delete)
X#if !0 || !0
N#   define _LIBCPP_HAS_NO_BUILTIN_OPERATOR_NEW_DELETE
N#endif
N
N#ifdef _LIBCPP_HAS_NO_STRONG_ENUMS
S#define _LIBCPP_DECLARE_STRONG_ENUM(x) struct _LIBCPP_TYPE_VIS x { enum __lx
S#define _LIBCPP_DECLARE_STRONG_ENUM_EPILOG(x) \
S    __lx __v_; \
S    _LIBCPP_ALWAYS_INLINE x(__lx __v) : __v_(__v) {} \
S    _LIBCPP_ALWAYS_INLINE explicit x(int __v) : __v_(static_cast<__lx>(__v)) {} \
S    _LIBCPP_ALWAYS_INLINE operator int() const {return __v_;} \
S    };
X#define _LIBCPP_DECLARE_STRONG_ENUM_EPILOG(x)     __lx __v_;     _LIBCPP_ALWAYS_INLINE x(__lx __v) : __v_(__v) {}     _LIBCPP_ALWAYS_INLINE explicit x(int __v) : __v_(static_cast<__lx>(__v)) {}     _LIBCPP_ALWAYS_INLINE operator int() const {return __v_;}     };
N#else  // _LIBCPP_HAS_NO_STRONG_ENUMS
N#define _LIBCPP_DECLARE_STRONG_ENUM(x) enum class _LIBCPP_ENUM_VIS x
N#define _LIBCPP_DECLARE_STRONG_ENUM_EPILOG(x)
N#endif  // _LIBCPP_HAS_NO_STRONG_ENUMS
N
N#ifdef _LIBCPP_DEBUG
S#   if _LIBCPP_DEBUG == 0
S#       define _LIBCPP_DEBUG_LEVEL 1
S#   elif _LIBCPP_DEBUG == 1
S#       define _LIBCPP_DEBUG_LEVEL 2
S#   else
S#       error Supported values for _LIBCPP_DEBUG are 0 and 1
S#   endif
S# if !defined(_LIBCPP_BUILDING_LIBRARY)
S#   define _LIBCPP_EXTERN_TEMPLATE(...)
S# endif
N#endif
N
N#ifdef _LIBCPP_DISABLE_EXTERN_TEMPLATE
S#define _LIBCPP_EXTERN_TEMPLATE(...)
S#define _LIBCPP_EXTERN_TEMPLATE2(...)
N#endif
N
N#ifndef _LIBCPP_EXTERN_TEMPLATE
N#define _LIBCPP_EXTERN_TEMPLATE(...) extern template __VA_ARGS__;
N#endif
N
N#ifndef _LIBCPP_EXTERN_TEMPLATE2
N#define _LIBCPP_EXTERN_TEMPLATE2(...) extern template __VA_ARGS__;
N#endif
N
N#if defined(__APPLE__) && defined(__LP64__) && !defined(__x86_64__)
X#if 0L && 0L && !0L
S#define _LIBCPP_NONUNIQUE_RTTI_BIT (1ULL << 63)
N#endif
N
N#if defined(__APPLE__) || defined(__FreeBSD__) || defined(_LIBCPP_MSVCRT) ||   \
N    defined(__sun__) || defined(__NetBSD__) || defined(__CloudABI__) ||        \
N    defined(__TI_COMPILER_VERSION__)
X#if 0L || 0L || 0L ||       0L || 0L || 0L ||            1L
N#define _LIBCPP_LOCALE__L_EXTENSIONS 1
N#endif
N
N#if defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))
X#if 0L || (0L && 0L)
S// Most unix variants have catopen.  These are the specific ones that don't.
S#if !defined(__BIONIC__) && !defined(_NEWLIB_VERSION)
S#define _LIBCPP_HAS_CATOPEN 1
S#endif
N#endif
N
N#ifdef __FreeBSD__
S#define _DECLARE_C99_LDBL_MATH 1
N#endif
N
N#if defined(__APPLE__)
X#if 0L
S# if !defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && \
S     defined(__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__)
X# if !defined(__MAC_OS_X_VERSION_MIN_REQUIRED) &&      defined(__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__)
S#   define __MAC_OS_X_VERSION_MIN_REQUIRED __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__
S# endif
S# if defined(__MAC_OS_X_VERSION_MIN_REQUIRED)
S#   if __MAC_OS_X_VERSION_MIN_REQUIRED < 1060
S#     define _LIBCPP_HAS_NO_ALIGNED_ALLOCATION
S#   endif
S# endif
N#endif // defined(__APPLE__)
N
N#if defined(__APPLE__) || defined(__FreeBSD__)
X#if 0L || 0L
S#define _LIBCPP_HAS_DEFAULTRUNELOCALE
N#endif
N
N#if defined(__APPLE__) || defined(__FreeBSD__) || defined(__sun__)
X#if 0L || 0L || 0L
S#define _LIBCPP_WCTYPE_IS_MASK
N#endif
N
N#ifndef _LIBCPP_STD_VER
N#  if  __cplusplus <= 201103L
X#  if  201402L <= 201103L
S#    define _LIBCPP_STD_VER 11
N#  elif __cplusplus <= 201402L
X#  elif 201402L <= 201402L
N#    define _LIBCPP_STD_VER 14
N#  elif __cplusplus <= 201703L
S#    define _LIBCPP_STD_VER 17
S#  else
S#    define _LIBCPP_STD_VER 18  // current year, or date of c++2a ratification
N#  endif
N#endif  // _LIBCPP_STD_VER
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
N#define _LIBCPP_DEPRECATED [[deprecated]]
N#else
S#define _LIBCPP_DEPRECATED
N#endif
N
N#if _LIBCPP_STD_VER <= 11
X#if 14 <= 11
S#define _LIBCPP_EXPLICIT_AFTER_CXX11
S#define _LIBCPP_DEPRECATED_AFTER_CXX11
N#else
N#define _LIBCPP_EXPLICIT_AFTER_CXX11 explicit
N#define _LIBCPP_DEPRECATED_AFTER_CXX11 [[deprecated]]
N#endif
N
N#if _LIBCPP_STD_VER > 11 && !defined(_LIBCPP_HAS_NO_CXX14_CONSTEXPR)
X#if 14 > 11 && !0L
N#define _LIBCPP_CONSTEXPR_AFTER_CXX11 constexpr
N#else
S#define _LIBCPP_CONSTEXPR_AFTER_CXX11
N#endif
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_CXX14_CONSTEXPR)
X#if 14 > 14 && !0L
S#define _LIBCPP_CONSTEXPR_AFTER_CXX14 constexpr
N#else
N#define _LIBCPP_CONSTEXPR_AFTER_CXX14
N#endif
N
N// FIXME: Remove all usages of this macro once compilers catch up.
N#if !defined(__cpp_inline_variables) || (__cpp_inline_variables < 201606L)
X#if !0L || (__cpp_inline_variables < 201606L)
N# define _LIBCPP_HAS_NO_INLINE_VARIABLES
N#endif
N
N#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES
S#  define _LIBCPP_EXPLICIT_MOVE(x) _VSTD::move(x)
N#else
N#  define _LIBCPP_EXPLICIT_MOVE(x) (x)
N#endif
N
N#ifndef _LIBCPP_HAS_NO_ASAN
S_LIBCPP_FUNC_VIS extern "C" void __sanitizer_annotate_contiguous_container(
S  const void *, const void *, const void *, const void *);
N#endif
N
N// Try to find out if RTTI is disabled.
N// g++ and cl.exe have RTTI on by default and define a macro when it is.
N// g++ only defines the macro in 4.3.2 and onwards.
N#if !defined(_LIBCPP_NO_RTTI)
X#if !0L
N#  if defined(__GNUC__) && ((__GNUC__ >= 5) || (__GNUC__ == 4 && \
N   (__GNUC_MINOR__ >= 3 || __GNUC_PATCHLEVEL__ >= 2))) && !defined(__GXX_RTTI)
X#  if 0L && ((__GNUC__ >= 5) || (__GNUC__ == 4 &&    (__GNUC_MINOR__ >= 3 || __GNUC_PATCHLEVEL__ >= 2))) && !1L
S#    define _LIBCPP_NO_RTTI
S#  elif defined(_LIBCPP_COMPILER_MSVC) && !defined(_CPPRTTI)
X#  elif 0L && !0L
S#    define _LIBCPP_NO_RTTI
N#  endif
N#endif
N
N#ifndef _LIBCPP_WEAK
N#  define _LIBCPP_WEAK __attribute__((__weak__))
N#endif
N
N// Thread API
N#if !defined(_LIBCPP_HAS_NO_THREADS) && \
N    !defined(_LIBCPP_HAS_THREAD_API_PTHREAD) && \
N    !defined(_LIBCPP_HAS_THREAD_API_WIN32) && \
N    !defined(_LIBCPP_HAS_THREAD_API_EXTERNAL)
X#if !1L &&     !0L &&     !0L &&     !0L
S# if defined(__FreeBSD__) || \
S    defined(__Fuchsia__) || \
S    defined(__NetBSD__) || \
S    defined(__linux__) || \
S    defined(__APPLE__) || \
S    defined(__CloudABI__) || \
S    defined(__sun__) || \
S    (defined(__MINGW32__) && __libcpp_has_include(<pthread.h>))
X# if defined(__FreeBSD__) ||     defined(__Fuchsia__) ||     defined(__NetBSD__) ||     defined(__linux__) ||     defined(__APPLE__) ||     defined(__CloudABI__) ||     defined(__sun__) ||     (defined(__MINGW32__) && __libcpp_has_include(<pthread.h>))
S#   define _LIBCPP_HAS_THREAD_API_PTHREAD
S# elif defined(_LIBCPP_WIN32API)
S#  define _LIBCPP_HAS_THREAD_API_WIN32
S# else
S#  error "No thread API"
S# endif // _LIBCPP_HAS_THREAD_API
N#endif // _LIBCPP_HAS_NO_THREADS
N
N#if defined(_LIBCPP_HAS_NO_THREADS) && defined(_LIBCPP_HAS_THREAD_API_PTHREAD)
X#if 1L && 0L
S#  error _LIBCPP_HAS_THREAD_API_PTHREAD may only be defined when \
S         _LIBCPP_HAS_NO_THREADS is not defined.
X#  error _LIBCPP_HAS_THREAD_API_PTHREAD may only be defined when          _LIBCPP_HAS_NO_THREADS is not defined.
N#endif
N
N#if defined(_LIBCPP_HAS_NO_THREADS) && defined(_LIBCPP_HAS_THREAD_API_EXTERNAL)
X#if 1L && 0L
S#  error _LIBCPP_HAS_THREAD_API_EXTERNAL may not be defined when \
S         _LIBCPP_HAS_NO_THREADS is defined.
X#  error _LIBCPP_HAS_THREAD_API_EXTERNAL may not be defined when          _LIBCPP_HAS_NO_THREADS is defined.
N#endif
N
N#if defined(_LIBCPP_HAS_NO_MONOTONIC_CLOCK) && !defined(_LIBCPP_HAS_NO_THREADS)
X#if 0L && !1L
S#  error _LIBCPP_HAS_NO_MONOTONIC_CLOCK may only be defined when \
S         _LIBCPP_HAS_NO_THREADS is defined.
X#  error _LIBCPP_HAS_NO_MONOTONIC_CLOCK may only be defined when          _LIBCPP_HAS_NO_THREADS is defined.
N#endif
N
N// Systems that use capability-based security (FreeBSD with Capsicum,
N// Nuxi CloudABI) may only provide local filesystem access (using *at()).
N// Functions like open(), rename(), unlink() and stat() should not be
N// used, as they attempt to access the global filesystem namespace.
N#ifdef __CloudABI__
S#define _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE
N#endif
N
N// CloudABI is intended for running networked services. Processes do not
N// have standard input and output channels.
N#ifdef __CloudABI__
S#define _LIBCPP_HAS_NO_STDIN
S#define _LIBCPP_HAS_NO_STDOUT
N#endif
N
N#if defined(__BIONIC__) || defined(__CloudABI__) ||                            \
N    defined(__Fuchsia__) || defined(_LIBCPP_HAS_MUSL_LIBC)
X#if 0L || 0L ||                                0L || 0L
S#define _LIBCPP_PROVIDES_DEFAULT_RUNE_TABLE
N#endif
N
N// Thread-unsafe functions such as strtok() and localtime()
N// are not available.
N#ifdef __CloudABI__
S#define _LIBCPP_HAS_NO_THREAD_UNSAFE_C_FUNCTIONS
N#endif
N
N#if __has_feature(cxx_atomic) || __has_extension(c_atomic) || __has_keyword(_Atomic)
X#if 0 || 0 || !(1)
S#define _LIBCPP_HAS_C_ATOMIC_IMP
N#elif _GNUC_VER > 407 || defined(__TI_COMPILER_VERSION__)
X#elif 0 > 407 || 1L
N#define _LIBCPP_HAS_GCC_ATOMIC_IMP
N#endif
N
N// TODO: Remove "&& !defined(__TI_COMPILER_VERSION__) when we enable threads.
N#if (!defined(_LIBCPP_HAS_C_ATOMIC_IMP) && !defined(_LIBCPP_HAS_GCC_ATOMIC_IMP)) \
N     || defined(_LIBCPP_HAS_NO_THREADS) && !defined(_LIBCPP_TI_HAS_ATOMIC_HEADER)
X#if (!0L && !1L)      || 1L && !1L
S#define _LIBCPP_HAS_NO_ATOMIC_HEADER
N#endif
N
N#ifndef _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK
N#define _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK
N#endif
N
N#if defined(_LIBCPP_ENABLE_THREAD_SAFETY_ANNOTATIONS)
X#if 0L
S#if defined(__clang__) && __has_attribute(acquire_capability)
S// Work around the attribute handling in clang.  When both __declspec and
S// __attribute__ are present, the processing goes awry preventing the definition
S// of the types.
S#if !defined(_LIBCPP_OBJECT_FORMAT_COFF)
S#define _LIBCPP_HAS_THREAD_SAFETY_ANNOTATIONS
S#endif
S#endif
N#endif
N
N#if __has_attribute(require_constant_initialization)
X#if 0
S#define _LIBCPP_SAFE_STATIC __attribute__((__require_constant_initialization__))
N#else
N#define _LIBCPP_SAFE_STATIC
N#endif
N
N#if !__has_builtin(__builtin_addressof) && _GNUC_VER < 700  && \
N    !defined(_LIBCPP_COMPILER_TI)
X#if !0 && 0 < 700  &&     !1L
S# define _LIBCPP_HAS_NO_BUILTIN_ADDRESSOF
N#endif
N
N#if !defined(_LIBCPP_HAS_NO_OFF_T_FUNCTIONS)
X#if !0L
N#if defined(_LIBCPP_MSVCRT) || defined(_NEWLIB_VERSION) || \
N    defined(_LIBCPP_COMPILER_TI)
X#if 0L || 0L ||     1L
N#define _LIBCPP_HAS_NO_OFF_T_FUNCTIONS
N#endif
N#endif
N
N#if __has_attribute(diagnose_if) && !defined(_LIBCPP_DISABLE_ADDITIONAL_DIAGNOSTICS)
X#if 0 && !0L
S# define _LIBCPP_DIAGNOSE_WARNING(...) \
S    __attribute__((diagnose_if(__VA_ARGS__, "warning")))
X# define _LIBCPP_DIAGNOSE_WARNING(...)     __attribute__((diagnose_if(__VA_ARGS__, "warning")))
S# define _LIBCPP_DIAGNOSE_ERROR(...) \
S    __attribute__((diagnose_if(__VA_ARGS__, "error")))
X# define _LIBCPP_DIAGNOSE_ERROR(...)     __attribute__((diagnose_if(__VA_ARGS__, "error")))
N#else
N# define _LIBCPP_DIAGNOSE_WARNING(...)
N# define _LIBCPP_DIAGNOSE_ERROR(...)
N#endif
N
N#if __has_attribute(fallthough) || _GNUC_VER >= 700
X#if 0 || 0 >= 700
S// Use a function like macro to imply that it must be followed by a semicolon
S#define _LIBCPP_FALLTHROUGH() __attribute__((__fallthrough__))
N#else
N#define _LIBCPP_FALLTHROUGH() ((void)0)
N#endif
N
N#if defined(_LIBCPP_ABI_MICROSOFT) && \
N   (defined(_LIBCPP_COMPILER_MSVC) || __has_declspec_attribute(empty_bases))
X#if 0L &&    (0L || 0)
S# define _LIBCPP_DECLSPEC_EMPTY_BASES __declspec(empty_bases)
N#else
N# define _LIBCPP_DECLSPEC_EMPTY_BASES
N#endif
N
N#if defined(_LIBCPP_ENABLE_CXX17_REMOVED_FEATURES)
X#if 0L
S# define _LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR
S# define _LIBCPP_ENABLE_CXX17_REMOVED_UNEXPECTED_FUNCTIONS
S# define _LIBCPP_ENABLE_CXX17_REMOVED_RANDOM_SHUFFLE
S# define _LIBCPP_ENABLE_CXX17_REMOVED_BINDERS
N#endif // _LIBCPP_ENABLE_CXX17_REMOVED_FEATURES
N
N#if !defined(__cpp_deduction_guides) || __cpp_deduction_guides < 201611
X#if !0L || __cpp_deduction_guides < 201611
N# define _LIBCPP_HAS_NO_DEDUCTION_GUIDES
N#endif
N
N#if !__has_keyword(__is_aggregate) && (_GNUC_VER_NEW < 7001)
X#if ! !(1) && (0 < 7001)
N# define _LIBCPP_HAS_NO_IS_AGGREGATE
N#endif
N
N#if !defined(__cpp_coroutines) || __cpp_coroutines < 201703L
X#if !0L || __cpp_coroutines < 201703L
N# define _LIBCPP_HAS_NO_COROUTINES
N#endif
N
N// Decide whether to use availability macros.
N#if !defined(_LIBCPP_BUILDING_LIBRARY) &&                                      \
N    !defined(_LIBCPP_DISABLE_AVAILABILITY) &&                                  \
N    __has_feature(attribute_availability_with_strict) &&                       \
N    __has_feature(attribute_availability_in_templates)
X#if !0L &&                                          !0L &&                                      0 &&                           0
S#ifdef __APPLE__
S#define _LIBCPP_USE_AVAILABILITY_APPLE
S#endif
N#endif
N
N// Define availability macros.
N#if defined(_LIBCPP_USE_AVAILABILITY_APPLE)
X#if 0L
S#define _LIBCPP_AVAILABILITY_SHARED_MUTEX                                      \
S  __attribute__((availability(macosx,strict,introduced=10.12)))                \
S  __attribute__((availability(ios,strict,introduced=10.0)))                    \
S  __attribute__((availability(tvos,strict,introduced=10.0)))                   \
S  __attribute__((availability(watchos,strict,introduced=3.0)))
X#define _LIBCPP_AVAILABILITY_SHARED_MUTEX                                        __attribute__((availability(macosx,strict,introduced=10.12)))                  __attribute__((availability(ios,strict,introduced=10.0)))                      __attribute__((availability(tvos,strict,introduced=10.0)))                     __attribute__((availability(watchos,strict,introduced=3.0)))
S#define _LIBCPP_AVAILABILITY_BAD_OPTIONAL_ACCESS __attribute__((unavailable))
S#define _LIBCPP_AVAILABILITY_BAD_ARRAY_LENGTH __attribute__((unavailable))
S#define _LIBCPP_AVAILABILITY_BAD_ANY_CAST __attribute__((unavailable))
S#define _LIBCPP_AVAILABILITY_UNCAUGHT_EXCEPTIONS                               \
S  __attribute__((availability(macosx,strict,introduced=10.12)))                \
S  __attribute__((availability(ios,strict,introduced=10.0)))                    \
S  __attribute__((availability(tvos,strict,introduced=10.0)))                   \
S  __attribute__((availability(watchos,strict,introduced=3.0)))
X#define _LIBCPP_AVAILABILITY_UNCAUGHT_EXCEPTIONS                                 __attribute__((availability(macosx,strict,introduced=10.12)))                  __attribute__((availability(ios,strict,introduced=10.0)))                      __attribute__((availability(tvos,strict,introduced=10.0)))                     __attribute__((availability(watchos,strict,introduced=3.0)))
S#define _LIBCPP_AVAILABILITY_SIZED_NEW_DELETE                                  \
S  __attribute__((availability(macosx,strict,introduced=10.12)))                \
S  __attribute__((availability(ios,strict,introduced=10.0)))                    \
S  __attribute__((availability(tvos,strict,introduced=10.0)))                   \
S  __attribute__((availability(watchos,strict,introduced=3.0)))
X#define _LIBCPP_AVAILABILITY_SIZED_NEW_DELETE                                    __attribute__((availability(macosx,strict,introduced=10.12)))                  __attribute__((availability(ios,strict,introduced=10.0)))                      __attribute__((availability(tvos,strict,introduced=10.0)))                     __attribute__((availability(watchos,strict,introduced=3.0)))
S#define _LIBCPP_AVAILABILITY_FUTURE_ERROR                                      \
S  __attribute__((availability(ios,strict,introduced=6.0)))
X#define _LIBCPP_AVAILABILITY_FUTURE_ERROR                                        __attribute__((availability(ios,strict,introduced=6.0)))
S#define _LIBCPP_AVAILABILITY_TYPEINFO_VTABLE                                   \
S  __attribute__((availability(macosx,strict,introduced=10.9)))                 \
S  __attribute__((availability(ios,strict,introduced=7.0)))
X#define _LIBCPP_AVAILABILITY_TYPEINFO_VTABLE                                     __attribute__((availability(macosx,strict,introduced=10.9)))                   __attribute__((availability(ios,strict,introduced=7.0)))
S#define _LIBCPP_AVAILABILITY_LOCALE_CATEGORY                                   \
S  __attribute__((availability(macosx,strict,introduced=10.9)))                 \
S  __attribute__((availability(ios,strict,introduced=7.0)))
X#define _LIBCPP_AVAILABILITY_LOCALE_CATEGORY                                     __attribute__((availability(macosx,strict,introduced=10.9)))                   __attribute__((availability(ios,strict,introduced=7.0)))
S#define _LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR                                 \
S  __attribute__((availability(macosx,strict,introduced=10.9)))                 \
S  __attribute__((availability(ios,strict,introduced=7.0)))
X#define _LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR                                   __attribute__((availability(macosx,strict,introduced=10.9)))                   __attribute__((availability(ios,strict,introduced=7.0)))
N#else
N#define _LIBCPP_AVAILABILITY_SHARED_MUTEX
N#define _LIBCPP_AVAILABILITY_BAD_OPTIONAL_ACCESS
N#define _LIBCPP_AVAILABILITY_BAD_ARRAY_LENGTH
N#define _LIBCPP_AVAILABILITY_BAD_ANY_CAST
N#define _LIBCPP_AVAILABILITY_UNCAUGHT_EXCEPTIONS
N#define _LIBCPP_AVAILABILITY_SIZED_NEW_DELETE
N#define _LIBCPP_AVAILABILITY_FUTURE_ERROR
N#define _LIBCPP_AVAILABILITY_TYPEINFO_VTABLE
N#define _LIBCPP_AVAILABILITY_LOCALE_CATEGORY
N#define _LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR
N#endif
N
N// Define availability that depends on _LIBCPP_NO_EXCEPTIONS.
N#ifdef _LIBCPP_NO_EXCEPTIONS
N#define _LIBCPP_AVAILABILITY_DYNARRAY
N#define _LIBCPP_AVAILABILITY_FUTURE
N#define _LIBCPP_AVAILABILITY_THROW_BAD_ANY_CAST
N#else
S#define _LIBCPP_AVAILABILITY_DYNARRAY _LIBCPP_AVAILABILITY_BAD_ARRAY_LENGTH
S#define _LIBCPP_AVAILABILITY_FUTURE _LIBCPP_AVAILABILITY_FUTURE_ERROR
S#define _LIBCPP_AVAILABILITY_THROW_BAD_ANY_CAST                                \
S  _LIBCPP_AVAILABILITY_BAD_ANY_CAST
X#define _LIBCPP_AVAILABILITY_THROW_BAD_ANY_CAST                                  _LIBCPP_AVAILABILITY_BAD_ANY_CAST
N#endif
N
N// Availability of stream API in the dylib got dropped and re-added.  The
N// extern template should effectively be available at:
N//    availability(macosx,introduced=10.9)
N//    availability(ios,introduced=7.0)
N#if defined(_LIBCPP_USE_AVAILABILITY_APPLE) &&                                 \
N    ((defined(__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__) &&                \
N      __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ < 1090) ||                 \
N     (defined(__ENVIRONMENT_IPHONE_OS_VERSION_MIN_REQUIRED__) &&               \
N      __ENVIRONMENT_IPHONE_OS_VERSION_MIN_REQUIRED__ < 70000))
X#if 0L &&                                     ((0L &&                      __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ < 1090) ||                      (0L &&                     __ENVIRONMENT_IPHONE_OS_VERSION_MIN_REQUIRED__ < 70000))
S#define _LIBCPP_AVAILABILITY_NO_STREAMS_EXTERN_TEMPLATE
N#endif
N
N#if defined(_LIBCPP_COMPILER_IBM)
X#if 0L
S#define _LIBCPP_HAS_NO_PRAGMA_PUSH_POP_MACRO
N#endif
N
N#if defined(_LIBCPP_HAS_NO_PRAGMA_PUSH_POP_MACRO)
X#if 0L
S# define _LIBCPP_PUSH_MACROS
S# define _LIBCPP_POP_MACROS
N#else
N  // Don't warn about macro conflicts when we can restore them at the
N  // end of the header.
N# ifndef _LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS
N#   define _LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS
N# endif
N# if defined(_LIBCPP_COMPILER_MSVC)
X# if 0L
S#   define _LIBCPP_PUSH_MACROS    \
S      __pragma(push_macro("min")) \
S      __pragma(push_macro("max"))
X#   define _LIBCPP_PUSH_MACROS          __pragma(push_macro("min"))       __pragma(push_macro("max"))
S#   define _LIBCPP_POP_MACROS     \
S      __pragma(pop_macro("min"))  \
S      __pragma(pop_macro("max"))
X#   define _LIBCPP_POP_MACROS           __pragma(pop_macro("min"))        __pragma(pop_macro("max"))
N# else
N#   define _LIBCPP_PUSH_MACROS        \
N      _Pragma("push_macro(\"min\")")  \
N      _Pragma("push_macro(\"max\")")
X#   define _LIBCPP_PUSH_MACROS              _Pragma("push_macro(\"min\")")        _Pragma("push_macro(\"max\")")
N#   define _LIBCPP_POP_MACROS         \
N      _Pragma("pop_macro(\"min\")")   \
N      _Pragma("pop_macro(\"max\")")
X#   define _LIBCPP_POP_MACROS               _Pragma("pop_macro(\"min\")")         _Pragma("pop_macro(\"max\")")
N# endif
N#endif // defined(_LIBCPP_HAS_NO_PRAGMA_PUSH_POP_MACRO)
N
N#ifdef _LIBCPP_C_AND_CPP_FUNCS_ARE_DISTINCT
N#define _LIBCPP_FREE [] (void *p) { free(p); }
N#define _LIBCPP_FCLOSE [] (FILE *f) { return fclose(f); }
N#else
S#define _LIBCPP_FREE free
S#define _LIBCPP_FCLOSE fclose
N#endif // defined(_LIBCPP_C_AND_CPP_FUNCS_ARE_DISTINCT)
N
N#endif // __cplusplus
N
N#pragma diag_pop
N
N#endif // _LIBCPP_CONFIG
L 470 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/string" 2
N#include <string_view>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/string_view" 1
N// -*- C++ -*-
N//===------------------------ string_view ---------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is distributed under the University of Illinois Open Source
N// License. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP_STRING_VIEW
N#define _LIBCPP_STRING_VIEW
N
N/*
Nstring_view synopsis
N
Nnamespace std {
N
N    // 7.2, Class template basic_string_view
N    template<class charT, class traits = char_traits<charT>>
N        class basic_string_view;
N
N    // 7.9, basic_string_view non-member comparison functions
N    template<class charT, class traits>
N    constexpr bool operator==(basic_string_view<charT, traits> x,
N                              basic_string_view<charT, traits> y) noexcept;
N    template<class charT, class traits>
N    constexpr bool operator!=(basic_string_view<charT, traits> x,
N                              basic_string_view<charT, traits> y) noexcept;
N    template<class charT, class traits>
N    constexpr bool operator< (basic_string_view<charT, traits> x,
N                                 basic_string_view<charT, traits> y) noexcept;
N    template<class charT, class traits>
N    constexpr bool operator> (basic_string_view<charT, traits> x,
N                              basic_string_view<charT, traits> y) noexcept;
N    template<class charT, class traits>
N    constexpr bool operator<=(basic_string_view<charT, traits> x,
N                                 basic_string_view<charT, traits> y) noexcept;
N    template<class charT, class traits>
N    constexpr bool operator>=(basic_string_view<charT, traits> x,
N                              basic_string_view<charT, traits> y) noexcept;
N    // see below, sufficient additional overloads of comparison functions
N
N    // 7.10, Inserters and extractors
N    template<class charT, class traits>
N      basic_ostream<charT, traits>&
N        operator<<(basic_ostream<charT, traits>& os,
N                   basic_string_view<charT, traits> str);
N
N    // basic_string_view typedef names
N    typedef basic_string_view<char> string_view;
N    typedef basic_string_view<char16_t> u16string_view;
N    typedef basic_string_view<char32_t> u32string_view;
N    typedef basic_string_view<wchar_t> wstring_view;
N
N    template<class charT, class traits = char_traits<charT>>
N    class basic_string_view {
N      public:
N      // types
N      typedef traits traits_type;
N      typedef charT value_type;
N      typedef charT* pointer;
N      typedef const charT* const_pointer;
N      typedef charT& reference;
N      typedef const charT& const_reference;
N      typedef implementation-defined const_iterator;
N      typedef const_iterator iterator;
N      typedef reverse_iterator<const_iterator> const_reverse_iterator;
N      typedef const_reverse_iterator reverse_iterator;
N      typedef size_t size_type;
N      typedef ptrdiff_t difference_type;
N      static constexpr size_type npos = size_type(-1);
N
N      // 7.3, basic_string_view constructors and assignment operators
N      constexpr basic_string_view() noexcept;
N      constexpr basic_string_view(const basic_string_view&) noexcept = default;
N      basic_string_view& operator=(const basic_string_view&) noexcept = default;
N      template<class Allocator>
N      constexpr basic_string_view(const charT* str);
N      constexpr basic_string_view(const charT* str, size_type len);
N
N      // 7.4, basic_string_view iterator support
N      constexpr const_iterator begin() const noexcept;
N      constexpr const_iterator end() const noexcept;
N      constexpr const_iterator cbegin() const noexcept;
N      constexpr const_iterator cend() const noexcept;
N      const_reverse_iterator rbegin() const noexcept;
N      const_reverse_iterator rend() const noexcept;
N      const_reverse_iterator crbegin() const noexcept;
N      const_reverse_iterator crend() const noexcept;
N
N      // 7.5, basic_string_view capacity
N      constexpr size_type size() const noexcept;
N      constexpr size_type length() const noexcept;
N      constexpr size_type max_size() const noexcept;
N      constexpr bool empty() const noexcept;
N
N      // 7.6, basic_string_view element access
N      constexpr const_reference operator[](size_type pos) const;
N      constexpr const_reference at(size_type pos) const;
N      constexpr const_reference front() const;
N      constexpr const_reference back() const;
N      constexpr const_pointer data() const noexcept;
N
N      // 7.7, basic_string_view modifiers
N      constexpr void remove_prefix(size_type n);
N      constexpr void remove_suffix(size_type n);
N      constexpr void swap(basic_string_view& s) noexcept;
N
N      size_type copy(charT* s, size_type n, size_type pos = 0) const;
N
N      constexpr basic_string_view substr(size_type pos = 0, size_type n = npos) const;
N      constexpr int compare(basic_string_view s) const noexcept;
N      constexpr int compare(size_type pos1, size_type n1, basic_string_view s) const;
N      constexpr int compare(size_type pos1, size_type n1,
N                            basic_string_view s, size_type pos2, size_type n2) const;
N      constexpr int compare(const charT* s) const;
N      constexpr int compare(size_type pos1, size_type n1, const charT* s) const;
N      constexpr int compare(size_type pos1, size_type n1,
N                            const charT* s, size_type n2) const;
N      constexpr size_type find(basic_string_view s, size_type pos = 0) const noexcept;
N      constexpr size_type find(charT c, size_type pos = 0) const noexcept;
N      constexpr size_type find(const charT* s, size_type pos, size_type n) const;
N      constexpr size_type find(const charT* s, size_type pos = 0) const;
N      constexpr size_type rfind(basic_string_view s, size_type pos = npos) const noexcept;
N      constexpr size_type rfind(charT c, size_type pos = npos) const noexcept;
N      constexpr size_type rfind(const charT* s, size_type pos, size_type n) const;
N      constexpr size_type rfind(const charT* s, size_type pos = npos) const;
N      constexpr size_type find_first_of(basic_string_view s, size_type pos = 0) const noexcept;
N      constexpr size_type find_first_of(charT c, size_type pos = 0) const noexcept;
N      constexpr size_type find_first_of(const charT* s, size_type pos, size_type n) const;
N      constexpr size_type find_first_of(const charT* s, size_type pos = 0) const;
N      constexpr size_type find_last_of(basic_string_view s, size_type pos = npos) const noexcept;
N      constexpr size_type find_last_of(charT c, size_type pos = npos) const noexcept;
N      constexpr size_type find_last_of(const charT* s, size_type pos, size_type n) const;
N      constexpr size_type find_last_of(const charT* s, size_type pos = npos) const;
N      constexpr size_type find_first_not_of(basic_string_view s, size_type pos = 0) const noexcept;
N      constexpr size_type find_first_not_of(charT c, size_type pos = 0) const noexcept;
N      constexpr size_type find_first_not_of(const charT* s, size_type pos, size_type n) const;
N      constexpr size_type find_first_not_of(const charT* s, size_type pos = 0) const;
N      constexpr size_type find_last_not_of(basic_string_view s, size_type pos = npos) const noexcept;
N      constexpr size_type find_last_not_of(charT c, size_type pos = npos) const noexcept;
N      constexpr size_type find_last_not_of(const charT* s, size_type pos, size_type n) const;
N      constexpr size_type find_last_not_of(const charT* s, size_type pos = npos) const;
N
N     private:
N      const_pointer data_;  // exposition only
N      size_type     size_;  // exposition only
N    };
N
N  // 7.11, Hash support
N  template <class T> struct hash;
N  template <> struct hash<string_view>;
N  template <> struct hash<u16string_view>;
N  template <> struct hash<u32string_view>;
N  template <> struct hash<wstring_view>;
N
N  constexpr basic_string_view<char>     operator "" sv( const char *str,     size_t len ) noexcept;
N  constexpr basic_string_view<wchar_t>  operator "" sv( const wchar_t *str,  size_t len ) noexcept;
N  constexpr basic_string_view<char16_t> operator "" sv( const char16_t *str, size_t len ) noexcept;
N  constexpr basic_string_view<char32_t> operator "" sv( const char32_t *str, size_t len ) noexcept;
N
N}  // namespace std
N
N
N*/
N
N#include <__config>
N#include <__string>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/__string" 1
N// -*- C++ -*-
N//===-------------------------- __string ----------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is distributed under the University of Illinois Open Source
N// License. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP___STRING
N#define _LIBCPP___STRING
N
N/*
N    string synopsis
N
Nnamespace std
N{
N
Ntemplate <class charT>
Nstruct char_traits
N{
N    typedef charT     char_type;
N    typedef ...       int_type;
N    typedef streamoff off_type;
N    typedef streampos pos_type;
N    typedef mbstate_t state_type;
N
N    static constexpr void assign(char_type& c1, const char_type& c2) noexcept;
N    static constexpr bool eq(char_type c1, char_type c2) noexcept;
N    static constexpr bool lt(char_type c1, char_type c2) noexcept;
N
N    static constexpr int    compare(const char_type* s1, const char_type* s2, size_t n);
N    static constexpr size_t length(const char_type* s);
N    static constexpr const char_type* 
N                            find(const char_type* s, size_t n, const char_type& a);
N    static char_type*       move(char_type* s1, const char_type* s2, size_t n);
N    static char_type*       copy(char_type* s1, const char_type* s2, size_t n);
N    static char_type*       assign(char_type* s, size_t n, char_type a);
N
N    static constexpr int_type  not_eof(int_type c) noexcept;
N    static constexpr char_type to_char_type(int_type c) noexcept;
N    static constexpr int_type  to_int_type(char_type c) noexcept;
N    static constexpr bool      eq_int_type(int_type c1, int_type c2) noexcept;
N    static constexpr int_type  eof() noexcept;
N};
N
Ntemplate <> struct char_traits<char>;
Ntemplate <> struct char_traits<wchar_t>;
N
N}  // std
N
N*/
N
N#include <__config>
N#include <algorithm>  // for search and min
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/algorithm" 1
N// -*- C++ -*-
N//===-------------------------- algorithm ---------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is dual licensed under the MIT and the University of Illinois Open
N// Source Licenses. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP_ALGORITHM
N#define _LIBCPP_ALGORITHM
N
N/*
N    algorithm synopsis
N
N#include <initializer_list>
N
Nnamespace std
N{
N
Ntemplate <class InputIterator, class Predicate>
N    bool
N    all_of(InputIterator first, InputIterator last, Predicate pred);
N
Ntemplate <class InputIterator, class Predicate>
N    bool
N    any_of(InputIterator first, InputIterator last, Predicate pred);
N
Ntemplate <class InputIterator, class Predicate>
N    bool
N    none_of(InputIterator first, InputIterator last, Predicate pred);
N
Ntemplate <class InputIterator, class Function>
N    Function
N    for_each(InputIterator first, InputIterator last, Function f);
N
Ntemplate<class InputIterator, class Size, class Function>
N    InputIterator for_each_n(InputIterator first, Size n, Function f); // C++17
N
Ntemplate <class InputIterator, class T>
N    InputIterator
N    find(InputIterator first, InputIterator last, const T& value);
N
Ntemplate <class InputIterator, class Predicate>
N    InputIterator
N    find_if(InputIterator first, InputIterator last, Predicate pred);
N
Ntemplate<class InputIterator, class Predicate>
N    InputIterator
N    find_if_not(InputIterator first, InputIterator last, Predicate pred);
N
Ntemplate <class ForwardIterator1, class ForwardIterator2>
N    ForwardIterator1
N    find_end(ForwardIterator1 first1, ForwardIterator1 last1,
N             ForwardIterator2 first2, ForwardIterator2 last2);
N
Ntemplate <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>
N    ForwardIterator1
N    find_end(ForwardIterator1 first1, ForwardIterator1 last1,
N             ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);
N
Ntemplate <class ForwardIterator1, class ForwardIterator2>
N    ForwardIterator1
N    find_first_of(ForwardIterator1 first1, ForwardIterator1 last1,
N                  ForwardIterator2 first2, ForwardIterator2 last2);
N
Ntemplate <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>
N    ForwardIterator1
N    find_first_of(ForwardIterator1 first1, ForwardIterator1 last1,
N                  ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);
N
Ntemplate <class ForwardIterator>
N    ForwardIterator
N    adjacent_find(ForwardIterator first, ForwardIterator last);
N
Ntemplate <class ForwardIterator, class BinaryPredicate>
N    ForwardIterator
N    adjacent_find(ForwardIterator first, ForwardIterator last, BinaryPredicate pred);
N
Ntemplate <class InputIterator, class T>
N    typename iterator_traits<InputIterator>::difference_type
N    count(InputIterator first, InputIterator last, const T& value);
N
Ntemplate <class InputIterator, class Predicate>
N    typename iterator_traits<InputIterator>::difference_type
N    count_if(InputIterator first, InputIterator last, Predicate pred);
N
Ntemplate <class InputIterator1, class InputIterator2>
N    pair<InputIterator1, InputIterator2>
N    mismatch(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);
N
Ntemplate <class InputIterator1, class InputIterator2>
N    pair<InputIterator1, InputIterator2>
N    mismatch(InputIterator1 first1, InputIterator1 last1,
N             InputIterator2 first2, InputIterator2 last2); // **C++14**
N
Ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>
N    pair<InputIterator1, InputIterator2>
N    mismatch(InputIterator1 first1, InputIterator1 last1,
N             InputIterator2 first2, BinaryPredicate pred);
N
Ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>
N    pair<InputIterator1, InputIterator2>
N    mismatch(InputIterator1 first1, InputIterator1 last1,
N             InputIterator2 first2, InputIterator2 last2,
N             BinaryPredicate pred); // **C++14**
N
Ntemplate <class InputIterator1, class InputIterator2>
N    bool
N    equal(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);
N
Ntemplate <class InputIterator1, class InputIterator2>
N    bool
N    equal(InputIterator1 first1, InputIterator1 last1,
N          InputIterator2 first2, InputIterator2 last2); // **C++14**
N
Ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>
N    bool
N    equal(InputIterator1 first1, InputIterator1 last1,
N          InputIterator2 first2, BinaryPredicate pred);
N
Ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>
N    bool
N    equal(InputIterator1 first1, InputIterator1 last1,
N          InputIterator2 first2, InputIterator2 last2,
N          BinaryPredicate pred); // **C++14**
N
Ntemplate<class ForwardIterator1, class ForwardIterator2>
N    bool
N    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
N                   ForwardIterator2 first2);
N
Ntemplate<class ForwardIterator1, class ForwardIterator2>
N    bool
N    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
N                   ForwardIterator2 first2, ForwardIterator2 last2); // **C++14**
N
Ntemplate<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>
N    bool
N    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
N                   ForwardIterator2 first2, BinaryPredicate pred);
N
Ntemplate<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>
N    bool
N    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
N                   ForwardIterator2 first2, ForwardIterator2 last2,
N                   BinaryPredicate pred);  // **C++14**
N
Ntemplate <class ForwardIterator1, class ForwardIterator2>
N    ForwardIterator1
N    search(ForwardIterator1 first1, ForwardIterator1 last1,
N           ForwardIterator2 first2, ForwardIterator2 last2);
N
Ntemplate <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>
N    ForwardIterator1
N    search(ForwardIterator1 first1, ForwardIterator1 last1,
N           ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);
N
Ntemplate <class ForwardIterator, class Size, class T>
N    ForwardIterator
N    search_n(ForwardIterator first, ForwardIterator last, Size count, const T& value);
N
Ntemplate <class ForwardIterator, class Size, class T, class BinaryPredicate>
N    ForwardIterator
N    search_n(ForwardIterator first, ForwardIterator last,
N             Size count, const T& value, BinaryPredicate pred);
N
Ntemplate <class InputIterator, class OutputIterator>
N    OutputIterator
N    copy(InputIterator first, InputIterator last, OutputIterator result);
N
Ntemplate<class InputIterator, class OutputIterator, class Predicate>
N    OutputIterator
N    copy_if(InputIterator first, InputIterator last,
N            OutputIterator result, Predicate pred);
N
Ntemplate<class InputIterator, class Size, class OutputIterator>
N    OutputIterator
N    copy_n(InputIterator first, Size n, OutputIterator result);
N
Ntemplate <class BidirectionalIterator1, class BidirectionalIterator2>
N    BidirectionalIterator2
N    copy_backward(BidirectionalIterator1 first, BidirectionalIterator1 last,
N                  BidirectionalIterator2 result);
N
Ntemplate <class ForwardIterator1, class ForwardIterator2>
N    ForwardIterator2
N    swap_ranges(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2);
N
Ntemplate <class ForwardIterator1, class ForwardIterator2>
N    void
N    iter_swap(ForwardIterator1 a, ForwardIterator2 b);
N
Ntemplate <class InputIterator, class OutputIterator, class UnaryOperation>
N    OutputIterator
N    transform(InputIterator first, InputIterator last, OutputIterator result, UnaryOperation op);
N
Ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class BinaryOperation>
N    OutputIterator
N    transform(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2,
N              OutputIterator result, BinaryOperation binary_op);
N
Ntemplate <class ForwardIterator, class T>
N    void
N    replace(ForwardIterator first, ForwardIterator last, const T& old_value, const T& new_value);
N
Ntemplate <class ForwardIterator, class Predicate, class T>
N    void
N    replace_if(ForwardIterator first, ForwardIterator last, Predicate pred, const T& new_value);
N
Ntemplate <class InputIterator, class OutputIterator, class T>
N    OutputIterator
N    replace_copy(InputIterator first, InputIterator last, OutputIterator result,
N                 const T& old_value, const T& new_value);
N
Ntemplate <class InputIterator, class OutputIterator, class Predicate, class T>
N    OutputIterator
N    replace_copy_if(InputIterator first, InputIterator last, OutputIterator result, Predicate pred, const T& new_value);
N
Ntemplate <class ForwardIterator, class T>
N    void
N    fill(ForwardIterator first, ForwardIterator last, const T& value);
N
Ntemplate <class OutputIterator, class Size, class T>
N    OutputIterator
N    fill_n(OutputIterator first, Size n, const T& value);
N
Ntemplate <class ForwardIterator, class Generator>
N    void
N    generate(ForwardIterator first, ForwardIterator last, Generator gen);
N
Ntemplate <class OutputIterator, class Size, class Generator>
N    OutputIterator
N    generate_n(OutputIterator first, Size n, Generator gen);
N
Ntemplate <class ForwardIterator, class T>
N    ForwardIterator
N    remove(ForwardIterator first, ForwardIterator last, const T& value);
N
Ntemplate <class ForwardIterator, class Predicate>
N    ForwardIterator
N    remove_if(ForwardIterator first, ForwardIterator last, Predicate pred);
N
Ntemplate <class InputIterator, class OutputIterator, class T>
N    OutputIterator
N    remove_copy(InputIterator first, InputIterator last, OutputIterator result, const T& value);
N
Ntemplate <class InputIterator, class OutputIterator, class Predicate>
N    OutputIterator
N    remove_copy_if(InputIterator first, InputIterator last, OutputIterator result, Predicate pred);
N
Ntemplate <class ForwardIterator>
N    ForwardIterator
N    unique(ForwardIterator first, ForwardIterator last);
N
Ntemplate <class ForwardIterator, class BinaryPredicate>
N    ForwardIterator
N    unique(ForwardIterator first, ForwardIterator last, BinaryPredicate pred);
N
Ntemplate <class InputIterator, class OutputIterator>
N    OutputIterator
N    unique_copy(InputIterator first, InputIterator last, OutputIterator result);
N
Ntemplate <class InputIterator, class OutputIterator, class BinaryPredicate>
N    OutputIterator
N    unique_copy(InputIterator first, InputIterator last, OutputIterator result, BinaryPredicate pred);
N
Ntemplate <class BidirectionalIterator>
N    void
N    reverse(BidirectionalIterator first, BidirectionalIterator last);
N
Ntemplate <class BidirectionalIterator, class OutputIterator>
N    OutputIterator
N    reverse_copy(BidirectionalIterator first, BidirectionalIterator last, OutputIterator result);
N
Ntemplate <class ForwardIterator>
N    ForwardIterator
N    rotate(ForwardIterator first, ForwardIterator middle, ForwardIterator last);
N
Ntemplate <class ForwardIterator, class OutputIterator>
N    OutputIterator
N    rotate_copy(ForwardIterator first, ForwardIterator middle, ForwardIterator last, OutputIterator result);
N
Ntemplate <class RandomAccessIterator>
N    void
N    random_shuffle(RandomAccessIterator first, RandomAccessIterator last); // deprecated in C++14, removed in C++17
N
Ntemplate <class RandomAccessIterator, class RandomNumberGenerator>
N    void
N    random_shuffle(RandomAccessIterator first, RandomAccessIterator last,
N                   RandomNumberGenerator& rand);  // deprecated in C++14, removed in C++17
N
Ntemplate<class PopulationIterator, class SampleIterator,
N         class Distance, class UniformRandomBitGenerator>
N    SampleIterator sample(PopulationIterator first, PopulationIterator last,
N                          SampleIterator out, Distance n,
N                          UniformRandomBitGenerator&& g); // C++17
N
Ntemplate<class RandomAccessIterator, class UniformRandomNumberGenerator>
N    void shuffle(RandomAccessIterator first, RandomAccessIterator last,
N                 UniformRandomNumberGenerator&& g);
N
Ntemplate <class InputIterator, class Predicate>
N    bool
N    is_partitioned(InputIterator first, InputIterator last, Predicate pred);
N
Ntemplate <class ForwardIterator, class Predicate>
N    ForwardIterator
N    partition(ForwardIterator first, ForwardIterator last, Predicate pred);
N
Ntemplate <class InputIterator, class OutputIterator1,
N          class OutputIterator2, class Predicate>
N    pair<OutputIterator1, OutputIterator2>
N    partition_copy(InputIterator first, InputIterator last,
N                   OutputIterator1 out_true, OutputIterator2 out_false,
N                   Predicate pred);
N
Ntemplate <class ForwardIterator, class Predicate>
N    ForwardIterator
N    stable_partition(ForwardIterator first, ForwardIterator last, Predicate pred);
N
Ntemplate<class ForwardIterator, class Predicate>
N    ForwardIterator
N    partition_point(ForwardIterator first, ForwardIterator last, Predicate pred);
N
Ntemplate <class ForwardIterator>
N    bool
N    is_sorted(ForwardIterator first, ForwardIterator last);
N
Ntemplate <class ForwardIterator, class Compare>
N    bool
N    is_sorted(ForwardIterator first, ForwardIterator last, Compare comp);
N
Ntemplate<class ForwardIterator>
N    ForwardIterator
N    is_sorted_until(ForwardIterator first, ForwardIterator last);
N
Ntemplate <class ForwardIterator, class Compare>
N    ForwardIterator
N    is_sorted_until(ForwardIterator first, ForwardIterator last, Compare comp);
N
Ntemplate <class RandomAccessIterator>
N    void
N    sort(RandomAccessIterator first, RandomAccessIterator last);
N
Ntemplate <class RandomAccessIterator, class Compare>
N    void
N    sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp);
N
Ntemplate <class RandomAccessIterator>
N    void
N    stable_sort(RandomAccessIterator first, RandomAccessIterator last);
N
Ntemplate <class RandomAccessIterator, class Compare>
N    void
N    stable_sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp);
N
Ntemplate <class RandomAccessIterator>
N    void
N    partial_sort(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last);
N
Ntemplate <class RandomAccessIterator, class Compare>
N    void
N    partial_sort(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last, Compare comp);
N
Ntemplate <class InputIterator, class RandomAccessIterator>
N    RandomAccessIterator
N    partial_sort_copy(InputIterator first, InputIterator last,
N                      RandomAccessIterator result_first, RandomAccessIterator result_last);
N
Ntemplate <class InputIterator, class RandomAccessIterator, class Compare>
N    RandomAccessIterator
N    partial_sort_copy(InputIterator first, InputIterator last,
N                      RandomAccessIterator result_first, RandomAccessIterator result_last, Compare comp);
N
Ntemplate <class RandomAccessIterator>
N    void
N    nth_element(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last);
N
Ntemplate <class RandomAccessIterator, class Compare>
N    void
N    nth_element(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last, Compare comp);
N
Ntemplate <class ForwardIterator, class T>
N    ForwardIterator
N    lower_bound(ForwardIterator first, ForwardIterator last, const T& value);
N
Ntemplate <class ForwardIterator, class T, class Compare>
N    ForwardIterator
N    lower_bound(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);
N
Ntemplate <class ForwardIterator, class T>
N    ForwardIterator
N    upper_bound(ForwardIterator first, ForwardIterator last, const T& value);
N
Ntemplate <class ForwardIterator, class T, class Compare>
N    ForwardIterator
N    upper_bound(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);
N
Ntemplate <class ForwardIterator, class T>
N    pair<ForwardIterator, ForwardIterator>
N    equal_range(ForwardIterator first, ForwardIterator last, const T& value);
N
Ntemplate <class ForwardIterator, class T, class Compare>
N    pair<ForwardIterator, ForwardIterator>
N    equal_range(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);
N
Ntemplate <class ForwardIterator, class T>
N    bool
N    binary_search(ForwardIterator first, ForwardIterator last, const T& value);
N
Ntemplate <class ForwardIterator, class T, class Compare>
N    bool
N    binary_search(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);
N
Ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>
N    OutputIterator
N    merge(InputIterator1 first1, InputIterator1 last1,
N          InputIterator2 first2, InputIterator2 last2, OutputIterator result);
N
Ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>
N    OutputIterator
N    merge(InputIterator1 first1, InputIterator1 last1,
N          InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);
N
Ntemplate <class BidirectionalIterator>
N    void
N    inplace_merge(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last);
N
Ntemplate <class BidirectionalIterator, class Compare>
N    void
N    inplace_merge(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last, Compare comp);
N
Ntemplate <class InputIterator1, class InputIterator2>
N    bool
N    includes(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2);
N
Ntemplate <class InputIterator1, class InputIterator2, class Compare>
N    bool
N    includes(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, Compare comp);
N
Ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>
N    OutputIterator
N    set_union(InputIterator1 first1, InputIterator1 last1,
N              InputIterator2 first2, InputIterator2 last2, OutputIterator result);
N
Ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>
N    OutputIterator
N    set_union(InputIterator1 first1, InputIterator1 last1,
N              InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);
N
Ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>
N    OutputIterator
N    set_intersection(InputIterator1 first1, InputIterator1 last1,
N                     InputIterator2 first2, InputIterator2 last2, OutputIterator result);
N
Ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>
N    OutputIterator
N    set_intersection(InputIterator1 first1, InputIterator1 last1,
N                     InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);
N
Ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>
N    OutputIterator
N    set_difference(InputIterator1 first1, InputIterator1 last1,
N                   InputIterator2 first2, InputIterator2 last2, OutputIterator result);
N
Ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>
N    OutputIterator
N    set_difference(InputIterator1 first1, InputIterator1 last1,
N                   InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);
N
Ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>
N    OutputIterator
N    set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,
N                             InputIterator2 first2, InputIterator2 last2, OutputIterator result);
N
Ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>
N    OutputIterator
N    set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,
N                             InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);
N
Ntemplate <class RandomAccessIterator>
N    void
N    push_heap(RandomAccessIterator first, RandomAccessIterator last);
N
Ntemplate <class RandomAccessIterator, class Compare>
N    void
N    push_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);
N
Ntemplate <class RandomAccessIterator>
N    void
N    pop_heap(RandomAccessIterator first, RandomAccessIterator last);
N
Ntemplate <class RandomAccessIterator, class Compare>
N    void
N    pop_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);
N
Ntemplate <class RandomAccessIterator>
N    void
N    make_heap(RandomAccessIterator first, RandomAccessIterator last);
N
Ntemplate <class RandomAccessIterator, class Compare>
N    void
N    make_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);
N
Ntemplate <class RandomAccessIterator>
N    void
N    sort_heap(RandomAccessIterator first, RandomAccessIterator last);
N
Ntemplate <class RandomAccessIterator, class Compare>
N    void
N    sort_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);
N
Ntemplate <class RandomAccessIterator>
N    bool
N    is_heap(RandomAccessIterator first, RandomAccessiterator last);
N
Ntemplate <class RandomAccessIterator, class Compare>
N    bool
N    is_heap(RandomAccessIterator first, RandomAccessiterator last, Compare comp);
N
Ntemplate <class RandomAccessIterator>
N    RandomAccessIterator
N    is_heap_until(RandomAccessIterator first, RandomAccessiterator last);
N
Ntemplate <class RandomAccessIterator, class Compare>
N    RandomAccessIterator
N    is_heap_until(RandomAccessIterator first, RandomAccessiterator last, Compare comp);
N
Ntemplate <class ForwardIterator>
N    ForwardIterator
N    min_element(ForwardIterator first, ForwardIterator last);  // constexpr in C++14
N
Ntemplate <class ForwardIterator, class Compare>
N    ForwardIterator
N    min_element(ForwardIterator first, ForwardIterator last, Compare comp);  // constexpr in C++14
N
Ntemplate <class T>
N    const T&
N    min(const T& a, const T& b);  // constexpr in C++14
N
Ntemplate <class T, class Compare>
N    const T&
N    min(const T& a, const T& b, Compare comp);  // constexpr in C++14
N
Ntemplate<class T>
N    T
N    min(initializer_list<T> t);  // constexpr in C++14
N
Ntemplate<class T, class Compare>
N    T
N    min(initializer_list<T> t, Compare comp);  // constexpr in C++14
N
Ntemplate<class T>
N    constexpr const T& clamp( const T& v, const T& lo, const T& hi );               // C++17
N
Ntemplate<class T, class Compare>
N    constexpr const T& clamp( const T& v, const T& lo, const T& hi, Compare comp ); // C++17
N
Ntemplate <class ForwardIterator>
N    ForwardIterator
N    max_element(ForwardIterator first, ForwardIterator last);  // constexpr in C++14
N
Ntemplate <class ForwardIterator, class Compare>
N    ForwardIterator
N    max_element(ForwardIterator first, ForwardIterator last, Compare comp);  // constexpr in C++14
N
Ntemplate <class T>
N    const T&
N    max(const T& a, const T& b); // constexpr in C++14
N
Ntemplate <class T, class Compare>
N    const T&
N    max(const T& a, const T& b, Compare comp);  // constexpr in C++14
N
Ntemplate<class T>
N    T
N    max(initializer_list<T> t);  // constexpr in C++14
N
Ntemplate<class T, class Compare>
N    T
N    max(initializer_list<T> t, Compare comp);  // constexpr in C++14
N
Ntemplate<class ForwardIterator>
N    pair<ForwardIterator, ForwardIterator>
N    minmax_element(ForwardIterator first, ForwardIterator last);   // constexpr in C++14
N
Ntemplate<class ForwardIterator, class Compare>
N    pair<ForwardIterator, ForwardIterator>
N    minmax_element(ForwardIterator first, ForwardIterator last, Compare comp);   // constexpr in C++14
N
Ntemplate<class T>
N    pair<const T&, const T&>
N    minmax(const T& a, const T& b);  // constexpr in C++14
N
Ntemplate<class T, class Compare>
N    pair<const T&, const T&>
N    minmax(const T& a, const T& b, Compare comp);  // constexpr in C++14
N
Ntemplate<class T>
N    pair<T, T>
N    minmax(initializer_list<T> t);  // constexpr in C++14
N
Ntemplate<class T, class Compare>
N    pair<T, T>
N    minmax(initializer_list<T> t, Compare comp);  // constexpr in C++14
N
Ntemplate <class InputIterator1, class InputIterator2>
N    bool
N    lexicographical_compare(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2);
N
Ntemplate <class InputIterator1, class InputIterator2, class Compare>
N    bool
N    lexicographical_compare(InputIterator1 first1, InputIterator1 last1,
N                            InputIterator2 first2, InputIterator2 last2, Compare comp);
N
Ntemplate <class BidirectionalIterator>
N    bool
N    next_permutation(BidirectionalIterator first, BidirectionalIterator last);
N
Ntemplate <class BidirectionalIterator, class Compare>
N    bool
N    next_permutation(BidirectionalIterator first, BidirectionalIterator last, Compare comp);
N
Ntemplate <class BidirectionalIterator>
N    bool
N    prev_permutation(BidirectionalIterator first, BidirectionalIterator last);
N
Ntemplate <class BidirectionalIterator, class Compare>
N    bool
N    prev_permutation(BidirectionalIterator first, BidirectionalIterator last, Compare comp);
N
N}  // std
N
N*/
N
N#include <__config>
N#include <initializer_list>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/initializer_list" 1
N// -*- C++ -*-
N//===----------------------- initializer_list -----------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is dual licensed under the MIT and the University of Illinois Open
N// Source Licenses. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP_INITIALIZER_LIST
N#define _LIBCPP_INITIALIZER_LIST
N
N/*
N    initializer_list synopsis
N
Nnamespace std
N{
N
Ntemplate<class E>
Nclass initializer_list
N{
Npublic:
N    typedef E        value_type;
N    typedef const E& reference;
N    typedef const E& const_reference;
N    typedef size_t   size_type;
N
N    typedef const E* iterator;
N    typedef const E* const_iterator;
N
N    initializer_list() noexcept; // constexpr in C++14
N
N    size_t   size()  const noexcept; // constexpr in C++14
N    const E* begin() const noexcept; // constexpr in C++14
N    const E* end()   const noexcept; // constexpr in C++14
N};
N
Ntemplate<class E> const E* begin(initializer_list<E> il) noexcept; // constexpr in C++14
Ntemplate<class E> const E* end(initializer_list<E> il) noexcept; // constexpr in C++14
N
N}  // std
N
N*/
N
N#include <__config>
N#include <cstddef>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/cstddef" 1
N// -*- C++ -*-
N//===--------------------------- cstddef ----------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is dual licensed under the MIT and the University of Illinois Open
N// Source Licenses. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP_CSTDDEF
N#define _LIBCPP_CSTDDEF
N
N/*
N    cstddef synopsis
N
NMacros:
N
N    offsetof(type,member-designator)
N    NULL
N
Nnamespace std
N{
N
NTypes:
N
N    ptrdiff_t
N    size_t
N    max_align_t
N    nullptr_t
N    byte // C++17
N
N}  // std
N
N*/
N
N#include <__config>
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N// Don't include our own <stddef.h>; we don't want to declare ::nullptr_t.
N#include_next <stddef.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/stddef.h" 1
N/*****************************************************************************/
N/* stddef.h                                                                  */
N/*                                                                           */
N/* Copyright (c) 1993 Texas Instruments Incorporated                         */
N/* http://www.ti.com/                                                        */
N/*                                                                           */
N/*  Redistribution and  use in source  and binary forms, with  or without    */
N/*  modification,  are permitted provided  that the  following conditions    */
N/*  are met:                                                                 */
N/*                                                                           */
N/*     Redistributions  of source  code must  retain the  above copyright    */
N/*     notice, this list of conditions and the following disclaimer.         */
N/*                                                                           */
N/*     Redistributions in binary form  must reproduce the above copyright    */
N/*     notice, this  list of conditions  and the following  disclaimer in    */
N/*     the  documentation  and/or   other  materials  provided  with  the    */
N/*     distribution.                                                         */
N/*                                                                           */
N/*     Neither the  name of Texas Instruments Incorporated  nor the names    */
N/*     of its  contributors may  be used to  endorse or  promote products    */
N/*     derived  from   this  software  without   specific  prior  written    */
N/*     permission.                                                           */
N/*                                                                           */
N/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS    */
N/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT    */
N/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    */
N/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT    */
N/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    */
N/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT    */
N/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    */
N/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    */
N/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT    */
N/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    */
N/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     */
N/*                                                                           */
N/*****************************************************************************/
N
N#ifndef _STDDEF
N#define _STDDEF
N
N#include <_ti_config.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/_ti_config.h" 1
N/*****************************************************************************/
N/* _ti_config.h                                                              */
N/*                                                                           */
N/* Copyright (c) 2017 Texas Instruments Incorporated                         */
N/* http://www.ti.com/                                                        */
N/*                                                                           */
N/*  Redistribution and  use in source  and binary forms, with  or without    */
N/*  modification,  are permitted provided  that the  following conditions    */
N/*  are met:                                                                 */
N/*                                                                           */
N/*     Redistributions  of source  code must  retain the  above copyright    */
N/*     notice, this list of conditions and the following disclaimer.         */
N/*                                                                           */
N/*     Redistributions in binary form  must reproduce the above copyright    */
N/*     notice, this  list of conditions  and the following  disclaimer in    */
N/*     the  documentation  and/or   other  materials  provided  with  the    */
N/*     distribution.                                                         */
N/*                                                                           */
N/*     Neither the  name of Texas Instruments Incorporated  nor the names    */
N/*     of its  contributors may  be used to  endorse or  promote products    */
N/*     derived  from   this  software  without   specific  prior  written    */
N/*     permission.                                                           */
N/*                                                                           */
N/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS    */
N/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT    */
N/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    */
N/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT    */
N/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    */
N/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT    */
N/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    */
N/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    */
N/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT    */
N/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    */
N/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     */
N/*                                                                           */
N/*****************************************************************************/
N
N#ifndef __TI_CONFIG_H
N#define __TI_CONFIG_H
N
N#pragma diag_push
N#pragma CHECK_MISRA("-19.4")
N#pragma CHECK_MISRA("-19.1")
N
N/* Common definitions */
N
N#if defined(__cplusplus)
X#if 1L
N/* C++ */
N# if (__cplusplus >= 201103L)
X# if (201402L >= 201103L)
N /* C++11 */
N#  define _TI_NORETURN [[noreturn]]
N#  define _TI_NOEXCEPT noexcept
N# else
S /* C++98/03 */
S#  define _TI_NORETURN __attribute__((noreturn))
S#  define _TI_NOEXCEPT throw()
N# endif
N#else
S/* C */
S# if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L)
S /* C11 */
S#  define _TI_NORETURN _Noreturn
S# else
S /* C89/C99 */
S#  define _TI_NORETURN __attribute__((noreturn))
S# endif
S# define _TI_NOEXCEPT
N#endif
N
N#if defined(__cplusplus) && (__cplusplus >= 201103L)
X#if 1L && (201402L >= 201103L)
N# define _TI_CPP11LIB 1
N#endif
N
N#if defined(__cplusplus) && (__cplusplus >= 201402L)
X#if 1L && (201402L >= 201402L)
N# define _TI_CPP14LIB 1
N#endif
N
N#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) || \
N    defined(_TI_CPP11LIB)
X#if 0L && (__STDC_VERSION__ >= 199901L) ||     1L
N# define _TI_C99LIB 1
N#endif
N
N#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L) || \
N    defined(_TI_CPP14LIB)
X#if 0L && (__STDC_VERSION__ >= 201112L) ||     1L
N# define _TI_C11LIB 1
N#endif
N
N/* _TI_NOEXCEPT_CPP14 is defined to noexcept only when compiling for C++14. It
N   is intended to be used for functions like abort and atexit that are supposed
N   to be declared noexcept only in C++14 mode. */
N#ifdef _TI_CPP14LIB
N# define _TI_NOEXCEPT_CPP14 noexcept
N#else
S# define _TI_NOEXCEPT_CPP14
N#endif
N
N/* Target-specific definitions */
N#include <linkage.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/linkage.h" 1
N/*****************************************************************************/
N/* linkage.h                                                                 */
N/*                                                                           */
N/* Copyright (c) 1998 Texas Instruments Incorporated                         */
N/* http://www.ti.com/                                                        */
N/*                                                                           */
N/*  Redistribution and  use in source  and binary forms, with  or without    */
N/*  modification,  are permitted provided  that the  following conditions    */
N/*  are met:                                                                 */
N/*                                                                           */
N/*     Redistributions  of source  code must  retain the  above copyright    */
N/*     notice, this list of conditions and the following disclaimer.         */
N/*                                                                           */
N/*     Redistributions in binary form  must reproduce the above copyright    */
N/*     notice, this  list of conditions  and the following  disclaimer in    */
N/*     the  documentation  and/or   other  materials  provided  with  the    */
N/*     distribution.                                                         */
N/*                                                                           */
N/*     Neither the  name of Texas Instruments Incorporated  nor the names    */
N/*     of its  contributors may  be used to  endorse or  promote products    */
N/*     derived  from   this  software  without   specific  prior  written    */
N/*     permission.                                                           */
N/*                                                                           */
N/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS    */
N/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT    */
N/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    */
N/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT    */
N/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    */
N/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT    */
N/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    */
N/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    */
N/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT    */
N/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    */
N/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     */
N/*                                                                           */
N/*****************************************************************************/
N
N#ifndef _LINKAGE
N#define _LINKAGE
N
N#pragma diag_push
N#pragma CHECK_MISRA("-19.4") /* macros required for implementation */
N
N/* No modifiers are needed to access code or data */
N
N#define _CODE_ACCESS
N#define _DATA_ACCESS
N#define _DATA_ACCESS_NEAR
N
N/*--------------------------------------------------------------------------*/
N/* Define _IDECL ==> how inline functions are declared                      */
N/*--------------------------------------------------------------------------*/
N#ifdef _INLINE
S#define _IDECL static __inline
S#define _IDEFN static __inline
N#else
N#define _IDECL extern _CODE_ACCESS
N#define _IDEFN _CODE_ACCESS
N#endif
N
N#pragma diag_pop
N
N#endif /* ifndef _LINKAGE */
L 99 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/_ti_config.h" 2
N
N#pragma diag_pop
N
N#endif /* ifndef __TI_CONFIG_H */
L 42 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/stddef.h" 2
N
N#pragma diag_push
N#pragma CHECK_MISRA("-19.7") /* macros required for implementation */
N#pragma CHECK_MISRA("-20.1") /* standard headers must define standard names */
N#pragma CHECK_MISRA("-20.2") /* standard headers must define standard names */
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
N#ifndef NULL
N#define NULL 0
N#endif
N
Ntypedef __PTRDIFF_T_TYPE__ ptrdiff_t;
Xtypedef int ptrdiff_t;
N
N#ifndef _SIZE_T_DECLARED
N#define _SIZE_T_DECLARED
N# ifdef __clang__
Stypedef __SIZE_TYPE__ __SIZE_T_TYPE__;
N# endif
N
Ntypedef __SIZE_T_TYPE__ size_t;
Xtypedef unsigned size_t;
N#endif
N
N#ifndef __cplusplus
S#ifndef _WCHAR_T_DECLARED
S#define _WCHAR_T_DECLARED
S#ifdef __clang__
Stypedef __WCHAR_TYPE__ __WCHAR_T_TYPE__;
S#endif
S
Stypedef __WCHAR_T_TYPE__ wchar_t;
S
S#endif /* _WCHAR_T */
N#endif /* ! __cplusplus */
N
N/*----------------------------------------------------------------------------*/
N/* C++11 and C11 required max_align_t to be defined. The libc++ cstddef       */
N/* header expects the macro __DEFINED_max_align_t to be defined if it is to   */
N/* use the definintion of max_align_t from stddef.h. Only define it if        */
N/* compiling for C11 or we're in non strict ansi mode.                        */
N/*----------------------------------------------------------------------------*/
N#if defined(_TI_C11LIB) || __TI_STRICT_ANSI_MODE__ == 0
X#if 1L || 0 == 0
N#ifndef __DEFINED_max_align_t
N#define __DEFINED_max_align_t
Ntypedef long double max_align_t;
N#endif /*__DEFINED_max_align_t */
N#endif /* defined(_TI_C11LIB) || __TI_STRICT_ANSI_MODE__ == 0 */
N
N#pragma diag_push
N#pragma CHECK_MISRA("-19.10") /* need types as macro arguments */
N
N#ifdef __TI_LLVM__
S#  define offsetof(_type, _ident) __builtin_offsetof(_type, _ident)
N#else
N#  ifndef __TMS320C55X__
N#      define offsetof(_type, _ident) \
N         ((size_t)__intaddr__(&(((_type *)0)->_ident)))
X#      define offsetof(_type, _ident)          ((size_t)__intaddr__(&(((_type *)0)->_ident)))
N#  else /* __TMS320C55X__ */
S#    define offsetof(_type, _ident) \
S    (__intaddr__( ((char *) &((_type *)0)->_ident) - ((char *) 0) ))
X#    define offsetof(_type, _ident)     (__intaddr__( ((char *) &((_type *)0)->_ident) - ((char *) 0) ))
N#  endif /* __TMS320C55X__ */
N#endif
N
N#pragma diag_pop
N
N#ifdef __cplusplus
N} /* extern "C" */
N#endif  /* __cplusplus */
N
N#pragma diag_pop
N
N#endif  /* _STDDEF */
L 45 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/cstddef" 2
N#include <__nullptr>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/__nullptr" 1
N// -*- C++ -*-
N//===--------------------------- __nullptr --------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is dual licensed under the MIT and the University of Illinois Open
N// Source Licenses. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP_NULLPTR
N#define _LIBCPP_NULLPTR
N
N#include <__config>
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N#ifdef _LIBCPP_HAS_NO_NULLPTR
S
S_LIBCPP_BEGIN_NAMESPACE_STD
S
Sstruct _LIBCPP_TEMPLATE_VIS nullptr_t
S{
S    void* __lx;
S
S    struct __nat {int __for_bool_;};
S
S    _LIBCPP_ALWAYS_INLINE _LIBCPP_CONSTEXPR nullptr_t() : __lx(0) {}
S    _LIBCPP_ALWAYS_INLINE _LIBCPP_CONSTEXPR nullptr_t(int __nat::*) : __lx(0) {}
S
S    _LIBCPP_ALWAYS_INLINE _LIBCPP_CONSTEXPR operator int __nat::*() const {return 0;}
S
S    template <class _Tp>
S        _LIBCPP_ALWAYS_INLINE _LIBCPP_CONSTEXPR
S        operator _Tp* () const {return 0;}
S
S    template <class _Tp, class _Up>
S        _LIBCPP_ALWAYS_INLINE
S        operator _Tp _Up::* () const {return 0;}
S
S    friend _LIBCPP_ALWAYS_INLINE _LIBCPP_CONSTEXPR bool operator==(nullptr_t, nullptr_t) {return true;}
S    friend _LIBCPP_ALWAYS_INLINE _LIBCPP_CONSTEXPR bool operator!=(nullptr_t, nullptr_t) {return false;}
S};
S
Sinline _LIBCPP_ALWAYS_INLINE _LIBCPP_CONSTEXPR nullptr_t __get_nullptr_t() {return nullptr_t(0);}
S
S#define nullptr _VSTD::__get_nullptr_t()
S
S_LIBCPP_END_NAMESPACE_STD
S
N#else  // _LIBCPP_HAS_NO_NULLPTR
N
Nnamespace std
N{
N    typedef decltype(nullptr) nullptr_t;
N}
N
N#endif  // _LIBCPP_HAS_NO_NULLPTR
N
N#endif  // _LIBCPP_NULLPTR
L 46 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/cstddef" 2
N
N_LIBCPP_BEGIN_NAMESPACE_STD
Xnamespace std { inline namespace __2 {
N
Nusing ::ptrdiff_t;
Nusing ::size_t;
N
N#if defined(__CLANG_MAX_ALIGN_T_DEFINED) || defined(_GCC_MAX_ALIGN_T) || \
N    defined(__DEFINED_max_align_t)
X#if 0L || 0L ||     1L
N// Re-use the compiler's <stddef.h> max_align_t where possible.
Nusing ::max_align_t;
N#else
Stypedef long double max_align_t;
N#endif
N
N_LIBCPP_END_NAMESPACE_STD
X} }
N
N#if _LIBCPP_STD_VER > 14
X#if 14 > 14
Snamespace std  // purposefully not versioned
S{
Senum class byte : unsigned char {};
S
Sconstexpr byte& operator|=(byte& __lhs, byte __rhs) noexcept
S{ return __lhs = byte(static_cast<unsigned char>(__lhs) | static_cast<unsigned char>(__rhs)); }
Sconstexpr byte  operator| (byte  __lhs, byte __rhs) noexcept
S{ return         byte(static_cast<unsigned char>(__lhs) | static_cast<unsigned char>(__rhs)); }
S
Sconstexpr byte& operator&=(byte& __lhs, byte __rhs) noexcept
S{ return __lhs = byte(static_cast<unsigned char>(__lhs) & static_cast<unsigned char>(__rhs)); }
Sconstexpr byte  operator& (byte  __lhs, byte __rhs) noexcept
S{ return         byte(static_cast<unsigned char>(__lhs) & static_cast<unsigned char>(__rhs)); }
S
Sconstexpr byte& operator^=(byte& __lhs, byte __rhs) noexcept 
S{ return __lhs = byte(static_cast<unsigned char>(__lhs) ^ static_cast<unsigned char>(__rhs)); }
Sconstexpr byte  operator^ (byte  __lhs, byte __rhs) noexcept
S{ return         byte(static_cast<unsigned char>(__lhs) ^ static_cast<unsigned char>(__rhs)); }
S
Sconstexpr byte  operator~ (byte __b) noexcept
S{ return  byte(~static_cast<unsigned char>(__b)); }
S
S}
S
S#include <type_traits>  // rest of byte
N#endif
N
N#endif  // _LIBCPP_CSTDDEF
L 48 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/initializer_list" 2
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
Nnamespace std  // purposefully not versioned
N{
N
N#ifndef _LIBCPP_CXX03_LANG
N
Ntemplate<class _Ep>
Nclass _LIBCPP_TEMPLATE_VIS initializer_list
Xclass  initializer_list
N{
N    const _Ep* __begin_;
N    size_t    __size_;
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    _LIBCPP_CONSTEXPR_AFTER_CXX11
X    constexpr
N    initializer_list(const _Ep* __b, size_t __s) _NOEXCEPT
X    initializer_list(const _Ep* __b, size_t __s) noexcept
N        : __begin_(__b),
N          __size_(__s)
N        {}
Npublic:
N    typedef _Ep        value_type;
N    typedef const _Ep& reference;
N    typedef const _Ep& const_reference;
N    typedef size_t    size_type;
N
N    typedef const _Ep* iterator;
N    typedef const _Ep* const_iterator;
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    _LIBCPP_CONSTEXPR_AFTER_CXX11
X    constexpr
N    initializer_list() _NOEXCEPT : __begin_(nullptr), __size_(0) {}
X    initializer_list() noexcept : __begin_(nullptr), __size_(0) {}
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    _LIBCPP_CONSTEXPR_AFTER_CXX11
X    constexpr
N    size_t    size()  const _NOEXCEPT {return __size_;}
X    size_t    size()  const noexcept {return __size_;}
N    
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    _LIBCPP_CONSTEXPR_AFTER_CXX11
X    constexpr
N    const _Ep* begin() const _NOEXCEPT {return __begin_;}
X    const _Ep* begin() const noexcept {return __begin_;}
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    _LIBCPP_CONSTEXPR_AFTER_CXX11
X    constexpr
N    const _Ep* end()   const _NOEXCEPT {return __begin_ + __size_;}
X    const _Ep* end()   const noexcept {return __begin_ + __size_;}
N};
N
Ntemplate<class _Ep>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_LIBCPP_CONSTEXPR_AFTER_CXX11
Xconstexpr
Nconst _Ep*
Nbegin(initializer_list<_Ep> __il) _NOEXCEPT
Xbegin(initializer_list<_Ep> __il) noexcept
N{
N    return __il.begin();
N}
N
Ntemplate<class _Ep>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_LIBCPP_CONSTEXPR_AFTER_CXX11
Xconstexpr
Nconst _Ep*
Nend(initializer_list<_Ep> __il) _NOEXCEPT
Xend(initializer_list<_Ep> __il) noexcept
N{
N    return __il.end();
N}
N
N#endif  // !defined(_LIBCPP_CXX03_LANG)
N
N}  // std
N
N#endif  // _LIBCPP_INITIALIZER_LIST
L 640 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/algorithm" 2
N#include <type_traits>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/type_traits" 1
N// -*- C++ -*-
N//===------------------------ type_traits ---------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is dual licensed under the MIT and the University of Illinois Open
N// Source Licenses. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP_TYPE_TRAITS
N#define _LIBCPP_TYPE_TRAITS
N
N/*
N    type_traits synopsis
N
Nnamespace std
N{
N
N    // helper class:
N    template <class T, T v> struct integral_constant;
N    typedef integral_constant<bool, true>  true_type;   // C++11
N    typedef integral_constant<bool, false> false_type;  // C++11
N    
N    template <bool B>                                   // C++14
N    using bool_constant = integral_constant<bool, B>;   // C++14
N    typedef bool_constant<true> true_type;              // C++14
N    typedef bool_constant<false> false_type;            // C++14
N
N    // helper traits
N    template <bool, class T = void> struct enable_if;
N    template <bool, class T, class F> struct conditional;
N
N    // Primary classification traits:
N    template <class T> struct is_void;
N    template <class T> struct is_null_pointer;  // C++14
N    template <class T> struct is_integral;
N    template <class T> struct is_floating_point;
N    template <class T> struct is_array;
N    template <class T> struct is_pointer;
N    template <class T> struct is_lvalue_reference;
N    template <class T> struct is_rvalue_reference;
N    template <class T> struct is_member_object_pointer;
N    template <class T> struct is_member_function_pointer;
N    template <class T> struct is_enum;
N    template <class T> struct is_union;
N    template <class T> struct is_class;
N    template <class T> struct is_function;
N
N    // Secondary classification traits:
N    template <class T> struct is_reference;
N    template <class T> struct is_arithmetic;
N    template <class T> struct is_fundamental;
N    template <class T> struct is_member_pointer;
N    template <class T> struct is_scalar;
N    template <class T> struct is_object;
N    template <class T> struct is_compound;
N
N    // Const-volatile properties and transformations:
N    template <class T> struct is_const;
N    template <class T> struct is_volatile;
N    template <class T> struct remove_const;
N    template <class T> struct remove_volatile;
N    template <class T> struct remove_cv;
N    template <class T> struct add_const;
N    template <class T> struct add_volatile;
N    template <class T> struct add_cv;
N
N    // Reference transformations:
N    template <class T> struct remove_reference;
N    template <class T> struct add_lvalue_reference;
N    template <class T> struct add_rvalue_reference;
N
N    // Pointer transformations:
N    template <class T> struct remove_pointer;
N    template <class T> struct add_pointer;
N
N    // Integral properties:
N    template <class T> struct is_signed;
N    template <class T> struct is_unsigned;
N    template <class T> struct make_signed;
N    template <class T> struct make_unsigned;
N
N    // Array properties and transformations:
N    template <class T> struct rank;
N    template <class T, unsigned I = 0> struct extent;
N    template <class T> struct remove_extent;
N    template <class T> struct remove_all_extents;
N
N    // Member introspection:
N    template <class T> struct is_pod;
N    template <class T> struct is_trivial;
N    template <class T> struct is_trivially_copyable;
N    template <class T> struct is_standard_layout;
N    template <class T> struct is_literal_type;
N    template <class T> struct is_empty;
N    template <class T> struct is_polymorphic;
N    template <class T> struct is_abstract;
N    template <class T> struct is_final; // C++14
N    template <class T> struct is_aggregate; // C++17
N
N    template <class T, class... Args> struct is_constructible;
N    template <class T>                struct is_default_constructible;
N    template <class T>                struct is_copy_constructible;
N    template <class T>                struct is_move_constructible;
N    template <class T, class U>       struct is_assignable;
N    template <class T>                struct is_copy_assignable;
N    template <class T>                struct is_move_assignable;
N    template <class T, class U>       struct is_swappable_with;       // C++17
N    template <class T>                struct is_swappable;            // C++17
N    template <class T>                struct is_destructible;
N
N    template <class T, class... Args> struct is_trivially_constructible;
N    template <class T>                struct is_trivially_default_constructible;
N    template <class T>                struct is_trivially_copy_constructible;
N    template <class T>                struct is_trivially_move_constructible;
N    template <class T, class U>       struct is_trivially_assignable;
N    template <class T>                struct is_trivially_copy_assignable;
N    template <class T>                struct is_trivially_move_assignable;
N    template <class T>                struct is_trivially_destructible;
N
N    template <class T, class... Args> struct is_nothrow_constructible;
N    template <class T>                struct is_nothrow_default_constructible;
N    template <class T>                struct is_nothrow_copy_constructible;
N    template <class T>                struct is_nothrow_move_constructible;
N    template <class T, class U>       struct is_nothrow_assignable;
N    template <class T>                struct is_nothrow_copy_assignable;
N    template <class T>                struct is_nothrow_move_assignable;
N    template <class T, class U>       struct is_nothrow_swappable_with; // C++17
N    template <class T>                struct is_nothrow_swappable;      // C++17
N    template <class T>                struct is_nothrow_destructible;
N
N    template <class T> struct has_virtual_destructor;
N
N    // Relationships between types:
N    template <class T, class U> struct is_same;
N    template <class Base, class Derived> struct is_base_of;
N    template <class From, class To> struct is_convertible;
N
N    template <class, class R = void> struct is_callable; // not defined
N    template <class Fn, class... ArgTypes, class R>
N      struct is_callable<Fn(ArgTypes...), R>;
N
N    template <class, class R = void> struct is_nothrow_callable; // not defined
N    template <class Fn, class... ArgTypes, class R>
N      struct is_nothrow_callable<Fn(ArgTypes...), R>;
N
N    // Alignment properties and transformations:
N    template <class T> struct alignment_of;
N    template <size_t Len, size_t Align = most_stringent_alignment_requirement>
N        struct aligned_storage;
N    template <size_t Len, class... Types> struct aligned_union;
N
N    template <class T> struct decay;
N    template <class... T> struct common_type;
N    template <class T> struct underlying_type;
N    template <class> class result_of; // undefined
N    template <class Fn, class... ArgTypes> class result_of<Fn(ArgTypes...)>;
N
N    // const-volatile modifications:
N    template <class T>
N      using remove_const_t    = typename remove_const<T>::type;  // C++14
N    template <class T>
N      using remove_volatile_t = typename remove_volatile<T>::type;  // C++14
N    template <class T>
N      using remove_cv_t       = typename remove_cv<T>::type;  // C++14
N    template <class T>
N      using add_const_t       = typename add_const<T>::type;  // C++14
N    template <class T>
N      using add_volatile_t    = typename add_volatile<T>::type;  // C++14
N    template <class T>
N      using add_cv_t          = typename add_cv<T>::type;  // C++14
N  
N    // reference modifications:
N    template <class T>
N      using remove_reference_t     = typename remove_reference<T>::type;  // C++14
N    template <class T>
N      using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;  // C++14
N    template <class T>
N      using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;  // C++14
N  
N    // sign modifications:
N    template <class T>
N      using make_signed_t   = typename make_signed<T>::type;  // C++14
N    template <class T>
N      using make_unsigned_t = typename make_unsigned<T>::type;  // C++14
N  
N    // array modifications:
N    template <class T>
N      using remove_extent_t      = typename remove_extent<T>::type;  // C++14
N    template <class T>
N      using remove_all_extents_t = typename remove_all_extents<T>::type;  // C++14
N
N    // pointer modifications:
N    template <class T>
N      using remove_pointer_t = typename remove_pointer<T>::type;  // C++14
N    template <class T>
N      using add_pointer_t    = typename add_pointer<T>::type;  // C++14
N
N    // other transformations:
N    template <size_t Len, std::size_t Align=default-alignment>
N      using aligned_storage_t = typename aligned_storage<Len,Align>::type;  // C++14
N    template <std::size_t Len, class... Types>
N      using aligned_union_t   = typename aligned_union<Len,Types...>::type;  // C++14
N    template <class T>
N      using decay_t           = typename decay<T>::type;  // C++14
N    template <bool b, class T=void>
N      using enable_if_t       = typename enable_if<b,T>::type;  // C++14
N    template <bool b, class T, class F>
N      using conditional_t     = typename conditional<b,T,F>::type;  // C++14
N    template <class... T>
N      using common_type_t     = typename common_type<T...>::type;  // C++14
N    template <class T>
N      using underlying_type_t = typename underlying_type<T>::type;  // C++14
N    template <class F, class... ArgTypes>
N      using result_of_t       = typename result_of<F(ArgTypes...)>::type;  // C++14
N
N    template <class...>
N      using void_t = void;   // C++17
N      
N      // See C++14 20.10.4.1, primary type categories
N      template <class T> constexpr bool is_void_v
N        = is_void<T>::value;                                             // C++17
N      template <class T> constexpr bool is_null_pointer_v
N        = is_null_pointer<T>::value;                                     // C++17
N      template <class T> constexpr bool is_integral_v
N        = is_integral<T>::value;                                         // C++17
N      template <class T> constexpr bool is_floating_point_v
N        = is_floating_point<T>::value;                                   // C++17
N      template <class T> constexpr bool is_array_v
N        = is_array<T>::value;                                            // C++17
N      template <class T> constexpr bool is_pointer_v
N        = is_pointer<T>::value;                                          // C++17
N      template <class T> constexpr bool is_lvalue_reference_v
N        = is_lvalue_reference<T>::value;                                 // C++17
N      template <class T> constexpr bool is_rvalue_reference_v
N        = is_rvalue_reference<T>::value;                                 // C++17
N      template <class T> constexpr bool is_member_object_pointer_v
N        = is_member_object_pointer<T>::value;                            // C++17
N      template <class T> constexpr bool is_member_function_pointer_v
N        = is_member_function_pointer<T>::value;                          // C++17
N      template <class T> constexpr bool is_enum_v
N        = is_enum<T>::value;                                             // C++17
N      template <class T> constexpr bool is_union_v
N        = is_union<T>::value;                                            // C++17
N      template <class T> constexpr bool is_class_v
N        = is_class<T>::value;                                            // C++17
N      template <class T> constexpr bool is_function_v
N        = is_function<T>::value;                                         // C++17
N
N      // See C++14 20.10.4.2, composite type categories
N      template <class T> constexpr bool is_reference_v
N        = is_reference<T>::value;                                        // C++17
N      template <class T> constexpr bool is_arithmetic_v
N        = is_arithmetic<T>::value;                                       // C++17
N      template <class T> constexpr bool is_fundamental_v
N        = is_fundamental<T>::value;                                      // C++17
N      template <class T> constexpr bool is_object_v
N        = is_object<T>::value;                                           // C++17
N      template <class T> constexpr bool is_scalar_v
N        = is_scalar<T>::value;                                           // C++17
N      template <class T> constexpr bool is_compound_v
N        = is_compound<T>::value;                                         // C++17
N      template <class T> constexpr bool is_member_pointer_v
N        = is_member_pointer<T>::value;                                   // C++17
N
N      // See C++14 20.10.4.3, type properties
N      template <class T> constexpr bool is_const_v
N        = is_const<T>::value;                                            // C++17
N      template <class T> constexpr bool is_volatile_v
N        = is_volatile<T>::value;                                         // C++17
N      template <class T> constexpr bool is_trivial_v
N        = is_trivial<T>::value;                                          // C++17
N      template <class T> constexpr bool is_trivially_copyable_v
N        = is_trivially_copyable<T>::value;                               // C++17
N      template <class T> constexpr bool is_standard_layout_v
N        = is_standard_layout<T>::value;                                  // C++17
N      template <class T> constexpr bool is_pod_v
N        = is_pod<T>::value;                                              // C++17
N      template <class T> constexpr bool is_literal_type_v
N        = is_literal_type<T>::value;                                     // C++17
N      template <class T> constexpr bool is_empty_v
N        = is_empty<T>::value;                                            // C++17
N      template <class T> constexpr bool is_polymorphic_v
N        = is_polymorphic<T>::value;                                      // C++17
N      template <class T> constexpr bool is_abstract_v
N        = is_abstract<T>::value;                                         // C++17
N      template <class T> constexpr bool is_final_v
N        = is_final<T>::value;                                            // C++17
N      template <class T> constexpr bool is_aggregate_v
N        = is_aggregate<T>::value;                                        // C++17
N      template <class T> constexpr bool is_signed_v
N        = is_signed<T>::value;                                           // C++17
N      template <class T> constexpr bool is_unsigned_v
N        = is_unsigned<T>::value;                                         // C++17
N      template <class T, class... Args> constexpr bool is_constructible_v
N        = is_constructible<T, Args...>::value;                           // C++17
N      template <class T> constexpr bool is_default_constructible_v
N        = is_default_constructible<T>::value;                            // C++17
N      template <class T> constexpr bool is_copy_constructible_v
N        = is_copy_constructible<T>::value;                               // C++17
N      template <class T> constexpr bool is_move_constructible_v
N        = is_move_constructible<T>::value;                               // C++17
N      template <class T, class U> constexpr bool is_assignable_v
N        = is_assignable<T, U>::value;                                    // C++17
N      template <class T> constexpr bool is_copy_assignable_v
N        = is_copy_assignable<T>::value;                                  // C++17
N      template <class T> constexpr bool is_move_assignable_v
N        = is_move_assignable<T>::value;                                  // C++17
N      template <class T, class U> constexpr bool is_swappable_with_v
N        = is_swappable_with<T, U>::value;                                // C++17
N      template <class T> constexpr bool is_swappable_v
N        = is_swappable<T>::value;                                        // C++17
N      template <class T> constexpr bool is_destructible_v
N        = is_destructible<T>::value;                                     // C++17
N      template <class T, class... Args> constexpr bool is_trivially_constructible_v
N        = is_trivially_constructible<T, Args...>::value;                 // C++17
N      template <class T> constexpr bool is_trivially_default_constructible_v
N        = is_trivially_default_constructible<T>::value;                  // C++17
N      template <class T> constexpr bool is_trivially_copy_constructible_v
N        = is_trivially_copy_constructible<T>::value;                     // C++17
N      template <class T> constexpr bool is_trivially_move_constructible_v
N        = is_trivially_move_constructible<T>::value;                     // C++17
N      template <class T, class U> constexpr bool is_trivially_assignable_v
N        = is_trivially_assignable<T, U>::value;                          // C++17
N      template <class T> constexpr bool is_trivially_copy_assignable_v
N        = is_trivially_copy_assignable<T>::value;                        // C++17
N      template <class T> constexpr bool is_trivially_move_assignable_v
N        = is_trivially_move_assignable<T>::value;                        // C++17
N      template <class T> constexpr bool is_trivially_destructible_v
N        = is_trivially_destructible<T>::value;                           // C++17
N      template <class T, class... Args> constexpr bool is_nothrow_constructible_v
N        = is_nothrow_constructible<T, Args...>::value;                   // C++17
N      template <class T> constexpr bool is_nothrow_default_constructible_v
N        = is_nothrow_default_constructible<T>::value;                    // C++17
N      template <class T> constexpr bool is_nothrow_copy_constructible_v
N        = is_nothrow_copy_constructible<T>::value;                       // C++17
N      template <class T> constexpr bool is_nothrow_move_constructible_v
N        = is_nothrow_move_constructible<T>::value;                       // C++17
N      template <class T, class U> constexpr bool is_nothrow_assignable_v
N        = is_nothrow_assignable<T, U>::value;                            // C++17
N      template <class T> constexpr bool is_nothrow_copy_assignable_v
N        = is_nothrow_copy_assignable<T>::value;                          // C++17
N      template <class T> constexpr bool is_nothrow_move_assignable_v
N        = is_nothrow_move_assignable<T>::value;                          // C++17
N      template <class T, class U> constexpr bool is_nothrow_swappable_with_v
N        = is_nothrow_swappable_with<T, U>::value;                       // C++17
N      template <class T> constexpr bool is_nothrow_swappable_v
N        = is_nothrow_swappable<T>::value;                               // C++17
N      template <class T> constexpr bool is_nothrow_destructible_v
N        = is_nothrow_destructible<T>::value;                             // C++17
N      template <class T> constexpr bool has_virtual_destructor_v
N        = has_virtual_destructor<T>::value;                              // C++17
N
N      // See C++14 20.10.5, type property queries
N      template <class T> constexpr size_t alignment_of_v
N        = alignment_of<T>::value;                                        // C++17
N      template <class T> constexpr size_t rank_v
N        = rank<T>::value;                                                // C++17
N      template <class T, unsigned I = 0> constexpr size_t extent_v
N        = extent<T, I>::value;                                           // C++17
N
N      // See C++14 20.10.6, type relations
N      template <class T, class U> constexpr bool is_same_v
N        = is_same<T, U>::value;                                          // C++17
N      template <class Base, class Derived> constexpr bool is_base_of_v
N        = is_base_of<Base, Derived>::value;                              // C++17
N      template <class From, class To> constexpr bool is_convertible_v
N        = is_convertible<From, To>::value;                               // C++17
N      template <class T, class R = void> constexpr bool is_callable_v
N        = is_callable<T, R>::value;                                      // C++17
N      template <class T, class R = void> constexpr bool is_nothrow_callable_v
N        = is_nothrow_callable<T, R>::value;                              // C++17
N
N      // [meta.logical], logical operator traits:
N      template<class... B> struct conjunction;                           // C++17
N      template<class... B> 
N        constexpr bool conjunction_v = conjunction<B...>::value;         // C++17
N      template<class... B> struct disjunction;                           // C++17
N      template<class... B>
N        constexpr bool disjunction_v = disjunction<B...>::value;         // C++17
N      template<class B> struct negation;                                 // C++17
N      template<class B> 
N        constexpr bool negation_v = negation<B>::value;                  // C++17
N
N}
N
N*/
N#include <__config>
N#include <cstddef>
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N_LIBCPP_BEGIN_NAMESPACE_STD
Xnamespace std { inline namespace __2 {
N
Ntemplate <class _T1, class _T2> struct _LIBCPP_TEMPLATE_VIS pair;
Xtemplate <class _T1, class _T2> struct  pair;
Ntemplate <class _Tp> class _LIBCPP_TEMPLATE_VIS reference_wrapper;
Xtemplate <class _Tp> class  reference_wrapper;
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS hash;
Xtemplate <class _Tp> struct  hash;
N
Ntemplate <class>
Nstruct __void_t { typedef void type; };
N
Ntemplate <class _Tp>
Nstruct __identity { typedef _Tp type; };
N
Ntemplate <class _Tp, bool>
Nstruct _LIBCPP_TEMPLATE_VIS __dependent_type : public _Tp {};
Xstruct  __dependent_type : public _Tp {};
N
Ntemplate <bool _Bp, class _If, class _Then>
N    struct _LIBCPP_TEMPLATE_VIS conditional {typedef _If type;};
X    struct  conditional {typedef _If type;};
Ntemplate <class _If, class _Then>
N    struct _LIBCPP_TEMPLATE_VIS conditional<false, _If, _Then> {typedef _Then type;};
X    struct  conditional<false, _If, _Then> {typedef _Then type;};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <bool _Bp, class _If, class _Then> using conditional_t = typename conditional<_Bp, _If, _Then>::type;
N#endif
N
Ntemplate <bool, class _Tp> struct _LIBCPP_TEMPLATE_VIS __lazy_enable_if {};
Xtemplate <bool, class _Tp> struct  __lazy_enable_if {};
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS __lazy_enable_if<true, _Tp> {typedef typename _Tp::type type;};
Xtemplate <class _Tp> struct  __lazy_enable_if<true, _Tp> {typedef typename _Tp::type type;};
N
Ntemplate <bool, class _Tp = void> struct _LIBCPP_TEMPLATE_VIS enable_if {};
Xtemplate <bool, class _Tp = void> struct  enable_if {};
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS enable_if<true, _Tp> {typedef _Tp type;};
Xtemplate <class _Tp> struct  enable_if<true, _Tp> {typedef _Tp type;};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <bool _Bp, class _Tp = void> using enable_if_t = typename enable_if<_Bp, _Tp>::type;
N#endif
N
N// addressof
N#ifndef _LIBCPP_HAS_NO_BUILTIN_ADDRESSOF
N
Ntemplate <class _Tp>
Ninline _LIBCPP_CONSTEXPR_AFTER_CXX14
Xinline 
N_LIBCPP_NO_CFI _LIBCPP_INLINE_VISIBILITY
X __attribute__ ((__always_inline__))
N_Tp*
Naddressof(_Tp& __x) _NOEXCEPT
Xaddressof(_Tp& __x) noexcept
N{
N    return __builtin_addressof(__x);
N}
N
N#else
S
Stemplate <class _Tp>
Sinline _LIBCPP_NO_CFI _LIBCPP_INLINE_VISIBILITY
S_Tp*
Saddressof(_Tp& __x) _NOEXCEPT
S{
S  return reinterpret_cast<_Tp *>(
S      const_cast<char *>(&reinterpret_cast<const volatile char &>(__x)));
S}
S
N#endif // _LIBCPP_HAS_NO_BUILTIN_ADDRESSOF
N
N#if defined(_LIBCPP_HAS_OBJC_ARC) && !defined(_LIBCPP_PREDEFINED_OBJC_ARC_ADDRESSOF)
X#if 0L && !0L
S// Objective-C++ Automatic Reference Counting uses qualified pointers
S// that require special addressof() signatures. When
S// _LIBCPP_PREDEFINED_OBJC_ARC_ADDRESSOF is defined, the compiler
S// itself is providing these definitions. Otherwise, we provide them.
Stemplate <class _Tp>
Sinline _LIBCPP_INLINE_VISIBILITY
S__strong _Tp*
Saddressof(__strong _Tp& __x) _NOEXCEPT
S{
S  return &__x;
S}
S
S#ifdef _LIBCPP_HAS_OBJC_ARC_WEAK
Stemplate <class _Tp>
Sinline _LIBCPP_INLINE_VISIBILITY
S__weak _Tp*
Saddressof(__weak _Tp& __x) _NOEXCEPT
S{
S  return &__x;
S}
S#endif
S
Stemplate <class _Tp>
Sinline _LIBCPP_INLINE_VISIBILITY
S__autoreleasing _Tp*
Saddressof(__autoreleasing _Tp& __x) _NOEXCEPT
S{
S  return &__x;
S}
S
Stemplate <class _Tp>
Sinline _LIBCPP_INLINE_VISIBILITY
S__unsafe_unretained _Tp*
Saddressof(__unsafe_unretained _Tp& __x) _NOEXCEPT
S{
S  return &__x;
S}
N#endif
N
N#if !defined(_LIBCPP_CXX03_LANG)
X#if !0L
Ntemplate <class _Tp> _Tp* addressof(const _Tp&&) noexcept = delete;
N#endif
N
Nstruct __two {char __lx[2];};
N
N// helper class:
N
Ntemplate <class _Tp, _Tp __v>
Nstruct _LIBCPP_TEMPLATE_VIS integral_constant
Xstruct  integral_constant
N{
N    static _LIBCPP_CONSTEXPR const _Tp      value = __v;
X    static constexpr const _Tp      value = __v;
N    typedef _Tp               value_type;
N    typedef integral_constant type;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N        _LIBCPP_CONSTEXPR operator value_type() const _NOEXCEPT {return value;}
X        constexpr operator value_type() const noexcept {return value;}
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N         constexpr value_type operator ()() const _NOEXCEPT {return value;}
X         constexpr value_type operator ()() const noexcept {return value;}
N#endif
N};
N
Ntemplate <class _Tp, _Tp __v>
N_LIBCPP_CONSTEXPR const _Tp integral_constant<_Tp, __v>::value;
Xconstexpr const _Tp integral_constant<_Tp, __v>::value;
N
N#if _LIBCPP_STD_VER > 14
X#if 14 > 14
Stemplate <bool __b>
Susing bool_constant = integral_constant<bool, __b>;
S#define _LIBCPP_BOOL_CONSTANT(__b) bool_constant<(__b)>
N#else
N#define _LIBCPP_BOOL_CONSTANT(__b) integral_constant<bool,(__b)>
N#endif
N
Ntypedef _LIBCPP_BOOL_CONSTANT(true)  true_type;
Xtypedef integral_constant<bool,(true)>  true_type;
Ntypedef _LIBCPP_BOOL_CONSTANT(false) false_type;
Xtypedef integral_constant<bool,(false)> false_type;
N
N#if !defined(_LIBCPP_CXX03_LANG)
X#if !0L
N
N// __lazy_and
N
Ntemplate <bool _Last, class ..._Preds>
Nstruct __lazy_and_impl;
N
Ntemplate <class ..._Preds>
Nstruct __lazy_and_impl<false, _Preds...> : false_type {};
N
Ntemplate <>
Nstruct __lazy_and_impl<true> : true_type {};
N
Ntemplate <class _Pred>
Nstruct __lazy_and_impl<true, _Pred> : integral_constant<bool, _Pred::type::value> {};
N
Ntemplate <class _Hp, class ..._Tp>
Nstruct __lazy_and_impl<true, _Hp, _Tp...> : __lazy_and_impl<_Hp::type::value, _Tp...> {};
N
Ntemplate <class _P1, class ..._Pr>
Nstruct __lazy_and : __lazy_and_impl<_P1::type::value, _Pr...> {};
N
N// __lazy_or
N
Ntemplate <bool _List, class ..._Preds>
Nstruct __lazy_or_impl;
N
Ntemplate <class ..._Preds>
Nstruct __lazy_or_impl<true, _Preds...> : true_type {};
N
Ntemplate <>
Nstruct __lazy_or_impl<false> : false_type {};
N
Ntemplate <class _Hp, class ..._Tp>
Nstruct __lazy_or_impl<false, _Hp, _Tp...>
N        : __lazy_or_impl<_Hp::type::value, _Tp...> {};
N
Ntemplate <class _P1, class ..._Pr>
Nstruct __lazy_or : __lazy_or_impl<_P1::type::value, _Pr...> {};
N
N// __lazy_not
N
Ntemplate <class _Pred>
Nstruct __lazy_not : integral_constant<bool, !_Pred::type::value> {};
N
N// __and_
Ntemplate<class...> struct __and_;
Ntemplate<> struct __and_<> : true_type {};
N
Ntemplate<class _B0> struct __and_<_B0> : _B0 {};
N
Ntemplate<class _B0, class _B1>
Nstruct __and_<_B0, _B1> : conditional<_B0::value, _B1, _B0>::type {};
N
Ntemplate<class _B0, class _B1, class _B2, class... _Bn>
Nstruct __and_<_B0, _B1, _B2, _Bn...> 
N        : conditional<_B0::value, __and_<_B1, _B2, _Bn...>, _B0>::type {};
N
N// __or_
Ntemplate<class...> struct __or_;
Ntemplate<> struct __or_<> : false_type {};
N
Ntemplate<class _B0> struct __or_<_B0> : _B0 {};
N
Ntemplate<class _B0, class _B1>
Nstruct __or_<_B0, _B1> : conditional<_B0::value, _B0, _B1>::type {};
N
Ntemplate<class _B0, class _B1, class _B2, class... _Bn>
Nstruct __or_<_B0, _B1, _B2, _Bn...> 
N        : conditional<_B0::value, _B0, __or_<_B1, _B2, _Bn...> >::type {};
N
N// __not_
Ntemplate<class _Tp> 
Nstruct __not_ : conditional<_Tp::value, false_type, true_type>::type {};
N
N#endif // !defined(_LIBCPP_CXX03_LANG)
N
N// is_const
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_const            : public false_type {};
Xtemplate <class _Tp> struct  is_const            : public false_type {};
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_const<_Tp const> : public true_type {};
Xtemplate <class _Tp> struct  is_const<_Tp const> : public true_type {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_const_v
S    = is_const<_Tp>::value;
N#endif
N
N// is_volatile
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_volatile               : public false_type {};
Xtemplate <class _Tp> struct  is_volatile               : public false_type {};
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_volatile<_Tp volatile> : public true_type {};
Xtemplate <class _Tp> struct  is_volatile<_Tp volatile> : public true_type {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_volatile_v
S    = is_volatile<_Tp>::value;
N#endif
N
N// remove_const
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_const            {typedef _Tp type;};
Xtemplate <class _Tp> struct  remove_const            {typedef _Tp type;};
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_const<const _Tp> {typedef _Tp type;};
Xtemplate <class _Tp> struct  remove_const<const _Tp> {typedef _Tp type;};
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _Tp> using remove_const_t = typename remove_const<_Tp>::type;
N#endif
N
N// remove_volatile
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_volatile               {typedef _Tp type;};
Xtemplate <class _Tp> struct  remove_volatile               {typedef _Tp type;};
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_volatile<volatile _Tp> {typedef _Tp type;};
Xtemplate <class _Tp> struct  remove_volatile<volatile _Tp> {typedef _Tp type;};
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _Tp> using remove_volatile_t = typename remove_volatile<_Tp>::type;
N#endif
N
N// remove_cv
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_cv
Xtemplate <class _Tp> struct  remove_cv
N{typedef typename remove_volatile<typename remove_const<_Tp>::type>::type type;};
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _Tp> using remove_cv_t = typename remove_cv<_Tp>::type;
N#endif
N
N// is_void
N
Ntemplate <class _Tp> struct __libcpp_is_void       : public false_type {};
Ntemplate <>          struct __libcpp_is_void<void> : public true_type {};
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_void
Xtemplate <class _Tp> struct  is_void
N    : public __libcpp_is_void<typename remove_cv<_Tp>::type> {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_void_v
S    = is_void<_Tp>::value;
N#endif
N
N// __is_nullptr_t
N
Ntemplate <class _Tp> struct __is_nullptr_t_impl       : public false_type {};
Ntemplate <>          struct __is_nullptr_t_impl<nullptr_t> : public true_type {};
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS __is_nullptr_t
Xtemplate <class _Tp> struct  __is_nullptr_t
N    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_null_pointer
Xtemplate <class _Tp> struct  is_null_pointer
N    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_null_pointer_v
S    = is_null_pointer<_Tp>::value;
N#endif
N#endif
N
N// is_integral
N
Ntemplate <class _Tp> struct __libcpp_is_integral                     : public false_type {};
Ntemplate <>          struct __libcpp_is_integral<bool>               : public true_type {};
Ntemplate <>          struct __libcpp_is_integral<char>               : public true_type {};
Ntemplate <>          struct __libcpp_is_integral<signed char>        : public true_type {};
Ntemplate <>          struct __libcpp_is_integral<unsigned char>      : public true_type {};
Ntemplate <>          struct __libcpp_is_integral<wchar_t>            : public true_type {};
N#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
Ntemplate <>          struct __libcpp_is_integral<char16_t>           : public true_type {};
Ntemplate <>          struct __libcpp_is_integral<char32_t>           : public true_type {};
N#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS
Ntemplate <>          struct __libcpp_is_integral<short>              : public true_type {};
Ntemplate <>          struct __libcpp_is_integral<unsigned short>     : public true_type {};
Ntemplate <>          struct __libcpp_is_integral<int>                : public true_type {};
Ntemplate <>          struct __libcpp_is_integral<unsigned int>       : public true_type {};
Ntemplate <>          struct __libcpp_is_integral<long>               : public true_type {};
Ntemplate <>          struct __libcpp_is_integral<unsigned long>      : public true_type {};
Ntemplate <>          struct __libcpp_is_integral<long long>          : public true_type {};
Ntemplate <>          struct __libcpp_is_integral<unsigned long long> : public true_type {};
N#ifndef _LIBCPP_HAS_NO_INT128
Stemplate <>          struct __libcpp_is_integral<__int128_t>         : public true_type {};
Stemplate <>          struct __libcpp_is_integral<__uint128_t>        : public true_type {};
N#endif
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_integral
Xtemplate <class _Tp> struct  is_integral
N    : public __libcpp_is_integral<typename remove_cv<_Tp>::type> {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_integral_v
S    = is_integral<_Tp>::value;
N#endif
N
N// is_floating_point
N
Ntemplate <class _Tp> struct __libcpp_is_floating_point              : public false_type {};
Ntemplate <>          struct __libcpp_is_floating_point<float>       : public true_type {};
Ntemplate <>          struct __libcpp_is_floating_point<double>      : public true_type {};
Ntemplate <>          struct __libcpp_is_floating_point<long double> : public true_type {};
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_floating_point
Xtemplate <class _Tp> struct  is_floating_point
N    : public __libcpp_is_floating_point<typename remove_cv<_Tp>::type> {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_floating_point_v
S    = is_floating_point<_Tp>::value;
N#endif
N
N// is_array
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_array
Xtemplate <class _Tp> struct  is_array
N    : public false_type {};
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_array<_Tp[]>
Xtemplate <class _Tp> struct  is_array<_Tp[]>
N    : public true_type {};
Ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS is_array<_Tp[_Np]>
Xtemplate <class _Tp, size_t _Np> struct  is_array<_Tp[_Np]>
N    : public true_type {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_array_v
S    = is_array<_Tp>::value;
N#endif
N
N// is_pointer
N
Ntemplate <class _Tp> struct __libcpp_is_pointer       : public false_type {};
Ntemplate <class _Tp> struct __libcpp_is_pointer<_Tp*> : public true_type {};
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_pointer
Xtemplate <class _Tp> struct  is_pointer
N    : public __libcpp_is_pointer<typename remove_cv<_Tp>::type> {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_pointer_v
S    = is_pointer<_Tp>::value;
N#endif
N
N// is_reference
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_lvalue_reference       : public false_type {};
Xtemplate <class _Tp> struct  is_lvalue_reference       : public false_type {};
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_lvalue_reference<_Tp&> : public true_type {};
Xtemplate <class _Tp> struct  is_lvalue_reference<_Tp&> : public true_type {};
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_rvalue_reference        : public false_type {};
Xtemplate <class _Tp> struct  is_rvalue_reference        : public false_type {};
N#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_rvalue_reference<_Tp&&> : public true_type {};
Xtemplate <class _Tp> struct  is_rvalue_reference<_Tp&&> : public true_type {};
N#endif
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_reference        : public false_type {};
Xtemplate <class _Tp> struct  is_reference        : public false_type {};
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_reference<_Tp&>  : public true_type {};
Xtemplate <class _Tp> struct  is_reference<_Tp&>  : public true_type {};
N#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_reference<_Tp&&> : public true_type {};
Xtemplate <class _Tp> struct  is_reference<_Tp&&> : public true_type {};
N#endif
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_reference_v
S    = is_reference<_Tp>::value;
S
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_lvalue_reference_v
S    = is_lvalue_reference<_Tp>::value;
S
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_rvalue_reference_v
S    = is_rvalue_reference<_Tp>::value;
N#endif
N// is_union
N
N#if __has_feature(is_union) || (_GNUC_VER >= 403)
X#if 1 || (0 >= 403)
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_union
Xtemplate <class _Tp> struct  is_union
N    : public integral_constant<bool, __is_union(_Tp)> {};
N
N#else
S
Stemplate <class _Tp> struct __libcpp_union : public false_type {};
Stemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_union
S    : public __libcpp_union<typename remove_cv<_Tp>::type> {};
S
N#endif
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_union_v
S    = is_union<_Tp>::value;
N#endif
N
N// is_class
N
N#if __has_feature(is_class) || (_GNUC_VER >= 403)
X#if 1 || (0 >= 403)
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_class
Xtemplate <class _Tp> struct  is_class
N    : public integral_constant<bool, __is_class(_Tp)> {};
N
N#else
S
Snamespace __is_class_imp
S{
Stemplate <class _Tp> char  __test(int _Tp::*);
Stemplate <class _Tp> __two __test(...);
S}
S
Stemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_class
S    : public integral_constant<bool, sizeof(__is_class_imp::__test<_Tp>(0)) == 1 && !is_union<_Tp>::value> {};
S
N#endif
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_class_v
S    = is_class<_Tp>::value;
N#endif
N
N// is_same
N
Ntemplate <class _Tp, class _Up> struct _LIBCPP_TEMPLATE_VIS is_same           : public false_type {};
Xtemplate <class _Tp, class _Up> struct  is_same           : public false_type {};
Ntemplate <class _Tp>            struct _LIBCPP_TEMPLATE_VIS is_same<_Tp, _Tp> : public true_type {};
Xtemplate <class _Tp>            struct  is_same<_Tp, _Tp> : public true_type {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp, class _Up> _LIBCPP_CONSTEXPR bool is_same_v
S    = is_same<_Tp, _Up>::value;
N#endif
N
N// is_function
N
Nnamespace __libcpp_is_function_imp
N{
Nstruct __dummy_type {};
Ntemplate <class _Tp> char  __test(_Tp*);
Ntemplate <class _Tp> char __test(__dummy_type);
Ntemplate <class _Tp> __two __test(...);
Ntemplate <class _Tp> _Tp&  __source(int);
Ntemplate <class _Tp> __dummy_type __source(...);
N}
N
Ntemplate <class _Tp, bool = is_class<_Tp>::value ||
N                            is_union<_Tp>::value ||
N                            is_void<_Tp>::value  ||
N                            is_reference<_Tp>::value ||
N                            __is_nullptr_t<_Tp>::value >
Nstruct __libcpp_is_function
N    : public integral_constant<bool, sizeof(__libcpp_is_function_imp::__test<_Tp>(__libcpp_is_function_imp::__source<_Tp>(0))) == 1>
N    {};
Ntemplate <class _Tp> struct __libcpp_is_function<_Tp, true> : public false_type {};
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_function
Xtemplate <class _Tp> struct  is_function
N    : public __libcpp_is_function<_Tp> {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_function_v
S    = is_function<_Tp>::value;
N#endif
N
N// is_member_function_pointer
N
N// template <class _Tp> struct            __libcpp_is_member_function_pointer             : public false_type {};
N// template <class _Tp, class _Up> struct __libcpp_is_member_function_pointer<_Tp _Up::*> : public is_function<_Tp> {};
N// 
N
Ntemplate <class _MP, bool _IsMemberFunctionPtr, bool _IsMemberObjectPtr>
Nstruct __member_pointer_traits_imp
N{  // forward declaration; specializations later
N};
N
N
Ntemplate <class _Tp> struct __libcpp_is_member_function_pointer
N    : public false_type {};
N
Ntemplate <class _Ret, class _Class>
Nstruct __libcpp_is_member_function_pointer<_Ret _Class::*>
N    : public is_function<_Ret> {};
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_member_function_pointer
Xtemplate <class _Tp> struct  is_member_function_pointer
N    : public __libcpp_is_member_function_pointer<typename remove_cv<_Tp>::type>::type {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_member_function_pointer_v
S    = is_member_function_pointer<_Tp>::value;
N#endif
N
N// is_member_pointer
N
Ntemplate <class _Tp>            struct __libcpp_is_member_pointer             : public false_type {};
Ntemplate <class _Tp, class _Up> struct __libcpp_is_member_pointer<_Tp _Up::*> : public true_type {};
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_member_pointer
Xtemplate <class _Tp> struct  is_member_pointer
N    : public __libcpp_is_member_pointer<typename remove_cv<_Tp>::type> {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_member_pointer_v
S    = is_member_pointer<_Tp>::value;
N#endif
N
N// is_member_object_pointer
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_member_object_pointer
Xtemplate <class _Tp> struct  is_member_object_pointer
N    : public integral_constant<bool, is_member_pointer<_Tp>::value &&
N                                    !is_member_function_pointer<_Tp>::value> {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_member_object_pointer_v
S    = is_member_object_pointer<_Tp>::value;
N#endif
N
N// is_enum
N
N#if __has_feature(is_enum) || (_GNUC_VER >= 403)
X#if 1 || (0 >= 403)
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_enum
Xtemplate <class _Tp> struct  is_enum
N    : public integral_constant<bool, __is_enum(_Tp)> {};
N
N#else
S
Stemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_enum
S    : public integral_constant<bool, !is_void<_Tp>::value             &&
S                                     !is_integral<_Tp>::value         &&
S                                     !is_floating_point<_Tp>::value   &&
S                                     !is_array<_Tp>::value            &&
S                                     !is_pointer<_Tp>::value          &&
S                                     !is_reference<_Tp>::value        &&
S                                     !is_member_pointer<_Tp>::value   &&
S                                     !is_union<_Tp>::value            &&
S                                     !is_class<_Tp>::value            &&
S                                     !is_function<_Tp>::value         > {};
S
N#endif
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_enum_v
S    = is_enum<_Tp>::value;
N#endif
N
N// is_arithmetic
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_arithmetic
Xtemplate <class _Tp> struct  is_arithmetic
N    : public integral_constant<bool, is_integral<_Tp>::value      ||
N                                     is_floating_point<_Tp>::value> {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_arithmetic_v
S    = is_arithmetic<_Tp>::value;
N#endif
N
N// is_fundamental
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_fundamental
Xtemplate <class _Tp> struct  is_fundamental
N    : public integral_constant<bool, is_void<_Tp>::value        ||
N                                     __is_nullptr_t<_Tp>::value ||
N                                     is_arithmetic<_Tp>::value> {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_fundamental_v
S    = is_fundamental<_Tp>::value;
N#endif
N
N// is_scalar
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_scalar
Xtemplate <class _Tp> struct  is_scalar
N    : public integral_constant<bool, is_arithmetic<_Tp>::value     ||
N                                     is_member_pointer<_Tp>::value ||
N                                     is_pointer<_Tp>::value        ||
N                                     __is_nullptr_t<_Tp>::value    ||
N                                     is_enum<_Tp>::value           > {};
N
Ntemplate <> struct _LIBCPP_TEMPLATE_VIS is_scalar<nullptr_t> : public true_type {};
Xtemplate <> struct  is_scalar<nullptr_t> : public true_type {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_scalar_v
S    = is_scalar<_Tp>::value;
N#endif
N
N// is_object
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_object
Xtemplate <class _Tp> struct  is_object
N    : public integral_constant<bool, is_scalar<_Tp>::value ||
N                                     is_array<_Tp>::value  ||
N                                     is_union<_Tp>::value  ||
N                                     is_class<_Tp>::value  > {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_object_v
S    = is_object<_Tp>::value;
N#endif
N
N// is_compound
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_compound
Xtemplate <class _Tp> struct  is_compound
N    : public integral_constant<bool, !is_fundamental<_Tp>::value> {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_compound_v
S    = is_compound<_Tp>::value;
N#endif
N
N
N// __is_referenceable  [defns.referenceable]
N
Nstruct __is_referenceable_impl {
N    template <class _Tp> static _Tp& __test(int);
N    template <class _Tp> static __two __test(...);
N};
N
Ntemplate <class _Tp>
Nstruct __is_referenceable : integral_constant<bool,
N    !is_same<decltype(__is_referenceable_impl::__test<_Tp>(0)), __two>::value> {};
N
N
N// add_const
N
Ntemplate <class _Tp, bool = is_reference<_Tp>::value ||
N                            is_function<_Tp>::value  ||
N                            is_const<_Tp>::value     >
Nstruct __add_const             {typedef _Tp type;};
N
Ntemplate <class _Tp>
Nstruct __add_const<_Tp, false> {typedef const _Tp type;};
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_const
Xtemplate <class _Tp> struct  add_const
N    {typedef typename __add_const<_Tp>::type type;};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _Tp> using add_const_t = typename add_const<_Tp>::type;
N#endif
N
N// add_volatile
N
Ntemplate <class _Tp, bool = is_reference<_Tp>::value ||
N                            is_function<_Tp>::value  ||
N                            is_volatile<_Tp>::value  >
Nstruct __add_volatile             {typedef _Tp type;};
N
Ntemplate <class _Tp>
Nstruct __add_volatile<_Tp, false> {typedef volatile _Tp type;};
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_volatile
Xtemplate <class _Tp> struct  add_volatile
N    {typedef typename __add_volatile<_Tp>::type type;};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _Tp> using add_volatile_t = typename add_volatile<_Tp>::type;
N#endif
N
N// add_cv
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_cv
Xtemplate <class _Tp> struct  add_cv
N    {typedef typename add_const<typename add_volatile<_Tp>::type>::type type;};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _Tp> using add_cv_t = typename add_cv<_Tp>::type;
N#endif
N
N// remove_reference
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_reference        {typedef _Tp type;};
Xtemplate <class _Tp> struct  remove_reference        {typedef _Tp type;};
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_reference<_Tp&>  {typedef _Tp type;};
Xtemplate <class _Tp> struct  remove_reference<_Tp&>  {typedef _Tp type;};
N#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_reference<_Tp&&> {typedef _Tp type;};
Xtemplate <class _Tp> struct  remove_reference<_Tp&&> {typedef _Tp type;};
N#endif
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _Tp> using remove_reference_t = typename remove_reference<_Tp>::type;
N#endif
N
N// add_lvalue_reference
N
Ntemplate <class _Tp, bool = __is_referenceable<_Tp>::value> struct __add_lvalue_reference_impl            { typedef _Tp  type; };
Ntemplate <class _Tp                                       > struct __add_lvalue_reference_impl<_Tp, true> { typedef _Tp& type; };
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_lvalue_reference
Xtemplate <class _Tp> struct  add_lvalue_reference
N{typedef typename __add_lvalue_reference_impl<_Tp>::type type;};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _Tp> using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;
N#endif
N
N#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
N
Ntemplate <class _Tp, bool = __is_referenceable<_Tp>::value> struct __add_rvalue_reference_impl            { typedef _Tp   type; };
Ntemplate <class _Tp                                       > struct __add_rvalue_reference_impl<_Tp, true> { typedef _Tp&& type; };
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_rvalue_reference
Xtemplate <class _Tp> struct  add_rvalue_reference
N{typedef typename __add_rvalue_reference_impl<_Tp>::type type;};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _Tp> using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;
N#endif
N
N#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
N
N#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
N
Ntemplate <class _Tp> _Tp&& __declval(int);
Ntemplate <class _Tp> _Tp   __declval(long);
N
Ntemplate <class _Tp>
Ndecltype(_VSTD::__declval<_Tp>(0))
Xdecltype(std::__2::__declval<_Tp>(0))
Ndeclval() _NOEXCEPT;
Xdeclval() noexcept;
N
N#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
S
Stemplate <class _Tp>
Stypename add_lvalue_reference<_Tp>::type
Sdeclval();
S
N#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
N
N// __uncvref
N
Ntemplate <class _Tp>
Nstruct __uncvref  {
N    typedef typename remove_cv<typename remove_reference<_Tp>::type>::type type;
N};
N
Ntemplate <class _Tp>
Nstruct __unconstref {
N    typedef typename remove_const<typename remove_reference<_Tp>::type>::type type;
N};
N
N#ifndef _LIBCPP_CXX03_LANG
Ntemplate <class _Tp>
Nusing __uncvref_t = typename __uncvref<_Tp>::type;
N#endif
N
N// __is_same_uncvref
N
Ntemplate <class _Tp, class _Up>
Nstruct __is_same_uncvref : is_same<typename __uncvref<_Tp>::type,
N                                   typename __uncvref<_Up>::type> {};
N
Nstruct __any
N{
N    __any(...);
N};
N
N// remove_pointer
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer                      {typedef _Tp type;};
Xtemplate <class _Tp> struct  remove_pointer                      {typedef _Tp type;};
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer<_Tp*>                {typedef _Tp type;};
Xtemplate <class _Tp> struct  remove_pointer<_Tp*>                {typedef _Tp type;};
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer<_Tp* const>          {typedef _Tp type;};
Xtemplate <class _Tp> struct  remove_pointer<_Tp* const>          {typedef _Tp type;};
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer<_Tp* volatile>       {typedef _Tp type;};
Xtemplate <class _Tp> struct  remove_pointer<_Tp* volatile>       {typedef _Tp type;};
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer<_Tp* const volatile> {typedef _Tp type;};
Xtemplate <class _Tp> struct  remove_pointer<_Tp* const volatile> {typedef _Tp type;};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _Tp> using remove_pointer_t = typename remove_pointer<_Tp>::type;
N#endif
N
N// add_pointer
N
Ntemplate <class _Tp, 
N        bool = __is_referenceable<_Tp>::value || 
N                is_same<typename remove_cv<_Tp>::type, void>::value>
Nstruct __add_pointer_impl
N    {typedef typename remove_reference<_Tp>::type* type;};
Ntemplate <class _Tp> struct __add_pointer_impl<_Tp, false> 
N    {typedef _Tp type;};
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_pointer
Xtemplate <class _Tp> struct  add_pointer
N    {typedef typename __add_pointer_impl<_Tp>::type type;};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _Tp> using add_pointer_t = typename add_pointer<_Tp>::type;
N#endif
N
N// is_signed
N
Ntemplate <class _Tp, bool = is_integral<_Tp>::value>
Nstruct __libcpp_is_signed_impl : public _LIBCPP_BOOL_CONSTANT(_Tp(-1) < _Tp(0)) {};
Xstruct __libcpp_is_signed_impl : public integral_constant<bool,(_Tp(-1) < _Tp(0))> {};
N
Ntemplate <class _Tp>
Nstruct __libcpp_is_signed_impl<_Tp, false> : public true_type {};  // floating point
N
Ntemplate <class _Tp, bool = is_arithmetic<_Tp>::value>
Nstruct __libcpp_is_signed : public __libcpp_is_signed_impl<_Tp> {};
N
Ntemplate <class _Tp> struct __libcpp_is_signed<_Tp, false> : public false_type {};
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_signed : public __libcpp_is_signed<_Tp> {};
Xtemplate <class _Tp> struct  is_signed : public __libcpp_is_signed<_Tp> {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_signed_v
S    = is_signed<_Tp>::value;
N#endif
N
N// is_unsigned
N
Ntemplate <class _Tp, bool = is_integral<_Tp>::value>
Nstruct __libcpp_is_unsigned_impl : public _LIBCPP_BOOL_CONSTANT(_Tp(0) < _Tp(-1)) {};
Xstruct __libcpp_is_unsigned_impl : public integral_constant<bool,(_Tp(0) < _Tp(-1))> {};
N
Ntemplate <class _Tp>
Nstruct __libcpp_is_unsigned_impl<_Tp, false> : public false_type {};  // floating point
N
Ntemplate <class _Tp, bool = is_arithmetic<_Tp>::value>
Nstruct __libcpp_is_unsigned : public __libcpp_is_unsigned_impl<_Tp> {};
N
Ntemplate <class _Tp> struct __libcpp_is_unsigned<_Tp, false> : public false_type {};
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_unsigned : public __libcpp_is_unsigned<_Tp> {};
Xtemplate <class _Tp> struct  is_unsigned : public __libcpp_is_unsigned<_Tp> {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_unsigned_v
S    = is_unsigned<_Tp>::value;
N#endif
N
N// rank
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS rank
Xtemplate <class _Tp> struct  rank
N    : public integral_constant<size_t, 0> {};
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS rank<_Tp[]>
Xtemplate <class _Tp> struct  rank<_Tp[]>
N    : public integral_constant<size_t, rank<_Tp>::value + 1> {};
Ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS rank<_Tp[_Np]>
Xtemplate <class _Tp, size_t _Np> struct  rank<_Tp[_Np]>
N    : public integral_constant<size_t, rank<_Tp>::value + 1> {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR size_t rank_v
S    = rank<_Tp>::value;
N#endif
N
N// extent
N
Ntemplate <class _Tp, unsigned _Ip = 0> struct _LIBCPP_TEMPLATE_VIS extent
Xtemplate <class _Tp, unsigned _Ip = 0> struct  extent
N    : public integral_constant<size_t, 0> {};
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS extent<_Tp[], 0>
Xtemplate <class _Tp> struct  extent<_Tp[], 0>
N    : public integral_constant<size_t, 0> {};
Ntemplate <class _Tp, unsigned _Ip> struct _LIBCPP_TEMPLATE_VIS extent<_Tp[], _Ip>
Xtemplate <class _Tp, unsigned _Ip> struct  extent<_Tp[], _Ip>
N    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};
Ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS extent<_Tp[_Np], 0>
Xtemplate <class _Tp, size_t _Np> struct  extent<_Tp[_Np], 0>
N    : public integral_constant<size_t, _Np> {};
Ntemplate <class _Tp, size_t _Np, unsigned _Ip> struct _LIBCPP_TEMPLATE_VIS extent<_Tp[_Np], _Ip>
Xtemplate <class _Tp, size_t _Np, unsigned _Ip> struct  extent<_Tp[_Np], _Ip>
N    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp, unsigned _Ip = 0> _LIBCPP_CONSTEXPR size_t extent_v
S    = extent<_Tp, _Ip>::value;
N#endif
N
N// remove_extent
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_extent
Xtemplate <class _Tp> struct  remove_extent
N    {typedef _Tp type;};
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_extent<_Tp[]>
Xtemplate <class _Tp> struct  remove_extent<_Tp[]>
N    {typedef _Tp type;};
Ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS remove_extent<_Tp[_Np]>
Xtemplate <class _Tp, size_t _Np> struct  remove_extent<_Tp[_Np]>
N    {typedef _Tp type;};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _Tp> using remove_extent_t = typename remove_extent<_Tp>::type;
N#endif
N
N// remove_all_extents
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_all_extents
Xtemplate <class _Tp> struct  remove_all_extents
N    {typedef _Tp type;};
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_all_extents<_Tp[]>
Xtemplate <class _Tp> struct  remove_all_extents<_Tp[]>
N    {typedef typename remove_all_extents<_Tp>::type type;};
Ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS remove_all_extents<_Tp[_Np]>
Xtemplate <class _Tp, size_t _Np> struct  remove_all_extents<_Tp[_Np]>
N    {typedef typename remove_all_extents<_Tp>::type type;};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _Tp> using remove_all_extents_t = typename remove_all_extents<_Tp>::type;
N#endif
N
N// decay
N
Ntemplate <class _Up, bool>
Nstruct __decay {
N    typedef typename remove_cv<_Up>::type type;
N};
N
Ntemplate <class _Up>
Nstruct __decay<_Up, true> {
Npublic:
N    typedef typename conditional
N                     <
N                         is_array<_Up>::value,
N                         typename remove_extent<_Up>::type*,
N                         typename conditional
N                         <
N                              is_function<_Up>::value,
N                              typename add_pointer<_Up>::type,
N                              typename remove_cv<_Up>::type
N                         >::type
N                     >::type type;
N};
N
Ntemplate <class _Tp>
Nstruct _LIBCPP_TEMPLATE_VIS decay
Xstruct  decay
N{
Nprivate:
N    typedef typename remove_reference<_Tp>::type _Up;
Npublic:
N    typedef typename __decay<_Up, __is_referenceable<_Up>::value>::type type;
N};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _Tp> using decay_t = typename decay<_Tp>::type;
N#endif
N
N// is_abstract
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_abstract
Xtemplate <class _Tp> struct  is_abstract
N    : public integral_constant<bool, __is_abstract(_Tp)> {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_abstract_v
S    = is_abstract<_Tp>::value;
N#endif
N
N// is_final
N
N#if defined(_LIBCPP_HAS_IS_FINAL)
X#if 1L
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS
Xtemplate <class _Tp> struct 
N__libcpp_is_final : public integral_constant<bool, __is_final(_Tp)> {};
N#else
Stemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS
S__libcpp_is_final : public false_type {};
N#endif
N
N#if defined(_LIBCPP_HAS_IS_FINAL) && _LIBCPP_STD_VER > 11
X#if 1L && 14 > 11
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS
Xtemplate <class _Tp> struct 
Nis_final : public integral_constant<bool, __is_final(_Tp)> {};
N#endif
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_final_v
S    = is_final<_Tp>::value;
N#endif
N
N// is_aggregate
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_IS_AGGREGATE)
X#if 14 > 14 && !1L
S
Stemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS
Sis_aggregate : public integral_constant<bool, __is_aggregate(_Tp)> {};
S
S#if !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
Stemplate <class _Tp>
Sconstexpr bool is_aggregate_v = is_aggregate<_Tp>::value;
S#endif
S
N#endif // _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_IS_AGGREGATE)
N
N// is_base_of
N
N#ifdef _LIBCPP_HAS_IS_BASE_OF
N
Ntemplate <class _Bp, class _Dp>
Nstruct _LIBCPP_TEMPLATE_VIS is_base_of
Xstruct  is_base_of
N    : public integral_constant<bool, __is_base_of(_Bp, _Dp)> {};
N
N#else  // _LIBCPP_HAS_IS_BASE_OF
S
Snamespace __is_base_of_imp
S{
Stemplate <class _Tp>
Sstruct _Dst
S{
S    _Dst(const volatile _Tp &);
S};
Stemplate <class _Tp>
Sstruct _Src
S{
S    operator const volatile _Tp &();
S    template <class _Up> operator const _Dst<_Up> &();
S};
Stemplate <size_t> struct __one { typedef char type; };
Stemplate <class _Bp, class _Dp> typename __one<sizeof(_Dst<_Bp>(declval<_Src<_Dp> >()))>::type __test(int);
Stemplate <class _Bp, class _Dp> __two __test(...);
S}
S
Stemplate <class _Bp, class _Dp>
Sstruct _LIBCPP_TEMPLATE_VIS is_base_of
S    : public integral_constant<bool, is_class<_Bp>::value &&
S                                     sizeof(__is_base_of_imp::__test<_Bp, _Dp>(0)) == 2> {};
S
N#endif  // _LIBCPP_HAS_IS_BASE_OF
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Bp, class _Dp> _LIBCPP_CONSTEXPR bool is_base_of_v
S    = is_base_of<_Bp, _Dp>::value;
N#endif
N
N// is_convertible
N
N#if __has_feature(is_convertible_to) && !defined(_LIBCPP_USE_IS_CONVERTIBLE_FALLBACK)
X#if 1 && !0L
N
Ntemplate <class _T1, class _T2> struct _LIBCPP_TEMPLATE_VIS is_convertible
Xtemplate <class _T1, class _T2> struct  is_convertible
N    : public integral_constant<bool, __is_convertible_to(_T1, _T2) &&
N                                     !is_abstract<_T2>::value> {};
N
N#else  // __has_feature(is_convertible_to)
S
Snamespace __is_convertible_imp
S{
Stemplate <class _Tp> void  __test_convert(_Tp);
S
Stemplate <class _From, class _To, class = void>
Sstruct __is_convertible_test : public false_type {};
S
Stemplate <class _From, class _To>
Sstruct __is_convertible_test<_From, _To,
S    decltype(_VSTD::__is_convertible_imp::__test_convert<_To>(_VSTD::declval<_From>()))> : public true_type
S{};
S
Stemplate <class _Tp, bool _IsArray =    is_array<_Tp>::value,
S                     bool _IsFunction = is_function<_Tp>::value,
S                     bool _IsVoid =     is_void<_Tp>::value>
S                     struct __is_array_function_or_void                          {enum __attribute__((packed)) {value = 0};};
Stemplate <class _Tp> struct __is_array_function_or_void<_Tp, true, false, false> {enum __attribute__((packed)) {value = 1};};
Stemplate <class _Tp> struct __is_array_function_or_void<_Tp, false, true, false> {enum __attribute__((packed)) {value = 2};};
Stemplate <class _Tp> struct __is_array_function_or_void<_Tp, false, false, true> {enum __attribute__((packed)) {value = 3};};
S}
S
Stemplate <class _Tp,
S    unsigned = __is_convertible_imp::__is_array_function_or_void<typename remove_reference<_Tp>::type>::value>
Sstruct __is_convertible_check
S{
S    static const size_t __v = 0;
S};
S
Stemplate <class _Tp>
Sstruct __is_convertible_check<_Tp, 0>
S{
S    static const size_t __v = sizeof(_Tp);
S};
S
Stemplate <class _T1, class _T2,
S    unsigned _T1_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T1>::value,
S    unsigned _T2_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T2>::value>
Sstruct __is_convertible
S    : public integral_constant<bool,
S        __is_convertible_imp::__is_convertible_test<_T1, _T2>::value
S#if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)
S         && !(!is_function<_T1>::value && !is_reference<_T1>::value && is_reference<_T2>::value
S              && (!is_const<typename remove_reference<_T2>::type>::value
S                  || is_volatile<typename remove_reference<_T2>::type>::value)
S                  && (is_same<typename remove_cv<_T1>::type,
S                              typename remove_cv<typename remove_reference<_T2>::type>::type>::value
S                      || is_base_of<typename remove_reference<_T2>::type, _T1>::value))
S#endif
S    >
S{};
S
Stemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 1> : public false_type {};
Stemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 1> : public false_type {};
Stemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 1> : public false_type {};
Stemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 1> : public false_type {};
S
Stemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 2> : public false_type {};
Stemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 2> : public false_type {};
Stemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 2> : public false_type {};
Stemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 2> : public false_type {};
S
Stemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 3> : public false_type {};
Stemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 3> : public false_type {};
Stemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 3> : public false_type {};
Stemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 3> : public true_type {};
S
Stemplate <class _T1, class _T2> struct _LIBCPP_TEMPLATE_VIS is_convertible
S    : public __is_convertible<_T1, _T2>
S{
S    static const size_t __complete_check1 = __is_convertible_check<_T1>::__v;
S    static const size_t __complete_check2 = __is_convertible_check<_T2>::__v;
S};
S
N#endif  // __has_feature(is_convertible_to)
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _From, class _To> _LIBCPP_CONSTEXPR bool is_convertible_v
S    = is_convertible<_From, _To>::value;
N#endif
N
N// is_empty
N
N#if __has_feature(is_empty) || (_GNUC_VER >= 407)
X#if 1 || (0 >= 407)
N
Ntemplate <class _Tp>
Nstruct _LIBCPP_TEMPLATE_VIS is_empty
Xstruct  is_empty
N    : public integral_constant<bool, __is_empty(_Tp)> {};
N
N#else  // __has_feature(is_empty)
S
Stemplate <class _Tp>
Sstruct __is_empty1
S    : public _Tp
S{
S    double __lx;
S};
S
Sstruct __is_empty2
S{
S    double __lx;
S};
S
Stemplate <class _Tp, bool = is_class<_Tp>::value>
Sstruct __libcpp_empty : public integral_constant<bool, sizeof(__is_empty1<_Tp>) == sizeof(__is_empty2)> {};
S
Stemplate <class _Tp> struct __libcpp_empty<_Tp, false> : public false_type {};
S
Stemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_empty : public __libcpp_empty<_Tp> {};
S
N#endif  // __has_feature(is_empty)
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_empty_v
S    = is_empty<_Tp>::value;
N#endif
N
N// is_polymorphic
N
N#if __has_feature(is_polymorphic) || defined(_LIBCPP_COMPILER_MSVC)
X#if 1 || 0L
N
Ntemplate <class _Tp>
Nstruct _LIBCPP_TEMPLATE_VIS is_polymorphic
Xstruct  is_polymorphic
N    : public integral_constant<bool, __is_polymorphic(_Tp)> {};
N
N#else
S
Stemplate<typename _Tp> char &__is_polymorphic_impl(
S    typename enable_if<sizeof((_Tp*)dynamic_cast<const volatile void*>(declval<_Tp*>())) != 0,
S                       int>::type);
Stemplate<typename _Tp> __two &__is_polymorphic_impl(...);
S
Stemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_polymorphic
S    : public integral_constant<bool, sizeof(__is_polymorphic_impl<_Tp>(0)) == 1> {};
S
N#endif // __has_feature(is_polymorphic)
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_polymorphic_v
S    = is_polymorphic<_Tp>::value;
N#endif
N
N// has_virtual_destructor
N
N#if __has_feature(has_virtual_destructor) || (_GNUC_VER >= 403)
X#if 1 || (0 >= 403)
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS has_virtual_destructor
Xtemplate <class _Tp> struct  has_virtual_destructor
N    : public integral_constant<bool, __has_virtual_destructor(_Tp)> {};
N
N#else
S
Stemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS has_virtual_destructor
S    : public false_type {};
S
N#endif
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool has_virtual_destructor_v
S    = has_virtual_destructor<_Tp>::value;
N#endif
N
N// alignment_of
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS alignment_of
Xtemplate <class _Tp> struct  alignment_of
N    : public integral_constant<size_t, __alignof__(_Tp)> {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR size_t alignment_of_v
S    = alignment_of<_Tp>::value;
N#endif
N
N// aligned_storage
N
Ntemplate <class _Hp, class _Tp>
Nstruct __type_list
N{
N    typedef _Hp _Head;
N    typedef _Tp _Tail;
N};
N
Nstruct __nat
N{
N#ifndef _LIBCPP_CXX03_LANG
N    __nat() = delete;
N    __nat(const __nat&) = delete;
N    __nat& operator=(const __nat&) = delete;
N    ~__nat() = delete;
N#endif
N};
N
Ntemplate <class _Tp>
Nstruct __align_type
N{
N    static const size_t value = alignment_of<_Tp>::value;
N    typedef _Tp type;
N};
N
Nstruct __struct_double {long double __lx;};
Nstruct __struct_double4 {double __lx[4];};
N
Ntypedef
N    __type_list<__align_type<unsigned char>,
N    __type_list<__align_type<unsigned short>,
N    __type_list<__align_type<unsigned int>,
N    __type_list<__align_type<unsigned long>,
N    __type_list<__align_type<unsigned long long>,
N    __type_list<__align_type<double>,
N    __type_list<__align_type<long double>,
N    __type_list<__align_type<__struct_double>,
N    __type_list<__align_type<__struct_double4>,
N    __type_list<__align_type<int*>,
N    __nat
N    > > > > > > > > > > __all_types;
N
Ntemplate <class _TL, size_t _Align> struct __find_pod;
N
Ntemplate <class _Hp, size_t _Align>
Nstruct __find_pod<__type_list<_Hp, __nat>, _Align>
N{
N    typedef typename conditional<
N                             _Align == _Hp::value,
N                             typename _Hp::type,
N                             void
N                         >::type type;
N};
N
Ntemplate <class _Hp, class _Tp, size_t _Align>
Nstruct __find_pod<__type_list<_Hp, _Tp>, _Align>
N{
N    typedef typename conditional<
N                             _Align == _Hp::value,
N                             typename _Hp::type,
N                             typename __find_pod<_Tp, _Align>::type
N                         >::type type;
N};
N
Ntemplate <class _TL, size_t _Len> struct __find_max_align;
N
Ntemplate <class _Hp, size_t _Len>
Nstruct __find_max_align<__type_list<_Hp, __nat>, _Len> : public integral_constant<size_t, _Hp::value> {};
N
Ntemplate <size_t _Len, size_t _A1, size_t _A2>
Nstruct __select_align
N{
Nprivate:
N    static const size_t __min = _A2 < _A1 ? _A2 : _A1;
N    static const size_t __max = _A1 < _A2 ? _A2 : _A1;
Npublic:
N    static const size_t value = _Len < __max ? __min : __max;
N};
N
Ntemplate <class _Hp, class _Tp, size_t _Len>
Nstruct __find_max_align<__type_list<_Hp, _Tp>, _Len>
N    : public integral_constant<size_t, __select_align<_Len, _Hp::value, __find_max_align<_Tp, _Len>::value>::value> {};
N
Ntemplate <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>
Nstruct _LIBCPP_TEMPLATE_VIS aligned_storage
Xstruct  aligned_storage
N{
N    typedef typename __find_pod<__all_types, _Align>::type _Aligner;
N    static_assert(!is_void<_Aligner>::value, "");
N    union type
N    {
N        _Aligner __align;
N        unsigned char __data[(_Len + _Align - 1)/_Align * _Align];
N    };
N};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>
N    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;
N#endif
N
N#define _CREATE_ALIGNED_STORAGE_SPECIALIZATION(n) \
Ntemplate <size_t _Len>\
Nstruct _LIBCPP_TEMPLATE_VIS aligned_storage<_Len, n>\
N{\
N    struct _ALIGNAS(n) type\
N    {\
N        unsigned char __lx[(_Len + n - 1)/n * n];\
N    };\
N}
X#define _CREATE_ALIGNED_STORAGE_SPECIALIZATION(n) template <size_t _Len>struct _LIBCPP_TEMPLATE_VIS aligned_storage<_Len, n>{    struct _ALIGNAS(n) type    {        unsigned char __lx[(_Len + n - 1)/n * n];    };}
N
N_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x1);
Xtemplate <size_t _Len>struct  aligned_storage<_Len, 0x1>{ struct alignas(0x1) type { unsigned char __lx[(_Len + 0x1 - 1)/0x1 * 0x1]; };};
N_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x2);
Xtemplate <size_t _Len>struct  aligned_storage<_Len, 0x2>{ struct alignas(0x2) type { unsigned char __lx[(_Len + 0x2 - 1)/0x2 * 0x2]; };};
N_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x4);
Xtemplate <size_t _Len>struct  aligned_storage<_Len, 0x4>{ struct alignas(0x4) type { unsigned char __lx[(_Len + 0x4 - 1)/0x4 * 0x4]; };};
N_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x8);
Xtemplate <size_t _Len>struct  aligned_storage<_Len, 0x8>{ struct alignas(0x8) type { unsigned char __lx[(_Len + 0x8 - 1)/0x8 * 0x8]; };};
N_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x10);
Xtemplate <size_t _Len>struct  aligned_storage<_Len, 0x10>{ struct alignas(0x10) type { unsigned char __lx[(_Len + 0x10 - 1)/0x10 * 0x10]; };};
N_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x20);
Xtemplate <size_t _Len>struct  aligned_storage<_Len, 0x20>{ struct alignas(0x20) type { unsigned char __lx[(_Len + 0x20 - 1)/0x20 * 0x20]; };};
N_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x40);
Xtemplate <size_t _Len>struct  aligned_storage<_Len, 0x40>{ struct alignas(0x40) type { unsigned char __lx[(_Len + 0x40 - 1)/0x40 * 0x40]; };};
N_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x80);
Xtemplate <size_t _Len>struct  aligned_storage<_Len, 0x80>{ struct alignas(0x80) type { unsigned char __lx[(_Len + 0x80 - 1)/0x80 * 0x80]; };};
N_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x100);
Xtemplate <size_t _Len>struct  aligned_storage<_Len, 0x100>{ struct alignas(0x100) type { unsigned char __lx[(_Len + 0x100 - 1)/0x100 * 0x100]; };};
N_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x200);
Xtemplate <size_t _Len>struct  aligned_storage<_Len, 0x200>{ struct alignas(0x200) type { unsigned char __lx[(_Len + 0x200 - 1)/0x200 * 0x200]; };};
N_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x400);
Xtemplate <size_t _Len>struct  aligned_storage<_Len, 0x400>{ struct alignas(0x400) type { unsigned char __lx[(_Len + 0x400 - 1)/0x400 * 0x400]; };};
N_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x800);
Xtemplate <size_t _Len>struct  aligned_storage<_Len, 0x800>{ struct alignas(0x800) type { unsigned char __lx[(_Len + 0x800 - 1)/0x800 * 0x800]; };};
N_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x1000);
Xtemplate <size_t _Len>struct  aligned_storage<_Len, 0x1000>{ struct alignas(0x1000) type { unsigned char __lx[(_Len + 0x1000 - 1)/0x1000 * 0x1000]; };};
N_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x2000);
Xtemplate <size_t _Len>struct  aligned_storage<_Len, 0x2000>{ struct alignas(0x2000) type { unsigned char __lx[(_Len + 0x2000 - 1)/0x2000 * 0x2000]; };};
N// PE/COFF does not support alignment beyond 8192 (=0x2000)
N#if !defined(_LIBCPP_OBJECT_FORMAT_COFF)
X#if !0L
N_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x4000);
Xtemplate <size_t _Len>struct  aligned_storage<_Len, 0x4000>{ struct alignas(0x4000) type { unsigned char __lx[(_Len + 0x4000 - 1)/0x4000 * 0x4000]; };};
N#endif // !defined(_LIBCPP_OBJECT_FORMAT_COFF)
N
N#undef _CREATE_ALIGNED_STORAGE_SPECIALIZATION
N
N#ifndef _LIBCPP_HAS_NO_VARIADICS
N
N// aligned_union
N
Ntemplate <size_t _I0, size_t ..._In>
Nstruct __static_max;
N
Ntemplate <size_t _I0>
Nstruct __static_max<_I0>
N{
N    static const size_t value = _I0;
N};
N
Ntemplate <size_t _I0, size_t _I1, size_t ..._In>
Nstruct __static_max<_I0, _I1, _In...>
N{
N    static const size_t value = _I0 >= _I1 ? __static_max<_I0, _In...>::value :
N                                             __static_max<_I1, _In...>::value;
N};
N
Ntemplate <size_t _Len, class _Type0, class ..._Types>
Nstruct aligned_union
N{
N    static const size_t alignment_value = __static_max<__alignof__(_Type0),
N                                                       __alignof__(_Types)...>::value;
N    static const size_t __len = __static_max<_Len, sizeof(_Type0),
N                                             sizeof(_Types)...>::value;
N    typedef typename aligned_storage<__len, alignment_value>::type type;
N};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <size_t _Len, class ..._Types> using aligned_union_t = typename aligned_union<_Len, _Types...>::type;
N#endif
N
N#endif  // _LIBCPP_HAS_NO_VARIADICS
N
Ntemplate <class _Tp>
Nstruct __numeric_type
N{
N   static void __test(...);
N   static float __test(float);
N   static double __test(char);
N   static double __test(int);
N   static double __test(unsigned);
N   static double __test(long);
N   static double __test(unsigned long);
N   static double __test(long long);
N   static double __test(unsigned long long);
N   static double __test(double);
N   static long double __test(long double);
N
N   typedef decltype(__test(declval<_Tp>())) type;
N   static const bool value = !is_same<type, void>::value;
N};
N
Ntemplate <>
Nstruct __numeric_type<void>
N{
N   static const bool value = true;
N};
N
N// __promote
N
Ntemplate <class _A1, class _A2 = void, class _A3 = void,
N          bool = __numeric_type<_A1>::value &&
N                 __numeric_type<_A2>::value &&
N                 __numeric_type<_A3>::value>
Nclass __promote_imp
N{
Npublic:
N    static const bool value = false;
N};
N
Ntemplate <class _A1, class _A2, class _A3>
Nclass __promote_imp<_A1, _A2, _A3, true>
N{
Nprivate:
N    typedef typename __promote_imp<_A1>::type __type1;
N    typedef typename __promote_imp<_A2>::type __type2;
N    typedef typename __promote_imp<_A3>::type __type3;
Npublic:
N    typedef decltype(__type1() + __type2() + __type3()) type;
N    static const bool value = true;
N};
N
Ntemplate <class _A1, class _A2>
Nclass __promote_imp<_A1, _A2, void, true>
N{
Nprivate:
N    typedef typename __promote_imp<_A1>::type __type1;
N    typedef typename __promote_imp<_A2>::type __type2;
Npublic:
N    typedef decltype(__type1() + __type2()) type;
N    static const bool value = true;
N};
N
Ntemplate <class _A1>
Nclass __promote_imp<_A1, void, void, true>
N{
Npublic:
N    typedef typename __numeric_type<_A1>::type type;
N    static const bool value = true;
N};
N
Ntemplate <class _A1, class _A2 = void, class _A3 = void>
Nclass __promote : public __promote_imp<_A1, _A2, _A3> {};
N
N// make_signed / make_unsigned
N
Ntypedef
N    __type_list<signed char,
N    __type_list<signed short,
N    __type_list<signed int,
N    __type_list<signed long,
N    __type_list<signed long long,
N#ifndef _LIBCPP_HAS_NO_INT128
S    __type_list<__int128_t,
N#endif
N    __nat
N#ifndef _LIBCPP_HAS_NO_INT128
S    >
N#endif
N    > > > > > __signed_types;
N
Ntypedef
N    __type_list<unsigned char,
N    __type_list<unsigned short,
N    __type_list<unsigned int,
N    __type_list<unsigned long,
N    __type_list<unsigned long long,
N#ifndef _LIBCPP_HAS_NO_INT128
S    __type_list<__uint128_t,
N#endif
N    __nat
N#ifndef _LIBCPP_HAS_NO_INT128
S    >
N#endif
N    > > > > > __unsigned_types;
N
Ntemplate <class _TypeList, size_t _Size, bool = _Size <= sizeof(typename _TypeList::_Head)> struct __find_first;
N
Ntemplate <class _Hp, class _Tp, size_t _Size>
Nstruct __find_first<__type_list<_Hp, _Tp>, _Size, true>
N{
N    typedef _Hp type;
N};
N
Ntemplate <class _Hp, class _Tp, size_t _Size>
Nstruct __find_first<__type_list<_Hp, _Tp>, _Size, false>
N{
N    typedef typename __find_first<_Tp, _Size>::type type;
N};
N
Ntemplate <class _Tp, class _Up, bool = is_const<typename remove_reference<_Tp>::type>::value,
N                             bool = is_volatile<typename remove_reference<_Tp>::type>::value>
Nstruct __apply_cv
N{
N    typedef _Up type;
N};
N
Ntemplate <class _Tp, class _Up>
Nstruct __apply_cv<_Tp, _Up, true, false>
N{
N    typedef const _Up type;
N};
N
Ntemplate <class _Tp, class _Up>
Nstruct __apply_cv<_Tp, _Up, false, true>
N{
N    typedef volatile _Up type;
N};
N
Ntemplate <class _Tp, class _Up>
Nstruct __apply_cv<_Tp, _Up, true, true>
N{
N    typedef const volatile _Up type;
N};
N
Ntemplate <class _Tp, class _Up>
Nstruct __apply_cv<_Tp&, _Up, false, false>
N{
N    typedef _Up& type;
N};
N
Ntemplate <class _Tp, class _Up>
Nstruct __apply_cv<_Tp&, _Up, true, false>
N{
N    typedef const _Up& type;
N};
N
Ntemplate <class _Tp, class _Up>
Nstruct __apply_cv<_Tp&, _Up, false, true>
N{
N    typedef volatile _Up& type;
N};
N
Ntemplate <class _Tp, class _Up>
Nstruct __apply_cv<_Tp&, _Up, true, true>
N{
N    typedef const volatile _Up& type;
N};
N
Ntemplate <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>
Nstruct __make_signed {};
N
Ntemplate <class _Tp>
Nstruct __make_signed<_Tp, true>
N{
N    typedef typename __find_first<__signed_types, sizeof(_Tp)>::type type;
N};
N
Ntemplate <> struct __make_signed<bool,               true> {};
Ntemplate <> struct __make_signed<  signed short,     true> {typedef short     type;};
Ntemplate <> struct __make_signed<unsigned short,     true> {typedef short     type;};
Ntemplate <> struct __make_signed<  signed int,       true> {typedef int       type;};
Ntemplate <> struct __make_signed<unsigned int,       true> {typedef int       type;};
Ntemplate <> struct __make_signed<  signed long,      true> {typedef long      type;};
Ntemplate <> struct __make_signed<unsigned long,      true> {typedef long      type;};
Ntemplate <> struct __make_signed<  signed long long, true> {typedef long long type;};
Ntemplate <> struct __make_signed<unsigned long long, true> {typedef long long type;};
N#ifndef _LIBCPP_HAS_NO_INT128
Stemplate <> struct __make_signed<__int128_t,         true> {typedef __int128_t type;};
Stemplate <> struct __make_signed<__uint128_t,        true> {typedef __int128_t type;};
N#endif
N
Ntemplate <class _Tp>
Nstruct _LIBCPP_TEMPLATE_VIS make_signed
Xstruct  make_signed
N{
N    typedef typename __apply_cv<_Tp, typename __make_signed<typename remove_cv<_Tp>::type>::type>::type type;
N};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _Tp> using make_signed_t = typename make_signed<_Tp>::type;
N#endif
N
Ntemplate <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>
Nstruct __make_unsigned {};
N
Ntemplate <class _Tp>
Nstruct __make_unsigned<_Tp, true>
N{
N    typedef typename __find_first<__unsigned_types, sizeof(_Tp)>::type type;
N};
N
Ntemplate <> struct __make_unsigned<bool,               true> {};
Ntemplate <> struct __make_unsigned<  signed short,     true> {typedef unsigned short     type;};
Ntemplate <> struct __make_unsigned<unsigned short,     true> {typedef unsigned short     type;};
Ntemplate <> struct __make_unsigned<  signed int,       true> {typedef unsigned int       type;};
Ntemplate <> struct __make_unsigned<unsigned int,       true> {typedef unsigned int       type;};
Ntemplate <> struct __make_unsigned<  signed long,      true> {typedef unsigned long      type;};
Ntemplate <> struct __make_unsigned<unsigned long,      true> {typedef unsigned long      type;};
Ntemplate <> struct __make_unsigned<  signed long long, true> {typedef unsigned long long type;};
Ntemplate <> struct __make_unsigned<unsigned long long, true> {typedef unsigned long long type;};
N#ifndef _LIBCPP_HAS_NO_INT128
Stemplate <> struct __make_unsigned<__int128_t,         true> {typedef __uint128_t        type;};
Stemplate <> struct __make_unsigned<__uint128_t,        true> {typedef __uint128_t        type;};
N#endif
N
Ntemplate <class _Tp>
Nstruct _LIBCPP_TEMPLATE_VIS make_unsigned
Xstruct  make_unsigned
N{
N    typedef typename __apply_cv<_Tp, typename __make_unsigned<typename remove_cv<_Tp>::type>::type>::type type;
N};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _Tp> using make_unsigned_t = typename make_unsigned<_Tp>::type;
N#endif
N
N#ifdef _LIBCPP_HAS_NO_VARIADICS
S
Stemplate <class _Tp, class _Up = void, class _Vp = void>
Sstruct _LIBCPP_TEMPLATE_VIS common_type
S{
Spublic:
S    typedef typename common_type<typename common_type<_Tp, _Up>::type, _Vp>::type type;
S};
S
Stemplate <>
Sstruct _LIBCPP_TEMPLATE_VIS common_type<void, void, void>
S{
Spublic:
S    typedef void type;
S};
S
Stemplate <class _Tp>
Sstruct _LIBCPP_TEMPLATE_VIS common_type<_Tp, void, void>
S{
Spublic:
S    typedef typename common_type<_Tp, _Tp>::type type;
S};
S
Stemplate <class _Tp, class _Up>
Sstruct _LIBCPP_TEMPLATE_VIS common_type<_Tp, _Up, void>
S{
S    typedef typename decay<decltype(
S        true ? _VSTD::declval<_Tp>() : _VSTD::declval<_Up>()
S      )>::type type;
S};
S
N#else  // _LIBCPP_HAS_NO_VARIADICS
N
N// bullet 1 - sizeof...(Tp) == 0
N
Ntemplate <class ..._Tp>
Nstruct _LIBCPP_TEMPLATE_VIS common_type {};
Xstruct  common_type {};
N
N// bullet 2 - sizeof...(Tp) == 1
N
Ntemplate <class _Tp>
Nstruct _LIBCPP_TEMPLATE_VIS common_type<_Tp>
Xstruct  common_type<_Tp>
N    : public common_type<_Tp, _Tp> {};
N
N// bullet 3 - sizeof...(Tp) == 2
N
Ntemplate <class _Tp, class _Up, class = void>
Nstruct __common_type2_imp {};
N
Ntemplate <class _Tp, class _Up>
Nstruct __common_type2_imp<_Tp, _Up,
N    typename __void_t<decltype(
N        true ? _VSTD::declval<_Tp>() : _VSTD::declval<_Up>()
X        true ? std::__2::declval<_Tp>() : std::__2::declval<_Up>()
N    )>::type>
N{
N    typedef typename decay<decltype(
N        true ? _VSTD::declval<_Tp>() : _VSTD::declval<_Up>()
X        true ? std::__2::declval<_Tp>() : std::__2::declval<_Up>()
N    )>::type type;
N};
N
Ntemplate <class _Tp, class _Up,
N          class _DTp = typename decay<_Tp>::type,
N          class _DUp = typename decay<_Up>::type>
Nusing __common_type2 =
N  typename conditional<
N    is_same<_Tp, _DTp>::value && is_same<_Up, _DUp>::value,
N    __common_type2_imp<_Tp, _Up>,
N    common_type<_DTp, _DUp>
N  >::type;
N
Ntemplate <class _Tp, class _Up>
Nstruct _LIBCPP_TEMPLATE_VIS common_type<_Tp, _Up>
Xstruct  common_type<_Tp, _Up>
N    : __common_type2<_Tp, _Up> {};
N
N// bullet 4 - sizeof...(Tp) > 2
N
Ntemplate <class ...Tp> struct __common_types;
N
Ntemplate <class, class = void>
Nstruct __common_type_impl {};
N
Ntemplate <class _Tp, class _Up>
Nstruct __common_type_impl<
N    __common_types<_Tp, _Up>,
N    typename __void_t<typename common_type<_Tp, _Up>::type>::type>
N{
N  typedef typename common_type<_Tp, _Up>::type type;
N};
N
Ntemplate <class _Tp, class _Up, class ..._Vp>
Nstruct __common_type_impl<__common_types<_Tp, _Up, _Vp...>,
N    typename __void_t<typename common_type<_Tp, _Up>::type>::type>
N  : __common_type_impl<
N      __common_types<typename common_type<_Tp, _Up>::type, _Vp...> >
N{
N
N};
N
Ntemplate <class _Tp, class _Up, class ..._Vp>
Nstruct _LIBCPP_TEMPLATE_VIS common_type<_Tp, _Up, _Vp...>
Xstruct  common_type<_Tp, _Up, _Vp...>
N    : __common_type_impl<__common_types<_Tp, _Up, _Vp...> > {};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class ..._Tp> using common_type_t = typename common_type<_Tp...>::type;
N#endif
N
N#endif  // _LIBCPP_HAS_NO_VARIADICS
N
N// is_assignable
N
Ntemplate<typename, typename _Tp> struct __select_2nd { typedef _Tp type; };
N
Ntemplate <class _Tp, class _Arg>
Ntypename __select_2nd<decltype((_VSTD::declval<_Tp>() = _VSTD::declval<_Arg>())), true_type>::type
Xtypename __select_2nd<decltype((std::__2::declval<_Tp>() = std::__2::declval<_Arg>())), true_type>::type
N__is_assignable_test(int);
N
Ntemplate <class, class>
Nfalse_type __is_assignable_test(...);
N
N
Ntemplate <class _Tp, class _Arg, bool = is_void<_Tp>::value || is_void<_Arg>::value>
Nstruct __is_assignable_imp
N    : public decltype((_VSTD::__is_assignable_test<_Tp, _Arg>(0))) {};
X    : public decltype((std::__2::__is_assignable_test<_Tp, _Arg>(0))) {};
N
Ntemplate <class _Tp, class _Arg>
Nstruct __is_assignable_imp<_Tp, _Arg, true>
N    : public false_type
N{
N};
N
Ntemplate <class _Tp, class _Arg>
Nstruct is_assignable
N    : public __is_assignable_imp<_Tp, _Arg> {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp, class _Arg> _LIBCPP_CONSTEXPR bool is_assignable_v
S    = is_assignable<_Tp, _Arg>::value;
N#endif
N
N// is_copy_assignable
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_copy_assignable
Xtemplate <class _Tp> struct  is_copy_assignable
N    : public is_assignable<typename add_lvalue_reference<_Tp>::type,
N                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_copy_assignable_v
S    = is_copy_assignable<_Tp>::value;
N#endif
N
N// is_move_assignable
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_move_assignable
Xtemplate <class _Tp> struct  is_move_assignable
N#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
N    : public is_assignable<typename add_lvalue_reference<_Tp>::type,
N                           typename add_rvalue_reference<_Tp>::type> {};
N#else
S    : public is_copy_assignable<_Tp> {};
N#endif
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_move_assignable_v
S    = is_move_assignable<_Tp>::value;
N#endif
N
N// is_destructible
N
N//  if it's a reference, return true
N//  if it's a function, return false
N//  if it's   void,     return false
N//  if it's an array of unknown bound, return false
N//  Otherwise, return "std::declval<_Up&>().~_Up()" is well-formed
N//    where _Up is remove_all_extents<_Tp>::type
N
Ntemplate <class>
Nstruct __is_destructible_apply { typedef int type; };
N
Ntemplate <typename _Tp>
Nstruct __is_destructor_wellformed {
N    template <typename _Tp1>
N    static char  __test (
N        typename __is_destructible_apply<decltype(_VSTD::declval<_Tp1&>().~_Tp1())>::type
X        typename __is_destructible_apply<decltype(std::__2::declval<_Tp1&>().~_Tp1())>::type
N    );
N
N    template <typename _Tp1>
N    static __two __test (...);
N    
N    static const bool value = sizeof(__test<_Tp>(12)) == sizeof(char);
N};
N
Ntemplate <class _Tp, bool>
Nstruct __destructible_imp;
N
Ntemplate <class _Tp>
Nstruct __destructible_imp<_Tp, false> 
N   : public _VSTD::integral_constant<bool, 
X   : public std::__2::integral_constant<bool, 
N        __is_destructor_wellformed<typename _VSTD::remove_all_extents<_Tp>::type>::value> {};
X        __is_destructor_wellformed<typename std::__2::remove_all_extents<_Tp>::type>::value> {};
N
Ntemplate <class _Tp>
Nstruct __destructible_imp<_Tp, true>
N    : public _VSTD::true_type {};
X    : public std::__2::true_type {};
N
Ntemplate <class _Tp, bool>
Nstruct __destructible_false;
N
Ntemplate <class _Tp>
Nstruct __destructible_false<_Tp, false> : public __destructible_imp<_Tp, _VSTD::is_reference<_Tp>::value> {};
Xstruct __destructible_false<_Tp, false> : public __destructible_imp<_Tp, std::__2::is_reference<_Tp>::value> {};
N
Ntemplate <class _Tp>
Nstruct __destructible_false<_Tp, true> : public _VSTD::false_type {};
Xstruct __destructible_false<_Tp, true> : public std::__2::false_type {};
N
Ntemplate <class _Tp>
Nstruct is_destructible
N    : public __destructible_false<_Tp, _VSTD::is_function<_Tp>::value> {};
X    : public __destructible_false<_Tp, std::__2::is_function<_Tp>::value> {};
N
Ntemplate <class _Tp>
Nstruct is_destructible<_Tp[]>
N    : public _VSTD::false_type {};
X    : public std::__2::false_type {};
N
Ntemplate <>
Nstruct is_destructible<void>
N    : public _VSTD::false_type {};
X    : public std::__2::false_type {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_destructible_v
S    = is_destructible<_Tp>::value;
N#endif
N
N// move
N
N#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
Xinline __attribute__ ((__always_inline__)) constexpr
Ntypename remove_reference<_Tp>::type&&
Nmove(_Tp&& __t) _NOEXCEPT
Xmove(_Tp&& __t) noexcept
N{
N    typedef typename remove_reference<_Tp>::type _Up;
N    return static_cast<_Up&&>(__t);
N}
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
Xinline __attribute__ ((__always_inline__)) constexpr
N_Tp&&
Nforward(typename remove_reference<_Tp>::type& __t) _NOEXCEPT
Xforward(typename remove_reference<_Tp>::type& __t) noexcept
N{
N    return static_cast<_Tp&&>(__t);
N}
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
Xinline __attribute__ ((__always_inline__)) constexpr
N_Tp&&
Nforward(typename remove_reference<_Tp>::type&& __t) _NOEXCEPT
Xforward(typename remove_reference<_Tp>::type&& __t) noexcept
N{
N    static_assert(!is_lvalue_reference<_Tp>::value,
N                  "can not forward an rvalue as an lvalue");
N    return static_cast<_Tp&&>(__t);
N}
N
N#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
S
Stemplate <class _Tp>
Sinline _LIBCPP_INLINE_VISIBILITY
S_Tp&
Smove(_Tp& __t)
S{
S    return __t;
S}
S
Stemplate <class _Tp>
Sinline _LIBCPP_INLINE_VISIBILITY
Sconst _Tp&
Smove(const _Tp& __t)
S{
S    return __t;
S}
S
Stemplate <class _Tp>
Sinline _LIBCPP_INLINE_VISIBILITY
S_Tp&
Sforward(typename remove_reference<_Tp>::type& __t) _NOEXCEPT
S{
S    return __t;
S}
S
S
Stemplate <class _Tp>
Sclass __rv
S{
S    typedef typename remove_reference<_Tp>::type _Trr;
S    _Trr& t_;
Spublic:
S    _LIBCPP_INLINE_VISIBILITY
S    _Trr* operator->() {return &t_;}
S    _LIBCPP_INLINE_VISIBILITY
S    explicit __rv(_Trr& __t) : t_(__t) {}
S};
S
N#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
N
N#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename decay<_Tp>::type
N__decay_copy(_Tp&& __t)
N{
N    return _VSTD::forward<_Tp>(__t);
X    return std::__2::forward<_Tp>(__t);
N}
N
N#else
S
Stemplate <class _Tp>
Sinline _LIBCPP_INLINE_VISIBILITY
Stypename decay<_Tp>::type
S__decay_copy(const _Tp& __t)
S{
S    return _VSTD::forward<_Tp>(__t);
S}
S
N#endif
N
N#ifndef _LIBCPP_HAS_NO_VARIADICS
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...), true, false>
N{
N    typedef _Class _ClassType;
N    typedef _Rp _ReturnType;
N    typedef _Rp (_FnType) (_Param...);
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...), true, false>
N{
N    typedef _Class _ClassType;
N    typedef _Rp _ReturnType;
N    typedef _Rp (_FnType) (_Param..., ...);
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const, true, false>
N{
N    typedef _Class const _ClassType;
N    typedef _Rp _ReturnType;
N    typedef _Rp (_FnType) (_Param...);
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const, true, false>
N{
N    typedef _Class const _ClassType;
N    typedef _Rp _ReturnType;
N    typedef _Rp (_FnType) (_Param..., ...);
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile, true, false>
N{
N    typedef _Class volatile _ClassType;
N    typedef _Rp _ReturnType;
N    typedef _Rp (_FnType) (_Param...);
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile, true, false>
N{
N    typedef _Class volatile _ClassType;
N    typedef _Rp _ReturnType;
N    typedef _Rp (_FnType) (_Param..., ...);
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile, true, false>
N{
N    typedef _Class const volatile _ClassType;
N    typedef _Rp _ReturnType;
N    typedef _Rp (_FnType) (_Param...);
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile, true, false>
N{
N    typedef _Class const volatile _ClassType;
N    typedef _Rp _ReturnType;
N    typedef _Rp (_FnType) (_Param..., ...);
N};
N
N#if __has_feature(cxx_reference_qualified_functions) || \
N    (defined(_GNUC_VER) && _GNUC_VER >= 409)
X#if 1 ||     (1L && 0 >= 409)
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &, true, false>
N{
N    typedef _Class& _ClassType;
N    typedef _Rp _ReturnType;
N    typedef _Rp (_FnType) (_Param...);
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &, true, false>
N{
N    typedef _Class& _ClassType;
N    typedef _Rp _ReturnType;
N    typedef _Rp (_FnType) (_Param..., ...);
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&, true, false>
N{
N    typedef _Class const& _ClassType;
N    typedef _Rp _ReturnType;
N    typedef _Rp (_FnType) (_Param...);
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&, true, false>
N{
N    typedef _Class const& _ClassType;
N    typedef _Rp _ReturnType;
N    typedef _Rp (_FnType) (_Param..., ...);
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&, true, false>
N{
N    typedef _Class volatile& _ClassType;
N    typedef _Rp _ReturnType;
N    typedef _Rp (_FnType) (_Param...);
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&, true, false>
N{
N    typedef _Class volatile& _ClassType;
N    typedef _Rp _ReturnType;
N    typedef _Rp (_FnType) (_Param..., ...);
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&, true, false>
N{
N    typedef _Class const volatile& _ClassType;
N    typedef _Rp _ReturnType;
N    typedef _Rp (_FnType) (_Param...);
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&, true, false>
N{
N    typedef _Class const volatile& _ClassType;
N    typedef _Rp _ReturnType;
N    typedef _Rp (_FnType) (_Param..., ...);
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &&, true, false>
N{
N    typedef _Class&& _ClassType;
N    typedef _Rp _ReturnType;
N    typedef _Rp (_FnType) (_Param...);
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &&, true, false>
N{
N    typedef _Class&& _ClassType;
N    typedef _Rp _ReturnType;
N    typedef _Rp (_FnType) (_Param..., ...);
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&&, true, false>
N{
N    typedef _Class const&& _ClassType;
N    typedef _Rp _ReturnType;
N    typedef _Rp (_FnType) (_Param...);
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&&, true, false>
N{
N    typedef _Class const&& _ClassType;
N    typedef _Rp _ReturnType;
N    typedef _Rp (_FnType) (_Param..., ...);
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&&, true, false>
N{
N    typedef _Class volatile&& _ClassType;
N    typedef _Rp _ReturnType;
N    typedef _Rp (_FnType) (_Param...);
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&&, true, false>
N{
N    typedef _Class volatile&& _ClassType;
N    typedef _Rp _ReturnType;
N    typedef _Rp (_FnType) (_Param..., ...);
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&&, true, false>
N{
N    typedef _Class const volatile&& _ClassType;
N    typedef _Rp _ReturnType;
N    typedef _Rp (_FnType) (_Param...);
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&&, true, false>
N{
N    typedef _Class const volatile&& _ClassType;
N    typedef _Rp _ReturnType;
N    typedef _Rp (_FnType) (_Param..., ...);
N};
N
N#endif  // __has_feature(cxx_reference_qualified_functions) || _GNUC_VER >= 409
N
N#else  // _LIBCPP_HAS_NO_VARIADICS
S
Stemplate <class _Rp, class _Class>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)(), true, false>
S{
S    typedef _Class _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) ();
S};
S
Stemplate <class _Rp, class _Class>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)(...), true, false>
S{
S    typedef _Class _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) (...);
S};
S
Stemplate <class _Rp, class _Class, class _P0>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0), true, false>
S{
S    typedef _Class _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) (_P0);
S};
S
Stemplate <class _Rp, class _Class, class _P0>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...), true, false>
S{
S    typedef _Class _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) (_P0, ...);
S};
S
Stemplate <class _Rp, class _Class, class _P0, class _P1>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1), true, false>
S{
S    typedef _Class _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) (_P0, _P1);
S};
S
Stemplate <class _Rp, class _Class, class _P0, class _P1>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...), true, false>
S{
S    typedef _Class _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) (_P0, _P1, ...);
S};
S
Stemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2), true, false>
S{
S    typedef _Class _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) (_P0, _P1, _P2);
S};
S
Stemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...), true, false>
S{
S    typedef _Class _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);
S};
S
Stemplate <class _Rp, class _Class>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)() const, true, false>
S{
S    typedef _Class const _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) ();
S};
S
Stemplate <class _Rp, class _Class>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)(...) const, true, false>
S{
S    typedef _Class const _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) (...);
S};
S
Stemplate <class _Rp, class _Class, class _P0>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const, true, false>
S{
S    typedef _Class const _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) (_P0);
S};
S
Stemplate <class _Rp, class _Class, class _P0>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) const, true, false>
S{
S    typedef _Class const _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) (_P0, ...);
S};
S
Stemplate <class _Rp, class _Class, class _P0, class _P1>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const, true, false>
S{
S    typedef _Class const _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) (_P0, _P1);
S};
S
Stemplate <class _Rp, class _Class, class _P0, class _P1>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) const, true, false>
S{
S    typedef _Class const _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) (_P0, _P1, ...);
S};
S
Stemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const, true, false>
S{
S    typedef _Class const _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) (_P0, _P1, _P2);
S};
S
Stemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) const, true, false>
S{
S    typedef _Class const _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);
S};
S
Stemplate <class _Rp, class _Class>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)() volatile, true, false>
S{
S    typedef _Class volatile _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) ();
S};
S
Stemplate <class _Rp, class _Class>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)(...) volatile, true, false>
S{
S    typedef _Class volatile _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) (...);
S};
S
Stemplate <class _Rp, class _Class, class _P0>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) volatile, true, false>
S{
S    typedef _Class volatile _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) (_P0);
S};
S
Stemplate <class _Rp, class _Class, class _P0>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) volatile, true, false>
S{
S    typedef _Class volatile _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) (_P0, ...);
S};
S
Stemplate <class _Rp, class _Class, class _P0, class _P1>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) volatile, true, false>
S{
S    typedef _Class volatile _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) (_P0, _P1);
S};
S
Stemplate <class _Rp, class _Class, class _P0, class _P1>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) volatile, true, false>
S{
S    typedef _Class volatile _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) (_P0, _P1, ...);
S};
S
Stemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) volatile, true, false>
S{
S    typedef _Class volatile _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) (_P0, _P1, _P2);
S};
S
Stemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) volatile, true, false>
S{
S    typedef _Class volatile _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);
S};
S
Stemplate <class _Rp, class _Class>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)() const volatile, true, false>
S{
S    typedef _Class const volatile _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) ();
S};
S
Stemplate <class _Rp, class _Class>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)(...) const volatile, true, false>
S{
S    typedef _Class const volatile _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) (...);
S};
S
Stemplate <class _Rp, class _Class, class _P0>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const volatile, true, false>
S{
S    typedef _Class const volatile _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) (_P0);
S};
S
Stemplate <class _Rp, class _Class, class _P0>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) const volatile, true, false>
S{
S    typedef _Class const volatile _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) (_P0, ...);
S};
S
Stemplate <class _Rp, class _Class, class _P0, class _P1>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const volatile, true, false>
S{
S    typedef _Class const volatile _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) (_P0, _P1);
S};
S
Stemplate <class _Rp, class _Class, class _P0, class _P1>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) const volatile, true, false>
S{
S    typedef _Class const volatile _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) (_P0, _P1, ...);
S};
S
Stemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const volatile, true, false>
S{
S    typedef _Class const volatile _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) (_P0, _P1, _P2);
S};
S
Stemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) const volatile, true, false>
S{
S    typedef _Class const volatile _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);
S};
S
N#endif  // _LIBCPP_HAS_NO_VARIADICS
N
Ntemplate <class _Rp, class _Class>
Nstruct __member_pointer_traits_imp<_Rp _Class::*, false, true>
N{
N    typedef _Class _ClassType;
N    typedef _Rp _ReturnType;
N};
N
Ntemplate <class _MP>
Nstruct __member_pointer_traits
N    : public __member_pointer_traits_imp<typename remove_cv<_MP>::type,
N                    is_member_function_pointer<_MP>::value,
N                    is_member_object_pointer<_MP>::value>
N{
N//     typedef ... _ClassType;
N//     typedef ... _ReturnType;
N//     typedef ... _FnType;
N};
N
N
Ntemplate <class _DecayedFp>
Nstruct __member_pointer_class_type {};
N
Ntemplate <class _Ret, class _ClassType>
Nstruct __member_pointer_class_type<_Ret _ClassType::*> {
N  typedef _ClassType type;
N};
N
N// result_of
N
Ntemplate <class _Callable> class result_of;
N
N#ifdef _LIBCPP_HAS_NO_VARIADICS
S
Stemplate <class _Fn, bool, bool>
Sclass __result_of
S{
S};
S
Stemplate <class _Fn>
Sclass __result_of<_Fn(), true, false>
S{
Spublic:
S    typedef decltype(declval<_Fn>()()) type;
S};
S
Stemplate <class _Fn, class _A0>
Sclass __result_of<_Fn(_A0), true, false>
S{
Spublic:
S    typedef decltype(declval<_Fn>()(declval<_A0>())) type;
S};
S
Stemplate <class _Fn, class _A0, class _A1>
Sclass __result_of<_Fn(_A0, _A1), true, false>
S{
Spublic:
S    typedef decltype(declval<_Fn>()(declval<_A0>(), declval<_A1>())) type;
S};
S
Stemplate <class _Fn, class _A0, class _A1, class _A2>
Sclass __result_of<_Fn(_A0, _A1, _A2), true, false>
S{
Spublic:
S    typedef decltype(declval<_Fn>()(declval<_A0>(), declval<_A1>(), declval<_A2>())) type;
S};
S
Stemplate <class _MP, class _Tp, bool _IsMemberFunctionPtr>
Sstruct __result_of_mp;
S
S// member function pointer
S
Stemplate <class _MP, class _Tp>
Sstruct __result_of_mp<_MP, _Tp, true>
S    : public __identity<typename __member_pointer_traits<_MP>::_ReturnType>
S{
S};
S
S// member data pointer
S
Stemplate <class _MP, class _Tp, bool>
Sstruct __result_of_mdp;
S
Stemplate <class _Rp, class _Class, class _Tp>
Sstruct __result_of_mdp<_Rp _Class::*, _Tp, false>
S{
S    typedef typename __apply_cv<decltype(*_VSTD::declval<_Tp>()), _Rp>::type& type;
S};
S
Stemplate <class _Rp, class _Class, class _Tp>
Sstruct __result_of_mdp<_Rp _Class::*, _Tp, true>
S{
S    typedef typename __apply_cv<_Tp, _Rp>::type& type;
S};
S
Stemplate <class _Rp, class _Class, class _Tp>
Sstruct __result_of_mp<_Rp _Class::*, _Tp, false>
S    : public __result_of_mdp<_Rp _Class::*, _Tp,
S            is_base_of<_Class, typename remove_reference<_Tp>::type>::value>
S{
S};
S
S
S
Stemplate <class _Fn, class _Tp>
Sclass __result_of<_Fn(_Tp), false, true>  // _Fn must be member pointer
S    : public __result_of_mp<typename remove_reference<_Fn>::type,
S                            _Tp,
S                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>
S{
S};
S
Stemplate <class _Fn, class _Tp, class _A0>
Sclass __result_of<_Fn(_Tp, _A0), false, true>  // _Fn must be member pointer
S    : public __result_of_mp<typename remove_reference<_Fn>::type,
S                            _Tp,
S                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>
S{
S};
S
Stemplate <class _Fn, class _Tp, class _A0, class _A1>
Sclass __result_of<_Fn(_Tp, _A0, _A1), false, true>  // _Fn must be member pointer
S    : public __result_of_mp<typename remove_reference<_Fn>::type,
S                            _Tp,
S                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>
S{
S};
S
Stemplate <class _Fn, class _Tp, class _A0, class _A1, class _A2>
Sclass __result_of<_Fn(_Tp, _A0, _A1, _A2), false, true>  // _Fn must be member pointer
S    : public __result_of_mp<typename remove_reference<_Fn>::type,
S                            _Tp,
S                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>
S{
S};
S
S// result_of
S
Stemplate <class _Fn>
Sclass _LIBCPP_TEMPLATE_VIS result_of<_Fn()>
S    : public __result_of<_Fn(),
S                         is_class<typename remove_reference<_Fn>::type>::value ||
S                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,
S                         is_member_pointer<typename remove_reference<_Fn>::type>::value
S                        >
S{
S};
S
Stemplate <class _Fn, class _A0>
Sclass _LIBCPP_TEMPLATE_VIS result_of<_Fn(_A0)>
S    : public __result_of<_Fn(_A0),
S                         is_class<typename remove_reference<_Fn>::type>::value ||
S                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,
S                         is_member_pointer<typename remove_reference<_Fn>::type>::value
S                        >
S{
S};
S
Stemplate <class _Fn, class _A0, class _A1>
Sclass _LIBCPP_TEMPLATE_VIS result_of<_Fn(_A0, _A1)>
S    : public __result_of<_Fn(_A0, _A1),
S                         is_class<typename remove_reference<_Fn>::type>::value ||
S                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,
S                         is_member_pointer<typename remove_reference<_Fn>::type>::value
S                        >
S{
S};
S
Stemplate <class _Fn, class _A0, class _A1, class _A2>
Sclass _LIBCPP_TEMPLATE_VIS result_of<_Fn(_A0, _A1, _A2)>
S    : public __result_of<_Fn(_A0, _A1, _A2),
S                         is_class<typename remove_reference<_Fn>::type>::value ||
S                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,
S                         is_member_pointer<typename remove_reference<_Fn>::type>::value
S                        >
S{
S};
S
N#endif  // _LIBCPP_HAS_NO_VARIADICS
N
N// template <class T, class... Args> struct is_constructible;
N
Nnamespace __is_construct
N{
Nstruct __nat {};
N}
N
N#if !defined(_LIBCPP_CXX03_LANG) && (!__has_feature(is_constructible) || \
N    defined(_LIBCPP_TESTING_FALLBACK_IS_CONSTRUCTIBLE))
X#if !0L && (!0 ||     0L)
N
Ntemplate <class _Tp, class... _Args>
Nstruct __libcpp_is_constructible;
N
Ntemplate <class _To, class _From>
Nstruct __is_invalid_base_to_derived_cast {
N  static_assert(is_reference<_To>::value, "Wrong specialization");
N  using _RawFrom = __uncvref_t<_From>;
N  using _RawTo = __uncvref_t<_To>;
N  static const bool value = __lazy_and<
N        __lazy_not<is_same<_RawFrom, _RawTo>>,
N        is_base_of<_RawFrom, _RawTo>,
N        __lazy_not<__libcpp_is_constructible<_RawTo, _From>>
N  >::value;
N};
N
Ntemplate <class _To, class _From>
Nstruct __is_invalid_lvalue_to_rvalue_cast : false_type {
N  static_assert(is_reference<_To>::value, "Wrong specialization");
N};
N
Ntemplate <class _ToRef, class _FromRef>
Nstruct __is_invalid_lvalue_to_rvalue_cast<_ToRef&&, _FromRef&> {
N  using _RawFrom = __uncvref_t<_FromRef>;
N  using _RawTo = __uncvref_t<_ToRef>;
N  static const bool value = __lazy_and<
N      __lazy_not<is_function<_RawTo>>,
N      __lazy_or<
N        is_same<_RawFrom, _RawTo>,
N        is_base_of<_RawTo, _RawFrom>>
N    >::value;
N};
N
Nstruct __is_constructible_helper
N{
N    template <class _To>
N    static void __eat(_To);
N
N    // This overload is needed to work around a Clang bug that disallows
N    // static_cast<T&&>(e) for non-reference-compatible types.
N    // Example: static_cast<int&&>(declval<double>());
N    // NOTE: The static_cast implementation below is required to support
N    //  classes with explicit conversion operators.
N    template <class _To, class _From,
N              class = decltype(__eat<_To>(_VSTD::declval<_From>()))>
X              class = decltype(__eat<_To>(std::__2::declval<_From>()))>
N    static true_type __test_cast(int);
N
N    template <class _To, class _From,
N              class = decltype(static_cast<_To>(_VSTD::declval<_From>()))>
X              class = decltype(static_cast<_To>(std::__2::declval<_From>()))>
N    static integral_constant<bool,
N        !__is_invalid_base_to_derived_cast<_To, _From>::value &&
N        !__is_invalid_lvalue_to_rvalue_cast<_To, _From>::value
N    > __test_cast(long);
N
N    template <class, class>
N    static false_type __test_cast(...);
N
N    template <class _Tp, class ..._Args,
N        class = decltype(_Tp(_VSTD::declval<_Args>()...))>
X        class = decltype(_Tp(std::__2::declval<_Args>()...))>
N    static true_type __test_nary(int);
N    template <class _Tp, class...>
N    static false_type __test_nary(...);
N
N    template <class _Tp, class _A0, class = decltype(::new _Tp(_VSTD::declval<_A0>()))>
X    template <class _Tp, class _A0, class = decltype(::new _Tp(std::__2::declval<_A0>()))>
N    static is_destructible<_Tp> __test_unary(int);
N    template <class, class>
N    static false_type __test_unary(...);
N};
N
Ntemplate <class _Tp, bool = is_void<_Tp>::value>
Nstruct __is_default_constructible
N    : decltype(__is_constructible_helper::__test_nary<_Tp>(0))
N{};
N
Ntemplate <class _Tp>
Nstruct __is_default_constructible<_Tp, true> : false_type {};
N
Ntemplate <class _Tp>
Nstruct __is_default_constructible<_Tp[], false> : false_type {};
N
Ntemplate <class _Tp, size_t _Nx>
Nstruct __is_default_constructible<_Tp[_Nx], false>
N    : __is_default_constructible<typename remove_all_extents<_Tp>::type>  {};
N
Ntemplate <class _Tp, class... _Args>
Nstruct __libcpp_is_constructible
N{
N  static_assert(sizeof...(_Args) > 1, "Wrong specialization");
N  typedef decltype(__is_constructible_helper::__test_nary<_Tp, _Args...>(0))
N      type;
N};
N
Ntemplate <class _Tp>
Nstruct __libcpp_is_constructible<_Tp> : __is_default_constructible<_Tp> {};
N
Ntemplate <class _Tp, class _A0>
Nstruct __libcpp_is_constructible<_Tp, _A0>
N    : public decltype(__is_constructible_helper::__test_unary<_Tp, _A0>(0))
N{};
N
Ntemplate <class _Tp, class _A0>
Nstruct __libcpp_is_constructible<_Tp&, _A0>
N    : public decltype(__is_constructible_helper::
N    __test_cast<_Tp&, _A0>(0))
N{};
N
Ntemplate <class _Tp, class _A0>
Nstruct __libcpp_is_constructible<_Tp&&, _A0>
N    : public decltype(__is_constructible_helper::
N    __test_cast<_Tp&&, _A0>(0))
N{};
N
N#endif
N
N#if __has_feature(is_constructible)
X#if 0
Stemplate <class _Tp, class ..._Args>
Sstruct _LIBCPP_TEMPLATE_VIS is_constructible
S    : public integral_constant<bool, __is_constructible(_Tp, _Args...)>
S    {};
N#elif !defined(_LIBCPP_CXX03_LANG)
X#elif !0L
Ntemplate <class _Tp, class... _Args>
Nstruct _LIBCPP_TEMPLATE_VIS is_constructible
Xstruct  is_constructible
N    : public __libcpp_is_constructible<_Tp, _Args...>::type {};
N#else
S// template <class T> struct is_constructible0;
S
S//      main is_constructible0 test
S
Stemplate <class _Tp>
Sdecltype((_Tp(), true_type()))
S__is_constructible0_test(_Tp&);
S
Sfalse_type
S__is_constructible0_test(__any);
S
Stemplate <class _Tp, class _A0>
Sdecltype((_Tp(_VSTD::declval<_A0>()), true_type()))
S__is_constructible1_test(_Tp&, _A0&);
S
Stemplate <class _A0>
Sfalse_type
S__is_constructible1_test(__any, _A0&);
S
Stemplate <class _Tp, class _A0, class _A1>
Sdecltype((_Tp(_VSTD::declval<_A0>(), _VSTD::declval<_A1>()), true_type()))
S__is_constructible2_test(_Tp&, _A0&, _A1&);
S
Stemplate <class _A0, class _A1>
Sfalse_type
S__is_constructible2_test(__any, _A0&, _A1&);
S
Stemplate <bool, class _Tp>
Sstruct __is_constructible0_imp // false, _Tp is not a scalar
S    : public common_type
S             <
S                 decltype(__is_constructible0_test(declval<_Tp&>()))
S             >::type
S    {};
S
Stemplate <bool, class _Tp, class _A0>
Sstruct __is_constructible1_imp // false, _Tp is not a scalar
S    : public common_type
S             <
S                 decltype(__is_constructible1_test(declval<_Tp&>(), declval<_A0&>()))
S             >::type
S    {};
S
Stemplate <bool, class _Tp, class _A0, class _A1>
Sstruct __is_constructible2_imp // false, _Tp is not a scalar
S    : public common_type
S             <
S                 decltype(__is_constructible2_test(declval<_Tp&>(), declval<_A0>(), declval<_A1>()))
S             >::type
S    {};
S
S//      handle scalars and reference types
S
S//      Scalars are default constructible, references are not
S
Stemplate <class _Tp>
Sstruct __is_constructible0_imp<true, _Tp>
S    : public is_scalar<_Tp>
S    {};
S
Stemplate <class _Tp, class _A0>
Sstruct __is_constructible1_imp<true, _Tp, _A0>
S    : public is_convertible<_A0, _Tp>
S    {};
S
Stemplate <class _Tp, class _A0, class _A1>
Sstruct __is_constructible2_imp<true, _Tp, _A0, _A1>
S    : public false_type
S    {};
S
S//      Treat scalars and reference types separately
S
Stemplate <bool, class _Tp>
Sstruct __is_constructible0_void_check
S    : public __is_constructible0_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,
S                                _Tp>
S    {};
S
Stemplate <bool, class _Tp, class _A0>
Sstruct __is_constructible1_void_check
S    : public __is_constructible1_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,
S                                _Tp, _A0>
S    {};
S
Stemplate <bool, class _Tp, class _A0, class _A1>
Sstruct __is_constructible2_void_check
S    : public __is_constructible2_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,
S                                _Tp, _A0, _A1>
S    {};
S
S//      If any of T or Args is void, is_constructible should be false
S
Stemplate <class _Tp>
Sstruct __is_constructible0_void_check<true, _Tp>
S    : public false_type
S    {};
S
Stemplate <class _Tp, class _A0>
Sstruct __is_constructible1_void_check<true, _Tp, _A0>
S    : public false_type
S    {};
S
Stemplate <class _Tp, class _A0, class _A1>
Sstruct __is_constructible2_void_check<true, _Tp, _A0, _A1>
S    : public false_type
S    {};
S
S//      is_constructible entry point
S
Stemplate <class _Tp, class _A0 = __is_construct::__nat,
S                     class _A1 = __is_construct::__nat>
Sstruct _LIBCPP_TEMPLATE_VIS is_constructible
S    : public __is_constructible2_void_check<is_void<_Tp>::value
S                                        || is_abstract<_Tp>::value
S                                        || is_function<_Tp>::value
S                                        || is_void<_A0>::value
S                                        || is_void<_A1>::value,
S                                           _Tp, _A0, _A1>
S    {};
S
Stemplate <class _Tp>
Sstruct _LIBCPP_TEMPLATE_VIS is_constructible<_Tp, __is_construct::__nat, __is_construct::__nat>
S    : public __is_constructible0_void_check<is_void<_Tp>::value
S                                        || is_abstract<_Tp>::value
S                                        || is_function<_Tp>::value,
S                                           _Tp>
S    {};
S
Stemplate <class _Tp, class _A0>
Sstruct _LIBCPP_TEMPLATE_VIS is_constructible<_Tp, _A0, __is_construct::__nat>
S    : public __is_constructible1_void_check<is_void<_Tp>::value
S                                        || is_abstract<_Tp>::value
S                                        || is_function<_Tp>::value
S                                        || is_void<_A0>::value,
S                                           _Tp, _A0>
S    {};
S
S//      Array types are default constructible if their element type
S//      is default constructible
S
Stemplate <class _Ap, size_t _Np>
Sstruct __is_constructible0_imp<false, _Ap[_Np]>
S    : public is_constructible<typename remove_all_extents<_Ap>::type>
S    {};
S
Stemplate <class _Ap, size_t _Np, class _A0>
Sstruct __is_constructible1_imp<false, _Ap[_Np], _A0>
S    : public false_type
S    {};
S
Stemplate <class _Ap, size_t _Np, class _A0, class _A1>
Sstruct __is_constructible2_imp<false, _Ap[_Np], _A0, _A1>
S    : public false_type
S    {};
S
S//      Incomplete array types are not constructible
S
Stemplate <class _Ap>
Sstruct __is_constructible0_imp<false, _Ap[]>
S    : public false_type
S    {};
S
Stemplate <class _Ap, class _A0>
Sstruct __is_constructible1_imp<false, _Ap[], _A0>
S    : public false_type
S    {};
S
Stemplate <class _Ap, class _A0, class _A1>
Sstruct __is_constructible2_imp<false, _Ap[], _A0, _A1>
S    : public false_type
S    {};
S
N#endif // __has_feature(is_constructible)
N
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES) && !defined(_LIBCPP_HAS_NO_VARIADICS)
X#if 14 > 14 && !0L && !0L
Stemplate <class _Tp, class ..._Args> _LIBCPP_CONSTEXPR bool is_constructible_v
S    = is_constructible<_Tp, _Args...>::value;
N#endif
N
N// is_default_constructible
N
Ntemplate <class _Tp>
Nstruct _LIBCPP_TEMPLATE_VIS is_default_constructible
Xstruct  is_default_constructible
N    : public is_constructible<_Tp>
N    {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_default_constructible_v
S    = is_default_constructible<_Tp>::value;
N#endif
N
N// is_copy_constructible
N
Ntemplate <class _Tp>
Nstruct _LIBCPP_TEMPLATE_VIS is_copy_constructible
Xstruct  is_copy_constructible
N    : public is_constructible<_Tp, 
N                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_copy_constructible_v
S    = is_copy_constructible<_Tp>::value;
N#endif
N
N// is_move_constructible
N
Ntemplate <class _Tp>
Nstruct _LIBCPP_TEMPLATE_VIS is_move_constructible
Xstruct  is_move_constructible
N#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
N    : public is_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>
N#else
S    : public is_copy_constructible<_Tp>
N#endif
N    {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_move_constructible_v
S    = is_move_constructible<_Tp>::value;
N#endif
N
N// is_trivially_constructible
N
N#ifndef _LIBCPP_HAS_NO_VARIADICS
N
N#if __has_feature(is_trivially_constructible) || _GNUC_VER >= 501
X#if 1 || 0 >= 501
N
Ntemplate <class _Tp, class... _Args>
Nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible
Xstruct  is_trivially_constructible
N    : integral_constant<bool, __is_trivially_constructible(_Tp, _Args...)>
N{
N};
N
N#else  // !__has_feature(is_trivially_constructible)
S
Stemplate <class _Tp, class... _Args>
Sstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible
S    : false_type
S{
S};
S
Stemplate <class _Tp>
Sstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp>
S#if __has_feature(has_trivial_constructor) || (_GNUC_VER >= 403)
S    : integral_constant<bool, __has_trivial_constructor(_Tp)>
S#else
S    : integral_constant<bool, is_scalar<_Tp>::value>
S#endif
S{
S};
S
Stemplate <class _Tp>
S#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
Sstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp&&>
S#else
Sstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp>
S#endif
S    : integral_constant<bool, is_scalar<_Tp>::value>
S{
S};
S
Stemplate <class _Tp>
Sstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, const _Tp&>
S    : integral_constant<bool, is_scalar<_Tp>::value>
S{
S};
S
Stemplate <class _Tp>
Sstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp&>
S    : integral_constant<bool, is_scalar<_Tp>::value>
S{
S};
S
N#endif  // !__has_feature(is_trivially_constructible)
N
N#else  // _LIBCPP_HAS_NO_VARIADICS
S
Stemplate <class _Tp, class _A0 = __is_construct::__nat,
S                     class _A1 = __is_construct::__nat>
Sstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible
S    : false_type
S{
S};
S
S#if __has_feature(is_trivially_constructible) || _GNUC_VER >= 501
S
Stemplate <class _Tp>
Sstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, __is_construct::__nat,
S                                                       __is_construct::__nat>
S    : integral_constant<bool, __is_trivially_constructible(_Tp)>
S{
S};
S
Stemplate <class _Tp>
Sstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp,
S                                                       __is_construct::__nat>
S    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp)>
S{
S};
S
Stemplate <class _Tp>
Sstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, const _Tp&,
S                                                       __is_construct::__nat>
S    : integral_constant<bool, __is_trivially_constructible(_Tp, const _Tp&)>
S{
S};
S
Stemplate <class _Tp>
Sstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp&,
S                                                       __is_construct::__nat>
S    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp&)>
S{
S};
S
S#else  // !__has_feature(is_trivially_constructible)
S
Stemplate <class _Tp>
Sstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, __is_construct::__nat,
S                                                       __is_construct::__nat>
S    : integral_constant<bool, is_scalar<_Tp>::value>
S{
S};
S
Stemplate <class _Tp>
Sstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp,
S                                                       __is_construct::__nat>
S    : integral_constant<bool, is_scalar<_Tp>::value>
S{
S};
S
Stemplate <class _Tp>
Sstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, const _Tp&,
S                                                       __is_construct::__nat>
S    : integral_constant<bool, is_scalar<_Tp>::value>
S{
S};
S
Stemplate <class _Tp>
Sstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp&,
S                                                       __is_construct::__nat>
S    : integral_constant<bool, is_scalar<_Tp>::value>
S{
S};
S
S#endif  // !__has_feature(is_trivially_constructible)
S
N#endif  // _LIBCPP_HAS_NO_VARIADICS
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES) && !defined(_LIBCPP_HAS_NO_VARIADICS)
X#if 14 > 14 && !0L && !0L
Stemplate <class _Tp, class... _Args> _LIBCPP_CONSTEXPR bool is_trivially_constructible_v
S    = is_trivially_constructible<_Tp, _Args...>::value;
N#endif
N
N// is_trivially_default_constructible
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_default_constructible
Xtemplate <class _Tp> struct  is_trivially_default_constructible
N    : public is_trivially_constructible<_Tp>
N    {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_default_constructible_v
S    = is_trivially_default_constructible<_Tp>::value;
N#endif
N
N// is_trivially_copy_constructible
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_copy_constructible
Xtemplate <class _Tp> struct  is_trivially_copy_constructible
N    : public is_trivially_constructible<_Tp, typename add_lvalue_reference<const _Tp>::type>
N    {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_copy_constructible_v
S    = is_trivially_copy_constructible<_Tp>::value;
N#endif
N
N// is_trivially_move_constructible
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_move_constructible
Xtemplate <class _Tp> struct  is_trivially_move_constructible
N#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
N    : public is_trivially_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>
N#else
S    : public is_trivially_copy_constructible<_Tp>
N#endif
N    {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_move_constructible_v
S    = is_trivially_move_constructible<_Tp>::value;
N#endif
N
N// is_trivially_assignable
N
N#if __has_feature(is_trivially_assignable) || _GNUC_VER >= 501
X#if 1 || 0 >= 501
N
Ntemplate <class _Tp, class _Arg>
Nstruct is_trivially_assignable
N    : integral_constant<bool, __is_trivially_assignable(_Tp, _Arg)>
N{
N};
N
N#else  // !__has_feature(is_trivially_assignable)
S
Stemplate <class _Tp, class _Arg>
Sstruct is_trivially_assignable
S    : public false_type {};
S
Stemplate <class _Tp>
Sstruct is_trivially_assignable<_Tp&, _Tp>
S    : integral_constant<bool, is_scalar<_Tp>::value> {};
S
Stemplate <class _Tp>
Sstruct is_trivially_assignable<_Tp&, _Tp&>
S    : integral_constant<bool, is_scalar<_Tp>::value> {};
S
Stemplate <class _Tp>
Sstruct is_trivially_assignable<_Tp&, const _Tp&>
S    : integral_constant<bool, is_scalar<_Tp>::value> {};
S
S#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
S
Stemplate <class _Tp>
Sstruct is_trivially_assignable<_Tp&, _Tp&&>
S    : integral_constant<bool, is_scalar<_Tp>::value> {};
S
S#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
S
N#endif  // !__has_feature(is_trivially_assignable)
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp, class _Arg> _LIBCPP_CONSTEXPR bool is_trivially_assignable_v
S    = is_trivially_assignable<_Tp, _Arg>::value;
N#endif
N
N// is_trivially_copy_assignable
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_copy_assignable
Xtemplate <class _Tp> struct  is_trivially_copy_assignable
N    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,
N                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_copy_assignable_v
S    = is_trivially_copy_assignable<_Tp>::value;
N#endif
N
N// is_trivially_move_assignable
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_move_assignable
Xtemplate <class _Tp> struct  is_trivially_move_assignable
N    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,
N#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
N                                     typename add_rvalue_reference<_Tp>::type>
N#else
S                                     typename add_lvalue_reference<_Tp>::type>
N#endif
N    {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_move_assignable_v
S    = is_trivially_move_assignable<_Tp>::value;
N#endif
N
N// is_trivially_destructible
N
N#if __has_feature(has_trivial_destructor) || (_GNUC_VER >= 403)
X#if 1 || (0 >= 403)
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_destructible
Xtemplate <class _Tp> struct  is_trivially_destructible
N    : public integral_constant<bool, is_destructible<_Tp>::value && __has_trivial_destructor(_Tp)> {};
N
N#else
S
Stemplate <class _Tp> struct __libcpp_trivial_destructor
S    : public integral_constant<bool, is_scalar<_Tp>::value ||
S                                     is_reference<_Tp>::value> {};
S
Stemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_destructible
S    : public __libcpp_trivial_destructor<typename remove_all_extents<_Tp>::type> {};
S
Stemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_destructible<_Tp[]>
S    : public false_type {};
S
N#endif
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_destructible_v
S    = is_trivially_destructible<_Tp>::value;
N#endif
N
N// is_nothrow_constructible
N
N#if 0
Stemplate <class _Tp, class... _Args>
Sstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible
S    : public integral_constant<bool, __is_nothrow_constructible(_Tp(_Args...))>
S{
S};
S
N#else
N
N#ifndef _LIBCPP_HAS_NO_VARIADICS
N
N#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)
X#if 1 || (0 >= 407 && 201402L >= 201103L)
N
Ntemplate <bool, bool, class _Tp, class... _Args> struct __libcpp_is_nothrow_constructible;
N
Ntemplate <class _Tp, class... _Args>
Nstruct __libcpp_is_nothrow_constructible</*is constructible*/true, /*is reference*/false, _Tp, _Args...>
N    : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>
N{
N};
N
Ntemplate <class _Tp>
Nvoid __implicit_conversion_to(_Tp) noexcept { }
N
Ntemplate <class _Tp, class _Arg>
Nstruct __libcpp_is_nothrow_constructible</*is constructible*/true, /*is reference*/true, _Tp, _Arg>
N    : public integral_constant<bool, noexcept(__implicit_conversion_to<_Tp>(declval<_Arg>()))>
N{
N};
N
Ntemplate <class _Tp, bool _IsReference, class... _Args>
Nstruct __libcpp_is_nothrow_constructible</*is constructible*/false, _IsReference, _Tp, _Args...>
N    : public false_type
N{
N};
N
Ntemplate <class _Tp, class... _Args>
Nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible
Xstruct  is_nothrow_constructible
N    : __libcpp_is_nothrow_constructible<is_constructible<_Tp, _Args...>::value, is_reference<_Tp>::value, _Tp, _Args...>
N{
N};
N
Ntemplate <class _Tp, size_t _Ns>
Nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp[_Ns]>
Xstruct  is_nothrow_constructible<_Tp[_Ns]>
N    : __libcpp_is_nothrow_constructible<is_constructible<_Tp>::value, is_reference<_Tp>::value, _Tp>
N{
N};
N
N#else  // __has_feature(cxx_noexcept)
S
Stemplate <class _Tp, class... _Args>
Sstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible
S    : false_type
S{
S};
S
Stemplate <class _Tp>
Sstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp>
S#if __has_feature(has_nothrow_constructor) || (_GNUC_VER >= 403)
S    : integral_constant<bool, __has_nothrow_constructor(_Tp)>
S#else
S    : integral_constant<bool, is_scalar<_Tp>::value>
S#endif
S{
S};
S
Stemplate <class _Tp>
S#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
Sstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp&&>
S#else
Sstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp>
S#endif
S#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)
S    : integral_constant<bool, __has_nothrow_copy(_Tp)>
S#else
S    : integral_constant<bool, is_scalar<_Tp>::value>
S#endif
S{
S};
S
Stemplate <class _Tp>
Sstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, const _Tp&>
S#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)
S    : integral_constant<bool, __has_nothrow_copy(_Tp)>
S#else
S    : integral_constant<bool, is_scalar<_Tp>::value>
S#endif
S{
S};
S
Stemplate <class _Tp>
Sstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp&>
S#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)
S    : integral_constant<bool, __has_nothrow_copy(_Tp)>
S#else
S    : integral_constant<bool, is_scalar<_Tp>::value>
S#endif
S{
S};
S
N#endif  // __has_feature(cxx_noexcept)
N
N#else  // _LIBCPP_HAS_NO_VARIADICS
S
Stemplate <class _Tp, class _A0 = __is_construct::__nat,
S                     class _A1 = __is_construct::__nat>
Sstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible
S    : false_type
S{
S};
S
Stemplate <class _Tp>
Sstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, __is_construct::__nat,
S                                                       __is_construct::__nat>
S#if __has_feature(has_nothrow_constructor) || (_GNUC_VER >= 403)
S    : integral_constant<bool, __has_nothrow_constructor(_Tp)>
S#else
S    : integral_constant<bool, is_scalar<_Tp>::value>
S#endif
S{
S};
S
Stemplate <class _Tp>
Sstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp,
S                                                       __is_construct::__nat>
S#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)
S    : integral_constant<bool, __has_nothrow_copy(_Tp)>
S#else
S    : integral_constant<bool, is_scalar<_Tp>::value>
S#endif
S{
S};
S
Stemplate <class _Tp>
Sstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, const _Tp&,
S                                                       __is_construct::__nat>
S#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)
S    : integral_constant<bool, __has_nothrow_copy(_Tp)>
S#else
S    : integral_constant<bool, is_scalar<_Tp>::value>
S#endif
S{
S};
S
Stemplate <class _Tp>
Sstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp&,
S                                                       __is_construct::__nat>
S#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)
S    : integral_constant<bool, __has_nothrow_copy(_Tp)>
S#else
S    : integral_constant<bool, is_scalar<_Tp>::value>
S#endif
S{
S};
S
N#endif  // _LIBCPP_HAS_NO_VARIADICS
N#endif  // __has_feature(is_nothrow_constructible)
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES) && !defined(_LIBCPP_HAS_NO_VARIADICS)
X#if 14 > 14 && !0L && !0L
Stemplate <class _Tp, class ..._Args> _LIBCPP_CONSTEXPR bool is_nothrow_constructible_v
S    = is_nothrow_constructible<_Tp, _Args...>::value;
N#endif
N
N// is_nothrow_default_constructible
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_default_constructible
Xtemplate <class _Tp> struct  is_nothrow_default_constructible
N    : public is_nothrow_constructible<_Tp>
N    {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_default_constructible_v
S    = is_nothrow_default_constructible<_Tp>::value;
N#endif
N
N// is_nothrow_copy_constructible
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_copy_constructible
Xtemplate <class _Tp> struct  is_nothrow_copy_constructible
N    : public is_nothrow_constructible<_Tp,
N                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_copy_constructible_v
S    = is_nothrow_copy_constructible<_Tp>::value;
N#endif
N
N// is_nothrow_move_constructible
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_move_constructible
Xtemplate <class _Tp> struct  is_nothrow_move_constructible
N#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
N    : public is_nothrow_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>
N#else
S    : public is_nothrow_copy_constructible<_Tp>
N#endif
N    {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_move_constructible_v
S    = is_nothrow_move_constructible<_Tp>::value;
N#endif
N
N// is_nothrow_assignable
N
N#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)
X#if 1 || (0 >= 407 && 201402L >= 201103L)
N
Ntemplate <bool, class _Tp, class _Arg> struct __libcpp_is_nothrow_assignable;
N
Ntemplate <class _Tp, class _Arg>
Nstruct __libcpp_is_nothrow_assignable<false, _Tp, _Arg>
N    : public false_type
N{
N};
N
Ntemplate <class _Tp, class _Arg>
Nstruct __libcpp_is_nothrow_assignable<true, _Tp, _Arg>
N    : public integral_constant<bool, noexcept(_VSTD::declval<_Tp>() = _VSTD::declval<_Arg>()) >
X    : public integral_constant<bool, noexcept(std::__2::declval<_Tp>() = std::__2::declval<_Arg>()) >
N{
N};
N
Ntemplate <class _Tp, class _Arg>
Nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable
Xstruct  is_nothrow_assignable
N    : public __libcpp_is_nothrow_assignable<is_assignable<_Tp, _Arg>::value, _Tp, _Arg>
N{
N};
N
N#else  // __has_feature(cxx_noexcept)
S
Stemplate <class _Tp, class _Arg>
Sstruct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable
S    : public false_type {};
S
Stemplate <class _Tp>
Sstruct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable<_Tp&, _Tp>
S#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)
S    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};
S#else
S    : integral_constant<bool, is_scalar<_Tp>::value> {};
S#endif
S
Stemplate <class _Tp>
Sstruct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable<_Tp&, _Tp&>
S#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)
S    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};
S#else
S    : integral_constant<bool, is_scalar<_Tp>::value> {};
S#endif
S
Stemplate <class _Tp>
Sstruct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable<_Tp&, const _Tp&>
S#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)
S    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};
S#else
S    : integral_constant<bool, is_scalar<_Tp>::value> {};
S#endif
S
S#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
S
Stemplate <class _Tp>
Sstruct is_nothrow_assignable<_Tp&, _Tp&&>
S#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)
S    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};
S#else
S    : integral_constant<bool, is_scalar<_Tp>::value> {};
S#endif
S
S#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
S
N#endif  // __has_feature(cxx_noexcept)
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp, class _Arg> _LIBCPP_CONSTEXPR bool is_nothrow_assignable_v
S    = is_nothrow_assignable<_Tp, _Arg>::value;
N#endif
N
N// is_nothrow_copy_assignable
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_copy_assignable
Xtemplate <class _Tp> struct  is_nothrow_copy_assignable
N    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,
N                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_copy_assignable_v
S    = is_nothrow_copy_assignable<_Tp>::value;
N#endif
N
N// is_nothrow_move_assignable
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_move_assignable
Xtemplate <class _Tp> struct  is_nothrow_move_assignable
N    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,
N#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
N                                     typename add_rvalue_reference<_Tp>::type>
N#else
S                                     typename add_lvalue_reference<_Tp>::type>
N#endif
N    {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_move_assignable_v
S    = is_nothrow_move_assignable<_Tp>::value;
N#endif
N
N// is_nothrow_destructible
N
N#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)
X#if 1 || (0 >= 407 && 201402L >= 201103L)
N
Ntemplate <bool, class _Tp> struct __libcpp_is_nothrow_destructible;
N
Ntemplate <class _Tp>
Nstruct __libcpp_is_nothrow_destructible<false, _Tp>
N    : public false_type
N{
N};
N
Ntemplate <class _Tp>
Nstruct __libcpp_is_nothrow_destructible<true, _Tp>
N    : public integral_constant<bool, noexcept(_VSTD::declval<_Tp>().~_Tp()) >
X    : public integral_constant<bool, noexcept(std::__2::declval<_Tp>().~_Tp()) >
N{
N};
N
Ntemplate <class _Tp>
Nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible
Xstruct  is_nothrow_destructible
N    : public __libcpp_is_nothrow_destructible<is_destructible<_Tp>::value, _Tp>
N{
N};
N
Ntemplate <class _Tp, size_t _Ns>
Nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible<_Tp[_Ns]>
Xstruct  is_nothrow_destructible<_Tp[_Ns]>
N    : public is_nothrow_destructible<_Tp>
N{
N};
N
Ntemplate <class _Tp>
Nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible<_Tp&>
Xstruct  is_nothrow_destructible<_Tp&>
N    : public true_type
N{
N};
N
N#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
N
Ntemplate <class _Tp>
Nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible<_Tp&&>
Xstruct  is_nothrow_destructible<_Tp&&>
N    : public true_type
N{
N};
N
N#endif
N
N#else
S
Stemplate <class _Tp> struct __libcpp_nothrow_destructor
S    : public integral_constant<bool, is_scalar<_Tp>::value ||
S                                     is_reference<_Tp>::value> {};
S
Stemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible
S    : public __libcpp_nothrow_destructor<typename remove_all_extents<_Tp>::type> {};
S
Stemplate <class _Tp>
Sstruct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible<_Tp[]>
S    : public false_type {};
S
N#endif
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_destructible_v
S    = is_nothrow_destructible<_Tp>::value;
N#endif
N
N// is_pod
N
N#if __has_feature(is_pod) || (_GNUC_VER >= 403)
X#if 1 || (0 >= 403)
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_pod
Xtemplate <class _Tp> struct  is_pod
N    : public integral_constant<bool, __is_pod(_Tp)> {};
N
N#else
S
Stemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_pod
S    : public integral_constant<bool, is_trivially_default_constructible<_Tp>::value   &&
S                                     is_trivially_copy_constructible<_Tp>::value      &&
S                                     is_trivially_copy_assignable<_Tp>::value    &&
S                                     is_trivially_destructible<_Tp>::value> {};
S
N#endif
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_pod_v
S    = is_pod<_Tp>::value;
N#endif
N
N// is_literal_type;
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_literal_type
Xtemplate <class _Tp> struct  is_literal_type
N#ifdef _LIBCPP_IS_LITERAL
N    : public integral_constant<bool, _LIBCPP_IS_LITERAL(_Tp)>
X    : public integral_constant<bool, __is_literal_type(_Tp)>
N#else
S    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value ||
S                              is_reference<typename remove_all_extents<_Tp>::type>::value>
N#endif
N    {};
N    
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_literal_type_v
S    = is_literal_type<_Tp>::value;
N#endif
N
N// is_standard_layout;
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_standard_layout
Xtemplate <class _Tp> struct  is_standard_layout
N#if __has_feature(is_standard_layout) || (_GNUC_VER >= 407)
X#if 1 || (0 >= 407)
N    : public integral_constant<bool, __is_standard_layout(_Tp)>
N#else
S    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value>
N#endif
N    {};
N    
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_standard_layout_v
S    = is_standard_layout<_Tp>::value;
N#endif
N
N// is_trivially_copyable;
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_copyable
Xtemplate <class _Tp> struct  is_trivially_copyable
N#if __has_feature(is_trivially_copyable)
X#if 1
N    : public integral_constant<bool, __is_trivially_copyable(_Tp)>
N#elif _GNUC_VER >= 501
S    : public integral_constant<bool, !is_volatile<_Tp>::value && __is_trivially_copyable(_Tp)>
S#else
S    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value>
N#endif
N    {};
N    
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_copyable_v
S    = is_trivially_copyable<_Tp>::value;
N#endif
N
N// is_trivial;
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivial
Xtemplate <class _Tp> struct  is_trivial
N#if __has_feature(is_trivial) || _GNUC_VER >= 407
X#if 1 || 0 >= 407
N    : public integral_constant<bool, __is_trivial(_Tp)>
N#else
S    : integral_constant<bool, is_trivially_copyable<_Tp>::value &&
S                                 is_trivially_default_constructible<_Tp>::value>
N#endif
N    {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivial_v
S    = is_trivial<_Tp>::value;
N#endif
N
Ntemplate <class _Tp> struct __is_reference_wrapper_impl : public false_type {};
Ntemplate <class _Tp> struct __is_reference_wrapper_impl<reference_wrapper<_Tp> > : public true_type {};
Ntemplate <class _Tp> struct __is_reference_wrapper
N    : public __is_reference_wrapper_impl<typename remove_cv<_Tp>::type> {};
N
N#ifndef _LIBCPP_CXX03_LANG
N
N// Check for complete types
N
Ntemplate <class ..._Tp> struct __check_complete;
N
Ntemplate <>
Nstruct __check_complete<>
N{
N};
N
Ntemplate <class _Hp, class _T0, class ..._Tp>
Nstruct __check_complete<_Hp, _T0, _Tp...>
N    : private __check_complete<_Hp>,
N      private __check_complete<_T0, _Tp...>
N{
N};
N
Ntemplate <class _Hp>
Nstruct __check_complete<_Hp, _Hp>
N    : private __check_complete<_Hp>
N{
N};
N
Ntemplate <class _Tp>
Nstruct __check_complete<_Tp>
N{
N    static_assert(sizeof(_Tp) > 0, "Type must be complete.");
N};
N
Ntemplate <class _Tp>
Nstruct __check_complete<_Tp&>
N    : private __check_complete<_Tp>
N{
N};
N
Ntemplate <class _Tp>
Nstruct __check_complete<_Tp&&>
N    : private __check_complete<_Tp>
N{
N};
N
Ntemplate <class _Rp, class ..._Param>
Nstruct __check_complete<_Rp (*)(_Param...)>
N    : private __check_complete<_Rp>
N{
N};
N
Ntemplate <class ..._Param>
Nstruct __check_complete<void (*)(_Param...)>
N{
N};
N
Ntemplate <class _Rp, class ..._Param>
Nstruct __check_complete<_Rp (_Param...)>
N    : private __check_complete<_Rp>
N{
N};
N
Ntemplate <class ..._Param>
Nstruct __check_complete<void (_Param...)>
N{
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __check_complete<_Rp (_Class::*)(_Param...)>
N    : private __check_complete<_Class>
N{
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __check_complete<_Rp (_Class::*)(_Param...) const>
N    : private __check_complete<_Class>
N{
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile>
N    : private __check_complete<_Class>
N{
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile>
N    : private __check_complete<_Class>
N{
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __check_complete<_Rp (_Class::*)(_Param...) &>
N    : private __check_complete<_Class>
N{
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __check_complete<_Rp (_Class::*)(_Param...) const&>
N    : private __check_complete<_Class>
N{
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile&>
N    : private __check_complete<_Class>
N{
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile&>
N    : private __check_complete<_Class>
N{
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __check_complete<_Rp (_Class::*)(_Param...) &&>
N    : private __check_complete<_Class>
N{
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __check_complete<_Rp (_Class::*)(_Param...) const&&>
N    : private __check_complete<_Class>
N{
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile&&>
N    : private __check_complete<_Class>
N{
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile&&>
N    : private __check_complete<_Class>
N{
N};
N
Ntemplate <class _Rp, class _Class>
Nstruct __check_complete<_Rp _Class::*>
N    : private __check_complete<_Class>
N{
N};
N
N
Ntemplate <class _Fp, class _A0,
N         class _DecayFp = typename decay<_Fp>::type,
N         class _DecayA0 = typename decay<_A0>::type,
N         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
Nusing __enable_if_bullet1 = typename enable_if
N    <
N        is_member_function_pointer<_DecayFp>::value
N        && is_base_of<_ClassT, _DecayA0>::value
N    >::type;
N
Ntemplate <class _Fp, class _A0,
N         class _DecayFp = typename decay<_Fp>::type,
N         class _DecayA0 = typename decay<_A0>::type>
Nusing __enable_if_bullet2 = typename enable_if
N    <
N        is_member_function_pointer<_DecayFp>::value
N        && __is_reference_wrapper<_DecayA0>::value
N    >::type;
N
Ntemplate <class _Fp, class _A0,
N         class _DecayFp = typename decay<_Fp>::type,
N         class _DecayA0 = typename decay<_A0>::type,
N         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
Nusing __enable_if_bullet3 = typename enable_if
N    <
N        is_member_function_pointer<_DecayFp>::value
N        && !is_base_of<_ClassT, _DecayA0>::value
N        && !__is_reference_wrapper<_DecayA0>::value
N    >::type;
N
Ntemplate <class _Fp, class _A0,
N         class _DecayFp = typename decay<_Fp>::type,
N         class _DecayA0 = typename decay<_A0>::type,
N         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
Nusing __enable_if_bullet4 = typename enable_if
N    <
N        is_member_object_pointer<_DecayFp>::value
N        && is_base_of<_ClassT, _DecayA0>::value
N    >::type;
N
Ntemplate <class _Fp, class _A0,
N         class _DecayFp = typename decay<_Fp>::type,
N         class _DecayA0 = typename decay<_A0>::type>
Nusing __enable_if_bullet5 = typename enable_if
N    <
N        is_member_object_pointer<_DecayFp>::value
N        && __is_reference_wrapper<_DecayA0>::value
N    >::type;
N
Ntemplate <class _Fp, class _A0,
N         class _DecayFp = typename decay<_Fp>::type,
N         class _DecayA0 = typename decay<_A0>::type,
N         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
Nusing __enable_if_bullet6 = typename enable_if
N    <
N        is_member_object_pointer<_DecayFp>::value
N        && !is_base_of<_ClassT, _DecayA0>::value
N        && !__is_reference_wrapper<_DecayA0>::value
N    >::type;
N
N// __invoke forward declarations
N
N// fall back - none of the bullets
N
N#define _LIBCPP_INVOKE_RETURN(...) \
N    noexcept(noexcept(__VA_ARGS__)) -> decltype(__VA_ARGS__) \
N    { return __VA_ARGS__; }
X#define _LIBCPP_INVOKE_RETURN(...)     noexcept(noexcept(__VA_ARGS__)) -> decltype(__VA_ARGS__)     { return __VA_ARGS__; }
N
Ntemplate <class ..._Args>
Nauto __invoke(__any, _Args&& ...__args) -> __nat;
N
Ntemplate <class ..._Args>
Nauto __invoke_constexpr(__any, _Args&& ...__args) -> __nat;
N
N// bullets 1, 2 and 3
N
Ntemplate <class _Fp, class _A0, class ..._Args,
N          class = __enable_if_bullet1<_Fp, _A0>>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nauto
N__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
N_LIBCPP_INVOKE_RETURN((_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...))
Xnoexcept(noexcept((std::__2::forward<_A0>(__a0).*__f)(std::__2::forward<_Args>(__args)...))) -> decltype((std::__2::forward<_A0>(__a0).*__f)(std::__2::forward<_Args>(__args)...)) { return (std::__2::forward<_A0>(__a0).*__f)(std::__2::forward<_Args>(__args)...); }
N
Ntemplate <class _Fp, class _A0, class ..._Args,
N          class = __enable_if_bullet1<_Fp, _A0>>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_LIBCPP_CONSTEXPR auto
Xconstexpr auto
N__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
N_LIBCPP_INVOKE_RETURN((_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...))
Xnoexcept(noexcept((std::__2::forward<_A0>(__a0).*__f)(std::__2::forward<_Args>(__args)...))) -> decltype((std::__2::forward<_A0>(__a0).*__f)(std::__2::forward<_Args>(__args)...)) { return (std::__2::forward<_A0>(__a0).*__f)(std::__2::forward<_Args>(__args)...); }
N
Ntemplate <class _Fp, class _A0, class ..._Args,
N          class = __enable_if_bullet2<_Fp, _A0>>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nauto
N__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
N_LIBCPP_INVOKE_RETURN((__a0.get().*__f)(_VSTD::forward<_Args>(__args)...))
Xnoexcept(noexcept((__a0 . get().*__f)(std::__2::forward<_Args>(__args)...))) -> decltype((__a0 . get().*__f)(std::__2::forward<_Args>(__args)...)) { return (__a0 . get().*__f)(std::__2::forward<_Args>(__args)...); }
N
Ntemplate <class _Fp, class _A0, class ..._Args,
N          class = __enable_if_bullet2<_Fp, _A0>>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_LIBCPP_CONSTEXPR auto
Xconstexpr auto
N__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
N_LIBCPP_INVOKE_RETURN((__a0.get().*__f)(_VSTD::forward<_Args>(__args)...))
Xnoexcept(noexcept((__a0 . get().*__f)(std::__2::forward<_Args>(__args)...))) -> decltype((__a0 . get().*__f)(std::__2::forward<_Args>(__args)...)) { return (__a0 . get().*__f)(std::__2::forward<_Args>(__args)...); }
N
Ntemplate <class _Fp, class _A0, class ..._Args,
N          class = __enable_if_bullet3<_Fp, _A0>>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nauto
N__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
N_LIBCPP_INVOKE_RETURN(((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...))
Xnoexcept(noexcept(((*std::__2::forward<_A0>(__a0)).*__f)(std::__2::forward<_Args>(__args)...))) -> decltype(((*std::__2::forward<_A0>(__a0)).*__f)(std::__2::forward<_Args>(__args)...)) { return ((*std::__2::forward<_A0>(__a0)).*__f)(std::__2::forward<_Args>(__args)...); }
N
Ntemplate <class _Fp, class _A0, class ..._Args,
N          class = __enable_if_bullet3<_Fp, _A0>>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_LIBCPP_CONSTEXPR auto
Xconstexpr auto
N__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
N_LIBCPP_INVOKE_RETURN(((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...))
Xnoexcept(noexcept(((*std::__2::forward<_A0>(__a0)).*__f)(std::__2::forward<_Args>(__args)...))) -> decltype(((*std::__2::forward<_A0>(__a0)).*__f)(std::__2::forward<_Args>(__args)...)) { return ((*std::__2::forward<_A0>(__a0)).*__f)(std::__2::forward<_Args>(__args)...); }
N
N// bullets 4, 5 and 6
N
Ntemplate <class _Fp, class _A0,
N          class = __enable_if_bullet4<_Fp, _A0>>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nauto
N__invoke(_Fp&& __f, _A0&& __a0)
N_LIBCPP_INVOKE_RETURN(_VSTD::forward<_A0>(__a0).*__f)
Xnoexcept(noexcept(std::__2::forward<_A0>(__a0).*__f)) -> decltype(std::__2::forward<_A0>(__a0).*__f) { return std::__2::forward<_A0>(__a0).*__f; }
N
Ntemplate <class _Fp, class _A0,
N          class = __enable_if_bullet4<_Fp, _A0>>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_LIBCPP_CONSTEXPR auto
Xconstexpr auto
N__invoke_constexpr(_Fp&& __f, _A0&& __a0)
N_LIBCPP_INVOKE_RETURN(_VSTD::forward<_A0>(__a0).*__f)
Xnoexcept(noexcept(std::__2::forward<_A0>(__a0).*__f)) -> decltype(std::__2::forward<_A0>(__a0).*__f) { return std::__2::forward<_A0>(__a0).*__f; }
N
Ntemplate <class _Fp, class _A0,
N          class = __enable_if_bullet5<_Fp, _A0>>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nauto
N__invoke(_Fp&& __f, _A0&& __a0)
N_LIBCPP_INVOKE_RETURN(__a0.get().*__f)
Xnoexcept(noexcept(__a0 . get().*__f)) -> decltype(__a0 . get().*__f) { return __a0 . get().*__f; }
N
Ntemplate <class _Fp, class _A0,
N          class = __enable_if_bullet5<_Fp, _A0>>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_LIBCPP_CONSTEXPR auto
Xconstexpr auto
N__invoke_constexpr(_Fp&& __f, _A0&& __a0)
N_LIBCPP_INVOKE_RETURN(__a0.get().*__f)
Xnoexcept(noexcept(__a0 . get().*__f)) -> decltype(__a0 . get().*__f) { return __a0 . get().*__f; }
N
Ntemplate <class _Fp, class _A0,
N          class = __enable_if_bullet6<_Fp, _A0>>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nauto
N__invoke(_Fp&& __f, _A0&& __a0)
N_LIBCPP_INVOKE_RETURN((*_VSTD::forward<_A0>(__a0)).*__f)
Xnoexcept(noexcept((*std::__2::forward<_A0>(__a0)).*__f)) -> decltype((*std::__2::forward<_A0>(__a0)).*__f) { return (*std::__2::forward<_A0>(__a0)).*__f; }
N
Ntemplate <class _Fp, class _A0,
N          class = __enable_if_bullet6<_Fp, _A0>>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_LIBCPP_CONSTEXPR auto
Xconstexpr auto
N__invoke_constexpr(_Fp&& __f, _A0&& __a0)
N_LIBCPP_INVOKE_RETURN((*_VSTD::forward<_A0>(__a0)).*__f)
Xnoexcept(noexcept((*std::__2::forward<_A0>(__a0)).*__f)) -> decltype((*std::__2::forward<_A0>(__a0)).*__f) { return (*std::__2::forward<_A0>(__a0)).*__f; }
N
N// bullet 7
N
Ntemplate <class _Fp, class ..._Args>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nauto
N__invoke(_Fp&& __f, _Args&& ...__args)
N_LIBCPP_INVOKE_RETURN(_VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...))
Xnoexcept(noexcept(std::__2::forward<_Fp>(__f)(std::__2::forward<_Args>(__args)...))) -> decltype(std::__2::forward<_Fp>(__f)(std::__2::forward<_Args>(__args)...)) { return std::__2::forward<_Fp>(__f)(std::__2::forward<_Args>(__args)...); }
N
Ntemplate <class _Fp, class ..._Args>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_LIBCPP_CONSTEXPR auto
Xconstexpr auto
N__invoke_constexpr(_Fp&& __f, _Args&& ...__args)
N_LIBCPP_INVOKE_RETURN(_VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...))
Xnoexcept(noexcept(std::__2::forward<_Fp>(__f)(std::__2::forward<_Args>(__args)...))) -> decltype(std::__2::forward<_Fp>(__f)(std::__2::forward<_Args>(__args)...)) { return std::__2::forward<_Fp>(__f)(std::__2::forward<_Args>(__args)...); }
N
N#undef _LIBCPP_INVOKE_RETURN
N
N// __invokable
N
Ntemplate <class _Ret, class _Fp, class ..._Args>
Nstruct __invokable_r
N    : private __check_complete<_Fp>
N{
N    using _Result = decltype(
N        _VSTD::__invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...));
X        std::__2::__invoke(std::__2::declval<_Fp>(), std::__2::declval<_Args>()...));
N
N    using type =
N        typename conditional<
N            !is_same<_Result, __nat>::value,
N            typename conditional<
N                is_void<_Ret>::value,
N                true_type,
N                is_convertible<_Result, _Ret>
N            >::type,
N            false_type
N        >::type;
N    static const bool value = type::value;
N};
N
Ntemplate <class _Fp, class ..._Args>
Nusing __invokable = __invokable_r<void, _Fp, _Args...>;
N
Ntemplate <bool _IsInvokable, bool _IsCVVoid, class _Ret, class _Fp, class ..._Args>
Nstruct __nothrow_invokable_r_imp {
N  static const bool value = false;
N};
N
Ntemplate <class _Ret, class _Fp, class ..._Args>
Nstruct __nothrow_invokable_r_imp<true, false, _Ret, _Fp, _Args...>
N{
N    typedef __nothrow_invokable_r_imp _ThisT;
N
N    template <class _Tp>
N    static void __test_noexcept(_Tp) noexcept;
N
N    static const bool value = noexcept(_ThisT::__test_noexcept<_Ret>(
N        _VSTD::__invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...)));
X        std::__2::__invoke(std::__2::declval<_Fp>(), std::__2::declval<_Args>()...)));
N};
N
Ntemplate <class _Ret, class _Fp, class ..._Args>
Nstruct __nothrow_invokable_r_imp<true, true, _Ret, _Fp, _Args...>
N{
N    static const bool value = noexcept(
N        _VSTD::__invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...));
X        std::__2::__invoke(std::__2::declval<_Fp>(), std::__2::declval<_Args>()...));
N};
N
Ntemplate <class _Ret, class _Fp, class ..._Args>
Nusing __nothrow_invokable_r =
N    __nothrow_invokable_r_imp<
N            __invokable_r<_Ret, _Fp, _Args...>::value,
N            is_void<_Ret>::value,
N            _Ret, _Fp, _Args...
N    >;
N
Ntemplate <class _Fp, class ..._Args>
Nstruct __invoke_of
N    : public enable_if<
N        __invokable<_Fp, _Args...>::value,
N        typename __invokable_r<void, _Fp, _Args...>::_Result>
N{
N};
N
N// result_of
N
Ntemplate <class _Fp, class ..._Args>
Nclass _LIBCPP_TEMPLATE_VIS result_of<_Fp(_Args...)>
Xclass  result_of<_Fp(_Args...)>
N    : public __invoke_of<_Fp, _Args...>
N{
N};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _Tp> using result_of_t = typename result_of<_Tp>::type;
N#endif
N
N#if _LIBCPP_STD_VER > 14
X#if 14 > 14
S
S// is_callable
S
Stemplate <class _Fn, class _Ret = void>
Sstruct _LIBCPP_TEMPLATE_VIS is_callable;
S
Stemplate <class _Fn, class ..._Args, class _Ret>
Sstruct _LIBCPP_TEMPLATE_VIS is_callable<_Fn(_Args...), _Ret>
S    : integral_constant<bool, __invokable_r<_Ret, _Fn, _Args...>::value> {};
S
Stemplate <class _Fn, class _Ret = void>
Sconstexpr bool is_callable_v = is_callable<_Fn, _Ret>::value;
S
S// is_nothrow_callable
S
Stemplate <class _Fn, class _Ret = void>
Sstruct _LIBCPP_TEMPLATE_VIS is_nothrow_callable;
S
Stemplate <class _Fn, class ..._Args, class _Ret>
Sstruct _LIBCPP_TEMPLATE_VIS is_nothrow_callable<_Fn(_Args...), _Ret>
S    : integral_constant<bool, __nothrow_invokable_r<_Ret, _Fn, _Args...>::value>
S{};
S
Stemplate <class _Fn, class _Ret = void>
Sconstexpr bool is_nothrow_callable_v = is_nothrow_callable<_Fn, _Ret>::value;
S
N#endif // _LIBCPP_STD_VER > 14
N
N#endif  // !defined(_LIBCPP_CXX03_LANG)
N
Ntemplate <class _Tp> struct __is_swappable;
Ntemplate <class _Tp> struct __is_nothrow_swappable;
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N#ifndef _LIBCPP_CXX03_LANG
Ntypename enable_if
N<
N    is_move_constructible<_Tp>::value &&
N    is_move_assignable<_Tp>::value
N>::type
N#else
Svoid
N#endif
Nswap(_Tp& __x, _Tp& __y) _NOEXCEPT_(is_nothrow_move_constructible<_Tp>::value &&
N                                    is_nothrow_move_assignable<_Tp>::value)
Xswap(_Tp& __x, _Tp& __y) noexcept(is_nothrow_move_constructible<_Tp> ::value && is_nothrow_move_assignable<_Tp> ::value)
N{
N    _Tp __t(_VSTD::move(__x));
X    _Tp __t(std::__2::move(__x));
N    __x = _VSTD::move(__y);
X    __x = std::__2::move(__y);
N    __y = _VSTD::move(__t);
X    __y = std::__2::move(__t);
N}
N
Ntemplate<class _Tp, size_t _Np>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename enable_if<
N    __is_swappable<_Tp>::value
N>::type
Nswap(_Tp (&__a)[_Np], _Tp (&__b)[_Np]) _NOEXCEPT_(__is_nothrow_swappable<_Tp>::value);
Xswap(_Tp (&__a)[_Np], _Tp (&__b)[_Np]) noexcept(__is_nothrow_swappable<_Tp> ::value);
N
Ntemplate <class _ForwardIterator1, class _ForwardIterator2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Niter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
N    //                                  _NOEXCEPT_(_NOEXCEPT_(swap(*__a, *__b)))
N               _NOEXCEPT_(_NOEXCEPT_(swap(*_VSTD::declval<_ForwardIterator1>(),
N                                          *_VSTD::declval<_ForwardIterator2>())))
X               noexcept(noexcept(swap(*std::__2::declval<_ForwardIterator1>(), *std::__2::declval<_ForwardIterator2>())))
N{
N    swap(*__a, *__b);
N}
N
N// __swappable
N
Nnamespace __detail
N{
N// ALL generic swap overloads MUST already have a declaration available at this point.
N
Ntemplate <class _Tp, class _Up = _Tp,
N          bool _NotVoid = !is_void<_Tp>::value && !is_void<_Up>::value>
Nstruct __swappable_with
N{
N    template <class _LHS, class _RHS>
N    static decltype(swap(_VSTD::declval<_LHS>(), _VSTD::declval<_RHS>()))
X    static decltype(swap(std::__2::declval<_LHS>(), std::__2::declval<_RHS>()))
N    __test_swap(int);
N    template <class, class>
N    static __nat __test_swap(long);
N
N    // Extra parens are needed for the C++03 definition of decltype.
N    typedef decltype((__test_swap<_Tp, _Up>(0))) __swap1;
N    typedef decltype((__test_swap<_Up, _Tp>(0))) __swap2;
N
N    static const bool value = !is_same<__swap1, __nat>::value
N                           && !is_same<__swap2, __nat>::value;
N};
N
Ntemplate <class _Tp, class _Up>
Nstruct __swappable_with<_Tp, _Up,  false> : false_type {};
N
Ntemplate <class _Tp, class _Up = _Tp, bool _Swappable = __swappable_with<_Tp, _Up>::value>
Nstruct __nothrow_swappable_with {
N  static const bool value =
N#ifndef _LIBCPP_HAS_NO_NOEXCEPT
N      noexcept(swap(_VSTD::declval<_Tp>(), _VSTD::declval<_Up>()))
X      noexcept(swap(std::__2::declval<_Tp>(), std::__2::declval<_Up>()))
N  &&  noexcept(swap(_VSTD::declval<_Up>(), _VSTD::declval<_Tp>()));
X  &&  noexcept(swap(std::__2::declval<_Up>(), std::__2::declval<_Tp>()));
N#else
S      false;
N#endif
N};
N
Ntemplate <class _Tp, class _Up>
Nstruct __nothrow_swappable_with<_Tp, _Up, false> : false_type {};
N
N}  // __detail
N
Ntemplate <class _Tp>
Nstruct __is_swappable
N    : public integral_constant<bool, __detail::__swappable_with<_Tp&>::value>
N{
N};
N
Ntemplate <class _Tp>
Nstruct __is_nothrow_swappable
N    : public integral_constant<bool, __detail::__nothrow_swappable_with<_Tp&>::value>
N{
N};
N
N#if _LIBCPP_STD_VER > 14
X#if 14 > 14
S
Stemplate <class _Tp, class _Up>
Sstruct _LIBCPP_TEMPLATE_VIS is_swappable_with
S    : public integral_constant<bool, __detail::__swappable_with<_Tp, _Up>::value>
S{
S};
S
Stemplate <class _Tp>
Sstruct _LIBCPP_TEMPLATE_VIS is_swappable
S    : public conditional<
S        __is_referenceable<_Tp>::value,
S        is_swappable_with<
S            typename add_lvalue_reference<_Tp>::type,
S            typename add_lvalue_reference<_Tp>::type>,
S        false_type
S    >::type
S{
S};
S
Stemplate <class _Tp, class _Up>
Sstruct _LIBCPP_TEMPLATE_VIS is_nothrow_swappable_with
S    : public integral_constant<bool, __detail::__nothrow_swappable_with<_Tp, _Up>::value>
S{
S};
S
Stemplate <class _Tp>
Sstruct _LIBCPP_TEMPLATE_VIS is_nothrow_swappable
S    : public conditional<
S        __is_referenceable<_Tp>::value,
S        is_nothrow_swappable_with<
S            typename add_lvalue_reference<_Tp>::type,
S            typename add_lvalue_reference<_Tp>::type>,
S        false_type
S    >::type
S{
S};
S
Stemplate <class _Tp, class _Up>
Sconstexpr bool is_swappable_with_v = is_swappable_with<_Tp, _Up>::value;
S
Stemplate <class _Tp>
Sconstexpr bool is_swappable_v = is_swappable<_Tp>::value;
S
Stemplate <class _Tp, class _Up>
Sconstexpr bool is_nothrow_swappable_with_v = is_nothrow_swappable_with<_Tp, _Up>::value;
S
Stemplate <class _Tp>
Sconstexpr bool is_nothrow_swappable_v = is_nothrow_swappable<_Tp>::value;
S
N#endif // _LIBCPP_STD_VER > 14
N
N#ifdef _LIBCPP_UNDERLYING_TYPE
N
Ntemplate <class _Tp>
Nstruct underlying_type
N{
N    typedef _LIBCPP_UNDERLYING_TYPE(_Tp) type;
X    typedef __underlying_type(_Tp) type;
N};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _Tp> using underlying_type_t = typename underlying_type<_Tp>::type;
N#endif
N
N#else  // _LIBCPP_UNDERLYING_TYPE
S
Stemplate <class _Tp, bool _Support = false>
Sstruct underlying_type
S{
S    static_assert(_Support, "The underyling_type trait requires compiler "
S                            "support. Either no such support exists or "
S                            "libc++ does not know how to use it.");
S};
S
N#endif // _LIBCPP_UNDERLYING_TYPE
N
N
Ntemplate <class _Tp, bool = is_enum<_Tp>::value>
Nstruct __sfinae_underlying_type
N{
N    typedef typename underlying_type<_Tp>::type type;
N    typedef decltype(((type)1) + 0) __promoted_type;
N};
N
Ntemplate <class _Tp>
Nstruct __sfinae_underlying_type<_Tp, false> {};
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nint __convert_to_integral(int __val) { return __val; }
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nunsigned __convert_to_integral(unsigned __val) { return __val; }
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nlong __convert_to_integral(long __val) { return __val; }
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nunsigned long __convert_to_integral(unsigned long __val) { return __val; }
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nlong long __convert_to_integral(long long __val) { return __val; }
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nunsigned long long __convert_to_integral(unsigned long long __val) {return __val; }
N
N#ifndef _LIBCPP_HAS_NO_INT128
Sinline _LIBCPP_INLINE_VISIBILITY
S__int128_t __convert_to_integral(__int128_t __val) { return __val; }
S
Sinline _LIBCPP_INLINE_VISIBILITY
S__uint128_t __convert_to_integral(__uint128_t __val) { return __val; }
N#endif
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename __sfinae_underlying_type<_Tp>::__promoted_type
N__convert_to_integral(_Tp __val) { return __val; }
N
N#ifndef _LIBCPP_CXX03_LANG
N
Ntemplate <class _Tp>
Nstruct __has_operator_addressof_member_imp
N{
N    template <class _Up>
N        static auto __test(int)
N            -> typename __select_2nd<decltype(_VSTD::declval<_Up>().operator&()), true_type>::type;
X            -> typename __select_2nd<decltype(std::__2::declval<_Up>().operator&()), true_type>::type;
N    template <class>
N        static auto __test(long) -> false_type;
N
N    static const bool value = decltype(__test<_Tp>(0))::value;
N};
N
Ntemplate <class _Tp>
Nstruct __has_operator_addressof_free_imp
N{
N    template <class _Up>
N        static auto __test(int)
N            -> typename __select_2nd<decltype(operator&(_VSTD::declval<_Up>())), true_type>::type;
X            -> typename __select_2nd<decltype(operator&(std::__2::declval<_Up>())), true_type>::type;
N    template <class>
N        static auto __test(long) -> false_type;
N
N    static const bool value = decltype(__test<_Tp>(0))::value;
N};
N
Ntemplate <class _Tp>
Nstruct __has_operator_addressof
N    : public integral_constant<bool, __has_operator_addressof_member_imp<_Tp>::value
N                                  || __has_operator_addressof_free_imp<_Tp>::value>
N{};
N
N#endif  // _LIBCPP_CXX03_LANG
N
N#if _LIBCPP_STD_VER > 14
X#if 14 > 14
S
S#define __cpp_lib_void_t 201411
Stemplate <class...> using void_t = void;
S
S# ifndef _LIBCPP_HAS_NO_VARIADICS
Stemplate <class... _Args>
Sstruct conjunction : __and_<_Args...> {};
Stemplate<class... _Args> constexpr bool conjunction_v = conjunction<_Args...>::value;
S
Stemplate <class... _Args>
Sstruct disjunction : __or_<_Args...> {};
Stemplate<class... _Args> constexpr bool disjunction_v = disjunction<_Args...>::value;
S
Stemplate <class _Tp>
Sstruct negation : __not_<_Tp> {};
Stemplate<class _Tp> constexpr bool negation_v = negation<_Tp>::value;
S# endif // _LIBCPP_HAS_NO_VARIADICS
N#endif  // _LIBCPP_STD_VER > 14
N
N// These traits are used in __tree and __hash_table
N#ifndef _LIBCPP_CXX03_LANG
Nstruct __extract_key_fail_tag {};
Nstruct __extract_key_self_tag {};
Nstruct __extract_key_first_tag {};
N
Ntemplate <class _ValTy, class _Key,
N          class _RawValTy = typename __unconstref<_ValTy>::type>
Nstruct __can_extract_key
N    : conditional<is_same<_RawValTy, _Key>::value, __extract_key_self_tag,
N                  __extract_key_fail_tag>::type {};
N
Ntemplate <class _Pair, class _Key, class _First, class _Second>
Nstruct __can_extract_key<_Pair, _Key, pair<_First, _Second>>
N    : conditional<is_same<typename remove_const<_First>::type, _Key>::value,
N                  __extract_key_first_tag, __extract_key_fail_tag>::type {};
N
N// __can_extract_map_key uses true_type/false_type instead of the tags.
N// It returns true if _Key != _ContainerValueTy (the container is a map not a set)
N// and _ValTy == _Key.
Ntemplate <class _ValTy, class _Key, class _ContainerValueTy,
N          class _RawValTy = typename __unconstref<_ValTy>::type>
Nstruct __can_extract_map_key
N    : integral_constant<bool, is_same<_RawValTy, _Key>::value> {};
N
N// This specialization returns __extract_key_fail_tag for non-map containers
N// because _Key == _ContainerValueTy
Ntemplate <class _ValTy, class _Key, class _RawValTy>
Nstruct __can_extract_map_key<_ValTy, _Key, _Key, _RawValTy>
N    : false_type {};
N
N#endif
N
N_LIBCPP_END_NAMESPACE_STD
X} }
N
N#if _LIBCPP_STD_VER > 14
X#if 14 > 14
S// std::byte
Snamespace std  // purposefully not versioned
S{
Stemplate <class _Integer>
S  constexpr typename enable_if<is_integral_v<_Integer>, byte>::type &
S  operator<<=(byte& __lhs, _Integer __shift) noexcept
S  { return __lhs = byte(static_cast<unsigned char>(__lhs) << __shift); }
S  
Stemplate <class _Integer>
S  constexpr typename enable_if<is_integral_v<_Integer>, byte>::type
S  operator<< (byte  __lhs, _Integer __shift) noexcept
S  { return         byte(static_cast<unsigned char>(__lhs) << __shift); }
S
Stemplate <class _Integer>
S  constexpr typename enable_if<is_integral_v<_Integer>, byte>::type &
S  operator>>=(byte& __lhs, _Integer __shift) noexcept
S  { return __lhs = byte(static_cast<unsigned char>(__lhs) >> __shift); }
S
Stemplate <class _Integer>
S  constexpr typename enable_if<is_integral_v<_Integer>, byte>::type
S  operator>> (byte  __lhs, _Integer __shift) noexcept
S  { return         byte(static_cast<unsigned char>(__lhs) >> __shift); }
S  
Stemplate <class _Integer>
S  constexpr typename enable_if<is_integral_v<_Integer>, _Integer>::type
S  to_integer(byte __b) noexcept { return _Integer(__b); }
S
S}
N#endif
N
N#endif  // _LIBCPP_TYPE_TRAITS
L 641 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/algorithm" 2
N#include <cstring>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/cstring" 1
N// -*- C++ -*-
N//===--------------------------- cstring ----------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is distributed under the University of Illinois Open Source
N// License. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP_CSTRING
N#define _LIBCPP_CSTRING
N
N/*
N    cstring synopsis
N
NMacros:
N
N    NULL
N
Nnamespace std
N{
N
NTypes:
N
N    size_t
N
Nvoid* memcpy(void* restrict s1, const void* restrict s2, size_t n);
Nvoid* memmove(void* s1, const void* s2, size_t n);
Nchar* strcpy (char* restrict s1, const char* restrict s2);
Nchar* strncpy(char* restrict s1, const char* restrict s2, size_t n);
Nchar* strcat (char* restrict s1, const char* restrict s2);
Nchar* strncat(char* restrict s1, const char* restrict s2, size_t n);
Nint memcmp(const void* s1, const void* s2, size_t n);
Nint strcmp (const char* s1, const char* s2);
Nint strncmp(const char* s1, const char* s2, size_t n);
Nint strcoll(const char* s1, const char* s2);
Nsize_t strxfrm(char* restrict s1, const char* restrict s2, size_t n);
Nconst void* memchr(const void* s, int c, size_t n);
N      void* memchr(      void* s, int c, size_t n);
Nconst char* strchr(const char* s, int c);
N      char* strchr(      char* s, int c);
Nsize_t strcspn(const char* s1, const char* s2);
Nconst char* strpbrk(const char* s1, const char* s2);
N      char* strpbrk(      char* s1, const char* s2);
Nconst char* strrchr(const char* s, int c);
N      char* strrchr(      char* s, int c);
Nsize_t strspn(const char* s1, const char* s2);
Nconst char* strstr(const char* s1, const char* s2);
N      char* strstr(      char* s1, const char* s2);
Nchar* strtok(char* restrict s1, const char* restrict s2);
Nvoid* memset(void* s, int c, size_t n);
Nchar* strerror(int errnum);
Nsize_t strlen(const char* s);
N
N}  // std
N
N*/
N
N#include <__config>
N#include <string.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/string.h" 1
N/* -*- C++ -*- */
N/*===--------------------------- complex.h --------------------------------===*/
N/*                                                                            */
N/*                     The LLVM Compiler Infrastructure                       */
N/*                                                                            */
N/* This file is dual licensed under the MIT and the University of Illinois Open
N** Source Licenses. See LICENSE.TXT for details.
N*/
N/*===----------------------------------------------------------------------===*/
N
N#ifndef _LIBCPP_STRING_H
N#define _LIBCPP_STRING_H
N
N/*
N    string.h synopsis
N
NMacros:
N
N    NULL
N
NTypes:
N
N    size_t
N
Nvoid* memcpy(void* restrict s1, const void* restrict s2, size_t n);
Nvoid* memmove(void* s1, const void* s2, size_t n);
Nchar* strcpy (char* restrict s1, const char* restrict s2);
Nchar* strncpy(char* restrict s1, const char* restrict s2, size_t n);
Nchar* strcat (char* restrict s1, const char* restrict s2);
Nchar* strncat(char* restrict s1, const char* restrict s2, size_t n);
Nint memcmp(const void* s1, const void* s2, size_t n);
Nint strcmp (const char* s1, const char* s2);
Nint strncmp(const char* s1, const char* s2, size_t n);
Nint strcoll(const char* s1, const char* s2);
Nsize_t strxfrm(char* restrict s1, const char* restrict s2, size_t n);
Nconst void* memchr(const void* s, int c, size_t n);
N      void* memchr(      void* s, int c, size_t n);
Nconst char* strchr(const char* s, int c);
N      char* strchr(      char* s, int c);
Nsize_t strcspn(const char* s1, const char* s2);
Nconst char* strpbrk(const char* s1, const char* s2);
N      char* strpbrk(      char* s1, const char* s2);
Nconst char* strrchr(const char* s, int c);
N      char* strrchr(      char* s, int c);
Nsize_t strspn(const char* s1, const char* s2);
Nconst char* strstr(const char* s1, const char* s2);
N      char* strstr(      char* s1, const char* s2);
Nchar* strtok(char* restrict s1, const char* restrict s2);
Nvoid* memset(void* s, int c, size_t n);
Nchar* strerror(int errnum);
Nsize_t strlen(const char* s);
N
N*/
N
N#include <__config>
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N#include_next <string.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/string.h" 1
N/*****************************************************************************/
N/* string.h                                                                  */
N/*                                                                           */
N/* Copyright (c) 1993 Texas Instruments Incorporated                         */
N/* http://www.ti.com/                                                        */
N/*                                                                           */
N/*  Redistribution and  use in source  and binary forms, with  or without    */
N/*  modification,  are permitted provided  that the  following conditions    */
N/*  are met:                                                                 */
N/*                                                                           */
N/*     Redistributions  of source  code must  retain the  above copyright    */
N/*     notice, this list of conditions and the following disclaimer.         */
N/*                                                                           */
N/*     Redistributions in binary form  must reproduce the above copyright    */
N/*     notice, this  list of conditions  and the following  disclaimer in    */
N/*     the  documentation  and/or   other  materials  provided  with  the    */
N/*     distribution.                                                         */
N/*                                                                           */
N/*     Neither the  name of Texas Instruments Incorporated  nor the names    */
N/*     of its  contributors may  be used to  endorse or  promote products    */
N/*     derived  from   this  software  without   specific  prior  written    */
N/*     permission.                                                           */
N/*                                                                           */
N/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS    */
N/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT    */
N/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    */
N/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT    */
N/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    */
N/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT    */
N/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    */
N/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    */
N/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT    */
N/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    */
N/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     */
N/*                                                                           */
N/*****************************************************************************/
N
N#ifndef _STRING_H_
N#define _STRING_H_
N
N#if defined(__TMS320C2000__)
X#if 0L
S#if defined(__TMS320C28XX_CLA__)
S#error "Header file <string.h> not supported by CLA compiler"
S#endif
N#endif
N
N#pragma diag_push
N#pragma CHECK_MISRA("-6.3") /* standard types required for standard headers */
N#pragma CHECK_MISRA("-19.1") /* #includes required for implementation */
N#pragma CHECK_MISRA("-20.1") /* standard headers must define standard names */
N#pragma CHECK_MISRA("-20.2") /* standard headers must define standard names */
N
N#ifdef __cplusplus
Nextern "C" {
N#endif /* __cplusplus */
N
N#ifndef NULL
S#define NULL 0
N#endif
N
N#ifndef _SIZE_T_DECLARED
S#define _SIZE_T_DECLARED
S#ifdef __clang__
Stypedef __SIZE_TYPE__ size_t;
S#else
Stypedef __SIZE_T_TYPE__ size_t;
S#endif
N#endif
N
N#include <_ti_config.h>
N
N#pragma diag_push
N#pragma CHECK_MISRA("-19.4") /* macros required for implementation */
N
N#if defined(_OPTIMIZE_FOR_SPACE) && (defined(__ARM_ARCH) || 		\
N				     defined(__TMS320C2000__)  ||       \
N                                     defined(__MSP430__))
X#if 1L && (1L || 						     0L  ||                                            0L)
N#define _OPT_IDECL
N#else
S#define _OPT_IDECL	_IDECL
N#endif
N
N#pragma diag_pop
N
N_OPT_IDECL size_t  strlen(const char *string);
X size_t  strlen(const char *string);
N
N_OPT_IDECL char *strcpy(char * __restrict dest,
X char *strcpy(char * __restrict dest,
N                        const char * __restrict src);
N_OPT_IDECL char *strncpy(char * __restrict dest,
X char *strncpy(char * __restrict dest,
N                         const char * __restrict src, size_t n);
N_OPT_IDECL char *strcat(char * __restrict string1,
X char *strcat(char * __restrict string1,
N                        const char * __restrict string2);
N_OPT_IDECL char *strncat(char * __restrict dest,
X char *strncat(char * __restrict dest,
N                         const char * __restrict src, size_t n);
N_OPT_IDECL char *strchr(const char *string, int c);
X char *strchr(const char *string, int c);
N_OPT_IDECL char *strrchr(const char *string, int c);
X char *strrchr(const char *string, int c);
N
N_OPT_IDECL int  strcmp(const char *string1, const char *string2);
X int  strcmp(const char *string1, const char *string2);
N_OPT_IDECL int  strncmp(const char *string1, const char *string2, size_t n);
X int  strncmp(const char *string1, const char *string2, size_t n);
N
N_CODE_ACCESS int     strcoll(const char *string1, const char *_string2);
X int     strcoll(const char *string1, const char *_string2);
N_CODE_ACCESS size_t  strxfrm(char * __restrict to,
X size_t  strxfrm(char * __restrict to,
N                             const char * __restrict from, size_t n);
N_CODE_ACCESS char   *strpbrk(const char *string, const char *chs);
X char   *strpbrk(const char *string, const char *chs);
N_CODE_ACCESS size_t  strspn(const char *string, const char *chs);
X size_t  strspn(const char *string, const char *chs);
N_CODE_ACCESS size_t  strcspn(const char *string, const char *chs);
X size_t  strcspn(const char *string, const char *chs);
N_CODE_ACCESS char   *strstr(const char *string1, const char *string2);
X char   *strstr(const char *string1, const char *string2);
N_CODE_ACCESS char   *strtok(char * __restrict str1,
X char   *strtok(char * __restrict str1,
N                            const char * __restrict str2);
N_CODE_ACCESS char   *strerror(int _errno);
X char   *strerror(int _errno);
N_CODE_ACCESS char   *strdup(const char *string);
X char   *strdup(const char *string);
N
N
N_CODE_ACCESS void   *memmove(void *s1, const void *s2, size_t n);
X void   *memmove(void *s1, const void *s2, size_t n);
N#pragma diag_push
N#pragma CHECK_MISRA("-16.4") /* false positives due to builtin declarations */
N_CODE_ACCESS void   *memcpy(void * __restrict s1,
X void   *memcpy(void * __restrict s1,
N                            const void * __restrict s2, size_t n);
N#pragma diag_pop
N
N_OPT_IDECL int     memcmp(const void *cs, const void *ct, size_t n);
X int     memcmp(const void *cs, const void *ct, size_t n);
N_OPT_IDECL void   *memchr(const void *cs, int c, size_t n);
X void   *memchr(const void *cs, int c, size_t n);
N
N#if (defined(_TMS320C6X) && !defined(__C6X_MIGRATION__)) || \
N    defined(__ARM_ARCH) || defined(__ARP32__) || defined(__C7000__)
X#if (0L && !0L) ||     1L || 0L || 0L
N_CODE_ACCESS void   *memset(void *mem, int ch, size_t length);
X void   *memset(void *mem, int ch, size_t length);
N#else
S_OPT_IDECL   void   *memset(void *mem, int ch, size_t length);
N#endif
N
N#if defined(__TMS320C2000__) && !defined(__TI_EABI__)
X#if 0L && !1L
S
S#ifndef __cplusplus
S
S#pragma diag_push
S
S/* keep macros as direct #defines and not function-like macros or function
S   names surrounded by parentheses to support all original supported use cases
S   including taking their address through the macros and prefixing with
S   namespace macros */
S#pragma CHECK_MISRA("-19.4")
S#define far_memcpy __memcpy_ff
S#define far_strcpy strcpy_ff
S
S#pragma diag_pop
S
Ssize_t    far_strlen(const char *s);
Schar     *strcpy_nf(char *s1, const char *s2);
Schar *strcpy_fn(char *s1, const char *s2);
Schar *strcpy_ff(char *s1, const char *s2);
Schar *far_strncpy(char *s1, const char *s2, size_t n);
Schar *far_strcat(char *s1, const char *s2);
Schar *far_strncat(char *s1, const char *s2, size_t n);
Schar *far_strchr(const char *s, int c);
Schar *far_strrchr(const char *s, int c);
Sint       far_strcmp(const char *s1, const char *s2);
Sint       far_strncmp(const char *s1, const char *s2, size_t n);
Sint       far_strcoll(const char *s1, const char *s2);
Ssize_t    far_strxfrm(char *s1, const char *s2, size_t n);
Schar *far_strpbrk(const char *s1, const char *s2);
Ssize_t    far_strspn(const char *s1, const char *s2);
Ssize_t    far_strcspn(const char *s1, const char *s2);
Schar *far_strstr(const char *s1, const char *s2);
Schar *far_strtok(char *s1, const char *s2);
Schar *far_strerror(int _errno);
Svoid *far_memmove(void *s1, const void *s2, size_t n);
Svoid     *__memcpy_nf (void *_s1, const void *_s2, size_t _n);
Svoid *__memcpy_fn (void *_s1, const void *_s2, size_t _n);
Svoid *__memcpy_ff (void *_s1, const void *_s2, size_t _n);
Sint       far_memcmp(const void *s1, const void *s2, size_t n);
Svoid *far_memchr(const void *s, int c, size_t n);
Svoid *far_memset(void *s, int c, size_t n);
Svoid *far_memlcpy(void *to, const void *from,
S                        unsigned long n);
Svoid *far_memlmove(void *to, const void *from,
S                         unsigned long n);
S#else /* __cplusplus */
Slong      far_memlcpy(long to, long from, unsigned long n);
Slong      far_memlmove(long to, long from, unsigned long n);
S#endif /* __cplusplus */
S
N#endif /* __TMS320C2000__ && !defined(__TI_EABI__) */
N
N#ifdef __cplusplus
N} /* extern "C" */
N#endif /* __cplusplus */
N
N#if defined(_INLINE) || defined(_STRING_IMPLEMENTATION)
X#if 0L || 0L
S
S#if (defined(_STRING_IMPLEMENTATION) ||					\
S     !(defined(_OPTIMIZE_FOR_SPACE) && (defined(__ARM_ARCH) || 		\
S					defined(__TMS320C2000__)  ||    \
S                                        defined(__MSP430__))))
X#if (defined(_STRING_IMPLEMENTATION) ||					     !(defined(_OPTIMIZE_FOR_SPACE) && (defined(__ARM_ARCH) || 							defined(__TMS320C2000__)  ||                                            defined(__MSP430__))))
S
S#pragma diag_push
S#pragma CHECK_MISRA("-19.4") /* macros required for implementation */
S
S#if (defined(_OPTIMIZE_FOR_SPACE) && (defined(__ARM_ARCH) || 		\
S				      defined(__TMS320C2000__) ||       \
S                                      defined(__MSP430__)))
X#if (defined(_OPTIMIZE_FOR_SPACE) && (defined(__ARM_ARCH) || 						      defined(__TMS320C2000__) ||                                             defined(__MSP430__)))
S#define _OPT_IDEFN
S#else
S#define _OPT_IDEFN	_IDEFN
S#endif
S
S#pragma diag_pop
S
S#pragma diag_push /* functions */
S
S/* MISRA exceptions to avoid changing inline versions of the functions that
S   would be linked in instead of included inline at different mf levels */
S/* these functions are very well-tested, stable, and efficient; it would
S   introduce a high risk to implement new, separate MISRA versions just for the
S   inline headers */
S
S#pragma CHECK_MISRA("-5.7") /* keep names intact */
S#pragma CHECK_MISRA("-6.1") /* false positive on use of char type */
S#pragma CHECK_MISRA("-8.5") /* need to define inline functions */
S#pragma CHECK_MISRA("-10.1") /* use implicit casts */
S#pragma CHECK_MISRA("-10.3") /* need casts */
S#pragma CHECK_MISRA("-11.5") /* casting away const required for standard impl */
S#pragma CHECK_MISRA("-12.1") /* avoid changing expressions */
S#pragma CHECK_MISRA("-12.2") /* avoid changing expressions */
S#pragma CHECK_MISRA("-12.4") /* avoid changing expressions */
S#pragma CHECK_MISRA("-12.5") /* avoid changing expressions */
S#pragma CHECK_MISRA("-12.6") /* avoid changing expressions */
S#pragma CHECK_MISRA("-12.13") /* ++/-- needed for reasonable implementation */
S#pragma CHECK_MISRA("-13.1") /* avoid changing expressions */
S#pragma CHECK_MISRA("-14.7") /* use multiple return points */
S#pragma CHECK_MISRA("-14.8") /* use non-compound statements */
S#pragma CHECK_MISRA("-14.9") /* use non-compound statements */
S#pragma CHECK_MISRA("-17.4") /* pointer arithmetic needed for reasonable impl */
S#pragma CHECK_MISRA("-17.6") /* false positive returning pointer-typed param */
S
S#if defined(_INLINE) || defined(_STRLEN)
S_OPT_IDEFN size_t strlen(const char *string)
S{
S   size_t      n = (size_t)-1;
S   const char *s = string;
S
S   do n++; while (*s++);
S   return n;
S}
S#endif /* _INLINE || _STRLEN */
S
S#if defined(_INLINE) || defined(_STRCPY)
S_OPT_IDEFN char *strcpy(char * __restrict dest, const char * __restrict src)
S{
S     char       *d = dest;
S     const char *s = src;
S
S     while ((*d++ = *s++));
S     return dest;
S}
S#endif /* _INLINE || _STRCPY */
S
S#if defined(_INLINE) || defined(_STRNCPY)
S_OPT_IDEFN char *strncpy(char * __restrict dest,
S                         const char * __restrict src,
S                         size_t n)
S{
S     if (n)
S     {
S	 char       *d = dest;
S	 const char *s = src;
S	 while ((*d++ = *s++) && --n);              /* COPY STRING         */
S	 if (n-- > 1) do *d++ = '\0'; while (--n);  /* TERMINATION PADDING */
S     }
S     return dest;
S}
S#endif /* _INLINE || _STRNCPY  */
S
S#if defined(_INLINE) || defined(_STRCAT)
S_OPT_IDEFN char *strcat(char * __restrict string1,
S                        const char * __restrict string2)
S{
S   char       *s1 = string1;
S   const char *s2 = string2;
S
S   while (*s1) s1++;		     /* FIND END OF STRING   */
S   while ((*s1++ = *s2++));	     /* APPEND SECOND STRING */
S   return string1;
S}
S#endif /* _INLINE || _STRCAT */
S
S#if defined(_INLINE) || defined(_STRNCAT)
S_OPT_IDEFN char *strncat(char * __restrict dest,
S                         const char * __restrict src, size_t n)
S{
S    if (n)
S    {
S	char       *d = dest;
S	const char *s = src;
S
S	while (*d) d++;                      /* FIND END OF STRING   */
S
S	while (n--)
S	  if (!(*d++ = *s++)) return dest; /* APPEND SECOND STRING */
S	*d = 0;
S    }
S    return dest;
S}
S#endif /* _INLINE || _STRNCAT */
S
S#if defined(_INLINE) || defined(_STRCHR)
S_OPT_IDEFN char *strchr(const char *string, int c)
S{
S   char        tch, ch  = c;
S   const char *s        = string;
S
S   for (;;)
S   {
S       if ((tch = *s) == ch) return (char *) s;
S       if (!tch)             return (char *) 0;
S       s++;
S   }
S}
S#endif /* _INLINE || _STRCHR */
S
S#if defined(_INLINE) || defined(_STRRCHR)
S_OPT_IDEFN char *strrchr(const char *string, int c)
S{
S   char        tch, ch = c;
S   char       *result  = 0;
S   const char *s       = string;
S
S   for (;;)
S   {
S      if ((tch = *s) == ch) result = (char *) s;
S      if (!tch) break;
S      s++;
S   }
S
S   return result;
S}
S#endif /* _INLINE || _STRRCHR */
S
S#if defined(_INLINE) || defined(_STRCMP)
S_OPT_IDEFN int strcmp(const char *string1, const char *string2)
S{
S   int c1, res;
S
S   for (;;)
S   {
S       c1  = (unsigned char)*string1++;
S       res = c1 - (unsigned char)*string2++;
S
S       if (c1 == 0 || res != 0) break;
S   }
S
S   return res;
S}
S#endif /* _INLINE || _STRCMP */
S
S#if defined(_INLINE) || defined(_STRNCMP)
S_OPT_IDEFN int strncmp(const char *string1, const char *string2, size_t n)
S{
S     if (n)
S     {
S	 const char *s1 = string1;
S	 const char *s2 = string2;
S	 unsigned char cp;
S	 int         result;
S
S	 do
S	    if ((result = (unsigned char)*s1++ - (cp = (unsigned char)*s2++)))
S                return result;
S	 while (cp && --n);
S     }
S     return 0;
S}
S#endif /* _INLINE || _STRNCMP */
S
S#if defined(_INLINE) || defined(_MEMCMP)
S_OPT_IDEFN int memcmp(const void *cs, const void *ct, size_t n)
S{
S   if (n)
S   {
S       const unsigned char *mem1 = (unsigned char *)cs;
S       const unsigned char *mem2 = (unsigned char *)ct;
S       int                 cp1, cp2;
S
S       while ((cp1 = *mem1++) == (cp2 = *mem2++) && --n);
S       return cp1 - cp2;
S   }
S   return 0;
S}
S#endif /* _INLINE || _MEMCMP */
S
S#if defined(_INLINE) || defined(_MEMCHR)
S_OPT_IDEFN void *memchr(const void *cs, int c, size_t n)
S{
S   if (n)
S   {
S      const unsigned char *mem = (unsigned char *)cs;
S      unsigned char        ch  = c;
S
S      do
S         if ( *mem == ch ) return (void *)mem;
S         else mem++;
S      while (--n);
S   }
S   return NULL;
S}
S#endif /* _INLINE || _MEMCHR */
S
S#if (((defined(_INLINE) || defined(_MEMSET)) && \
S    !(defined(_TMS320C6X) && !defined(__C6X_MIGRATION__))) && \
S    !defined(__ARM_ARCH) && !defined(__ARP32__) && !defined(__C7000__))
X#if (((defined(_INLINE) || defined(_MEMSET)) &&     !(defined(_TMS320C6X) && !defined(__C6X_MIGRATION__))) &&     !defined(__ARM_ARCH) && !defined(__ARP32__) && !defined(__C7000__))
S_OPT_IDEFN void *memset(void *mem, int ch, size_t length)
S{
S     char *m = (char *)mem;
S
S     while (length--) *m++ = ch;
S     return mem;
S}
S#endif /* _INLINE || _MEMSET */
S
S#pragma diag_pop
S
S#endif /* (_STRING_IMPLEMENTATION || !(_OPTIMIZE_FOR_SPACE && __ARM_ARCH)) */
S
N#endif /* (_INLINE || _STRING_IMPLEMENTATION) */
N
N/*----------------------------------------------------------------------------*/
N/* If sys/cdefs.h is available, go ahead and include it. xlocale.h assumes    */
N/* this file will have already included sys/cdefs.h.                          */
N/*----------------------------------------------------------------------------*/
N#if __has_include(<sys/cdefs.h>)
X#if 1
N#include <sys/cdefs.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/sys/cdefs.h" 1
N/*-
N * SPDX-License-Identifier: BSD-3-Clause
N *
N * Copyright (c) 1991, 1993
N *	The Regents of the University of California.  All rights reserved.
N *
N * This code is derived from software contributed to Berkeley by
N * Berkeley Software Design, Inc.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N * 1. Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N * 3. Neither the name of the University nor the names of its contributors
N *    may be used to endorse or promote products derived from this software
N *    without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
N * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
N * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
N * SUCH DAMAGE.
N *
N *	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
N * $FreeBSD$
N */
N
N#ifndef	_SYS_CDEFS_H_
N#define	_SYS_CDEFS_H_
N
N#if defined(__TI_COMPILER_VERSION__)
X#if 1L
N#pragma diag_push
N#pragma CHECK_MISRA("none")
N#endif
N
N/*
N * Testing against Clang-specific extensions.
N */
N#ifndef	__has_attribute
S#define	__has_attribute(x)	0
N#endif
N#ifndef	__has_extension
S#define	__has_extension		__has_feature
N#endif
N#ifndef	__has_feature
S#define	__has_feature(x)	0
N#endif
N#ifndef	__has_include
S#define	__has_include(x)	0
N#endif
N#ifndef	__has_builtin
S#define	__has_builtin(x)	0
N#endif
N
N#if defined(__cplusplus)
X#if 1L
N#define	__BEGIN_DECLS	extern "C" {
N#define	__END_DECLS	}
N#else
S#define	__BEGIN_DECLS
S#define	__END_DECLS
N#endif
N
N/*
N * This code has been put in place to help reduce the addition of
N * compiler specific defines in FreeBSD code.  It helps to aid in
N * having a compiler-agnostic source tree.
N */
N
N#if defined(__GNUC__) || defined(__INTEL_COMPILER)
X#if 0L || 0L
S
S#if __GNUC__ >= 3 || defined(__INTEL_COMPILER)
S#define	__GNUCLIKE_ASM 3
S#define	__GNUCLIKE_MATH_BUILTIN_CONSTANTS
S#else
S#define	__GNUCLIKE_ASM 2
S#endif
S#define	__GNUCLIKE___TYPEOF 1
S#define	__GNUCLIKE___OFFSETOF 1
S#define	__GNUCLIKE___SECTION 1
S
S#ifndef __INTEL_COMPILER
S#define	__GNUCLIKE_CTOR_SECTION_HANDLING 1
S#endif
S
S#define	__GNUCLIKE_BUILTIN_CONSTANT_P 1
S#if defined(__INTEL_COMPILER) && defined(__cplusplus) && \
S   __INTEL_COMPILER < 800
X#if defined(__INTEL_COMPILER) && defined(__cplusplus) &&    __INTEL_COMPILER < 800
S#undef __GNUCLIKE_BUILTIN_CONSTANT_P
S#endif
S
S#if (__GNUC_MINOR__ > 95 || __GNUC__ >= 3)
S#define	__GNUCLIKE_BUILTIN_VARARGS 1
S#define	__GNUCLIKE_BUILTIN_STDARG 1
S#define	__GNUCLIKE_BUILTIN_VAALIST 1
S#endif
S
S#if defined(__GNUC__)
S#define	__GNUC_VA_LIST_COMPATIBILITY 1
S#endif
S
S/*
S * Compiler memory barriers, specific to gcc and clang.
S */
S#if defined(__GNUC__)
S#define	__compiler_membar()	__asm __volatile(" " : : : "memory")
S#endif
S
S#ifndef __INTEL_COMPILER
S#define	__GNUCLIKE_BUILTIN_NEXT_ARG 1
S#define	__GNUCLIKE_MATH_BUILTIN_RELOPS
S#endif
S
S#define	__GNUCLIKE_BUILTIN_MEMCPY 1
S
S/* XXX: if __GNUC__ >= 2: not tested everywhere originally, where replaced */
S#define	__CC_SUPPORTS_INLINE 1
S#define	__CC_SUPPORTS___INLINE 1
S#define	__CC_SUPPORTS___INLINE__ 1
S
S#define	__CC_SUPPORTS___FUNC__ 1
S#define	__CC_SUPPORTS_WARNING 1
S
S#define	__CC_SUPPORTS_VARADIC_XXX 1 /* see varargs.h */
S
S#define	__CC_SUPPORTS_DYNAMIC_ARRAY_INIT 1
S
N#endif /* __GNUC__ || __INTEL_COMPILER */
N
N#ifdef __TI_COMPILER_VERSION__
N#define	__GNUCLIKE___TYPEOF 1
N#define	__GNUCLIKE___OFFSETOF 1
N#define	__GNUCLIKE___SECTION 1
N
N#define	__CC_SUPPORTS_INLINE 1
N#define	__CC_SUPPORTS___INLINE 1
N#define	__CC_SUPPORTS___INLINE__ 1
N
N#define	__CC_SUPPORTS___FUNC__ 1
N#define	__CC_SUPPORTS_WARNING 1
N
N#define	__CC_SUPPORTS_VARADIC_XXX 1 /* see varargs.h */
N
N#define	__CC_SUPPORTS_DYNAMIC_ARRAY_INIT 1
N#endif /* __TI_COMPILER_VERSION__ */
N
N/*
N * Macro to test if we're using a specific version of gcc or later.
N */
N#if defined(__GNUC__) && !defined(__INTEL_COMPILER)
X#if 0L && !0L
S#define	__GNUC_PREREQ__(ma, mi)	\
S	(__GNUC__ > (ma) || __GNUC__ == (ma) && __GNUC_MINOR__ >= (mi))
X#define	__GNUC_PREREQ__(ma, mi)		(__GNUC__ > (ma) || __GNUC__ == (ma) && __GNUC_MINOR__ >= (mi))
N#else
N#define	__GNUC_PREREQ__(ma, mi)	0
N#endif
N
N/*
N * The __CONCAT macro is used to concatenate parts of symbol names, e.g.
N * with "#define OLD(foo) __CONCAT(old,foo)", OLD(foo) produces oldfoo.
N * The __CONCAT macro is a bit tricky to use if it must work in non-ANSI
N * mode -- there must be no spaces between its arguments, and for nested
N * __CONCAT's, all the __CONCAT's must be at the left.  __CONCAT can also
N * concatenate double-quoted strings produced by the __STRING macro, but
N * this only works with ANSI C.
N *
N * __XSTRING is like __STRING, but it expands any macros in its argument
N * first.  It is only available with ANSI C.
N */
N#if defined(__STDC__) || defined(__cplusplus)
X#if 1L || 1L
N#define	__P(protos)	protos		/* full-blown ANSI C */
N#define	__CONCAT1(x,y)	x ## y
N#define	__CONCAT(x,y)	__CONCAT1(x,y)
N#define	__STRING(x)	#x		/* stringify without expanding x */
N#define	__XSTRING(x)	__STRING(x)	/* expand x, then stringify */
N
N#define	__const		const		/* define reserved names to standard */
N#define	__signed	signed
N#define	__volatile	volatile
N#if defined(__cplusplus)
X#if 1L
N#define	__inline	inline		/* convert to C++ keyword */
N#else
S#if !(defined(__CC_SUPPORTS___INLINE))
S#define	__inline			/* delete GCC keyword */
S#endif /* ! __CC_SUPPORTS___INLINE */
N#endif /* !__cplusplus */
N
N#else	/* !(__STDC__ || __cplusplus) */
S#define	__P(protos)	()		/* traditional C preprocessor */
S#define	__CONCAT(x,y)	x/**/y
S#define	__STRING(x)	"x"
S
S#if !defined(__CC_SUPPORTS___INLINE)
S#define	__const				/* delete pseudo-ANSI C keywords */
S#define	__inline
S#define	__signed
S#define	__volatile
S/*
S * In non-ANSI C environments, new programs will want ANSI-only C keywords
S * deleted from the program and old programs will want them left alone.
S * When using a compiler other than gcc, programs using the ANSI C keywords
S * const, inline etc. as normal identifiers should define -DNO_ANSI_KEYWORDS.
S * When using "gcc -traditional", we assume that this is the intent; if
S * __GNUC__ is defined but __STDC__ is not, we leave the new keywords alone.
S */
S#ifndef	NO_ANSI_KEYWORDS
S#define	const				/* delete ANSI C keywords */
S#define	inline
S#define	signed
S#define	volatile
S#endif	/* !NO_ANSI_KEYWORDS */
S#endif	/* !__CC_SUPPORTS___INLINE */
N#endif	/* !(__STDC__ || __cplusplus) */
N
N/*
N * Compiler-dependent macros to help declare dead (non-returning) and
N * pure (no side effects) functions, and unused variables.  They are
N * null except for versions of gcc that are known to support the features
N * properly (old versions of gcc-2 supported the dead and pure features
N * in a different (wrong) way).  If we do not provide an implementation
N * for a given compiler, let the compile fail if it is told to use
N * a feature that we cannot live without.
N */
N#define	__weak_symbol	__attribute__((__weak__))
N#if !__GNUC_PREREQ__(2, 5) && !defined(__INTEL_COMPILER) && !defined(__TI_COMPILER_VERSION__)
X#if !0 && !0L && !1L
S#define	__dead2
S#define	__pure2
S#define	__unused
N#endif
N
N/*
N * TI ADD - check that __GNUC__ is defined before referencing it to avoid
N *          generating an error when __GNUC__ treated as zero warning is
N *          promoted to an error via -pdse195 option.
N */
N#if defined(__GNUC__) && __GNUC__ == 2 && __GNUC_MINOR__ >= 5 && __GNUC_MINOR__ < 7 && !defined(__INTEL_COMPILER)
X#if 0L && __GNUC__ == 2 && __GNUC_MINOR__ >= 5 && __GNUC_MINOR__ < 7 && !0L
S#define	__dead2		__attribute__((__noreturn__))
S#define	__pure2		__attribute__((__const__))
S#define	__unused
S/* XXX Find out what to do for __packed, __aligned and __section */
N#endif
N
N#if __GNUC_PREREQ__(2, 7) || defined(__INTEL_COMPILER) || defined(__TI_COMPILER_VERSION__)
X#if 0 || 0L || 1L
N#define	__dead2		__attribute__((__noreturn__))
N#define	__pure2		__attribute__((__const__))
N#define	__unused	__attribute__((__unused__))
N#define	__used		__attribute__((__used__))
N#define	__packed	__attribute__((__packed__))
N#define	__aligned(x)	__attribute__((__aligned__(x)))
N#define	__section(x)	__attribute__((__section__(x)))
N#endif
N#if __GNUC_PREREQ__(4, 3) || __has_attribute(__alloc_size__)
X#if 0 || 1
N#define	__alloc_size(x)	__attribute__((__alloc_size__(x)))
N#else
S#define	__alloc_size(x)
N#endif
N#if __GNUC_PREREQ__(4, 9) || __has_attribute(__alloc_align__)
X#if 0 || 0
S#define	__alloc_align(x)	__attribute__((__alloc_align__(x)))
N#else
N#define	__alloc_align(x)
N#endif
N
N#if defined(__TI_COMPILER_VERSION__)
X#if 1L
N#define __alignof(x)    __alignof__(x)
N#elif !__GNUC_PREREQ__(2, 95)
S#define	__alignof(x)	__offsetof(struct { char __a; x __b; }, __b)
N#endif
N
N/*
N * Keywords added in C11.
N */
N
N#if !defined(__STDC_VERSION__) || __STDC_VERSION__ < 201112L
X#if !0L || __STDC_VERSION__ < 201112L
N
N#if !__has_extension(c_alignas)
X#if !0
N#if (defined(__cplusplus) && __cplusplus >= 201103L) || \
N    __has_extension(cxx_alignas)
X#if (1L && 201402L >= 201103L) ||     1
N#define	_Alignas(x)		alignas(x)
N#else
S/* XXX: Only emulates _Alignas(constant-expression); not _Alignas(type-name). */
S#define	_Alignas(x)		__aligned(x)
N#endif
N#endif
N
N#if defined(__cplusplus) && __cplusplus >= 201103L
X#if 1L && 201402L >= 201103L
N#define	_Alignof(x)		alignof(x)
N#else
S#define	_Alignof(x)		__alignof(x)
N#endif
N
N#if !defined(__cplusplus) && !__has_extension(c_atomic) && \
N    !__has_extension(cxx_atomic)
X#if !1L && !0 &&     !0
S/*
S * No native support for _Atomic(). Place object in structure to prevent
S * most forms of direct non-atomic access.
S */
S#define	_Atomic(T)		struct { T volatile __val; }
N#endif
N
N#if defined(__cplusplus) && __cplusplus >= 201103L
X#if 1L && 201402L >= 201103L
N#define	_Noreturn		[[noreturn]]
N#else
S#define	_Noreturn		__dead2
N#endif
N
N#if !__has_extension(c_static_assert)
X#if !0
N#if (defined(__cplusplus) && __cplusplus >= 201103L) || \
N    __has_extension(cxx_static_assert)
X#if (1L && 201402L >= 201103L) ||     1
N#define	_Static_assert(x, y)	static_assert(x, y)
N#elif __GNUC_PREREQ__(4,6) && !defined(__cplusplus)
S/* Nothing, gcc 4.6 and higher has _Static_assert built-in */
S#elif defined(__COUNTER__)
S#define	_Static_assert(x, y)	__Static_assert(x, __COUNTER__)
S#define	__Static_assert(x, y)	___Static_assert(x, y)
S#define	___Static_assert(x, y)	typedef char __assert_ ## y[(x) ? 1 : -1] \
S				__unused
X#define	___Static_assert(x, y)	typedef char __assert_ ## y[(x) ? 1 : -1] 				__unused
S#else
S#define	_Static_assert(x, y)	struct __hack
N#endif
N#endif
N
N#if !__has_extension(c_thread_local)
X#if !0
N/*
N * XXX: Some compilers (Clang 3.3, GCC 4.7) falsely announce C++11 mode
N * without actually supporting the thread_local keyword. Don't check for
N * the presence of C++11 when defining _Thread_local.
N */
N#if /* (defined(__cplusplus) && __cplusplus >= 201103L) || */ \
N    __has_extension(cxx_thread_local)
X#if       1
N#define	_Thread_local		thread_local
N#else
S#define	_Thread_local		__thread
N#endif
N#endif
N
N#endif /* __STDC_VERSION__ || __STDC_VERSION__ < 201112L */
N
N/*
N * Emulation of C11 _Generic().  Unlike the previously defined C11
N * keywords, it is not possible to implement this using exactly the same
N * syntax.  Therefore implement something similar under the name
N * __generic().  Unlike _Generic(), this macro can only distinguish
N * between a single type, so it requires nested invocations to
N * distinguish multiple cases.
N */
N
N#if (defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L) || \
N    __has_extension(c_generic_selections)
X#if (0L && __STDC_VERSION__ >= 201112L) ||     0
S#define	__generic(expr, t, yes, no)					\
S	_Generic(expr, t: yes, default: no)
X#define	__generic(expr, t, yes, no)						_Generic(expr, t: yes, default: no)
S#elif __GNUC_PREREQ__(3, 1) && !defined(__cplusplus)
X#elif 0 && !1L
S#define	__generic(expr, t, yes, no)					\
S	__builtin_choose_expr(						\
S	    __builtin_types_compatible_p(__typeof(expr), t), yes, no)
X#define	__generic(expr, t, yes, no)						__builtin_choose_expr(							    __builtin_types_compatible_p(__typeof(expr), t), yes, no)
N#endif
N
N/*
N * C99 Static array indices in function parameter declarations.  Syntax such as:
N * void bar(int myArray[static 10]);
N * is allowed in C99 but not in C++.  Define __min_size appropriately so
N * headers using it can be compiled in either language.  Use like this:
N * void bar(int myArray[__min_size(10)]);
N */
N#if !defined(__cplusplus) && \
N    (defined(__clang__) || __GNUC_PREREQ__(4, 6)) && \
N    (!defined(__STDC_VERSION__) || (__STDC_VERSION__ >= 199901))
X#if !1L &&     (0L || 0) &&     (!0L || (__STDC_VERSION__ >= 199901))
S#define __min_size(x)	static (x)
N#else
N#define __min_size(x)	(x)
N#endif
N
N#if __GNUC_PREREQ__(2, 96)
X#if 0
S#define	__malloc_like	__attribute__((__malloc__))
S#define	__pure		__attribute__((__pure__))
N#else
N#define	__malloc_like
N#define	__pure
N#endif
N
N#if __GNUC_PREREQ__(3, 1) || (defined(__INTEL_COMPILER) && __INTEL_COMPILER >= 800) || defined(__TI_COMPILER_VERSION__)
X#if 0 || (0L && __INTEL_COMPILER >= 800) || 1L
N#define	__always_inline	__attribute__((__always_inline__))
N#else
S#define	__always_inline
N#endif
N
N#if __GNUC_PREREQ__(3, 1) || defined(__TI_COMPILER_VERSION__)
X#if 0 || 1L
N#define	__noinline	__attribute__ ((__noinline__))
N#else
S#define	__noinline
N#endif
N
N#if __GNUC_PREREQ__(3, 4)
X#if 0
S#define	__fastcall	__attribute__((__fastcall__))
S#define	__result_use_check	__attribute__((__warn_unused_result__))
N#else
N#define	__fastcall
N#define	__result_use_check
N#endif
N
N#if __GNUC_PREREQ__(4, 1)
X#if 0
S#define	__returns_twice	__attribute__((__returns_twice__))
N#else
N#define	__returns_twice
N#endif
N
N#if __GNUC_PREREQ__(4, 6) || __has_builtin(__builtin_unreachable)
X#if 0 || 0
S#define	__unreachable()	__builtin_unreachable()
N#else
N#define	__unreachable()	((void)0)
N#endif
N
N/* XXX: should use `#if __STDC_VERSION__ < 199901'. */
N#if !__GNUC_PREREQ__(2, 7) && !defined(__INTEL_COMPILER) && !defined(__TI_COMPILER_VERSION__)
X#if !0 && !0L && !1L
S#define	__func__	NULL
N#endif
N
N#if (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901)) || \
N    defined(__TI_COMPILER_VERSION__) || ((defined(__INTEL_COMPILER) || (defined(__GNUC__) && __GNUC__ >= 2)) && !defined(__STRICT_ANSI__))
X#if (0L && (__STDC_VERSION__ >= 199901)) ||     1L || ((0L || (0L && __GNUC__ >= 2)) && !0L)
N#define	__LONG_LONG_SUPPORTED
N#endif
N
N/* C++11 exposes a load of C99 stuff */
N#if defined(__cplusplus) && __cplusplus >= 201103L
X#if 1L && 201402L >= 201103L
N#define	__LONG_LONG_SUPPORTED
N#ifndef	__STDC_LIMIT_MACROS
N#define	__STDC_LIMIT_MACROS
N#endif
N#ifndef	__STDC_CONSTANT_MACROS
N#define	__STDC_CONSTANT_MACROS
N#endif
N#endif
N
N/*
N * GCC 2.95 provides `__restrict' as an extension to C90 to support the
N * C99-specific `restrict' type qualifier.  We happen to use `__restrict' as
N * a way to define the `restrict' type qualifier without disturbing older
N * software that is unaware of C99 keywords.
N * The TI compiler supports __restrict in all compilation modes.
N */
N#if !defined(__TI_COMPILER_VERSION__)
X#if !1L
S#if !(__GNUC__ == 2 && __GNUC_MINOR__ == 95)
S#if !defined(__STDC_VERSION__) || __STDC_VERSION__ < 199901
S#define	__restrict
S#else
S#define	__restrict	restrict
S#endif
S#endif
N#endif
N
N/*
N * GNU C version 2.96 adds explicit branch prediction so that
N * the CPU back-end can hint the processor and also so that
N * code blocks can be reordered such that the predicted path
N * sees a more linear flow, thus improving cache behavior, etc.
N *
N * The following two macros provide us with a way to utilize this
N * compiler feature.  Use __predict_true() if you expect the expression
N * to evaluate to true, and __predict_false() if you expect the
N * expression to evaluate to false.
N *
N * A few notes about usage:
N *
N *	* Generally, __predict_false() error condition checks (unless
N *	  you have some _strong_ reason to do otherwise, in which case
N *	  document it), and/or __predict_true() `no-error' condition
N *	  checks, assuming you want to optimize for the no-error case.
N *
N *	* Other than that, if you don't know the likelihood of a test
N *	  succeeding from empirical or other `hard' evidence, don't
N *	  make predictions.
N *
N *	* These are meant to be used in places that are run `a lot'.
N *	  It is wasteful to make predictions in code that is run
N *	  seldomly (e.g. at subsystem initialization time) as the
N *	  basic block reordering that this affects can often generate
N *	  larger code.
N */
N#if __GNUC_PREREQ__(2, 96)
X#if 0
S#define	__predict_true(exp)     __builtin_expect((exp), 1)
S#define	__predict_false(exp)    __builtin_expect((exp), 0)
N#else
N#define	__predict_true(exp)     (exp)
N#define	__predict_false(exp)    (exp)
N#endif
N
N#if __GNUC_PREREQ__(4, 0)
X#if 0
S#define	__null_sentinel	__attribute__((__sentinel__))
S#define	__exported	__attribute__((__visibility__("default")))
S#define	__hidden	__attribute__((__visibility__("hidden")))
N#else
N#define	__null_sentinel
N#define	__exported
N#define	__hidden
N#endif
N
N/*
N * We define this here since <stddef.h>, <sys/queue.h>, and <sys/types.h>
N * require it.
N */
N#if __GNUC_PREREQ__(4, 1)
X#if 0
S#define	__offsetof(type, field)	 __builtin_offsetof(type, field)
N#else
N#ifndef __cplusplus
S#define	__offsetof(type, field) \
S	((__size_t)(__uintptr_t)((const volatile void *)&((type *)0)->field))
X#define	__offsetof(type, field) 	((__size_t)(__uintptr_t)((const volatile void *)&((type *)0)->field))
N#else
N#define	__offsetof(type, field)					\
N  (__offsetof__ (reinterpret_cast <__size_t>			\
N                 (&reinterpret_cast <const volatile char &>	\
N                  (static_cast<type *> (0)->field))))
X#define	__offsetof(type, field)					  (__offsetof__ (reinterpret_cast <__size_t>			                 (&reinterpret_cast <const volatile char &>	                  (static_cast<type *> (0)->field))))
N#endif
N#endif
N#define	__rangeof(type, start, end) \
N	(__offsetof(type, end) - __offsetof(type, start))
X#define	__rangeof(type, start, end) 	(__offsetof(type, end) - __offsetof(type, start))
N
N/*
N * Given the pointer x to the member m of the struct s, return
N * a pointer to the containing structure.  When using GCC, we first
N * assign pointer x to a local variable, to check that its type is
N * compatible with member m.
N */
N#if __GNUC_PREREQ__(3, 1)
X#if 0
S#define	__containerof(x, s, m) ({					\
S	const volatile __typeof(((s *)0)->m) *__x = (x);		\
S	__DEQUALIFY(s *, (const volatile char *)__x - __offsetof(s, m));\
S})
X#define	__containerof(x, s, m) ({						const volatile __typeof(((s *)0)->m) *__x = (x);			__DEQUALIFY(s *, (const volatile char *)__x - __offsetof(s, m));})
N#else
N#define	__containerof(x, s, m)						\
N	__DEQUALIFY(s *, (const volatile char *)(x) - __offsetof(s, m))
X#define	__containerof(x, s, m)							__DEQUALIFY(s *, (const volatile char *)(x) - __offsetof(s, m))
N#endif
N
N/*
N * Compiler-dependent macros to declare that functions take printf-like
N * or scanf-like arguments.  They are null except for versions of gcc
N * that are known to support the features properly (old versions of gcc-2
N * didn't permit keeping the keywords out of the application namespace).
N */
N#if !__GNUC_PREREQ__(2, 7) && !defined(__INTEL_COMPILER)
X#if !0 && !0L
N#define	__printflike(fmtarg, firstvararg)
N#define	__scanflike(fmtarg, firstvararg)
N#define	__format_arg(fmtarg)
N#define	__strfmonlike(fmtarg, firstvararg)
N#define	__strftimelike(fmtarg, firstvararg)
N#else
S#define	__printflike(fmtarg, firstvararg) \
S	    __attribute__((__format__ (__printf__, fmtarg, firstvararg)))
X#define	__printflike(fmtarg, firstvararg) 	    __attribute__((__format__ (__printf__, fmtarg, firstvararg)))
S#define	__scanflike(fmtarg, firstvararg) \
S	    __attribute__((__format__ (__scanf__, fmtarg, firstvararg)))
X#define	__scanflike(fmtarg, firstvararg) 	    __attribute__((__format__ (__scanf__, fmtarg, firstvararg)))
S#define	__format_arg(fmtarg)	__attribute__((__format_arg__ (fmtarg)))
S#define	__strfmonlike(fmtarg, firstvararg) \
S	    __attribute__((__format__ (__strfmon__, fmtarg, firstvararg)))
X#define	__strfmonlike(fmtarg, firstvararg) 	    __attribute__((__format__ (__strfmon__, fmtarg, firstvararg)))
S#define	__strftimelike(fmtarg, firstvararg) \
S	    __attribute__((__format__ (__strftime__, fmtarg, firstvararg)))
X#define	__strftimelike(fmtarg, firstvararg) 	    __attribute__((__format__ (__strftime__, fmtarg, firstvararg)))
N#endif
N
N/* Compiler-dependent macros that rely on FreeBSD-specific extensions. */
N#if defined(__FreeBSD_cc_version) && __FreeBSD_cc_version >= 300001 && \
N    defined(__GNUC__) && !defined(__INTEL_COMPILER)
X#if 0L && __FreeBSD_cc_version >= 300001 &&     0L && !0L
S#define	__printf0like(fmtarg, firstvararg) \
S	    __attribute__((__format__ (__printf0__, fmtarg, firstvararg)))
X#define	__printf0like(fmtarg, firstvararg) 	    __attribute__((__format__ (__printf0__, fmtarg, firstvararg)))
N#else
N#define	__printf0like(fmtarg, firstvararg)
N#endif
N
N#if defined(__GNUC__) || defined(__INTEL_COMPILER)
X#if 0L || 0L
S#ifndef __INTEL_COMPILER
S#define	__strong_reference(sym,aliassym)	\
S	extern __typeof (sym) aliassym __attribute__ ((__alias__ (#sym)))
X#define	__strong_reference(sym,aliassym)		extern __typeof (sym) aliassym __attribute__ ((__alias__ (#sym)))
S#endif
S#ifdef __STDC__
S#define	__weak_reference(sym,alias)	\
S	__asm__(".weak " #alias);	\
S	__asm__(".equ "  #alias ", " #sym)
X#define	__weak_reference(sym,alias)		__asm__(".weak " #alias);		__asm__(".equ "  #alias ", " #sym)
S#define	__warn_references(sym,msg)	\
S	__asm__(".section .gnu.warning." #sym);	\
S	__asm__(".asciz \"" msg "\"");	\
S	__asm__(".previous")
X#define	__warn_references(sym,msg)		__asm__(".section .gnu.warning." #sym);		__asm__(".asciz \"" msg "\"");		__asm__(".previous")
S#define	__sym_compat(sym,impl,verid)	\
S	__asm__(".symver " #impl ", " #sym "@" #verid)
X#define	__sym_compat(sym,impl,verid)		__asm__(".symver " #impl ", " #sym "@" #verid)
S#define	__sym_default(sym,impl,verid)	\
S	__asm__(".symver " #impl ", " #sym "@@@" #verid)
X#define	__sym_default(sym,impl,verid)		__asm__(".symver " #impl ", " #sym "@@@" #verid)
S#else
S#define	__weak_reference(sym,alias)	\
S	__asm__(".weak alias");		\
S	__asm__(".equ alias, sym")
X#define	__weak_reference(sym,alias)		__asm__(".weak alias");			__asm__(".equ alias, sym")
S#define	__warn_references(sym,msg)	\
S	__asm__(".section .gnu.warning.sym"); \
S	__asm__(".asciz \"msg\"");	\
S	__asm__(".previous")
X#define	__warn_references(sym,msg)		__asm__(".section .gnu.warning.sym"); 	__asm__(".asciz \"msg\"");		__asm__(".previous")
S#define	__sym_compat(sym,impl,verid)	\
S	__asm__(".symver impl, sym@verid")
X#define	__sym_compat(sym,impl,verid)		__asm__(".symver impl, sym@verid")
S#define	__sym_default(impl,sym,verid)	\
S	__asm__(".symver impl, sym@@@verid")
X#define	__sym_default(impl,sym,verid)		__asm__(".symver impl, sym@@@verid")
S#endif	/* __STDC__ */
N#endif	/* __GNUC__ || __INTEL_COMPILER */
N
N#define	__GLOBL1(sym)	__asm__(".globl " #sym)
N#define	__GLOBL(sym)	__GLOBL1(sym)
N
N#if defined(__GNUC__) || defined(__INTEL_COMPILER)
X#if 0L || 0L
S#define	__IDSTRING(name,string)	__asm__(".ident\t\"" string "\"")
N#else
N/*
N * The following definition might not work well if used in header files,
N * but it should be better than nothing.  If you want a "do nothing"
N * version, then it should generate some harmless declaration, such as:
N *    #define	__IDSTRING(name,string)	struct __hack
N */
N#define	__IDSTRING(name,string)	static const char name[] __unused = string
N#endif
N
N#if defined(__TI_COMPILER_VERSION__) && defined(__TI_STRICT_ANSI_MODE__)
X#if 1L && 1L
N#define __extension__
N#endif
N
N/*
N * Embed the rcs id of a source file in the resulting library.  Note that in
N * more recent ELF binutils, we use .ident allowing the ID to be stripped.
N * Usage:
N *	__FBSDID("$FreeBSD$");
N */
N#ifndef	__FBSDID
N#if !defined(lint) && !defined(STRIP_FBSDID)
X#if !0L && !0L
N#define	__FBSDID(s)	__IDSTRING(__CONCAT(__rcsid_,__LINE__),s)
N#else
S#define	__FBSDID(s)	struct __hack
N#endif
N#endif
N
N#ifndef	__RCSID
N#ifndef	NO__RCSID
N#define	__RCSID(s)	__IDSTRING(__CONCAT(__rcsid_,__LINE__),s)
N#else
S#define	__RCSID(s)	struct __hack
N#endif
N#endif
N
N#ifndef	__RCSID_SOURCE
N#ifndef	NO__RCSID_SOURCE
N#define	__RCSID_SOURCE(s)	__IDSTRING(__CONCAT(__rcsid_source_,__LINE__),s)
N#else
S#define	__RCSID_SOURCE(s)	struct __hack
N#endif
N#endif
N
N#ifndef	__SCCSID
N#ifndef	NO__SCCSID
N#define	__SCCSID(s)	__IDSTRING(__CONCAT(__sccsid_,__LINE__),s)
N#else
S#define	__SCCSID(s)	struct __hack
N#endif
N#endif
N
N#ifndef	__COPYRIGHT
N#ifndef	NO__COPYRIGHT
N#define	__COPYRIGHT(s)	__IDSTRING(__CONCAT(__copyright_,__LINE__),s)
N#else
S#define	__COPYRIGHT(s)	struct __hack
N#endif
N#endif
N
N#ifndef	__DECONST
N#define	__DECONST(type, var)	((type)(__uintptr_t)(const void *)(var))
N#endif
N
N#ifndef	__DEVOLATILE
N#define	__DEVOLATILE(type, var)	((type)(__uintptr_t)(volatile void *)(var))
N#endif
N
N#ifndef	__DEQUALIFY
N#define	__DEQUALIFY(type, var)	((type)(__uintptr_t)(const volatile void *)(var))
N#endif
N
N/*-
N * The following definitions are an extension of the behavior originally
N * implemented in <sys/_posix.h>, but with a different level of granularity.
N * POSIX.1 requires that the macros we test be defined before any standard
N * header file is included.
N *
N * Here's a quick run-down of the versions:
N *  defined(_POSIX_SOURCE)		1003.1-1988
N *  _POSIX_C_SOURCE == 1		1003.1-1990
N *  _POSIX_C_SOURCE == 2		1003.2-1992 C Language Binding Option
N *  _POSIX_C_SOURCE == 199309		1003.1b-1993
N *  _POSIX_C_SOURCE == 199506		1003.1c-1995, 1003.1i-1995,
N *					and the omnibus ISO/IEC 9945-1: 1996
N *  _POSIX_C_SOURCE == 200112		1003.1-2001
N *  _POSIX_C_SOURCE == 200809		1003.1-2008
N *
N * In addition, the X/Open Portability Guide, which is now the Single UNIX
N * Specification, defines a feature-test macro which indicates the version of
N * that specification, and which subsumes _POSIX_C_SOURCE.
N *
N * Our macros begin with two underscores to avoid namespace screwage.
N */
N
N/* Deal with IEEE Std. 1003.1-1990, in which _POSIX_C_SOURCE == 1. */
N#if defined(_POSIX_C_SOURCE) && _POSIX_C_SOURCE == 1
X#if 0L && _POSIX_C_SOURCE == 1
S#undef _POSIX_C_SOURCE		/* Probably illegal, but beyond caring now. */
S#define	_POSIX_C_SOURCE		199009
N#endif
N
N/* Deal with IEEE Std. 1003.2-1992, in which _POSIX_C_SOURCE == 2. */
N#if defined(_POSIX_C_SOURCE) && _POSIX_C_SOURCE == 2
X#if 0L && _POSIX_C_SOURCE == 2
S#undef _POSIX_C_SOURCE
S#define	_POSIX_C_SOURCE		199209
N#endif
N
N/* Deal with various X/Open Portability Guides and Single UNIX Spec. */
N#ifdef _XOPEN_SOURCE
S#if _XOPEN_SOURCE - 0 >= 700
S#define	__XSI_VISIBLE		700
S#undef _POSIX_C_SOURCE
S#define	_POSIX_C_SOURCE		200809
S#elif _XOPEN_SOURCE - 0 >= 600
S#define	__XSI_VISIBLE		600
S#undef _POSIX_C_SOURCE
S#define	_POSIX_C_SOURCE		200112
S#elif _XOPEN_SOURCE - 0 >= 500
S#define	__XSI_VISIBLE		500
S#undef _POSIX_C_SOURCE
S#define	_POSIX_C_SOURCE		199506
S#endif
N#endif
N
N/*
N * Deal with all versions of POSIX.  The ordering relative to the tests above is
N * important.
N */
N#if defined(_POSIX_SOURCE) && !defined(_POSIX_C_SOURCE)
X#if 0L && !0L
S#define	_POSIX_C_SOURCE		198808
N#endif
N#ifdef _POSIX_C_SOURCE
S#if _POSIX_C_SOURCE >= 200809
S#define	__POSIX_VISIBLE		200809
S#define	__ISO_C_VISIBLE		1999
S#elif _POSIX_C_SOURCE >= 200112
S#define	__POSIX_VISIBLE		200112
S#define	__ISO_C_VISIBLE		1999
S#elif _POSIX_C_SOURCE >= 199506
S#define	__POSIX_VISIBLE		199506
S#define	__ISO_C_VISIBLE		1990
S#elif _POSIX_C_SOURCE >= 199309
S#define	__POSIX_VISIBLE		199309
S#define	__ISO_C_VISIBLE		1990
S#elif _POSIX_C_SOURCE >= 199209
S#define	__POSIX_VISIBLE		199209
S#define	__ISO_C_VISIBLE		1990
S#elif _POSIX_C_SOURCE >= 199009
S#define	__POSIX_VISIBLE		199009
S#define	__ISO_C_VISIBLE		1990
S#else
S#define	__POSIX_VISIBLE		198808
S#define	__ISO_C_VISIBLE		0
S#endif /* _POSIX_C_SOURCE */
N#else
N/*-
N * Deal with _ANSI_SOURCE:
N * If it is defined, and no other compilation environment is explicitly
N * requested, then define our internal feature-test macros to zero.  This
N * makes no difference to the preprocessor (undefined symbols in preprocessing
N * expressions are defined to have value zero), but makes it more convenient for
N * a test program to print out the values.
N *
N * If a program mistakenly defines _ANSI_SOURCE and some other macro such as
N * _POSIX_C_SOURCE, we will assume that it wants the broader compilation
N * environment (and in fact we will never get here).
N */
N#if defined(_ANSI_SOURCE)	/* Hide almost everything. */
X#if 0L	 
S#define	__POSIX_VISIBLE		0
S#define	__XSI_VISIBLE		0
S#define	__BSD_VISIBLE		0
S#define	__ISO_C_VISIBLE		1990
S#define	__EXT1_VISIBLE		0
S#elif defined(_C99_SOURCE)	/* Localism to specify strict C99 env. */
X#elif 0L	 
S#define	__POSIX_VISIBLE		0
S#define	__XSI_VISIBLE		0
S#define	__BSD_VISIBLE		0
S#define	__ISO_C_VISIBLE		1999
S#define	__EXT1_VISIBLE		0
S#elif defined(_C11_SOURCE)	/* Localism to specify strict C11 env. */
X#elif 0L	 
S#define	__POSIX_VISIBLE		0
S#define	__XSI_VISIBLE		0
S#define	__BSD_VISIBLE		0
S#define	__ISO_C_VISIBLE		2011
S#define	__EXT1_VISIBLE		0
N#else				/* Default environment: show everything. */
N#define	__POSIX_VISIBLE		200809
N#define	__XSI_VISIBLE		700
N#define	__BSD_VISIBLE		1
N#define	__ISO_C_VISIBLE		2011
N#define	__EXT1_VISIBLE		1
N#endif
N#endif
N
N/* User override __EXT1_VISIBLE */
N#if defined(__STDC_WANT_LIB_EXT1__)
X#if 0L
S#undef	__EXT1_VISIBLE
S#if __STDC_WANT_LIB_EXT1__
S#define	__EXT1_VISIBLE		1
S#else
S#define	__EXT1_VISIBLE		0
S#endif
N#endif /* __STDC_WANT_LIB_EXT1__ */
N
N#if defined(__mips) || defined(__powerpc64__) || defined(__riscv)
X#if 0L || 0L || 0L
S#define	__NO_TLS 1
N#endif
N
N/*
N * Old versions of GCC use non-standard ARM arch symbols; acle-compat.h
N * translates them to __ARM_ARCH and the modern feature symbols defined by ARM.
N */
N#if defined(__arm__) && !defined(__ARM_ARCH)
X#if 0L && !1L
S#include <machine/acle-compat.h>
N#endif
N
N/*
N * Nullability qualifiers: currently only supported by Clang.
N */
N#if !(defined(__clang__) && __has_feature(nullability))
X#if !(0L && 0)
N#define	_Nonnull
N#define	_Nullable
N#define	_Null_unspecified
N#define	__NULLABILITY_PRAGMA_PUSH
N#define	__NULLABILITY_PRAGMA_POP
N#else
S#define	__NULLABILITY_PRAGMA_PUSH _Pragma("clang diagnostic push")	\
S	_Pragma("clang diagnostic ignored \"-Wnullability-completeness\"")
X#define	__NULLABILITY_PRAGMA_PUSH _Pragma("clang diagnostic push")		_Pragma("clang diagnostic ignored \"-Wnullability-completeness\"")
S#define	__NULLABILITY_PRAGMA_POP _Pragma("clang diagnostic pop")
N#endif
N
N/*
N * Type Safety Checking
N *
N * Clang provides additional attributes to enable checking type safety
N * properties that cannot be enforced by the C type system. 
N */
N
N#if __has_attribute(__argument_with_type_tag__) && \
N    __has_attribute(__type_tag_for_datatype__)
X#if 0 &&     0
S#define	__arg_type_tag(arg_kind, arg_idx, type_tag_idx) \
S	    __attribute__((__argument_with_type_tag__(arg_kind, arg_idx, type_tag_idx)))
X#define	__arg_type_tag(arg_kind, arg_idx, type_tag_idx) 	    __attribute__((__argument_with_type_tag__(arg_kind, arg_idx, type_tag_idx)))
S#define	__datatype_type_tag(kind, type) \
S	    __attribute__((__type_tag_for_datatype__(kind, type)))
X#define	__datatype_type_tag(kind, type) 	    __attribute__((__type_tag_for_datatype__(kind, type)))
N#else
N#define	__arg_type_tag(arg_kind, arg_idx, type_tag_idx)
N#define	__datatype_type_tag(kind, type)
N#endif
N
N/*
N * Lock annotations.
N *
N * Clang provides support for doing basic thread-safety tests at
N * compile-time, by marking which locks will/should be held when
N * entering/leaving a functions.
N *
N * Furthermore, it is also possible to annotate variables and structure
N * members to enforce that they are only accessed when certain locks are
N * held.
N */
N
N#if __has_extension(c_thread_safety_attributes)
X#if 0
S#define	__lock_annotate(x)	__attribute__((x))
N#else
N#define	__lock_annotate(x)
N#endif
N
N/* Structure implements a lock. */
N#define	__lockable		__lock_annotate(lockable)
N
N/* Function acquires an exclusive or shared lock. */
N#define	__locks_exclusive(...) \
N	__lock_annotate(exclusive_lock_function(__VA_ARGS__))
X#define	__locks_exclusive(...) 	__lock_annotate(exclusive_lock_function(__VA_ARGS__))
N#define	__locks_shared(...) \
N	__lock_annotate(shared_lock_function(__VA_ARGS__))
X#define	__locks_shared(...) 	__lock_annotate(shared_lock_function(__VA_ARGS__))
N
N/* Function attempts to acquire an exclusive or shared lock. */
N#define	__trylocks_exclusive(...) \
N	__lock_annotate(exclusive_trylock_function(__VA_ARGS__))
X#define	__trylocks_exclusive(...) 	__lock_annotate(exclusive_trylock_function(__VA_ARGS__))
N#define	__trylocks_shared(...) \
N	__lock_annotate(shared_trylock_function(__VA_ARGS__))
X#define	__trylocks_shared(...) 	__lock_annotate(shared_trylock_function(__VA_ARGS__))
N
N/* Function releases a lock. */
N#define	__unlocks(...)		__lock_annotate(unlock_function(__VA_ARGS__))
N
N/* Function asserts that an exclusive or shared lock is held. */
N#define	__asserts_exclusive(...) \
N	__lock_annotate(assert_exclusive_lock(__VA_ARGS__))
X#define	__asserts_exclusive(...) 	__lock_annotate(assert_exclusive_lock(__VA_ARGS__))
N#define	__asserts_shared(...) \
N	__lock_annotate(assert_shared_lock(__VA_ARGS__))
X#define	__asserts_shared(...) 	__lock_annotate(assert_shared_lock(__VA_ARGS__))
N
N/* Function requires that an exclusive or shared lock is or is not held. */
N#define	__requires_exclusive(...) \
N	__lock_annotate(exclusive_locks_required(__VA_ARGS__))
X#define	__requires_exclusive(...) 	__lock_annotate(exclusive_locks_required(__VA_ARGS__))
N#define	__requires_shared(...) \
N	__lock_annotate(shared_locks_required(__VA_ARGS__))
X#define	__requires_shared(...) 	__lock_annotate(shared_locks_required(__VA_ARGS__))
N#define	__requires_unlocked(...) \
N	__lock_annotate(locks_excluded(__VA_ARGS__))
X#define	__requires_unlocked(...) 	__lock_annotate(locks_excluded(__VA_ARGS__))
N
N/* Function should not be analyzed. */
N#define	__no_lock_analysis	__lock_annotate(no_thread_safety_analysis)
N
N/* Guard variables and structure members by lock. */
N#define	__guarded_by(x)		__lock_annotate(guarded_by(x))
N#define	__pt_guarded_by(x)	__lock_annotate(pt_guarded_by(x))
N
N#ifdef __TI_COMPILER_VERSION__
N#pragma diag_pop
N#endif
N
N#endif /* !_SYS_CDEFS_H_ */
L 431 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/string.h" 2
N#endif
N
N/*----------------------------------------------------------------------------*/
N/* Include xlocale/_string.h> if POSIX is enabled. This will expose the       */
N/* xlocale string interface.                                                  */
N/*----------------------------------------------------------------------------*/
N#if defined(_POSIX_VISIBLE) && _POSIX_VISIBLE >= 200809
X#if 0L && _POSIX_VISIBLE >= 200809
S__BEGIN_DECLS
S#include <xlocale/_string.h>
S__END_DECLS
N#endif
N
N
N#pragma diag_pop
N
N#endif /* ! _STRING_H_ */
L 62 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/string.h" 2
N
N/* MSVCRT, GNU libc and its derivates may already have the correct prototype in */
N/* <string.h>. This macro can be defined by users if their C library provides */
N/* the right signature. */
N#if defined(__CORRECT_ISO_CPP_STRING_H_PROTO) || defined(_LIBCPP_MSVCRT) || \
N    defined(__sun__) || defined(_STRING_H_CPLUSPLUS_98_CONFORMANCE_)
X#if 0L || 0L ||     0L || 0L
S#define _LIBCPP_STRING_H_HAS_CONST_OVERLOADS
N#endif
N
N#if defined(__cplusplus) && !defined(_LIBCPP_STRING_H_HAS_CONST_OVERLOADS) && defined(_LIBCPP_PREFERRED_OVERLOAD)
X#if 1L && !0L && 0L
Sextern "C++" {
Sinline _LIBCPP_INLINE_VISIBILITY
Schar* __libcpp_strchr(const char* __s, int __c) {return (char*)strchr(__s, __c);}
Sinline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD
Sconst char* strchr(const char* __s, int __c) {return __libcpp_strchr(__s, __c);}
Sinline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD
S      char* strchr(      char* __s, int __c) {return __libcpp_strchr(__s, __c);}
S
Sinline _LIBCPP_INLINE_VISIBILITY
Schar* __libcpp_strpbrk(const char* __s1, const char* __s2) {return (char*)strpbrk(__s1, __s2);}
Sinline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD
Sconst char* strpbrk(const char* __s1, const char* __s2) {return __libcpp_strpbrk(__s1, __s2);}
Sinline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD
S      char* strpbrk(      char* __s1, const char* __s2) {return __libcpp_strpbrk(__s1, __s2);}
S
Sinline _LIBCPP_INLINE_VISIBILITY
Schar* __libcpp_strrchr(const char* __s, int __c) {return (char*)strrchr(__s, __c);}
Sinline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD
Sconst char* strrchr(const char* __s, int __c) {return __libcpp_strrchr(__s, __c);}
Sinline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD
S      char* strrchr(      char* __s, int __c) {return __libcpp_strrchr(__s, __c);}
S
Sinline _LIBCPP_INLINE_VISIBILITY
Svoid* __libcpp_memchr(const void* __s, int __c, size_t __n) {return (void*)memchr(__s, __c, __n);}
Sinline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD
Sconst void* memchr(const void* __s, int __c, size_t __n) {return __libcpp_memchr(__s, __c, __n);}
Sinline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD
S      void* memchr(      void* __s, int __c, size_t __n) {return __libcpp_memchr(__s, __c, __n);}
S
Sinline _LIBCPP_INLINE_VISIBILITY
Schar* __libcpp_strstr(const char* __s1, const char* __s2) {return (char*)strstr(__s1, __s2);}
Sinline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD
Sconst char* strstr(const char* __s1, const char* __s2) {return __libcpp_strstr(__s1, __s2);}
Sinline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD
S      char* strstr(      char* __s1, const char* __s2) {return __libcpp_strstr(__s1, __s2);}
S}
N#endif
N
N#endif  /* _LIBCPP_STRING_H */
L 62 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/cstring" 2
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N_LIBCPP_BEGIN_NAMESPACE_STD
Xnamespace std { inline namespace __2 {
N
Nusing ::size_t;
Nusing ::memcpy;
Nusing ::memmove;
Nusing ::strcpy;
Nusing ::strncpy;
Nusing ::strcat;
Nusing ::strncat;
Nusing ::memcmp;
Nusing ::strcmp;
Nusing ::strncmp;
Nusing ::strcoll;
Nusing ::strxfrm;
Nusing ::memchr;
Nusing ::strchr;
Nusing ::strcspn;
Nusing ::strpbrk;
Nusing ::strrchr;
Nusing ::strspn;
Nusing ::strstr;
N#ifndef _LIBCPP_HAS_NO_THREAD_UNSAFE_C_FUNCTIONS
Nusing ::strtok;
N#endif
Nusing ::memset;
Nusing ::strerror;
Nusing ::strlen;
N
N_LIBCPP_END_NAMESPACE_STD
X} }
N
N#endif  // _LIBCPP_CSTRING
L 642 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/algorithm" 2
N#include <utility> // needed to provide swap_ranges.
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/utility" 1
N// -*- C++ -*-
N//===-------------------------- utility -----------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is dual licensed under the MIT and the University of Illinois Open
N// Source Licenses. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP_UTILITY
N#define _LIBCPP_UTILITY
N
N/*
N    utility synopsis
N
Nnamespace std
N{
N
Ntemplate <class T>
N    void
N    swap(T& a, T& b);
N
Nnamespace rel_ops
N{
N    template<class T> bool operator!=(const T&, const T&);
N    template<class T> bool operator> (const T&, const T&);
N    template<class T> bool operator<=(const T&, const T&);
N    template<class T> bool operator>=(const T&, const T&);
N}
N
Ntemplate<class T>
Nvoid
Nswap(T& a, T& b) noexcept(is_nothrow_move_constructible<T>::value &&
N                          is_nothrow_move_assignable<T>::value);
N
Ntemplate <class T, size_t N>
Nvoid
Nswap(T (&a)[N], T (&b)[N]) noexcept(noexcept(swap(*a, *b)));
N
Ntemplate <class T> T&& forward(typename remove_reference<T>::type& t) noexcept;  // constexpr in C++14
Ntemplate <class T> T&& forward(typename remove_reference<T>::type&& t) noexcept; // constexpr in C++14
N
Ntemplate <class T> typename remove_reference<T>::type&& move(T&&) noexcept;      // constexpr in C++14
N
Ntemplate <class T>
N    typename conditional
N    <
N        !is_nothrow_move_constructible<T>::value && is_copy_constructible<T>::value,
N        const T&,
N        T&&
N    >::type
N    move_if_noexcept(T& x) noexcept; // constexpr in C++14
N
Ntemplate <class T> constexpr add_const<T>_t& as_const(T& t) noexcept;      // C++17
Ntemplate <class T>                      void as_const(const T&&) = delete; // C++17
N
Ntemplate <class T> typename add_rvalue_reference<T>::type declval() noexcept;
N
Ntemplate <class T1, class T2>
Nstruct pair
N{
N    typedef T1 first_type;
N    typedef T2 second_type;
N
N    T1 first;
N    T2 second;
N
N    pair(const pair&) = default;
N    pair(pair&&) = default;
N    constexpr pair();
N    pair(const T1& x, const T2& y);                          // constexpr in C++14
N    template <class U, class V> pair(U&& x, V&& y);          // constexpr in C++14
N    template <class U, class V> pair(const pair<U, V>& p);   // constexpr in C++14
N    template <class U, class V> pair(pair<U, V>&& p);        // constexpr in C++14
N    template <class... Args1, class... Args2>
N        pair(piecewise_construct_t, tuple<Args1...> first_args,
N             tuple<Args2...> second_args);
N
N    template <class U, class V> pair& operator=(const pair<U, V>& p);
N    pair& operator=(pair&& p) noexcept(is_nothrow_move_assignable<T1>::value &&
N                                       is_nothrow_move_assignable<T2>::value);
N    template <class U, class V> pair& operator=(pair<U, V>&& p);
N
N    void swap(pair& p) noexcept(is_nothrow_swappable_v<T1> &&
N                                is_nothrow_swappable_v<T2>);
N};
N
Ntemplate <class T1, class T2> bool operator==(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14
Ntemplate <class T1, class T2> bool operator!=(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14
Ntemplate <class T1, class T2> bool operator< (const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14
Ntemplate <class T1, class T2> bool operator> (const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14
Ntemplate <class T1, class T2> bool operator>=(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14
Ntemplate <class T1, class T2> bool operator<=(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14
N
Ntemplate <class T1, class T2> pair<V1, V2> make_pair(T1&&, T2&&);   // constexpr in C++14
Ntemplate <class T1, class T2>
Nvoid
Nswap(pair<T1, T2>& x, pair<T1, T2>& y) noexcept(noexcept(x.swap(y)));
N
Nstruct piecewise_construct_t { };
Nconstexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();
N
Ntemplate <class T> class tuple_size;
Ntemplate <size_t I, class T> class tuple_element;
N
Ntemplate <class T1, class T2> struct tuple_size<pair<T1, T2> >;
Ntemplate <class T1, class T2> struct tuple_element<0, pair<T1, T2> >;
Ntemplate <class T1, class T2> struct tuple_element<1, pair<T1, T2> >;
N
Ntemplate<size_t I, class T1, class T2>
N    typename tuple_element<I, pair<T1, T2> >::type&
N    get(pair<T1, T2>&) noexcept; // constexpr in C++14
N
Ntemplate<size_t I, class T1, class T2>
N    const typename tuple_element<I, pair<T1, T2> >::type&
N    get(const pair<T1, T2>&) noexcept; // constexpr in C++14
N
Ntemplate<size_t I, class T1, class T2>
N    typename tuple_element<I, pair<T1, T2> >::type&&
N    get(pair<T1, T2>&&) noexcept; // constexpr in C++14
N
Ntemplate<size_t I, class T1, class T2>
N    const typename tuple_element<I, pair<T1, T2> >::type&&
N    get(const pair<T1, T2>&&) noexcept; // constexpr in C++14
N
Ntemplate<class T1, class T2>
N    constexpr T1& get(pair<T1, T2>&) noexcept; // C++14
N
Ntemplate<class T1, class T2>
N    constexpr const T1& get(const pair<T1, T2>&) noexcept; // C++14
N
Ntemplate<class T1, class T2>
N    constexpr T1&& get(pair<T1, T2>&&) noexcept; // C++14
N
Ntemplate<class T1, class T2>
N    constexpr const T1&& get(const pair<T1, T2>&&) noexcept; // C++14
N
Ntemplate<class T1, class T2>
N    constexpr T1& get(pair<T2, T1>&) noexcept; // C++14
N
Ntemplate<class T1, class T2>
N    constexpr const T1& get(const pair<T2, T1>&) noexcept; // C++14
N
Ntemplate<class T1, class T2>
N    constexpr T1&& get(pair<T2, T1>&&) noexcept; // C++14
N
Ntemplate<class T1, class T2>
N    constexpr const T1&& get(const pair<T2, T1>&&) noexcept; // C++14
N
N// C++14
N
Ntemplate<class T, T... I>
Nstruct integer_sequence
N{
N    typedef T value_type;
N
N    static constexpr size_t size() noexcept;
N};
N
Ntemplate<size_t... I>
N  using index_sequence = integer_sequence<size_t, I...>;
N
Ntemplate<class T, T N>
N  using make_integer_sequence = integer_sequence<T, 0, 1, ..., N-1>;
Ntemplate<size_t N>
N  using make_index_sequence = make_integer_sequence<size_t, N>;
N
Ntemplate<class... T>
N  using index_sequence_for = make_index_sequence<sizeof...(T)>;
N
Ntemplate<class T, class U=T>
N    T exchange(T& obj, U&& new_value);
N
N// 20.2.7, in-place construction // C++17
Nstruct in_place_t {
N  explicit in_place_t() = default;
N};
Ninline constexpr in_place_t in_place{};
Ntemplate <class T>
N  struct in_place_type_t {
N    explicit in_place_type_t() = default;
N  };
Ntemplate <class T>
N  inline constexpr in_place_type_t<T> in_place_type{};
Ntemplate <size_t I>
N  struct in_place_index_t {
N    explicit in_place_index_t() = default;
N  };
Ntemplate <size_t I>
N  inline constexpr in_place_index_t<I> in_place_index{};
N
N}  // std
N
N*/
N
N#include <__config>
N#include <__tuple>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/__tuple" 1
N// -*- C++ -*-
N//===----------------------------------------------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is dual licensed under the MIT and the University of Illinois Open
N// Source Licenses. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP___TUPLE
N#define _LIBCPP___TUPLE
N
N#include <__config>
N#include <cstddef>
N#include <type_traits>
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N
N_LIBCPP_BEGIN_NAMESPACE_STD
Xnamespace std { inline namespace __2 {
N
Ntemplate <class _Tp> class _LIBCPP_TEMPLATE_VIS tuple_size;
Xtemplate <class _Tp> class  tuple_size;
N
N#if !defined(_LIBCPP_CXX03_LANG)
X#if !0L
Ntemplate <class _Tp, class...>
Nusing __enable_if_tuple_size_imp = _Tp;
N
Ntemplate <class _Tp>
Nclass _LIBCPP_TEMPLATE_VIS tuple_size<__enable_if_tuple_size_imp<
Xclass  tuple_size<__enable_if_tuple_size_imp<
N    const _Tp,
N    typename enable_if<!is_volatile<_Tp>::value>::type,
N    integral_constant<size_t, sizeof(tuple_size<_Tp>)>>>
N    : public integral_constant<size_t, tuple_size<_Tp>::value> {};
N
Ntemplate <class _Tp>
Nclass _LIBCPP_TEMPLATE_VIS tuple_size<__enable_if_tuple_size_imp<
Xclass  tuple_size<__enable_if_tuple_size_imp<
N    volatile _Tp,
N    typename enable_if<!is_const<_Tp>::value>::type,
N    integral_constant<size_t, sizeof(tuple_size<_Tp>)>>>
N    : public integral_constant<size_t, tuple_size<_Tp>::value> {};
N
Ntemplate <class _Tp>
Nclass _LIBCPP_TEMPLATE_VIS tuple_size<__enable_if_tuple_size_imp<
Xclass  tuple_size<__enable_if_tuple_size_imp<
N    const volatile _Tp,
N    integral_constant<size_t, sizeof(tuple_size<_Tp>)>>>
N    : public integral_constant<size_t, tuple_size<_Tp>::value> {};
N
N#else
Stemplate <class _Tp> class _LIBCPP_TEMPLATE_VIS tuple_size<const _Tp> : public tuple_size<_Tp> {};
Stemplate <class _Tp> class _LIBCPP_TEMPLATE_VIS tuple_size<volatile _Tp> : public tuple_size<_Tp> {};
Stemplate <class _Tp> class _LIBCPP_TEMPLATE_VIS tuple_size<const volatile _Tp> : public tuple_size<_Tp> {};
N#endif
N
Ntemplate <size_t _Ip, class _Tp> class _LIBCPP_TEMPLATE_VIS tuple_element;
Xtemplate <size_t _Ip, class _Tp> class  tuple_element;
N
Ntemplate <size_t _Ip, class _Tp>
Nclass _LIBCPP_TEMPLATE_VIS tuple_element<_Ip, const _Tp>
Xclass  tuple_element<_Ip, const _Tp>
N{
Npublic:
N    typedef typename add_const<typename tuple_element<_Ip, _Tp>::type>::type type;
N};
N
Ntemplate <size_t _Ip, class _Tp>
Nclass _LIBCPP_TEMPLATE_VIS tuple_element<_Ip, volatile _Tp>
Xclass  tuple_element<_Ip, volatile _Tp>
N{
Npublic:
N    typedef typename add_volatile<typename tuple_element<_Ip, _Tp>::type>::type type;
N};
N
Ntemplate <size_t _Ip, class _Tp>
Nclass _LIBCPP_TEMPLATE_VIS tuple_element<_Ip, const volatile _Tp>
Xclass  tuple_element<_Ip, const volatile _Tp>
N{
Npublic:
N    typedef typename add_cv<typename tuple_element<_Ip, _Tp>::type>::type type;
N};
N
Ntemplate <class _Tp> struct __tuple_like : false_type {};
N
Ntemplate <class _Tp> struct __tuple_like<const _Tp> : public __tuple_like<_Tp> {};
Ntemplate <class _Tp> struct __tuple_like<volatile _Tp> : public __tuple_like<_Tp> {};
Ntemplate <class _Tp> struct __tuple_like<const volatile _Tp> : public __tuple_like<_Tp> {};
N
N// tuple specializations
N
N#ifndef _LIBCPP_CXX03_LANG
N
Ntemplate <size_t...> struct __tuple_indices {};
N
Ntemplate <class _IdxType, _IdxType... _Values>
Nstruct __integer_sequence {
N  template <template <class _OIdxType, _OIdxType...> class _ToIndexSeq, class _ToIndexType>
N  using __convert = _ToIndexSeq<_ToIndexType, _Values...>;
N
N  template <size_t _Sp>
N  using __to_tuple_indices = __tuple_indices<(_Values + _Sp)...>;
N};
N
N#if !__has_builtin(__make_integer_seq) || defined(_LIBCPP_TESTING_FALLBACK_MAKE_INTEGER_SEQUENCE)
X#if !0 || 0L
Nnamespace __detail {
N
Ntemplate<typename _Tp, size_t ..._Extra> struct __repeat;
Ntemplate<typename _Tp, _Tp ..._Np, size_t ..._Extra> struct __repeat<__integer_sequence<_Tp, _Np...>, _Extra...> {
N  typedef __integer_sequence<_Tp,
N                           _Np...,
N                           sizeof...(_Np) + _Np...,
N                           2 * sizeof...(_Np) + _Np...,
N                           3 * sizeof...(_Np) + _Np...,
N                           4 * sizeof...(_Np) + _Np...,
N                           5 * sizeof...(_Np) + _Np...,
N                           6 * sizeof...(_Np) + _Np...,
N                           7 * sizeof...(_Np) + _Np...,
N                           _Extra...> type;
N};
N
Ntemplate<size_t _Np> struct __parity;
Ntemplate<size_t _Np> struct __make : __parity<_Np % 8>::template __pmake<_Np> {};
N
Ntemplate<> struct __make<0> { typedef __integer_sequence<size_t> type; };
Ntemplate<> struct __make<1> { typedef __integer_sequence<size_t, 0> type; };
Ntemplate<> struct __make<2> { typedef __integer_sequence<size_t, 0, 1> type; };
Ntemplate<> struct __make<3> { typedef __integer_sequence<size_t, 0, 1, 2> type; };
Ntemplate<> struct __make<4> { typedef __integer_sequence<size_t, 0, 1, 2, 3> type; };
Ntemplate<> struct __make<5> { typedef __integer_sequence<size_t, 0, 1, 2, 3, 4> type; };
Ntemplate<> struct __make<6> { typedef __integer_sequence<size_t, 0, 1, 2, 3, 4, 5> type; };
Ntemplate<> struct __make<7> { typedef __integer_sequence<size_t, 0, 1, 2, 3, 4, 5, 6> type; };
N
Ntemplate<> struct __parity<0> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type> {}; };
Ntemplate<> struct __parity<1> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 1> {}; };
Ntemplate<> struct __parity<2> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 2, _Np - 1> {}; };
Ntemplate<> struct __parity<3> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 3, _Np - 2, _Np - 1> {}; };
Ntemplate<> struct __parity<4> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 4, _Np - 3, _Np - 2, _Np - 1> {}; };
Ntemplate<> struct __parity<5> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 5, _Np - 4, _Np - 3, _Np - 2, _Np - 1> {}; };
Ntemplate<> struct __parity<6> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 6, _Np - 5, _Np - 4, _Np - 3, _Np - 2, _Np - 1> {}; };
Ntemplate<> struct __parity<7> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 7, _Np - 6, _Np - 5, _Np - 4, _Np - 3, _Np - 2, _Np - 1> {}; };
N
N} // namespace detail
N
N#endif  // !__has_builtin(__make_integer_seq) || defined(_LIBCPP_TESTING_FALLBACK_MAKE_INTEGER_SEQUENCE)
N
N#if __has_builtin(__make_integer_seq)
X#if 0
Stemplate <size_t _Ep, size_t _Sp>
Susing __make_indices_imp =
S    typename __make_integer_seq<__integer_sequence, size_t, _Ep - _Sp>::template
S    __to_tuple_indices<_Sp>;
N#else
Ntemplate <size_t _Ep, size_t _Sp>
Nusing __make_indices_imp =
N    typename __detail::__make<_Ep - _Sp>::type::template __to_tuple_indices<_Sp>;
N
N#endif
N
Ntemplate <size_t _Ep, size_t _Sp = 0>
Nstruct __make_tuple_indices
N{
N    static_assert(_Sp <= _Ep, "__make_tuple_indices input error");
N    typedef __make_indices_imp<_Ep, _Sp> type;
N};
N
N
Ntemplate <class ..._Tp> class _LIBCPP_TEMPLATE_VIS tuple;
Xtemplate <class ..._Tp> class  tuple;
N
Ntemplate <class... _Tp> struct __tuple_like<tuple<_Tp...> > : true_type {};
N
Ntemplate <class ..._Tp>
Nclass _LIBCPP_TEMPLATE_VIS tuple_size<tuple<_Tp...> >
Xclass  tuple_size<tuple<_Tp...> >
N    : public integral_constant<size_t, sizeof...(_Tp)>
N{
N};
N
Ntemplate <size_t _Ip, class ..._Tp>
N_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
X__attribute__ ((__always_inline__)) constexpr
Ntypename tuple_element<_Ip, tuple<_Tp...> >::type&
Nget(tuple<_Tp...>&) _NOEXCEPT;
Xget(tuple<_Tp...>&) noexcept;
N
Ntemplate <size_t _Ip, class ..._Tp>
N_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
X__attribute__ ((__always_inline__)) constexpr
Nconst typename tuple_element<_Ip, tuple<_Tp...> >::type&
Nget(const tuple<_Tp...>&) _NOEXCEPT;
Xget(const tuple<_Tp...>&) noexcept;
N
Ntemplate <size_t _Ip, class ..._Tp>
N_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
X__attribute__ ((__always_inline__)) constexpr
Ntypename tuple_element<_Ip, tuple<_Tp...> >::type&&
Nget(tuple<_Tp...>&&) _NOEXCEPT;
Xget(tuple<_Tp...>&&) noexcept;
N
Ntemplate <size_t _Ip, class ..._Tp>
N_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
X__attribute__ ((__always_inline__)) constexpr
Nconst typename tuple_element<_Ip, tuple<_Tp...> >::type&&
Nget(const tuple<_Tp...>&&) _NOEXCEPT;
Xget(const tuple<_Tp...>&&) noexcept;
N
N#endif // !defined(_LIBCPP_CXX03_LANG)
N
N// pair specializations
N
Ntemplate <class _T1, class _T2> struct __tuple_like<pair<_T1, _T2> > : true_type {};
N
Ntemplate <size_t _Ip, class _T1, class _T2>
N_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
X__attribute__ ((__always_inline__)) constexpr
Ntypename tuple_element<_Ip, pair<_T1, _T2> >::type&
Nget(pair<_T1, _T2>&) _NOEXCEPT;
Xget(pair<_T1, _T2>&) noexcept;
N
Ntemplate <size_t _Ip, class _T1, class _T2>
N_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
X__attribute__ ((__always_inline__)) constexpr
Nconst typename tuple_element<_Ip, pair<_T1, _T2> >::type&
Nget(const pair<_T1, _T2>&) _NOEXCEPT;
Xget(const pair<_T1, _T2>&) noexcept;
N
N#ifndef _LIBCPP_CXX03_LANG
Ntemplate <size_t _Ip, class _T1, class _T2>
N_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
X__attribute__ ((__always_inline__)) constexpr
Ntypename tuple_element<_Ip, pair<_T1, _T2> >::type&&
Nget(pair<_T1, _T2>&&) _NOEXCEPT;
Xget(pair<_T1, _T2>&&) noexcept;
N
Ntemplate <size_t _Ip, class _T1, class _T2>
N_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
X__attribute__ ((__always_inline__)) constexpr
Nconst typename tuple_element<_Ip, pair<_T1, _T2> >::type&&
Nget(const pair<_T1, _T2>&&) _NOEXCEPT;
Xget(const pair<_T1, _T2>&&) noexcept;
N#endif
N
N// array specializations
N
Ntemplate <class _Tp, size_t _Size> struct _LIBCPP_TEMPLATE_VIS array;
Xtemplate <class _Tp, size_t _Size> struct  array;
N
Ntemplate <class _Tp, size_t _Size> struct __tuple_like<array<_Tp, _Size> > : true_type {};
N
Ntemplate <size_t _Ip, class _Tp, size_t _Size>
N_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
X__attribute__ ((__always_inline__)) constexpr
N_Tp&
Nget(array<_Tp, _Size>&) _NOEXCEPT;
Xget(array<_Tp, _Size>&) noexcept;
N
Ntemplate <size_t _Ip, class _Tp, size_t _Size>
N_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
X__attribute__ ((__always_inline__)) constexpr
Nconst _Tp&
Nget(const array<_Tp, _Size>&) _NOEXCEPT;
Xget(const array<_Tp, _Size>&) noexcept;
N
N#ifndef _LIBCPP_CXX03_LANG
Ntemplate <size_t _Ip, class _Tp, size_t _Size>
N_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
X__attribute__ ((__always_inline__)) constexpr
N_Tp&&
Nget(array<_Tp, _Size>&&) _NOEXCEPT;
Xget(array<_Tp, _Size>&&) noexcept;
N
Ntemplate <size_t _Ip, class _Tp, size_t _Size>
N_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
X__attribute__ ((__always_inline__)) constexpr
Nconst _Tp&&
Nget(const array<_Tp, _Size>&&) _NOEXCEPT;
Xget(const array<_Tp, _Size>&&) noexcept;
N#endif
N
N#ifndef _LIBCPP_CXX03_LANG
N
N// __tuple_types
N
Ntemplate <class ..._Tp> struct __tuple_types {};
N
N#if !__has_builtin(__type_pack_element)
X#if !0
N
Nnamespace __indexer_detail {
N
Ntemplate <size_t _Idx, class _Tp>
Nstruct __indexed { using type = _Tp; };
N
Ntemplate <class _Types, class _Indexes> struct __indexer;
N
Ntemplate <class ..._Types, size_t ..._Idx>
Nstruct __indexer<__tuple_types<_Types...>, __tuple_indices<_Idx...>>
N    : __indexed<_Idx, _Types>...
N{};
N
Ntemplate <size_t _Idx, class _Tp>
N__indexed<_Idx, _Tp> __at_index(__indexed<_Idx, _Tp> const&);
N
N} // namespace __indexer_detail
N
Ntemplate <size_t _Idx, class ..._Types>
Nusing __type_pack_element = typename decltype(
N    __indexer_detail::__at_index<_Idx>(
N        __indexer_detail::__indexer<
N            __tuple_types<_Types...>,
N            typename __make_tuple_indices<sizeof...(_Types)>::type
N        >{})
N  )::type;
N#endif
N
Ntemplate <size_t _Ip, class ..._Types>
Nclass _LIBCPP_TEMPLATE_VIS tuple_element<_Ip, __tuple_types<_Types...>>
Xclass  tuple_element<_Ip, __tuple_types<_Types...>>
N{
Npublic:
N    static_assert(_Ip < sizeof...(_Types), "tuple_element index out of range");
N    typedef __type_pack_element<_Ip, _Types...> type;
N};
N
N
Ntemplate <class ..._Tp>
Nclass _LIBCPP_TEMPLATE_VIS tuple_size<__tuple_types<_Tp...> >
Xclass  tuple_size<__tuple_types<_Tp...> >
N    : public integral_constant<size_t, sizeof...(_Tp)>
N{
N};
N
Ntemplate <class... _Tp> struct __tuple_like<__tuple_types<_Tp...> > : true_type {};
N
Ntemplate <bool _ApplyLV, bool _ApplyConst, bool _ApplyVolatile>
Nstruct __apply_cv_mf;
Ntemplate <>
Nstruct __apply_cv_mf<false, false, false> {
N  template <class _Tp> using __apply = _Tp;
N};
Ntemplate <>
Nstruct __apply_cv_mf<false, true, false> {
N  template <class _Tp> using __apply = const _Tp;
N};
Ntemplate <>
Nstruct __apply_cv_mf<false, false, true> {
N  template <class _Tp> using __apply = volatile _Tp;
N};
Ntemplate <>
Nstruct __apply_cv_mf<false, true, true> {
N  template <class _Tp> using __apply = const volatile _Tp;
N};
Ntemplate <>
Nstruct __apply_cv_mf<true, false, false> {
N  template <class _Tp> using __apply = _Tp&;
N};
Ntemplate <>
Nstruct __apply_cv_mf<true, true, false> {
N  template <class _Tp> using __apply = const _Tp&;
N};
Ntemplate <>
Nstruct __apply_cv_mf<true, false, true> {
N  template <class _Tp> using __apply = volatile _Tp&;
N};
Ntemplate <>
Nstruct __apply_cv_mf<true, true, true> {
N  template <class _Tp> using __apply = const volatile _Tp&;
N};
Ntemplate <class _Tp, class _RawTp = typename remove_reference<_Tp>::type>
Nusing __apply_cv_t = __apply_cv_mf<
N    is_lvalue_reference<_Tp>::value,
N    is_const<_RawTp>::value,
N    is_volatile<_RawTp>::value>;
N
N// __make_tuple_types
N
N// __make_tuple_types<_Tuple<_Types...>, _Ep, _Sp>::type is a
N// __tuple_types<_Types...> using only those _Types in the range [_Sp, _Ep).
N// _Sp defaults to 0 and _Ep defaults to tuple_size<_Tuple>.  If _Tuple is a
N// lvalue_reference type, then __tuple_types<_Types&...> is the result.
N
Ntemplate <class _TupleTypes, class _TupleIndices>
Nstruct __make_tuple_types_flat;
N
Ntemplate <template <class...> class _Tuple, class ..._Types, size_t ..._Idx>
Nstruct __make_tuple_types_flat<_Tuple<_Types...>, __tuple_indices<_Idx...>> {
N  // Specialization for pair, tuple, and __tuple_types
N  template <class _Tp, class _ApplyFn = __apply_cv_t<_Tp>>
N  using __apply_quals = __tuple_types<
N      typename _ApplyFn::template __apply<__type_pack_element<_Idx, _Types...>>...
N    >;
N};
N
Ntemplate <class _Vt, size_t _Np, size_t ..._Idx>
Nstruct __make_tuple_types_flat<array<_Vt, _Np>, __tuple_indices<_Idx...>> {
N  template <size_t>
N  using __value_type = _Vt;
N  template <class _Tp, class _ApplyFn = __apply_cv_t<_Tp>>
N  using __apply_quals = __tuple_types<
N      typename _ApplyFn::template __apply<__value_type<_Idx>>...
N    >;
N};
N
Ntemplate <class _Tp, size_t _Ep = tuple_size<typename remove_reference<_Tp>::type>::value,
N          size_t _Sp = 0,
N          bool _SameSize = (_Ep == tuple_size<typename remove_reference<_Tp>::type>::value)>
Nstruct __make_tuple_types
N{
N    static_assert(_Sp <= _Ep, "__make_tuple_types input error");
N    using _RawTp = typename remove_cv<typename remove_reference<_Tp>::type>::type;
N    using _Maker = __make_tuple_types_flat<_RawTp, typename __make_tuple_indices<_Ep, _Sp>::type>;
N    using type = typename _Maker::template __apply_quals<_Tp>;
N};
N
Ntemplate <class ..._Types, size_t _Ep>
Nstruct __make_tuple_types<tuple<_Types...>, _Ep, 0, true> {
N  typedef __tuple_types<_Types...> type;
N};
N
Ntemplate <class ..._Types, size_t _Ep>
Nstruct __make_tuple_types<__tuple_types<_Types...>, _Ep, 0, true> {
N  typedef __tuple_types<_Types...> type;
N};
N
Ntemplate <bool ..._Preds>
Nstruct __all_dummy;
N
Ntemplate <bool ..._Pred>
Nusing __all = is_same<__all_dummy<_Pred...>, __all_dummy<((void)_Pred, true)...>>;
N
Nstruct __tuple_sfinae_base {
N  template <template <class, class...> class _Trait,
N            class ..._LArgs, class ..._RArgs>
N  static auto __do_test(__tuple_types<_LArgs...>, __tuple_types<_RArgs...>)
N    -> __all<typename enable_if<_Trait<_LArgs, _RArgs>::value, bool>::type(true)...>;
N  template <template <class...> class>
N  static auto __do_test(...) -> false_type;
N
N  template <class _FromArgs, class _ToArgs>
N  using __constructible = decltype(__do_test<is_constructible>(_ToArgs{}, _FromArgs{}));
N  template <class _FromArgs, class _ToArgs>
N  using __convertible = decltype(__do_test<is_convertible>(_FromArgs{}, _ToArgs{}));
N  template <class _FromArgs, class _ToArgs>
N  using __assignable = decltype(__do_test<is_assignable>(_ToArgs{}, _FromArgs{}));
N};
N
N// __tuple_convertible
N
Ntemplate <class _Tp, class _Up, bool = __tuple_like<typename remove_reference<_Tp>::type>::value,
N                                bool = __tuple_like<_Up>::value>
Nstruct __tuple_convertible
N    : public false_type {};
N
Ntemplate <class _Tp, class _Up>
Nstruct __tuple_convertible<_Tp, _Up, true, true>
N    : public __tuple_sfinae_base::__convertible<
N      typename __make_tuple_types<_Tp>::type
N    , typename __make_tuple_types<_Up>::type
N    >
N{};
N
N// __tuple_constructible
N
Ntemplate <class _Tp, class _Up, bool = __tuple_like<typename remove_reference<_Tp>::type>::value,
N                                bool = __tuple_like<_Up>::value>
Nstruct __tuple_constructible
N    : public false_type {};
N
Ntemplate <class _Tp, class _Up>
Nstruct __tuple_constructible<_Tp, _Up, true, true>
N    : public __tuple_sfinae_base::__constructible<
N      typename __make_tuple_types<_Tp>::type
N    , typename __make_tuple_types<_Up>::type
N    >
N{};
N
N// __tuple_assignable
N
Ntemplate <class _Tp, class _Up, bool = __tuple_like<typename remove_reference<_Tp>::type>::value,
N                                bool = __tuple_like<_Up>::value>
Nstruct __tuple_assignable
N    : public false_type {};
N
Ntemplate <class _Tp, class _Up>
Nstruct __tuple_assignable<_Tp, _Up, true, true>
N    : public __tuple_sfinae_base::__assignable<
N      typename __make_tuple_types<_Tp>::type
N    , typename __make_tuple_types<_Up&>::type
N    >
N{};
N
N
Ntemplate <size_t _Ip, class ..._Tp>
Nclass _LIBCPP_TEMPLATE_VIS tuple_element<_Ip, tuple<_Tp...> >
Xclass  tuple_element<_Ip, tuple<_Tp...> >
N{
Npublic:
N    typedef typename tuple_element<_Ip, __tuple_types<_Tp...> >::type type;
N};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <size_t _Ip, class ..._Tp>
Nusing tuple_element_t = typename tuple_element <_Ip, _Tp...>::type;
N#endif
N
Ntemplate <bool _IsTuple, class _SizeTrait, size_t _Expected>
Nstruct __tuple_like_with_size_imp : false_type {};
N
Ntemplate <class _SizeTrait, size_t _Expected>
Nstruct __tuple_like_with_size_imp<true, _SizeTrait, _Expected>
N    : integral_constant<bool, _SizeTrait::value == _Expected> {};
N
Ntemplate <class _Tuple, size_t _ExpectedSize,
N          class _RawTuple = typename __uncvref<_Tuple>::type>
Nusing __tuple_like_with_size = __tuple_like_with_size_imp<
N                                   __tuple_like<_RawTuple>::value,
N                                   tuple_size<_RawTuple>, _ExpectedSize
N                              >;
N
Nstruct _LIBCPP_TYPE_VIS __check_tuple_constructor_fail {
Xstruct  __check_tuple_constructor_fail {
N    template <class ...>
N    static constexpr bool __enable_default() { return false; }
N    template <class ...>
N    static constexpr bool __enable_explicit() { return false; }
N    template <class ...>
N    static constexpr bool __enable_implicit() { return false; }
N    template <class ...>
N    static constexpr bool __enable_assign() { return false; }
N};
N#endif // !defined(_LIBCPP_CXX03_LANG)
N
N#if _LIBCPP_STD_VER > 14
X#if 14 > 14
S
Stemplate <bool _CanCopy, bool _CanMove>
Sstruct __sfinae_ctor_base {};
Stemplate <>
Sstruct __sfinae_ctor_base<false, false> {
S  __sfinae_ctor_base() = default;
S  __sfinae_ctor_base(__sfinae_ctor_base const&) = delete;
S  __sfinae_ctor_base(__sfinae_ctor_base &&) = delete;
S  __sfinae_ctor_base& operator=(__sfinae_ctor_base const&) = default;
S  __sfinae_ctor_base& operator=(__sfinae_ctor_base&&) = default;
S};
Stemplate <>
Sstruct __sfinae_ctor_base<true, false> {
S  __sfinae_ctor_base() = default;
S  __sfinae_ctor_base(__sfinae_ctor_base const&) = default;
S  __sfinae_ctor_base(__sfinae_ctor_base &&) = delete;
S  __sfinae_ctor_base& operator=(__sfinae_ctor_base const&) = default;
S  __sfinae_ctor_base& operator=(__sfinae_ctor_base&&) = default;
S};
Stemplate <>
Sstruct __sfinae_ctor_base<false, true> {
S  __sfinae_ctor_base() = default;
S  __sfinae_ctor_base(__sfinae_ctor_base const&) = delete;
S  __sfinae_ctor_base(__sfinae_ctor_base &&) = default;
S  __sfinae_ctor_base& operator=(__sfinae_ctor_base const&) = default;
S  __sfinae_ctor_base& operator=(__sfinae_ctor_base&&) = default;
S};
S
Stemplate <bool _CanCopy, bool _CanMove>
Sstruct __sfinae_assign_base {};
Stemplate <>
Sstruct __sfinae_assign_base<false, false> {
S  __sfinae_assign_base() = default;
S  __sfinae_assign_base(__sfinae_assign_base const&) = default;
S  __sfinae_assign_base(__sfinae_assign_base &&) = default;
S  __sfinae_assign_base& operator=(__sfinae_assign_base const&) = delete;
S  __sfinae_assign_base& operator=(__sfinae_assign_base&&) = delete;
S};
Stemplate <>
Sstruct __sfinae_assign_base<true, false> {
S  __sfinae_assign_base() = default;
S  __sfinae_assign_base(__sfinae_assign_base const&) = default;
S  __sfinae_assign_base(__sfinae_assign_base &&) = default;
S  __sfinae_assign_base& operator=(__sfinae_assign_base const&) = default;
S  __sfinae_assign_base& operator=(__sfinae_assign_base&&) = delete;
S};
Stemplate <>
Sstruct __sfinae_assign_base<false, true> {
S  __sfinae_assign_base() = default;
S  __sfinae_assign_base(__sfinae_assign_base const&) = default;
S  __sfinae_assign_base(__sfinae_assign_base &&) = default;
S  __sfinae_assign_base& operator=(__sfinae_assign_base const&) = delete;
S  __sfinae_assign_base& operator=(__sfinae_assign_base&&) = default;
S};
N#endif // _LIBCPP_STD_VER > 14
N
N_LIBCPP_END_NAMESPACE_STD
X} }
N
N#endif  // _LIBCPP___TUPLE
L 199 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/utility" 2
N#include <type_traits>
N#include <initializer_list>
N#include <limits>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/limits" 1
N// -*- C++ -*-
N//===---------------------------- limits ----------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is dual licensed under the MIT and the University of Illinois Open
N// Source Licenses. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP_LIMITS
N#define _LIBCPP_LIMITS
N
N/*
N    limits synopsis
N
Nnamespace std
N{
N
Ntemplate<class T>
Nclass numeric_limits
N{
Npublic:
N    static constexpr bool is_specialized = false;
N    static constexpr T min() noexcept;
N    static constexpr T max() noexcept;
N    static constexpr T lowest() noexcept;
N
N    static constexpr int  digits = 0;
N    static constexpr int  digits10 = 0;
N    static constexpr int  max_digits10 = 0;
N    static constexpr bool is_signed = false;
N    static constexpr bool is_integer = false;
N    static constexpr bool is_exact = false;
N    static constexpr int  radix = 0;
N    static constexpr T epsilon() noexcept;
N    static constexpr T round_error() noexcept;
N
N    static constexpr int  min_exponent = 0;
N    static constexpr int  min_exponent10 = 0;
N    static constexpr int  max_exponent = 0;
N    static constexpr int  max_exponent10 = 0;
N
N    static constexpr bool has_infinity = false;
N    static constexpr bool has_quiet_NaN = false;
N    static constexpr bool has_signaling_NaN = false;
N    static constexpr float_denorm_style has_denorm = denorm_absent;
N    static constexpr bool has_denorm_loss = false;
N    static constexpr T infinity() noexcept;
N    static constexpr T quiet_NaN() noexcept;
N    static constexpr T signaling_NaN() noexcept;
N    static constexpr T denorm_min() noexcept;
N
N    static constexpr bool is_iec559 = false;
N    static constexpr bool is_bounded = false;
N    static constexpr bool is_modulo = false;
N
N    static constexpr bool traps = false;
N    static constexpr bool tinyness_before = false;
N    static constexpr float_round_style round_style = round_toward_zero;
N};
N
Nenum __attribute__((packed)) float_round_style
N{
N    round_indeterminate       = -1,
N    round_toward_zero         =  0,
N    round_to_nearest          =  1,
N    round_toward_infinity     =  2,
N    round_toward_neg_infinity =  3
N};
N
Nenum __attribute__((packed)) float_denorm_style
N{
N    denorm_indeterminate = -1,
N    denorm_absent = 0,
N    denorm_present = 1
N};
N
Ntemplate<> class numeric_limits<cv bool>;
N
Ntemplate<> class numeric_limits<cv char>;
Ntemplate<> class numeric_limits<cv signed char>;
Ntemplate<> class numeric_limits<cv unsigned char>;
Ntemplate<> class numeric_limits<cv wchar_t>;
Ntemplate<> class numeric_limits<cv char16_t>;
Ntemplate<> class numeric_limits<cv char32_t>;
N
Ntemplate<> class numeric_limits<cv short>;
Ntemplate<> class numeric_limits<cv int>;
Ntemplate<> class numeric_limits<cv long>;
Ntemplate<> class numeric_limits<cv long long>;
Ntemplate<> class numeric_limits<cv unsigned short>;
Ntemplate<> class numeric_limits<cv unsigned int>;
Ntemplate<> class numeric_limits<cv unsigned long>;
Ntemplate<> class numeric_limits<cv unsigned long long>;
N
Ntemplate<> class numeric_limits<cv float>;
Ntemplate<> class numeric_limits<cv double>;
Ntemplate<> class numeric_limits<cv long double>;
N
N}  // std
N
N*/
N#include <__config>
N#include <type_traits>
N
N#if defined(_LIBCPP_COMPILER_MSVC)
X#if 0L
S#include "support/win32/limits_msvc_win32.h"
N#elif defined(_LIBCPP_COMPILER_TI)
X#elif 1L
N#include "support/ti/__limit_defs.h"
L 1 "C:\ti\ccs930\ccs\tools\compiler\ti-cgt-arm_18.12.5.LTS\include\libcxx\support/ti/__limit_defs.h" 1
N// -*- C++ -*-
N//===--------------------- support/ti/limits.h ----------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is dual licensed under the MIT and the University of Illinois Open
N// Source Licenses. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP_SUPPORT_TI_LIMIT_DEFS_H
N#define _LIBCPP_SUPPORT_TI_LIMIT_DEFS_H
N
N#include <__config>
N#include <float.h>  // FP Limits
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/float.h" 1
N/* -*- C++ -*- */
N/*===--------------------------- complex.h --------------------------------===*/
N/*                                                                            */
N/*                     The LLVM Compiler Infrastructure                       */
N/*                                                                            */
N/* This file is dual licensed under the MIT and the University of Illinois Open
N** Source Licenses. See LICENSE.TXT for details.
N*/
N/*===----------------------------------------------------------------------===*/
N
N#ifndef _LIBCPP_FLOAT_H
N#define _LIBCPP_FLOAT_H
N
N/*
N    float.h synopsis
N
NMacros:
N
N    FLT_ROUNDS
N    FLT_EVAL_METHOD     // C99
N    FLT_RADIX
N
N    FLT_MANT_DIG
N    DBL_MANT_DIG
N    LDBL_MANT_DIG
N
N    DECIMAL_DIG         // C99
N
N    FLT_DIG
N    DBL_DIG
N    LDBL_DIG
N
N    FLT_MIN_EXP
N    DBL_MIN_EXP
N    LDBL_MIN_EXP
N
N    FLT_MIN_10_EXP
N    DBL_MIN_10_EXP
N    LDBL_MIN_10_EXP
N
N    FLT_MAX_EXP
N    DBL_MAX_EXP
N    LDBL_MAX_EXP
N
N    FLT_MAX_10_EXP
N    DBL_MAX_10_EXP
N    LDBL_MAX_10_EXP
N
N    FLT_MAX
N    DBL_MAX
N    LDBL_MAX
N
N    FLT_EPSILON
N    DBL_EPSILON
N    LDBL_EPSILON
N
N    FLT_MIN
N    DBL_MIN
N    LDBL_MIN
N
N*/
N
N#include <__config>
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N#include_next <float.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/float.h" 1
N/*****************************************************************************/
N/* float.h                                                                   */
N/*                                                                           */
N/* Copyright (c) 1993 Texas Instruments Incorporated                         */
N/* http://www.ti.com/                                                        */
N/*                                                                           */
N/*  Redistribution and  use in source  and binary forms, with  or without    */
N/*  modification,  are permitted provided  that the  following conditions    */
N/*  are met:                                                                 */
N/*                                                                           */
N/*     Redistributions  of source  code must  retain the  above copyright    */
N/*     notice, this list of conditions and the following disclaimer.         */
N/*                                                                           */
N/*     Redistributions in binary form  must reproduce the above copyright    */
N/*     notice, this  list of conditions  and the following  disclaimer in    */
N/*     the  documentation  and/or   other  materials  provided  with  the    */
N/*     distribution.                                                         */
N/*                                                                           */
N/*     Neither the  name of Texas Instruments Incorporated  nor the names    */
N/*     of its  contributors may  be used to  endorse or  promote products    */
N/*     derived  from   this  software  without   specific  prior  written    */
N/*     permission.                                                           */
N/*                                                                           */
N/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS    */
N/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT    */
N/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    */
N/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT    */
N/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    */
N/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT    */
N/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    */
N/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    */
N/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT    */
N/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    */
N/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     */
N/*                                                                           */
N/*****************************************************************************/
N
N/********************************************************************/
N/*    KEY:  FLT_     - APPLIES TO TYPE FLOAT                        */
N/*          DBL_     - APPLIES TO TYPE DOUBLE                       */
N/*          LDBL_    - APPLIES TO TYPE LONG DOUBLE                  */
N/********************************************************************/
N#ifndef _FLOAT_H_
N#define _FLOAT_H_
N
N#include <_ti_config.h>
N
N#pragma diag_push
N#pragma CHECK_MISRA("-20.1") /* standard headers must define standard names */
N
N#define FLT_RADIX                         2   /* RADIX OF EXPONENT         */
N#define FLT_ROUNDS                        1   /* ROUND TO NEAREST          */
N#define FLT_EVAL_METHOD                 (-1)  /* INDETERMINABLE            */
N
N#define FLT_DIG                           6   /* DECIMAL PRECISION         */
N#define FLT_DECIMAL_DIG                    9  /* DECIMAL PRECISION         */
N#define FLT_MANT_DIG                     24   /* BITS IN MANTISSA          */
N#define FLT_MIN_EXP                   (-125)  /* SMALLEST EXPONENT         */
N#define FLT_MAX_EXP                     128   /* LARGEST EXPONENT          */
N#define FLT_MIN_10_EXP                 (-37)  /* MIN POWER OF 10           */
N#define FLT_MAX_10_EXP                   38   /* MAX POWER OF 10           */
N#define FLT_EPSILON         1.192092896E-07F  /* SMALLEST X WHERE 1+X != 1 */
N#define FLT_MIN             1.175494351E-38F  /* MIN NORMALIZED POS VALUE  */
N#define FLT_MAX             3.402823466E+38F  /* MAX POSITIVE VALUE        */
N#if defined(_TI_C11LIB) || __TI_STRICT_ANSI_MODE__ == 0
X#if 1L || 0 == 0
N#define FLT_TRUE_MIN        1.401298464E-45F  /* MIN POSITIVE VALUE        */
N#define FLT_HAS_SUBNORM                    0  /* SUPPORTS SUBNORMAL        */
N#endif
N
N#if defined(__TMS320C2000__) && !defined(__TI_EABI__) || defined(__MSP430__) && !defined(__TI_EABI__)
X#if 0L && !1L || 0L && !1L
S
S#define DBL_DIG             (FLT_DIG)         /* DECIMAL PRECISION         */
S#define DBL_DECIMAL_DIG     (FLT_DECIMAL_DIG) /* DECIMAL PRECISION         */
S#define DBL_MANT_DIG        (FLT_MANT_DIG)    /* BITS IN MANTISSA          */
S#define DBL_MIN_EXP         (FLT_MIN_EXP)     /* SMALLEST EXPONENT         */
S#define DBL_MAX_EXP         (FLT_MAX_EXP)     /* LARGEST EXPONENT          */
S#define DBL_MIN_10_EXP      (FLT_MIN_10_EXP)  /* MIN POWER OF 10           */
S#define DBL_MAX_10_EXP      (FLT_MAX_10_EXP)  /* MAX POWER OF 10           */
S#define DBL_EPSILON         1.192092896E-07   /* SMALLEST X WHERE 1+X != 1 */
S#define DBL_MIN             1.175494351E-38   /* MIN NORMALIZED POS VALUE  */
S#define DBL_MAX             3.402823466E+38   /* MAX POSITIVE VALUE        */
S#if defined(_TI_C11LIB) || __TI_STRICT_ANSI_MODE__ == 0
S#define DBL_TRUE_MIN        ((double)(FLT_TRUE_MIN))
S#define DBL_HAS_SUBNORM     (FLT_HAS_SUBNORM)
S#endif /* C11 IS VISIBLE */
S
N#else
N
N#define DBL_DIG                          15   /* DECIMAL PRECISION         */
N#define DBL_DECIMAL_DIG                  17   /* DECIMAL PRECISION         */
N#define DBL_MANT_DIG                     53   /* BITS IN MANTISSA          */
N#define DBL_MIN_EXP                  (-1021)  /* SMALLEST EXPONENT         */
N#define DBL_MAX_EXP                    1024   /* LARGEST EXPONENT          */
N#define DBL_MIN_10_EXP                (-307)  /* MIN POWER OF 10           */
N#define DBL_MAX_10_EXP                  308   /* MAX POWER OF 10           */
N#define DBL_EPSILON  2.2204460492503131E-16   /* SMALLEST X WHERE 1+X != 1 */
N#define DBL_MIN     2.2250738585072014E-308   /* MIN NORMALIZED POS VALUE  */
N#define DBL_MAX     1.7976931348623157E+308   /* MAX POSITIVE VALUE        */
N#if defined(_TI_C11LIB) || __TI_STRICT_ANSI_MODE__ == 0
X#if 1L || 0 == 0
N#define DBL_TRUE_MIN 4.9406564584124654E-324
N#define DBL_HAS_SUBNORM                   0
N#endif
N
N#endif
N
N#if defined(__MSP430__) && !defined(__TI_EABI__)
X#if 0L && !1L
S
S#define LDBL_DIG            (FLT_DIG)         /* DECIMAL PRECISION         */
S#define LDBL_DECIMAL_DIG    (FLT_DECIMAL_DIGIT)/* DECIMAL PRECISION        */
S#define LDBL_MANT_DIG       (FLT_MANT_DIG)    /* BITS IN MANTISSA          */
S#define LDBL_MIN_EXP        (FLT_MIN_EXP)     /* SMALLEST EXPONENT         */
S#define LDBL_MAX_EXP        (FLT_MAX_EXP)     /* LARGEST EXPONENT          */
S#define LDBL_MIN_10_EXP     (FLT_MIN_10_EXP)  /* MIN POWER OF 10           */
S#define LDBL_MAX_10_EXP     (FLT_MAX_10_EXP)  /* MAX POWER OF 10           */
S#define LDBL_EPSILON        1.192092896E-07L  /* SMALLEST X WHERE 1+X != 1 */
S#define LDBL_MIN            1.175494351E-38L  /* MIN NORMALIZED POS VALUE  */
S#define LDBL_MAX            3.402823466E+38L  /* MAX POSITIVE VALUE        */
S#if defined(_TI_C11LIB) || __TI_STRICT_ANSI_MODE__ == 0
S#define LDBL_TRUE_MIN       ((long double)FLT_TRUE_MIN)
S#define LDBL_HAS_SUBNORM    (FLT_HAS_SUBNORM)              1
S#endif
S
N#else
N
N#define LDBL_DIG                         15   /* DECIMAL PRECISION         */
N#define LDBL_DECIMAL_DIG                 17   /* DECIMAL PRECISION         */
N#define LDBL_MANT_DIG                    53   /* BITS IN MANTISSA          */
N#define LDBL_MIN_EXP                 (-1021)  /* SMALLEST EXPONENT         */
N#define LDBL_MAX_EXP                   1024   /* LARGEST EXPONENT          */
N#define LDBL_MIN_10_EXP               (-307)  /* MIN POWER OF 10           */
N#define LDBL_MAX_10_EXP                 308   /* MAX POWER OF 10           */
N#define LDBL_EPSILON 2.2204460492503131E-16L  /* SMALLEST X WHERE 1+X != 1 */
N#define LDBL_MIN    2.2250738585072014E-308L  /* MIN NORMALIZED POS VALUE  */
N#define LDBL_MAX    1.7976931348623157E+308L  /* MAX POSITIVE VALUE        */
N#if defined(_TI_C11LIB) || __TI_STRICT_ANSI_MODE__ == 0
X#if 1L || 0 == 0
N#define LDBL_TRUE_MIN 4.9406564584124654E-324L
N#define LDBL_HAS_SUBNORM                  0
N#endif
N
N#endif
N
N#define DECIMAL_DIG        (LDBL_DECIMAL_DIG) /* LARGEST DECIMAL PRECISION */
N
N#pragma diag_pop
N
N#endif /* _FLOAT_H_ */
L 70 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/float.h" 2
N
N#ifdef __cplusplus
N
N#ifndef FLT_EVAL_METHOD
S#define FLT_EVAL_METHOD __FLT_EVAL_METHOD__
N#endif
N
N#ifndef DECIMAL_DIG
S#define DECIMAL_DIG __DECIMAL_DIG__
N#endif
N
N#endif /* __cplusplus */
N
N#endif  /* _LIBCPP_FLOAT_H */
L 16 "C:\ti\ccs930\ccs\tools\compiler\ti-cgt-arm_18.12.5.LTS\include\libcxx\support/ti/__limit_defs.h" 2
N
N#define __DBL_DENORM_MIN__ (0.0)
N#define __DBL_DIG__ DBL_DIG
N#define __DBL_EPSILON__ DBL_EPSILON
N#define __DBL_MANT_DIG__ DBL_MANT_DIG
N#define __DBL_MAX__ DBL_MAX
N#define __DBL_MAX_10_EXP__ DBL_MAX_10_EXP
N#define __DBL_MAX_EXP__ DBL_MAX_EXP
N#define __DBL_MIN__ DBL_MIN
N#define __DBL_MIN_10_EXP__ DBL_MIN_10_EXP
N#define __DBL_MIN_EXP__ DBL_MIN_EXP
N
N#define __FLT_DENORM_MIN__ (0.0f)
N#define __FLT_DIG__ FLT_DIG
N#define __FLT_EPSILON__ FLT_EPSILON
N#define __FLT_MANT_DIG__ FLT_MANT_DIG
N#define __FLT_MAX__ FLT_MAX
N#define __FLT_MAX_10_EXP__ FLT_MAX_10_EXP
N#define __FLT_MAX_EXP__ FLT_MAX_EXP
N#define __FLT_MIN__ FLT_MIN
N#define __FLT_MIN_10_EXP__ FLT_MIN_10_EXP
N#define __FLT_MIN_EXP__ FLT_MIN_EXP
N#define __FLT_RADIX__ FLT_RADIX
N
N#define __LDBL_DENORM_MIN__ (0.0l)
N#define __LDBL_DIG__ LDBL_DIG
N#define __LDBL_EPSILON__ LDBL_EPSILON
N#define __LDBL_MANT_DIG__ LDBL_MANT_DIG
N#define __LDBL_MAX__ LDBL_MAX
N#define __LDBL_MAX_10_EXP__ LDBL_MAX_10_EXP
N#define __LDBL_MAX_EXP__ LDBL_MAX_EXP
N#define __LDBL_MIN__ LDBL_MIN
N#define __LDBL_MIN_10_EXP__ LDBL_MIN_10_EXP
N#define __LDBL_MIN_EXP__ LDBL_MIN_EXP
N
N#endif // _LIBCPP_SUPPORT_TI_LIMITS_H
L 111 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/limits" 2
N#endif // _LIBCPP_MSVCRT
N
N#if defined(__IBMCPP__)
X#if 0L
S#include "support/ibm/limits.h"
N#endif // __IBMCPP__
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N_LIBCPP_PUSH_MACROS
X_Pragma("push_macro(\"min\")") _Pragma("push_macro(\"max\")")
N#include <__undef_macros>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/__undef_macros" 1
N// -*- C++ -*-
N//===------------------------ __undef_macros ------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is distributed under the University of Illinois Open Source
N// License. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N
N#ifdef min
S#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
S#if defined(_LIBCPP_WARNING)
S_LIBCPP_WARNING("macro min is incompatible with C++.  Try #define NOMINMAX "
S                "before any Windows header. #undefing min")
S#else
S#warning: macro min is incompatible with C++.  #undefing min
S#endif
S#endif
S#undef min
N#endif
N
N#ifdef max
S#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
S#if defined(_LIBCPP_WARNING)
S_LIBCPP_WARNING("macro max is incompatible with C++.  Try #define NOMINMAX "
S                "before any Windows header. #undefing max")
S#else
S#warning: macro max is incompatible with C++.  #undefing max
S#endif
S#endif
S#undef max
N#endif
L 123 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/limits" 2
N
N
N_LIBCPP_BEGIN_NAMESPACE_STD
Xnamespace std { inline namespace __2 {
N
Nenum __attribute__((packed)) float_round_style
N{
N    round_indeterminate       = -1,
N    round_toward_zero         =  0,
N    round_to_nearest          =  1,
N    round_toward_infinity     =  2,
N    round_toward_neg_infinity =  3
N};
N
Nenum __attribute__((packed)) float_denorm_style
N{
N    denorm_indeterminate = -1,
N    denorm_absent = 0,
N    denorm_present = 1
N};
N
Ntemplate <class _Tp, bool = is_arithmetic<_Tp>::value>
Nclass __libcpp_numeric_limits
N{
Nprotected:
N    typedef _Tp type;
N
N    static _LIBCPP_CONSTEXPR const  bool is_specialized = false;
X    static constexpr const  bool is_specialized = false;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type min() _NOEXCEPT {return type();}
X    __attribute__ ((__always_inline__)) static constexpr type min() noexcept {return type();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type max() _NOEXCEPT {return type();}
X    __attribute__ ((__always_inline__)) static constexpr type max() noexcept {return type();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type lowest() _NOEXCEPT {return type();}
X    __attribute__ ((__always_inline__)) static constexpr type lowest() noexcept {return type();}
N
N    static _LIBCPP_CONSTEXPR const int  digits = 0;
X    static constexpr const int  digits = 0;
N    static _LIBCPP_CONSTEXPR const int  digits10 = 0;
X    static constexpr const int  digits10 = 0;
N    static _LIBCPP_CONSTEXPR const int  max_digits10 = 0;
X    static constexpr const int  max_digits10 = 0;
N    static _LIBCPP_CONSTEXPR const bool is_signed = false;
X    static constexpr const bool is_signed = false;
N    static _LIBCPP_CONSTEXPR const bool is_integer = false;
X    static constexpr const bool is_integer = false;
N    static _LIBCPP_CONSTEXPR const bool is_exact = false;
X    static constexpr const bool is_exact = false;
N    static _LIBCPP_CONSTEXPR const int  radix = 0;
X    static constexpr const int  radix = 0;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type epsilon() _NOEXCEPT {return type();}
X    __attribute__ ((__always_inline__)) static constexpr type epsilon() noexcept {return type();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type round_error() _NOEXCEPT {return type();}
X    __attribute__ ((__always_inline__)) static constexpr type round_error() noexcept {return type();}
N
N    static _LIBCPP_CONSTEXPR const int  min_exponent = 0;
X    static constexpr const int  min_exponent = 0;
N    static _LIBCPP_CONSTEXPR const int  min_exponent10 = 0;
X    static constexpr const int  min_exponent10 = 0;
N    static _LIBCPP_CONSTEXPR const int  max_exponent = 0;
X    static constexpr const int  max_exponent = 0;
N    static _LIBCPP_CONSTEXPR const int  max_exponent10 = 0;
X    static constexpr const int  max_exponent10 = 0;
N
N    static _LIBCPP_CONSTEXPR const bool has_infinity = false;
X    static constexpr const bool has_infinity = false;
N    static _LIBCPP_CONSTEXPR const bool has_quiet_NaN = false;
X    static constexpr const bool has_quiet_NaN = false;
N    static _LIBCPP_CONSTEXPR const bool has_signaling_NaN = false;
X    static constexpr const bool has_signaling_NaN = false;
N    static _LIBCPP_CONSTEXPR const float_denorm_style has_denorm = denorm_absent;
X    static constexpr const float_denorm_style has_denorm = denorm_absent;
N    static _LIBCPP_CONSTEXPR const bool has_denorm_loss = false;
X    static constexpr const bool has_denorm_loss = false;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type infinity() _NOEXCEPT {return type();}
X    __attribute__ ((__always_inline__)) static constexpr type infinity() noexcept {return type();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return type();}
X    __attribute__ ((__always_inline__)) static constexpr type quiet_NaN() noexcept {return type();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return type();}
X    __attribute__ ((__always_inline__)) static constexpr type signaling_NaN() noexcept {return type();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return type();}
X    __attribute__ ((__always_inline__)) static constexpr type denorm_min() noexcept {return type();}
N
N    static _LIBCPP_CONSTEXPR const bool is_iec559 = false;
X    static constexpr const bool is_iec559 = false;
N    static _LIBCPP_CONSTEXPR const bool is_bounded = false;
X    static constexpr const bool is_bounded = false;
N    static _LIBCPP_CONSTEXPR const bool is_modulo = false;
X    static constexpr const bool is_modulo = false;
N
N    static _LIBCPP_CONSTEXPR const bool traps = false;
X    static constexpr const bool traps = false;
N    static _LIBCPP_CONSTEXPR const bool tinyness_before = false;
X    static constexpr const bool tinyness_before = false;
N    static _LIBCPP_CONSTEXPR const float_round_style round_style = round_toward_zero;
X    static constexpr const float_round_style round_style = round_toward_zero;
N};
N
Ntemplate <class _Tp, int __digits, bool _IsSigned>
Nstruct __libcpp_compute_min
N{
N    static _LIBCPP_CONSTEXPR const _Tp value = _Tp(_Tp(1) << __digits);
X    static constexpr const _Tp value = _Tp(_Tp(1) << __digits);
N};
N
Ntemplate <class _Tp, int __digits>
Nstruct __libcpp_compute_min<_Tp, __digits, false>
N{
N    static _LIBCPP_CONSTEXPR const _Tp value = _Tp(0);
X    static constexpr const _Tp value = _Tp(0);
N};
N
Ntemplate <class _Tp>
Nclass __libcpp_numeric_limits<_Tp, true>
N{
Nprotected:
N    typedef _Tp type;
N
N    static _LIBCPP_CONSTEXPR const bool is_specialized = true;
X    static constexpr const bool is_specialized = true;
N
N    static _LIBCPP_CONSTEXPR const bool is_signed = type(-1) < type(0);
X    static constexpr const bool is_signed = type(-1) < type(0);
N    static _LIBCPP_CONSTEXPR const int  digits = static_cast<int>(sizeof(type) * __CHAR_BIT__ - is_signed);
X    static constexpr const int  digits = static_cast<int>(sizeof(type) * 8 - is_signed);
N    static _LIBCPP_CONSTEXPR const int  digits10 = digits * 3 / 10;
X    static constexpr const int  digits10 = digits * 3 / 10;
N    static _LIBCPP_CONSTEXPR const int  max_digits10 = 0;
X    static constexpr const int  max_digits10 = 0;
N    static _LIBCPP_CONSTEXPR const type __min = __libcpp_compute_min<type, digits, is_signed>::value;
X    static constexpr const type __min = __libcpp_compute_min<type, digits, is_signed>::value;
N    static _LIBCPP_CONSTEXPR const type __max = is_signed ? type(type(~0) ^ __min) : type(~0);
X    static constexpr const type __max = is_signed ? type(type(~0) ^ __min) : type(~0);
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type min() _NOEXCEPT {return __min;}
X    __attribute__ ((__always_inline__)) static constexpr type min() noexcept {return __min;}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type max() _NOEXCEPT {return __max;}
X    __attribute__ ((__always_inline__)) static constexpr type max() noexcept {return __max;}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type lowest() _NOEXCEPT {return min();}
X    __attribute__ ((__always_inline__)) static constexpr type lowest() noexcept {return min();}
N
N    static _LIBCPP_CONSTEXPR const bool is_integer = true;
X    static constexpr const bool is_integer = true;
N    static _LIBCPP_CONSTEXPR const bool is_exact = true;
X    static constexpr const bool is_exact = true;
N    static _LIBCPP_CONSTEXPR const int  radix = 2;
X    static constexpr const int  radix = 2;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type epsilon() _NOEXCEPT {return type(0);}
X    __attribute__ ((__always_inline__)) static constexpr type epsilon() noexcept {return type(0);}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type round_error() _NOEXCEPT {return type(0);}
X    __attribute__ ((__always_inline__)) static constexpr type round_error() noexcept {return type(0);}
N
N    static _LIBCPP_CONSTEXPR const int  min_exponent = 0;
X    static constexpr const int  min_exponent = 0;
N    static _LIBCPP_CONSTEXPR const int  min_exponent10 = 0;
X    static constexpr const int  min_exponent10 = 0;
N    static _LIBCPP_CONSTEXPR const int  max_exponent = 0;
X    static constexpr const int  max_exponent = 0;
N    static _LIBCPP_CONSTEXPR const int  max_exponent10 = 0;
X    static constexpr const int  max_exponent10 = 0;
N
N    static _LIBCPP_CONSTEXPR const bool has_infinity = false;
X    static constexpr const bool has_infinity = false;
N    static _LIBCPP_CONSTEXPR const bool has_quiet_NaN = false;
X    static constexpr const bool has_quiet_NaN = false;
N    static _LIBCPP_CONSTEXPR const bool has_signaling_NaN = false;
X    static constexpr const bool has_signaling_NaN = false;
N    static _LIBCPP_CONSTEXPR const float_denorm_style has_denorm = denorm_absent;
X    static constexpr const float_denorm_style has_denorm = denorm_absent;
N    static _LIBCPP_CONSTEXPR const bool has_denorm_loss = false;
X    static constexpr const bool has_denorm_loss = false;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type infinity() _NOEXCEPT {return type(0);}
X    __attribute__ ((__always_inline__)) static constexpr type infinity() noexcept {return type(0);}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return type(0);}
X    __attribute__ ((__always_inline__)) static constexpr type quiet_NaN() noexcept {return type(0);}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return type(0);}
X    __attribute__ ((__always_inline__)) static constexpr type signaling_NaN() noexcept {return type(0);}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return type(0);}
X    __attribute__ ((__always_inline__)) static constexpr type denorm_min() noexcept {return type(0);}
N
N    static _LIBCPP_CONSTEXPR const bool is_iec559 = false;
X    static constexpr const bool is_iec559 = false;
N    static _LIBCPP_CONSTEXPR const bool is_bounded = true;
X    static constexpr const bool is_bounded = true;
N    static _LIBCPP_CONSTEXPR const bool is_modulo = !_VSTD::is_signed<_Tp>::value;
X    static constexpr const bool is_modulo = !std::__2::is_signed<_Tp>::value;
N
N#if defined(__i386__) || defined(__x86_64__) || defined(__pnacl__) || \
N    defined(__wasm__)
X#if 0L || 0L || 0L ||     0L
S    static _LIBCPP_CONSTEXPR const bool traps = true;
N#else
N    static _LIBCPP_CONSTEXPR const bool traps = false;
X    static constexpr const bool traps = false;
N#endif
N    static _LIBCPP_CONSTEXPR const bool tinyness_before = false;
X    static constexpr const bool tinyness_before = false;
N    static _LIBCPP_CONSTEXPR const float_round_style round_style = round_toward_zero;
X    static constexpr const float_round_style round_style = round_toward_zero;
N};
N
Ntemplate <>
Nclass __libcpp_numeric_limits<bool, true>
N{
Nprotected:
N    typedef bool type;
N
N    static _LIBCPP_CONSTEXPR const bool is_specialized = true;
X    static constexpr const bool is_specialized = true;
N
N    static _LIBCPP_CONSTEXPR const bool is_signed = false;
X    static constexpr const bool is_signed = false;
N    static _LIBCPP_CONSTEXPR const int  digits = 1;
X    static constexpr const int  digits = 1;
N    static _LIBCPP_CONSTEXPR const int  digits10 = 0;
X    static constexpr const int  digits10 = 0;
N    static _LIBCPP_CONSTEXPR const int  max_digits10 = 0;
X    static constexpr const int  max_digits10 = 0;
N    static _LIBCPP_CONSTEXPR const type __min = false;
X    static constexpr const type __min = false;
N    static _LIBCPP_CONSTEXPR const type __max = true;
X    static constexpr const type __max = true;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type min() _NOEXCEPT {return __min;}
X    __attribute__ ((__always_inline__)) static constexpr type min() noexcept {return __min;}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type max() _NOEXCEPT {return __max;}
X    __attribute__ ((__always_inline__)) static constexpr type max() noexcept {return __max;}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type lowest() _NOEXCEPT {return min();}
X    __attribute__ ((__always_inline__)) static constexpr type lowest() noexcept {return min();}
N
N    static _LIBCPP_CONSTEXPR const bool is_integer = true;
X    static constexpr const bool is_integer = true;
N    static _LIBCPP_CONSTEXPR const bool is_exact = true;
X    static constexpr const bool is_exact = true;
N    static _LIBCPP_CONSTEXPR const int  radix = 2;
X    static constexpr const int  radix = 2;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type epsilon() _NOEXCEPT {return type(0);}
X    __attribute__ ((__always_inline__)) static constexpr type epsilon() noexcept {return type(0);}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type round_error() _NOEXCEPT {return type(0);}
X    __attribute__ ((__always_inline__)) static constexpr type round_error() noexcept {return type(0);}
N
N    static _LIBCPP_CONSTEXPR const int  min_exponent = 0;
X    static constexpr const int  min_exponent = 0;
N    static _LIBCPP_CONSTEXPR const int  min_exponent10 = 0;
X    static constexpr const int  min_exponent10 = 0;
N    static _LIBCPP_CONSTEXPR const int  max_exponent = 0;
X    static constexpr const int  max_exponent = 0;
N    static _LIBCPP_CONSTEXPR const int  max_exponent10 = 0;
X    static constexpr const int  max_exponent10 = 0;
N
N    static _LIBCPP_CONSTEXPR const bool has_infinity = false;
X    static constexpr const bool has_infinity = false;
N    static _LIBCPP_CONSTEXPR const bool has_quiet_NaN = false;
X    static constexpr const bool has_quiet_NaN = false;
N    static _LIBCPP_CONSTEXPR const bool has_signaling_NaN = false;
X    static constexpr const bool has_signaling_NaN = false;
N    static _LIBCPP_CONSTEXPR const float_denorm_style has_denorm = denorm_absent;
X    static constexpr const float_denorm_style has_denorm = denorm_absent;
N    static _LIBCPP_CONSTEXPR const bool has_denorm_loss = false;
X    static constexpr const bool has_denorm_loss = false;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type infinity() _NOEXCEPT {return type(0);}
X    __attribute__ ((__always_inline__)) static constexpr type infinity() noexcept {return type(0);}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return type(0);}
X    __attribute__ ((__always_inline__)) static constexpr type quiet_NaN() noexcept {return type(0);}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return type(0);}
X    __attribute__ ((__always_inline__)) static constexpr type signaling_NaN() noexcept {return type(0);}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return type(0);}
X    __attribute__ ((__always_inline__)) static constexpr type denorm_min() noexcept {return type(0);}
N
N    static _LIBCPP_CONSTEXPR const bool is_iec559 = false;
X    static constexpr const bool is_iec559 = false;
N    static _LIBCPP_CONSTEXPR const bool is_bounded = true;
X    static constexpr const bool is_bounded = true;
N    static _LIBCPP_CONSTEXPR const bool is_modulo = false;
X    static constexpr const bool is_modulo = false;
N
N    static _LIBCPP_CONSTEXPR const bool traps = false;
X    static constexpr const bool traps = false;
N    static _LIBCPP_CONSTEXPR const bool tinyness_before = false;
X    static constexpr const bool tinyness_before = false;
N    static _LIBCPP_CONSTEXPR const float_round_style round_style = round_toward_zero;
X    static constexpr const float_round_style round_style = round_toward_zero;
N};
N
Ntemplate <>
Nclass __libcpp_numeric_limits<float, true>
N{
Nprotected:
N    typedef float type;
N
N    static _LIBCPP_CONSTEXPR const bool is_specialized = true;
X    static constexpr const bool is_specialized = true;
N
N    static _LIBCPP_CONSTEXPR const bool is_signed = true;
X    static constexpr const bool is_signed = true;
N    static _LIBCPP_CONSTEXPR const int  digits = __FLT_MANT_DIG__;
X    static constexpr const int  digits = 24;
N    static _LIBCPP_CONSTEXPR const int  digits10 = __FLT_DIG__;
X    static constexpr const int  digits10 = 6;
N    static _LIBCPP_CONSTEXPR const int  max_digits10 = 2+(digits * 30103l)/100000l;
X    static constexpr const int  max_digits10 = 2+(digits * 30103l)/100000l;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type min() _NOEXCEPT {return __FLT_MIN__;}
X    __attribute__ ((__always_inline__)) static constexpr type min() noexcept {return 1.175494351E-38F;}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type max() _NOEXCEPT {return __FLT_MAX__;}
X    __attribute__ ((__always_inline__)) static constexpr type max() noexcept {return 3.402823466E+38F;}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type lowest() _NOEXCEPT {return -max();}
X    __attribute__ ((__always_inline__)) static constexpr type lowest() noexcept {return -max();}
N
N    static _LIBCPP_CONSTEXPR const bool is_integer = false;
X    static constexpr const bool is_integer = false;
N    static _LIBCPP_CONSTEXPR const bool is_exact = false;
X    static constexpr const bool is_exact = false;
N    static _LIBCPP_CONSTEXPR const int  radix = __FLT_RADIX__;
X    static constexpr const int  radix = 2;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type epsilon() _NOEXCEPT {return __FLT_EPSILON__;}
X    __attribute__ ((__always_inline__)) static constexpr type epsilon() noexcept {return 1.192092896E-07F;}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type round_error() _NOEXCEPT {return 0.5F;}
X    __attribute__ ((__always_inline__)) static constexpr type round_error() noexcept {return 0.5F;}
N
N    static _LIBCPP_CONSTEXPR const int  min_exponent = __FLT_MIN_EXP__;
X    static constexpr const int  min_exponent = (-125);
N    static _LIBCPP_CONSTEXPR const int  min_exponent10 = __FLT_MIN_10_EXP__;
X    static constexpr const int  min_exponent10 = (-37);
N    static _LIBCPP_CONSTEXPR const int  max_exponent = __FLT_MAX_EXP__;
X    static constexpr const int  max_exponent = 128;
N    static _LIBCPP_CONSTEXPR const int  max_exponent10 = __FLT_MAX_10_EXP__;
X    static constexpr const int  max_exponent10 = 38;
N
N    static _LIBCPP_CONSTEXPR const bool has_infinity = true;
X    static constexpr const bool has_infinity = true;
N    static _LIBCPP_CONSTEXPR const bool has_quiet_NaN = true;
X    static constexpr const bool has_quiet_NaN = true;
N    static _LIBCPP_CONSTEXPR const bool has_signaling_NaN = false;
X    static constexpr const bool has_signaling_NaN = false;
N    static _LIBCPP_CONSTEXPR const float_denorm_style has_denorm = denorm_absent;
X    static constexpr const float_denorm_style has_denorm = denorm_absent;
N    static _LIBCPP_CONSTEXPR const bool has_denorm_loss = false;
X    static constexpr const bool has_denorm_loss = false;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type infinity() _NOEXCEPT {return __builtin_huge_valf();}
X    __attribute__ ((__always_inline__)) static constexpr type infinity() noexcept {return __builtin_huge_valf();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return __builtin_nanf("");}
X    __attribute__ ((__always_inline__)) static constexpr type quiet_NaN() noexcept {return __builtin_nanf("");}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return __builtin_nansf("");}
X    __attribute__ ((__always_inline__)) static constexpr type signaling_NaN() noexcept {return __builtin_nansf("");}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return has_denorm == denorm_absent ? min() : __FLT_DENORM_MIN__;}
X    __attribute__ ((__always_inline__)) static constexpr type denorm_min() noexcept {return has_denorm == denorm_absent ? min() : (0.0f);}
N
N    static _LIBCPP_CONSTEXPR const bool is_iec559 = false; // Because has_signaling_NaN is false
X    static constexpr const bool is_iec559 = false; 
N    static _LIBCPP_CONSTEXPR const bool is_bounded = true;
X    static constexpr const bool is_bounded = true;
N    static _LIBCPP_CONSTEXPR const bool is_modulo = false;
X    static constexpr const bool is_modulo = false;
N
N    static _LIBCPP_CONSTEXPR const bool traps = false;
X    static constexpr const bool traps = false;
N    static _LIBCPP_CONSTEXPR const bool tinyness_before = false;
X    static constexpr const bool tinyness_before = false;
N    static _LIBCPP_CONSTEXPR const float_round_style round_style = round_to_nearest;
X    static constexpr const float_round_style round_style = round_to_nearest;
N};
N
Ntemplate <>
Nclass __libcpp_numeric_limits<double, true>
N{
Nprotected:
N    typedef double type;
N
N    static _LIBCPP_CONSTEXPR const bool is_specialized = true;
X    static constexpr const bool is_specialized = true;
N
N    static _LIBCPP_CONSTEXPR const bool is_signed = true;
X    static constexpr const bool is_signed = true;
N    static _LIBCPP_CONSTEXPR const int  digits = __DBL_MANT_DIG__;
X    static constexpr const int  digits = 53;
N    static _LIBCPP_CONSTEXPR const int  digits10 = __DBL_DIG__;
X    static constexpr const int  digits10 = 15;
N    static _LIBCPP_CONSTEXPR const int  max_digits10 = 2+(digits * 30103l)/100000l;
X    static constexpr const int  max_digits10 = 2+(digits * 30103l)/100000l;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type min() _NOEXCEPT {return __DBL_MIN__;}
X    __attribute__ ((__always_inline__)) static constexpr type min() noexcept {return 2.2250738585072014E-308;}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type max() _NOEXCEPT {return __DBL_MAX__;}
X    __attribute__ ((__always_inline__)) static constexpr type max() noexcept {return 1.7976931348623157E+308;}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type lowest() _NOEXCEPT {return -max();}
X    __attribute__ ((__always_inline__)) static constexpr type lowest() noexcept {return -max();}
N
N    static _LIBCPP_CONSTEXPR const bool is_integer = false;
X    static constexpr const bool is_integer = false;
N    static _LIBCPP_CONSTEXPR const bool is_exact = false;
X    static constexpr const bool is_exact = false;
N    static _LIBCPP_CONSTEXPR const int  radix = __FLT_RADIX__;
X    static constexpr const int  radix = 2;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type epsilon() _NOEXCEPT {return __DBL_EPSILON__;}
X    __attribute__ ((__always_inline__)) static constexpr type epsilon() noexcept {return 2.2204460492503131E-16;}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type round_error() _NOEXCEPT {return 0.5;}
X    __attribute__ ((__always_inline__)) static constexpr type round_error() noexcept {return 0.5;}
N
N    static _LIBCPP_CONSTEXPR const int  min_exponent = __DBL_MIN_EXP__;
X    static constexpr const int  min_exponent = (-1021);
N    static _LIBCPP_CONSTEXPR const int  min_exponent10 = __DBL_MIN_10_EXP__;
X    static constexpr const int  min_exponent10 = (-307);
N    static _LIBCPP_CONSTEXPR const int  max_exponent = __DBL_MAX_EXP__;
X    static constexpr const int  max_exponent = 1024;
N    static _LIBCPP_CONSTEXPR const int  max_exponent10 = __DBL_MAX_10_EXP__;
X    static constexpr const int  max_exponent10 = 308;
N
N    static _LIBCPP_CONSTEXPR const bool has_infinity = true;
X    static constexpr const bool has_infinity = true;
N    static _LIBCPP_CONSTEXPR const bool has_quiet_NaN = true;
X    static constexpr const bool has_quiet_NaN = true;
N    static _LIBCPP_CONSTEXPR const bool has_signaling_NaN = false;
X    static constexpr const bool has_signaling_NaN = false;
N    static _LIBCPP_CONSTEXPR const float_denorm_style has_denorm = denorm_absent;
X    static constexpr const float_denorm_style has_denorm = denorm_absent;
N    static _LIBCPP_CONSTEXPR const bool has_denorm_loss = false;
X    static constexpr const bool has_denorm_loss = false;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type infinity() _NOEXCEPT {return __builtin_huge_val();}
X    __attribute__ ((__always_inline__)) static constexpr type infinity() noexcept {return __builtin_huge_val();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return __builtin_nan("");}
X    __attribute__ ((__always_inline__)) static constexpr type quiet_NaN() noexcept {return __builtin_nan("");}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return __builtin_nans("");}
X    __attribute__ ((__always_inline__)) static constexpr type signaling_NaN() noexcept {return __builtin_nans("");}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return has_denorm == denorm_absent ? min() : __DBL_DENORM_MIN__;}
X    __attribute__ ((__always_inline__)) static constexpr type denorm_min() noexcept {return has_denorm == denorm_absent ? min() : (0.0);}
N
N    static _LIBCPP_CONSTEXPR const bool is_iec559 = false; // Because has_signaling_NaN is false
X    static constexpr const bool is_iec559 = false; 
N    static _LIBCPP_CONSTEXPR const bool is_bounded = true;
X    static constexpr const bool is_bounded = true;
N    static _LIBCPP_CONSTEXPR const bool is_modulo = false;
X    static constexpr const bool is_modulo = false;
N
N    static _LIBCPP_CONSTEXPR const bool traps = false;
X    static constexpr const bool traps = false;
N    static _LIBCPP_CONSTEXPR const bool tinyness_before = false;
X    static constexpr const bool tinyness_before = false;
N    static _LIBCPP_CONSTEXPR const float_round_style round_style = round_to_nearest;
X    static constexpr const float_round_style round_style = round_to_nearest;
N};
N
Ntemplate <>
Nclass __libcpp_numeric_limits<long double, true>
N{
Nprotected:
N    typedef long double type;
N
N    static _LIBCPP_CONSTEXPR const bool is_specialized = true;
X    static constexpr const bool is_specialized = true;
N
N    static _LIBCPP_CONSTEXPR const bool is_signed = true;
X    static constexpr const bool is_signed = true;
N    static _LIBCPP_CONSTEXPR const int  digits = __LDBL_MANT_DIG__;
X    static constexpr const int  digits = 53;
N    static _LIBCPP_CONSTEXPR const int  digits10 = __LDBL_DIG__;
X    static constexpr const int  digits10 = 15;
N    static _LIBCPP_CONSTEXPR const int  max_digits10 = 2+(digits * 30103l)/100000l;
X    static constexpr const int  max_digits10 = 2+(digits * 30103l)/100000l;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type min() _NOEXCEPT {return __LDBL_MIN__;}
X    __attribute__ ((__always_inline__)) static constexpr type min() noexcept {return 2.2250738585072014E-308L;}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type max() _NOEXCEPT {return __LDBL_MAX__;}
X    __attribute__ ((__always_inline__)) static constexpr type max() noexcept {return 1.7976931348623157E+308L;}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type lowest() _NOEXCEPT {return -max();}
X    __attribute__ ((__always_inline__)) static constexpr type lowest() noexcept {return -max();}
N
N    static _LIBCPP_CONSTEXPR const bool is_integer = false;
X    static constexpr const bool is_integer = false;
N    static _LIBCPP_CONSTEXPR const bool is_exact = false;
X    static constexpr const bool is_exact = false;
N    static _LIBCPP_CONSTEXPR const int  radix = __FLT_RADIX__;
X    static constexpr const int  radix = 2;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type epsilon() _NOEXCEPT {return __LDBL_EPSILON__;}
X    __attribute__ ((__always_inline__)) static constexpr type epsilon() noexcept {return 2.2204460492503131E-16L;}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type round_error() _NOEXCEPT {return 0.5;}
X    __attribute__ ((__always_inline__)) static constexpr type round_error() noexcept {return 0.5;}
N
N    static _LIBCPP_CONSTEXPR const int  min_exponent = __LDBL_MIN_EXP__;
X    static constexpr const int  min_exponent = (-1021);
N    static _LIBCPP_CONSTEXPR const int  min_exponent10 = __LDBL_MIN_10_EXP__;
X    static constexpr const int  min_exponent10 = (-307);
N    static _LIBCPP_CONSTEXPR const int  max_exponent = __LDBL_MAX_EXP__;
X    static constexpr const int  max_exponent = 1024;
N    static _LIBCPP_CONSTEXPR const int  max_exponent10 = __LDBL_MAX_10_EXP__;
X    static constexpr const int  max_exponent10 = 308;
N
N    static _LIBCPP_CONSTEXPR const bool has_infinity = true;
X    static constexpr const bool has_infinity = true;
N    static _LIBCPP_CONSTEXPR const bool has_quiet_NaN = true;
X    static constexpr const bool has_quiet_NaN = true;
N    static _LIBCPP_CONSTEXPR const bool has_signaling_NaN = false;
X    static constexpr const bool has_signaling_NaN = false;
N    static _LIBCPP_CONSTEXPR const float_denorm_style has_denorm = denorm_absent;
X    static constexpr const float_denorm_style has_denorm = denorm_absent;
N    static _LIBCPP_CONSTEXPR const bool has_denorm_loss = false;
X    static constexpr const bool has_denorm_loss = false;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type infinity() _NOEXCEPT {return __builtin_huge_vall();}
X    __attribute__ ((__always_inline__)) static constexpr type infinity() noexcept {return __builtin_huge_vall();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return __builtin_nanl("");}
X    __attribute__ ((__always_inline__)) static constexpr type quiet_NaN() noexcept {return __builtin_nanl("");}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return __builtin_nansl("");}
X    __attribute__ ((__always_inline__)) static constexpr type signaling_NaN() noexcept {return __builtin_nansl("");}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return has_denorm == denorm_absent ? min() : __LDBL_DENORM_MIN__;}
X    __attribute__ ((__always_inline__)) static constexpr type denorm_min() noexcept {return has_denorm == denorm_absent ? min() : (0.0l);}
N
N#if (defined(__ppc__) || defined(__ppc64__))
X#if (0L || 0L)
S    static _LIBCPP_CONSTEXPR const bool is_iec559 = false;
N#else
N    static _LIBCPP_CONSTEXPR const bool is_iec559 = false; // Because has_signaling_NaN is false
X    static constexpr const bool is_iec559 = false; 
N#endif
N    static _LIBCPP_CONSTEXPR const bool is_bounded = true;
X    static constexpr const bool is_bounded = true;
N    static _LIBCPP_CONSTEXPR const bool is_modulo = false;
X    static constexpr const bool is_modulo = false;
N
N    static _LIBCPP_CONSTEXPR const bool traps = false;
X    static constexpr const bool traps = false;
N    static _LIBCPP_CONSTEXPR const bool tinyness_before = false;
X    static constexpr const bool tinyness_before = false;
N    static _LIBCPP_CONSTEXPR const float_round_style round_style = round_to_nearest;
X    static constexpr const float_round_style round_style = round_to_nearest;
N};
N
Ntemplate <class _Tp>
Nclass _LIBCPP_TEMPLATE_VIS numeric_limits
Xclass  numeric_limits
N    : private __libcpp_numeric_limits<typename remove_cv<_Tp>::type>
N{
N    typedef __libcpp_numeric_limits<typename remove_cv<_Tp>::type> __base;
N    typedef typename __base::type type;
Npublic:
N    static _LIBCPP_CONSTEXPR const bool is_specialized = __base::is_specialized;
X    static constexpr const bool is_specialized = __base::is_specialized;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type min() _NOEXCEPT {return __base::min();}
X    __attribute__ ((__always_inline__)) static constexpr type min() noexcept {return __base::min();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type max() _NOEXCEPT {return __base::max();}
X    __attribute__ ((__always_inline__)) static constexpr type max() noexcept {return __base::max();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type lowest() _NOEXCEPT {return __base::lowest();}
X    __attribute__ ((__always_inline__)) static constexpr type lowest() noexcept {return __base::lowest();}
N
N    static _LIBCPP_CONSTEXPR const int  digits = __base::digits;
X    static constexpr const int  digits = __base::digits;
N    static _LIBCPP_CONSTEXPR const int  digits10 = __base::digits10;
X    static constexpr const int  digits10 = __base::digits10;
N    static _LIBCPP_CONSTEXPR const int  max_digits10 = __base::max_digits10;
X    static constexpr const int  max_digits10 = __base::max_digits10;
N    static _LIBCPP_CONSTEXPR const bool is_signed = __base::is_signed;
X    static constexpr const bool is_signed = __base::is_signed;
N    static _LIBCPP_CONSTEXPR const bool is_integer = __base::is_integer;
X    static constexpr const bool is_integer = __base::is_integer;
N    static _LIBCPP_CONSTEXPR const bool is_exact = __base::is_exact;
X    static constexpr const bool is_exact = __base::is_exact;
N    static _LIBCPP_CONSTEXPR const int  radix = __base::radix;
X    static constexpr const int  radix = __base::radix;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type epsilon() _NOEXCEPT {return __base::epsilon();}
X    __attribute__ ((__always_inline__)) static constexpr type epsilon() noexcept {return __base::epsilon();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type round_error() _NOEXCEPT {return __base::round_error();}
X    __attribute__ ((__always_inline__)) static constexpr type round_error() noexcept {return __base::round_error();}
N
N    static _LIBCPP_CONSTEXPR const int  min_exponent = __base::min_exponent;
X    static constexpr const int  min_exponent = __base::min_exponent;
N    static _LIBCPP_CONSTEXPR const int  min_exponent10 = __base::min_exponent10;
X    static constexpr const int  min_exponent10 = __base::min_exponent10;
N    static _LIBCPP_CONSTEXPR const int  max_exponent = __base::max_exponent;
X    static constexpr const int  max_exponent = __base::max_exponent;
N    static _LIBCPP_CONSTEXPR const int  max_exponent10 = __base::max_exponent10;
X    static constexpr const int  max_exponent10 = __base::max_exponent10;
N
N    static _LIBCPP_CONSTEXPR const bool has_infinity = __base::has_infinity;
X    static constexpr const bool has_infinity = __base::has_infinity;
N    static _LIBCPP_CONSTEXPR const bool has_quiet_NaN = __base::has_quiet_NaN;
X    static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
N    static _LIBCPP_CONSTEXPR const bool has_signaling_NaN = __base::has_signaling_NaN;
X    static constexpr const bool has_signaling_NaN = __base::has_signaling_NaN;
N    static _LIBCPP_CONSTEXPR const float_denorm_style has_denorm = __base::has_denorm;
X    static constexpr const float_denorm_style has_denorm = __base::has_denorm;
N    static _LIBCPP_CONSTEXPR const bool has_denorm_loss = __base::has_denorm_loss;
X    static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type infinity() _NOEXCEPT {return __base::infinity();}
X    __attribute__ ((__always_inline__)) static constexpr type infinity() noexcept {return __base::infinity();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return __base::quiet_NaN();}
X    __attribute__ ((__always_inline__)) static constexpr type quiet_NaN() noexcept {return __base::quiet_NaN();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return __base::signaling_NaN();}
X    __attribute__ ((__always_inline__)) static constexpr type signaling_NaN() noexcept {return __base::signaling_NaN();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return __base::denorm_min();}
X    __attribute__ ((__always_inline__)) static constexpr type denorm_min() noexcept {return __base::denorm_min();}
N
N    static _LIBCPP_CONSTEXPR const bool is_iec559 = __base::is_iec559;
X    static constexpr const bool is_iec559 = __base::is_iec559;
N    static _LIBCPP_CONSTEXPR const bool is_bounded = __base::is_bounded;
X    static constexpr const bool is_bounded = __base::is_bounded;
N    static _LIBCPP_CONSTEXPR const bool is_modulo = __base::is_modulo;
X    static constexpr const bool is_modulo = __base::is_modulo;
N
N    static _LIBCPP_CONSTEXPR const bool traps = __base::traps;
X    static constexpr const bool traps = __base::traps;
N    static _LIBCPP_CONSTEXPR const bool tinyness_before = __base::tinyness_before;
X    static constexpr const bool tinyness_before = __base::tinyness_before;
N    static _LIBCPP_CONSTEXPR const float_round_style round_style = __base::round_style;
X    static constexpr const float_round_style round_style = __base::round_style;
N};
N
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::is_specialized;
X    constexpr const bool numeric_limits<_Tp>::is_specialized;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<_Tp>::digits;
X    constexpr const int numeric_limits<_Tp>::digits;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<_Tp>::digits10;
X    constexpr const int numeric_limits<_Tp>::digits10;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<_Tp>::max_digits10;
X    constexpr const int numeric_limits<_Tp>::max_digits10;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::is_signed;
X    constexpr const bool numeric_limits<_Tp>::is_signed;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::is_integer;
X    constexpr const bool numeric_limits<_Tp>::is_integer;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::is_exact;
X    constexpr const bool numeric_limits<_Tp>::is_exact;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<_Tp>::radix;
X    constexpr const int numeric_limits<_Tp>::radix;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<_Tp>::min_exponent;
X    constexpr const int numeric_limits<_Tp>::min_exponent;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<_Tp>::min_exponent10;
X    constexpr const int numeric_limits<_Tp>::min_exponent10;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<_Tp>::max_exponent;
X    constexpr const int numeric_limits<_Tp>::max_exponent;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<_Tp>::max_exponent10;
X    constexpr const int numeric_limits<_Tp>::max_exponent10;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::has_infinity;
X    constexpr const bool numeric_limits<_Tp>::has_infinity;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::has_quiet_NaN;
X    constexpr const bool numeric_limits<_Tp>::has_quiet_NaN;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::has_signaling_NaN;
X    constexpr const bool numeric_limits<_Tp>::has_signaling_NaN;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const float_denorm_style numeric_limits<_Tp>::has_denorm;
X    constexpr const float_denorm_style numeric_limits<_Tp>::has_denorm;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::has_denorm_loss;
X    constexpr const bool numeric_limits<_Tp>::has_denorm_loss;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::is_iec559;
X    constexpr const bool numeric_limits<_Tp>::is_iec559;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::is_bounded;
X    constexpr const bool numeric_limits<_Tp>::is_bounded;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::is_modulo;
X    constexpr const bool numeric_limits<_Tp>::is_modulo;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::traps;
X    constexpr const bool numeric_limits<_Tp>::traps;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::tinyness_before;
X    constexpr const bool numeric_limits<_Tp>::tinyness_before;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const float_round_style numeric_limits<_Tp>::round_style;
X    constexpr const float_round_style numeric_limits<_Tp>::round_style;
N
Ntemplate <class _Tp>
Nclass _LIBCPP_TEMPLATE_VIS numeric_limits<const _Tp>
Xclass  numeric_limits<const _Tp>
N    : private numeric_limits<_Tp>
N{
N    typedef numeric_limits<_Tp> __base;
N    typedef _Tp type;
Npublic:
N    static _LIBCPP_CONSTEXPR const bool is_specialized = __base::is_specialized;
X    static constexpr const bool is_specialized = __base::is_specialized;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type min() _NOEXCEPT {return __base::min();}
X    __attribute__ ((__always_inline__)) static constexpr type min() noexcept {return __base::min();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type max() _NOEXCEPT {return __base::max();}
X    __attribute__ ((__always_inline__)) static constexpr type max() noexcept {return __base::max();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type lowest() _NOEXCEPT {return __base::lowest();}
X    __attribute__ ((__always_inline__)) static constexpr type lowest() noexcept {return __base::lowest();}
N
N    static _LIBCPP_CONSTEXPR const int  digits = __base::digits;
X    static constexpr const int  digits = __base::digits;
N    static _LIBCPP_CONSTEXPR const int  digits10 = __base::digits10;
X    static constexpr const int  digits10 = __base::digits10;
N    static _LIBCPP_CONSTEXPR const int  max_digits10 = __base::max_digits10;
X    static constexpr const int  max_digits10 = __base::max_digits10;
N    static _LIBCPP_CONSTEXPR const bool is_signed = __base::is_signed;
X    static constexpr const bool is_signed = __base::is_signed;
N    static _LIBCPP_CONSTEXPR const bool is_integer = __base::is_integer;
X    static constexpr const bool is_integer = __base::is_integer;
N    static _LIBCPP_CONSTEXPR const bool is_exact = __base::is_exact;
X    static constexpr const bool is_exact = __base::is_exact;
N    static _LIBCPP_CONSTEXPR const int  radix = __base::radix;
X    static constexpr const int  radix = __base::radix;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type epsilon() _NOEXCEPT {return __base::epsilon();}
X    __attribute__ ((__always_inline__)) static constexpr type epsilon() noexcept {return __base::epsilon();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type round_error() _NOEXCEPT {return __base::round_error();}
X    __attribute__ ((__always_inline__)) static constexpr type round_error() noexcept {return __base::round_error();}
N
N    static _LIBCPP_CONSTEXPR const int  min_exponent = __base::min_exponent;
X    static constexpr const int  min_exponent = __base::min_exponent;
N    static _LIBCPP_CONSTEXPR const int  min_exponent10 = __base::min_exponent10;
X    static constexpr const int  min_exponent10 = __base::min_exponent10;
N    static _LIBCPP_CONSTEXPR const int  max_exponent = __base::max_exponent;
X    static constexpr const int  max_exponent = __base::max_exponent;
N    static _LIBCPP_CONSTEXPR const int  max_exponent10 = __base::max_exponent10;
X    static constexpr const int  max_exponent10 = __base::max_exponent10;
N
N    static _LIBCPP_CONSTEXPR const bool has_infinity = __base::has_infinity;
X    static constexpr const bool has_infinity = __base::has_infinity;
N    static _LIBCPP_CONSTEXPR const bool has_quiet_NaN = __base::has_quiet_NaN;
X    static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
N    static _LIBCPP_CONSTEXPR const bool has_signaling_NaN = __base::has_signaling_NaN;
X    static constexpr const bool has_signaling_NaN = __base::has_signaling_NaN;
N    static _LIBCPP_CONSTEXPR const float_denorm_style has_denorm = __base::has_denorm;
X    static constexpr const float_denorm_style has_denorm = __base::has_denorm;
N    static _LIBCPP_CONSTEXPR const bool has_denorm_loss = __base::has_denorm_loss;
X    static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type infinity() _NOEXCEPT {return __base::infinity();}
X    __attribute__ ((__always_inline__)) static constexpr type infinity() noexcept {return __base::infinity();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return __base::quiet_NaN();}
X    __attribute__ ((__always_inline__)) static constexpr type quiet_NaN() noexcept {return __base::quiet_NaN();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return __base::signaling_NaN();}
X    __attribute__ ((__always_inline__)) static constexpr type signaling_NaN() noexcept {return __base::signaling_NaN();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return __base::denorm_min();}
X    __attribute__ ((__always_inline__)) static constexpr type denorm_min() noexcept {return __base::denorm_min();}
N
N    static _LIBCPP_CONSTEXPR const bool is_iec559 = __base::is_iec559;
X    static constexpr const bool is_iec559 = __base::is_iec559;
N    static _LIBCPP_CONSTEXPR const bool is_bounded = __base::is_bounded;
X    static constexpr const bool is_bounded = __base::is_bounded;
N    static _LIBCPP_CONSTEXPR const bool is_modulo = __base::is_modulo;
X    static constexpr const bool is_modulo = __base::is_modulo;
N
N    static _LIBCPP_CONSTEXPR const bool traps = __base::traps;
X    static constexpr const bool traps = __base::traps;
N    static _LIBCPP_CONSTEXPR const bool tinyness_before = __base::tinyness_before;
X    static constexpr const bool tinyness_before = __base::tinyness_before;
N    static _LIBCPP_CONSTEXPR const float_round_style round_style = __base::round_style;
X    static constexpr const float_round_style round_style = __base::round_style;
N};
N
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::is_specialized;
X    constexpr const bool numeric_limits<const _Tp>::is_specialized;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<const _Tp>::digits;
X    constexpr const int numeric_limits<const _Tp>::digits;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<const _Tp>::digits10;
X    constexpr const int numeric_limits<const _Tp>::digits10;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<const _Tp>::max_digits10;
X    constexpr const int numeric_limits<const _Tp>::max_digits10;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::is_signed;
X    constexpr const bool numeric_limits<const _Tp>::is_signed;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::is_integer;
X    constexpr const bool numeric_limits<const _Tp>::is_integer;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::is_exact;
X    constexpr const bool numeric_limits<const _Tp>::is_exact;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<const _Tp>::radix;
X    constexpr const int numeric_limits<const _Tp>::radix;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<const _Tp>::min_exponent;
X    constexpr const int numeric_limits<const _Tp>::min_exponent;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<const _Tp>::min_exponent10;
X    constexpr const int numeric_limits<const _Tp>::min_exponent10;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<const _Tp>::max_exponent;
X    constexpr const int numeric_limits<const _Tp>::max_exponent;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<const _Tp>::max_exponent10;
X    constexpr const int numeric_limits<const _Tp>::max_exponent10;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::has_infinity;
X    constexpr const bool numeric_limits<const _Tp>::has_infinity;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::has_quiet_NaN;
X    constexpr const bool numeric_limits<const _Tp>::has_quiet_NaN;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::has_signaling_NaN;
X    constexpr const bool numeric_limits<const _Tp>::has_signaling_NaN;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const float_denorm_style numeric_limits<const _Tp>::has_denorm;
X    constexpr const float_denorm_style numeric_limits<const _Tp>::has_denorm;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::has_denorm_loss;
X    constexpr const bool numeric_limits<const _Tp>::has_denorm_loss;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::is_iec559;
X    constexpr const bool numeric_limits<const _Tp>::is_iec559;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::is_bounded;
X    constexpr const bool numeric_limits<const _Tp>::is_bounded;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::is_modulo;
X    constexpr const bool numeric_limits<const _Tp>::is_modulo;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::traps;
X    constexpr const bool numeric_limits<const _Tp>::traps;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::tinyness_before;
X    constexpr const bool numeric_limits<const _Tp>::tinyness_before;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const float_round_style numeric_limits<const _Tp>::round_style;
X    constexpr const float_round_style numeric_limits<const _Tp>::round_style;
N
Ntemplate <class _Tp>
Nclass _LIBCPP_TEMPLATE_VIS numeric_limits<volatile _Tp>
Xclass  numeric_limits<volatile _Tp>
N    : private numeric_limits<_Tp>
N{
N    typedef numeric_limits<_Tp> __base;
N    typedef _Tp type;
Npublic:
N    static _LIBCPP_CONSTEXPR const bool is_specialized = __base::is_specialized;
X    static constexpr const bool is_specialized = __base::is_specialized;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type min() _NOEXCEPT {return __base::min();}
X    __attribute__ ((__always_inline__)) static constexpr type min() noexcept {return __base::min();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type max() _NOEXCEPT {return __base::max();}
X    __attribute__ ((__always_inline__)) static constexpr type max() noexcept {return __base::max();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type lowest() _NOEXCEPT {return __base::lowest();}
X    __attribute__ ((__always_inline__)) static constexpr type lowest() noexcept {return __base::lowest();}
N
N    static _LIBCPP_CONSTEXPR const int  digits = __base::digits;
X    static constexpr const int  digits = __base::digits;
N    static _LIBCPP_CONSTEXPR const int  digits10 = __base::digits10;
X    static constexpr const int  digits10 = __base::digits10;
N    static _LIBCPP_CONSTEXPR const int  max_digits10 = __base::max_digits10;
X    static constexpr const int  max_digits10 = __base::max_digits10;
N    static _LIBCPP_CONSTEXPR const bool is_signed = __base::is_signed;
X    static constexpr const bool is_signed = __base::is_signed;
N    static _LIBCPP_CONSTEXPR const bool is_integer = __base::is_integer;
X    static constexpr const bool is_integer = __base::is_integer;
N    static _LIBCPP_CONSTEXPR const bool is_exact = __base::is_exact;
X    static constexpr const bool is_exact = __base::is_exact;
N    static _LIBCPP_CONSTEXPR const int  radix = __base::radix;
X    static constexpr const int  radix = __base::radix;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type epsilon() _NOEXCEPT {return __base::epsilon();}
X    __attribute__ ((__always_inline__)) static constexpr type epsilon() noexcept {return __base::epsilon();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type round_error() _NOEXCEPT {return __base::round_error();}
X    __attribute__ ((__always_inline__)) static constexpr type round_error() noexcept {return __base::round_error();}
N
N    static _LIBCPP_CONSTEXPR const int  min_exponent = __base::min_exponent;
X    static constexpr const int  min_exponent = __base::min_exponent;
N    static _LIBCPP_CONSTEXPR const int  min_exponent10 = __base::min_exponent10;
X    static constexpr const int  min_exponent10 = __base::min_exponent10;
N    static _LIBCPP_CONSTEXPR const int  max_exponent = __base::max_exponent;
X    static constexpr const int  max_exponent = __base::max_exponent;
N    static _LIBCPP_CONSTEXPR const int  max_exponent10 = __base::max_exponent10;
X    static constexpr const int  max_exponent10 = __base::max_exponent10;
N
N    static _LIBCPP_CONSTEXPR const bool has_infinity = __base::has_infinity;
X    static constexpr const bool has_infinity = __base::has_infinity;
N    static _LIBCPP_CONSTEXPR const bool has_quiet_NaN = __base::has_quiet_NaN;
X    static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
N    static _LIBCPP_CONSTEXPR const bool has_signaling_NaN = __base::has_signaling_NaN;
X    static constexpr const bool has_signaling_NaN = __base::has_signaling_NaN;
N    static _LIBCPP_CONSTEXPR const float_denorm_style has_denorm = __base::has_denorm;
X    static constexpr const float_denorm_style has_denorm = __base::has_denorm;
N    static _LIBCPP_CONSTEXPR const bool has_denorm_loss = __base::has_denorm_loss;
X    static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type infinity() _NOEXCEPT {return __base::infinity();}
X    __attribute__ ((__always_inline__)) static constexpr type infinity() noexcept {return __base::infinity();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return __base::quiet_NaN();}
X    __attribute__ ((__always_inline__)) static constexpr type quiet_NaN() noexcept {return __base::quiet_NaN();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return __base::signaling_NaN();}
X    __attribute__ ((__always_inline__)) static constexpr type signaling_NaN() noexcept {return __base::signaling_NaN();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return __base::denorm_min();}
X    __attribute__ ((__always_inline__)) static constexpr type denorm_min() noexcept {return __base::denorm_min();}
N
N    static _LIBCPP_CONSTEXPR const bool is_iec559 = __base::is_iec559;
X    static constexpr const bool is_iec559 = __base::is_iec559;
N    static _LIBCPP_CONSTEXPR const bool is_bounded = __base::is_bounded;
X    static constexpr const bool is_bounded = __base::is_bounded;
N    static _LIBCPP_CONSTEXPR const bool is_modulo = __base::is_modulo;
X    static constexpr const bool is_modulo = __base::is_modulo;
N
N    static _LIBCPP_CONSTEXPR const bool traps = __base::traps;
X    static constexpr const bool traps = __base::traps;
N    static _LIBCPP_CONSTEXPR const bool tinyness_before = __base::tinyness_before;
X    static constexpr const bool tinyness_before = __base::tinyness_before;
N    static _LIBCPP_CONSTEXPR const float_round_style round_style = __base::round_style;
X    static constexpr const float_round_style round_style = __base::round_style;
N};
N
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::is_specialized;
X    constexpr const bool numeric_limits<volatile _Tp>::is_specialized;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<volatile _Tp>::digits;
X    constexpr const int numeric_limits<volatile _Tp>::digits;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<volatile _Tp>::digits10;
X    constexpr const int numeric_limits<volatile _Tp>::digits10;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<volatile _Tp>::max_digits10;
X    constexpr const int numeric_limits<volatile _Tp>::max_digits10;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::is_signed;
X    constexpr const bool numeric_limits<volatile _Tp>::is_signed;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::is_integer;
X    constexpr const bool numeric_limits<volatile _Tp>::is_integer;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::is_exact;
X    constexpr const bool numeric_limits<volatile _Tp>::is_exact;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<volatile _Tp>::radix;
X    constexpr const int numeric_limits<volatile _Tp>::radix;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<volatile _Tp>::min_exponent;
X    constexpr const int numeric_limits<volatile _Tp>::min_exponent;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<volatile _Tp>::min_exponent10;
X    constexpr const int numeric_limits<volatile _Tp>::min_exponent10;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<volatile _Tp>::max_exponent;
X    constexpr const int numeric_limits<volatile _Tp>::max_exponent;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<volatile _Tp>::max_exponent10;
X    constexpr const int numeric_limits<volatile _Tp>::max_exponent10;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::has_infinity;
X    constexpr const bool numeric_limits<volatile _Tp>::has_infinity;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::has_quiet_NaN;
X    constexpr const bool numeric_limits<volatile _Tp>::has_quiet_NaN;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::has_signaling_NaN;
X    constexpr const bool numeric_limits<volatile _Tp>::has_signaling_NaN;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const float_denorm_style numeric_limits<volatile _Tp>::has_denorm;
X    constexpr const float_denorm_style numeric_limits<volatile _Tp>::has_denorm;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::has_denorm_loss;
X    constexpr const bool numeric_limits<volatile _Tp>::has_denorm_loss;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::is_iec559;
X    constexpr const bool numeric_limits<volatile _Tp>::is_iec559;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::is_bounded;
X    constexpr const bool numeric_limits<volatile _Tp>::is_bounded;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::is_modulo;
X    constexpr const bool numeric_limits<volatile _Tp>::is_modulo;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::traps;
X    constexpr const bool numeric_limits<volatile _Tp>::traps;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::tinyness_before;
X    constexpr const bool numeric_limits<volatile _Tp>::tinyness_before;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const float_round_style numeric_limits<volatile _Tp>::round_style;
X    constexpr const float_round_style numeric_limits<volatile _Tp>::round_style;
N
Ntemplate <class _Tp>
Nclass _LIBCPP_TEMPLATE_VIS numeric_limits<const volatile _Tp>
Xclass  numeric_limits<const volatile _Tp>
N    : private numeric_limits<_Tp>
N{
N    typedef numeric_limits<_Tp> __base;
N    typedef _Tp type;
Npublic:
N    static _LIBCPP_CONSTEXPR const bool is_specialized = __base::is_specialized;
X    static constexpr const bool is_specialized = __base::is_specialized;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type min() _NOEXCEPT {return __base::min();}
X    __attribute__ ((__always_inline__)) static constexpr type min() noexcept {return __base::min();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type max() _NOEXCEPT {return __base::max();}
X    __attribute__ ((__always_inline__)) static constexpr type max() noexcept {return __base::max();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type lowest() _NOEXCEPT {return __base::lowest();}
X    __attribute__ ((__always_inline__)) static constexpr type lowest() noexcept {return __base::lowest();}
N
N    static _LIBCPP_CONSTEXPR const int  digits = __base::digits;
X    static constexpr const int  digits = __base::digits;
N    static _LIBCPP_CONSTEXPR const int  digits10 = __base::digits10;
X    static constexpr const int  digits10 = __base::digits10;
N    static _LIBCPP_CONSTEXPR const int  max_digits10 = __base::max_digits10;
X    static constexpr const int  max_digits10 = __base::max_digits10;
N    static _LIBCPP_CONSTEXPR const bool is_signed = __base::is_signed;
X    static constexpr const bool is_signed = __base::is_signed;
N    static _LIBCPP_CONSTEXPR const bool is_integer = __base::is_integer;
X    static constexpr const bool is_integer = __base::is_integer;
N    static _LIBCPP_CONSTEXPR const bool is_exact = __base::is_exact;
X    static constexpr const bool is_exact = __base::is_exact;
N    static _LIBCPP_CONSTEXPR const int  radix = __base::radix;
X    static constexpr const int  radix = __base::radix;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type epsilon() _NOEXCEPT {return __base::epsilon();}
X    __attribute__ ((__always_inline__)) static constexpr type epsilon() noexcept {return __base::epsilon();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type round_error() _NOEXCEPT {return __base::round_error();}
X    __attribute__ ((__always_inline__)) static constexpr type round_error() noexcept {return __base::round_error();}
N
N    static _LIBCPP_CONSTEXPR const int  min_exponent = __base::min_exponent;
X    static constexpr const int  min_exponent = __base::min_exponent;
N    static _LIBCPP_CONSTEXPR const int  min_exponent10 = __base::min_exponent10;
X    static constexpr const int  min_exponent10 = __base::min_exponent10;
N    static _LIBCPP_CONSTEXPR const int  max_exponent = __base::max_exponent;
X    static constexpr const int  max_exponent = __base::max_exponent;
N    static _LIBCPP_CONSTEXPR const int  max_exponent10 = __base::max_exponent10;
X    static constexpr const int  max_exponent10 = __base::max_exponent10;
N
N    static _LIBCPP_CONSTEXPR const bool has_infinity = __base::has_infinity;
X    static constexpr const bool has_infinity = __base::has_infinity;
N    static _LIBCPP_CONSTEXPR const bool has_quiet_NaN = __base::has_quiet_NaN;
X    static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
N    static _LIBCPP_CONSTEXPR const bool has_signaling_NaN = __base::has_signaling_NaN;
X    static constexpr const bool has_signaling_NaN = __base::has_signaling_NaN;
N    static _LIBCPP_CONSTEXPR const float_denorm_style has_denorm = __base::has_denorm;
X    static constexpr const float_denorm_style has_denorm = __base::has_denorm;
N    static _LIBCPP_CONSTEXPR const bool has_denorm_loss = __base::has_denorm_loss;
X    static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type infinity() _NOEXCEPT {return __base::infinity();}
X    __attribute__ ((__always_inline__)) static constexpr type infinity() noexcept {return __base::infinity();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return __base::quiet_NaN();}
X    __attribute__ ((__always_inline__)) static constexpr type quiet_NaN() noexcept {return __base::quiet_NaN();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return __base::signaling_NaN();}
X    __attribute__ ((__always_inline__)) static constexpr type signaling_NaN() noexcept {return __base::signaling_NaN();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return __base::denorm_min();}
X    __attribute__ ((__always_inline__)) static constexpr type denorm_min() noexcept {return __base::denorm_min();}
N
N    static _LIBCPP_CONSTEXPR const bool is_iec559 = __base::is_iec559;
X    static constexpr const bool is_iec559 = __base::is_iec559;
N    static _LIBCPP_CONSTEXPR const bool is_bounded = __base::is_bounded;
X    static constexpr const bool is_bounded = __base::is_bounded;
N    static _LIBCPP_CONSTEXPR const bool is_modulo = __base::is_modulo;
X    static constexpr const bool is_modulo = __base::is_modulo;
N
N    static _LIBCPP_CONSTEXPR const bool traps = __base::traps;
X    static constexpr const bool traps = __base::traps;
N    static _LIBCPP_CONSTEXPR const bool tinyness_before = __base::tinyness_before;
X    static constexpr const bool tinyness_before = __base::tinyness_before;
N    static _LIBCPP_CONSTEXPR const float_round_style round_style = __base::round_style;
X    static constexpr const float_round_style round_style = __base::round_style;
N};
N
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::is_specialized;
X    constexpr const bool numeric_limits<const volatile _Tp>::is_specialized;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<const volatile _Tp>::digits;
X    constexpr const int numeric_limits<const volatile _Tp>::digits;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<const volatile _Tp>::digits10;
X    constexpr const int numeric_limits<const volatile _Tp>::digits10;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<const volatile _Tp>::max_digits10;
X    constexpr const int numeric_limits<const volatile _Tp>::max_digits10;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::is_signed;
X    constexpr const bool numeric_limits<const volatile _Tp>::is_signed;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::is_integer;
X    constexpr const bool numeric_limits<const volatile _Tp>::is_integer;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::is_exact;
X    constexpr const bool numeric_limits<const volatile _Tp>::is_exact;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<const volatile _Tp>::radix;
X    constexpr const int numeric_limits<const volatile _Tp>::radix;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<const volatile _Tp>::min_exponent;
X    constexpr const int numeric_limits<const volatile _Tp>::min_exponent;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<const volatile _Tp>::min_exponent10;
X    constexpr const int numeric_limits<const volatile _Tp>::min_exponent10;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<const volatile _Tp>::max_exponent;
X    constexpr const int numeric_limits<const volatile _Tp>::max_exponent;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<const volatile _Tp>::max_exponent10;
X    constexpr const int numeric_limits<const volatile _Tp>::max_exponent10;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::has_infinity;
X    constexpr const bool numeric_limits<const volatile _Tp>::has_infinity;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::has_quiet_NaN;
X    constexpr const bool numeric_limits<const volatile _Tp>::has_quiet_NaN;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::has_signaling_NaN;
X    constexpr const bool numeric_limits<const volatile _Tp>::has_signaling_NaN;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const float_denorm_style numeric_limits<const volatile _Tp>::has_denorm;
X    constexpr const float_denorm_style numeric_limits<const volatile _Tp>::has_denorm;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::has_denorm_loss;
X    constexpr const bool numeric_limits<const volatile _Tp>::has_denorm_loss;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::is_iec559;
X    constexpr const bool numeric_limits<const volatile _Tp>::is_iec559;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::is_bounded;
X    constexpr const bool numeric_limits<const volatile _Tp>::is_bounded;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::is_modulo;
X    constexpr const bool numeric_limits<const volatile _Tp>::is_modulo;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::traps;
X    constexpr const bool numeric_limits<const volatile _Tp>::traps;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::tinyness_before;
X    constexpr const bool numeric_limits<const volatile _Tp>::tinyness_before;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const float_round_style numeric_limits<const volatile _Tp>::round_style;
X    constexpr const float_round_style numeric_limits<const volatile _Tp>::round_style;
N
N_LIBCPP_END_NAMESPACE_STD
X} }
N
N_LIBCPP_POP_MACROS
X_Pragma("pop_macro(\"min\")") _Pragma("pop_macro(\"max\")")
N
N#endif  // _LIBCPP_LIMITS
L 202 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/utility" 2
N#include <cstddef>
N#include <cstring>
N#include <cstdint>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/cstdint" 1
N// -*- C++ -*-
N//===--------------------------- cstdint ----------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is dual licensed under the MIT and the University of Illinois Open
N// Source Licenses. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP_CSTDINT
N#define _LIBCPP_CSTDINT
N
N/*
N    cstdint synopsis
N
NMacros:
N
N    INT8_MIN
N    INT16_MIN
N    INT32_MIN
N    INT64_MIN
N
N    INT8_MAX
N    INT16_MAX
N    INT32_MAX
N    INT64_MAX
N
N    UINT8_MAX
N    UINT16_MAX
N    UINT32_MAX
N    UINT64_MAX
N
N    INT_LEAST8_MIN
N    INT_LEAST16_MIN
N    INT_LEAST32_MIN
N    INT_LEAST64_MIN
N
N    INT_LEAST8_MAX
N    INT_LEAST16_MAX
N    INT_LEAST32_MAX
N    INT_LEAST64_MAX
N
N    UINT_LEAST8_MAX
N    UINT_LEAST16_MAX
N    UINT_LEAST32_MAX
N    UINT_LEAST64_MAX
N
N    INT_FAST8_MIN
N    INT_FAST16_MIN
N    INT_FAST32_MIN
N    INT_FAST64_MIN
N
N    INT_FAST8_MAX
N    INT_FAST16_MAX
N    INT_FAST32_MAX
N    INT_FAST64_MAX
N
N    UINT_FAST8_MAX
N    UINT_FAST16_MAX
N    UINT_FAST32_MAX
N    UINT_FAST64_MAX
N
N    INTPTR_MIN
N    INTPTR_MAX
N    UINTPTR_MAX
N
N    INTMAX_MIN
N    INTMAX_MAX
N
N    UINTMAX_MAX
N
N    PTRDIFF_MIN
N    PTRDIFF_MAX
N
N    SIG_ATOMIC_MIN
N    SIG_ATOMIC_MAX
N
N    SIZE_MAX
N
N    WCHAR_MIN
N    WCHAR_MAX
N
N    WINT_MIN
N    WINT_MAX
N
N    INT8_C(value)
N    INT16_C(value)
N    INT32_C(value)
N    INT64_C(value)
N
N    UINT8_C(value)
N    UINT16_C(value)
N    UINT32_C(value)
N    UINT64_C(value)
N
N    INTMAX_C(value)
N    UINTMAX_C(value)
N
Nnamespace std
N{
N
NTypes:
N
N    int8_t
N    int16_t
N    int32_t
N    int64_t
N
N    uint8_t
N    uint16_t
N    uint32_t
N    uint64_t
N
N    int_least8_t
N    int_least16_t
N    int_least32_t
N    int_least64_t
N
N    uint_least8_t
N    uint_least16_t
N    uint_least32_t
N    uint_least64_t
N
N    int_fast8_t
N    int_fast16_t
N    int_fast32_t
N    int_fast64_t
N
N    uint_fast8_t
N    uint_fast16_t
N    uint_fast32_t
N    uint_fast64_t
N
N    intptr_t
N    uintptr_t
N
N    intmax_t
N    uintmax_t
N
N}  // std
N*/
N
N#include <__config>
N#include <stdint.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/stdint.h" 1
N/* -*- C++ -*- */
N/*===--------------------------- complex.h --------------------------------===*/
N/*                                                                            */
N/*                     The LLVM Compiler Infrastructure                       */
N/*                                                                            */
N/* This file is dual licensed under the MIT and the University of Illinois Open
N** Source Licenses. See LICENSE.TXT for details.
N*/
N/*===----------------------------------------------------------------------===*/
N
N#ifndef _LIBCPP_STDINT_H
N#define _LIBCPP_STDINT_H
N
N/*
N    stdint.h synopsis
N
NMacros:
N
N    INT8_MIN
N    INT16_MIN
N    INT32_MIN
N    INT64_MIN
N
N    INT8_MAX
N    INT16_MAX
N    INT32_MAX
N    INT64_MAX
N
N    UINT8_MAX
N    UINT16_MAX
N    UINT32_MAX
N    UINT64_MAX
N
N    INT_LEAST8_MIN
N    INT_LEAST16_MIN
N    INT_LEAST32_MIN
N    INT_LEAST64_MIN
N
N    INT_LEAST8_MAX
N    INT_LEAST16_MAX
N    INT_LEAST32_MAX
N    INT_LEAST64_MAX
N
N    UINT_LEAST8_MAX
N    UINT_LEAST16_MAX
N    UINT_LEAST32_MAX
N    UINT_LEAST64_MAX
N
N    INT_FAST8_MIN
N    INT_FAST16_MIN
N    INT_FAST32_MIN
N    INT_FAST64_MIN
N
N    INT_FAST8_MAX
N    INT_FAST16_MAX
N    INT_FAST32_MAX
N    INT_FAST64_MAX
N
N    UINT_FAST8_MAX
N    UINT_FAST16_MAX
N    UINT_FAST32_MAX
N    UINT_FAST64_MAX
N
N    INTPTR_MIN
N    INTPTR_MAX
N    UINTPTR_MAX
N
N    INTMAX_MIN
N    INTMAX_MAX
N
N    UINTMAX_MAX
N
N    PTRDIFF_MIN
N    PTRDIFF_MAX
N
N    SIG_ATOMIC_MIN
N    SIG_ATOMIC_MAX
N
N    SIZE_MAX
N
N    WCHAR_MIN
N    WCHAR_MAX
N
N    WINT_MIN
N    WINT_MAX
N
N    INT8_C(value)
N    INT16_C(value)
N    INT32_C(value)
N    INT64_C(value)
N
N    UINT8_C(value)
N    UINT16_C(value)
N    UINT32_C(value)
N    UINT64_C(value)
N
N    INTMAX_C(value)
N    UINTMAX_C(value)
N
N*/
N
N#include <__config>
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N/* C99 stdlib (e.g. glibc < 2.18) does not provide macros needed
N   for C++11 unless __STDC_LIMIT_MACROS and __STDC_CONSTANT_MACROS
N   are defined
N*/
N#if defined(__cplusplus) && !defined(__STDC_LIMIT_MACROS)
X#if 1L && !1L
S#   define __STDC_LIMIT_MACROS
N#endif
N#if defined(__cplusplus) && !defined(__STDC_CONSTANT_MACROS)
X#if 1L && !1L
S#   define __STDC_CONSTANT_MACROS
N#endif
N
N#include_next <stdint.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/stdint.h" 1
N/*****************************************************************************/
N/* STDINT.H                                                                  */
N/*                                                                           */
N/* Copyright (c) 2002 Texas Instruments Incorporated                         */
N/* http://www.ti.com/                                                        */
N/*                                                                           */
N/*  Redistribution and  use in source  and binary forms, with  or without    */
N/*  modification,  are permitted provided  that the  following conditions    */
N/*  are met:                                                                 */
N/*                                                                           */
N/*     Redistributions  of source  code must  retain the  above copyright    */
N/*     notice, this list of conditions and the following disclaimer.         */
N/*                                                                           */
N/*     Redistributions in binary form  must reproduce the above copyright    */
N/*     notice, this  list of conditions  and the following  disclaimer in    */
N/*     the  documentation  and/or   other  materials  provided  with  the    */
N/*     distribution.                                                         */
N/*                                                                           */
N/*     Neither the  name of Texas Instruments Incorporated  nor the names    */
N/*     of its  contributors may  be used to  endorse or  promote products    */
N/*     derived  from   this  software  without   specific  prior  written    */
N/*     permission.                                                           */
N/*                                                                           */
N/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS    */
N/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT    */
N/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    */
N/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT    */
N/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    */
N/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT    */
N/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    */
N/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    */
N/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT    */
N/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    */
N/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     */
N/*                                                                           */
N/*****************************************************************************/
N#ifndef _STDINT_H_
N#define _STDINT_H_
N
N#include <_stdint40.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/_stdint40.h" 1
N/*****************************************************************************/
N/* _STDINT40.H                                                               */
N/*                                                                           */
N/* Copyright (c) 2018 Texas Instruments Incorporated                         */
N/* http://www.ti.com/                                                        */
N/*                                                                           */
N/*  Redistribution and  use in source  and binary forms, with  or without    */
N/*  modification,  are permitted provided  that the  following conditions    */
N/*  are met:                                                                 */
N/*                                                                           */
N/*     Redistributions  of source  code must  retain the  above copyright    */
N/*     notice, this list of conditions and the following disclaimer.         */
N/*                                                                           */
N/*     Redistributions in binary form  must reproduce the above copyright    */
N/*     notice, this  list of conditions  and the following  disclaimer in    */
N/*     the  documentation  and/or   other  materials  provided  with  the    */
N/*     distribution.                                                         */
N/*                                                                           */
N/*     Neither the  name of Texas Instruments Incorporated  nor the names    */
N/*     of its  contributors may  be used to  endorse or  promote products    */
N/*     derived  from   this  software  without   specific  prior  written    */
N/*     permission.                                                           */
N/*                                                                           */
N/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS    */
N/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT    */
N/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    */
N/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT    */
N/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    */
N/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT    */
N/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    */
N/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    */
N/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT    */
N/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    */
N/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     */
N/*                                                                           */
N/*****************************************************************************/
N#ifndef __STDINT40_H_
N#define __STDINT40_H_
N
N#if defined(_TMS320C6X) && !defined(__C6X_MIGRATION__)
X#if 0L && !0L
S    typedef          __int40_t  int40_t;
S    typedef unsigned __int40_t uint40_t;
S
S    typedef  int40_t  int_least40_t;
S    typedef uint40_t uint_least40_t;
S
S    typedef  int40_t  int_fast40_t;
S    typedef uint40_t uint_fast40_t;
N#endif
N
N/* 
N   According to footnotes in the 1999 C standard, "C++ implementations
N   should define these macros only when __STDC_LIMIT_MACROS is defined
N   before <stdint.h> is included." 
N*/
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !1L || 1L
N
N#if defined(_TMS320C6X) && !defined(__C6X_MIGRATION__)
X#if 0L && !0L
S    #define  INT40_MAX  0x7fffffffff
S    #define  INT40_MIN  (-INT40_MAX-1)
S    #define UINT40_MAX  0xffffffffff
S
S    #define  INT_LEAST40_MAX  (INT40_MAX)
S    #define  INT_LEAST40_MIN  (INT40_MIN)
S    #define UINT_LEAST40_MAX  (UINT40_MAX)
S
S    #define  INT_FAST40_MAX  (INT40_MAX)
S    #define  INT_FAST40_MIN  (INT40_MIN)
S    #define UINT_FAST40_MAX  (UINT40_MAX)
S
S    #define  INT40_C(value) ((int_least40_t)(value))
S    #define UINT40_C(value) ((uint_least40_t)(value))
N#endif
N
N#endif /* !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS) */
N#endif /* __STDINT40_H_ */
L 41 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/stdint.h" 2
N#if __has_include(<sys/stdint.h>) 
X#if 1 
N#include <sys/stdint.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/sys/stdint.h" 1
N/*-
N * SPDX-License-Identifier: BSD-2-Clause-FreeBSD
N *
N * Copyright (c) 2001 Mike Barcroft <mike@FreeBSD.org>
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N * 1. Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
N * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
N * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
N * SUCH DAMAGE.
N *
N * $FreeBSD$
N */
N
N#ifndef _SYS_STDINT_H_
N#define _SYS_STDINT_H_
N
N#include <sys/cdefs.h>
N#include <sys/_types.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/sys/_types.h" 1
N/*-
N * SPDX-License-Identifier: BSD-2-Clause-FreeBSD
N *
N * Copyright (c) 2002 Mike Barcroft <mike@FreeBSD.org>
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N * 1. Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
N * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
N * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
N * SUCH DAMAGE.
N *
N * $FreeBSD$
N */
N
N#ifndef _SYS__TYPES_H_
N#define _SYS__TYPES_H_
N
N#include <sys/cdefs.h>
N#include <machine/_types.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/machine/_types.h" 1
N/*-
N * SPDX-License-Identifier: BSD-4-Clause
N *
N * Copyright (c) 2002 Mike Barcroft <mike@FreeBSD.org>
N * Copyright (c) 1990, 1993
N *	The Regents of the University of California.  All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N * 1. Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N * 3. All advertising materials mentioning features or use of this software
N *    must display the following acknowledgement:
N *	This product includes software developed by the University of
N *	California, Berkeley and its contributors.
N * 4. Neither the name of the University nor the names of its contributors
N *    may be used to endorse or promote products derived from this software
N *    without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
N * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
N * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
N * SUCH DAMAGE.
N *
N *	From: @(#)ansi.h	8.2 (Berkeley) 1/4/94
N *	From: @(#)types.h	8.3 (Berkeley) 1/5/94
N * $FreeBSD$
N */
N
N#ifndef _MACHINE__TYPES_H_
N#define	_MACHINE__TYPES_H_
N
N#ifndef _SYS_CDEFS_H_
S#error this file needs sys/cdefs.h as a prerequisite
N#endif
N
N#ifdef __TI_COMPILER_VERSION__
N#pragma diag_push
N/* This file is required to use base types */
N#pragma CHECK_MISRA("-6.3")
N#endif
N
N/*
N * Basic types upon which most other types are built.
N */
Ntypedef	signed char		__int8_t;
Ntypedef	unsigned char		__uint8_t;
Ntypedef	short			__int16_t;
Ntypedef	unsigned short		__uint16_t;
Ntypedef	int			__int32_t;
Ntypedef	unsigned int		__uint32_t;
N#ifndef lint
N__extension__
X
N#endif
N/* LONGLONG */
Ntypedef	long long		__int64_t;
N#ifndef lint
N__extension__
X
N#endif
N/* LONGLONG */
Ntypedef	unsigned long long	__uint64_t;
N
N/*
N * Standard type definitions.
N */
Ntypedef	__uint32_t	__clock_t;		/* clock()... */
Ntypedef	__int32_t	__critical_t;
Ntypedef	double		__double_t;
Ntypedef	float		__float_t;
Ntypedef	__int32_t	__intfptr_t;
Ntypedef	__int64_t	__intmax_t;
Ntypedef	__int32_t	__intptr_t;
Ntypedef	__int32_t	__int_fast8_t;
Ntypedef	__int32_t	__int_fast16_t;
Ntypedef	__int32_t	__int_fast32_t;
Ntypedef	__int64_t	__int_fast64_t;
Ntypedef	__int8_t	__int_least8_t;
Ntypedef	__int16_t	__int_least16_t;
Ntypedef	__int32_t	__int_least32_t;
Ntypedef	__int64_t	__int_least64_t;
Ntypedef	__int32_t	__ptrdiff_t;		/* ptr1 - ptr2 */
Ntypedef	__int32_t	__register_t;
Ntypedef	__int32_t	__segsz_t;		/* segment size (in pages) */
Ntypedef	__uint32_t	__size_t;		/* sizeof() */
Ntypedef	__int32_t	__ssize_t;		/* byte count or error */
N#if (defined(__TI_TIME_USES_64) && __TI_TIME_USES_64)
X#if (0L && __TI_TIME_USES_64)
Stypedef	__int64_t	__time_t;		/* time()... */
N#else
Ntypedef __uint32_t      __time_t;
N#endif
Ntypedef	__uint32_t	__uintfptr_t;
Ntypedef	__uint64_t	__uintmax_t;
Ntypedef	__uint32_t	__uintptr_t;
Ntypedef	__uint32_t	__uint_fast8_t;
Ntypedef	__uint32_t	__uint_fast16_t;
Ntypedef	__uint32_t	__uint_fast32_t;
Ntypedef	__uint64_t	__uint_fast64_t;
Ntypedef	__uint8_t	__uint_least8_t;
Ntypedef	__uint16_t	__uint_least16_t;
Ntypedef	__uint32_t	__uint_least32_t;
Ntypedef	__uint64_t	__uint_least64_t;
Ntypedef	__uint32_t	__u_register_t;
Ntypedef	__uint32_t	__vm_offset_t;
Ntypedef	__uint32_t	__vm_paddr_t;
Ntypedef	__uint32_t	__vm_size_t;
N
N# ifdef __clang__
Stypedef __WCHAR_TYPE__ __WCHAR_T_TYPE__;
N# endif
Ntypedef	__WCHAR_T_TYPE__ ___wchar_t;
Xtypedef	unsigned short ___wchar_t;
N
N#define	__WCHAR_MIN	0		/* min value for a wchar_t */
N
N#ifdef __TI_COMPILER_VERSION__
N#if !defined(__TI_WCHAR_T_BITS__) || __TI_WCHAR_T_BITS__ == 16
X#if !1L || 16 == 16
N#    define __WCHAR_MAX 0xffffu
N#else
S#    define __WCHAR_MAX 0xffffffffu
N#endif
N#else
S#define	__WCHAR_MAX	__UINT_MAX	/* max value for a wchar_t */
N#endif
N
N/*
N * Unusual type definitions.
N */
N#ifdef __TI_COMPILER_VERSION__
Ntypedef struct __va_list_t {
N    void * __ap;
N} __va_list;
N#elif defined(__GNUCLIKE_BUILTIN_VARARGS)
Stypedef __builtin_va_list	__va_list;	/* internally known to gcc */
S#else
Stypedef	char *			__va_list;
N#endif /* __GNUCLIKE_BUILTIN_VARARGS */
N#if defined(__GNUCLIKE_BUILTIN_VAALIST) \
N    && !defined(__NO_GNUC_VA_LIST) && !defined(__GNUC_VA_LIST)
X#if 0L     && !0L && !0L
S#define __GNUC_VA_LIST	1
Stypedef __va_list		__gnuc_va_list;	/* compatibility w/GNU headers*/
N#endif
N
N#if defined(__TI_COMPILER_VERSION__)
X#if 1L
N#pragma diag_pop
N#endif
N
N#endif /* !_MACHINE__TYPES_H_ */
L 36 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/sys/_types.h" 2
N
N#if defined(__TI_COMPILER_VERSION__)
X#if 1L
N#pragma diag_push
N/* This file is required to use types without size and signedness */
N#pragma CHECK_MISRA("-6.3")
N#endif
N
N/*
N * Standard type definitions.
N */
Ntypedef	__int32_t	__blksize_t;	/* file block size */
Ntypedef	__int64_t	__blkcnt_t;	/* file block count */
Ntypedef	__int32_t	__clockid_t;	/* clock_gettime()... */
Ntypedef	__uint32_t	__fflags_t;	/* file flags */
Ntypedef	__uint64_t	__fsblkcnt_t;
Ntypedef	__uint64_t	__fsfilcnt_t;
Ntypedef	__uint32_t	__gid_t;
Ntypedef	__int64_t	__id_t;		/* can hold a gid_t, pid_t, or uid_t */
Ntypedef	__uint64_t	__ino_t;	/* inode number */
Ntypedef	long		__key_t;	/* IPC key (for Sys V IPC) */
Ntypedef	__int32_t	__lwpid_t;	/* Thread ID (a.k.a. LWP) */
Ntypedef	__uint16_t	__mode_t;	/* permissions */
Ntypedef	int		__accmode_t;	/* access permissions */
Ntypedef	int		__nl_item;
Ntypedef	__uint64_t	__nlink_t;	/* link count */
Ntypedef	__int64_t	__off_t;	/* file offset */
Ntypedef	__int64_t	__off64_t;	/* file offset (alias) */
Ntypedef	__int32_t	__pid_t;	/* process [group] */
Ntypedef	__int64_t	__rlim_t;	/* resource limit - intentionally */
N					/* signed, because of legacy code */
N					/* that uses -1 for RLIM_INFINITY */
N#if defined(__TI_COMPILER_VERSION__) &&  defined(__TMS320C2000__)
X#if 1L &&  0L
Stypedef	__uint16_t	__sa_family_t;
N#else
Ntypedef	__uint8_t	__sa_family_t;
N#endif
Ntypedef	__uint32_t	__socklen_t;
Ntypedef	long		__suseconds_t;	/* microseconds (signed) */
Ntypedef	struct __timer	*__timer_t;	/* timer_gettime()... */
Ntypedef	struct __mq	*__mqd_t;	/* mq_open()... */
Ntypedef	__uint32_t	__uid_t;
Ntypedef	unsigned int	__useconds_t;	/* microseconds (unsigned) */
Ntypedef	int		__cpuwhich_t;	/* which parameter for cpuset. */
Ntypedef	int		__cpulevel_t;	/* level parameter for cpuset. */
Ntypedef int		__cpusetid_t;	/* cpuset identifier. */
N
N/*
N * Unusual type definitions.
N */
N/*
N * rune_t is declared to be an ``int'' instead of the more natural
N * ``unsigned long'' or ``long''.  Two things are happening here.  It is not
N * unsigned so that EOF (-1) can be naturally assigned to it and used.  Also,
N * it looks like 10646 will be a 31 bit standard.  This means that if your
N * ints cannot hold 32 bits, you will be in trouble.  The reason an int was
N * chosen over a long is that the is*() and to*() routines take ints (says
N * ANSI C), but they use __ct_rune_t instead of int.
N *
N * NOTE: rune_t is not covered by ANSI nor other standards, and should not
N * be instantiated outside of lib/libc/locale.  Use wchar_t.  wint_t and
N * rune_t must be the same type.  Also, wint_t should be able to hold all
N * members of the largest character set plus one extra value (WEOF), and
N * must be at least 16 bits.
N */
N#if defined(__TI_COMPILER_VERSION__) && \
N    defined(__TMS320C2000__) && defined(__TI_EABI__)
X#if 1L &&     0L && 1L
Stypedef	unsigned long	__ct_rune_t;	/* arg type for ctype funcs */
N#else
Ntypedef	int		__ct_rune_t;	/* arg type for ctype funcs */
N#endif
N
Ntypedef	__ct_rune_t	__rune_t;	/* rune_t (see above) */
Ntypedef	__ct_rune_t	__wint_t;	/* wint_t (see above) */
N
N/* Clang already provides these types as built-ins, but only in C++ mode. */
N#if !defined(__clang__) || !defined(__cplusplus)
X#if !0L || !1L
Ntypedef	__uint_least16_t __char16_t;
Ntypedef	__uint_least32_t __char32_t;
N#endif
N/* In C++11, char16_t and char32_t are built-in types. */
N#if defined(__cplusplus) && __cplusplus >= 201103L
X#if 1L && 201402L >= 201103L
N#define	_CHAR16_T_DECLARED
N#define	_CHAR32_T_DECLARED
N#endif
N
Ntypedef struct {
N	long long __max_align1 __attribute__((aligned(_Alignof(long long))));
X	long long __max_align1 __attribute__((aligned(alignof(long long))));
N	long double __max_align2 __attribute__((aligned(_Alignof(long double))));
X	long double __max_align2 __attribute__((aligned(alignof(long double))));
N} __max_align_t;
N
Ntypedef	__uint64_t	__dev_t;	/* device number */
N
Ntypedef	__uint32_t	__fixpt_t;	/* fixed point number */
N
N/*
N * mbstate_t is an opaque object to keep conversion state during multibyte
N * stream conversions.
N */
N
N#ifdef __TI_COMPILER_VERSION__
N#if defined(_AEABI_PORTABILITY_LEVEL) && _AEABI_PORTABILITY_LEVEL != 0
X#if 0L && _AEABI_PORTABILITY_LEVEL != 0
Stypedef struct _Mbstatet
S{
S    unsigned int __state, __state2;
S} _Mbstatet;
N#else
Ntypedef int _Mbstatet;
N#endif /* _AEABI_PORTABILITY_LEVEL */
N
Ntypedef _Mbstatet __mbstate_t;
N#else
Stypedef union {
S	char		__mbstate8[128];
S	__int64_t	_mbstateL;	/* for alignment */
S} __mbstate_t;
N#endif
N
Ntypedef __uintmax_t     __rman_res_t;
N
N/*
N * When the following macro is defined, the system uses 64-bit inode numbers.
N * Programs can use this to avoid including <sys/param.h>, with its associated
N * namespace pollution.
N */
N#define	__INO64
N
N#if defined(__TI_COMPILER_VERSION__)
X#if 1L
N#pragma diag_pop
N#endif
N
N#endif /* !_SYS__TYPES_H_ */
L 36 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/sys/stdint.h" 2
N
N#include <machine/_stdint.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/machine/_stdint.h" 1
N/*-
N * SPDX-License-Identifier: BSD-2-Clause-NetBSD
N *
N * Copyright (c) 2001, 2002 Mike Barcroft <mike@FreeBSD.org>
N * Copyright (c) 2001 The NetBSD Foundation, Inc.
N * All rights reserved.
N *
N * This code is derived from software contributed to The NetBSD Foundation
N * by Klaus Klein.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N * 1. Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
N * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
N * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
N * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
N * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *
N * $FreeBSD$
N */
N
N#ifndef _MACHINE__STDINT_H_
N#define	_MACHINE__STDINT_H_
N
N#pragma diag_push
N/* 19.4 is issued for macros that are defined in terms of other macros. */
N#pragma CHECK_MISRA("-19.4")
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !1L || 1L
N
N#define	INT8_C(c)		(c)
N#define	INT16_C(c)		(c)
N#define	INT32_C(c)		(c)
N#define	INT64_C(c)		(c ## LL)
N
N#define	UINT8_C(c)		(c)
N#define	UINT16_C(c)		(c)
N#define	UINT32_C(c)		(c ## U)
N#define	UINT64_C(c)		(c ## ULL)
N
N#define	INTMAX_C(c)		INT64_C(c)
N#define	UINTMAX_C(c)		UINT64_C(c)
N
N#endif /* !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS) */
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !1L || 1L
N
N/*
N * ISO/IEC 9899:1999
N * 7.18.2.1 Limits of exact-width integer types
N */
N/* Minimum values of exact-width signed integer types. */
N#define	INT8_MIN	(-0x7f-1)
N#define	INT16_MIN	(-0x7fff-1)
N#define	INT32_MIN	(-0x7fffffff-1)
N#define	INT64_MIN	(-0x7fffffffffffffffLL-1)
N
N/* Maximum values of exact-width signed integer types. */
N#define	INT8_MAX	0x7f
N#define	INT16_MAX	0x7fff
N#define	INT32_MAX	0x7fffffff
N#define	INT64_MAX	0x7fffffffffffffffLL
N
N/* Maximum values of exact-width unsigned integer types. */
N#define	UINT8_MAX	0xff
N#define	UINT16_MAX	0xffff
N#define	UINT32_MAX	0xffffffffU
N#define	UINT64_MAX	0xffffffffffffffffULL
N
N/*
N * ISO/IEC 9899:1999
N * 7.18.2.2  Limits of minimum-width integer types
N */
N/* Minimum values of minimum-width signed integer types. */
N#define	INT_LEAST8_MIN	INT8_MIN
N#define	INT_LEAST16_MIN	INT16_MIN
N#define	INT_LEAST32_MIN	INT32_MIN
N#define	INT_LEAST64_MIN	INT64_MIN
N
N/* Maximum values of minimum-width signed integer types. */
N#define	INT_LEAST8_MAX	INT8_MAX
N#define	INT_LEAST16_MAX	INT16_MAX
N#define	INT_LEAST32_MAX	INT32_MAX
N#define	INT_LEAST64_MAX	INT64_MAX
N
N/* Maximum values of minimum-width unsigned integer types. */
N#define	UINT_LEAST8_MAX	 UINT8_MAX
N#define	UINT_LEAST16_MAX UINT16_MAX
N#define	UINT_LEAST32_MAX UINT32_MAX
N#define	UINT_LEAST64_MAX UINT64_MAX
N
N/*
N * ISO/IEC 9899:1999
N * 7.18.2.3  Limits of fastest minimum-width integer types
N */
N/* Minimum values of fastest minimum-width signed integer types. */
N#define	INT_FAST8_MIN	INT32_MIN
N#define	INT_FAST16_MIN	INT32_MIN
N#define	INT_FAST32_MIN	INT32_MIN
N#define	INT_FAST64_MIN	INT64_MIN
N
N/* Maximum values of fastest minimum-width signed integer types. */
N#define	INT_FAST8_MAX	INT32_MAX
N#define	INT_FAST16_MAX	INT32_MAX
N#define	INT_FAST32_MAX	INT32_MAX
N#define	INT_FAST64_MAX	INT64_MAX
N
N/* Maximum values of fastest minimum-width unsigned integer types. */
N#define	UINT_FAST8_MAX	UINT32_MAX
N#define	UINT_FAST16_MAX	UINT32_MAX
N#define	UINT_FAST32_MAX	UINT32_MAX
N#define	UINT_FAST64_MAX	UINT64_MAX
N
N/*
N * ISO/IEC 9899:1999
N * 7.18.2.4  Limits of integer types capable of holding object pointers
N */
N#define	INTPTR_MIN	INT32_MIN
N#define	INTPTR_MAX	INT32_MAX
N#define	UINTPTR_MAX	UINT32_MAX
N
N/*
N * ISO/IEC 9899:1999
N * 7.18.2.5  Limits of greatest-width integer types
N */
N#define	INTMAX_MIN	INT64_MIN
N#define	INTMAX_MAX	INT64_MAX
N#define	UINTMAX_MAX	UINT64_MAX
N
N/*
N * ISO/IEC 9899:1999
N * 7.18.3  Limits of other integer types
N */
N/* Limits of ptrdiff_t. */
N#define	PTRDIFF_MIN	INT32_MIN
N#define	PTRDIFF_MAX	INT32_MAX
N
N/* Limits of sig_atomic_t. */
N#define	SIG_ATOMIC_MIN	INT32_MIN
N#define	SIG_ATOMIC_MAX	INT32_MAX
N
N/* Limit of size_t. */
N#define	SIZE_MAX	UINT32_MAX
N
N/* Limits of wint_t. */
N#define	WINT_MIN	INT32_MIN
N#define	WINT_MAX	INT32_MAX
N
N#endif /* !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS) */
N
N#pragma diag_pop
N
N#endif /* !_MACHINE__STDINT_H_ */
L 38 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/sys/stdint.h" 2
N#include <sys/_stdint.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/sys/_stdint.h" 1
N/*-
N * SPDX-License-Identifier: BSD-2-Clause-FreeBSD
N *
N * Copyright (c) 2011 David E. O'Brien <obrien@FreeBSD.org>
N * Copyright (c) 2001 Mike Barcroft <mike@FreeBSD.org>
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N * 1. Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
N * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
N * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
N * SUCH DAMAGE.
N *
N * $FreeBSD$
N */
N
N#ifndef _SYS__STDINT_H_
N#define _SYS__STDINT_H_
N
N#if !defined(__TI_COMPILER_VERSION__) ||  !defined(__TMS320C2000__)
X#if !1L ||  !0L
N#ifndef _INT8_T_DECLARED
Ntypedef	__int8_t		int8_t;
N#define	_INT8_T_DECLARED
N#endif
N#endif
N
N#ifndef _INT16_T_DECLARED
Ntypedef	__int16_t		int16_t;
N#define	_INT16_T_DECLARED
N#endif
N
N#ifndef _INT32_T_DECLARED
Ntypedef	__int32_t		int32_t;
N#define	_INT32_T_DECLARED
N#endif
N
N#ifndef _INT64_T_DECLARED
Ntypedef	__int64_t		int64_t;
N#define	_INT64_T_DECLARED
N#endif
N
N#if !defined(__TI_COMPILER_VERSION__) ||  !defined(__TMS320C2000__)
X#if !1L ||  !0L
N#ifndef _UINT8_T_DECLARED
Ntypedef	__uint8_t		uint8_t;
N#define	_UINT8_T_DECLARED
N#endif
N#endif
N
N#ifndef _UINT16_T_DECLARED
Ntypedef	__uint16_t		uint16_t;
N#define	_UINT16_T_DECLARED
N#endif
N
N#ifndef _UINT32_T_DECLARED
Ntypedef	__uint32_t		uint32_t;
N#define	_UINT32_T_DECLARED
N#endif
N
N#ifndef _UINT64_T_DECLARED
Ntypedef	__uint64_t		uint64_t;
N#define	_UINT64_T_DECLARED
N#endif
N
N#ifndef _INTPTR_T_DECLARED
Ntypedef	__intptr_t		intptr_t;
N#define	_INTPTR_T_DECLARED
N#endif
N#ifndef _UINTPTR_T_DECLARED
Ntypedef	__uintptr_t		uintptr_t;
N#define	_UINTPTR_T_DECLARED
N#endif
N#ifndef _INTMAX_T_DECLARED
Ntypedef	__intmax_t		intmax_t;
N#define	_INTMAX_T_DECLARED
N#endif
N#ifndef _UINTMAX_T_DECLARED
Ntypedef	__uintmax_t		uintmax_t;
N#define	_UINTMAX_T_DECLARED
N#endif
N
N#endif /* !_SYS__STDINT_H_ */
L 39 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/sys/stdint.h" 2
N
Ntypedef	__int_least8_t		int_least8_t;
Ntypedef	__int_least16_t		int_least16_t;
Ntypedef	__int_least32_t		int_least32_t;
Ntypedef	__int_least64_t		int_least64_t;
N
Ntypedef	__uint_least8_t		uint_least8_t;
Ntypedef	__uint_least16_t	uint_least16_t;
Ntypedef	__uint_least32_t	uint_least32_t;
Ntypedef	__uint_least64_t	uint_least64_t;
N
Ntypedef	__int_fast8_t		int_fast8_t;
Ntypedef	__int_fast16_t		int_fast16_t;
Ntypedef	__int_fast32_t		int_fast32_t;
Ntypedef	__int_fast64_t		int_fast64_t;
N
Ntypedef	__uint_fast8_t		uint_fast8_t;
Ntypedef	__uint_fast16_t		uint_fast16_t;
Ntypedef	__uint_fast32_t		uint_fast32_t;
Ntypedef	__uint_fast64_t		uint_fast64_t;
N
N/* GNU and Darwin define this and people seem to think it's portable */
N#if defined(UINTPTR_MAX) && defined(UINT64_MAX) && (UINTPTR_MAX == UINT64_MAX)
X#if 1L && 1L && (0xffffffffU == 0xffffffffffffffffULL)
S#define	__WORDSIZE		64
N#else
N#define	__WORDSIZE		32
N#endif
N
N#pragma diag_push
N#pragma CHECK_MISRA("-19.4")
N/* Limits of wchar_t. */
N#define	WCHAR_MIN	__WCHAR_MIN
N#define	WCHAR_MAX	__WCHAR_MAX
N#pragma diag_pop
N
N#if __EXT1_VISIBLE
X#if 1
N/* ISO/IEC 9899:2011 K.3.4.4 */
N#ifndef RSIZE_MAX
N#define RSIZE_MAX (SIZE_MAX >> 1)
N#endif
N#endif /* __EXT1_VISIBLE */
N
N#endif /* !_SYS_STDINT_H_ */
L 43 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/stdint.h" 2
N#else
S/* 7.18.1.1 Exact-width integer types */
S
S#if defined(__MSP430__) || defined(__TMS320C55X_PLUS_BYTE__)
S    typedef   signed char    int8_t;
S    typedef unsigned char   uint8_t;
S    typedef          int    int16_t;
S    typedef unsigned int   uint16_t;
S    typedef          long   int32_t;
S    typedef unsigned long  uint32_t;
S#elif defined(_TMS320C5XX) || defined(__TMS320C55X__)
S    typedef          int    int16_t;
S    typedef unsigned int   uint16_t;
S    typedef          long   int32_t;
S    typedef unsigned long  uint32_t;
S#elif defined(_TMS320C6X) || defined(__ARM_ARCH) || defined(__ARP32__) || \
S      defined(__PRU__)    || defined(__C7000__)
X#elif defined(_TMS320C6X) || defined(__ARM_ARCH) || defined(__ARP32__) ||       defined(__PRU__)    || defined(__C7000__)
S    typedef   signed char   int8_t;
S    typedef unsigned char  uint8_t;
S    typedef          short  int16_t;
S    typedef unsigned short uint16_t;
S    typedef          int    int32_t;
S    typedef unsigned int   uint32_t;
S#elif defined (__TMS320C2000__)
S#if defined(__TMS320C28XX_CLA__)
S    typedef          short  int16_t;
S    typedef unsigned short uint16_t;
S    typedef          int    int32_t;
S    typedef unsigned int   uint32_t;
S#else
S    typedef          int    int16_t;
S    typedef unsigned int   uint16_t;
S    typedef          long   int32_t;
S    typedef unsigned long  uint32_t;
S#endif
S#endif
S
S#if defined(__ARM_ARCH) || defined(_TMS320C6X) || defined(__ARP32__) || \
S    defined(__MSP430__) || defined(__PRU__)    || defined(__C7000__)
X#if defined(__ARM_ARCH) || defined(_TMS320C6X) || defined(__ARP32__) ||     defined(__MSP430__) || defined(__PRU__)    || defined(__C7000__)
S    typedef          long long  int64_t;
S    typedef unsigned long long uint64_t;
S#elif defined(__TMS320C2000__)
S#if defined(__TMS320C28X__) || \
S    (defined(__TMS320C28XX_CLA__) && defined(__TI_EABI__))
X#if defined(__TMS320C28X__) ||     (defined(__TMS320C28XX_CLA__) && defined(__TI_EABI__))
S    typedef          long long  int64_t;
S    typedef unsigned long long uint64_t;
S#endif
S#endif
S
S/* 7.18.1.2 Minimum-width integer types */
S
S#if defined(_TMS320C6X) || defined(__ARM_ARCH) || defined(__MSP430__) || \
S    defined(__TMS320C55X_PLUS_BYTE__)          || defined(__ARP32__)  || \
S    defined(__PRU__)    || defined(__C7000__)
X#if defined(_TMS320C6X) || defined(__ARM_ARCH) || defined(__MSP430__) ||     defined(__TMS320C55X_PLUS_BYTE__)          || defined(__ARP32__)  ||     defined(__PRU__)    || defined(__C7000__)
S    typedef  int8_t   int_least8_t;
S    typedef uint8_t  uint_least8_t;
S#elif defined(__TMS320C2000__) || defined(_TMS320C5XX) || defined(__TMS320C55X__)
S    typedef  int16_t  int_least8_t;
S    typedef uint16_t uint_least8_t;
S#endif
S
S    typedef  int16_t  int_least16_t;
S    typedef uint16_t uint_least16_t;
S    typedef  int32_t  int_least32_t;
S    typedef uint32_t uint_least32_t;
S
S#if defined(__ARM_ARCH) || defined(_TMS320C6X) || defined(__C7000__) || \
S    defined(__ARP32__)  || defined(__MSP430__) || defined(__PRU__)
X#if defined(__ARM_ARCH) || defined(_TMS320C6X) || defined(__C7000__) ||     defined(__ARP32__)  || defined(__MSP430__) || defined(__PRU__)
S    typedef  int64_t  int_least64_t;
S    typedef uint64_t uint_least64_t;
S#elif defined(__TMS320C2000__)
S#if defined(__TMS320C28X__) || \
S    (defined(__TMS320C28XX_CLA__) && defined(__TI_EABI__))
X#if defined(__TMS320C28X__) ||     (defined(__TMS320C28XX_CLA__) && defined(__TI_EABI__))
S    typedef  int64_t  int_least64_t;
S    typedef uint64_t uint_least64_t;
S#else
S/* sorry, [u]int_least64_t not implemented for C27X, CLA */
S#endif
S#elif defined(_TMS320C5XX) || defined(__TMS320C55X__) 
S/* sorry, [u]int_least64_t not implemented for C54x, C55x */
S#endif
S
S/* 7.18.1.3 Fastest minimum-width integer types */
S
S#if defined(_TMS320C5XX) || defined(__TMS320C55X__)  || defined(__MSP430__)
S    typedef  int16_t  int_fast8_t;
S    typedef uint16_t uint_fast8_t;
S    typedef  int16_t  int_fast16_t;
S    typedef uint16_t uint_fast16_t;
S#elif defined(_TMS320C6X) || defined(__ARM_ARCH) || defined(__ARP32__) || \
S      defined(__PRU__)    || defined(__C7000__)
X#elif defined(_TMS320C6X) || defined(__ARM_ARCH) || defined(__ARP32__) ||       defined(__PRU__)    || defined(__C7000__)
S    typedef  int32_t  int_fast8_t;
S    typedef uint32_t uint_fast8_t;
S    typedef  int32_t  int_fast16_t;
S    typedef uint32_t uint_fast16_t;
S#elif defined (__TMS320C2000__)
S#if defined(__TMS320C28XX_CLA__)
S    typedef  int32_t  int_fast8_t;
S    typedef uint32_t uint_fast8_t;
S    typedef  int32_t  int_fast16_t;
S    typedef uint32_t uint_fast16_t;
S#else
S    typedef  int16_t  int_fast8_t;
S    typedef uint16_t uint_fast8_t;
S    typedef  int16_t  int_fast16_t;
S    typedef uint16_t uint_fast16_t;
S#endif
S#endif
S
S    typedef  int32_t  int_fast32_t;
S    typedef uint32_t uint_fast32_t;
S
S#if defined(__ARM_ARCH) || defined(_TMS320C6X) || defined(__C7000__) || \
S    defined(__ARP32__)  || defined(__MSP430__) || defined(__PRU__)
X#if defined(__ARM_ARCH) || defined(_TMS320C6X) || defined(__C7000__) ||     defined(__ARP32__)  || defined(__MSP430__) || defined(__PRU__)
S    typedef  int64_t  int_fast64_t;
S    typedef uint64_t uint_fast64_t;
S#elif defined(__TMS320C2000__)
S#if defined(__TMS320C28X__) || \
S    (defined(__TMS320C28XX_CLA__) && defined(__TI_EABI__))
X#if defined(__TMS320C28X__) ||     (defined(__TMS320C28XX_CLA__) && defined(__TI_EABI__))
S    typedef  int64_t  int_fast64_t;
S    typedef uint64_t uint_fast64_t;
S#else
S/* sorry, [u]int_fast64_t not implemented for C27X, CLA */
S#endif
S#elif defined(_TMS320C5XX) || defined(__TMS320C55X__) 
S/* sorry, [u]int_fast64_t not implemented for C54x, C55x */
S#endif
S
S/* 7.18.1.4 Integer types capable of holding object pointers */
S#if defined(_TMS320C5XX) || defined(__TMS320C55X__)        || \
S    (defined(__MSP430__) && defined(__LARGE_CODE_MODEL__)) || \
S    defined(__C7000__)
X#if defined(_TMS320C5XX) || defined(__TMS320C55X__)        ||     (defined(__MSP430__) && defined(__LARGE_CODE_MODEL__)) ||     defined(__C7000__)
S    typedef          long intptr_t;
S    typedef unsigned long uintptr_t;
S#elif defined(_TMS320C6X) || defined(__ARM_ARCH) || defined(__MSP430__) || \
S      defined(__ARP32__)  || defined(__PRU__)
X#elif defined(_TMS320C6X) || defined(__ARM_ARCH) || defined(__MSP430__) ||       defined(__ARP32__)  || defined(__PRU__)
S    typedef          int intptr_t;
S    typedef unsigned int uintptr_t;
S#elif defined(__TMS320C2000__)
S#if defined(__TMS320C28XX_CLA__)
S    typedef          short intptr_t;
S    typedef unsigned short uintptr_t;
S#else
S    typedef          long intptr_t;
S    typedef unsigned long uintptr_t;
S#endif
S#endif
S
S/* 7.18.1.5 Greatest-width integer types */
S#if defined(__TMS320C55X__) || defined(__ARM_ARCH) || defined(_TMS320C6X) || \
S    defined(__ARP32__)      || defined(__MSP430__) || defined(__PRU__)    || \
S    defined(__C7000__)
X#if defined(__TMS320C55X__) || defined(__ARM_ARCH) || defined(_TMS320C6X) ||     defined(__ARP32__)      || defined(__MSP430__) || defined(__PRU__)    ||     defined(__C7000__)
S    typedef          long long intmax_t;
S    typedef unsigned long long uintmax_t;
S#elif defined(_TMS320C5XX)
S    typedef          long intmax_t;
S    typedef unsigned long uintmax_t;
S#elif defined(__TMS320C2000__)
S#if defined(__TMS320C28X__) || \
S    (defined(__TMS320C28XX_CLA__) && defined(__TI_EABI__))
X#if defined(__TMS320C28X__) ||     (defined(__TMS320C28XX_CLA__) && defined(__TI_EABI__))
S    typedef          long long intmax_t;
S    typedef unsigned long long uintmax_t;
S#else /* C27X or CLA */
S    typedef          long intmax_t;
S    typedef unsigned long uintmax_t;
S#endif
S#endif
S
S/* 
S   According to footnotes in the 1999 C standard, "C++ implementations
S   should define these macros only when __STDC_LIMIT_MACROS is defined
S   before <stdint.h> is included." 
S*/
S#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
S
S/* 7.18.2 Limits of specified width integer types */
S
S#if defined(_TMS320C6X) || defined(__ARM_ARCH) || defined(__MSP430__) || \
S    defined(__TMS320C55X_PLUS_BYTE__)          || defined(__ARP32__)  || \
S    defined(__PRU__)    || defined(__C7000__)
X#if defined(_TMS320C6X) || defined(__ARM_ARCH) || defined(__MSP430__) ||     defined(__TMS320C55X_PLUS_BYTE__)          || defined(__ARP32__)  ||     defined(__PRU__)    || defined(__C7000__)
S    #define  INT8_MAX   0x7f
S    #define  INT8_MIN   (-INT8_MAX-1)
S    #define UINT8_MAX   0xff
S#endif
S
S    #define  INT16_MAX  0x7fff
S    #define  INT16_MIN  (-INT16_MAX-1)
S    #define UINT16_MAX  0xffff
S
S    #define  INT32_MAX  0x7fffffff
S    #define  INT32_MIN  (-INT32_MAX-1)
S    #define UINT32_MAX  0xffffffff
S
S#if defined(__ARM_ARCH) || defined(_TMS320C6X) || defined(__C7000__) || \
S    defined(__ARP32__)  || defined(__MSP430__) || defined(__PRU__)
X#if defined(__ARM_ARCH) || defined(_TMS320C6X) || defined(__C7000__) ||     defined(__ARP32__)  || defined(__MSP430__) || defined(__PRU__)
S    #define  INT64_MAX  0x7fffffffffffffff
S    #define  INT64_MIN  (-INT64_MAX-1)
S    #define UINT64_MAX  0xffffffffffffffff
S#elif defined(__TMS320C2000__)
S#if defined(__TMS320C28X__) || \
S    (defined(__TMS320C28XX_CLA__) && defined(__TI_EABI__))
X#if defined(__TMS320C28X__) ||     (defined(__TMS320C28XX_CLA__) && defined(__TI_EABI__))
S    #define  INT64_MAX  0x7fffffffffffffff
S    #define  INT64_MIN  (-INT64_MAX-1)
S    #define UINT64_MAX  0xffffffffffffffff
S#endif
S#endif
S
S#if defined(_TMS320C6X) || defined(__ARM_ARCH) || defined(__MSP430__) || \
S    defined(__TMS320C55X_PLUS_BYTE__)          || defined(__ARP32__)  || \
S    defined(__PRU__)    || defined(__C7000__)
X#if defined(_TMS320C6X) || defined(__ARM_ARCH) || defined(__MSP430__) ||     defined(__TMS320C55X_PLUS_BYTE__)          || defined(__ARP32__)  ||     defined(__PRU__)    || defined(__C7000__)
S    #define  INT_LEAST8_MAX   (INT8_MAX)
S    #define  INT_LEAST8_MIN   (INT8_MIN)
S    #define UINT_LEAST8_MAX   (UINT8_MAX)
S#elif defined(__TMS320C2000__) || defined(_TMS320C5XX) || defined(__TMS320C55X__)
S    #define  INT_LEAST8_MAX   (INT16_MAX)
S    #define  INT_LEAST8_MIN   (INT16_MIN)
S    #define UINT_LEAST8_MAX   (UINT16_MAX)
S#endif
S
S    #define  INT_LEAST16_MAX  (INT16_MAX)
S    #define  INT_LEAST16_MIN  (INT16_MIN)
S    #define UINT_LEAST16_MAX  (UINT16_MAX)
S    #define  INT_LEAST32_MAX  (INT32_MAX)
S    #define  INT_LEAST32_MIN  (INT32_MIN)
S    #define UINT_LEAST32_MAX  (UINT32_MAX)
S
S#if defined(__ARM_ARCH) || defined(_TMS320C6X) || defined(__C7000__) || \
S    defined(__ARP32__)  || defined(__MSP430__) || defined(__PRU__)
X#if defined(__ARM_ARCH) || defined(_TMS320C6X) || defined(__C7000__) ||     defined(__ARP32__)  || defined(__MSP430__) || defined(__PRU__)
S    #define  INT_LEAST64_MAX  (INT64_MAX)
S    #define  INT_LEAST64_MIN  (INT64_MIN)
S    #define UINT_LEAST64_MAX  (UINT64_MAX)
S#elif defined(__TMS320C2000__)
S#if defined(__TMS320C28X__) || \
S    (defined(__TMS320C28XX_CLA__) && defined(__TI_EABI__))
X#if defined(__TMS320C28X__) ||     (defined(__TMS320C28XX_CLA__) && defined(__TI_EABI__))
S    #define  INT_LEAST64_MAX  (INT64_MAX)
S    #define  INT_LEAST64_MIN  (INT64_MIN)
S    #define UINT_LEAST64_MAX  (UINT64_MAX)
S#endif
S#endif
S
S#if defined(_TMS320C5XX) || defined(__TMS320C55X__)
S    #define  INT_FAST8_MAX   (INT16_MAX)
S    #define  INT_FAST8_MIN   (INT16_MIN)
S    #define UINT_FAST8_MAX   (UINT16_MAX)
S    #define  INT_FAST16_MAX  (INT16_MAX)
S    #define  INT_FAST16_MIN  (INT16_MIN)
S    #define UINT_FAST16_MAX  (UINT16_MAX)
S#elif defined(_TMS320C6X) || defined(__ARM_ARCH) || defined(__ARP32__) || \
S      defined(__PRU__)    || defined(__C7000__)
X#elif defined(_TMS320C6X) || defined(__ARM_ARCH) || defined(__ARP32__) ||       defined(__PRU__)    || defined(__C7000__)
S    #define  INT_FAST8_MAX   (INT32_MAX)
S    #define  INT_FAST8_MIN   (INT32_MIN)
S    #define UINT_FAST8_MAX   (UINT32_MAX)
S    #define  INT_FAST16_MAX  (INT32_MAX)
S    #define  INT_FAST16_MIN  (INT32_MIN)
S    #define UINT_FAST16_MAX  (UINT32_MAX)
S#elif defined(__MSP430__)
S    #define  INT_FAST8_MAX    (INT16_MAX)
S    #define  INT_FAST8_MIN    (INT16_MIN)
S    #define  UINT_FAST8_MAX   (UINT16_MAX)
S    #define  INT_FAST16_MAX   (INT16_MAX)
S    #define  INT_FAST16_MIN   (INT16_MIN)
S    #define  UINT_FAST16_MAX  (UINT16_MAX)
S#elif defined (__TMS320C2000__)
S#if defined(__TMS320C28XX_CLA__)
S    #define  INT_FAST8_MAX   (INT32_MAX)
S    #define  INT_FAST8_MIN   (INT32_MIN)
S    #define UINT_FAST8_MAX   (UINT32_MAX)
S    #define  INT_FAST16_MAX  (INT32_MAX)
S    #define  INT_FAST16_MIN  (INT32_MIN)
S    #define UINT_FAST16_MAX  (UINT32_MAX)
S#else
S    #define  INT_FAST8_MAX   (INT16_MAX)
S    #define  INT_FAST8_MIN   (INT16_MIN)
S    #define UINT_FAST8_MAX   (UINT16_MAX)
S    #define  INT_FAST16_MAX  (INT16_MAX)
S    #define  INT_FAST16_MIN  (INT16_MIN)
S    #define UINT_FAST16_MAX  (UINT16_MAX)
S#endif
S#endif
S
S    #define  INT_FAST32_MAX  (INT32_MAX)
S    #define  INT_FAST32_MIN  (INT32_MIN)
S    #define UINT_FAST32_MAX  (UINT32_MAX)
S
S#if defined(__ARM_ARCH) || defined(_TMS320C6X) || defined(__C7000__) || \
S    defined(__ARP32__)  || defined(__MSP430__) || defined(__PRU__)
X#if defined(__ARM_ARCH) || defined(_TMS320C6X) || defined(__C7000__) ||     defined(__ARP32__)  || defined(__MSP430__) || defined(__PRU__)
S    #define  INT_FAST64_MAX  (INT64_MAX)
S    #define  INT_FAST64_MIN  (INT64_MIN)
S    #define UINT_FAST64_MAX  (UINT64_MAX)
S#elif defined(__TMS320C2000__)
S#if defined(__TMS320C28X__) || \
S    (defined(__TMS320C28XX_CLA__) && defined(__TI_EABI__))
X#if defined(__TMS320C28X__) ||     (defined(__TMS320C28XX_CLA__) && defined(__TI_EABI__))
S    #define  INT_FAST64_MAX  (INT64_MAX)
S    #define  INT_FAST64_MIN  (INT64_MIN)
S    #define UINT_FAST64_MAX  (UINT64_MAX)
S#endif
S#endif
S
S#if defined(__MSP430__) && !defined(__LARGE_CODE_MODEL__)
S    #define INTPTR_MAX   (INT16_MAX)
S    #define INTPTR_MIN   (INT16_MIN)
S    #define UINTPTR_MAX  (UINT16_MAX)
S#elif defined(__C7000__)
S    #define INTPTR_MAX   (INT64_MAX)
S    #define INTPTR_MIN   (INT64_MIN)
S    #define UINTPTR_MAX  (UINT64_MAX)
S#else
S    #define INTPTR_MAX   (INT32_MAX)
S    #define INTPTR_MIN   (INT32_MIN)
S    #define UINTPTR_MAX  (UINT32_MAX)
S#endif
S
S#if defined(__ARM_ARCH) || defined(_TMS320C6X) || defined(__C7000__) || \
S    defined(__ARP32__)  || defined(__MSP430__) || defined(__PRU__)
X#if defined(__ARM_ARCH) || defined(_TMS320C6X) || defined(__C7000__) ||     defined(__ARP32__)  || defined(__MSP430__) || defined(__PRU__)
S    #define INTMAX_MIN   (INT64_MIN)
S    #define INTMAX_MAX   (INT64_MAX)
S    #define UINTMAX_MAX  (UINT64_MAX)
S#elif defined(_TMS320C5XX)
S    #define INTMAX_MIN   (INT32_MIN)
S    #define INTMAX_MAX   (INT32_MAX)
S    #define UINTMAX_MAX  (UINT32_MAX)
S#elif defined(__TMS320C2000__)
S#if defined(__TMS320C28X__) || \
S    (defined(__TMS320C28XX_CLA__) && defined(__TI_EABI__))
X#if defined(__TMS320C28X__) ||     (defined(__TMS320C28XX_CLA__) && defined(__TI_EABI__))
S    #define INTMAX_MIN   (INT64_MIN)
S    #define INTMAX_MAX   (INT64_MAX)
S    #define UINTMAX_MAX  (UINT64_MAX)
S#else
S    #define INTMAX_MIN   (INT32_MIN)
S    #define INTMAX_MAX   (INT32_MAX)
S    #define UINTMAX_MAX  (UINT32_MAX)
S#endif
S#endif
S
S/* 7.18.3 Limits of other integer types */
S
S#if defined(_TMS320C5XX) || defined(__TMS320C55X__) || \
S    (defined(__MSP430__) && !defined(__LONG_PTRDIFF_T__))
X#if defined(_TMS320C5XX) || defined(__TMS320C55X__) ||     (defined(__MSP430__) && !defined(__LONG_PTRDIFF_T__))
S    #define PTRDIFF_MAX (INT16_MAX)
S    #define PTRDIFF_MIN (INT16_MIN)
S#elif defined(__TMS320C2000__) || defined(__MSP430__) || \
S      (defined(_TMS320C6X) && !defined(__C6X_MIGRATION__)) || \
S      defined(__ARM_ARCH)      || defined(__ARP32__) || defined(__PRU__)
X#elif defined(__TMS320C2000__) || defined(__MSP430__) ||       (defined(_TMS320C6X) && !defined(__C6X_MIGRATION__)) ||       defined(__ARM_ARCH)      || defined(__ARP32__) || defined(__PRU__)
S    #define PTRDIFF_MAX (INT32_MAX)
S    #define PTRDIFF_MIN (INT32_MIN)
S#elif defined(__C7000__)
S    #define PTRDIFF_MAX (INT64_MAX)
S    #define PTRDIFF_MIN (INT64_MIN)
S#endif
S
S#if defined(_TMS320C5XX) || defined(__TMS320C55X__) || defined(__MSP430__)
S    #define SIG_ATOMIC_MIN (INT16_MIN)
S    #define SIG_ATOMIC_MAX (INT16_MAX)
S#elif defined(__TMS320C2000__) || defined(_TMS320C6X) || defined(__C7000__) || \
S      defined(__ARM_ARCH)      || defined(__ARP32__)  || defined(__PRU__)
X#elif defined(__TMS320C2000__) || defined(_TMS320C6X) || defined(__C7000__) ||       defined(__ARM_ARCH)      || defined(__ARP32__)  || defined(__PRU__)
S    #define SIG_ATOMIC_MIN (INT32_MIN)
S    #define SIG_ATOMIC_MAX (INT32_MAX)
S#endif
S
S#if defined(_TMS320C5XX) || defined(__TMS320C55X__) || \
S    (defined(__MSP430__) && !defined(__LONG_PTRDIFF_T__))
X#if defined(_TMS320C5XX) || defined(__TMS320C55X__) ||     (defined(__MSP430__) && !defined(__LONG_PTRDIFF_T__))
S    #define SIZE_MAX (UINT16_MAX)
S#elif defined(__TMS320C2000__) || defined(__MSP430__) || \
S      (defined(_TMS320C6X) && !defined(__C6X_MIGRATION__)) || \
S      defined(__ARM_ARCH)      || defined(__ARP32__)  || defined(__PRU__)
X#elif defined(__TMS320C2000__) || defined(__MSP430__) ||       (defined(_TMS320C6X) && !defined(__C6X_MIGRATION__)) ||       defined(__ARM_ARCH)      || defined(__ARP32__)  || defined(__PRU__)
S    #define SIZE_MAX (UINT32_MAX)
S#elif defined(__C7000__)
S    #define SIZE_MAX (UINT64_MAX)
S#endif
S
S#ifndef WCHAR_MAX
S#if !defined(__TI_WCHAR_T_BITS__) || __TI_WCHAR_T_BITS__ == 16
S#define WCHAR_MAX 0xffffu
S#else 
S#define WCHAR_MAX 0xffffffffu
S#endif
S#endif
S
S#ifndef WCHAR_MIN
S#define WCHAR_MIN 0
S#endif
S
S#if defined(_TMS320C5XX) || defined(__TMS320C55X__) || defined(__MSP430__)
S    #define WINT_MIN (INT16_MIN)
S    #define WINT_MAX (INT16_MAX)
S#elif defined(__TMS320C2000__) || defined(_TMS320C6X) || defined(__C7000__) || \
S      defined(__ARM_ARCH)      || defined(__ARP32__)  || defined(__PRU__)
X#elif defined(__TMS320C2000__) || defined(_TMS320C6X) || defined(__C7000__) ||       defined(__ARM_ARCH)      || defined(__ARP32__)  || defined(__PRU__)
S    #define WINT_MIN (INT32_MIN)
S    #define WINT_MAX (INT32_MAX)
S#endif
S
S/* 7.18.4.1 Macros for minimum-width integer constants */
S
S/*
S   There is a defect report filed against the C99 standard concerning how 
S   the (U)INTN_C macros should be implemented.  Please refer to --
S   http://wwwold.dkuug.dk/JTC1/SC22/WG14/www/docs/dr_209.htm 
S   for more information.  These macros are implemented according to the
S   suggestion given at this web site.
S*/
S
S    #define  INT8_C(value)  ((int_least8_t)(value))
S    #define UINT8_C(value)  ((uint_least8_t)(value))
S    #define  INT16_C(value) ((int_least16_t)(value))
S    #define UINT16_C(value) ((uint_least16_t)(value))
S    #define  INT32_C(value) ((int_least32_t)(value))
S    #define UINT32_C(value) ((uint_least32_t)(value))
S
S#if defined(__ARM_ARCH) || defined(_TMS320C6X) || defined(__C7000__) || \
S    defined(__ARP32__)  || defined(__MSP430__) || defined(__PRU__)
X#if defined(__ARM_ARCH) || defined(_TMS320C6X) || defined(__C7000__) ||     defined(__ARP32__)  || defined(__MSP430__) || defined(__PRU__)
S    #define  INT64_C(value) ((int_least64_t)(value))
S    #define UINT64_C(value) ((uint_least64_t)(value))
S#elif defined(__TMS320C2000__)
S#if defined(__TMS320C28X__) || \
S    (defined(__TMS320C28XX_CLA__) && defined(__TI_EABI__))
X#if defined(__TMS320C28X__) ||     (defined(__TMS320C28XX_CLA__) && defined(__TI_EABI__))
S    #define  INT64_C(value) ((int_least64_t)(value))
S    #define UINT64_C(value) ((uint_least64_t)(value))
S#endif
S#endif
S
S/* 7.18.4.2 Macros for greatest-width integer constants */
S
S    #define  INTMAX_C(value) ((intmax_t)(value))
S    #define UINTMAX_C(value) ((uintmax_t)(value))
S
S#endif /* !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS) */
N#endif
N#endif /* _STDINT_H_ */
L 120 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/stdint.h" 2
N
N#endif  /* _LIBCPP_STDINT_H */
L 146 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/cstdint" 2
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N_LIBCPP_BEGIN_NAMESPACE_STD
Xnamespace std { inline namespace __2 {
N
Nusing::int8_t;
Nusing::int16_t;
Nusing::int32_t;
Nusing::int64_t;
N
Nusing::uint8_t;
Nusing::uint16_t;
Nusing::uint32_t;
Nusing::uint64_t;
N
Nusing::int_least8_t;
Nusing::int_least16_t;
Nusing::int_least32_t;
Nusing::int_least64_t;
N
Nusing::uint_least8_t;
Nusing::uint_least16_t;
Nusing::uint_least32_t;
Nusing::uint_least64_t;
N
Nusing::int_fast8_t;
Nusing::int_fast16_t;
Nusing::int_fast32_t;
Nusing::int_fast64_t;
N
Nusing::uint_fast8_t;
Nusing::uint_fast16_t;
Nusing::uint_fast32_t;
Nusing::uint_fast64_t;
N
Nusing::intptr_t;
Nusing::uintptr_t;
N
Nusing::intmax_t;
Nusing::uintmax_t;
N
N_LIBCPP_END_NAMESPACE_STD
X} }
N
N#endif  // _LIBCPP_CSTDINT
L 205 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/utility" 2
N#include <__debug>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/__debug" 1
N// -*- C++ -*-
N//===--------------------------- __debug ----------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is dual licensed under the MIT and the University of Illinois Open
N// Source Licenses. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP_DEBUG_H
N#define _LIBCPP_DEBUG_H
N
N#include <__config>
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N#if defined(_LIBCPP_HAS_NO_NULLPTR)
X#if 0L
S# include <cstddef>
N#endif
N
N#if _LIBCPP_DEBUG_LEVEL >= 1 || defined(_LIBCPP_BUILDING_LIBRARY)
X#if _LIBCPP_DEBUG_LEVEL >= 1 || 0L
S#   include <cstdlib>
S#   include <cstdio>
S#   include <cstddef>
S#   include <exception>
N#endif
N
N#if _LIBCPP_DEBUG_LEVEL >= 1 && !defined(_LIBCPP_ASSERT)
X#if _LIBCPP_DEBUG_LEVEL >= 1 && !0L
S# ifdef _LIBCPP_COMPILER_TI
S#  define _LIBCPP_ASSERT(x, m) ((x) ? (void)0 : \
S   _VSTD::__libcpp_debug_function(_VSTD::__libcpp_debug_info("", 0, #x, m)))
X#  define _LIBCPP_ASSERT(x, m) ((x) ? (void)0 :    _VSTD::__libcpp_debug_function(_VSTD::__libcpp_debug_info("", 0, #x, m)))
S# else
S#  define _LIBCPP_ASSERT(x, m) ((x) ? (void)0 : \
S   _VSTD::__libcpp_debug_function(_VSTD::__libcpp_debug_info(__FILE__, __LINE__, #x, m)))
X#  define _LIBCPP_ASSERT(x, m) ((x) ? (void)0 :    _VSTD::__libcpp_debug_function(_VSTD::__libcpp_debug_info(__FILE__, __LINE__, #x, m)))
S# endif
N#endif
N
N#if _LIBCPP_DEBUG_LEVEL >= 2
S#ifndef _LIBCPP_DEBUG_ASSERT
S#define _LIBCPP_DEBUG_ASSERT(x, m) _LIBCPP_ASSERT(x, m)
S#endif
S#define _LIBCPP_DEBUG_MODE(...) __VA_ARGS__
N#endif
N
N#ifndef _LIBCPP_ASSERT
N#   define _LIBCPP_ASSERT(x, m) ((void)0)
N#endif
N#ifndef _LIBCPP_DEBUG_ASSERT
N#   define _LIBCPP_DEBUG_ASSERT(x, m) ((void)0)
N#endif
N#ifndef _LIBCPP_DEBUG_MODE
N#define _LIBCPP_DEBUG_MODE(...) ((void)0)
N#endif
N
N#if _LIBCPP_DEBUG_LEVEL < 1
Nclass _LIBCPP_EXCEPTION_ABI __libcpp_debug_exception;
Xclass  __libcpp_debug_exception;
N#endif
N
N_LIBCPP_BEGIN_NAMESPACE_STD
Xnamespace std { inline namespace __2 {
N
Nstruct _LIBCPP_TEMPLATE_VIS __libcpp_debug_info {
Xstruct  __libcpp_debug_info {
N  _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
X  __attribute__ ((__always_inline__)) constexpr
N  __libcpp_debug_info()
N      : __file_(nullptr), __line_(-1), __pred_(nullptr), __msg_(nullptr) {}
N  _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
X  __attribute__ ((__always_inline__)) constexpr
N  __libcpp_debug_info(const char* __f, int __l, const char* __p, const char* __m)
N    : __file_(__f), __line_(__l), __pred_(__p), __msg_(__m) {}
N  const char* __file_;
N  int __line_;
N  const char* __pred_;
N  const char* __msg_;
N};
N
N/// __libcpp_debug_function_type - The type of the assertion failure handler.
Ntypedef void(*__libcpp_debug_function_type)(__libcpp_debug_info const&);
N
N/// __libcpp_debug_function - The handler function called when a _LIBCPP_ASSERT
N///    fails.
Nextern _LIBCPP_EXTERN_VIS __libcpp_debug_function_type __libcpp_debug_function;
Xextern  __libcpp_debug_function_type __libcpp_debug_function;
N
N/// __libcpp_abort_debug_function - A debug handler that aborts when called.
N_LIBCPP_NORETURN _LIBCPP_FUNC_VIS
X[[noreturn]] 
Nvoid __libcpp_abort_debug_function(__libcpp_debug_info const&);
N
N/// __libcpp_throw_debug_function - A debug handler that throws
N///   an instance of __libcpp_debug_exception when called.
N _LIBCPP_NORETURN _LIBCPP_FUNC_VIS
X [[noreturn]] 
Nvoid __libcpp_throw_debug_function(__libcpp_debug_info const&);
N
N/// __libcpp_set_debug_function - Set the debug handler to the specified
N///    function.
N_LIBCPP_FUNC_VIS
X
Nbool __libcpp_set_debug_function(__libcpp_debug_function_type __func);
N
N// Setup the throwing debug handler during dynamic initialization.
N#if _LIBCPP_DEBUG_LEVEL >= 1 && defined(_LIBCPP_DEBUG_USE_EXCEPTIONS)
X#if _LIBCPP_DEBUG_LEVEL >= 1 && 0L
S# if defined(_LIBCPP_NO_EXCEPTIONS)
S#   error _LIBCPP_DEBUG_USE_EXCEPTIONS cannot be used when exceptions are disabled.
S# endif
Sstatic bool __init_dummy = __libcpp_set_debug_function(__libcpp_throw_debug_function);
N#endif
N
N#if _LIBCPP_DEBUG_LEVEL >= 1 || defined(_LIBCPP_BUILDING_LIBRARY)
X#if _LIBCPP_DEBUG_LEVEL >= 1 || 0L
Sclass _LIBCPP_EXCEPTION_ABI __libcpp_debug_exception : public exception {
Spublic:
S  __libcpp_debug_exception() _NOEXCEPT;
S  explicit __libcpp_debug_exception(__libcpp_debug_info const& __i);
S  __libcpp_debug_exception(__libcpp_debug_exception const&);
S  ~__libcpp_debug_exception() _NOEXCEPT;
S  const char* what() const _NOEXCEPT;
Sprivate:
S  struct __libcpp_debug_exception_imp;
S  __libcpp_debug_exception_imp *__imp_;
S};
N#endif
N
N#if _LIBCPP_DEBUG_LEVEL >= 2 || defined(_LIBCPP_BUILDING_LIBRARY)
X#if _LIBCPP_DEBUG_LEVEL >= 2 || 0L
S
Sstruct _LIBCPP_TYPE_VIS __c_node;
S
Sstruct _LIBCPP_TYPE_VIS __i_node
S{
S    void* __i_;
S    __i_node* __next_;
S    __c_node* __c_;
S
S#ifndef _LIBCPP_CXX03_LANG
S    __i_node(const __i_node&) = delete;
S    __i_node& operator=(const __i_node&) = delete;
S#else
Sprivate:
S    __i_node(const __i_node&);
S    __i_node& operator=(const __i_node&);
Spublic:
S#endif
S    _LIBCPP_INLINE_VISIBILITY
S    __i_node(void* __i, __i_node* __next, __c_node* __c)
S        : __i_(__i), __next_(__next), __c_(__c) {}
S    ~__i_node();
S};
S
Sstruct _LIBCPP_TYPE_VIS __c_node
S{
S    void* __c_;
S    __c_node* __next_;
S    __i_node** beg_;
S    __i_node** end_;
S    __i_node** cap_;
S
S#ifndef _LIBCPP_CXX03_LANG
S    __c_node(const __c_node&) = delete;
S    __c_node& operator=(const __c_node&) = delete;
S#else
Sprivate:
S    __c_node(const __c_node&);
S    __c_node& operator=(const __c_node&);
Spublic:
S#endif
S    _LIBCPP_INLINE_VISIBILITY
S    __c_node(void* __c, __c_node* __next)
S        : __c_(__c), __next_(__next), beg_(nullptr), end_(nullptr), cap_(nullptr) {}
S    virtual ~__c_node();
S
S    virtual bool __dereferenceable(const void*) const = 0;
S    virtual bool __decrementable(const void*) const = 0;
S    virtual bool __addable(const void*, ptrdiff_t) const = 0;
S    virtual bool __subscriptable(const void*, ptrdiff_t) const = 0;
S
S    void __add(__i_node* __i);
S    _LIBCPP_HIDDEN void __remove(__i_node* __i);
S};
S
Stemplate <class _Cont>
Sstruct _C_node
S    : public __c_node
S{
S    _C_node(void* __c, __c_node* __n)
S        : __c_node(__c, __n) {}
S
S    virtual bool __dereferenceable(const void*) const;
S    virtual bool __decrementable(const void*) const;
S    virtual bool __addable(const void*, ptrdiff_t) const;
S    virtual bool __subscriptable(const void*, ptrdiff_t) const;
S};
S
Stemplate <class _Cont>
Sinline bool
S_C_node<_Cont>::__dereferenceable(const void* __i) const
S{
S    typedef typename _Cont::const_iterator iterator;
S    const iterator* __j = static_cast<const iterator*>(__i);
S    _Cont* _Cp = static_cast<_Cont*>(__c_);
S    return _Cp->__dereferenceable(__j);
S}
S
Stemplate <class _Cont>
Sinline bool
S_C_node<_Cont>::__decrementable(const void* __i) const
S{
S    typedef typename _Cont::const_iterator iterator;
S    const iterator* __j = static_cast<const iterator*>(__i);
S    _Cont* _Cp = static_cast<_Cont*>(__c_);
S    return _Cp->__decrementable(__j);
S}
S
Stemplate <class _Cont>
Sinline bool
S_C_node<_Cont>::__addable(const void* __i, ptrdiff_t __n) const
S{
S    typedef typename _Cont::const_iterator iterator;
S    const iterator* __j = static_cast<const iterator*>(__i);
S    _Cont* _Cp = static_cast<_Cont*>(__c_);
S    return _Cp->__addable(__j, __n);
S}
S
Stemplate <class _Cont>
Sinline bool
S_C_node<_Cont>::__subscriptable(const void* __i, ptrdiff_t __n) const
S{
S    typedef typename _Cont::const_iterator iterator;
S    const iterator* __j = static_cast<const iterator*>(__i);
S    _Cont* _Cp = static_cast<_Cont*>(__c_);
S    return _Cp->__subscriptable(__j, __n);
S}
S
Sclass _LIBCPP_TYPE_VIS __libcpp_db
S{
S    __c_node** __cbeg_;
S    __c_node** __cend_;
S    size_t   __csz_;
S    __i_node** __ibeg_;
S    __i_node** __iend_;
S    size_t   __isz_;
S
S    __libcpp_db();
Spublic:
S#ifndef _LIBCPP_CXX03_LANG
S    __libcpp_db(const __libcpp_db&) = delete;
S    __libcpp_db& operator=(const __libcpp_db&) = delete;
S#else
Sprivate:
S    __libcpp_db(const __libcpp_db&);
S    __libcpp_db& operator=(const __libcpp_db&);
Spublic:
S#endif
S    ~__libcpp_db();
S
S    class __db_c_iterator;
S    class __db_c_const_iterator;
S    class __db_i_iterator;
S    class __db_i_const_iterator;
S
S    __db_c_const_iterator __c_end() const;
S    __db_i_const_iterator __i_end() const;
S
S    template <class _Cont>
S    _LIBCPP_INLINE_VISIBILITY
S    void __insert_c(_Cont* __c)
S    {
S        __c_node* __n = __insert_c(static_cast<void*>(__c));
S        ::new(__n) _C_node<_Cont>(__n->__c_, __n->__next_);
S    }
S
S    void __insert_i(void* __i);
S    __c_node* __insert_c(void* __c);
S    void __erase_c(void* __c);
S
S    void __insert_ic(void* __i, const void* __c);
S    void __iterator_copy(void* __i, const void* __i0);
S    void __erase_i(void* __i);
S
S    void* __find_c_from_i(void* __i) const;
S    void __invalidate_all(void* __c);
S    __c_node* __find_c_and_lock(void* __c) const;
S    __c_node* __find_c(void* __c) const;
S    void unlock() const;
S
S    void swap(void* __c1, void* __c2);
S
S
S    bool __dereferenceable(const void* __i) const;
S    bool __decrementable(const void* __i) const;
S    bool __addable(const void* __i, ptrdiff_t __n) const;
S    bool __subscriptable(const void* __i, ptrdiff_t __n) const;
S    bool __less_than_comparable(const void* __i, const void* __j) const;
Sprivate:
S    _LIBCPP_HIDDEN
S    __i_node* __insert_iterator(void* __i);
S    _LIBCPP_HIDDEN
S    __i_node* __find_iterator(const void* __i) const;
S
S    friend _LIBCPP_FUNC_VIS __libcpp_db* __get_db();
S};
S
S_LIBCPP_FUNC_VIS __libcpp_db* __get_db();
S_LIBCPP_FUNC_VIS const __libcpp_db* __get_const_db();
S
S
N#endif // _LIBCPP_DEBUG_LEVEL >= 2 || defined(_LIBCPP_BUILDING_LIBRARY)
N
N_LIBCPP_END_NAMESPACE_STD
X} }
N
N#endif  // _LIBCPP_DEBUG_H
N
L 206 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/utility" 2
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N_LIBCPP_BEGIN_NAMESPACE_STD
Xnamespace std { inline namespace __2 {
N
Nnamespace rel_ops
N{
N
Ntemplate<class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator!=(const _Tp& __x, const _Tp& __y)
N{
N    return !(__x == __y);
N}
N
Ntemplate<class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator> (const _Tp& __x, const _Tp& __y)
N{
N    return __y < __x;
N}
N
Ntemplate<class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator<=(const _Tp& __x, const _Tp& __y)
N{
N    return !(__y < __x);
N}
N
Ntemplate<class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator>=(const _Tp& __x, const _Tp& __y)
N{
N    return !(__x < __y);
N}
N
N}  // rel_ops
N
N// swap_ranges
N
N
Ntemplate <class _ForwardIterator1, class _ForwardIterator2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_ForwardIterator2
Nswap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2)
N{
N    for(; __first1 != __last1; ++__first1, (void) ++__first2)
N        swap(*__first1, *__first2);
N    return __first2;
N}
N
N// forward declared in <type_traits>
Ntemplate<class _Tp, size_t _Np>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename enable_if<
N    __is_swappable<_Tp>::value
N>::type
Nswap(_Tp (&__a)[_Np], _Tp (&__b)[_Np]) _NOEXCEPT_(__is_nothrow_swappable<_Tp>::value)
Xswap(_Tp (&__a)[_Np], _Tp (&__b)[_Np]) noexcept(__is_nothrow_swappable<_Tp> ::value)
N{
N    _VSTD::swap_ranges(__a, __a + _Np, __b);
X    std::__2::swap_ranges(__a, __a + _Np, __b);
N}
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
Xinline __attribute__ ((__always_inline__)) constexpr
N#ifndef _LIBCPP_CXX03_LANG
Ntypename conditional
N<
N    !is_nothrow_move_constructible<_Tp>::value && is_copy_constructible<_Tp>::value,
N    const _Tp&,
N    _Tp&&
N>::type
N#else  // _LIBCPP_CXX03_LANG
Sconst _Tp&
N#endif
Nmove_if_noexcept(_Tp& __x) _NOEXCEPT
Xmove_if_noexcept(_Tp& __x) noexcept
N{
N    return _VSTD::move(__x);
X    return std::__2::move(__x);
N}
N
N#if _LIBCPP_STD_VER > 14
X#if 14 > 14
Stemplate <class _Tp> constexpr add_const_t<_Tp>& as_const(_Tp& __t) noexcept { return __t; }
Stemplate <class _Tp>                        void as_const(const _Tp&&) = delete;
N#endif
N
Nstruct _LIBCPP_TEMPLATE_VIS piecewise_construct_t { };
Xstruct  piecewise_construct_t { };
N#if defined(_LIBCPP_CXX03_LANG) || defined(_LIBCPP_BUILDING_UTILITY)
X#if 0L || 0L
Sextern const piecewise_construct_t piecewise_construct;// = piecewise_construct_t();
N#else
Nconstexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();
N#endif
N
N#if defined(_LIBCPP_DEPRECATED_ABI_DISABLE_PAIR_TRIVIAL_COPY_CTOR)
X#if 0L
Sstruct __non_trivially_copyable_base {
S  _LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY
S  __non_trivially_copyable_base() _NOEXCEPT {}
S  _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
S  __non_trivially_copyable_base(__non_trivially_copyable_base const&) _NOEXCEPT {}
S};
N#endif
N
Ntemplate <class _T1, class _T2>
Nstruct _LIBCPP_TEMPLATE_VIS pair
Xstruct  pair
N#if defined(_LIBCPP_DEPRECATED_ABI_DISABLE_PAIR_TRIVIAL_COPY_CTOR)
X#if 0L
S: private __non_trivially_copyable_base
N#endif
N{
N    typedef _T1 first_type;
N    typedef _T2 second_type;
N
N    _T1 first;
N    _T2 second;
N
N#if !defined(_LIBCPP_CXX03_LANG)
X#if !0L
N    pair(pair const&) = default;
N    pair(pair&&) = default;
N#else
S  // Use the implicitly declared copy constructor in C++03
N#endif
N
N#ifdef _LIBCPP_CXX03_LANG
S    _LIBCPP_INLINE_VISIBILITY
S    pair() : first(), second() {}
S
S    _LIBCPP_INLINE_VISIBILITY
S    pair(_T1 const& __t1, _T2 const& __t2) : first(__t1), second(__t2) {}
S
S    template <class _U1, class _U2>
S    _LIBCPP_INLINE_VISIBILITY
S    pair(const pair<_U1, _U2>& __p) : first(__p.first), second(__p.second) {}
S
S    _LIBCPP_INLINE_VISIBILITY
S    pair& operator=(pair const& __p) {
S        first = __p.first;
S        second = __p.second;
S        return *this;
S    }
N#else
N    template <bool _Val>
N    using _EnableB = typename enable_if<_Val, bool>::type;
N
N    struct _CheckArgs {
N      template <class _U1, class _U2>
N      static constexpr bool __enable_default() {
N          return is_default_constructible<_U1>::value
N              && is_default_constructible<_U2>::value;
N      }
N
N      template <class _U1, class _U2>
N      static constexpr bool __enable_explicit() {
N          return is_constructible<first_type, _U1>::value
N              && is_constructible<second_type, _U2>::value
N              && (!is_convertible<_U1, first_type>::value
N                  || !is_convertible<_U2, second_type>::value);
N      }
N
N      template <class _U1, class _U2>
N      static constexpr bool __enable_implicit() {
N          return is_constructible<first_type, _U1>::value
N              && is_constructible<second_type, _U2>::value
N              && is_convertible<_U1, first_type>::value
N              && is_convertible<_U2, second_type>::value;
N      }
N    };
N
N    template <bool _MaybeEnable>
N    using _CheckArgsDep = typename conditional<
N      _MaybeEnable, _CheckArgs, __check_tuple_constructor_fail>::type;
N
N    struct _CheckTupleLikeConstructor {
N        template <class _Tuple>
N        static constexpr bool __enable_implicit() {
N            return __tuple_convertible<_Tuple, pair>::value;
N        }
N
N        template <class _Tuple>
N        static constexpr bool __enable_explicit() {
N            return __tuple_constructible<_Tuple, pair>::value
N               && !__tuple_convertible<_Tuple, pair>::value;
N        }
N
N        template <class _Tuple>
N        static constexpr bool __enable_assign() {
N            return __tuple_assignable<_Tuple, pair>::value;
N        }
N    };
N
N    template <class _Tuple>
N    using _CheckTLC = typename conditional<
N        __tuple_like_with_size<_Tuple, 2>::value
N            && !is_same<typename decay<_Tuple>::type, pair>::value,
N        _CheckTupleLikeConstructor,
N        __check_tuple_constructor_fail
N    >::type;
N
N    template<bool _Dummy = true, _EnableB<
N            _CheckArgsDep<_Dummy>::template __enable_default<_T1, _T2>()
N    > = false>
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
X    __attribute__ ((__always_inline__)) constexpr
N    pair() : first(), second() {}
N
N    template <bool _Dummy = true, _EnableB<
N             _CheckArgsDep<_Dummy>::template __enable_explicit<_T1 const&, _T2 const&>()
N    > = false>
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
X    __attribute__ ((__always_inline__)) constexpr
N    explicit pair(_T1 const& __t1, _T2 const& __t2)
N        : first(__t1), second(__t2) {}
N
N    template<bool _Dummy = true, _EnableB<
N            _CheckArgsDep<_Dummy>::template __enable_implicit<_T1 const&, _T2 const&>()
N    > = false>
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
X    __attribute__ ((__always_inline__)) constexpr
N    pair(_T1 const& __t1, _T2 const& __t2)
N        : first(__t1), second(__t2) {}
N
N    template<class _U1, class _U2, _EnableB<
N             _CheckArgs::template __enable_explicit<_U1, _U2>()
N    > = false>
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
X    __attribute__ ((__always_inline__)) constexpr
N    explicit pair(_U1&& __u1, _U2&& __u2)
N        : first(_VSTD::forward<_U1>(__u1)), second(_VSTD::forward<_U2>(__u2)) {}
X        : first(std::__2::forward<_U1>(__u1)), second(std::__2::forward<_U2>(__u2)) {}
N
N    template<class _U1, class _U2, _EnableB<
N            _CheckArgs::template __enable_implicit<_U1, _U2>()
N    > = false>
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
X    __attribute__ ((__always_inline__)) constexpr
N    pair(_U1&& __u1, _U2&& __u2)
N        : first(_VSTD::forward<_U1>(__u1)), second(_VSTD::forward<_U2>(__u2)) {}
X        : first(std::__2::forward<_U1>(__u1)), second(std::__2::forward<_U2>(__u2)) {}
N
N    template<class _U1, class _U2, _EnableB<
N            _CheckArgs::template __enable_explicit<_U1 const&, _U2 const&>()
N    > = false>
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
X    __attribute__ ((__always_inline__)) constexpr
N    explicit pair(pair<_U1, _U2> const& __p)
N        : first(__p.first), second(__p.second) {}
N
N    template<class _U1, class _U2, _EnableB<
N            _CheckArgs::template __enable_implicit<_U1 const&, _U2 const&>()
N    > = false>
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
X    __attribute__ ((__always_inline__)) constexpr
N    pair(pair<_U1, _U2> const& __p)
N        : first(__p.first), second(__p.second) {}
N
N    template<class _U1, class _U2, _EnableB<
N            _CheckArgs::template __enable_explicit<_U1, _U2>()
N    > = false>
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
X    __attribute__ ((__always_inline__)) constexpr
N    explicit pair(pair<_U1, _U2>&&__p)
N        : first(_VSTD::forward<_U1>(__p.first)), second(_VSTD::forward<_U2>(__p.second)) {}
X        : first(std::__2::forward<_U1>(__p.first)), second(std::__2::forward<_U2>(__p.second)) {}
N
N    template<class _U1, class _U2, _EnableB<
N            _CheckArgs::template __enable_implicit<_U1, _U2>()
N    > = false>
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
X    __attribute__ ((__always_inline__)) constexpr
N    pair(pair<_U1, _U2>&& __p)
N        : first(_VSTD::forward<_U1>(__p.first)), second(_VSTD::forward<_U2>(__p.second)) {}
X        : first(std::__2::forward<_U1>(__p.first)), second(std::__2::forward<_U2>(__p.second)) {}
N
N    template<class _Tuple, _EnableB<
N            _CheckTLC<_Tuple>::template __enable_explicit<_Tuple>()
N    > = false>
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
X    __attribute__ ((__always_inline__)) constexpr
N    explicit pair(_Tuple&& __p)
N        : first(_VSTD::get<0>(_VSTD::forward<_Tuple>(__p))),
X        : first(std::__2::get<0>(std::__2::forward<_Tuple>(__p))),
N          second(_VSTD::get<1>(_VSTD::forward<_Tuple>(__p))) {}
X          second(std::__2::get<1>(std::__2::forward<_Tuple>(__p))) {}
N
N    template<class _Tuple, _EnableB<
N            _CheckTLC<_Tuple>::template __enable_implicit<_Tuple>()
N    > = false>
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
X    __attribute__ ((__always_inline__)) constexpr
N    pair(_Tuple&& __p)
N        : first(_VSTD::get<0>(_VSTD::forward<_Tuple>(__p))),
X        : first(std::__2::get<0>(std::__2::forward<_Tuple>(__p))),
N          second(_VSTD::get<1>(_VSTD::forward<_Tuple>(__p))) {}
X          second(std::__2::get<1>(std::__2::forward<_Tuple>(__p))) {}
N
N    template <class... _Args1, class... _Args2>
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    pair(piecewise_construct_t __pc,
N         tuple<_Args1...> __first_args, tuple<_Args2...> __second_args)
N        : pair(__pc, __first_args, __second_args,
N                typename __make_tuple_indices<sizeof...(_Args1)>::type(),
N                typename __make_tuple_indices<sizeof...(_Args2) >::type()) {}
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    pair& operator=(typename conditional<
N                        is_copy_assignable<first_type>::value &&
N                        is_copy_assignable<second_type>::value,
N                    pair, __nat>::type const& __p)
N        _NOEXCEPT_(is_nothrow_copy_assignable<first_type>::value &&
N                   is_nothrow_copy_assignable<second_type>::value)
X        noexcept(is_nothrow_copy_assignable<first_type> ::value && is_nothrow_copy_assignable<second_type> ::value)
N    {
N        first = __p.first;
N        second = __p.second;
N        return *this;
N    }
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    pair& operator=(typename conditional<
N                        is_move_assignable<first_type>::value &&
N                        is_move_assignable<second_type>::value,
N                    pair, __nat>::type&& __p)
N        _NOEXCEPT_(is_nothrow_move_assignable<first_type>::value &&
N                   is_nothrow_move_assignable<second_type>::value)
X        noexcept(is_nothrow_move_assignable<first_type> ::value && is_nothrow_move_assignable<second_type> ::value)
N    {
N        first = _VSTD::forward<first_type>(__p.first);
X        first = std::__2::forward<first_type>(__p.first);
N        second = _VSTD::forward<second_type>(__p.second);
X        second = std::__2::forward<second_type>(__p.second);
N        return *this;
N    }
N
N    template <class _Tuple, _EnableB<
N            _CheckTLC<_Tuple>::template __enable_assign<_Tuple>()
N     > = false>
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    pair& operator=(_Tuple&& __p) {
N        first = _VSTD::get<0>(_VSTD::forward<_Tuple>(__p));
X        first = std::__2::get<0>(std::__2::forward<_Tuple>(__p));
N        second = _VSTD::get<1>(_VSTD::forward<_Tuple>(__p));
X        second = std::__2::get<1>(std::__2::forward<_Tuple>(__p));
N        return *this;
N    }
N#endif
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    void
N    swap(pair& __p) _NOEXCEPT_(__is_nothrow_swappable<first_type>::value &&
N                               __is_nothrow_swappable<second_type>::value)
X    swap(pair& __p) noexcept(__is_nothrow_swappable<first_type> ::value && __is_nothrow_swappable<second_type> ::value)
N    {
N        using _VSTD::swap;
X        using std::__2::swap;
N        swap(first,  __p.first);
N        swap(second, __p.second);
N    }
Nprivate:
N
N#ifndef _LIBCPP_CXX03_LANG
N    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        pair(piecewise_construct_t,
N             tuple<_Args1...>& __first_args, tuple<_Args2...>& __second_args,
N             __tuple_indices<_I1...>, __tuple_indices<_I2...>);
N#endif
N};
N
N#ifndef _LIBCPP_HAS_NO_DEDUCTION_GUIDES
Stemplate<class _T1, class _T2>
Spair(_T1, _T2) -> pair<_T1, _T2>;
N#endif // _LIBCPP_HAS_NO_DEDUCTION_GUIDES
N
Ntemplate <class _T1, class _T2>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
Xinline __attribute__ ((__always_inline__)) constexpr
Nbool
Noperator==(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
N{
N    return __x.first == __y.first && __x.second == __y.second;
N}
N
Ntemplate <class _T1, class _T2>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
Xinline __attribute__ ((__always_inline__)) constexpr
Nbool
Noperator!=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
N{
N    return !(__x == __y);
N}
N
Ntemplate <class _T1, class _T2>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
Xinline __attribute__ ((__always_inline__)) constexpr
Nbool
Noperator< (const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
N{
N    return __x.first < __y.first || (!(__y.first < __x.first) && __x.second < __y.second);
N}
N
Ntemplate <class _T1, class _T2>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
Xinline __attribute__ ((__always_inline__)) constexpr
Nbool
Noperator> (const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
N{
N    return __y < __x;
N}
N
Ntemplate <class _T1, class _T2>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
Xinline __attribute__ ((__always_inline__)) constexpr
Nbool
Noperator>=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
N{
N    return !(__x < __y);
N}
N
Ntemplate <class _T1, class _T2>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
Xinline __attribute__ ((__always_inline__)) constexpr
Nbool
Noperator<=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
N{
N    return !(__y < __x);
N}
N
Ntemplate <class _T1, class _T2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename enable_if
N<
N    __is_swappable<_T1>::value &&
N    __is_swappable<_T2>::value,
N    void
N>::type
Nswap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
N                     _NOEXCEPT_((__is_nothrow_swappable<_T1>::value &&
N                                 __is_nothrow_swappable<_T2>::value))
X                     noexcept((__is_nothrow_swappable<_T1> ::value && __is_nothrow_swappable<_T2> ::value))
N{
N    __x.swap(__y);
N}
N
N#ifndef _LIBCPP_CXX03_LANG
N
Ntemplate <class _Tp>
Nstruct __make_pair_return_impl
N{
N    typedef _Tp type;
N};
N
Ntemplate <class _Tp>
Nstruct __make_pair_return_impl<reference_wrapper<_Tp>>
N{
N    typedef _Tp& type;
N};
N
Ntemplate <class _Tp>
Nstruct __make_pair_return
N{
N    typedef typename __make_pair_return_impl<typename decay<_Tp>::type>::type type;
N};
N
Ntemplate <class _T1, class _T2>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
Xinline __attribute__ ((__always_inline__)) constexpr
Npair<typename __make_pair_return<_T1>::type, typename __make_pair_return<_T2>::type>
Nmake_pair(_T1&& __t1, _T2&& __t2)
N{
N    return pair<typename __make_pair_return<_T1>::type, typename __make_pair_return<_T2>::type>
N               (_VSTD::forward<_T1>(__t1), _VSTD::forward<_T2>(__t2));
X               (std::__2::forward<_T1>(__t1), std::__2::forward<_T2>(__t2));
N}
N
N#else  // _LIBCPP_CXX03_LANG
S
Stemplate <class _T1, class _T2>
Sinline _LIBCPP_INLINE_VISIBILITY
Spair<_T1,_T2>
Smake_pair(_T1 __x, _T2 __y)
S{
S    return pair<_T1, _T2>(__x, __y);
S}
S
N#endif  // _LIBCPP_CXX03_LANG
N
Ntemplate <class _T1, class _T2>
N  class _LIBCPP_TEMPLATE_VIS tuple_size<pair<_T1, _T2> >
X  class  tuple_size<pair<_T1, _T2> >
N    : public integral_constant<size_t, 2> {};
N
Ntemplate <size_t _Ip, class _T1, class _T2>
Nclass _LIBCPP_TEMPLATE_VIS tuple_element<_Ip, pair<_T1, _T2> >
Xclass  tuple_element<_Ip, pair<_T1, _T2> >
N{
N    static_assert(_Ip < 2, "Index out of bounds in std::tuple_element<std::pair<T1, T2>>");
N};
N
Ntemplate <class _T1, class _T2>
Nclass _LIBCPP_TEMPLATE_VIS tuple_element<0, pair<_T1, _T2> >
Xclass  tuple_element<0, pair<_T1, _T2> >
N{
Npublic:
N    typedef _T1 type;
N};
N
Ntemplate <class _T1, class _T2>
Nclass _LIBCPP_TEMPLATE_VIS tuple_element<1, pair<_T1, _T2> >
Xclass  tuple_element<1, pair<_T1, _T2> >
N{
Npublic:
N    typedef _T2 type;
N};
N
Ntemplate <size_t _Ip> struct __get_pair;
N
Ntemplate <>
Nstruct __get_pair<0>
N{
N    template <class _T1, class _T2>
N    static
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
X    __attribute__ ((__always_inline__)) constexpr
N    _T1&
N    get(pair<_T1, _T2>& __p) _NOEXCEPT {return __p.first;}
X    get(pair<_T1, _T2>& __p) noexcept {return __p.first;}
N
N    template <class _T1, class _T2>
N    static
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
X    __attribute__ ((__always_inline__)) constexpr
N    const _T1&
N    get(const pair<_T1, _T2>& __p) _NOEXCEPT {return __p.first;}
X    get(const pair<_T1, _T2>& __p) noexcept {return __p.first;}
N
N#ifndef _LIBCPP_CXX03_LANG
N    template <class _T1, class _T2>
N    static
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
X    __attribute__ ((__always_inline__)) constexpr
N    _T1&&
N    get(pair<_T1, _T2>&& __p) _NOEXCEPT {return _VSTD::forward<_T1>(__p.first);}
X    get(pair<_T1, _T2>&& __p) noexcept {return std::__2::forward<_T1>(__p.first);}
N
N    template <class _T1, class _T2>
N    static
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
X    __attribute__ ((__always_inline__)) constexpr
N    const _T1&&
N    get(const pair<_T1, _T2>&& __p) _NOEXCEPT {return _VSTD::forward<const _T1>(__p.first);}
X    get(const pair<_T1, _T2>&& __p) noexcept {return std::__2::forward<const _T1>(__p.first);}
N#endif  // _LIBCPP_CXX03_LANG
N};
N
Ntemplate <>
Nstruct __get_pair<1>
N{
N    template <class _T1, class _T2>
N    static
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
X    __attribute__ ((__always_inline__)) constexpr
N    _T2&
N    get(pair<_T1, _T2>& __p) _NOEXCEPT {return __p.second;}
X    get(pair<_T1, _T2>& __p) noexcept {return __p.second;}
N
N    template <class _T1, class _T2>
N    static
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
X    __attribute__ ((__always_inline__)) constexpr
N    const _T2&
N    get(const pair<_T1, _T2>& __p) _NOEXCEPT {return __p.second;}
X    get(const pair<_T1, _T2>& __p) noexcept {return __p.second;}
N
N#ifndef _LIBCPP_CXX03_LANG
N    template <class _T1, class _T2>
N    static
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
X    __attribute__ ((__always_inline__)) constexpr
N    _T2&&
N    get(pair<_T1, _T2>&& __p) _NOEXCEPT {return _VSTD::forward<_T2>(__p.second);}
X    get(pair<_T1, _T2>&& __p) noexcept {return std::__2::forward<_T2>(__p.second);}
N
N    template <class _T1, class _T2>
N    static
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
X    __attribute__ ((__always_inline__)) constexpr
N    const _T2&&
N    get(const pair<_T1, _T2>&& __p) _NOEXCEPT {return _VSTD::forward<const _T2>(__p.second);}
X    get(const pair<_T1, _T2>&& __p) noexcept {return std::__2::forward<const _T2>(__p.second);}
N#endif  // _LIBCPP_CXX03_LANG
N};
N
Ntemplate <size_t _Ip, class _T1, class _T2>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
Xinline __attribute__ ((__always_inline__)) constexpr
Ntypename tuple_element<_Ip, pair<_T1, _T2> >::type&
Nget(pair<_T1, _T2>& __p) _NOEXCEPT
Xget(pair<_T1, _T2>& __p) noexcept
N{
N    return __get_pair<_Ip>::get(__p);
N}
N
Ntemplate <size_t _Ip, class _T1, class _T2>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
Xinline __attribute__ ((__always_inline__)) constexpr
Nconst typename tuple_element<_Ip, pair<_T1, _T2> >::type&
Nget(const pair<_T1, _T2>& __p) _NOEXCEPT
Xget(const pair<_T1, _T2>& __p) noexcept
N{
N    return __get_pair<_Ip>::get(__p);
N}
N
N#ifndef _LIBCPP_CXX03_LANG
Ntemplate <size_t _Ip, class _T1, class _T2>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
Xinline __attribute__ ((__always_inline__)) constexpr
Ntypename tuple_element<_Ip, pair<_T1, _T2> >::type&&
Nget(pair<_T1, _T2>&& __p) _NOEXCEPT
Xget(pair<_T1, _T2>&& __p) noexcept
N{
N    return __get_pair<_Ip>::get(_VSTD::move(__p));
X    return __get_pair<_Ip>::get(std::__2::move(__p));
N}
N
Ntemplate <size_t _Ip, class _T1, class _T2>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
Xinline __attribute__ ((__always_inline__)) constexpr
Nconst typename tuple_element<_Ip, pair<_T1, _T2> >::type&&
Nget(const pair<_T1, _T2>&& __p) _NOEXCEPT
Xget(const pair<_T1, _T2>&& __p) noexcept
N{
N    return __get_pair<_Ip>::get(_VSTD::move(__p));
X    return __get_pair<_Ip>::get(std::__2::move(__p));
N}
N#endif  // _LIBCPP_CXX03_LANG
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _T1, class _T2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nconstexpr _T1 & get(pair<_T1, _T2>& __p) _NOEXCEPT
Xconstexpr _T1 & get(pair<_T1, _T2>& __p) noexcept
N{
N    return __get_pair<0>::get(__p);
N}
N
Ntemplate <class _T1, class _T2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nconstexpr _T1 const & get(pair<_T1, _T2> const& __p) _NOEXCEPT
Xconstexpr _T1 const & get(pair<_T1, _T2> const& __p) noexcept
N{
N    return __get_pair<0>::get(__p);
N}
N
Ntemplate <class _T1, class _T2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nconstexpr _T1 && get(pair<_T1, _T2>&& __p) _NOEXCEPT
Xconstexpr _T1 && get(pair<_T1, _T2>&& __p) noexcept
N{
N    return __get_pair<0>::get(_VSTD::move(__p));
X    return __get_pair<0>::get(std::__2::move(__p));
N}
N
Ntemplate <class _T1, class _T2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nconstexpr _T1 const && get(pair<_T1, _T2> const&& __p) _NOEXCEPT
Xconstexpr _T1 const && get(pair<_T1, _T2> const&& __p) noexcept
N{
N    return __get_pair<0>::get(_VSTD::move(__p));
X    return __get_pair<0>::get(std::__2::move(__p));
N}
N
Ntemplate <class _T1, class _T2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nconstexpr _T1 & get(pair<_T2, _T1>& __p) _NOEXCEPT
Xconstexpr _T1 & get(pair<_T2, _T1>& __p) noexcept
N{
N    return __get_pair<1>::get(__p);
N}
N
Ntemplate <class _T1, class _T2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nconstexpr _T1 const & get(pair<_T2, _T1> const& __p) _NOEXCEPT
Xconstexpr _T1 const & get(pair<_T2, _T1> const& __p) noexcept
N{
N    return __get_pair<1>::get(__p);
N}
N
Ntemplate <class _T1, class _T2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nconstexpr _T1 && get(pair<_T2, _T1>&& __p) _NOEXCEPT
Xconstexpr _T1 && get(pair<_T2, _T1>&& __p) noexcept
N{
N    return __get_pair<1>::get(_VSTD::move(__p));
X    return __get_pair<1>::get(std::__2::move(__p));
N}
N
Ntemplate <class _T1, class _T2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nconstexpr _T1 const && get(pair<_T2, _T1> const&& __p) _NOEXCEPT
Xconstexpr _T1 const && get(pair<_T2, _T1> const&& __p) noexcept
N{
N    return __get_pair<1>::get(_VSTD::move(__p));
X    return __get_pair<1>::get(std::__2::move(__p));
N}
N
N#endif
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
N
Ntemplate<class _Tp, _Tp... _Ip>
Nstruct _LIBCPP_TEMPLATE_VIS integer_sequence
Xstruct  integer_sequence
N{
N    typedef _Tp value_type;
N    static_assert( is_integral<_Tp>::value,
N                  "std::integer_sequence can only be instantiated with an integral type" );
N    static
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    constexpr
N    size_t
N    size() noexcept { return sizeof...(_Ip); }
N};
N
Ntemplate<size_t... _Ip>
N    using index_sequence = integer_sequence<size_t, _Ip...>;
N
N#if __has_builtin(__make_integer_seq) && !defined(_LIBCPP_TESTING_FALLBACK_MAKE_INTEGER_SEQUENCE)
X#if 0 && !0L
S
Stemplate <class _Tp, _Tp _Ep>
Susing __make_integer_sequence = __make_integer_seq<integer_sequence, _Tp, _Ep>;
S
N#else
N
Ntemplate<typename _Tp, _Tp _Np> using __make_integer_sequence_unchecked =
N  typename __detail::__make<_Np>::type::template __convert<integer_sequence, _Tp>;
N
Ntemplate <class _Tp, _Tp _Ep>
Nstruct __make_integer_sequence_checked
N{
N    static_assert(is_integral<_Tp>::value,
N                  "std::make_integer_sequence can only be instantiated with an integral type" );
N    static_assert(0 <= _Ep, "std::make_integer_sequence must have a non-negative sequence length");
N    // Workaround GCC bug by preventing bad installations when 0 <= _Ep
N    // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=68929
N    typedef __make_integer_sequence_unchecked<_Tp, 0 <= _Ep ? _Ep : 0> type;
N};
N
Ntemplate <class _Tp, _Tp _Ep>
Nusing __make_integer_sequence = typename __make_integer_sequence_checked<_Tp, _Ep>::type;
N
N#endif
N
Ntemplate<class _Tp, _Tp _Np>
N    using make_integer_sequence = __make_integer_sequence<_Tp, _Np>;
N
Ntemplate<size_t _Np>
N    using make_index_sequence = make_integer_sequence<size_t, _Np>;
N
Ntemplate<class... _Tp>
N    using index_sequence_for = make_index_sequence<sizeof...(_Tp)>;
N
N#endif  // _LIBCPP_STD_VER > 11
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate<class _T1, class _T2 = _T1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_T1 exchange(_T1& __obj, _T2 && __new_value)
N{
N    _T1 __old_value = _VSTD::move(__obj);
X    _T1 __old_value = std::__2::move(__obj);
N    __obj = _VSTD::forward<_T2>(__new_value);
X    __obj = std::__2::forward<_T2>(__new_value);
N    return __old_value;
N}
N#endif  // _LIBCPP_STD_VER > 11
N
N#if _LIBCPP_STD_VER > 14
X#if 14 > 14
S
Sstruct _LIBCPP_TYPE_VIS in_place_t {
S    explicit in_place_t() = default;
S};
S#ifndef _LIBCPP_HAS_NO_INLINE_VARIABLES
Sinline
S#endif
Sconstexpr in_place_t in_place{};
S
Stemplate <class _Tp>
Sstruct _LIBCPP_TEMPLATE_VIS in_place_type_t {
S    explicit in_place_type_t() = default;
S};
Stemplate <class _Tp>
S#ifndef _LIBCPP_HAS_NO_INLINE_VARIABLES
Sinline
S#endif
Sconstexpr in_place_type_t<_Tp> in_place_type{};
S
Stemplate <size_t _Idx>
Sstruct _LIBCPP_TYPE_VIS in_place_index_t {
S    explicit in_place_index_t() = default;
S};
Stemplate <size_t _Idx>
S#ifndef _LIBCPP_HAS_NO_INLINE_VARIABLES
Sinline
S#endif
Sconstexpr in_place_index_t<_Idx> in_place_index{};
S
Stemplate <class _Tp> struct __is_inplace_type_imp : false_type {};
Stemplate <class _Tp> struct __is_inplace_type_imp<in_place_type_t<_Tp>> : true_type {};
S
Stemplate <class _Tp>
Susing __is_inplace_type = __is_inplace_type_imp<__uncvref_t<_Tp>>;
S
Stemplate <class _Tp> struct __is_inplace_index_imp : false_type {};
Stemplate <size_t _Idx> struct __is_inplace_index_imp<in_place_index_t<_Idx>> : true_type {};
S
Stemplate <class _Tp>
Susing __is_inplace_index = __is_inplace_index_imp<__uncvref_t<_Tp>>;
S
N#endif // _LIBCPP_STD_VER > 14
N
Ntemplate <class _Arg, class _Result>
Nstruct _LIBCPP_TEMPLATE_VIS unary_function
Xstruct  unary_function
N{
N    typedef _Arg    argument_type;
N    typedef _Result result_type;
N};
N
Ntemplate <class _Size>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_Size
N__loadword(const void* __p)
N{
N    _Size __r;
N    std::memcpy(&__r, __p, sizeof(__r));
N    return __r;
N}
N
N// We use murmur2 when size_t is 32 bits, and cityhash64 when size_t
N// is 64 bits.  This is because cityhash64 uses 64bit x 64bit
N// multiplication, which can be very slow on 32-bit systems.
Ntemplate <class _Size, size_t = sizeof(_Size)*__CHAR_BIT__>
Xtemplate <class _Size, size_t = sizeof(_Size)*8>
Nstruct __murmur2_or_cityhash;
N
Ntemplate <class _Size>
Nstruct __murmur2_or_cityhash<_Size, 32>
N{
N    inline _Size operator()(const void* __key, _Size __len)
N         _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK;
X         ;
N};
N
N// murmur2
Ntemplate <class _Size>
N_Size
N__murmur2_or_cityhash<_Size, 32>::operator()(const void* __key, _Size __len)
N{
N    const _Size __m = 0x5bd1e995;
N    const _Size __r = 24;
N    _Size __h = __len;
N    const unsigned char* __data = static_cast<const unsigned char*>(__key);
N    for (; __len >= 4; __data += 4, __len -= 4)
N    {
N        _Size __k = __loadword<_Size>(__data);
N        __k *= __m;
N        __k ^= __k >> __r;
N        __k *= __m;
N        __h *= __m;
N        __h ^= __k;
N    }
N    switch (__len)
N    {
N    case 3:
N        __h ^= (_Size)(__data[2]) << 16;
N    case 2:
N        __h ^= (_Size)(__data[1]) << 8;
N    case 1:
N        __h ^= (_Size)(__data[0]);
N        __h *= __m;
N    }
N    __h ^= __h >> 13;
N    __h *= __m;
N    __h ^= __h >> 15;
N    return __h;
N}
N
Ntemplate <class _Size>
Nstruct __murmur2_or_cityhash<_Size, 64>
N{
N    inline _Size operator()(const void* __key, _Size __len)  _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK;
X    inline _Size operator()(const void* __key, _Size __len)  ;
N
N private:
N  // Some primes between 2^63 and 2^64.
N  static const _Size __k0 = 0xc3a5c85c97cb3127ULL;
N  static const _Size __k1 = 0xb492b66fbe98f273ULL;
N  static const _Size __k2 = 0x9ae16a3b2f90404fULL;
N  static const _Size __k3 = 0xc949d7c7509e6557ULL;
N
N  static _Size __rotate(_Size __val, int __shift) {
N    return __shift == 0 ? __val : ((__val >> __shift) | (__val << (64 - __shift)));
N  }
N
N  static _Size __rotate_by_at_least_1(_Size __val, int __shift) {
N    return (__val >> __shift) | (__val << (64 - __shift));
N  }
N
N  static _Size __shift_mix(_Size __val) {
N    return __val ^ (__val >> 47);
N  }
N
N  static _Size __hash_len_16(_Size __u, _Size __v)
N     _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK
X     
N  {
N    const _Size __mul = 0x9ddfea08eb382d69ULL;
N    _Size __a = (__u ^ __v) * __mul;
N    __a ^= (__a >> 47);
N    _Size __b = (__v ^ __a) * __mul;
N    __b ^= (__b >> 47);
N    __b *= __mul;
N    return __b;
N  }
N
N  static _Size __hash_len_0_to_16(const char* __s, _Size __len)
N     _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK
X     
N  {
N    if (__len > 8) {
N      const _Size __a = __loadword<_Size>(__s);
N      const _Size __b = __loadword<_Size>(__s + __len - 8);
N      return __hash_len_16(__a, __rotate_by_at_least_1(__b + __len, __len)) ^ __b;
N    }
N    if (__len >= 4) {
N      const uint32_t __a = __loadword<uint32_t>(__s);
N      const uint32_t __b = __loadword<uint32_t>(__s + __len - 4);
N      return __hash_len_16(__len + (__a << 3), __b);
N    }
N    if (__len > 0) {
N      const unsigned char __a = __s[0];
N      const unsigned char __b = __s[__len >> 1];
N      const unsigned char __c = __s[__len - 1];
N      const uint32_t __y = static_cast<uint32_t>(__a) +
N                           (static_cast<uint32_t>(__b) << 8);
N      const uint32_t __z = __len + (static_cast<uint32_t>(__c) << 2);
N      return __shift_mix(__y * __k2 ^ __z * __k3) * __k2;
N    }
N    return __k2;
N  }
N
N  static _Size __hash_len_17_to_32(const char *__s, _Size __len)
N     _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK
X     
N  {
N    const _Size __a = __loadword<_Size>(__s) * __k1;
N    const _Size __b = __loadword<_Size>(__s + 8);
N    const _Size __c = __loadword<_Size>(__s + __len - 8) * __k2;
N    const _Size __d = __loadword<_Size>(__s + __len - 16) * __k0;
N    return __hash_len_16(__rotate(__a - __b, 43) + __rotate(__c, 30) + __d,
N                         __a + __rotate(__b ^ __k3, 20) - __c + __len);
N  }
N
N  // Return a 16-byte hash for 48 bytes.  Quick and dirty.
N  // Callers do best to use "random-looking" values for a and b.
N  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(
N      _Size __w, _Size __x, _Size __y, _Size __z, _Size __a, _Size __b)
N        _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK
X        
N  {
N    __a += __w;
N    __b = __rotate(__b + __a + __z, 21);
N    const _Size __c = __a;
N    __a += __x;
N    __a += __y;
N    __b += __rotate(__a, 44);
N    return pair<_Size, _Size>(__a + __z, __b + __c);
N  }
N
N  // Return a 16-byte hash for s[0] ... s[31], a, and b.  Quick and dirty.
N  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(
N      const char* __s, _Size __a, _Size __b)
N    _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK
X    
N  {
N    return __weak_hash_len_32_with_seeds(__loadword<_Size>(__s),
N                                         __loadword<_Size>(__s + 8),
N                                         __loadword<_Size>(__s + 16),
N                                         __loadword<_Size>(__s + 24),
N                                         __a,
N                                         __b);
N  }
N
N  // Return an 8-byte hash for 33 to 64 bytes.
N  static _Size __hash_len_33_to_64(const char *__s, size_t __len)
N    _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK
X    
N  {
N    _Size __z = __loadword<_Size>(__s + 24);
N    _Size __a = __loadword<_Size>(__s) +
N                (__len + __loadword<_Size>(__s + __len - 16)) * __k0;
N    _Size __b = __rotate(__a + __z, 52);
N    _Size __c = __rotate(__a, 37);
N    __a += __loadword<_Size>(__s + 8);
N    __c += __rotate(__a, 7);
N    __a += __loadword<_Size>(__s + 16);
N    _Size __vf = __a + __z;
N    _Size __vs = __b + __rotate(__a, 31) + __c;
N    __a = __loadword<_Size>(__s + 16) + __loadword<_Size>(__s + __len - 32);
N    __z += __loadword<_Size>(__s + __len - 8);
N    __b = __rotate(__a + __z, 52);
N    __c = __rotate(__a, 37);
N    __a += __loadword<_Size>(__s + __len - 24);
N    __c += __rotate(__a, 7);
N    __a += __loadword<_Size>(__s + __len - 16);
N    _Size __wf = __a + __z;
N    _Size __ws = __b + __rotate(__a, 31) + __c;
N    _Size __r = __shift_mix((__vf + __ws) * __k2 + (__wf + __vs) * __k0);
N    return __shift_mix(__r * __k0 + __vs) * __k2;
N  }
N};
N
N// cityhash64
Ntemplate <class _Size>
N_Size
N__murmur2_or_cityhash<_Size, 64>::operator()(const void* __key, _Size __len)
N{
N  const char* __s = static_cast<const char*>(__key);
N  if (__len <= 32) {
N    if (__len <= 16) {
N      return __hash_len_0_to_16(__s, __len);
N    } else {
N      return __hash_len_17_to_32(__s, __len);
N    }
N  } else if (__len <= 64) {
N    return __hash_len_33_to_64(__s, __len);
N  }
N
N  // For strings over 64 bytes we hash the end first, and then as we
N  // loop we keep 56 bytes of state: v, w, x, y, and z.
N  _Size __x = __loadword<_Size>(__s + __len - 40);
N  _Size __y = __loadword<_Size>(__s + __len - 16) +
N              __loadword<_Size>(__s + __len - 56);
N  _Size __z = __hash_len_16(__loadword<_Size>(__s + __len - 48) + __len,
N                          __loadword<_Size>(__s + __len - 24));
N  pair<_Size, _Size> __v = __weak_hash_len_32_with_seeds(__s + __len - 64, __len, __z);
N  pair<_Size, _Size> __w = __weak_hash_len_32_with_seeds(__s + __len - 32, __y + __k1, __x);
N  __x = __x * __k1 + __loadword<_Size>(__s);
N
N  // Decrease len to the nearest multiple of 64, and operate on 64-byte chunks.
N  __len = (__len - 1) & ~static_cast<_Size>(63);
N  do {
N    __x = __rotate(__x + __y + __v.first + __loadword<_Size>(__s + 8), 37) * __k1;
N    __y = __rotate(__y + __v.second + __loadword<_Size>(__s + 48), 42) * __k1;
N    __x ^= __w.second;
N    __y += __v.first + __loadword<_Size>(__s + 40);
N    __z = __rotate(__z + __w.first, 33) * __k1;
N    __v = __weak_hash_len_32_with_seeds(__s, __v.second * __k1, __x + __w.first);
N    __w = __weak_hash_len_32_with_seeds(__s + 32, __z + __w.second,
N                                        __y + __loadword<_Size>(__s + 16));
N    std::swap(__z, __x);
N    __s += 64;
N    __len -= 64;
N  } while (__len != 0);
N  return __hash_len_16(
N      __hash_len_16(__v.first, __w.first) + __shift_mix(__y) * __k1 + __z,
N      __hash_len_16(__v.second, __w.second) + __x);
N}
N
N// JBN
Ntemplate <class _Size>
Nstruct __murmur2_or_cityhash<_Size, 16>
N{
N    inline _Size operator()(const void* __key, _Size __len)
N         _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK;
X         ;
N};
N
Ntemplate <class _Size>
N_Size
N__murmur2_or_cityhash<_Size, 16>::operator()(const void *__key, _Size __len)
N{
N    return __murmur2_or_cityhash<uint32_t>()(__key, __len) & 0x0000ffff;
N}
N
N
Ntemplate <class _Tp, size_t = sizeof(_Tp) / sizeof(size_t)>
Nstruct __scalar_hash;
N
Ntemplate <class _Tp>
Nstruct __scalar_hash<_Tp, 0>
N    : public unary_function<_Tp, size_t>
N{
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    size_t operator()(_Tp __v) const _NOEXCEPT
X    size_t operator()(_Tp __v) const noexcept
N    {
N        union
N        {
N            _Tp    __t;
N            size_t __a;
N        } __u;
N        __u.__a = 0;
N        __u.__t = __v;
N        return __u.__a;
N    }
N};
N
Ntemplate <class _Tp>
Nstruct __scalar_hash<_Tp, 1>
N    : public unary_function<_Tp, size_t>
N{
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    size_t operator()(_Tp __v) const _NOEXCEPT
X    size_t operator()(_Tp __v) const noexcept
N    {
N        union
N        {
N            _Tp    __t;
N            size_t __a;
N        } __u;
N        __u.__t = __v;
N        return __u.__a;
N    }
N};
N
Ntemplate <class _Tp>
Nstruct __scalar_hash<_Tp, 2>
N    : public unary_function<_Tp, size_t>
N{
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    size_t operator()(_Tp __v) const _NOEXCEPT
X    size_t operator()(_Tp __v) const noexcept
N    {
N        union
N        {
N            _Tp __t;
N            struct
N            {
N                size_t __a;
N                size_t __b;
N            } __s;
N        } __u;
N        __u.__t = __v;
N        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
N    }
N};
N
Ntemplate <class _Tp>
Nstruct __scalar_hash<_Tp, 3>
N    : public unary_function<_Tp, size_t>
N{
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    size_t operator()(_Tp __v) const _NOEXCEPT
X    size_t operator()(_Tp __v) const noexcept
N    {
N        union
N        {
N            _Tp __t;
N            struct
N            {
N                size_t __a;
N                size_t __b;
N                size_t __c;
N            } __s;
N        } __u;
N        __u.__t = __v;
N        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
N    }
N};
N
Ntemplate <class _Tp>
Nstruct __scalar_hash<_Tp, 4>
N    : public unary_function<_Tp, size_t>
N{
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    size_t operator()(_Tp __v) const _NOEXCEPT
X    size_t operator()(_Tp __v) const noexcept
N    {
N        union
N        {
N            _Tp __t;
N            struct
N            {
N                size_t __a;
N                size_t __b;
N                size_t __c;
N                size_t __d;
N            } __s;
N        } __u;
N        __u.__t = __v;
N        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
N    }
N};
N
Nstruct _PairT {
N  size_t first;
N  size_t second;
N};
N
N_LIBCPP_INLINE_VISIBILITY
X__attribute__ ((__always_inline__))
Ninline size_t __hash_combine(size_t __lhs, size_t __rhs) _NOEXCEPT {
Xinline size_t __hash_combine(size_t __lhs, size_t __rhs) noexcept {
N    typedef __scalar_hash<_PairT> _HashT;
N    const _PairT __p = {__lhs, __rhs};
N    return _HashT()(__p);
N}
N
Ntemplate<class _Tp>
Nstruct _LIBCPP_TEMPLATE_VIS hash<_Tp*>
Xstruct  hash<_Tp*>
N    : public unary_function<_Tp*, size_t>
N{
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    size_t operator()(_Tp* __v) const _NOEXCEPT
X    size_t operator()(_Tp* __v) const noexcept
N    {
N        union
N        {
N            _Tp* __t;
N            size_t __a;
N        } __u;
N        __u.__t = __v;
N        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
N    }
N};
N
N
Ntemplate <>
Nstruct _LIBCPP_TEMPLATE_VIS hash<bool>
Xstruct  hash<bool>
N    : public unary_function<bool, size_t>
N{
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    size_t operator()(bool __v) const _NOEXCEPT {return static_cast<size_t>(__v);}
X    size_t operator()(bool __v) const noexcept {return static_cast<size_t>(__v);}
N};
N
Ntemplate <>
Nstruct _LIBCPP_TEMPLATE_VIS hash<char>
Xstruct  hash<char>
N    : public unary_function<char, size_t>
N{
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    size_t operator()(char __v) const _NOEXCEPT {return static_cast<size_t>(__v);}
X    size_t operator()(char __v) const noexcept {return static_cast<size_t>(__v);}
N};
N
Ntemplate <>
Nstruct _LIBCPP_TEMPLATE_VIS hash<signed char>
Xstruct  hash<signed char>
N    : public unary_function<signed char, size_t>
N{
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    size_t operator()(signed char __v) const _NOEXCEPT {return static_cast<size_t>(__v);}
X    size_t operator()(signed char __v) const noexcept {return static_cast<size_t>(__v);}
N};
N
Ntemplate <>
Nstruct _LIBCPP_TEMPLATE_VIS hash<unsigned char>
Xstruct  hash<unsigned char>
N    : public unary_function<unsigned char, size_t>
N{
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    size_t operator()(unsigned char __v) const _NOEXCEPT {return static_cast<size_t>(__v);}
X    size_t operator()(unsigned char __v) const noexcept {return static_cast<size_t>(__v);}
N};
N
N#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
N
Ntemplate <>
Nstruct _LIBCPP_TEMPLATE_VIS hash<char16_t>
Xstruct  hash<char16_t>
N    : public unary_function<char16_t, size_t>
N{
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    size_t operator()(char16_t __v) const _NOEXCEPT {return static_cast<size_t>(__v);}
X    size_t operator()(char16_t __v) const noexcept {return static_cast<size_t>(__v);}
N};
N
Ntemplate <>
Nstruct _LIBCPP_TEMPLATE_VIS hash<char32_t>
Xstruct  hash<char32_t>
N    : public unary_function<char32_t, size_t>
N{
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    size_t operator()(char32_t __v) const _NOEXCEPT {return static_cast<size_t>(__v);}
X    size_t operator()(char32_t __v) const noexcept {return static_cast<size_t>(__v);}
N};
N
N#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS
N
Ntemplate <>
Nstruct _LIBCPP_TEMPLATE_VIS hash<wchar_t>
Xstruct  hash<wchar_t>
N    : public unary_function<wchar_t, size_t>
N{
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    size_t operator()(wchar_t __v) const _NOEXCEPT {return static_cast<size_t>(__v);}
X    size_t operator()(wchar_t __v) const noexcept {return static_cast<size_t>(__v);}
N};
N
Ntemplate <>
Nstruct _LIBCPP_TEMPLATE_VIS hash<short>
Xstruct  hash<short>
N    : public unary_function<short, size_t>
N{
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    size_t operator()(short __v) const _NOEXCEPT {return static_cast<size_t>(__v);}
X    size_t operator()(short __v) const noexcept {return static_cast<size_t>(__v);}
N};
N
Ntemplate <>
Nstruct _LIBCPP_TEMPLATE_VIS hash<unsigned short>
Xstruct  hash<unsigned short>
N    : public unary_function<unsigned short, size_t>
N{
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    size_t operator()(unsigned short __v) const _NOEXCEPT {return static_cast<size_t>(__v);}
X    size_t operator()(unsigned short __v) const noexcept {return static_cast<size_t>(__v);}
N};
N
Ntemplate <>
Nstruct _LIBCPP_TEMPLATE_VIS hash<int>
Xstruct  hash<int>
N    : public unary_function<int, size_t>
N{
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    size_t operator()(int __v) const _NOEXCEPT {return static_cast<size_t>(__v);}
X    size_t operator()(int __v) const noexcept {return static_cast<size_t>(__v);}
N};
N
Ntemplate <>
Nstruct _LIBCPP_TEMPLATE_VIS hash<unsigned int>
Xstruct  hash<unsigned int>
N    : public unary_function<unsigned int, size_t>
N{
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    size_t operator()(unsigned int __v) const _NOEXCEPT {return static_cast<size_t>(__v);}
X    size_t operator()(unsigned int __v) const noexcept {return static_cast<size_t>(__v);}
N};
N
Ntemplate <>
Nstruct _LIBCPP_TEMPLATE_VIS hash<long>
Xstruct  hash<long>
N    : public unary_function<long, size_t>
N{
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    size_t operator()(long __v) const _NOEXCEPT {return static_cast<size_t>(__v);}
X    size_t operator()(long __v) const noexcept {return static_cast<size_t>(__v);}
N};
N
Ntemplate <>
Nstruct _LIBCPP_TEMPLATE_VIS hash<unsigned long>
Xstruct  hash<unsigned long>
N    : public unary_function<unsigned long, size_t>
N{
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    size_t operator()(unsigned long __v) const _NOEXCEPT {return static_cast<size_t>(__v);}
X    size_t operator()(unsigned long __v) const noexcept {return static_cast<size_t>(__v);}
N};
N
Ntemplate <>
Nstruct _LIBCPP_TEMPLATE_VIS hash<long long>
Xstruct  hash<long long>
N    : public __scalar_hash<long long>
N{
N};
N
Ntemplate <>
Nstruct _LIBCPP_TEMPLATE_VIS hash<unsigned long long>
Xstruct  hash<unsigned long long>
N    : public __scalar_hash<unsigned long long>
N{
N};
N
N#ifndef _LIBCPP_HAS_NO_INT128
S
Stemplate <>
Sstruct _LIBCPP_TEMPLATE_VIS hash<__int128_t>
S    : public __scalar_hash<__int128_t>
S{
S};
S
Stemplate <>
Sstruct _LIBCPP_TEMPLATE_VIS hash<__uint128_t>
S    : public __scalar_hash<__uint128_t>
S{
S};
S
N#endif
N
Ntemplate <>
Nstruct _LIBCPP_TEMPLATE_VIS hash<float>
Xstruct  hash<float>
N    : public __scalar_hash<float>
N{
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    size_t operator()(float __v) const _NOEXCEPT
X    size_t operator()(float __v) const noexcept
N    {
N        // -0.0 and 0.0 should return same hash
N       if (__v == 0)
N           return 0;
N        return __scalar_hash<float>::operator()(__v);
N    }
N};
N
Ntemplate <>
Nstruct _LIBCPP_TEMPLATE_VIS hash<double>
Xstruct  hash<double>
N    : public __scalar_hash<double>
N{
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    size_t operator()(double __v) const _NOEXCEPT
X    size_t operator()(double __v) const noexcept
N    {
N        // -0.0 and 0.0 should return same hash
N       if (__v == 0)
N           return 0;
N        return __scalar_hash<double>::operator()(__v);
N    }
N};
N
Ntemplate <>
Nstruct _LIBCPP_TEMPLATE_VIS hash<long double>
Xstruct  hash<long double>
N    : public __scalar_hash<long double>
N{
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    size_t operator()(long double __v) const _NOEXCEPT
X    size_t operator()(long double __v) const noexcept
N    {
N        // -0.0 and 0.0 should return same hash
N        if (__v == 0)
N            return 0;
N#if defined(__i386__)
X#if 0L
S        // Zero out padding bits
S        union
S        {
S            long double __t;
S            struct
S            {
S                size_t __a;
S                size_t __b;
S                size_t __c;
S                size_t __d;
S            } __s;
S        } __u;
S        __u.__s.__a = 0;
S        __u.__s.__b = 0;
S        __u.__s.__c = 0;
S        __u.__s.__d = 0;
S        __u.__t = __v;
S        return __u.__s.__a ^ __u.__s.__b ^ __u.__s.__c ^ __u.__s.__d;
S#elif defined(__x86_64__)
X#elif 0L
S        // Zero out padding bits
S        union
S        {
S            long double __t;
S            struct
S            {
S                size_t __a;
S                size_t __b;
S            } __s;
S        } __u;
S        __u.__s.__a = 0;
S        __u.__s.__b = 0;
S        __u.__t = __v;
S        return __u.__s.__a ^ __u.__s.__b;
N#else
N        return __scalar_hash<long double>::operator()(__v);
N#endif
N    }
N};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
N
Ntemplate <class _Tp, bool = is_enum<_Tp>::value>
Nstruct _LIBCPP_TEMPLATE_VIS __enum_hash
Xstruct  __enum_hash
N    : public unary_function<_Tp, size_t>
N{
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    size_t operator()(_Tp __v) const _NOEXCEPT
X    size_t operator()(_Tp __v) const noexcept
N    {
N        typedef typename underlying_type<_Tp>::type type;
N        return hash<type>{}(static_cast<type>(__v));
N    }
N};
Ntemplate <class _Tp>
Nstruct _LIBCPP_TEMPLATE_VIS __enum_hash<_Tp, false> {
Xstruct  __enum_hash<_Tp, false> {
N    __enum_hash() = delete;
N    __enum_hash(__enum_hash const&) = delete;
N    __enum_hash& operator=(__enum_hash const&) = delete;
N};
N
Ntemplate <class _Tp>
Nstruct _LIBCPP_TEMPLATE_VIS hash : public __enum_hash<_Tp>
Xstruct  hash : public __enum_hash<_Tp>
N{
N};
N#endif
N
N#if _LIBCPP_STD_VER > 14
X#if 14 > 14
S
Stemplate <>
Sstruct _LIBCPP_TEMPLATE_VIS hash<nullptr_t>
S  : public unary_function<nullptr_t, size_t>
S{
S  _LIBCPP_INLINE_VISIBILITY
S  size_t operator()(nullptr_t) const _NOEXCEPT {
S    return 662607004ull;
S  }
S};
N#endif
N
N#ifndef _LIBCPP_CXX03_LANG
Ntemplate <class _Key, class _Hash>
Nusing __check_hash_requirements = integral_constant<bool,
N    is_copy_constructible<_Hash>::value &&
N    is_move_constructible<_Hash>::value &&
N    __invokable_r<size_t, _Hash, _Key const&>::value
N>;
N
Ntemplate <class _Key, class _Hash = std::hash<_Key> >
Nusing __has_enabled_hash = integral_constant<bool,
N    __check_hash_requirements<_Key, _Hash>::value &&
N    is_default_constructible<_Hash>::value
N>;
N
N#if _LIBCPP_STD_VER > 14
X#if 14 > 14
Stemplate <class _Type, class>
Susing __enable_hash_helper_imp = _Type;
S
Stemplate <class _Type, class ..._Keys>
Susing __enable_hash_helper = __enable_hash_helper_imp<_Type,
S  typename enable_if<__all<__has_enabled_hash<_Keys>::value...>::value>::type
S>;
N#else
Ntemplate <class _Type, class ...>
Nusing __enable_hash_helper = _Type;
N#endif
N
N#endif // !_LIBCPP_CXX03_LANG
N
N_LIBCPP_END_NAMESPACE_STD
X} }
N
N#endif  // _LIBCPP_UTILITY
L 643 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/algorithm" 2
N#include <memory>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/memory" 1
N// -*- C++ -*-
N//===-------------------------- memory ------------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is dual licensed under the MIT and the University of Illinois Open
N// Source Licenses. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP_MEMORY
N#define _LIBCPP_MEMORY
N
N/*
N    memory synopsis
N
Nnamespace std
N{
N
Nstruct allocator_arg_t { };
Nconstexpr allocator_arg_t allocator_arg = allocator_arg_t();
N
Ntemplate <class T, class Alloc> struct uses_allocator;
N
Ntemplate <class Ptr>
Nstruct pointer_traits
N{
N    typedef Ptr pointer;
N    typedef <details> element_type;
N    typedef <details> difference_type;
N
N    template <class U> using rebind = <details>;
N
N    static pointer pointer_to(<details>);
N};
N
Ntemplate <class T>
Nstruct pointer_traits<T*>
N{
N    typedef T* pointer;
N    typedef T element_type;
N    typedef ptrdiff_t difference_type;
N
N    template <class U> using rebind = U*;
N
N    static pointer pointer_to(<details>) noexcept;
N};
N
Ntemplate <class Alloc>
Nstruct allocator_traits
N{
N    typedef Alloc                        allocator_type;
N    typedef typename allocator_type::value_type
N                                         value_type;
N
N    typedef Alloc::pointer | value_type* pointer;
N    typedef Alloc::const_pointer
N          | pointer_traits<pointer>::rebind<const value_type>
N                                         const_pointer;
N    typedef Alloc::void_pointer
N          | pointer_traits<pointer>::rebind<void>
N                                         void_pointer;
N    typedef Alloc::const_void_pointer
N          | pointer_traits<pointer>::rebind<const void>
N                                         const_void_pointer;
N    typedef Alloc::difference_type
N          | pointer_traits<pointer>::difference_type
N                                         difference_type;
N    typedef Alloc::size_type
N          | make_unsigned<difference_type>::type
N                                         size_type;
N    typedef Alloc::propagate_on_container_copy_assignment
N          | false_type                   propagate_on_container_copy_assignment;
N    typedef Alloc::propagate_on_container_move_assignment
N          | false_type                   propagate_on_container_move_assignment;
N    typedef Alloc::propagate_on_container_swap
N          | false_type                   propagate_on_container_swap;
N    typedef Alloc::is_always_equal
N          | is_empty                     is_always_equal;
N
N    template <class T> using rebind_alloc  = Alloc::rebind<U>::other | Alloc<T, Args...>;
N    template <class T> using rebind_traits = allocator_traits<rebind_alloc<T>>;
N
N    static pointer allocate(allocator_type& a, size_type n);
N    static pointer allocate(allocator_type& a, size_type n, const_void_pointer hint);
N
N    static void deallocate(allocator_type& a, pointer p, size_type n) noexcept;
N
N    template <class T, class... Args>
N        static void construct(allocator_type& a, T* p, Args&&... args);
N
N    template <class T>
N        static void destroy(allocator_type& a, T* p);
N
N    static size_type max_size(const allocator_type& a); // noexcept in C++14
N
N    static allocator_type
N        select_on_container_copy_construction(const allocator_type& a);
N};
N
Ntemplate <>
Nclass allocator<void>
N{
Npublic:
N    typedef void*                                 pointer;
N    typedef const void*                           const_pointer;
N    typedef void                                  value_type;
N
N    template <class _Up> struct rebind {typedef allocator<_Up> other;};
N};
N
Ntemplate <class T>
Nclass allocator
N{
Npublic:
N    typedef size_t                                size_type;
N    typedef ptrdiff_t                             difference_type;
N    typedef T*                                    pointer;
N    typedef const T*                              const_pointer;
N    typedef typename add_lvalue_reference<T>::type       reference;
N    typedef typename add_lvalue_reference<const T>::type const_reference;
N    typedef T                                     value_type;
N
N    template <class U> struct rebind {typedef allocator<U> other;};
N
N    allocator() noexcept;
N    allocator(const allocator&) noexcept;
N    template <class U> allocator(const allocator<U>&) noexcept;
N    ~allocator();
N    pointer address(reference x) const noexcept;
N    const_pointer address(const_reference x) const noexcept;
N    pointer allocate(size_type, allocator<void>::const_pointer hint = 0);
N    void deallocate(pointer p, size_type n) noexcept;
N    size_type max_size() const noexcept;
N    template<class U, class... Args>
N        void construct(U* p, Args&&... args);
N    template <class U>
N        void destroy(U* p);
N};
N
Ntemplate <class T, class U>
Nbool operator==(const allocator<T>&, const allocator<U>&) noexcept;
N
Ntemplate <class T, class U>
Nbool operator!=(const allocator<T>&, const allocator<U>&) noexcept;
N
Ntemplate <class OutputIterator, class T>
Nclass raw_storage_iterator
N    : public iterator<output_iterator_tag,
N                      T,                               // purposefully not C++03
N                      ptrdiff_t,                       // purposefully not C++03
N                      T*,                              // purposefully not C++03
N                      raw_storage_iterator&>           // purposefully not C++03
N{
Npublic:
N    explicit raw_storage_iterator(OutputIterator x);
N    raw_storage_iterator& operator*();
N    raw_storage_iterator& operator=(const T& element);
N    raw_storage_iterator& operator++();
N    raw_storage_iterator  operator++(int);
N};
N
Ntemplate <class T> pair<T*,ptrdiff_t> get_temporary_buffer(ptrdiff_t n) noexcept;
Ntemplate <class T> void               return_temporary_buffer(T* p) noexcept;
N
Ntemplate <class T> T* addressof(T& r) noexcept;
Ntemplate <class T> T* addressof(const T&& r) noexcept = delete;
N
Ntemplate <class InputIterator, class ForwardIterator>
NForwardIterator
Nuninitialized_copy(InputIterator first, InputIterator last, ForwardIterator result);
N
Ntemplate <class InputIterator, class Size, class ForwardIterator>
NForwardIterator
Nuninitialized_copy_n(InputIterator first, Size n, ForwardIterator result);
N
Ntemplate <class ForwardIterator, class T>
Nvoid uninitialized_fill(ForwardIterator first, ForwardIterator last, const T& x);
N
Ntemplate <class ForwardIterator, class Size, class T>
NForwardIterator
Nuninitialized_fill_n(ForwardIterator first, Size n, const T& x);
N
Ntemplate <class T>
Nvoid destroy_at(T* location);
N
Ntemplate <class ForwardIterator>
N void destroy(ForwardIterator first, ForwardIterator last);
N
Ntemplate <class ForwardIterator, class Size>
N ForwardIterator destroy_n(ForwardIterator first, Size n);
N
Ntemplate <class InputIterator, class ForwardIterator>
N ForwardIterator uninitialized_move(InputIterator first, InputIterator last, ForwardIterator result);
N
Ntemplate <class InputIterator, class Size, class ForwardIterator>
N pair<InputIterator,ForwardIterator> uninitialized_move_n(InputIterator first, Size n, ForwardIterator result);
N
Ntemplate <class ForwardIterator>
N void uninitialized_value_construct(ForwardIterator first, ForwardIterator last);
N
Ntemplate <class ForwardIterator, class Size>
N ForwardIterator uninitialized_value_construct_n(ForwardIterator first, Size n);
N
Ntemplate <class ForwardIterator>
N void uninitialized_default_construct(ForwardIterator first, ForwardIterator last);
N
Ntemplate <class ForwardIterator, class Size>
N ForwardIterator uninitialized_default_construct_n(ForwardIterator first, Size n);
N
Ntemplate <class Y> struct auto_ptr_ref {};      // removed in C++17
N
Ntemplate<class X>
Nclass auto_ptr                                  // removed in C++17
N{
Npublic:
N    typedef X element_type;
N
N    explicit auto_ptr(X* p =0) throw();
N    auto_ptr(auto_ptr&) throw();
N    template<class Y> auto_ptr(auto_ptr<Y>&) throw();
N    auto_ptr& operator=(auto_ptr&) throw();
N    template<class Y> auto_ptr& operator=(auto_ptr<Y>&) throw();
N    auto_ptr& operator=(auto_ptr_ref<X> r) throw();
N    ~auto_ptr() throw();
N
N    typename add_lvalue_reference<X>::type operator*() const throw();
N    X* operator->() const throw();
N    X* get() const throw();
N    X* release() throw();
N    void reset(X* p =0) throw();
N
N    auto_ptr(auto_ptr_ref<X>) throw();
N    template<class Y> operator auto_ptr_ref<Y>() throw();
N    template<class Y> operator auto_ptr<Y>() throw();
N};
N
Ntemplate <class T>
Nstruct default_delete
N{
N    constexpr default_delete() noexcept = default;
N    template <class U> default_delete(const default_delete<U>&) noexcept;
N
N    void operator()(T*) const noexcept;
N};
N
Ntemplate <class T>
Nstruct default_delete<T[]>
N{
N    constexpr default_delete() noexcept = default;
N    void operator()(T*) const noexcept;
N    template <class U> void operator()(U*) const = delete;
N};
N
Ntemplate <class T, class D = default_delete<T>>
Nclass unique_ptr
N{
Npublic:
N    typedef see below pointer;
N    typedef T element_type;
N    typedef D deleter_type;
N
N    // constructors
N    constexpr unique_ptr() noexcept;
N    explicit unique_ptr(pointer p) noexcept;
N    unique_ptr(pointer p, see below d1) noexcept;
N    unique_ptr(pointer p, see below d2) noexcept;
N    unique_ptr(unique_ptr&& u) noexcept;
N    unique_ptr(nullptr_t) noexcept : unique_ptr() { }
N    template <class U, class E>
N        unique_ptr(unique_ptr<U, E>&& u) noexcept;
N    template <class U>
N        unique_ptr(auto_ptr<U>&& u) noexcept;       // removed in C++17
N
N    // destructor
N    ~unique_ptr();
N
N    // assignment
N    unique_ptr& operator=(unique_ptr&& u) noexcept;
N    template <class U, class E> unique_ptr& operator=(unique_ptr<U, E>&& u) noexcept;
N    unique_ptr& operator=(nullptr_t) noexcept;
N
N    // observers
N    typename add_lvalue_reference<T>::type operator*() const;
N    pointer operator->() const noexcept;
N    pointer get() const noexcept;
N    deleter_type& get_deleter() noexcept;
N    const deleter_type& get_deleter() const noexcept;
N    explicit operator bool() const noexcept;
N
N    // modifiers
N    pointer release() noexcept;
N    void reset(pointer p = pointer()) noexcept;
N    void swap(unique_ptr& u) noexcept;
N};
N
Ntemplate <class T, class D>
Nclass unique_ptr<T[], D>
N{
Npublic:
N    typedef implementation-defined pointer;
N    typedef T element_type;
N    typedef D deleter_type;
N
N    // constructors
N    constexpr unique_ptr() noexcept;
N    explicit unique_ptr(pointer p) noexcept;
N    unique_ptr(pointer p, see below d) noexcept;
N    unique_ptr(pointer p, see below d) noexcept;
N    unique_ptr(unique_ptr&& u) noexcept;
N    unique_ptr(nullptr_t) noexcept : unique_ptr() { }
N
N    // destructor
N    ~unique_ptr();
N
N    // assignment
N    unique_ptr& operator=(unique_ptr&& u) noexcept;
N    unique_ptr& operator=(nullptr_t) noexcept;
N
N    // observers
N    T& operator[](size_t i) const;
N    pointer get() const noexcept;
N    deleter_type& get_deleter() noexcept;
N    const deleter_type& get_deleter() const noexcept;
N    explicit operator bool() const noexcept;
N
N    // modifiers
N    pointer release() noexcept;
N    void reset(pointer p = pointer()) noexcept;
N    void reset(nullptr_t) noexcept;
N    template <class U> void reset(U) = delete;
N    void swap(unique_ptr& u) noexcept;
N};
N
Ntemplate <class T, class D>
N    void swap(unique_ptr<T, D>& x, unique_ptr<T, D>& y) noexcept;
N
Ntemplate <class T1, class D1, class T2, class D2>
N    bool operator==(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
Ntemplate <class T1, class D1, class T2, class D2>
N    bool operator!=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
Ntemplate <class T1, class D1, class T2, class D2>
N    bool operator<(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
Ntemplate <class T1, class D1, class T2, class D2>
N    bool operator<=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
Ntemplate <class T1, class D1, class T2, class D2>
N    bool operator>(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
Ntemplate <class T1, class D1, class T2, class D2>
N    bool operator>=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
N
Ntemplate <class T, class D>
N    bool operator==(const unique_ptr<T, D>& x, nullptr_t) noexcept;
Ntemplate <class T, class D>
N    bool operator==(nullptr_t, const unique_ptr<T, D>& y) noexcept;
Ntemplate <class T, class D>
N    bool operator!=(const unique_ptr<T, D>& x, nullptr_t) noexcept;
Ntemplate <class T, class D>
N    bool operator!=(nullptr_t, const unique_ptr<T, D>& y) noexcept;
N
Ntemplate <class T, class D>
N    bool operator<(const unique_ptr<T, D>& x, nullptr_t);
Ntemplate <class T, class D>
N    bool operator<(nullptr_t, const unique_ptr<T, D>& y);
Ntemplate <class T, class D>
N    bool operator<=(const unique_ptr<T, D>& x, nullptr_t);
Ntemplate <class T, class D>
N    bool operator<=(nullptr_t, const unique_ptr<T, D>& y);
Ntemplate <class T, class D>
N    bool operator>(const unique_ptr<T, D>& x, nullptr_t);
Ntemplate <class T, class D>
N    bool operator>(nullptr_t, const unique_ptr<T, D>& y);
Ntemplate <class T, class D>
N    bool operator>=(const unique_ptr<T, D>& x, nullptr_t);
Ntemplate <class T, class D>
N    bool operator>=(nullptr_t, const unique_ptr<T, D>& y);
N
Nclass bad_weak_ptr
N    : public std::exception
N{
N    bad_weak_ptr() noexcept;
N};
N
Ntemplate<class T, class... Args> unique_ptr<T> make_unique(Args&&... args);     // C++14
Ntemplate<class T>                unique_ptr<T> make_unique(size_t n);           // C++14
Ntemplate<class T, class... Args> unspecified   make_unique(Args&&...) = delete; // C++14, T == U[N]
N
Ntemplate<class T>
Nclass shared_ptr
N{
Npublic:
N    typedef T element_type;
N    typedef weak_ptr<T> weak_type; // C++17
N
N    // constructors:
N    constexpr shared_ptr() noexcept;
N    template<class Y> explicit shared_ptr(Y* p);
N    template<class Y, class D> shared_ptr(Y* p, D d);
N    template<class Y, class D, class A> shared_ptr(Y* p, D d, A a);
N    template <class D> shared_ptr(nullptr_t p, D d);
N    template <class D, class A> shared_ptr(nullptr_t p, D d, A a);
N    template<class Y> shared_ptr(const shared_ptr<Y>& r, T *p) noexcept;
N    shared_ptr(const shared_ptr& r) noexcept;
N    template<class Y> shared_ptr(const shared_ptr<Y>& r) noexcept;
N    shared_ptr(shared_ptr&& r) noexcept;
N    template<class Y> shared_ptr(shared_ptr<Y>&& r) noexcept;
N    template<class Y> explicit shared_ptr(const weak_ptr<Y>& r);
N    template<class Y> shared_ptr(auto_ptr<Y>&& r);          // removed in C++17
N    template <class Y, class D> shared_ptr(unique_ptr<Y, D>&& r);
N    shared_ptr(nullptr_t) : shared_ptr() { }
N
N    // destructor:
N    ~shared_ptr();
N
N    // assignment:
N    shared_ptr& operator=(const shared_ptr& r) noexcept;
N    template<class Y> shared_ptr& operator=(const shared_ptr<Y>& r) noexcept;
N    shared_ptr& operator=(shared_ptr&& r) noexcept;
N    template<class Y> shared_ptr& operator=(shared_ptr<Y>&& r);
N    template<class Y> shared_ptr& operator=(auto_ptr<Y>&& r); // removed in C++17
N    template <class Y, class D> shared_ptr& operator=(unique_ptr<Y, D>&& r);
N
N    // modifiers:
N    void swap(shared_ptr& r) noexcept;
N    void reset() noexcept;
N    template<class Y> void reset(Y* p);
N    template<class Y, class D> void reset(Y* p, D d);
N    template<class Y, class D, class A> void reset(Y* p, D d, A a);
N
N    // observers:
N    T* get() const noexcept;
N    T& operator*() const noexcept;
N    T* operator->() const noexcept;
N    long use_count() const noexcept;
N    bool unique() const noexcept;
N    explicit operator bool() const noexcept;
N    template<class U> bool owner_before(shared_ptr<U> const& b) const noexcept;
N    template<class U> bool owner_before(weak_ptr<U> const& b) const noexcept;
N};
N
N// shared_ptr comparisons:
Ntemplate<class T, class U>
N    bool operator==(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;
Ntemplate<class T, class U>
N    bool operator!=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;
Ntemplate<class T, class U>
N    bool operator<(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;
Ntemplate<class T, class U>
N    bool operator>(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;
Ntemplate<class T, class U>
N    bool operator<=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;
Ntemplate<class T, class U>
N    bool operator>=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;
N
Ntemplate <class T>
N    bool operator==(const shared_ptr<T>& x, nullptr_t) noexcept;
Ntemplate <class T>
N    bool operator==(nullptr_t, const shared_ptr<T>& y) noexcept;
Ntemplate <class T>
N    bool operator!=(const shared_ptr<T>& x, nullptr_t) noexcept;
Ntemplate <class T>
N    bool operator!=(nullptr_t, const shared_ptr<T>& y) noexcept;
Ntemplate <class T>
N    bool operator<(const shared_ptr<T>& x, nullptr_t) noexcept;
Ntemplate <class T>
Nbool operator<(nullptr_t, const shared_ptr<T>& y) noexcept;
Ntemplate <class T>
N    bool operator<=(const shared_ptr<T>& x, nullptr_t) noexcept;
Ntemplate <class T>
N    bool operator<=(nullptr_t, const shared_ptr<T>& y) noexcept;
Ntemplate <class T>
N    bool operator>(const shared_ptr<T>& x, nullptr_t) noexcept;
Ntemplate <class T>
N    bool operator>(nullptr_t, const shared_ptr<T>& y) noexcept;
Ntemplate <class T>
N    bool operator>=(const shared_ptr<T>& x, nullptr_t) noexcept;
Ntemplate <class T>
N    bool operator>=(nullptr_t, const shared_ptr<T>& y) noexcept;
N
N// shared_ptr specialized algorithms:
Ntemplate<class T> void swap(shared_ptr<T>& a, shared_ptr<T>& b) noexcept;
N
N// shared_ptr casts:
Ntemplate<class T, class U>
N    shared_ptr<T> static_pointer_cast(shared_ptr<U> const& r) noexcept;
Ntemplate<class T, class U>
N    shared_ptr<T> dynamic_pointer_cast(shared_ptr<U> const& r) noexcept;
Ntemplate<class T, class U>
N    shared_ptr<T> const_pointer_cast(shared_ptr<U> const& r) noexcept;
N
N// shared_ptr I/O:
Ntemplate<class E, class T, class Y>
N    basic_ostream<E, T>& operator<< (basic_ostream<E, T>& os, shared_ptr<Y> const& p);
N
N// shared_ptr get_deleter:
Ntemplate<class D, class T> D* get_deleter(shared_ptr<T> const& p) noexcept;
N
Ntemplate<class T, class... Args>
N    shared_ptr<T> make_shared(Args&&... args);
Ntemplate<class T, class A, class... Args>
N    shared_ptr<T> allocate_shared(const A& a, Args&&... args);
N
Ntemplate<class T>
Nclass weak_ptr
N{
Npublic:
N    typedef T element_type;
N
N    // constructors
N    constexpr weak_ptr() noexcept;
N    template<class Y> weak_ptr(shared_ptr<Y> const& r) noexcept;
N    weak_ptr(weak_ptr const& r) noexcept;
N    template<class Y> weak_ptr(weak_ptr<Y> const& r) noexcept;
N    weak_ptr(weak_ptr&& r) noexcept;                      // C++14
N    template<class Y> weak_ptr(weak_ptr<Y>&& r) noexcept; // C++14
N
N    // destructor
N    ~weak_ptr();
N
N    // assignment
N    weak_ptr& operator=(weak_ptr const& r) noexcept;
N    template<class Y> weak_ptr& operator=(weak_ptr<Y> const& r) noexcept;
N    template<class Y> weak_ptr& operator=(shared_ptr<Y> const& r) noexcept;
N    weak_ptr& operator=(weak_ptr&& r) noexcept;                      // C++14
N    template<class Y> weak_ptr& operator=(weak_ptr<Y>&& r) noexcept; // C++14
N
N    // modifiers
N    void swap(weak_ptr& r) noexcept;
N    void reset() noexcept;
N
N    // observers
N    long use_count() const noexcept;
N    bool expired() const noexcept;
N    shared_ptr<T> lock() const noexcept;
N    template<class U> bool owner_before(shared_ptr<U> const& b) const noexcept;
N    template<class U> bool owner_before(weak_ptr<U> const& b) const noexcept;
N};
N
N// weak_ptr specialized algorithms:
Ntemplate<class T> void swap(weak_ptr<T>& a, weak_ptr<T>& b) noexcept;
N
N// class owner_less:
Ntemplate<class T> struct owner_less;
N
Ntemplate<class T>
Nstruct owner_less<shared_ptr<T>>
N    : binary_function<shared_ptr<T>, shared_ptr<T>, bool>
N{
N    typedef bool result_type;
N    bool operator()(shared_ptr<T> const&, shared_ptr<T> const&) const noexcept;
N    bool operator()(shared_ptr<T> const&, weak_ptr<T> const&) const noexcept;
N    bool operator()(weak_ptr<T> const&, shared_ptr<T> const&) const noexcept;
N};
N
Ntemplate<class T>
Nstruct owner_less<weak_ptr<T>>
N    : binary_function<weak_ptr<T>, weak_ptr<T>, bool>
N{
N    typedef bool result_type;
N    bool operator()(weak_ptr<T> const&, weak_ptr<T> const&) const noexcept;
N    bool operator()(shared_ptr<T> const&, weak_ptr<T> const&) const noexcept;
N    bool operator()(weak_ptr<T> const&, shared_ptr<T> const&) const noexcept;
N};
N
Ntemplate <>  // Added in C++14
Nstruct owner_less<void>
N{
N    template <class _Tp, class _Up>
N    bool operator()( shared_ptr<_Tp> const& __x, shared_ptr<_Up> const& __y) const noexcept;
N    template <class _Tp, class _Up>
N    bool operator()( shared_ptr<_Tp> const& __x,   weak_ptr<_Up> const& __y) const noexcept;
N    template <class _Tp, class _Up>
N    bool operator()(   weak_ptr<_Tp> const& __x, shared_ptr<_Up> const& __y) const noexcept;
N    template <class _Tp, class _Up>
N    bool operator()(   weak_ptr<_Tp> const& __x,   weak_ptr<_Up> const& __y) const noexcept;
N
N    typedef void is_transparent;
N};
N
Ntemplate<class T>
Nclass enable_shared_from_this
N{
Nprotected:
N    constexpr enable_shared_from_this() noexcept;
N    enable_shared_from_this(enable_shared_from_this const&) noexcept;
N    enable_shared_from_this& operator=(enable_shared_from_this const&) noexcept;
N    ~enable_shared_from_this();
Npublic:
N    shared_ptr<T> shared_from_this();
N    shared_ptr<T const> shared_from_this() const;
N};
N
Ntemplate<class T>
N    bool atomic_is_lock_free(const shared_ptr<T>* p);
Ntemplate<class T>
N    shared_ptr<T> atomic_load(const shared_ptr<T>* p);
Ntemplate<class T>
N    shared_ptr<T> atomic_load_explicit(const shared_ptr<T>* p, memory_order mo);
Ntemplate<class T>
N    void atomic_store(shared_ptr<T>* p, shared_ptr<T> r);
Ntemplate<class T>
N    void atomic_store_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);
Ntemplate<class T>
N    shared_ptr<T> atomic_exchange(shared_ptr<T>* p, shared_ptr<T> r);
Ntemplate<class T>
N    shared_ptr<T>
N    atomic_exchange_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);
Ntemplate<class T>
N    bool
N    atomic_compare_exchange_weak(shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);
Ntemplate<class T>
N    bool
N    atomic_compare_exchange_strong( shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);
Ntemplate<class T>
N    bool
N    atomic_compare_exchange_weak_explicit(shared_ptr<T>* p, shared_ptr<T>* v,
N                                          shared_ptr<T> w, memory_order success,
N                                          memory_order failure);
Ntemplate<class T>
N    bool
N    atomic_compare_exchange_strong_explicit(shared_ptr<T>* p, shared_ptr<T>* v,
N                                            shared_ptr<T> w, memory_order success,
N                                            memory_order failure);
N// Hash support
Ntemplate <class T> struct hash;
Ntemplate <class T, class D> struct hash<unique_ptr<T, D> >;
Ntemplate <class T> struct hash<shared_ptr<T> >;
N
N// Pointer safety
Nenum class pointer_safety { relaxed, preferred, strict };
Nvoid declare_reachable(void *p);
Ntemplate <class T> T *undeclare_reachable(T *p);
Nvoid declare_no_pointers(char *p, size_t n);
Nvoid undeclare_no_pointers(char *p, size_t n);
Npointer_safety get_pointer_safety() noexcept;
N
Nvoid* align(size_t alignment, size_t size, void*& ptr, size_t& space);
N
N}  // std
N
N*/
N
N#include <__config>
N#include <type_traits>
N#include <typeinfo>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/typeinfo" 1
N// -*- C++ -*-
N//===-------------------------- typeinfo ----------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is dual licensed under the MIT and the University of Illinois Open
N// Source Licenses. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef __LIBCPP_TYPEINFO
N#define __LIBCPP_TYPEINFO
N
N/*
N
N    typeinfo synopsis
N
Nnamespace std {
N
Nclass type_info
N{
Npublic:
N    virtual ~type_info();
N
N    bool operator==(const type_info& rhs) const noexcept;
N    bool operator!=(const type_info& rhs) const noexcept;
N
N    bool before(const type_info& rhs) const noexcept;
N    size_t hash_code() const noexcept;
N    const char* name() const noexcept;
N
N    type_info(const type_info& rhs) = delete;
N    type_info& operator=(const type_info& rhs) = delete;
N};
N
Nclass bad_cast
N    : public exception
N{
Npublic:
N    bad_cast() noexcept;
N    bad_cast(const bad_cast&) noexcept;
N    bad_cast& operator=(const bad_cast&) noexcept;
N    virtual const char* what() const noexcept;
N};
N
Nclass bad_typeid
N    : public exception
N{
Npublic:
N    bad_typeid() noexcept;
N    bad_typeid(const bad_typeid&) noexcept;
N    bad_typeid& operator=(const bad_typeid&) noexcept;
N    virtual const char* what() const noexcept;
N};
N
N}  // std
N
N*/
N
N#include <__config>
N#include <exception>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/exception" 1
N// -*- C++ -*-
N//===-------------------------- exception ---------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is dual licensed under the MIT and the University of Illinois Open
N// Source Licenses. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP_EXCEPTION
N#define _LIBCPP_EXCEPTION
N
N/*
N    exception synopsis
N
Nnamespace std
N{
N
Nclass exception
N{
Npublic:
N    exception() noexcept;
N    exception(const exception&) noexcept;
N    exception& operator=(const exception&) noexcept;
N    virtual ~exception() noexcept;
N    virtual const char* what() const noexcept;
N};
N
Nclass bad_exception
N    : public exception
N{
Npublic:
N    bad_exception() noexcept;
N    bad_exception(const bad_exception&) noexcept;
N    bad_exception& operator=(const bad_exception&) noexcept;
N    virtual ~bad_exception() noexcept;
N    virtual const char* what() const noexcept;
N};
N
Ntypedef void (*unexpected_handler)();
Nunexpected_handler set_unexpected(unexpected_handler  f ) noexcept;
Nunexpected_handler get_unexpected() noexcept;
N[[noreturn]] void unexpected();
N
Ntypedef void (*terminate_handler)();
Nterminate_handler set_terminate(terminate_handler  f ) noexcept;
Nterminate_handler get_terminate() noexcept;
N[[noreturn]] void terminate() noexcept;
N
Nbool uncaught_exception()  noexcept;
Nint  uncaught_exceptions() noexcept;  // C++17
N
Ntypedef unspecified exception_ptr;
N
Nexception_ptr current_exception() noexcept;
Nvoid rethrow_exception [[noreturn]] (exception_ptr p);
Ntemplate<class E> exception_ptr make_exception_ptr(E e) noexcept;
N
Nclass nested_exception
N{
Npublic:
N    nested_exception() noexcept;
N    nested_exception(const nested_exception&) noexcept = default;
N    nested_exception& operator=(const nested_exception&) noexcept = default;
N    virtual ~nested_exception() = default;
N
N    // access functions
N    [[noreturn]] void rethrow_nested() const;
N    exception_ptr nested_ptr() const noexcept;
N};
N
Ntemplate <class T> [[noreturn]] void throw_with_nested(T&& t);
Ntemplate <class E> void rethrow_if_nested(const E& e);
N
N}  // std
N
N*/
N
N#include <__config>
N#include <cstddef>
N#include <cstdlib>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/cstdlib" 1
N// -*- C++ -*-
N//===--------------------------- cstdlib ----------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is dual licensed under the MIT and the University of Illinois Open
N// Source Licenses. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP_CSTDLIB
N#define _LIBCPP_CSTDLIB
N
N/*
N    cstdlib synopsis
N
NMacros:
N
N    EXIT_FAILURE
N    EXIT_SUCCESS
N    MB_CUR_MAX
N    NULL
N    RAND_MAX
N
Nnamespace std
N{
N
NTypes:
N
N    size_t
N    div_t
N    ldiv_t
N    lldiv_t                                                               // C99
N
Ndouble    atof (const char* nptr);
Nint       atoi (const char* nptr);
Nlong      atol (const char* nptr);
Nlong long atoll(const char* nptr);                                        // C99
Ndouble             strtod  (const char* restrict nptr, char** restrict endptr);
Nfloat              strtof  (const char* restrict nptr, char** restrict endptr); // C99
Nlong double        strtold (const char* restrict nptr, char** restrict endptr); // C99
Nlong               strtol  (const char* restrict nptr, char** restrict endptr, int base);
Nlong long          strtoll (const char* restrict nptr, char** restrict endptr, int base); // C99
Nunsigned long      strtoul (const char* restrict nptr, char** restrict endptr, int base);
Nunsigned long long strtoull(const char* restrict nptr, char** restrict endptr, int base); // C99
Nint rand(void);
Nvoid srand(unsigned int seed);
Nvoid* calloc(size_t nmemb, size_t size);
Nvoid free(void* ptr);
Nvoid* malloc(size_t size);
Nvoid* realloc(void* ptr, size_t size);
Nvoid abort(void);
Nint atexit(void (*func)(void));
Nvoid exit(int status);
Nvoid _Exit(int status);
Nchar* getenv(const char* name);
Nint system(const char* string);
Nvoid* bsearch(const void* key, const void* base, size_t nmemb, size_t size,
N              int (*compar)(const void *, const void *));
Nvoid qsort(void* base, size_t nmemb, size_t size,
N           int (*compar)(const void *, const void *));
Nint         abs(      int j);
Nlong        abs(     long j);
Nlong long   abs(long long j);                                             // C++0X
Nlong       labs(     long j);
Nlong long llabs(long long j);                                             // C99
Ndiv_t     div(      int numer,       int denom);
Nldiv_t    div(     long numer,      long denom);
Nlldiv_t   div(long long numer, long long denom);                          // C++0X
Nldiv_t   ldiv(     long numer,      long denom);
Nlldiv_t lldiv(long long numer, long long denom);                          // C99
Nint mblen(const char* s, size_t n);
Nint mbtowc(wchar_t* restrict pwc, const char* restrict s, size_t n);
Nint wctomb(char* s, wchar_t wchar);
Nsize_t mbstowcs(wchar_t* restrict pwcs, const char* restrict s, size_t n);
Nsize_t wcstombs(char* restrict s, const wchar_t* restrict pwcs, size_t n);
Nint at_quick_exit(void (*func)(void))                                     // C++11
Nvoid quick_exit(int status);                                              // C++11
Nvoid *aligned_alloc(size_t alignment, size_t size);                       // C11
N
N}  // std
N
N*/
N
N#include <__config>
N#include <stdlib.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/stdlib.h" 1
N/* -*- C++ -*- */
N/*===--------------------------- complex.h --------------------------------===*/
N/*                                                                            */
N/*                     The LLVM Compiler Infrastructure                       */
N/*                                                                            */
N/* This file is dual licensed under the MIT and the University of Illinois Open
N** Source Licenses. See LICENSE.TXT for details.
N*/
N/*===----------------------------------------------------------------------===*/
N
N#if defined(__need_malloc_and_calloc)
X#if 0L
S
S#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
S#pragma GCC system_header
S#endif
S
S#include_next <stdlib.h>
S
N#elif !defined(_LIBCPP_STDLIB_H)
X#elif !0L
N#define _LIBCPP_STDLIB_H
N
N/*
N    stdlib.h synopsis
N
NMacros:
N
N    EXIT_FAILURE
N    EXIT_SUCCESS
N    MB_CUR_MAX
N    NULL
N    RAND_MAX
N
NTypes:
N
N    size_t
N    div_t
N    ldiv_t
N    lldiv_t                                                               // C99
N
Ndouble    atof (const char* nptr);
Nint       atoi (const char* nptr);
Nlong      atol (const char* nptr);
Nlong long atoll(const char* nptr);                                        // C99
Ndouble             strtod  (const char* restrict nptr, char** restrict endptr);
Nfloat              strtof  (const char* restrict nptr, char** restrict endptr); // C99
Nlong double        strtold (const char* restrict nptr, char** restrict endptr); // C99
Nlong               strtol  (const char* restrict nptr, char** restrict endptr, int base);
Nlong long          strtoll (const char* restrict nptr, char** restrict endptr, int base); // C99
Nunsigned long      strtoul (const char* restrict nptr, char** restrict endptr, int base);
Nunsigned long long strtoull(const char* restrict nptr, char** restrict endptr, int base); // C99
Nint rand(void);
Nvoid srand(unsigned int seed);
Nvoid* calloc(size_t nmemb, size_t size);
Nvoid free(void* ptr);
Nvoid* malloc(size_t size);
Nvoid* realloc(void* ptr, size_t size);
Nvoid abort(void);
Nint atexit(void (*func)(void));
Nvoid exit(int status);
Nvoid _Exit(int status);
Nchar* getenv(const char* name);
Nint system(const char* string);
Nvoid* bsearch(const void* key, const void* base, size_t nmemb, size_t size,
N              int (*compar)(const void *, const void *));
Nvoid qsort(void* base, size_t nmemb, size_t size,
N           int (*compar)(const void *, const void *));
Nint         abs(      int j);
Nlong        abs(     long j);
Nlong long   abs(long long j);                                             // C++0X
Nlong       labs(     long j);
Nlong long llabs(long long j);                                             // C99
Ndiv_t     div(      int numer,       int denom);
Nldiv_t    div(     long numer,      long denom);
Nlldiv_t   div(long long numer, long long denom);                          // C++0X
Nldiv_t   ldiv(     long numer,      long denom);
Nlldiv_t lldiv(long long numer, long long denom);                          // C99
Nint mblen(const char* s, size_t n);
Nint mbtowc(wchar_t* restrict pwc, const char* restrict s, size_t n);
Nint wctomb(char* s, wchar_t wchar);
Nsize_t mbstowcs(wchar_t* restrict pwcs, const char* restrict s, size_t n);
Nsize_t wcstombs(char* restrict s, const wchar_t* restrict pwcs, size_t n);
Nint at_quick_exit(void (*func)(void))                                     // C++11
Nvoid quick_exit(int status);                                              // C++11
Nvoid *aligned_alloc(size_t alignment, size_t size);                       // C11
N
N*/
N
N#include <__config>
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N#include_next <stdlib.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/stdlib.h" 1
N/*****************************************************************************/
N/* stdlib.h                                                                  */
N/*                                                                           */
N/* Copyright (c) 1993 Texas Instruments Incorporated                         */
N/* http://www.ti.com/                                                        */
N/*                                                                           */
N/*  Redistribution and  use in source  and binary forms, with  or without    */
N/*  modification,  are permitted provided  that the  following conditions    */
N/*  are met:                                                                 */
N/*                                                                           */
N/*     Redistributions  of source  code must  retain the  above copyright    */
N/*     notice, this list of conditions and the following disclaimer.         */
N/*                                                                           */
N/*     Redistributions in binary form  must reproduce the above copyright    */
N/*     notice, this  list of conditions  and the following  disclaimer in    */
N/*     the  documentation  and/or   other  materials  provided  with  the    */
N/*     distribution.                                                         */
N/*                                                                           */
N/*     Neither the  name of Texas Instruments Incorporated  nor the names    */
N/*     of its  contributors may  be used to  endorse or  promote products    */
N/*     derived  from   this  software  without   specific  prior  written    */
N/*     permission.                                                           */
N/*                                                                           */
N/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS    */
N/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT    */
N/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    */
N/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT    */
N/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    */
N/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT    */
N/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    */
N/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    */
N/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT    */
N/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    */
N/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     */
N/*                                                                           */
N/*****************************************************************************/
N
N#ifndef _STDLIB_H_
N#define _STDLIB_H_
N
N#if defined(__TMS320C2000__)
X#if 0L
S#if defined(__TMS320C28XX_CLA__)
S#error "Header file <stdlib.h> not supported by CLA compiler"
S#endif
N#endif
N
N#include <_ti_config.h>
N
N#pragma diag_push
N#pragma CHECK_MISRA("-6.3") /* standard types required for standard headers */
N#pragma CHECK_MISRA("-8.5") /* need to define inline function */
N#pragma CHECK_MISRA("-19.1") /* #includes required for implementation */
N#pragma CHECK_MISRA("-19.7") /* need function-like macros */
N#pragma CHECK_MISRA("-20.1") /* standard headers must define standard names */
N#pragma CHECK_MISRA("-20.2") /* standard headers must define standard names */
N
N/*---------------------------------------------------------------------------*/
N/* Attributes are only available in relaxed ANSI mode.                       */
N/*---------------------------------------------------------------------------*/
N#ifndef __ATTRIBUTE
N#if __TI_STRICT_ANSI_MODE__
X#if 0
S#define __ATTRIBUTE(attr)
N#else
N#define __ATTRIBUTE(attr) __attribute__(attr)
N#endif
N#endif
N
N#ifdef __cplusplus
Nextern "C" {
N#endif /* !__cplusplus */
N
N#pragma diag_push
N#pragma CHECK_MISRA("-5.7") /* keep names intact */
N
Ntypedef struct { int quot, rem; } div_t;
N
N#ifndef __ARM_ARCH
Stypedef struct { long quot, rem; } ldiv_t;
N#else /* __ARM_ARCH */
Ntypedef struct { int quot, rem; } ldiv_t;
N#endif /* __ARM_ARCH */
N
N#if defined(__TMS320C55X__) || defined(__ARM_ARCH)      || \
N    defined(_TMS320C6X)     || defined(__TMS320C2000__) || \
N    defined(__ARP32__)      || defined(__MSP430__)      || \
N    defined(__PRU__)        || defined(__C7000__)
X#if 0L || 1L      ||     0L     || 0L ||     0L      || 0L      ||     0L        || 0L
N#define _LLONG_AVAILABLE 1
Ntypedef struct { long long quot, rem; } lldiv_t;
N#endif
N
N#pragma diag_pop
N
N#if defined(_AEABI_PORTABILITY_LEVEL) && _AEABI_PORTABILITY_LEVEL != 0
X#if 0L && _AEABI_PORTABILITY_LEVEL != 0
Sextern int __aeabi_MB_CUR_MAX(void);
S#define MB_CUR_MAX ( __aeabi_MB_CUR_MAX() )
N#else
N#define MB_CUR_MAX    1
N#endif /* _AEABI_PORTABILITY_LEVEL */
N
N#ifndef NULL
S#define NULL          0
N#endif
N
N#ifndef _SIZE_T_DECLARED
S#define _SIZE_T_DECLARED
S# ifdef __clang__
Stypedef __SIZE_TYPE__ __SIZE_T_TYPE__;
S# endif
S
Stypedef __SIZE_T_TYPE__ size_t;
N#endif
N
N#ifndef __cplusplus
S#ifndef _WCHAR_T_DECLARED
S#define _WCHAR_T_DECLARED
S# ifdef __clang__
Stypedef __WCHAR_TYPE__ __WCHAR_T_TYPE__;
S# endif
S
Stypedef __WCHAR_T_TYPE__ wchar_t;
S#endif
N#endif
N
N#define EXIT_FAILURE  1
N#define EXIT_SUCCESS  0
N
N#define RAND_MAX      32767
N
N#include <_ti_config.h>
N
N/*---------------------------------------------------------------*/
N/* NOTE - Normally, abs, labs, and fabs are expanded inline, so  */
N/*        no formal definition is really required. However, ANSI */
N/*        requires that they exist as separate functions, so     */
N/*        they are supplied in the library.  The prototype is    */
N/*        here mainly for documentation.                         */
N/*---------------------------------------------------------------*/
N#pragma diag_push
N#pragma CHECK_MISRA("-16.4") /* false positives due to builtin declarations */
N    _CODE_ACCESS  int       abs(int _val); 
X      int       abs(int _val); 
N    _CODE_ACCESS  long      labs(long _val);
X      long      labs(long _val);
N#if defined(_LLONG_AVAILABLE)
X#if 1L
N    _CODE_ACCESS  long long llabs(long long _val);
X      long long llabs(long long _val);
N#endif
N#pragma diag_pop
N
N    _CODE_ACCESS int       atoi(const char *_st);
X     int       atoi(const char *_st);
N    _CODE_ACCESS long      atol(const char *_st);
X     long      atol(const char *_st);
N#if defined(_LLONG_AVAILABLE)
X#if 1L
N    _CODE_ACCESS long long atoll(const char *_st);
X     long long atoll(const char *_st);
N#endif
N    _CODE_ACCESS int       ltoa(long val, char *buffer);
X     int       ltoa(long val, char *buffer);
N          _IDECL double    atof(const char *_st);
X          extern  double    atof(const char *_st);
N
N    _CODE_ACCESS long      strtol(const char * __restrict _st,
X     long      strtol(const char * __restrict _st,
N                                  char ** __restrict _endptr, int _base);
N    _CODE_ACCESS unsigned long strtoul(const char * __restrict _st,
X     unsigned long strtoul(const char * __restrict _st,
N                                       char ** __restrict _endptr, int _base);
N#if defined(_LLONG_AVAILABLE)
X#if 1L
N    _CODE_ACCESS long long strtoll(const char * __restrict _st,
X     long long strtoll(const char * __restrict _st,
N                                   char ** __restrict _endptr, int _base);
N    _CODE_ACCESS unsigned long long strtoull(const char * __restrict _st,
X     unsigned long long strtoull(const char * __restrict _st,
N                                             char ** __restrict _endptr,
N					     int _base);
N#endif
N    _CODE_ACCESS float     strtof(const char * __restrict _st,
X     float     strtof(const char * __restrict _st,
N                                  char ** __restrict _endptr);
N    _CODE_ACCESS double    strtod(const char * __restrict _st,
X     double    strtod(const char * __restrict _st,
N                                  char ** __restrict _endptr);
N    _CODE_ACCESS long double strtold(const char * __restrict _st,
X     long double strtold(const char * __restrict _st,
N                                     char ** __restrict _endptr);
N    
N    _CODE_ACCESS int    rand(void);
X     int    rand(void);
N    _CODE_ACCESS void   srand(unsigned _seed);
X     void   srand(unsigned _seed);
N    
N    _CODE_ACCESS void  *calloc(size_t _num, size_t _size)
X     void  *calloc(size_t _num, size_t _size)
N               __ATTRIBUTE((malloc));
X               __attribute__((malloc));
N    _CODE_ACCESS void  *malloc(size_t _size)
X     void  *malloc(size_t _size)
N               __ATTRIBUTE((malloc));
X               __attribute__((malloc));
N    _CODE_ACCESS void  *realloc(void *_ptr, size_t _size);
X     void  *realloc(void *_ptr, size_t _size);
N    _CODE_ACCESS void   free(void *_ptr);
X     void   free(void *_ptr);
N    _CODE_ACCESS void  *memalign(size_t _aln, size_t _size)
X     void  *memalign(size_t _aln, size_t _size)
N               __ATTRIBUTE((malloc));
X               __attribute__((malloc));
N#if defined(_TI_C11LIB) || __TI_STRICT_ANSI_MODE__ == 0
X#if 1L || 0 == 0
N    _CODE_ACCESS void  *aligned_alloc(size_t _aln, size_t _size)
X     void  *aligned_alloc(size_t _aln, size_t _size)
N               __ATTRIBUTE((malloc));
X               __attribute__((malloc));
N#endif
N
N    _CODE_ACCESS void   __TI_heap_stats(void);
X     void   __TI_heap_stats(void);
N    _CODE_ACCESS void  *__TI_heap_check(void);
X     void  *__TI_heap_check(void);
N    _CODE_ACCESS size_t __TI_heap_total_available(void);
X     size_t __TI_heap_total_available(void);
N    _CODE_ACCESS size_t __TI_heap_largest_available(void);
X     size_t __TI_heap_largest_available(void);
N    
N    _TI_NORETURN _CODE_ACCESS void abort(void) _TI_NOEXCEPT_CPP14;
X    [[noreturn]]  void abort(void) noexcept;
N
N    typedef void (*__TI_atexit_fn)(void);
N    _CODE_ACCESS int    atexit(__TI_atexit_fn _func) _TI_NOEXCEPT_CPP14;
X     int    atexit(__TI_atexit_fn _func) noexcept;
N
N    typedef int (*__TI_compar_fn)(const void *_a,const void *_b);
N    _CODE_ACCESS void  *bsearch(const void *_key, const void *_base,
X     void  *bsearch(const void *_key, const void *_base,
N                                size_t _nmemb, size_t _size, 
N                                __TI_compar_fn compar);
N    _CODE_ACCESS void   qsort(void *_base, size_t _nmemb, size_t _size, 
X     void   qsort(void *_base, size_t _nmemb, size_t _size, 
N                              __TI_compar_fn compar);
N
N    _TI_NORETURN _CODE_ACCESS void exit(int _status);
X    [[noreturn]]  void exit(int _status);
N#if defined(_TI_C99LIB) || __TI_STRICT_ANSI_MODE__ == 0
X#if 1L || 0 == 0
N    _TI_NORETURN _CODE_ACCESS void _Exit(int _status);
X    [[noreturn]]  void _Exit(int _status);
N#endif
N
N#if defined(_TI_C11LIB) || __TI_STRICT_ANSI_MODE__ == 0
X#if 1L || 0 == 0
N    _TI_NORETURN _CODE_ACCESS void quick_exit(int _status);
X    [[noreturn]]  void quick_exit(int _status);
N    _CODE_ACCESS int at_quick_exit(__TI_atexit_fn _func) _TI_NOEXCEPT_CPP14;
X     int at_quick_exit(__TI_atexit_fn _func) noexcept;
N#endif
N    
N    _CODE_ACCESS div_t  div(int _numer, int _denom);
X     div_t  div(int _numer, int _denom);
N    _CODE_ACCESS ldiv_t ldiv(long _numer, long _denom);
X     ldiv_t ldiv(long _numer, long _denom);
N#if defined(_LLONG_AVAILABLE)
X#if 1L
N    _CODE_ACCESS lldiv_t lldiv(long long _numer, long long _denom);
X     lldiv_t lldiv(long long _numer, long long _denom);
N#endif
N
N    _CODE_ACCESS char  *getenv(const char *_string);
X     char  *getenv(const char *_string);
N    _CODE_ACCESS int    system(const char *_name);
X     int    system(const char *_name);
N
N    _CODE_ACCESS int    mblen(const char *_s, size_t _n);
X     int    mblen(const char *_s, size_t _n);
N    _CODE_ACCESS size_t mbstowcs(wchar_t * __restrict _dest,
X     size_t mbstowcs(wchar_t * __restrict _dest,
N                                 const char * __restrict _src, size_t _n);
N    _CODE_ACCESS int    mbtowc(wchar_t * __restrict _dest,
X     int    mbtowc(wchar_t * __restrict _dest,
N                               const char * __restrict _src, size_t _n);
N
N    _CODE_ACCESS size_t wcstombs(char * __restrict _dest,
X     size_t wcstombs(char * __restrict _dest,
N                                 const wchar_t * __restrict _src, size_t _n);
N    _CODE_ACCESS int    wctomb(char *_s, wchar_t _wc);
X     int    wctomb(char *_s, wchar_t _wc);
N
N#ifdef __cplusplus
N} /* extern "C" */
N#endif /* __cplusplus */
N
N
N#ifdef _INLINE
S
Sstatic __inline double atof(const char *_st) 
S{
S  return strtod(_st, (char **)0); 
S}
S
N#endif  /* _INLINE */
N
N#ifdef __cplusplus
N/*****************************************************************************/
N/* If we leave these active when in relaxed ANSI mode, we get infinite       */
N/* recursion due to changes in type matching.  See comment in                */
N/* ansi/sys_predef.c line 4377 on why we specifically check the              */
N/* __TI_STRICT_ANSI_MODE__ macro here and its relation to strict ANSI and    */
N/* relaxed ANSI parser modes.                                                */
N/*****************************************************************************/
N#if __TI_STRICT_ANSI_MODE__
X#if 0
S    _CODE_ACCESS inline int atexit(void (*func)(void)) _TI_NOEXCEPT_CPP14
S        {
S            return atexit((__TI_atexit_fn)func);
S        }
S
S#if defined(_TI_C11LIB)
S    _CODE_ACCESS inline int quick_atexit(void (*func)(void)) _TI_NOEXCEPT_CPP14
S        {
S            return at_quick_exit((__TI_atexit_fn)func);
S        }
S#endif
S
S    _CODE_ACCESS inline void  *bsearch(const void *_key, const void *_base,
S                                       size_t _nmemb, size_t _size, 
S                                       int (*compar)(const void *,const void *))
S        {
S            return bsearch(_key, _base, _nmemb, _size, (__TI_compar_fn)compar);
S        }
S
S    _CODE_ACCESS inline void   qsort(void *_base, size_t _nmemb, size_t _size, 
S                                     int (*_compar)(const void *, const void *))
S        {
S            return qsort(_base, _nmemb, _size, (__TI_compar_fn)_compar);
S        }
N#endif
N#endif
N
N/* C2000-specific additions to header implemented with #include */
N
N#if defined(__TMS320C2000__)
X#if 0L
S#include <stdlibf.h>     /* far versions of stdlib fns */
S
S#pragma diag_push
S#pragma CHECK_MISRA("-19.4") /* Macros needed to retarget builtins */
S
Sldiv_t __attribute__((builtin))
S__euclidean_div_i32byu32(long numerator, unsigned long denominator);
S
S# if defined(__TMS320C28XX_IDIV__)
S/*****************************************************************************/
S/* These two structures are unsigned analogues of ldiv_t and lldiv_t.        */
S/* They are used only by the fast integer division intrinsics                */
S/*****************************************************************************/
S#pragma diag_push
S#pragma CHECK_MISRA("-5.7") /* Must have equivalent field names to ldiv_t and
S                               lldiv_t for usability */
S
Stypedef struct { unsigned long quot; unsigned long rem; }            __uldiv_t;
Stypedef struct { unsigned long long quot; unsigned long long rem; } __ulldiv_t;
S
S#pragma diag_pop
S
S/*****************************************************************************/
S/* NOTE: The result of division between two unsigned values does not vary    */
S/*       between traditional, euclidean, and modulo versions. Thus, only     */
S/*       traditional versions are provided for unsigned inputs               */
S/*****************************************************************************/
S
S/* 16-bit by 16-bit */
Sldiv_t __attribute__((builtin))
S__traditional_div_i16byi16(int numerator, int denominator);
Sldiv_t __attribute__((builtin))
S__euclidean_div_i16byi16(int numerator, int denominator);
Sldiv_t __attribute__((builtin))
S__modulo_div_i16byi16(int numerator, int denominator);
S
S__uldiv_t __attribute__((builtin))
S__traditional_div_u16byu16(unsigned int numerator, unsigned int denominator);
S
S/* 32-bit by 32-bit */
Sldiv_t __attribute__((builtin))
S__traditional_div_i32byi32(long numerator, long denominator);
Sldiv_t __attribute__((builtin))
S__euclidean_div_i32byi32(long numerator, long denominator);
Sldiv_t __attribute__((builtin))
S__modulo_div_i32byi32(long numerator, long denominator);
S
Sldiv_t __attribute__((builtin))
S__traditional_div_i32byu32(long numerator, unsigned long denominator);
S/* Declared above for all C200 targets */
S/* ldiv_t __attribute__((builtin))
S__euclidean_div_i32byu32(long numerator, unsigned long denominator); */
Sldiv_t __attribute__((builtin))
S__modulo_div_i32byu32(long numerator, unsigned long denominator);
S
S__uldiv_t __attribute__((builtin))
S__traditional_div_u32byu32(unsigned long numerator, unsigned long denominator);
S
S/* 32-bit by 16-bit */
Sldiv_t __attribute__((builtin))
S__traditional_div_i32byi16(long numerator, int denominator);
Sldiv_t __attribute__((builtin))
S__euclidean_div_i32byi16(long numerator, int denominator);
Sldiv_t __attribute__((builtin))
S__modulo_div_i32byi16(long numerator, int denominator);
S
S__uldiv_t __attribute__((builtin))
S__traditional_div_u32byu16(unsigned long numerator, unsigned int denominator);
S
S/* 64-bit by 64-bit */
Slldiv_t __attribute__((builtin))
S__traditional_div_i64byi64(long long numerator, long long denominator);
Slldiv_t __attribute__((builtin))
S__euclidean_div_i64byi64(long long numerator, long long denominator);
Slldiv_t __attribute__((builtin))
S__modulo_div_i64byi64(long long numerator, long long denominator);
S
Slldiv_t __attribute__((builtin))
S__traditional_div_i64byu64(long long numerator, unsigned long long denominator);
Slldiv_t __attribute__((builtin))
S__euclidean_div_i64byu64(long long numerator, unsigned long long denominator);
Slldiv_t __attribute__((builtin))
S__modulo_div_i64byu64(long long numerator, unsigned long long denominator);
S
S__ulldiv_t __attribute__((builtin))
S__traditional_div_u64byu64(unsigned long long numerator,
S                           unsigned long long denominator);
S
S/* 64-bit by 32-bit */
S/*
Slldiv_t __attribute__((builtin))
S__traditional_div_i64byi32(unsigned long long numerator, long denominator);
Slldiv_t __attribute__((builtin))
S__euclidean_div_i64byi32(unsigned long long numerator, long denominator);
Slldiv_t __attribute__((builtin))
S__modulo_div_i64byi32(unsigned long long numerator, long denominator);
S
Slldiv_t __attribute__((builtin))
S__traditional_div_i64byu32(unsigned long long numerator,
S                           unsigned long denominator);
Slldiv_t __attribute__((builtin))
S__euclidean_div_i64byu32(unsigned long long numerator,
S                         unsigned long denominator);
Slldiv_t __attribute__((builtin))
S__modulo_div_i64byu32(unsigned long long numerator, unsigned long denominator);
S
S__ulldiv_t __attribute__((builtin))
S__traditional_div_u64byu32(unsigned long long numerator,
S                           unsigned long denominator);
S*/
S#define __traditional_div_i64byi32(n, d) \
S    __traditional_div_i64byi64((n), (long long)(d))
X#define __traditional_div_i64byi32(n, d)     __traditional_div_i64byi64((n), (long long)(d))
S#define __euclidean_div_i64byi32(n, d) \
S    __euclidean_div_i64byi64((n), (long long)d)
X#define __euclidean_div_i64byi32(n, d)     __euclidean_div_i64byi64((n), (long long)d)
S#define __modulo_div_i64byi32(n, d) \
S    __modulo_div_i64byi64((n), (long long)d)
X#define __modulo_div_i64byi32(n, d)     __modulo_div_i64byi64((n), (long long)d)
S
S#define __traditional_div_i64byu32(n, d) \
S    __traditional_div_i64byu64((n), (unsigned long long)d)
X#define __traditional_div_i64byu32(n, d)     __traditional_div_i64byu64((n), (unsigned long long)d)
S#define __euclidean_div_i64byu32(n, d) \
S    __euclidean_div_i64byu64((n), (unsigned long long)d)
X#define __euclidean_div_i64byu32(n, d)     __euclidean_div_i64byu64((n), (unsigned long long)d)
S#define __modulo_div_i64byu32(n, d) \
S    __modulo_div_i64byu64((n), (unsigned long long)d)
X#define __modulo_div_i64byu32(n, d)     __modulo_div_i64byu64((n), (unsigned long long)d)
S
S#define __traditional_div_u64byu32(n, d) \
S    __traditional_div_u64byu64((n), (unsigned long long)d)
X#define __traditional_div_u64byu32(n, d)     __traditional_div_u64byu64((n), (unsigned long long)d)
S
S/* ldiv and lldiv implementations using intrinsics. They are implemented using
S * inline functions so the address of the functions can be taken */
S#pragma diag_push
S#pragma CHECK_MISRA("-5.6") /* We use a preprocessor macro to optimize ldiv
S                               and lldiv standard functions */
S
S#define ldiv __fast_ldiv
S__inline ldiv_t __fast_ldiv(long _numer, long _denom);
S__inline ldiv_t __fast_ldiv(long _numer, long _denom)
S{
S   return __traditional_div_i32byi32(_numer, _denom);
S}
S
S#define lldiv __fast_lldiv
S__inline lldiv_t __fast_lldiv(long long _numer, long long _denom);
S__inline lldiv_t __fast_lldiv(long long _numer, long long _denom)
S{
S   return __traditional_div_i64byi64(_numer, _denom);
S}
S
S#pragma diag_pop
S
S# endif /* defined(__TMS320C28XX_FAST_IDIV__) */
S
S#pragma diag_pop
S
N#endif
N
N#pragma diag_pop
N
N#if defined(_AEABI_PORTABILITY_LEVEL) && _AEABI_PORTABILITY_LEVEL != 0 && \
N   !defined(_AEABI_PORTABLE)
X#if 0L && _AEABI_PORTABILITY_LEVEL != 0 &&    !0L
S#define _AEABI_PORTABLE
N#endif
N
N#endif  /* ! _STDLIB_H_ */
N
N#pragma diag_push
N#pragma CHECK_MISRA("-19.15") /* FreeBSD library requires code outside of the
N                                 include guard */
N
N/*----------------------------------------------------------------------------*/
N/* If sys/cdefs.h is available, go ahead and include it. xlocale.h assumes    */
N/* this file will have already included sys/cdefs.h.                          */
N/*----------------------------------------------------------------------------*/
N#if __has_include(<sys/cdefs.h>)
X#if 1
N#include <sys/cdefs.h>
N#endif
N
N/*----------------------------------------------------------------------------*/
N/* Include xlocale/_stdlib.h if xlocale.h has already been included. This     */
N/* comes from FreeBSD's stdlib.h.                                             */
N/*----------------------------------------------------------------------------*/
N#ifdef _XLOCALE_H_
S#include <sys/_types.h>
S__BEGIN_DECLS
S#include <xlocale/_stdlib.h>
S__END_DECLS
N#endif
N
N#pragma diag_pop
L 95 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/stdlib.h" 2
N
N#ifdef __cplusplus
N
Nextern "C++" {
N
N#undef abs
N#undef div
N#undef labs
N#undef ldiv
N#ifndef _LIBCPP_HAS_NO_LONG_LONG
N#undef llabs
N#undef lldiv
N#endif
N
N/* MSVCRT already has the correct prototype in <stdlib.h> if __cplusplus is defined */
N#if !defined(_LIBCPP_MSVCRT) && !defined(__sun__) && !defined(_AIX)
X#if !0L && !0L && !0L
Ninline _LIBCPP_INLINE_VISIBILITY long      abs(     long __x) _NOEXCEPT {return  labs(__x);}
Xinline __attribute__ ((__always_inline__)) long      abs(     long __x) noexcept {return  labs(__x);}
N#ifndef _LIBCPP_HAS_NO_LONG_LONG
Ninline _LIBCPP_INLINE_VISIBILITY long long abs(long long __x) _NOEXCEPT {return llabs(__x);}
Xinline __attribute__ ((__always_inline__)) long long abs(long long __x) noexcept {return llabs(__x);}
N#endif /* _LIBCPP_HAS_NO_LONG_LONG */
N
Ninline _LIBCPP_INLINE_VISIBILITY  ldiv_t div(     long __x,      long __y) _NOEXCEPT {return  ldiv(__x, __y);}
Xinline __attribute__ ((__always_inline__))  ldiv_t div(     long __x,      long __y) noexcept {return  ldiv(__x, __y);}
N#ifndef _LIBCPP_HAS_NO_LONG_LONG
Ninline _LIBCPP_INLINE_VISIBILITY lldiv_t div(long long __x, long long __y) _NOEXCEPT {return lldiv(__x, __y);}
Xinline __attribute__ ((__always_inline__)) lldiv_t div(long long __x, long long __y) noexcept {return lldiv(__x, __y);}
N#endif /* _LIBCPP_HAS_NO_LONG_LONG */
N#endif /* _LIBCPP_MSVCRT / __sun__ / _AIX */
N
N}  /* extern "C++" */
N
N#endif  /* __cplusplus */
N
N#endif  /* _LIBCPP_STDLIB_H */
L 87 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/cstdlib" 2
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N#ifdef __GNUC__
S#define _LIBCPP_UNREACHABLE() __builtin_unreachable()
N#else
N#define _LIBCPP_UNREACHABLE() _VSTD::abort()
N#endif
N
N_LIBCPP_BEGIN_NAMESPACE_STD
Xnamespace std { inline namespace __2 {
N
Nusing ::size_t;
Nusing ::div_t;
Nusing ::ldiv_t;
N#ifndef _LIBCPP_HAS_NO_LONG_LONG
Nusing ::lldiv_t;
N#endif // _LIBCPP_HAS_NO_LONG_LONG
Nusing ::atof;
Nusing ::atoi;
Nusing ::atol;
N#ifndef _LIBCPP_HAS_NO_LONG_LONG
Nusing ::atoll;
N#endif // _LIBCPP_HAS_NO_LONG_LONG
Nusing ::strtod;
Nusing ::strtof;
Nusing ::strtold;
Nusing ::strtol;
N#ifndef _LIBCPP_HAS_NO_LONG_LONG
Nusing ::strtoll;
N#endif // _LIBCPP_HAS_NO_LONG_LONG
Nusing ::strtoul;
N#ifndef _LIBCPP_HAS_NO_LONG_LONG
Nusing ::strtoull;
N#endif // _LIBCPP_HAS_NO_LONG_LONG
Nusing ::rand;
Nusing ::srand;
Nusing ::calloc;
Nusing ::free;
Nusing ::malloc;
Nusing ::realloc;
Nusing ::abort;
Nusing ::atexit;
Nusing ::exit;
Nusing ::_Exit;
N#ifndef _LIBCPP_WINDOWS_STORE_APP
Nusing ::getenv;
Nusing ::system;
N#endif
Nusing ::bsearch;
Nusing ::qsort;
Nusing ::abs;
Nusing ::labs;
N#ifndef _LIBCPP_HAS_NO_LONG_LONG
Nusing ::llabs;
N#endif // _LIBCPP_HAS_NO_LONG_LONG
Nusing ::div;
Nusing ::ldiv;
N#ifndef _LIBCPP_HAS_NO_LONG_LONG
Nusing ::lldiv;
N#endif // _LIBCPP_HAS_NO_LONG_LONG
Nusing ::mblen;
Nusing ::mbtowc;
Nusing ::wctomb;
Nusing ::mbstowcs;
Nusing ::wcstombs;
N#ifdef _LIBCPP_HAS_QUICK_EXIT
Susing ::at_quick_exit;
Susing ::quick_exit;
N#endif
N#ifdef _LIBCPP_HAS_C11_FEATURES
Susing ::aligned_alloc;
N#endif
N
N_LIBCPP_END_NAMESPACE_STD
X} }
N
N#endif  // _LIBCPP_CSTDLIB
L 83 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/exception" 2
N#include <type_traits>
N
N#if defined(_LIBCPP_ABI_MICROSOFT) && !defined(_LIBCPP_NO_VCRUNTIME)
X#if 0L && !0L
S#include <vcruntime_exception.h>
N#endif
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
Nnamespace std  // purposefully not using versioning namespace
N{
N
N#if !defined(_LIBCPP_ABI_MICROSOFT) || defined(_LIBCPP_NO_VCRUNTIME)
X#if !0L || 0L
Nclass _LIBCPP_EXCEPTION_ABI exception
Xclass  exception
N{
Npublic:
N    _LIBCPP_INLINE_VISIBILITY exception() _NOEXCEPT {}
X    __attribute__ ((__always_inline__)) exception() noexcept {}
N    virtual ~exception() _NOEXCEPT;
X    virtual ~exception() noexcept;
N    virtual const char* what() const _NOEXCEPT;
X    virtual const char* what() const noexcept;
N};
N
Nclass _LIBCPP_EXCEPTION_ABI bad_exception
Xclass  bad_exception
N    : public exception
N{
Npublic:
N    _LIBCPP_INLINE_VISIBILITY bad_exception() _NOEXCEPT {}
X    __attribute__ ((__always_inline__)) bad_exception() noexcept {}
N    virtual ~bad_exception() _NOEXCEPT;
X    virtual ~bad_exception() noexcept;
N    virtual const char* what() const _NOEXCEPT;
X    virtual const char* what() const noexcept;
N};
N#endif // !_LIBCPP_ABI_MICROSOFT || _LIBCPP_NO_VCRUNTIME
N
N#if _LIBCPP_STD_VER <= 14 \
N    || defined(_LIBCPP_ENABLE_CXX17_REMOVED_UNEXPECTED_FUNCTIONS) \
N    || defined(_LIBCPP_BUILDING_LIBRARY)
X#if 14 <= 14     || 0L     || 0L
Ntypedef void (*unexpected_handler)();
N_LIBCPP_FUNC_VIS unexpected_handler set_unexpected(unexpected_handler) _NOEXCEPT;
X unexpected_handler set_unexpected(unexpected_handler) noexcept;
N_LIBCPP_FUNC_VIS unexpected_handler get_unexpected() _NOEXCEPT;
X unexpected_handler get_unexpected() noexcept;
N_LIBCPP_NORETURN _LIBCPP_FUNC_VIS void unexpected();
X[[noreturn]]  void unexpected();
N#endif
N
Ntypedef void (*terminate_handler)();
N_LIBCPP_FUNC_VIS terminate_handler set_terminate(terminate_handler) _NOEXCEPT;
X terminate_handler set_terminate(terminate_handler) noexcept;
N_LIBCPP_FUNC_VIS terminate_handler get_terminate() _NOEXCEPT;
X terminate_handler get_terminate() noexcept;
N_LIBCPP_NORETURN _LIBCPP_FUNC_VIS void terminate() _NOEXCEPT;
X[[noreturn]]  void terminate() noexcept;
N
N_LIBCPP_FUNC_VIS bool uncaught_exception() _NOEXCEPT;
X bool uncaught_exception() noexcept;
N_LIBCPP_FUNC_VIS _LIBCPP_AVAILABILITY_UNCAUGHT_EXCEPTIONS int uncaught_exceptions() _NOEXCEPT;
X  int uncaught_exceptions() noexcept;
N
Nclass _LIBCPP_TYPE_VIS exception_ptr;
Xclass  exception_ptr;
N
N_LIBCPP_FUNC_VIS exception_ptr current_exception() _NOEXCEPT;
X exception_ptr current_exception() noexcept;
N_LIBCPP_NORETURN _LIBCPP_FUNC_VIS void rethrow_exception(exception_ptr);
X[[noreturn]]  void rethrow_exception(exception_ptr);
N
N#ifndef _LIBCPP_ABI_MICROSOFT
N
Nclass _LIBCPP_TYPE_VIS exception_ptr
Xclass  exception_ptr
N{
N    void* __ptr_;
Npublic:
N    _LIBCPP_INLINE_VISIBILITY exception_ptr() _NOEXCEPT : __ptr_() {}
X    __attribute__ ((__always_inline__)) exception_ptr() noexcept : __ptr_() {}
N    _LIBCPP_INLINE_VISIBILITY exception_ptr(nullptr_t) _NOEXCEPT : __ptr_() {}
X    __attribute__ ((__always_inline__)) exception_ptr(nullptr_t) noexcept : __ptr_() {}
N
N    exception_ptr(const exception_ptr&) _NOEXCEPT;
X    exception_ptr(const exception_ptr&) noexcept;
N    exception_ptr& operator=(const exception_ptr&) _NOEXCEPT;
X    exception_ptr& operator=(const exception_ptr&) noexcept;
N    ~exception_ptr() _NOEXCEPT;
X    ~exception_ptr() noexcept;
N
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT
X    __attribute__ ((__always_inline__)) explicit operator bool() const noexcept
N    {return __ptr_ != nullptr;}
N
N    friend _LIBCPP_INLINE_VISIBILITY
X    friend __attribute__ ((__always_inline__))
N    bool operator==(const exception_ptr& __x, const exception_ptr& __y) _NOEXCEPT
X    bool operator==(const exception_ptr& __x, const exception_ptr& __y) noexcept
N        {return __x.__ptr_ == __y.__ptr_;}
N
N    friend _LIBCPP_INLINE_VISIBILITY
X    friend __attribute__ ((__always_inline__))
N    bool operator!=(const exception_ptr& __x, const exception_ptr& __y) _NOEXCEPT
X    bool operator!=(const exception_ptr& __x, const exception_ptr& __y) noexcept
N        {return !(__x == __y);}
N
N    friend _LIBCPP_FUNC_VIS exception_ptr current_exception() _NOEXCEPT;
X    friend  exception_ptr current_exception() noexcept;
N    friend _LIBCPP_FUNC_VIS void rethrow_exception(exception_ptr);
X    friend  void rethrow_exception(exception_ptr);
N};
N
Ntemplate<class _Ep>
Nexception_ptr
Nmake_exception_ptr(_Ep __e) _NOEXCEPT
Xmake_exception_ptr(_Ep __e) noexcept
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
S        throw __e;
S    }
S    catch (...)
S    {
S        return current_exception();
S    }
N#else
N    ((void)__e);
N    _VSTD::abort();
X    std::__2::abort();
N#endif
N}
N
N#else // _LIBCPP_ABI_MICROSOFT
S
Sclass _LIBCPP_TYPE_VIS exception_ptr
S{
S#if defined(__clang__)
S#pragma clang diagnostic push
S#pragma clang diagnostic ignored "-Wunused-private-field"
S#endif
S    void* __ptr1_;
S    void* __ptr2_;
S#if defined(__clang__)
S#pragma clang diagnostic pop
S#endif
Spublic:
S    exception_ptr() _NOEXCEPT;
S    exception_ptr(nullptr_t) _NOEXCEPT;
S    exception_ptr(const exception_ptr& __other) _NOEXCEPT;
S    exception_ptr& operator=(const exception_ptr& __other) _NOEXCEPT;
S    exception_ptr& operator=(nullptr_t) _NOEXCEPT;
S    ~exception_ptr() _NOEXCEPT;
S    _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT;
S};
S
S_LIBCPP_FUNC_VIS
Sbool operator==(const exception_ptr& __x, const exception_ptr& __y) _NOEXCEPT;
S
Sinline _LIBCPP_INLINE_VISIBILITY
Sbool operator!=(const exception_ptr& __x, const exception_ptr& __y) _NOEXCEPT
S    {return !(__x == __y);}
S
S_LIBCPP_FUNC_VIS void swap(exception_ptr&, exception_ptr&) _NOEXCEPT;
S
S_LIBCPP_FUNC_VIS exception_ptr __copy_exception_ptr(void *__except, const void* __ptr);
S_LIBCPP_FUNC_VIS exception_ptr current_exception() _NOEXCEPT;
S_LIBCPP_NORETURN _LIBCPP_FUNC_VIS void rethrow_exception(exception_ptr p);
S
S// This is a built-in template function which automagically extracts the required
S// information.
Stemplate <class _E> void *__GetExceptionInfo(_E);
S
Stemplate<class _Ep>
Sexception_ptr
Smake_exception_ptr(_Ep __e) _NOEXCEPT
S{
S  return __copy_exception_ptr(_VSTD::addressof(__e), __GetExceptionInfo(__e));
S}
S
N#endif // _LIBCPP_ABI_MICROSOFT
N// nested_exception
N
Nclass _LIBCPP_EXCEPTION_ABI nested_exception
Xclass  nested_exception
N{
N    exception_ptr __ptr_;
Npublic:
N    nested_exception() _NOEXCEPT;
X    nested_exception() noexcept;
N//     nested_exception(const nested_exception&) noexcept = default;
N//     nested_exception& operator=(const nested_exception&) noexcept = default;
N    virtual ~nested_exception() _NOEXCEPT;
X    virtual ~nested_exception() noexcept;
N
N    // access functions
N    _LIBCPP_NORETURN void rethrow_nested() const;
X    [[noreturn]] void rethrow_nested() const;
N    _LIBCPP_INLINE_VISIBILITY exception_ptr nested_ptr() const _NOEXCEPT {return __ptr_;}
X    __attribute__ ((__always_inline__)) exception_ptr nested_ptr() const noexcept {return __ptr_;}
N};
N
Ntemplate <class _Tp>
Nstruct __nested
N    : public _Tp,
N      public nested_exception
N{
N    _LIBCPP_INLINE_VISIBILITY explicit __nested(const _Tp& __t) : _Tp(__t) {}
X    __attribute__ ((__always_inline__)) explicit __nested(const _Tp& __t) : _Tp(__t) {}
N};
N
N#ifndef _LIBCPP_NO_EXCEPTIONS
Stemplate <class _Tp, class _Up, bool>
Sstruct __throw_with_nested;
S
Stemplate <class _Tp, class _Up>
Sstruct __throw_with_nested<_Tp, _Up, true> {
S    _LIBCPP_NORETURN static inline _LIBCPP_ALWAYS_INLINE void
S#ifndef _LIBCPP_CXX03_LANG
S    __do_throw(_Tp&& __t)
S#else
S    __do_throw (_Tp& __t)
S#endif  // _LIBCPP_CXX03_LANG
S    {
S        throw __nested<_Up>(_VSTD::forward<_Tp>(__t));
S    }
S};
S
Stemplate <class _Tp, class _Up>
Sstruct __throw_with_nested<_Tp, _Up, false> {
S    _LIBCPP_NORETURN static inline _LIBCPP_ALWAYS_INLINE void
S#ifndef _LIBCPP_CXX03_LANG
S    __do_throw(_Tp&& __t)
S#else
S    __do_throw (_Tp& __t)
S#endif  // _LIBCPP_CXX03_LANG
S    {
S        throw _VSTD::forward<_Tp>(__t);
S    }
S};
N#endif
N
Ntemplate <class _Tp>
N_LIBCPP_NORETURN
X[[noreturn]]
Nvoid
N#ifndef _LIBCPP_CXX03_LANG
Nthrow_with_nested(_Tp&& __t)
N#else
Sthrow_with_nested (_Tp& __t)
N#endif // _LIBCPP_CXX03_LANG
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    typedef typename decay<_Tp>::type _Up;
S    static_assert( is_copy_constructible<_Up>::value, "type thrown must be CopyConstructible");
S    __throw_with_nested<_Tp, _Up,
S        is_class<_Up>::value &&
S        !is_base_of<nested_exception, _Up>::value &&
S        !__libcpp_is_final<_Up>::value>::
S            __do_throw(_VSTD::forward<_Tp>(__t));
N#else
N    ((void)__t);
N    // FIXME: Make this abort
N#endif
N}
N
Ntemplate <class _From, class _To>
Nstruct __can_dynamic_cast : public _LIBCPP_BOOL_CONSTANT(
N              is_polymorphic<_From>::value &&
N                 (!is_base_of<_To, _From>::value ||
N                   is_convertible<const _From*, const _To*>::value)) {};
Xstruct __can_dynamic_cast : public integral_constant<bool,(is_polymorphic<_From> ::value && (!is_base_of<_To, _From> ::value || is_convertible<const _From*, const _To* > ::value))> {};
N
Ntemplate <class _Ep>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Nrethrow_if_nested(const _Ep& __e,
N                  typename enable_if< __can_dynamic_cast<_Ep, nested_exception>::value>::type* = 0)
N{
N    const nested_exception* __nep = dynamic_cast<const nested_exception*>(_VSTD::addressof(__e));
X    const nested_exception* __nep = dynamic_cast<const nested_exception*>(std::__2::addressof(__e));
N    if (__nep)
N        __nep->rethrow_nested();
N}
N
Ntemplate <class _Ep>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Nrethrow_if_nested(const _Ep&,
N                  typename enable_if<!__can_dynamic_cast<_Ep, nested_exception>::value>::type* = 0)
N{
N}
N
N}  // std
N
N#endif  // _LIBCPP_EXCEPTION
L 62 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/typeinfo" 2
N#include <cstddef>
N#include <cstdint>
N#ifdef _LIBCPP_NO_EXCEPTIONS
N#include <cstdlib>
N#endif
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N#if !defined(_LIBCPP_ABI_MICROSOFT)
X#if !0L
N#if defined(_LIBCPP_NONUNIQUE_RTTI_BIT)
X#if 0L
S#define _LIBCPP_HAS_NONUNIQUE_TYPEINFO
N#else
N#define _LIBCPP_HAS_UNIQUE_TYPEINFO
N#endif
N#endif
N
Nnamespace std  // purposefully not using versioning namespace
N{
N
N#ifdef __EDG_VERSION__
N#pragma define_type_info
N#endif /* defined(__EDG_VERSION__) */
Nclass _LIBCPP_EXCEPTION_ABI type_info
Xclass  type_info
N{
N    type_info& operator=(const type_info&);
N    type_info(const type_info&);
N
N#if defined(_LIBCPP_HAS_NONUNIQUE_TYPEINFO)
X#if 0L
S    _LIBCPP_INLINE_VISIBILITY
S    int __compare_nonunique_names(const type_info &__arg) const _NOEXCEPT
S    { return __builtin_strcmp(name(), __arg.name()); }
N#endif
N#if defined(_LIBCPP_HAS_NONUNIQUE_TYPEINFO) || defined(__MSP430__)
X#if 0L || 0L
S    _LIBCPP_INLINE_VISIBILITY
S    size_t __hash_typeinfo_name() const _NOEXCEPT
S    {
S      const char* __ptr = name();
S      size_t __hash = 5381;
S      while (unsigned char __c = static_cast<unsigned char>(*__ptr++))
S        __hash = (__hash * 33) ^ __c;
S      return __hash;
S    }
N#endif // defined(_LIBCPP_HAS_NONUNIQUE_TYPEINFO) || defined(__MSP430__)
N
N#if defined(_LIBCPP_ABI_MICROSOFT)
X#if 0L
S    mutable struct {
S      const char *__undecorated_name;
S      const char __decorated_name[1];
S    } __data;
S
S    int __compare(const type_info &__rhs) const _NOEXCEPT;
N#endif // _LIBCPP_ABI_MICROSOFT
N
Nprotected:
N#if !defined(_LIBCPP_ABI_MICROSOFT)
X#if !0L
N#if defined(_LIBCPP_HAS_NONUNIQUE_TYPEINFO)
X#if 0L
S    // A const char* with the non-unique RTTI bit possibly set.
S    uintptr_t __type_name;
S
S    _LIBCPP_INLINE_VISIBILITY
S    explicit type_info(const char* __n)
S      : __type_name(reinterpret_cast<uintptr_t>(__n)) {}
N#else
N    const char *__type_name;
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    explicit type_info(const char* __n) : __type_name(__n) {}
N#endif
N#endif // ! _LIBCPP_ABI_MICROSOFT
N
Npublic:
N    _LIBCPP_AVAILABILITY_TYPEINFO_VTABLE
X    
N    virtual ~type_info();
N
N#if defined(_LIBCPP_ABI_MICROSOFT)
X#if 0L
S    const char *name() const _NOEXCEPT;
S
S    _LIBCPP_INLINE_VISIBILITY
S    bool before(const type_info& __arg) const _NOEXCEPT {
S      return __compare(__arg) < 0;
S    }
S
S    size_t hash_code() const _NOEXCEPT;
S
S    _LIBCPP_INLINE_VISIBILITY
S    bool operator==(const type_info& __arg) const _NOEXCEPT {
S      return __compare(__arg) == 0;
S    }
N#else
N#if defined(_LIBCPP_HAS_NONUNIQUE_TYPEINFO)
X#if 0L
S    _LIBCPP_INLINE_VISIBILITY
S    const char* name() const _NOEXCEPT
S    {
S      return reinterpret_cast<const char*>(__type_name &
S                                           ~_LIBCPP_NONUNIQUE_RTTI_BIT);
S    }
S
S    _LIBCPP_INLINE_VISIBILITY
S    bool before(const type_info& __arg) const _NOEXCEPT
S    {
S      if (!((__type_name & __arg.__type_name) & _LIBCPP_NONUNIQUE_RTTI_BIT))
S        return __type_name < __arg.__type_name;
S      return __compare_nonunique_names(__arg) < 0;
S    }
S
S    _LIBCPP_INLINE_VISIBILITY
S    size_t hash_code() const _NOEXCEPT
S    {
S      if (!(__type_name & _LIBCPP_NONUNIQUE_RTTI_BIT))
S        return __type_name;
S      return __hash_typeinfo_name();
S    }
S
S    _LIBCPP_INLINE_VISIBILITY
S    bool operator==(const type_info& __arg) const _NOEXCEPT
S    {
S      if (__type_name == __arg.__type_name)
S        return true;
S
S      if (!((__type_name & __arg.__type_name) & _LIBCPP_NONUNIQUE_RTTI_BIT))
S        return false;
S      return __compare_nonunique_names(__arg) == 0;
S    }
N#else
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    const char* name() const _NOEXCEPT
X    const char* name() const noexcept
N    { return __type_name; }
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    bool before(const type_info& __arg) const _NOEXCEPT
X    bool before(const type_info& __arg) const noexcept
N    { return __type_name < __arg.__type_name; }
N
N#ifndef __MSP430__
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    size_t hash_code() const _NOEXCEPT
X    size_t hash_code() const noexcept
N    { return reinterpret_cast<size_t>(__type_name); }
N#else // defined(__MSP430__)
S    _LIBCPP_INLINE_VISIBILITY
S    size_t hash_code() const _NOEXCEPT
S    { return __hash_typeinfo_name(); }
N#endif // !defined(__MSP430__)
N
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    bool operator==(const type_info& __arg) const _NOEXCEPT
X    bool operator==(const type_info& __arg) const noexcept
N    { return __type_name == __arg.__type_name; }
N#endif
N#endif // _LIBCPP_ABI_MICROSOFT
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    bool operator!=(const type_info& __arg) const _NOEXCEPT
X    bool operator!=(const type_info& __arg) const noexcept
N    { return !operator==(__arg); }
N};
N
Nclass _LIBCPP_EXCEPTION_ABI bad_cast
Xclass  bad_cast
N    : public exception
N{
Npublic:
N    bad_cast() _NOEXCEPT;
X    bad_cast() noexcept;
N    virtual ~bad_cast() _NOEXCEPT;
X    virtual ~bad_cast() noexcept;
N    virtual const char* what() const _NOEXCEPT;
X    virtual const char* what() const noexcept;
N};
N
Nclass _LIBCPP_EXCEPTION_ABI bad_typeid
Xclass  bad_typeid
N    : public exception
N{
Npublic:
N    bad_typeid() _NOEXCEPT;
X    bad_typeid() noexcept;
N    virtual ~bad_typeid() _NOEXCEPT;
X    virtual ~bad_typeid() noexcept;
N    virtual const char* what() const _NOEXCEPT;
X    virtual const char* what() const noexcept;
N};
N
N}  // std
N
N_LIBCPP_BEGIN_NAMESPACE_STD
Xnamespace std { inline namespace __2 {
N_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE
X[[noreturn]] inline __attribute__ ((__always_inline__))
Nvoid __throw_bad_cast()
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    throw bad_cast();
N#else
N	_VSTD::abort();
X	std::__2::abort();
N#endif
N}
N_LIBCPP_END_NAMESPACE_STD
X} }
N
N#endif  // __LIBCPP_TYPEINFO
L 645 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/memory" 2
N#include <cstddef>
N#include <cstdint>
N#include <new>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/new" 1
N// -*- C++ -*-
N//===----------------------------- new ------------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is dual licensed under the MIT and the University of Illinois Open
N// Source Licenses. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP_NEW
N#define _LIBCPP_NEW
N
N/*
N    new synopsis
N
Nnamespace std
N{
N
Nclass bad_alloc
N    : public exception
N{
Npublic:
N    bad_alloc() noexcept;
N    bad_alloc(const bad_alloc&) noexcept;
N    bad_alloc& operator=(const bad_alloc&) noexcept;
N    virtual const char* what() const noexcept;
N};
N
Nclass bad_array_length : public bad_alloc // FIXME: Not part of C++
N{
Npublic:
N    bad_array_length() noexcept;
N};
N
Nclass bad_array_new_length : public bad_alloc // C++14
N{
Npublic:
N    bad_array_new_length() noexcept;
N};
N
Nenum class align_val_t : size_t {}; // C++17
Nstruct nothrow_t {};
Nextern const nothrow_t nothrow;
Ntypedef void (*new_handler)();
Nnew_handler set_new_handler(new_handler new_p) noexcept;
Nnew_handler get_new_handler() noexcept;
N
N}  // std
N
Nvoid* operator new(std::size_t size);                                   // replaceable
Nvoid* operator new(std::size_t size, std::align_val_t alignment);       // replaceable, C++17
Nvoid* operator new(std::size_t size, const std::nothrow_t&) noexcept;   // replaceable
Nvoid* operator new(std::size_t size, std::align_val_t alignment,
N                   const std::nothrow_t&) noexcept;                     // replaceable, C++17
Nvoid  operator delete(void* ptr) noexcept;                              // replaceable
Nvoid  operator delete(void* ptr, std::size_t size) noexcept;            // replaceable, C++14
Nvoid  operator delete(void* ptr, std::align_val_t alignment) noexcept;  // replaceable, C++17
Nvoid  operator delete(void* ptr, std::size_t size,
N                      std::align_val_t alignment) noexcept;             // replaceable, C++17
Nvoid  operator delete(void* ptr, const std::nothrow_t&) noexcept;       // replaceable
Nvoid  operator delete(void* ptr, std:align_val_t alignment,
N                      const std::nothrow_t&) noexcept;                  // replaceable, C++17
N
Nvoid* operator new[](std::size_t size);                                 // replaceable
Nvoid* operator new[](std::size_t size,
N                     std::align_val_t alignment) noexcept;              // replaceable, C++17
Nvoid* operator new[](std::size_t size, const std::nothrow_t&) noexcept; // replaceable
Nvoid* operator new[](std::size_t size, std::align_val_t alignment,
N                     const std::nothrow_t&) noexcept;                   // replaceable, C++17
Nvoid  operator delete[](void* ptr) noexcept;                            // replaceable
Nvoid  operator delete[](void* ptr, std::size_t size) noexcept;          // replaceable, C++14
Nvoid  operator delete[](void* ptr,
N                        std::align_val_t alignment) noexcept;           // replaceable, C++17
Nvoid  operator delete[](void* ptr, std::size_t size,
N                        std::align_val_t alignment) noexcept;           // replaceable, C++17
Nvoid  operator delete[](void* ptr, const std::nothrow_t&) noexcept;     // replaceable
Nvoid  operator delete[](void* ptr, std::align_val_t alignment,
N                        const std::nothrow_t&) noexcept;                // replaceable, C++17
N
Nvoid* operator new  (std::size_t size, void* ptr) noexcept;
Nvoid* operator new[](std::size_t size, void* ptr) noexcept;
Nvoid  operator delete  (void* ptr, void*) noexcept;
Nvoid  operator delete[](void* ptr, void*) noexcept;
N
N*/
N
N#include <__config>
N#include <exception>
N#include <cstddef>
N#ifdef _LIBCPP_NO_EXCEPTIONS
N#include <cstdlib>
N#endif
N
N#if defined(_LIBCPP_ABI_MICROSOFT) && !defined(_LIBCPP_NO_VCRUNTIME)
X#if 0L && !0L
S#include <new.h>
N#endif
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N#if !(defined(_LIBCPP_BUILDING_NEW) || _LIBCPP_STD_VER >= 14 || \
N    (defined(__cpp_sized_deallocation) && __cpp_sized_deallocation >= 201309))
X#if !(0L || 14 >= 14 ||     (1L && 201309 >= 201309))
S# define _LIBCPP_HAS_NO_SIZED_DEALLOCATION
N#endif
N
N#if !defined(_LIBCPP_HAS_NO_ALIGNED_ALLOCATION) && \
N    (!(defined(_LIBCPP_BUILDING_NEW) || _LIBCPP_STD_VER > 14 || \
N    (defined(__cpp_aligned_new) && __cpp_aligned_new >= 201606)))
X#if !1L &&     (!(0L || 14 > 14 ||     (0L && __cpp_aligned_new >= 201606)))
S# define _LIBCPP_HAS_NO_ALIGNED_ALLOCATION
N#endif
N
Nnamespace std  // purposefully not using versioning namespace
N{
N
N#if !defined(_LIBCPP_ABI_MICROSOFT) || defined(_LIBCPP_NO_VCRUNTIME)
X#if !0L || 0L
Nstruct _LIBCPP_TYPE_VIS nothrow_t {};
Xstruct  nothrow_t {};
Nextern _LIBCPP_FUNC_VIS const nothrow_t nothrow;
Xextern  const nothrow_t nothrow;
N
Nclass _LIBCPP_EXCEPTION_ABI bad_alloc
Xclass  bad_alloc
N    : public exception
N{
Npublic:
N    bad_alloc() _NOEXCEPT;
X    bad_alloc() noexcept;
N    virtual ~bad_alloc() _NOEXCEPT;
X    virtual ~bad_alloc() noexcept;
N    virtual const char* what() const _NOEXCEPT;
X    virtual const char* what() const noexcept;
N};
N
Nclass _LIBCPP_EXCEPTION_ABI bad_array_new_length
Xclass  bad_array_new_length
N    : public bad_alloc
N{
Npublic:
N    bad_array_new_length() _NOEXCEPT;
X    bad_array_new_length() noexcept;
N    virtual ~bad_array_new_length() _NOEXCEPT;
X    virtual ~bad_array_new_length() noexcept;
N    virtual const char* what() const _NOEXCEPT;
X    virtual const char* what() const noexcept;
N};
N
Ntypedef void (*new_handler)();
N_LIBCPP_FUNC_VIS new_handler set_new_handler(new_handler) _NOEXCEPT;
X new_handler set_new_handler(new_handler) noexcept;
N_LIBCPP_FUNC_VIS new_handler get_new_handler() _NOEXCEPT;
X new_handler get_new_handler() noexcept;
N
N#endif // !_LIBCPP_ABI_MICROSOFT || _LIBCPP_NO_VCRUNTIME
N
N_LIBCPP_NORETURN _LIBCPP_FUNC_VIS void __throw_bad_alloc();  // not in C++ spec
X[[noreturn]]  void __throw_bad_alloc();  
N
N#if defined(_LIBCPP_BUILDING_LIBRARY) || (_LIBCPP_STD_VER > 11)
X#if 0L || (14 > 11)
N
Nclass _LIBCPP_EXCEPTION_ABI _LIBCPP_AVAILABILITY_BAD_ARRAY_LENGTH
Xclass  
N    bad_array_length : public bad_alloc {
Npublic:
N    bad_array_length() _NOEXCEPT;
X    bad_array_length() noexcept;
N    virtual ~bad_array_length() _NOEXCEPT;
X    virtual ~bad_array_length() noexcept;
N    virtual const char* what() const _NOEXCEPT;
X    virtual const char* what() const noexcept;
N};
N
N#define _LIBCPP_BAD_ARRAY_LENGTH_DEFINED
N
N#endif  // defined(_LIBCPP_BUILDING_NEW) || (_LIBCPP_STD_VER > 11)
N
N#if !defined(_LIBCPP_HAS_NO_ALIGNED_ALLOCATION) || _LIBCPP_STD_VER > 14
X#if !1L || 14 > 14
S#ifndef _LIBCPP_CXX03_LANG
Senum class _LIBCPP_ENUM_VIS align_val_t : size_t { };
S#else
Senum __attribute__((packed)) align_val_t { __zero = 0, __max = (size_t)-1 };
S#endif
N#endif
N
N}  // std
N
N#if defined(_LIBCPP_CXX03_LANG)
X#if 0L
S#define _THROW_BAD_ALLOC throw(std::bad_alloc)
N#else
N#define _THROW_BAD_ALLOC
N#endif
N
N#if !defined(_LIBCPP_ABI_MICROSOFT) || defined(_LIBCPP_NO_VCRUNTIME)
X#if !0L || 0L
N
N_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new(std::size_t __sz) _THROW_BAD_ALLOC;
X void* operator new(std::size_t __sz) ;
N_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new(std::size_t __sz, const std::nothrow_t&) _NOEXCEPT _NOALIAS;
X void* operator new(std::size_t __sz, const std::nothrow_t&) noexcept ;
N_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete(void* __p) _NOEXCEPT;
X void  operator delete(void* __p) noexcept;
N_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete(void* __p, const std::nothrow_t&) _NOEXCEPT;
X void  operator delete(void* __p, const std::nothrow_t&) noexcept;
N#ifndef _LIBCPP_HAS_NO_SIZED_DEALLOCATION
N_LIBCPP_OVERRIDABLE_FUNC_VIS _LIBCPP_AVAILABILITY_SIZED_NEW_DELETE void  operator delete(void* __p, std::size_t __sz) _NOEXCEPT;
X  void  operator delete(void* __p, std::size_t __sz) noexcept;
N#endif
N
N_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new[](std::size_t __sz) _THROW_BAD_ALLOC;
X void* operator new[](std::size_t __sz) ;
N_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new[](std::size_t __sz, const std::nothrow_t&) _NOEXCEPT _NOALIAS;
X void* operator new[](std::size_t __sz, const std::nothrow_t&) noexcept ;
N_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete[](void* __p) _NOEXCEPT;
X void  operator delete[](void* __p) noexcept;
N_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete[](void* __p, const std::nothrow_t&) _NOEXCEPT;
X void  operator delete[](void* __p, const std::nothrow_t&) noexcept;
N#ifndef _LIBCPP_HAS_NO_SIZED_DEALLOCATION
N_LIBCPP_OVERRIDABLE_FUNC_VIS _LIBCPP_AVAILABILITY_SIZED_NEW_DELETE void  operator delete[](void* __p, std::size_t __sz) _NOEXCEPT;
X  void  operator delete[](void* __p, std::size_t __sz) noexcept;
N#endif
N
N#ifndef _LIBCPP_HAS_NO_ALIGNED_ALLOCATION
S_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new(std::size_t __sz, std::align_val_t) _THROW_BAD_ALLOC;
S_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new(std::size_t __sz, std::align_val_t, const std::nothrow_t&) _NOEXCEPT _NOALIAS;
S_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete(void* __p, std::align_val_t) _NOEXCEPT;
S_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete(void* __p, std::align_val_t, const std::nothrow_t&) _NOEXCEPT;
S#ifndef _LIBCPP_HAS_NO_SIZED_DEALLOCATION
S_LIBCPP_OVERRIDABLE_FUNC_VIS _LIBCPP_AVAILABILITY_SIZED_NEW_DELETE void  operator delete(void* __p, std::size_t __sz, std::align_val_t) _NOEXCEPT;
S#endif
S
S_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new[](std::size_t __sz, std::align_val_t) _THROW_BAD_ALLOC;
S_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new[](std::size_t __sz, std::align_val_t, const std::nothrow_t&) _NOEXCEPT _NOALIAS;
S_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete[](void* __p, std::align_val_t) _NOEXCEPT;
S_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete[](void* __p, std::align_val_t, const std::nothrow_t&) _NOEXCEPT;
S#ifndef _LIBCPP_HAS_NO_SIZED_DEALLOCATION
S_LIBCPP_OVERRIDABLE_FUNC_VIS _LIBCPP_AVAILABILITY_SIZED_NEW_DELETE void  operator delete[](void* __p, std::size_t __sz, std::align_val_t) _NOEXCEPT;
S#endif
N#endif
N
Ninline _LIBCPP_INLINE_VISIBILITY void* operator new  (std::size_t, void* __p) _NOEXCEPT {return __p;}
Xinline __attribute__ ((__always_inline__)) void* operator new  (std::size_t, void* __p) noexcept {return __p;}
Ninline _LIBCPP_INLINE_VISIBILITY void* operator new[](std::size_t, void* __p) _NOEXCEPT {return __p;}
Xinline __attribute__ ((__always_inline__)) void* operator new[](std::size_t, void* __p) noexcept {return __p;}
Ninline _LIBCPP_INLINE_VISIBILITY void  operator delete  (void*, void*) _NOEXCEPT {}
Xinline __attribute__ ((__always_inline__)) void  operator delete  (void*, void*) noexcept {}
Ninline _LIBCPP_INLINE_VISIBILITY void  operator delete[](void*, void*) _NOEXCEPT {}
Xinline __attribute__ ((__always_inline__)) void  operator delete[](void*, void*) noexcept {}
N
N#endif // !_LIBCPP_ABI_MICROSOFT || _LIBCPP_NO_VCRUNTIME
N
N_LIBCPP_BEGIN_NAMESPACE_STD
Xnamespace std { inline namespace __2 {
N
Ninline _LIBCPP_INLINE_VISIBILITY void *__allocate(size_t __size) {
Xinline __attribute__ ((__always_inline__)) void *__allocate(size_t __size) {
N#ifdef _LIBCPP_HAS_NO_BUILTIN_OPERATOR_NEW_DELETE
N  return ::operator new(__size);
N#else
S  return __builtin_operator_new(__size);
N#endif
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY void __libcpp_deallocate(void *__ptr) {
Xinline __attribute__ ((__always_inline__)) void __libcpp_deallocate(void *__ptr) {
N#ifdef _LIBCPP_HAS_NO_BUILTIN_OPERATOR_NEW_DELETE
N  ::operator delete(__ptr);
N#else
S  __builtin_operator_delete(__ptr);
N#endif
N}
N
N#ifdef _LIBCPP_BAD_ARRAY_LENGTH_DEFINED
N_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE
X[[noreturn]] inline __attribute__ ((__always_inline__))
N#ifndef _LIBCPP_NO_EXCEPTIONS
S_LIBCPP_AVAILABILITY_BAD_ARRAY_LENGTH
N#endif
Nvoid __throw_bad_array_length()
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    throw bad_array_length();
N#else
N	_VSTD::abort();
X	std::__2::abort();
N#endif
N}
N#endif
N
N_LIBCPP_END_NAMESPACE_STD
X} }
N
N#endif  // _LIBCPP_NEW
L 648 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/memory" 2
N#include <utility>
N#include <limits>
N#include <iterator>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/iterator" 1
N// -*- C++ -*-
N//===-------------------------- iterator ----------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is dual licensed under the MIT and the University of Illinois Open
N// Source Licenses. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP_ITERATOR
N#define _LIBCPP_ITERATOR
N
N/*
N    iterator synopsis
N
Nnamespace std
N{
N
Ntemplate<class Iterator>
Nstruct iterator_traits
N{
N    typedef typename Iterator::difference_type difference_type;
N    typedef typename Iterator::value_type value_type;
N    typedef typename Iterator::pointer pointer;
N    typedef typename Iterator::reference reference;
N    typedef typename Iterator::iterator_category iterator_category;
N};
N
Ntemplate<class T>
Nstruct iterator_traits<T*>
N{
N    typedef ptrdiff_t difference_type;
N    typedef T value_type;
N    typedef T* pointer;
N    typedef T& reference;
N    typedef random_access_iterator_tag iterator_category;
N};
N
Ntemplate<class T>
Nstruct iterator_traits<const T*>
N{
N    typedef ptrdiff_t difference_type;
N    typedef T value_type;
N    typedef const T* pointer;
N    typedef const T& reference;
N    typedef random_access_iterator_tag iterator_category;
N};
N
Ntemplate<class Category, class T, class Distance = ptrdiff_t,
N         class Pointer = T*, class Reference = T&>
Nstruct iterator
N{
N    typedef T         value_type;
N    typedef Distance  difference_type;
N    typedef Pointer   pointer;
N    typedef Reference reference;
N    typedef Category  iterator_category;
N};
N
Nstruct input_iterator_tag  {};
Nstruct output_iterator_tag {};
Nstruct forward_iterator_tag       : public input_iterator_tag         {};
Nstruct bidirectional_iterator_tag : public forward_iterator_tag       {};
Nstruct random_access_iterator_tag : public bidirectional_iterator_tag {};
N
N// 27.4.3, iterator operations
N// extension: second argument not conforming to C++03
Ntemplate <class InputIterator>  // constexpr in C++17
N  constexpr void advance(InputIterator& i,
N             typename iterator_traits<InputIterator>::difference_type n);
N
Ntemplate <class InputIterator>  // constexpr in C++17
N  constexpr typename iterator_traits<InputIterator>::difference_type
N    distance(InputIterator first, InputIterator last);
N
Ntemplate <class InputIterator>  // constexpr in C++17
N  constexpr InputIterator next(InputIterator x,
Ntypename iterator_traits<InputIterator>::difference_type n = 1);
N
Ntemplate <class BidirectionalIterator>  // constexpr in C++17
N  constexpr BidirectionalIterator prev(BidirectionalIterator x,
N    typename iterator_traits<BidirectionalIterator>::difference_type n = 1);    
N
Ntemplate <class Iterator>
Nclass reverse_iterator
N    : public iterator<typename iterator_traits<Iterator>::iterator_category,
N                      typename iterator_traits<Iterator>::value_type,
N                      typename iterator_traits<Iterator>::difference_type,
N                      typename iterator_traits<Iterator>::pointer,
N                      typename iterator_traits<Iterator>::reference>
N{
Nprotected:
N    Iterator current;
Npublic:
N    typedef Iterator                                            iterator_type;
N    typedef typename iterator_traits<Iterator>::difference_type difference_type;
N    typedef typename iterator_traits<Iterator>::reference       reference;
N    typedef typename iterator_traits<Iterator>::pointer         pointer;
N
N    constexpr reverse_iterator();
N    constexpr explicit reverse_iterator(Iterator x);
N    template <class U> constexpr reverse_iterator(const reverse_iterator<U>& u);
N    template <class U> constexpr reverse_iterator& operator=(const reverse_iterator<U>& u);
N    constexpr Iterator base() const;
N    constexpr reference operator*() const;
N    constexpr pointer   operator->() const;
N    constexpr reverse_iterator& operator++();
N    constexpr reverse_iterator  operator++(int);
N    constexpr reverse_iterator& operator--();
N    constexpr reverse_iterator  operator--(int);
N    constexpr reverse_iterator  operator+ (difference_type n) const;
N    constexpr reverse_iterator& operator+=(difference_type n);
N    constexpr reverse_iterator  operator- (difference_type n) const;
N    constexpr reverse_iterator& operator-=(difference_type n);
N    constexpr reference         operator[](difference_type n) const;
N};
N
Ntemplate <class Iterator1, class Iterator2>
Nconstexpr bool                          // constexpr in C++17
Noperator==(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);
N
Ntemplate <class Iterator1, class Iterator2>
Nconstexpr bool                          // constexpr in C++17
Noperator<(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);
N
Ntemplate <class Iterator1, class Iterator2>
Nconstexpr bool                          // constexpr in C++17
Noperator!=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);
N
Ntemplate <class Iterator1, class Iterator2>
Nconstexpr bool                          // constexpr in C++17
Noperator>(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);
N
Ntemplate <class Iterator1, class Iterator2>
Nconstexpr bool                          // constexpr in C++17
Noperator>=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);
N
Ntemplate <class Iterator1, class Iterator2>
Nconstexpr bool                          // constexpr in C++17
Noperator<=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);
N
Ntemplate <class Iterator1, class Iterator2>
Nconstexpr auto
Noperator-(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y)
N-> decltype(__y.base() - __x.base());   // constexpr in C++17
N
Ntemplate <class Iterator>
Nconstexpr reverse_iterator<Iterator>
Noperator+(typename reverse_iterator<Iterator>::difference_type n, 
N          const reverse_iterator<Iterator>& x);   // constexpr in C++17
N
Ntemplate <class Iterator>
Nconstexpr reverse_iterator<Iterator> make_reverse_iterator(Iterator i); // C++14, constexpr in C++17
N
Ntemplate <class Container>
Nclass back_insert_iterator
N{
Nprotected:
N    Container* container;
Npublic:
N    typedef Container                   container_type;
N    typedef void                        value_type;
N    typedef void                        difference_type;
N    typedef void                        reference;
N    typedef void                        pointer;
N
N    explicit back_insert_iterator(Container& x);
N    back_insert_iterator& operator=(const typename Container::value_type& value);
N    back_insert_iterator& operator*();
N    back_insert_iterator& operator++();
N    back_insert_iterator  operator++(int);
N};
N
Ntemplate <class Container> back_insert_iterator<Container> back_inserter(Container& x);
N
Ntemplate <class Container>
Nclass front_insert_iterator
N{
Nprotected:
N    Container* container;
Npublic:
N    typedef Container                    container_type;
N    typedef void                         value_type;
N    typedef void                         difference_type;
N    typedef void                         reference;
N    typedef void                         pointer;
N
N    explicit front_insert_iterator(Container& x);
N    front_insert_iterator& operator=(const typename Container::value_type& value);
N    front_insert_iterator& operator*();
N    front_insert_iterator& operator++();
N    front_insert_iterator  operator++(int);
N};
N
Ntemplate <class Container> front_insert_iterator<Container> front_inserter(Container& x);
N
Ntemplate <class Container>
Nclass insert_iterator
N{
Nprotected:
N    Container* container;
N    typename Container::iterator iter;
Npublic:
N    typedef Container              container_type;
N    typedef void                   value_type;
N    typedef void                   difference_type;
N    typedef void                   reference;
N    typedef void                   pointer;
N
N    insert_iterator(Container& x, typename Container::iterator i);
N    insert_iterator& operator=(const typename Container::value_type& value);
N    insert_iterator& operator*();
N    insert_iterator& operator++();
N    insert_iterator& operator++(int);
N};
N
Ntemplate <class Container, class Iterator>
Ninsert_iterator<Container> inserter(Container& x, Iterator i);
N
Ntemplate <class Iterator>
Nclass move_iterator {
Npublic:
N    typedef Iterator                                              iterator_type;
N    typedef typename iterator_traits<Iterator>::difference_type   difference_type;
N    typedef Iterator                                              pointer;
N    typedef typename iterator_traits<Iterator>::value_type        value_type;
N    typedef typename iterator_traits<Iterator>::iterator_category iterator_category;
N    typedef value_type&&                                          reference;
N 
N    constexpr move_iterator();  // all the constexprs are in C++17
N    constexpr explicit move_iterator(Iterator i);
N    template <class U>
N      constexpr move_iterator(const move_iterator<U>& u);
N    template <class U>
N      constexpr move_iterator& operator=(const move_iterator<U>& u);
N    constexpr iterator_type base() const;
N    constexpr reference operator*() const;
N    constexpr pointer operator->() const;
N    constexpr move_iterator& operator++();
N    constexpr move_iterator operator++(int);
N    constexpr move_iterator& operator--();
N    constexpr move_iterator operator--(int);
N    constexpr move_iterator operator+(difference_type n) const; 
N    constexpr move_iterator& operator+=(difference_type n); 
N    constexpr move_iterator operator-(difference_type n) const; 
N    constexpr move_iterator& operator-=(difference_type n); 
N    constexpr unspecified operator[](difference_type n) const;
Nprivate:
N    Iterator current; // exposition only
N};
N
Ntemplate <class Iterator1, class Iterator2>
Nconstexpr bool   // constexpr in C++17
Noperator==(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);
N
Ntemplate <class Iterator1, class Iterator2>
Nconstexpr bool   // constexpr in C++17
Noperator!=(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);
N
Ntemplate <class Iterator1, class Iterator2>
Nconstexpr bool   // constexpr in C++17
Noperator<(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);
N
Ntemplate <class Iterator1, class Iterator2>
Nconstexpr bool   // constexpr in C++17
Noperator<=(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);
N
Ntemplate <class Iterator1, class Iterator2>
Nconstexpr bool   // constexpr in C++17
Noperator>(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);
N
Ntemplate <class Iterator1, class Iterator2>
Nconstexpr bool   // constexpr in C++17
Noperator>=(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);
N
Ntemplate <class Iterator1, class Iterator2>
Nconstexpr auto   // constexpr in C++17
Noperator-(const move_iterator<Iterator1>& x,
N          const move_iterator<Iterator2>& y) -> decltype(x.base() - y.base());
N
Ntemplate <class Iterator>
Nconstexpr move_iterator<Iterator> operator+(   // constexpr in C++17
N            typename move_iterator<Iterator>::difference_type n, 
N            const move_iterator<Iterator>& x);
N
Ntemplate <class Iterator>   // constexpr in C++17
Nconstexpr  move_iterator<Iterator> make_move_iterator(const Iterator& i);
N
N
Ntemplate <class T, class charT = char, class traits = char_traits<charT>, class Distance = ptrdiff_t>
Nclass istream_iterator
N    : public iterator<input_iterator_tag, T, Distance, const T*, const T&>
N{
Npublic:
N    typedef charT char_type;
N    typedef traits traits_type;
N    typedef basic_istream<charT,traits> istream_type;
N
N    constexpr istream_iterator();
N    istream_iterator(istream_type& s);
N    istream_iterator(const istream_iterator& x);
N    ~istream_iterator();
N
N    const T& operator*() const;
N    const T* operator->() const;
N    istream_iterator& operator++();
N    istream_iterator  operator++(int);
N};
N
Ntemplate <class T, class charT, class traits, class Distance>
Nbool operator==(const istream_iterator<T,charT,traits,Distance>& x,
N                const istream_iterator<T,charT,traits,Distance>& y);
Ntemplate <class T, class charT, class traits, class Distance>
Nbool operator!=(const istream_iterator<T,charT,traits,Distance>& x,
N                const istream_iterator<T,charT,traits,Distance>& y);
N
Ntemplate <class T, class charT = char, class traits = char_traits<charT> >
Nclass ostream_iterator
N    : public iterator<output_iterator_tag, void, void, void ,void>
N{
Npublic:
N    typedef charT char_type;
N    typedef traits traits_type;
N    typedef basic_ostream<charT,traits> ostream_type;
N
N    ostream_iterator(ostream_type& s);
N    ostream_iterator(ostream_type& s, const charT* delimiter);
N    ostream_iterator(const ostream_iterator& x);
N    ~ostream_iterator();
N    ostream_iterator& operator=(const T& value);
N
N    ostream_iterator& operator*();
N    ostream_iterator& operator++();
N    ostream_iterator& operator++(int);
N};
N
Ntemplate<class charT, class traits = char_traits<charT> >
Nclass istreambuf_iterator
N    : public iterator<input_iterator_tag, charT,
N                      typename traits::off_type, unspecified,
N                      charT>
N{
Npublic:
N    typedef charT                         char_type;
N    typedef traits                        traits_type;
N    typedef typename traits::int_type     int_type;
N    typedef basic_streambuf<charT,traits> streambuf_type;
N    typedef basic_istream<charT,traits>   istream_type;
N
N    istreambuf_iterator() noexcept;
N    istreambuf_iterator(istream_type& s) noexcept;
N    istreambuf_iterator(streambuf_type* s) noexcept;
N    istreambuf_iterator(a-private-type) noexcept;
N
N    charT                operator*() const;
N    pointer operator->() const;
N    istreambuf_iterator& operator++();
N    a-private-type       operator++(int);
N
N    bool equal(const istreambuf_iterator& b) const;
N};
N
Ntemplate <class charT, class traits>
Nbool operator==(const istreambuf_iterator<charT,traits>& a,
N                const istreambuf_iterator<charT,traits>& b);
Ntemplate <class charT, class traits>
Nbool operator!=(const istreambuf_iterator<charT,traits>& a,
N                const istreambuf_iterator<charT,traits>& b);
N
Ntemplate <class charT, class traits = char_traits<charT> >
Nclass ostreambuf_iterator
N    : public iterator<output_iterator_tag, void, void, void, void>
N{
Npublic:
N    typedef charT                         char_type;
N    typedef traits                        traits_type;
N    typedef basic_streambuf<charT,traits> streambuf_type;
N    typedef basic_ostream<charT,traits>   ostream_type;
N
N    ostreambuf_iterator(ostream_type& s) noexcept;
N    ostreambuf_iterator(streambuf_type* s) noexcept;
N    ostreambuf_iterator& operator=(charT c);
N    ostreambuf_iterator& operator*();
N    ostreambuf_iterator& operator++();
N    ostreambuf_iterator& operator++(int);
N    bool failed() const noexcept;
N};
N
Ntemplate <class C> constexpr auto begin(C& c) -> decltype(c.begin());
Ntemplate <class C> constexpr auto begin(const C& c) -> decltype(c.begin());
Ntemplate <class C> constexpr auto end(C& c) -> decltype(c.end());
Ntemplate <class C> constexpr auto end(const C& c) -> decltype(c.end());
Ntemplate <class T, size_t N> constexpr T* begin(T (&array)[N]);
Ntemplate <class T, size_t N> constexpr T* end(T (&array)[N]);
N
Ntemplate <class C> auto constexpr cbegin(const C& c) -> decltype(std::begin(c));        // C++14
Ntemplate <class C> auto constexpr cend(const C& c) -> decltype(std::end(c));            // C++14
Ntemplate <class C> auto constexpr rbegin(C& c) -> decltype(c.rbegin());                 // C++14
Ntemplate <class C> auto constexpr rbegin(const C& c) -> decltype(c.rbegin());           // C++14
Ntemplate <class C> auto constexpr rend(C& c) -> decltype(c.rend());                     // C++14
Ntemplate <class C> constexpr auto rend(const C& c) -> decltype(c.rend());               // C++14
Ntemplate <class E> reverse_iterator<const E*> constexpr rbegin(initializer_list<E> il); // C++14
Ntemplate <class E> reverse_iterator<const E*> constexpr rend(initializer_list<E> il);   // C++14
Ntemplate <class T, size_t N> reverse_iterator<T*> constexpr rbegin(T (&array)[N]);      // C++14
Ntemplate <class T, size_t N> reverse_iterator<T*> constexpr rend(T (&array)[N]);        // C++14
Ntemplate <class C> constexpr auto crbegin(const C& c) -> decltype(std::rbegin(c));      // C++14
Ntemplate <class C> constexpr auto crend(const C& c) -> decltype(std::rend(c));          // C++14
N
N// 24.8, container access:
Ntemplate <class C> constexpr auto size(const C& c) -> decltype(c.size());         // C++17
Ntemplate <class T, size_t N> constexpr size_t size(const T (&array)[N]) noexcept; // C++17
Ntemplate <class C> constexpr auto empty(const C& c) -> decltype(c.empty());       // C++17
Ntemplate <class T, size_t N> constexpr bool empty(const T (&array)[N]) noexcept;  // C++17
Ntemplate <class E> constexpr bool empty(initializer_list<E> il) noexcept;         // C++17
Ntemplate <class C> constexpr auto data(C& c) -> decltype(c.data());               // C++17
Ntemplate <class C> constexpr auto data(const C& c) -> decltype(c.data());         // C++17
Ntemplate <class T, size_t N> constexpr T* data(T (&array)[N]) noexcept;           // C++17
Ntemplate <class E> constexpr const E* data(initializer_list<E> il) noexcept;      // C++17
N
N}  // std
N
N*/
N
N#include <__config>
N#include <iosfwd> // for forward declarations of vector and string.
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/iosfwd" 1
N// -*- C++ -*-
N//===--------------------------- iosfwd -----------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is dual licensed under the MIT and the University of Illinois Open
N// Source Licenses. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP_IOSFWD
N#define _LIBCPP_IOSFWD
N
N/*
N    iosfwd synopsis
N
Nnamespace std
N{
N
Ntemplate<class charT> struct char_traits;
Ntemplate<class T>     class allocator;
N
Nclass ios_base;
Ntemplate <class charT, class traits = char_traits<charT> > class basic_ios;
N
Ntemplate <class charT, class traits = char_traits<charT> > class basic_streambuf;
Ntemplate <class charT, class traits = char_traits<charT> > class basic_istream;
Ntemplate <class charT, class traits = char_traits<charT> > class basic_ostream;
Ntemplate <class charT, class traits = char_traits<charT> > class basic_iostream;
N
Ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >
N    class basic_stringbuf;
Ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >
N    class basic_istringstream;
Ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >
N    class basic_ostringstream;
Ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >
N    class basic_stringstream;
N
Ntemplate <class charT, class traits = char_traits<charT> > class basic_filebuf;
Ntemplate <class charT, class traits = char_traits<charT> > class basic_ifstream;
Ntemplate <class charT, class traits = char_traits<charT> > class basic_ofstream;
Ntemplate <class charT, class traits = char_traits<charT> > class basic_fstream;
N
Ntemplate <class charT, class traits = char_traits<charT> > class istreambuf_iterator;
Ntemplate <class charT, class traits = char_traits<charT> > class ostreambuf_iterator;
N
Ntypedef basic_ios<char>              ios;
Ntypedef basic_ios<wchar_t>           wios;
N
Ntypedef basic_streambuf<char>        streambuf;
Ntypedef basic_istream<char>          istream;
Ntypedef basic_ostream<char>          ostream;
Ntypedef basic_iostream<char>         iostream;
N
Ntypedef basic_stringbuf<char>        stringbuf;
Ntypedef basic_istringstream<char>    istringstream;
Ntypedef basic_ostringstream<char>    ostringstream;
Ntypedef basic_stringstream<char>     stringstream;
N
Ntypedef basic_filebuf<char>          filebuf;
Ntypedef basic_ifstream<char>         ifstream;
Ntypedef basic_ofstream<char>         ofstream;
Ntypedef basic_fstream<char>          fstream;
N
Ntypedef basic_streambuf<wchar_t>     wstreambuf;
Ntypedef basic_istream<wchar_t>       wistream;
Ntypedef basic_ostream<wchar_t>       wostream;
Ntypedef basic_iostream<wchar_t>      wiostream;
N
Ntypedef basic_stringbuf<wchar_t>     wstringbuf;
Ntypedef basic_istringstream<wchar_t> wistringstream;
Ntypedef basic_ostringstream<wchar_t> wostringstream;
Ntypedef basic_stringstream<wchar_t>  wstringstream;
N
Ntypedef basic_filebuf<wchar_t>       wfilebuf;
Ntypedef basic_ifstream<wchar_t>      wifstream;
Ntypedef basic_ofstream<wchar_t>      wofstream;
Ntypedef basic_fstream<wchar_t>       wfstream;
N
Ntemplate <class state> class fpos;
Ntypedef fpos<char_traits<char>::state_type>    streampos;
Ntypedef fpos<char_traits<wchar_t>::state_type> wstreampos;
N
N}  // std
N
N*/
N
N#include <__config>
N#include <wchar.h>  // for mbstate_t
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/wchar.h" 1
N/* -*- C++ -*- */
N/*===--------------------------- complex.h --------------------------------===*/
N/*                                                                            */
N/*                     The LLVM Compiler Infrastructure                       */
N/*                                                                            */
N/* This file is dual licensed under the MIT and the University of Illinois Open
N** Source Licenses. See LICENSE.TXT for details.
N*/
N/*===----------------------------------------------------------------------===*/
N
N#if defined(__need_wint_t) || defined(__need_mbstate_t)
X#if 0L || 0L
S
S#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
S#pragma GCC system_header
S#endif
S
S#include_next <wchar.h>
S
N#elif !defined(_LIBCPP_WCHAR_H)
X#elif !0L
N#define _LIBCPP_WCHAR_H
N
N/*
N    wchar.h synopsis
N
NMacros:
N
N    NULL
N    WCHAR_MAX
N    WCHAR_MIN
N    WEOF
N
NTypes:
N
N    mbstate_t
N    size_t
N    tm
N    wint_t
N
Nint fwprintf(FILE* restrict stream, const wchar_t* restrict format, ...);
Nint fwscanf(FILE* restrict stream, const wchar_t* restrict format, ...);
Nint swprintf(wchar_t* restrict s, size_t n, const wchar_t* restrict format, ...);
Nint swscanf(const wchar_t* restrict s, const wchar_t* restrict format, ...);
Nint vfwprintf(FILE* restrict stream, const wchar_t* restrict format, va_list arg);
Nint vfwscanf(FILE* restrict stream, const wchar_t* restrict format, va_list arg);  // C99
Nint vswprintf(wchar_t* restrict s, size_t n, const wchar_t* restrict format, va_list arg);
Nint vswscanf(const wchar_t* restrict s, const wchar_t* restrict format, va_list arg);  // C99
Nint vwprintf(const wchar_t* restrict format, va_list arg);
Nint vwscanf(const wchar_t* restrict format, va_list arg);  // C99
Nint wprintf(const wchar_t* restrict format, ...);
Nint wscanf(const wchar_t* restrict format, ...);
Nwint_t fgetwc(FILE* stream);
Nwchar_t* fgetws(wchar_t* restrict s, int n, FILE* restrict stream);
Nwint_t fputwc(wchar_t c, FILE* stream);
Nint fputws(const wchar_t* restrict s, FILE* restrict stream);
Nint fwide(FILE* stream, int mode);
Nwint_t getwc(FILE* stream);
Nwint_t getwchar();
Nwint_t putwc(wchar_t c, FILE* stream);
Nwint_t putwchar(wchar_t c);
Nwint_t ungetwc(wint_t c, FILE* stream);
Ndouble wcstod(const wchar_t* restrict nptr, wchar_t** restrict endptr);
Nfloat wcstof(const wchar_t* restrict nptr, wchar_t** restrict endptr);         // C99
Nlong double wcstold(const wchar_t* restrict nptr, wchar_t** restrict endptr);  // C99
Nlong wcstol(const wchar_t* restrict nptr, wchar_t** restrict endptr, int base);
Nlong long wcstoll(const wchar_t* restrict nptr, wchar_t** restrict endptr, int base);  // C99
Nunsigned long wcstoul(const wchar_t* restrict nptr, wchar_t** restrict endptr, int base);
Nunsigned long long wcstoull(const wchar_t* restrict nptr, wchar_t** restrict endptr, int base);  // C99
Nwchar_t* wcscpy(wchar_t* restrict s1, const wchar_t* restrict s2);
Nwchar_t* wcsncpy(wchar_t* restrict s1, const wchar_t* restrict s2, size_t n);
Nwchar_t* wcscat(wchar_t* restrict s1, const wchar_t* restrict s2);
Nwchar_t* wcsncat(wchar_t* restrict s1, const wchar_t* restrict s2, size_t n);
Nint wcscmp(const wchar_t* s1, const wchar_t* s2);
Nint wcscoll(const wchar_t* s1, const wchar_t* s2);
Nint wcsncmp(const wchar_t* s1, const wchar_t* s2, size_t n);
Nsize_t wcsxfrm(wchar_t* restrict s1, const wchar_t* restrict s2, size_t n);
Nconst wchar_t* wcschr(const wchar_t* s, wchar_t c);
N      wchar_t* wcschr(      wchar_t* s, wchar_t c);
Nsize_t wcscspn(const wchar_t* s1, const wchar_t* s2);
Nsize_t wcslen(const wchar_t* s);
Nconst wchar_t* wcspbrk(const wchar_t* s1, const wchar_t* s2);
N      wchar_t* wcspbrk(      wchar_t* s1, const wchar_t* s2);
Nconst wchar_t* wcsrchr(const wchar_t* s, wchar_t c);
N      wchar_t* wcsrchr(      wchar_t* s, wchar_t c);
Nsize_t wcsspn(const wchar_t* s1, const wchar_t* s2);
Nconst wchar_t* wcsstr(const wchar_t* s1, const wchar_t* s2);
N      wchar_t* wcsstr(      wchar_t* s1, const wchar_t* s2);
Nwchar_t* wcstok(wchar_t* restrict s1, const wchar_t* restrict s2, wchar_t** restrict ptr);
Nconst wchar_t* wmemchr(const wchar_t* s, wchar_t c, size_t n);
N      wchar_t* wmemchr(      wchar_t* s, wchar_t c, size_t n);
Nint wmemcmp(wchar_t* restrict s1, const wchar_t* restrict s2, size_t n);
Nwchar_t* wmemcpy(wchar_t* restrict s1, const wchar_t* restrict s2, size_t n);
Nwchar_t* wmemmove(wchar_t* s1, const wchar_t* s2, size_t n);
Nwchar_t* wmemset(wchar_t* s, wchar_t c, size_t n);
Nsize_t wcsftime(wchar_t* restrict s, size_t maxsize, const wchar_t* restrict format,
N                const tm* restrict timeptr);
Nwint_t btowc(int c);
Nint wctob(wint_t c);
Nint mbsinit(const mbstate_t* ps);
Nsize_t mbrlen(const char* restrict s, size_t n, mbstate_t* restrict ps);
Nsize_t mbrtowc(wchar_t* restrict pwc, const char* restrict s, size_t n, mbstate_t* restrict ps);
Nsize_t wcrtomb(char* restrict s, wchar_t wc, mbstate_t* restrict ps);
Nsize_t mbsrtowcs(wchar_t* restrict dst, const char** restrict src, size_t len,
N                 mbstate_t* restrict ps);
Nsize_t wcsrtombs(char* restrict dst, const wchar_t** restrict src, size_t len,
N                 mbstate_t* restrict ps);
N
N*/
N
N#include <__config>
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N#ifdef __cplusplus
N#define __CORRECT_ISO_CPP_WCHAR_H_PROTO
N#endif
N
N#include_next <wchar.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/wchar.h" 1
N/*-
N * SPDX-License-Identifier: (BSD-2-Clause AND BSD-2-Clause-NetBSD)
N *
N * Copyright (c)1999 Citrus Project,
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N * 1. Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
N * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
N * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
N * SUCH DAMAGE.
N *
N * $FreeBSD$
N */
N
N/*-
N * Copyright (c) 1999, 2000 The NetBSD Foundation, Inc.
N * All rights reserved.
N *
N * This code is derived from software contributed to The NetBSD Foundation
N * by Julian Coleman.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N * 1. Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
N * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
N * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
N * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
N * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *
N *	$NetBSD: wchar.h,v 1.8 2000/12/22 05:31:42 itojun Exp $
N */
N
N#ifndef _WCHAR_H_
N#define _WCHAR_H_
N
N#include <sys/cdefs.h>
N#include <sys/_null.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/sys/_null.h" 1
N/*-
N * SPDX-License-Identifier: BSD-2-Clause-FreeBSD
N *
N * Copyright (c) 2003 Marcel Moolenaar
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N *
N * 1. Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
N * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
N * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
N * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
N * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
N * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
N * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
N * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
N * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
N * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N * $FreeBSD$
N */
N
N#ifndef NULL
S
S#if !defined(__cplusplus)
S#define	NULL	((void *)0)
S#else
S#if __cplusplus >= 201103L
S#define	NULL	nullptr
S#elif defined(__GNUG__) && defined(__GNUC__) && __GNUC__ >= 4
S#define	NULL	__null
S#else
S#if defined(__LP64__)
S#define	NULL	(0L)
S#else
S#define	NULL	0
S#endif	/* __LP64__ */
S#endif	/* __GNUG__ */
S#endif	/* !__cplusplus */
S
N#endif
L 67 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/wchar.h" 2
N#include <sys/_types.h>
N#include <machine/_limits.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/machine/_limits.h" 1
N/*-
N * SPDX-License-Identifier: BSD-3-Clause
N *
N * Copyright (c) 1988, 1993
N *	The Regents of the University of California.  All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N * 1. Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N * 3. Neither the name of the University nor the names of its contributors
N *    may be used to endorse or promote products derived from this software
N *    without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
N * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
N * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
N * SUCH DAMAGE.
N *
N *	@(#)limits.h	8.3 (Berkeley) 1/4/94
N * $FreeBSD$
N */
N
N#ifndef _MACHINE__LIMITS_H_
N#define	_MACHINE__LIMITS_H_
N
N/*
N * According to ANSI (section 2.2.4.2), the values below must be usable by
N * #if preprocessing directives.  Additionally, the expression must have the
N * same type as would an expression that is an object of the corresponding
N * type converted according to the integral promotions.  The subtraction for
N * INT_MIN, etc., is so the value is not unsigned; e.g., 0x80000000 is an
N * unsigned int for 32-bit two's complement ANSI compilers (section 3.1.3.2).
N */
N
N#define	__CHAR_BIT	8		/* number of bits in a char */
N
N#define	__SCHAR_MAX	0x7f		/* max value for a signed char */
N#define	__SCHAR_MIN	(-0x7f - 1)	/* min value for a signed char */
N
N#define	__UCHAR_MAX	0xff		/* max value for an unsigned char */
N
N#define	__USHRT_MAX	0xffff		/* max value for an unsigned short */
N#define	__SHRT_MAX	0x7fff		/* max value for a short */
N#define	__SHRT_MIN	(-0x7fff - 1)	/* min value for a short */
N
N#define	__UINT_MAX	0xffffffff	/* max value for an unsigned int */
N#define	__INT_MAX	0x7fffffff	/* max value for an int */
N#define	__INT_MIN	(-0x7fffffff - 1)	/* min value for an int */
N
N#define	__ULONG_MAX	0xffffffffUL	/* max value for an unsigned long */
N#define	__LONG_MAX	0x7fffffffL	/* max value for a long */
N#define	__LONG_MIN	(-0x7fffffffL - 1)	/* min value for a long */
N
N			/* max value for an unsigned long long */
N#define	__ULLONG_MAX	0xffffffffffffffffULL
N#define	__LLONG_MAX	0x7fffffffffffffffLL	/* max value for a long long */
N#define	__LLONG_MIN	(-0x7fffffffffffffffLL - 1)  /* min for a long long */
N
N#define	__SSIZE_MAX	__INT_MAX	/* max value for a ssize_t */
N
N#define	__SIZE_T_MAX	__UINT_MAX	/* max value for a size_t */
N
N#define	__OFF_MAX	__LLONG_MAX	/* max value for a off_t */
N#define	__OFF_MIN	__LLONG_MIN	/* min value for a off_t */
N
N/* Quads and long longs are the same size.  Ensure they stay in sync. */
N#define	__UQUAD_MAX	__ULLONG_MAX	/* max value for a uquad_t */
N#define	__QUAD_MAX	__LLONG_MAX	/* max value for a quad_t */
N#define	__QUAD_MIN	__LLONG_MIN	/* min value for a quad_t */
N
N#define	__LONG_BIT	32
N#define	__WORD_BIT	32
N
N/* Minimum signal stack size. */
N#define	__MINSIGSTKSZ	(1024 * 4)
N
N#endif /* !_MACHINE__LIMITS_H_ */
L 69 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/wchar.h" 2
N
N#ifndef _MBSTATE_T_DECLARED
Ntypedef	__mbstate_t	mbstate_t;
N#define	_MBSTATE_T_DECLARED
N#endif
N
N#ifndef _SIZE_T_DECLARED
Stypedef	__size_t	size_t;
S#define	_SIZE_T_DECLARED
N#endif
N
N#if __POSIX_VISIBLE >= 200809 || __XSI_VISIBLE
X#if 200809 >= 200809 || 700
N#if !defined(_VA_LIST_DECLARED) && !defined(_VA_LIST)
X#if !0L && !0L
Ntypedef	__va_list	va_list;
N#define	_VA_LIST_DECLARED
N#define	_VA_LIST
N#endif
N#endif
N
N#ifndef	__cplusplus
S#ifndef _WCHAR_T_DECLARED
Stypedef	___wchar_t	wchar_t;
S#define	_WCHAR_T_DECLARED
S#endif
N#endif
N
N#ifndef _WINT_T_DECLARED
Ntypedef	__wint_t	wint_t;
N#define	_WINT_T_DECLARED
N#endif
N
N#define	WCHAR_MIN	__WCHAR_MIN
N#define	WCHAR_MAX	__WCHAR_MAX
N
N#ifndef WEOF
N#define	WEOF 	((wint_t)-1)
N#endif
N
N#ifndef _STDFILE_DECLARED
N#define _STDFILE_DECLARED
Ntypedef struct __sFILE FILE;
N#endif
Nstruct tm;
N
N__BEGIN_DECLS
Xextern "C" {
Nwint_t	btowc(int);
Nwint_t	fgetwc(FILE *);
Nwchar_t	*
N	fgetws(wchar_t * __restrict, int, FILE * __restrict);
Nwint_t	fputwc(wchar_t, FILE *);
Nint	fputws(const wchar_t * __restrict, FILE * __restrict);
Nint	fwide(FILE *, int);
Nint	fwprintf(FILE * __restrict, const wchar_t * __restrict, ...);
Nint	fwscanf(FILE * __restrict, const wchar_t * __restrict, ...);
Nwint_t	getwc(FILE *);
Nwint_t	getwchar(void);
Nsize_t	mbrlen(const char * __restrict, size_t, mbstate_t * __restrict);
Nsize_t	mbrtowc(wchar_t * __restrict, const char * __restrict, size_t,
N	    mbstate_t * __restrict);
Nint	mbsinit(const mbstate_t *);
Nsize_t	mbsrtowcs(wchar_t * __restrict, const char ** __restrict, size_t,
N	    mbstate_t * __restrict);
Nwint_t	putwc(wchar_t, FILE *);
Nwint_t	putwchar(wchar_t);
Nint	swprintf(wchar_t * __restrict, size_t n, const wchar_t * __restrict,
N	    ...);
Nint	swscanf(const wchar_t * __restrict, const wchar_t * __restrict, ...);
Nwint_t	ungetwc(wint_t, FILE *);
Nint	vfwprintf(FILE * __restrict, const wchar_t * __restrict,
N	    __va_list);
Nint	vswprintf(wchar_t * __restrict, size_t n, const wchar_t * __restrict,
N	    __va_list);
Nint	vwprintf(const wchar_t * __restrict, __va_list);
Nsize_t	wcrtomb(char * __restrict, wchar_t, mbstate_t * __restrict);
Nwchar_t	*wcscat(wchar_t * __restrict, const wchar_t * __restrict);
Nwchar_t	*wcschr(const wchar_t *, wchar_t) __pure;
Xwchar_t	*wcschr(const wchar_t *, wchar_t) ;
Nint	wcscmp(const wchar_t *, const wchar_t *) __pure;
Xint	wcscmp(const wchar_t *, const wchar_t *) ;
Nint	wcscoll(const wchar_t *, const wchar_t *);
Nwchar_t	*wcscpy(wchar_t * __restrict, const wchar_t * __restrict);
Nsize_t	wcscspn(const wchar_t *, const wchar_t *) __pure;
Xsize_t	wcscspn(const wchar_t *, const wchar_t *) ;
Nsize_t	wcsftime(wchar_t * __restrict, size_t, const wchar_t * __restrict,
N	    const struct tm * __restrict);
Nsize_t	wcslen(const wchar_t *) __pure;
Xsize_t	wcslen(const wchar_t *) ;
Nwchar_t	*wcsncat(wchar_t * __restrict, const wchar_t * __restrict,
N	    size_t);
Nint	wcsncmp(const wchar_t *, const wchar_t *, size_t) __pure;
Xint	wcsncmp(const wchar_t *, const wchar_t *, size_t) ;
Nwchar_t	*wcsncpy(wchar_t * __restrict , const wchar_t * __restrict, size_t);
Nwchar_t	*wcspbrk(const wchar_t *, const wchar_t *) __pure;
Xwchar_t	*wcspbrk(const wchar_t *, const wchar_t *) ;
Nwchar_t	*wcsrchr(const wchar_t *, wchar_t) __pure;
Xwchar_t	*wcsrchr(const wchar_t *, wchar_t) ;
Nsize_t	wcsrtombs(char * __restrict, const wchar_t ** __restrict, size_t,
N	    mbstate_t * __restrict);
Nsize_t	wcsspn(const wchar_t *, const wchar_t *) __pure;
Xsize_t	wcsspn(const wchar_t *, const wchar_t *) ;
Nwchar_t	*wcsstr(const wchar_t * __restrict, const wchar_t * __restrict)
N	    __pure;
X	    ;
Nsize_t	wcsxfrm(wchar_t * __restrict, const wchar_t * __restrict, size_t);
Nint	wctob(wint_t);
Ndouble	wcstod(const wchar_t * __restrict, wchar_t ** __restrict);
Nwchar_t	*wcstok(wchar_t * __restrict, const wchar_t * __restrict,
N	    wchar_t ** __restrict);
Nlong	 wcstol(const wchar_t * __restrict, wchar_t ** __restrict, int);
Nunsigned long
N	 wcstoul(const wchar_t * __restrict, wchar_t ** __restrict, int);
Nwchar_t	*wmemchr(const wchar_t *, wchar_t, size_t) __pure;
Xwchar_t	*wmemchr(const wchar_t *, wchar_t, size_t) ;
Nint	wmemcmp(const wchar_t *, const wchar_t *, size_t) __pure;
Xint	wmemcmp(const wchar_t *, const wchar_t *, size_t) ;
Nwchar_t	*wmemcpy(wchar_t * __restrict, const wchar_t * __restrict, size_t);
Nwchar_t	*wmemmove(wchar_t *, const wchar_t *, size_t);
Nwchar_t	*wmemset(wchar_t *, wchar_t, size_t);
Nint	wprintf(const wchar_t * __restrict, ...);
Nint	wscanf(const wchar_t * __restrict, ...);
N
N#ifndef _STDSTREAM_DECLARED
Nextern FILE *__stdinp;
Nextern FILE *__stdoutp;
Nextern FILE *__stderrp;
N#define	_STDSTREAM_DECLARED
N#endif
N
N#define	getwc(fp)	fgetwc(fp)
N#define	getwchar()	fgetwc(__stdinp)
N#define	putwc(wc, fp)	fputwc(wc, fp)
N#define	putwchar(wc)	fputwc(wc, __stdoutp)
N
N#if __ISO_C_VISIBLE >= 1999
X#if 2011 >= 1999
Nint	vfwscanf(FILE * __restrict, const wchar_t * __restrict,
N	    __va_list);
Nint	vswscanf(const wchar_t * __restrict, const wchar_t * __restrict,
N	    __va_list);
Nint	vwscanf(const wchar_t * __restrict, __va_list);
Nfloat	wcstof(const wchar_t * __restrict, wchar_t ** __restrict);
Nlong double
N	wcstold(const wchar_t * __restrict, wchar_t ** __restrict);
N#ifdef __LONG_LONG_SUPPORTED
N/* LONGLONG */
Nlong long
N	wcstoll(const wchar_t * __restrict, wchar_t ** __restrict, int);
N/* LONGLONG */
Nunsigned long long
N	 wcstoull(const wchar_t * __restrict, wchar_t ** __restrict, int);
N#endif
N#endif	/* __ISO_C_VISIBLE >= 1999 */
N
N#if __XSI_VISIBLE
X#if 700
Nint	wcswidth(const wchar_t *, size_t);
Nint	wcwidth(wchar_t);
N#define	wcwidth(_c)	__wcwidth(_c)
N#endif
N
N#if __POSIX_VISIBLE >= 200809
X#if 200809 >= 200809
Nsize_t	mbsnrtowcs(wchar_t * __restrict, const char ** __restrict, size_t,
N	    size_t, mbstate_t * __restrict);
NFILE	*open_wmemstream(wchar_t **, size_t *);
Nwchar_t	*wcpcpy(wchar_t * __restrict, const wchar_t * __restrict);
Nwchar_t	*wcpncpy(wchar_t * __restrict, const wchar_t * __restrict, size_t);
Nwchar_t	*wcsdup(const wchar_t *) __malloc_like;
Xwchar_t	*wcsdup(const wchar_t *) ;
Nint	wcscasecmp(const wchar_t *, const wchar_t *);
Nint	wcsncasecmp(const wchar_t *, const wchar_t *, size_t n);
Nsize_t	wcsnlen(const wchar_t *, size_t) __pure;
Xsize_t	wcsnlen(const wchar_t *, size_t) ;
Nsize_t	wcsnrtombs(char * __restrict, const wchar_t ** __restrict, size_t,
N	    size_t, mbstate_t * __restrict);
N#endif
N
N#if __BSD_VISIBLE
X#if 1
Nwchar_t	*fgetwln(FILE * __restrict, size_t * __restrict);
Nsize_t	wcslcat(wchar_t *, const wchar_t *, size_t);
Nsize_t	wcslcpy(wchar_t *, const wchar_t *, size_t);
N#endif
N
N#if __POSIX_VISIBLE >= 200809 || defined(_XLOCALE_H_)
X#if 200809 >= 200809 || 0L
N#include <xlocale/_wchar.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/xlocale/_wchar.h" 1
N/*-
N * SPDX-License-Identifier: BSD-2-Clause-FreeBSD
N *
N * Copyright (c) 2011, 2012 The FreeBSD Foundation
N * All rights reserved.
N *
N * This software was developed by David Chisnall under sponsorship from
N * the FreeBSD Foundation.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N * 1. Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
N * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
N * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
N * SUCH DAMAGE.
N *
N * $FreeBSD$
N */
N
N#ifndef _LOCALE_T_DEFINED
N#define _LOCALE_T_DEFINED
Ntypedef struct	_xlocale *locale_t;
N#endif
N
N#ifndef _XLOCALE_WCHAR1_H
N#define _XLOCALE_WCHAR1_H
Nint			 wcscasecmp_l(const wchar_t *, const wchar_t *,
N			   locale_t);
Nint			 wcsncasecmp_l(const wchar_t *, const wchar_t *, size_t,
N			   locale_t);
Nint			 wcscoll_l(const wchar_t *, const wchar_t *, locale_t);
Nsize_t			 wcsxfrm_l(wchar_t * __restrict,
N			   const wchar_t * __restrict, size_t, locale_t);
N
N#endif /* _XLOCALE_WCHAR1_H */
N
N/*
N * Only declare the non-POSIX functions if we're included from xlocale.h.
N */
N
N#ifdef _XLOCALE_H_
S#ifndef _XLOCALE_WCHAR2_H
S#define _XLOCALE_WCHAR2_H
S
Swint_t			 btowc_l(int, locale_t);
Swint_t			 fgetwc_l(FILE *, locale_t);
Swchar_t			*fgetws_l(wchar_t * __restrict, int, FILE * __restrict,
S			    locale_t);
Swint_t			 fputwc_l(wchar_t, FILE *, locale_t);
Sint			 fputws_l(const wchar_t * __restrict, FILE * __restrict,
S			   locale_t);
Sint			 fwprintf_l(FILE * __restrict, locale_t,
S			    const wchar_t * __restrict, ...);
Sint			 fwscanf_l(FILE * __restrict, locale_t,
S			    const wchar_t * __restrict, ...);
Swint_t			 getwc_l(FILE *, locale_t);
Swint_t			 getwchar_l(locale_t);
Ssize_t			 mbrlen_l(const char * __restrict, size_t,
S			   mbstate_t * __restrict, locale_t);
Ssize_t			 mbrtowc_l(wchar_t * __restrict,
S			    const char * __restrict, size_t,
S			    mbstate_t * __restrict, locale_t);
Sint			 mbsinit_l(const mbstate_t *, locale_t);
Ssize_t			 mbsrtowcs_l(wchar_t * __restrict,
S			    const char ** __restrict, size_t,
S			    mbstate_t * __restrict, locale_t);
Swint_t			 putwc_l(wchar_t, FILE *, locale_t);
Swint_t			 putwchar_l(wchar_t, locale_t);
Sint			 swprintf_l(wchar_t * __restrict, size_t n, locale_t,
S			    const wchar_t * __restrict, ...);
Sint			 swscanf_l(const wchar_t * __restrict, locale_t,
S			   const wchar_t * __restrict, ...);
Swint_t			 ungetwc_l(wint_t, FILE *, locale_t);
Sint			 vfwprintf_l(FILE * __restrict, locale_t,
S			    const wchar_t * __restrict, __va_list);
Sint			 vswprintf_l(wchar_t * __restrict, size_t n, locale_t,
S			    const wchar_t * __restrict, __va_list);
Sint			 vwprintf_l(locale_t, const wchar_t * __restrict,
S			    __va_list);
Ssize_t			 wcrtomb_l(char * __restrict, wchar_t,
S			    mbstate_t * __restrict, locale_t);
Ssize_t			 wcsftime_l(wchar_t * __restrict, size_t,
S			    const wchar_t * __restrict,
S			    const struct tm * __restrict, locale_t);
Ssize_t			 wcsrtombs_l(char * __restrict,
S			    const wchar_t ** __restrict, size_t,
S			    mbstate_t * __restrict, locale_t);
Sdouble			 wcstod_l(const wchar_t * __restrict,
S			    wchar_t ** __restrict, locale_t);
Slong			 wcstol_l(const wchar_t * __restrict,
S			    wchar_t ** __restrict, int, locale_t);
Sunsigned long		 wcstoul_l(const wchar_t * __restrict,
S			    wchar_t ** __restrict, int, locale_t);
Sint			 wcswidth_l(const wchar_t *, size_t, locale_t);
Sint			 wctob_l(wint_t, locale_t);
Sint			 wcwidth_l(wchar_t, locale_t);
Sint			 wprintf_l(locale_t, const wchar_t * __restrict, ...);
Sint			 wscanf_l(locale_t, const wchar_t * __restrict, ...);
Sint			 vfwscanf_l(FILE * __restrict, locale_t,
S			    const wchar_t * __restrict, __va_list);
Sint			 vswscanf_l(const wchar_t * __restrict, locale_t,
S			    const wchar_t *__restrict, __va_list);
Sint			 vwscanf_l(locale_t, const wchar_t * __restrict,
S			    __va_list);
Sfloat			 wcstof_l(const wchar_t * __restrict,
S			    wchar_t ** __restrict, locale_t);
Slong double		 wcstold_l(const wchar_t * __restrict,
S			    wchar_t ** __restrict, locale_t);
Slong long		 wcstoll_l(const wchar_t * __restrict,
S			    wchar_t ** __restrict, int, locale_t);
Sunsigned long long	 wcstoull_l(const wchar_t * __restrict,
S			    wchar_t ** __restrict, int, locale_t);
Ssize_t			 mbsnrtowcs_l(wchar_t * __restrict,
S			    const char ** __restrict, size_t, size_t,
S			    mbstate_t * __restrict, locale_t);
Ssize_t			 wcsnrtombs_l(char * __restrict,
S			    const wchar_t ** __restrict, size_t, size_t,
S			    mbstate_t * __restrict, locale_t);
S
S#endif /* _XLOCALE_WCHAR_H */
N#endif /* _XLOCALE_H_ */
L 238 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/wchar.h" 2
N#endif
N__END_DECLS
X}
N
N#endif /* !_WCHAR_H_ */
L 120 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/wchar.h" 2
N
N/* Determine whether we have const-correct overloads for wcschr and friends. */
N#if defined(_WCHAR_H_CPLUSPLUS_98_CONFORMANCE_)
X#if 0L
S#  define _LIBCPP_WCHAR_H_HAS_CONST_OVERLOADS 1
S#elif defined(__GLIBC_PREREQ)
X#elif 0L
S#  if __GLIBC_PREREQ(2, 10)
S#    define _LIBCPP_WCHAR_H_HAS_CONST_OVERLOADS 1
S#  endif
S#elif defined(_LIBCPP_MSVCRT)
X#elif 0L
S#  if defined(_CRT_CONST_CORRECT_OVERLOADS)
S#    define _LIBCPP_WCHAR_H_HAS_CONST_OVERLOADS 1
S#  endif
N#endif
N
N#if defined(__cplusplus) && !defined(_LIBCPP_WCHAR_H_HAS_CONST_OVERLOADS) && defined(_LIBCPP_PREFERRED_OVERLOAD)
X#if 1L && !0L && 0L
Sextern "C++" {
Sinline _LIBCPP_INLINE_VISIBILITY
Swchar_t* __libcpp_wcschr(const wchar_t* __s, wchar_t __c) {return (wchar_t*)wcschr(__s, __c);}
Sinline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD
Sconst wchar_t* wcschr(const wchar_t* __s, wchar_t __c) {return __libcpp_wcschr(__s, __c);}
Sinline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD
S      wchar_t* wcschr(      wchar_t* __s, wchar_t __c) {return __libcpp_wcschr(__s, __c);}
S
Sinline _LIBCPP_INLINE_VISIBILITY
Swchar_t* __libcpp_wcspbrk(const wchar_t* __s1, const wchar_t* __s2) {return (wchar_t*)wcspbrk(__s1, __s2);}
Sinline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD
Sconst wchar_t* wcspbrk(const wchar_t* __s1, const wchar_t* __s2) {return __libcpp_wcspbrk(__s1, __s2);}
Sinline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD
S      wchar_t* wcspbrk(      wchar_t* __s1, const wchar_t* __s2) {return __libcpp_wcspbrk(__s1, __s2);}
S
Sinline _LIBCPP_INLINE_VISIBILITY
Swchar_t* __libcpp_wcsrchr(const wchar_t* __s, wchar_t __c) {return (wchar_t*)wcsrchr(__s, __c);}
Sinline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD
Sconst wchar_t* wcsrchr(const wchar_t* __s, wchar_t __c) {return __libcpp_wcsrchr(__s, __c);}
Sinline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD
S      wchar_t* wcsrchr(      wchar_t* __s, wchar_t __c) {return __libcpp_wcsrchr(__s, __c);}
S
Sinline _LIBCPP_INLINE_VISIBILITY
Swchar_t* __libcpp_wcsstr(const wchar_t* __s1, const wchar_t* __s2) {return (wchar_t*)wcsstr(__s1, __s2);}
Sinline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD
Sconst wchar_t* wcsstr(const wchar_t* __s1, const wchar_t* __s2) {return __libcpp_wcsstr(__s1, __s2);}
Sinline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD
S      wchar_t* wcsstr(      wchar_t* __s1, const wchar_t* __s2) {return __libcpp_wcsstr(__s1, __s2);}
S
Sinline _LIBCPP_INLINE_VISIBILITY
Swchar_t* __libcpp_wmemchr(const wchar_t* __s, wchar_t __c, size_t __n) {return (wchar_t*)wmemchr(__s, __c, __n);}
Sinline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD
Sconst wchar_t* wmemchr(const wchar_t* __s, wchar_t __c, size_t __n) {return __libcpp_wmemchr(__s, __c, __n);}
Sinline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD
S      wchar_t* wmemchr(      wchar_t* __s, wchar_t __c, size_t __n) {return __libcpp_wmemchr(__s, __c, __n);}
S}
N#endif
N
N#if defined(__cplusplus) && defined(_LIBCPP_MSVCRT_LIKE)
X#if 1L && 0L
Sextern "C" {
Ssize_t mbsnrtowcs(wchar_t *__restrict dst, const char **__restrict src,
S                  size_t nmc, size_t len, mbstate_t *__restrict ps);
Ssize_t wcsnrtombs(char *__restrict dst, const wchar_t **__restrict src,
S                  size_t nwc, size_t len, mbstate_t *__restrict ps);
S}  /* extern "C++" */
N#endif  /* __cplusplus && _LIBCPP_MSVCRT */
N
N#endif  /* _LIBCPP_WCHAR_H */
L 91 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/iosfwd" 2
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N_LIBCPP_BEGIN_NAMESPACE_STD
Xnamespace std { inline namespace __2 {
N
Nclass _LIBCPP_TYPE_VIS ios_base;
Xclass  ios_base;
N
Ntemplate<class _CharT>  struct _LIBCPP_TEMPLATE_VIS char_traits;
Xtemplate<class _CharT>  struct  char_traits;
Ntemplate<class _Tp>     class _LIBCPP_TEMPLATE_VIS allocator;
Xtemplate<class _Tp>     class  allocator;
N
Ntemplate <class _CharT, class _Traits = char_traits<_CharT> >
N    class _LIBCPP_TEMPLATE_VIS basic_ios;
X    class  basic_ios;
N
Ntemplate <class _CharT, class _Traits = char_traits<_CharT> >
N    class _LIBCPP_TEMPLATE_VIS basic_streambuf;
X    class  basic_streambuf;
Ntemplate <class _CharT, class _Traits = char_traits<_CharT> >
N    class _LIBCPP_TEMPLATE_VIS basic_istream;
X    class  basic_istream;
Ntemplate <class _CharT, class _Traits = char_traits<_CharT> >
N    class _LIBCPP_TEMPLATE_VIS basic_ostream;
X    class  basic_ostream;
Ntemplate <class _CharT, class _Traits = char_traits<_CharT> >
N    class _LIBCPP_TEMPLATE_VIS basic_iostream;
X    class  basic_iostream;
N
Ntemplate <class _CharT, class _Traits = char_traits<_CharT>,
N          class _Allocator = allocator<_CharT> >
N    class _LIBCPP_TEMPLATE_VIS basic_stringbuf;
X    class  basic_stringbuf;
Ntemplate <class _CharT, class _Traits = char_traits<_CharT>,
N          class _Allocator = allocator<_CharT> >
N    class _LIBCPP_TEMPLATE_VIS basic_istringstream;
X    class  basic_istringstream;
Ntemplate <class _CharT, class _Traits = char_traits<_CharT>,
N          class _Allocator = allocator<_CharT> >
N    class _LIBCPP_TEMPLATE_VIS basic_ostringstream;
X    class  basic_ostringstream;
Ntemplate <class _CharT, class _Traits = char_traits<_CharT>,
N          class _Allocator = allocator<_CharT> >
N    class _LIBCPP_TEMPLATE_VIS basic_stringstream;
X    class  basic_stringstream;
N
Ntemplate <class _CharT, class _Traits = char_traits<_CharT> >
N    class _LIBCPP_TEMPLATE_VIS basic_filebuf;
X    class  basic_filebuf;
Ntemplate <class _CharT, class _Traits = char_traits<_CharT> >
N    class _LIBCPP_TEMPLATE_VIS basic_ifstream;
X    class  basic_ifstream;
Ntemplate <class _CharT, class _Traits = char_traits<_CharT> >
N    class _LIBCPP_TEMPLATE_VIS basic_ofstream;
X    class  basic_ofstream;
Ntemplate <class _CharT, class _Traits = char_traits<_CharT> >
N    class _LIBCPP_TEMPLATE_VIS basic_fstream;
X    class  basic_fstream;
N
Ntemplate <class _CharT, class _Traits = char_traits<_CharT> >
N    class _LIBCPP_TEMPLATE_VIS istreambuf_iterator;
X    class  istreambuf_iterator;
Ntemplate <class _CharT, class _Traits = char_traits<_CharT> >
N    class _LIBCPP_TEMPLATE_VIS ostreambuf_iterator;
X    class  ostreambuf_iterator;
N
Ntypedef basic_ios<char>              ios;
Ntypedef basic_ios<wchar_t>           wios;
N
Ntypedef basic_streambuf<char>        streambuf;
Ntypedef basic_istream<char>          istream;
Ntypedef basic_ostream<char>          ostream;
Ntypedef basic_iostream<char>         iostream;
N
Ntypedef basic_stringbuf<char>        stringbuf;
Ntypedef basic_istringstream<char>    istringstream;
Ntypedef basic_ostringstream<char>    ostringstream;
Ntypedef basic_stringstream<char>     stringstream;
N
Ntypedef basic_filebuf<char>          filebuf;
Ntypedef basic_ifstream<char>         ifstream;
Ntypedef basic_ofstream<char>         ofstream;
Ntypedef basic_fstream<char>          fstream;
N
Ntypedef basic_streambuf<wchar_t>     wstreambuf;
Ntypedef basic_istream<wchar_t>       wistream;
Ntypedef basic_ostream<wchar_t>       wostream;
Ntypedef basic_iostream<wchar_t>      wiostream;
N
Ntypedef basic_stringbuf<wchar_t>     wstringbuf;
Ntypedef basic_istringstream<wchar_t> wistringstream;
Ntypedef basic_ostringstream<wchar_t> wostringstream;
Ntypedef basic_stringstream<wchar_t>  wstringstream;
N
Ntypedef basic_filebuf<wchar_t>       wfilebuf;
Ntypedef basic_ifstream<wchar_t>      wifstream;
Ntypedef basic_ofstream<wchar_t>      wofstream;
Ntypedef basic_fstream<wchar_t>       wfstream;
N
Ntemplate <class _State>             class _LIBCPP_TEMPLATE_VIS fpos;
Xtemplate <class _State>             class  fpos;
Ntypedef fpos<mbstate_t>    streampos;
Ntypedef fpos<mbstate_t>    wstreampos;
N#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
Ntypedef fpos<mbstate_t>    u16streampos;
Ntypedef fpos<mbstate_t>    u32streampos;
N#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS
N
N#if defined(_NEWLIB_VERSION)
X#if 0L
S// On newlib, off_t is 'long int'
Stypedef long int streamoff;         // for char_traits in <string>
N#else
Ntypedef long long streamoff;        // for char_traits in <string>
N#endif
N
Ntemplate <class _CharT,             // for <stdexcept>
N          class _Traits = char_traits<_CharT>,
N          class _Allocator = allocator<_CharT> >
N    class _LIBCPP_TEMPLATE_VIS basic_string;
X    class  basic_string;
Ntypedef basic_string<char, char_traits<char>, allocator<char> > string;
Ntypedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > wstring;
N
N
N// Include other forward declarations here
Ntemplate <class _Tp, class _Alloc = allocator<_Tp> >
Nclass _LIBCPP_TEMPLATE_VIS vector;
Xclass  vector;
N
N_LIBCPP_END_NAMESPACE_STD
X} }
N
N#endif  // _LIBCPP_IOSFWD
L 427 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/iterator" 2
N#include <__functional_base>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/__functional_base" 1
N// -*- C++ -*-
N//===----------------------------------------------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is dual licensed under the MIT and the University of Illinois Open
N// Source Licenses. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP_FUNCTIONAL_BASE
N#define _LIBCPP_FUNCTIONAL_BASE
N
N#include <__config>
N#include <type_traits>
N#include <typeinfo>
N#include <exception>
N#include <new>
N#include <utility>
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N_LIBCPP_BEGIN_NAMESPACE_STD
Xnamespace std { inline namespace __2 {
N
Ntemplate <class _Arg1, class _Arg2, class _Result>
Nstruct _LIBCPP_TEMPLATE_VIS binary_function
Xstruct  binary_function
N{
N    typedef _Arg1   first_argument_type;
N    typedef _Arg2   second_argument_type;
N    typedef _Result result_type;
N};
N
Ntemplate <class _Tp>
Nstruct __has_result_type
N{
Nprivate:
N    struct __two {char __lx; char __lxx;};
N    template <class _Up> static __two __test(...);
N    template <class _Up> static char __test(typename _Up::result_type* = 0);
Npublic:
N    static const bool value = sizeof(__test<_Tp>(0)) == 1;
N};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _Tp = void>
N#else
Stemplate <class _Tp>
N#endif
Nstruct _LIBCPP_TEMPLATE_VIS less : binary_function<_Tp, _Tp, bool>
Xstruct  less : binary_function<_Tp, _Tp, bool>
N{
N    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY 
X    constexpr __attribute__ ((__always_inline__)) 
N    bool operator()(const _Tp& __x, const _Tp& __y) const
N        {return __x < __y;}
N};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <>
Nstruct _LIBCPP_TEMPLATE_VIS less<void>
Xstruct  less<void>
N{
N    template <class _T1, class _T2> 
N    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X    constexpr __attribute__ ((__always_inline__))
N    auto operator()(_T1&& __t, _T2&& __u) const
N    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) < _VSTD::forward<_T2>(__u)))
X    noexcept(noexcept(std::__2::forward<_T1>(__t) < std::__2::forward<_T2>(__u)))
N    -> decltype        (_VSTD::forward<_T1>(__t) < _VSTD::forward<_T2>(__u))
X    -> decltype        (std::__2::forward<_T1>(__t) < std::__2::forward<_T2>(__u))
N        { return        _VSTD::forward<_T1>(__t) < _VSTD::forward<_T2>(__u); }
X        { return        std::__2::forward<_T1>(__t) < std::__2::forward<_T2>(__u); }
N    typedef void is_transparent;
N};
N#endif
N
N// __weak_result_type
N
Ntemplate <class _Tp>
Nstruct __derives_from_unary_function
N{
Nprivate:
N    struct __two {char __lx; char __lxx;};
N    static __two __test(...);
N    template <class _Ap, class _Rp>
N        static unary_function<_Ap, _Rp>
N        __test(const volatile unary_function<_Ap, _Rp>*);
Npublic:
N    static const bool value = !is_same<decltype(__test((_Tp*)0)), __two>::value;
N    typedef decltype(__test((_Tp*)0)) type;
N};
N
Ntemplate <class _Tp>
Nstruct __derives_from_binary_function
N{
Nprivate:
N    struct __two {char __lx; char __lxx;};
N    static __two __test(...);
N    template <class _A1, class _A2, class _Rp>
N        static binary_function<_A1, _A2, _Rp>
N        __test(const volatile binary_function<_A1, _A2, _Rp>*);
Npublic:
N    static const bool value = !is_same<decltype(__test((_Tp*)0)), __two>::value;
N    typedef decltype(__test((_Tp*)0)) type;
N};
N
Ntemplate <class _Tp, bool = __derives_from_unary_function<_Tp>::value>
Nstruct __maybe_derive_from_unary_function  // bool is true
N    : public __derives_from_unary_function<_Tp>::type
N{
N};
N
Ntemplate <class _Tp>
Nstruct __maybe_derive_from_unary_function<_Tp, false>
N{
N};
N
Ntemplate <class _Tp, bool = __derives_from_binary_function<_Tp>::value>
Nstruct __maybe_derive_from_binary_function  // bool is true
N    : public __derives_from_binary_function<_Tp>::type
N{
N};
N
Ntemplate <class _Tp>
Nstruct __maybe_derive_from_binary_function<_Tp, false>
N{
N};
N
Ntemplate <class _Tp, bool = __has_result_type<_Tp>::value>
Nstruct __weak_result_type_imp // bool is true
N    : public __maybe_derive_from_unary_function<_Tp>,
N      public __maybe_derive_from_binary_function<_Tp>
N{
N    typedef typename _Tp::result_type result_type;
N};
N
Ntemplate <class _Tp>
Nstruct __weak_result_type_imp<_Tp, false>
N    : public __maybe_derive_from_unary_function<_Tp>,
N      public __maybe_derive_from_binary_function<_Tp>
N{
N};
N
Ntemplate <class _Tp>
Nstruct __weak_result_type
N    : public __weak_result_type_imp<_Tp>
N{
N};
N
N// 0 argument case
N
Ntemplate <class _Rp>
Nstruct __weak_result_type<_Rp ()>
N{
N    typedef _Rp result_type;
N};
N
Ntemplate <class _Rp>
Nstruct __weak_result_type<_Rp (&)()>
N{
N    typedef _Rp result_type;
N};
N
Ntemplate <class _Rp>
Nstruct __weak_result_type<_Rp (*)()>
N{
N    typedef _Rp result_type;
N};
N
N// 1 argument case
N
Ntemplate <class _Rp, class _A1>
Nstruct __weak_result_type<_Rp (_A1)>
N    : public unary_function<_A1, _Rp>
N{
N};
N
Ntemplate <class _Rp, class _A1>
Nstruct __weak_result_type<_Rp (&)(_A1)>
N    : public unary_function<_A1, _Rp>
N{
N};
N
Ntemplate <class _Rp, class _A1>
Nstruct __weak_result_type<_Rp (*)(_A1)>
N    : public unary_function<_A1, _Rp>
N{
N};
N
Ntemplate <class _Rp, class _Cp>
Nstruct __weak_result_type<_Rp (_Cp::*)()>
N    : public unary_function<_Cp*, _Rp>
N{
N};
N
Ntemplate <class _Rp, class _Cp>
Nstruct __weak_result_type<_Rp (_Cp::*)() const>
N    : public unary_function<const _Cp*, _Rp>
N{
N};
N
Ntemplate <class _Rp, class _Cp>
Nstruct __weak_result_type<_Rp (_Cp::*)() volatile>
N    : public unary_function<volatile _Cp*, _Rp>
N{
N};
N
Ntemplate <class _Rp, class _Cp>
Nstruct __weak_result_type<_Rp (_Cp::*)() const volatile>
N    : public unary_function<const volatile _Cp*, _Rp>
N{
N};
N
N// 2 argument case
N
Ntemplate <class _Rp, class _A1, class _A2>
Nstruct __weak_result_type<_Rp (_A1, _A2)>
N    : public binary_function<_A1, _A2, _Rp>
N{
N};
N
Ntemplate <class _Rp, class _A1, class _A2>
Nstruct __weak_result_type<_Rp (*)(_A1, _A2)>
N    : public binary_function<_A1, _A2, _Rp>
N{
N};
N
Ntemplate <class _Rp, class _A1, class _A2>
Nstruct __weak_result_type<_Rp (&)(_A1, _A2)>
N    : public binary_function<_A1, _A2, _Rp>
N{
N};
N
Ntemplate <class _Rp, class _Cp, class _A1>
Nstruct __weak_result_type<_Rp (_Cp::*)(_A1)>
N    : public binary_function<_Cp*, _A1, _Rp>
N{
N};
N
Ntemplate <class _Rp, class _Cp, class _A1>
Nstruct __weak_result_type<_Rp (_Cp::*)(_A1) const>
N    : public binary_function<const _Cp*, _A1, _Rp>
N{
N};
N
Ntemplate <class _Rp, class _Cp, class _A1>
Nstruct __weak_result_type<_Rp (_Cp::*)(_A1) volatile>
N    : public binary_function<volatile _Cp*, _A1, _Rp>
N{
N};
N
Ntemplate <class _Rp, class _Cp, class _A1>
Nstruct __weak_result_type<_Rp (_Cp::*)(_A1) const volatile>
N    : public binary_function<const volatile _Cp*, _A1, _Rp>
N{
N};
N
N
N#ifndef _LIBCPP_CXX03_LANG
N// 3 or more arguments
N
Ntemplate <class _Rp, class _A1, class _A2, class _A3, class ..._A4>
Nstruct __weak_result_type<_Rp (_A1, _A2, _A3, _A4...)>
N{
N    typedef _Rp result_type;
N};
N
Ntemplate <class _Rp, class _A1, class _A2, class _A3, class ..._A4>
Nstruct __weak_result_type<_Rp (&)(_A1, _A2, _A3, _A4...)>
N{
N    typedef _Rp result_type;
N};
N
Ntemplate <class _Rp, class _A1, class _A2, class _A3, class ..._A4>
Nstruct __weak_result_type<_Rp (*)(_A1, _A2, _A3, _A4...)>
N{
N    typedef _Rp result_type;
N};
N
Ntemplate <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>
Nstruct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...)>
N{
N    typedef _Rp result_type;
N};
N
Ntemplate <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>
Nstruct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const>
N{
N    typedef _Rp result_type;
N};
N
Ntemplate <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>
Nstruct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) volatile>
N{
N    typedef _Rp result_type;
N};
N
Ntemplate <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>
Nstruct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const volatile>
N{
N    typedef _Rp result_type;
N};
N
Ntemplate <class _Tp, class ..._Args>
Nstruct __invoke_return
N{
N    typedef decltype(__invoke(_VSTD::declval<_Tp>(), _VSTD::declval<_Args>()...)) type;
X    typedef decltype(__invoke(std::__2::declval<_Tp>(), std::__2::declval<_Args>()...)) type;
N};
N
N#else // defined(_LIBCPP_CXX03_LANG)
S
S#include <__functional_base_03>
S
N#endif  // !defined(_LIBCPP_CXX03_LANG)
N
N
Ntemplate <class _Ret>
Nstruct __invoke_void_return_wrapper
N{
N#ifndef _LIBCPP_CXX03_LANG
N    template <class ..._Args>
N    static _Ret __call(_Args&&... __args) {
N        return __invoke(_VSTD::forward<_Args>(__args)...);
X        return __invoke(std::__2::forward<_Args>(__args)...);
N    }
N#else
S    template <class _Fn>
S    static _Ret __call(_Fn __f) {
S        return __invoke(__f);
S    }
S
S    template <class _Fn, class _A0>
S    static _Ret __call(_Fn __f, _A0& __a0) {
S        return __invoke(__f, __a0);
S    }
S
S    template <class _Fn, class _A0, class _A1>
S    static _Ret __call(_Fn __f, _A0& __a0, _A1& __a1) {
S        return __invoke(__f, __a0, __a1);
S    }
S
S    template <class _Fn, class _A0, class _A1, class _A2>
S    static _Ret __call(_Fn __f, _A0& __a0, _A1& __a1, _A2& __a2){
S        return __invoke(__f, __a0, __a1, __a2);
S    }
N#endif
N};
N
Ntemplate <>
Nstruct __invoke_void_return_wrapper<void>
N{
N#ifndef _LIBCPP_CXX03_LANG
N    template <class ..._Args>
N    static void __call(_Args&&... __args) {
N        __invoke(_VSTD::forward<_Args>(__args)...);
X        __invoke(std::__2::forward<_Args>(__args)...);
N    }
N#else
S    template <class _Fn>
S    static void __call(_Fn __f) {
S        __invoke(__f);
S    }
S
S    template <class _Fn, class _A0>
S    static void __call(_Fn __f, _A0& __a0) {
S        __invoke(__f, __a0);
S    }
S
S    template <class _Fn, class _A0, class _A1>
S    static void __call(_Fn __f, _A0& __a0, _A1& __a1) {
S        __invoke(__f, __a0, __a1);
S    }
S
S    template <class _Fn, class _A0, class _A1, class _A2>
S    static void __call(_Fn __f, _A0& __a0, _A1& __a1, _A2& __a2) {
S        __invoke(__f, __a0, __a1, __a2);
S    }
N#endif
N};
N
Ntemplate <class _Tp>
Nclass _LIBCPP_TEMPLATE_VIS reference_wrapper
Xclass  reference_wrapper
N    : public __weak_result_type<_Tp>
N{
Npublic:
N    // types
N    typedef _Tp type;
Nprivate:
N    type* __f_;
N
Npublic:
N    // construct/copy/destroy
N    _LIBCPP_INLINE_VISIBILITY reference_wrapper(type& __f) _NOEXCEPT
X    __attribute__ ((__always_inline__)) reference_wrapper(type& __f) noexcept
N        : __f_(_VSTD::addressof(__f)) {}
X        : __f_(std::__2::addressof(__f)) {}
N#ifndef _LIBCPP_CXX03_LANG
N    private: reference_wrapper(type&&); public: // = delete; // do not bind to temps
N#endif
N
N    // access
N    _LIBCPP_INLINE_VISIBILITY operator type&    () const _NOEXCEPT {return *__f_;}
X    __attribute__ ((__always_inline__)) operator type&    () const noexcept {return *__f_;}
N    _LIBCPP_INLINE_VISIBILITY          type& get() const _NOEXCEPT {return *__f_;}
X    __attribute__ ((__always_inline__))          type& get() const noexcept {return *__f_;}
N
N#ifndef _LIBCPP_CXX03_LANG
N    // invoke
N    template <class... _ArgTypes>
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    typename __invoke_of<type&, _ArgTypes...>::type
N    operator() (_ArgTypes&&... __args) const {
N        return __invoke(get(), _VSTD::forward<_ArgTypes>(__args)...);
X        return __invoke(get(), std::__2::forward<_ArgTypes>(__args)...);
N    }
N#else
S
S    _LIBCPP_INLINE_VISIBILITY
S    typename __invoke_return<type>::type
S    operator() () const {
S        return __invoke(get());
S    }
S
S    template <class _A0>
S    _LIBCPP_INLINE_VISIBILITY
S    typename __invoke_return0<type, _A0>::type
S    operator() (_A0& __a0) const {
S        return __invoke(get(), __a0);
S    }
S
S    template <class _A0>
S    _LIBCPP_INLINE_VISIBILITY
S    typename __invoke_return0<type, _A0 const>::type
S    operator() (_A0 const& __a0) const {
S        return __invoke(get(), __a0);
S    }
S
S    template <class _A0, class _A1>
S    _LIBCPP_INLINE_VISIBILITY
S    typename __invoke_return1<type, _A0, _A1>::type
S    operator() (_A0& __a0, _A1& __a1) const {
S        return __invoke(get(), __a0, __a1);
S    }
S
S    template <class _A0, class _A1>
S    _LIBCPP_INLINE_VISIBILITY
S    typename __invoke_return1<type, _A0 const, _A1>::type
S    operator() (_A0 const& __a0, _A1& __a1) const {
S        return __invoke(get(), __a0, __a1);
S    }
S
S    template <class _A0, class _A1>
S    _LIBCPP_INLINE_VISIBILITY
S    typename __invoke_return1<type, _A0, _A1 const>::type
S    operator() (_A0& __a0, _A1 const& __a1) const {
S        return __invoke(get(), __a0, __a1);
S    }
S
S    template <class _A0, class _A1>
S    _LIBCPP_INLINE_VISIBILITY
S    typename __invoke_return1<type, _A0 const, _A1 const>::type
S    operator() (_A0 const& __a0, _A1 const& __a1) const {
S        return __invoke(get(), __a0, __a1);
S    }
S
S    template <class _A0, class _A1, class _A2>
S    _LIBCPP_INLINE_VISIBILITY
S    typename __invoke_return2<type, _A0, _A1, _A2>::type
S    operator() (_A0& __a0, _A1& __a1, _A2& __a2) const {
S        return __invoke(get(), __a0, __a1, __a2);
S    }
S
S    template <class _A0, class _A1, class _A2>
S    _LIBCPP_INLINE_VISIBILITY
S    typename __invoke_return2<type, _A0 const, _A1, _A2>::type
S    operator() (_A0 const& __a0, _A1& __a1, _A2& __a2) const {
S        return __invoke(get(), __a0, __a1, __a2);
S    }
S
S    template <class _A0, class _A1, class _A2>
S    _LIBCPP_INLINE_VISIBILITY
S    typename __invoke_return2<type, _A0, _A1 const, _A2>::type
S    operator() (_A0& __a0, _A1 const& __a1, _A2& __a2) const {
S        return __invoke(get(), __a0, __a1, __a2);
S    }
S
S    template <class _A0, class _A1, class _A2>
S    _LIBCPP_INLINE_VISIBILITY
S    typename __invoke_return2<type, _A0, _A1, _A2 const>::type
S    operator() (_A0& __a0, _A1& __a1, _A2 const& __a2) const {
S        return __invoke(get(), __a0, __a1, __a2);
S    }
S
S    template <class _A0, class _A1, class _A2>
S    _LIBCPP_INLINE_VISIBILITY
S    typename __invoke_return2<type, _A0 const, _A1 const, _A2>::type
S    operator() (_A0 const& __a0, _A1 const& __a1, _A2& __a2) const {
S        return __invoke(get(), __a0, __a1, __a2);
S    }
S
S    template <class _A0, class _A1, class _A2>
S    _LIBCPP_INLINE_VISIBILITY
S    typename __invoke_return2<type, _A0 const, _A1, _A2 const>::type
S    operator() (_A0 const& __a0, _A1& __a1, _A2 const& __a2) const {
S        return __invoke(get(), __a0, __a1, __a2);
S    }
S
S    template <class _A0, class _A1, class _A2>
S    _LIBCPP_INLINE_VISIBILITY
S    typename __invoke_return2<type, _A0, _A1 const, _A2 const>::type
S    operator() (_A0& __a0, _A1 const& __a1, _A2 const& __a2) const {
S        return __invoke(get(), __a0, __a1, __a2);
S    }
S
S    template <class _A0, class _A1, class _A2>
S    _LIBCPP_INLINE_VISIBILITY
S    typename __invoke_return2<type, _A0 const, _A1 const, _A2 const>::type
S    operator() (_A0 const& __a0, _A1 const& __a1, _A2 const& __a2) const {
S        return __invoke(get(), __a0, __a1, __a2);
S    }
N#endif // _LIBCPP_CXX03_LANG
N};
N
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nreference_wrapper<_Tp>
Nref(_Tp& __t) _NOEXCEPT
Xref(_Tp& __t) noexcept
N{
N    return reference_wrapper<_Tp>(__t);
N}
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nreference_wrapper<_Tp>
Nref(reference_wrapper<_Tp> __t) _NOEXCEPT
Xref(reference_wrapper<_Tp> __t) noexcept
N{
N    return ref(__t.get());
N}
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nreference_wrapper<const _Tp>
Ncref(const _Tp& __t) _NOEXCEPT
Xcref(const _Tp& __t) noexcept
N{
N    return reference_wrapper<const _Tp>(__t);
N}
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nreference_wrapper<const _Tp>
Ncref(reference_wrapper<_Tp> __t) _NOEXCEPT
Xcref(reference_wrapper<_Tp> __t) noexcept
N{
N    return cref(__t.get());
N}
N
N#ifndef _LIBCPP_CXX03_LANG
Ntemplate <class _Tp> void ref(const _Tp&&) = delete;
Ntemplate <class _Tp> void cref(const _Tp&&) = delete;
N#endif
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _Tp, class, class = void>
Nstruct __is_transparent : false_type {};
N
Ntemplate <class _Tp, class _Up>
Nstruct __is_transparent<_Tp, _Up,  
N                        typename __void_t<typename _Tp::is_transparent>::type>
N   : true_type {};
N#endif
N
N// allocator_arg_t
N
Nstruct _LIBCPP_TEMPLATE_VIS allocator_arg_t { };
Xstruct  allocator_arg_t { };
N
N#if defined(_LIBCPP_CXX03_LANG) || defined(_LIBCPP_BUILDING_MEMORY)
X#if 0L || 0L
Sextern const allocator_arg_t allocator_arg;
N#else
Nconstexpr allocator_arg_t allocator_arg = allocator_arg_t();
N#endif
N
N// uses_allocator
N
Ntemplate <class _Tp>
Nstruct __has_allocator_type
N{
Nprivate:
N    struct __two {char __lx; char __lxx;};
N    template <class _Up> static __two __test(...);
N    template <class _Up> static char __test(typename _Up::allocator_type* = 0);
Npublic:
N    static const bool value = sizeof(__test<_Tp>(0)) == 1;
N};
N
Ntemplate <class _Tp, class _Alloc, bool = __has_allocator_type<_Tp>::value>
Nstruct __uses_allocator
N    : public integral_constant<bool,
N        is_convertible<_Alloc, typename _Tp::allocator_type>::value>
N{
N};
N
Ntemplate <class _Tp, class _Alloc>
Nstruct __uses_allocator<_Tp, _Alloc, false>
N    : public false_type
N{
N};
N
Ntemplate <class _Tp, class _Alloc>
Nstruct _LIBCPP_TEMPLATE_VIS uses_allocator
Xstruct  uses_allocator
N    : public __uses_allocator<_Tp, _Alloc>
N{
N};
N
N#if _LIBCPP_STD_VER > 14
X#if 14 > 14
Stemplate <class _Tp, class _Alloc>
Sconstexpr size_t uses_allocator_v = uses_allocator<_Tp, _Alloc>::value;
N#endif
N
N#ifndef _LIBCPP_CXX03_LANG
N
N// allocator construction
N
Ntemplate <class _Tp, class _Alloc, class ..._Args>
Nstruct __uses_alloc_ctor_imp
N{
N    typedef typename __uncvref<_Alloc>::type _RawAlloc;
N    static const bool __ua = uses_allocator<_Tp, _RawAlloc>::value;
N    static const bool __ic =
N        is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>::value;
N    static const int value = __ua ? 2 - __ic : 0;
N};
N
Ntemplate <class _Tp, class _Alloc, class ..._Args>
Nstruct __uses_alloc_ctor
N    : integral_constant<int, __uses_alloc_ctor_imp<_Tp, _Alloc, _Args...>::value>
N    {};
N
Ntemplate <class _Tp, class _Allocator, class... _Args>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid __user_alloc_construct_impl (integral_constant<int, 0>, _Tp *__storage, const _Allocator &, _Args &&... __args )
N{
N    new (__storage) _Tp (_VSTD::forward<_Args>(__args)...);
X    new (__storage) _Tp (std::__2::forward<_Args>(__args)...);
N}
N
N// FIXME: This should have a version which takes a non-const alloc.
Ntemplate <class _Tp, class _Allocator, class... _Args>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid __user_alloc_construct_impl (integral_constant<int, 1>, _Tp *__storage, const _Allocator &__a, _Args &&... __args )
N{
N    new (__storage) _Tp (allocator_arg, __a, _VSTD::forward<_Args>(__args)...);
X    new (__storage) _Tp (allocator_arg, __a, std::__2::forward<_Args>(__args)...);
N}
N
N// FIXME: This should have a version which takes a non-const alloc.
Ntemplate <class _Tp, class _Allocator, class... _Args>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid __user_alloc_construct_impl (integral_constant<int, 2>, _Tp *__storage, const _Allocator &__a, _Args &&... __args )
N{
N    new (__storage) _Tp (_VSTD::forward<_Args>(__args)..., __a);
X    new (__storage) _Tp (std::__2::forward<_Args>(__args)..., __a);
N}
N
N// FIXME: Theis should have a version which takes a non-const alloc.
Ntemplate <class _Tp, class _Allocator, class... _Args>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid __user_alloc_construct (_Tp *__storage, const _Allocator &__a, _Args &&... __args)
N{ 
N    __user_alloc_construct_impl( 
N             __uses_alloc_ctor<_Tp, _Allocator>(), 
N             __storage, __a, _VSTD::forward<_Args>(__args)...
X             __storage, __a, std::__2::forward<_Args>(__args)...
N        );
N}
N#endif  // _LIBCPP_CXX03_LANG
N
N_LIBCPP_END_NAMESPACE_STD
X} }
N
N#endif  // _LIBCPP_FUNCTIONAL_BASE
L 428 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/iterator" 2
N#include <type_traits>
N#include <cstddef>
N#include <initializer_list>
N#ifdef __APPLE__
S#include <Availability.h>
N#endif
N
N#include <__debug>
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N_LIBCPP_BEGIN_NAMESPACE_STD
Xnamespace std { inline namespace __2 {
N
Nstruct _LIBCPP_TEMPLATE_VIS input_iterator_tag {};
Xstruct  input_iterator_tag {};
Nstruct _LIBCPP_TEMPLATE_VIS output_iterator_tag {};
Xstruct  output_iterator_tag {};
Nstruct _LIBCPP_TEMPLATE_VIS forward_iterator_tag       : public input_iterator_tag {};
Xstruct  forward_iterator_tag       : public input_iterator_tag {};
Nstruct _LIBCPP_TEMPLATE_VIS bidirectional_iterator_tag : public forward_iterator_tag {};
Xstruct  bidirectional_iterator_tag : public forward_iterator_tag {};
Nstruct _LIBCPP_TEMPLATE_VIS random_access_iterator_tag : public bidirectional_iterator_tag {};
Xstruct  random_access_iterator_tag : public bidirectional_iterator_tag {};
N
Ntemplate <class _Tp>
Nstruct __has_iterator_category
N{
Nprivate:
N    struct __two {char __lx; char __lxx;};
N    template <class _Up> static __two __test(...);
N    template <class _Up> static char __test(typename _Up::iterator_category* = 0);
Npublic:
N    static const bool value = sizeof(__test<_Tp>(0)) == 1;
N};
N
Ntemplate <class _Iter, bool> struct __iterator_traits_impl {};
N
Ntemplate <class _Iter>
Nstruct __iterator_traits_impl<_Iter, true>
N{
N    typedef typename _Iter::difference_type   difference_type;
N    typedef typename _Iter::value_type        value_type;
N    typedef typename _Iter::pointer           pointer;
N    typedef typename _Iter::reference         reference;
N    typedef typename _Iter::iterator_category iterator_category;
N};
N
Ntemplate <class _Iter, bool> struct __iterator_traits {};
N
Ntemplate <class _Iter>
Nstruct __iterator_traits<_Iter, true>
N    :  __iterator_traits_impl
N      <
N        _Iter,
N        is_convertible<typename _Iter::iterator_category, input_iterator_tag>::value ||
N        is_convertible<typename _Iter::iterator_category, output_iterator_tag>::value
N      >
N{};
N
N// iterator_traits<Iterator> will only have the nested types if Iterator::iterator_category
N//    exists.  Else iterator_traits<Iterator> will be an empty class.  This is a
N//    conforming extension which allows some programs to compile and behave as
N//    the client expects instead of failing at compile time.
N
Ntemplate <class _Iter>
Nstruct _LIBCPP_TEMPLATE_VIS iterator_traits
Xstruct  iterator_traits
N    : __iterator_traits<_Iter, __has_iterator_category<_Iter>::value> {};
N
Ntemplate<class _Tp>
Nstruct _LIBCPP_TEMPLATE_VIS iterator_traits<_Tp*>
Xstruct  iterator_traits<_Tp*>
N{
N    typedef ptrdiff_t difference_type;
N    typedef typename remove_const<_Tp>::type value_type;
N    typedef _Tp* pointer;
N    typedef _Tp& reference;
N    typedef random_access_iterator_tag iterator_category;
N};
N
Ntemplate <class _Tp, class _Up, bool = __has_iterator_category<iterator_traits<_Tp> >::value>
Nstruct __has_iterator_category_convertible_to
N    : public integral_constant<bool, is_convertible<typename iterator_traits<_Tp>::iterator_category, _Up>::value>
N{};
N
Ntemplate <class _Tp, class _Up>
Nstruct __has_iterator_category_convertible_to<_Tp, _Up, false> : public false_type {};
N
Ntemplate <class _Tp>
Nstruct __is_input_iterator : public __has_iterator_category_convertible_to<_Tp, input_iterator_tag> {};
N
Ntemplate <class _Tp>
Nstruct __is_forward_iterator : public __has_iterator_category_convertible_to<_Tp, forward_iterator_tag> {};
N
Ntemplate <class _Tp>
Nstruct __is_bidirectional_iterator : public __has_iterator_category_convertible_to<_Tp, bidirectional_iterator_tag> {};
N
Ntemplate <class _Tp>
Nstruct __is_random_access_iterator : public __has_iterator_category_convertible_to<_Tp, random_access_iterator_tag> {};
N
Ntemplate <class _Tp>
Nstruct __is_exactly_input_iterator
N    : public integral_constant<bool, 
N         __has_iterator_category_convertible_to<_Tp, input_iterator_tag>::value && 
N        !__has_iterator_category_convertible_to<_Tp, forward_iterator_tag>::value> {};
N
Ntemplate<class _Category, class _Tp, class _Distance = ptrdiff_t,
N         class _Pointer = _Tp*, class _Reference = _Tp&>
Nstruct _LIBCPP_TEMPLATE_VIS iterator
Xstruct  iterator
N{
N    typedef _Tp        value_type;
N    typedef _Distance  difference_type;
N    typedef _Pointer   pointer;
N    typedef _Reference reference;
N    typedef _Category  iterator_category;
N};
N
Ntemplate <class _InputIter>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
Xinline __attribute__ ((__always_inline__)) 
Nvoid __advance(_InputIter& __i,
N             typename iterator_traits<_InputIter>::difference_type __n, input_iterator_tag)
N{
N    for (; __n > 0; --__n)
N        ++__i;
N}
N
Ntemplate <class _BiDirIter>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
Xinline __attribute__ ((__always_inline__)) 
Nvoid __advance(_BiDirIter& __i,
N             typename iterator_traits<_BiDirIter>::difference_type __n, bidirectional_iterator_tag)
N{
N    if (__n >= 0)
N        for (; __n > 0; --__n)
N            ++__i;
N    else
N        for (; __n < 0; ++__n)
N            --__i;
N}
N
Ntemplate <class _RandIter>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
Xinline __attribute__ ((__always_inline__)) 
Nvoid __advance(_RandIter& __i,
N             typename iterator_traits<_RandIter>::difference_type __n, random_access_iterator_tag)
N{
N   __i += __n;
N}
N
Ntemplate <class _InputIter>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
Xinline __attribute__ ((__always_inline__)) 
Nvoid advance(_InputIter& __i,
N             typename iterator_traits<_InputIter>::difference_type __n)
N{
N    __advance(__i, __n, typename iterator_traits<_InputIter>::iterator_category());
N}
N
Ntemplate <class _InputIter>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
Xinline __attribute__ ((__always_inline__)) 
Ntypename iterator_traits<_InputIter>::difference_type
N__distance(_InputIter __first, _InputIter __last, input_iterator_tag)
N{
N    typename iterator_traits<_InputIter>::difference_type __r(0);
N    for (; __first != __last; ++__first)
N        ++__r;
N    return __r;
N}
N
Ntemplate <class _RandIter>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
Xinline __attribute__ ((__always_inline__)) 
Ntypename iterator_traits<_RandIter>::difference_type
N__distance(_RandIter __first, _RandIter __last, random_access_iterator_tag)
N{
N    return __last - __first;
N}
N
Ntemplate <class _InputIter>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
Xinline __attribute__ ((__always_inline__)) 
Ntypename iterator_traits<_InputIter>::difference_type
Ndistance(_InputIter __first, _InputIter __last)
N{
N    return __distance(__first, __last, typename iterator_traits<_InputIter>::iterator_category());
N}
N
Ntemplate <class _InputIter>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
Xinline __attribute__ ((__always_inline__)) 
Ntypename enable_if
N<
N    __is_input_iterator<_InputIter>::value, 
N    _InputIter
N>::type
Nnext(_InputIter __x,
N     typename iterator_traits<_InputIter>::difference_type __n = 1)
N{
N    _VSTD::advance(__x, __n);
X    std::__2::advance(__x, __n);
N    return __x;
N}
N
Ntemplate <class _BidirectionalIter>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
Xinline __attribute__ ((__always_inline__)) 
Ntypename enable_if
N<
N    __is_bidirectional_iterator<_BidirectionalIter>::value, 
N    _BidirectionalIter
N>::type
Nprev(_BidirectionalIter __x,
N     typename iterator_traits<_BidirectionalIter>::difference_type __n = 1)
N{
N    _VSTD::advance(__x, -__n);
X    std::__2::advance(__x, -__n);
N    return __x;
N}
N
N
Ntemplate <class _Tp, class = void>
Nstruct __is_stashing_iterator : false_type {};
N
Ntemplate <class _Tp>
Nstruct __is_stashing_iterator<_Tp, typename __void_t<typename _Tp::__stashing_iterator_tag>::type>
N  : true_type {};
N
Ntemplate <class _Iter>
Nclass _LIBCPP_TEMPLATE_VIS reverse_iterator
Xclass  reverse_iterator
N    : public iterator<typename iterator_traits<_Iter>::iterator_category,
N                      typename iterator_traits<_Iter>::value_type,
N                      typename iterator_traits<_Iter>::difference_type,
N                      typename iterator_traits<_Iter>::pointer,
N                      typename iterator_traits<_Iter>::reference>
N{
Nprivate:
N    /*mutable*/ _Iter __t;  // no longer used as of LWG #2360, not removed due to ABI break
N
N    static_assert(!__is_stashing_iterator<_Iter>::value,
N      "The specified iterator type cannot be used with reverse_iterator; "
N      "Using stashing iterators with reverse_iterator causes undefined behavior");
N
Nprotected:
N    _Iter current;
Npublic:
N    typedef _Iter                                            iterator_type;
N    typedef typename iterator_traits<_Iter>::difference_type difference_type;
N    typedef typename iterator_traits<_Iter>::reference       reference;
N    typedef typename iterator_traits<_Iter>::pointer         pointer;
N
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
X    __attribute__ ((__always_inline__)) 
N    reverse_iterator() : __t(), current() {}
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
X    __attribute__ ((__always_inline__)) 
N    explicit reverse_iterator(_Iter __x) : __t(__x), current(__x) {}
N    template <class _Up>
N        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
X        __attribute__ ((__always_inline__)) 
N        reverse_iterator(const reverse_iterator<_Up>& __u) : __t(__u.base()), current(__u.base()) {}
N    template <class _Up>
N        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
X        __attribute__ ((__always_inline__)) 
N        reverse_iterator& operator=(const reverse_iterator<_Up>& __u)
N            { __t = current = __u.base(); return *this; }
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
X    __attribute__ ((__always_inline__)) 
N    _Iter base() const {return current;}
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
X    __attribute__ ((__always_inline__)) 
N    reference operator*() const {_Iter __tmp = current; return *--__tmp;}
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
X    __attribute__ ((__always_inline__)) 
N    pointer  operator->() const {return _VSTD::addressof(operator*());}
X    pointer  operator->() const {return std::__2::addressof(operator*());}
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
X    __attribute__ ((__always_inline__)) 
N    reverse_iterator& operator++() {--current; return *this;}
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
X    __attribute__ ((__always_inline__)) 
N    reverse_iterator  operator++(int) {reverse_iterator __tmp(*this); --current; return __tmp;}
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
X    __attribute__ ((__always_inline__)) 
N    reverse_iterator& operator--() {++current; return *this;}
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
X    __attribute__ ((__always_inline__)) 
N    reverse_iterator  operator--(int) {reverse_iterator __tmp(*this); ++current; return __tmp;}
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
X    __attribute__ ((__always_inline__)) 
N    reverse_iterator  operator+ (difference_type __n) const {return reverse_iterator(current - __n);}
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
X    __attribute__ ((__always_inline__)) 
N    reverse_iterator& operator+=(difference_type __n) {current -= __n; return *this;}
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
X    __attribute__ ((__always_inline__)) 
N    reverse_iterator  operator- (difference_type __n) const {return reverse_iterator(current + __n);}
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
X    __attribute__ ((__always_inline__)) 
N    reverse_iterator& operator-=(difference_type __n) {current += __n; return *this;}
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
X    __attribute__ ((__always_inline__)) 
N    reference         operator[](difference_type __n) const {return *(*this + __n);}
N};
N
Ntemplate <class _Iter1, class _Iter2>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
Xinline __attribute__ ((__always_inline__)) 
Nbool
Noperator==(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
N{
N    return __x.base() == __y.base();
N}
N
Ntemplate <class _Iter1, class _Iter2>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
Xinline __attribute__ ((__always_inline__)) 
Nbool
Noperator<(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
N{
N    return __x.base() > __y.base();
N}
N
Ntemplate <class _Iter1, class _Iter2>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
Xinline __attribute__ ((__always_inline__)) 
Nbool
Noperator!=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
N{
N    return __x.base() != __y.base();
N}
N
Ntemplate <class _Iter1, class _Iter2>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
Xinline __attribute__ ((__always_inline__)) 
Nbool
Noperator>(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
N{
N    return __x.base() < __y.base();
N}
N
Ntemplate <class _Iter1, class _Iter2>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
Xinline __attribute__ ((__always_inline__)) 
Nbool
Noperator>=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
N{
N    return __x.base() <= __y.base();
N}
N
Ntemplate <class _Iter1, class _Iter2>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
Xinline __attribute__ ((__always_inline__)) 
Nbool
Noperator<=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
N{
N    return __x.base() >= __y.base();
N}
N
N#ifndef _LIBCPP_CXX03_LANG
Ntemplate <class _Iter1, class _Iter2>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
Xinline __attribute__ ((__always_inline__)) 
Nauto
Noperator-(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
N-> decltype(__y.base() - __x.base())
N{
N    return __y.base() - __x.base();
N}
N#else
Stemplate <class _Iter1, class _Iter2>
Sinline _LIBCPP_INLINE_VISIBILITY
Stypename reverse_iterator<_Iter1>::difference_type
Soperator-(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
S{
S    return __y.base() - __x.base();
S}
N#endif
N
Ntemplate <class _Iter>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
Xinline __attribute__ ((__always_inline__)) 
Nreverse_iterator<_Iter>
Noperator+(typename reverse_iterator<_Iter>::difference_type __n, const reverse_iterator<_Iter>& __x)
N{
N    return reverse_iterator<_Iter>(__x.base() - __n);
N}
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _Iter>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
Xinline __attribute__ ((__always_inline__)) 
Nreverse_iterator<_Iter> make_reverse_iterator(_Iter __i)
N{
N    return reverse_iterator<_Iter>(__i);
N}
N#endif
N
Ntemplate <class _Container>
Nclass _LIBCPP_TEMPLATE_VIS back_insert_iterator
Xclass  back_insert_iterator
N    : public iterator<output_iterator_tag,
N                      void,
N                      void,
N                      void,
N                      void>
N{
Nprotected:
N    _Container* container;
Npublic:
N    typedef _Container container_type;
N
N    _LIBCPP_INLINE_VISIBILITY explicit back_insert_iterator(_Container& __x) : container(_VSTD::addressof(__x)) {}
X    __attribute__ ((__always_inline__)) explicit back_insert_iterator(_Container& __x) : container(std::__2::addressof(__x)) {}
N    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator=(const typename _Container::value_type& __value_)
X    __attribute__ ((__always_inline__)) back_insert_iterator& operator=(const typename _Container::value_type& __value_)
N        {container->push_back(__value_); return *this;}
N#ifndef _LIBCPP_CXX03_LANG
N    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator=(typename _Container::value_type&& __value_)
X    __attribute__ ((__always_inline__)) back_insert_iterator& operator=(typename _Container::value_type&& __value_)
N        {container->push_back(_VSTD::move(__value_)); return *this;}
X        {container->push_back(std::__2::move(__value_)); return *this;}
N#endif  // _LIBCPP_CXX03_LANG
N    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator*()     {return *this;}
X    __attribute__ ((__always_inline__)) back_insert_iterator& operator*()     {return *this;}
N    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator++()    {return *this;}
X    __attribute__ ((__always_inline__)) back_insert_iterator& operator++()    {return *this;}
N    _LIBCPP_INLINE_VISIBILITY back_insert_iterator  operator++(int) {return *this;}
X    __attribute__ ((__always_inline__)) back_insert_iterator  operator++(int) {return *this;}
N};
N
Ntemplate <class _Container>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nback_insert_iterator<_Container>
Nback_inserter(_Container& __x)
N{
N    return back_insert_iterator<_Container>(__x);
N}
N
Ntemplate <class _Container>
Nclass _LIBCPP_TEMPLATE_VIS front_insert_iterator
Xclass  front_insert_iterator
N    : public iterator<output_iterator_tag,
N                      void,
N                      void,
N                      void,
N                      void>
N{
Nprotected:
N    _Container* container;
Npublic:
N    typedef _Container container_type;
N
N    _LIBCPP_INLINE_VISIBILITY explicit front_insert_iterator(_Container& __x) : container(_VSTD::addressof(__x)) {}
X    __attribute__ ((__always_inline__)) explicit front_insert_iterator(_Container& __x) : container(std::__2::addressof(__x)) {}
N    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator=(const typename _Container::value_type& __value_)
X    __attribute__ ((__always_inline__)) front_insert_iterator& operator=(const typename _Container::value_type& __value_)
N        {container->push_front(__value_); return *this;}
N#ifndef _LIBCPP_CXX03_LANG
N    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator=(typename _Container::value_type&& __value_)
X    __attribute__ ((__always_inline__)) front_insert_iterator& operator=(typename _Container::value_type&& __value_)
N        {container->push_front(_VSTD::move(__value_)); return *this;}
X        {container->push_front(std::__2::move(__value_)); return *this;}
N#endif  // _LIBCPP_CXX03_LANG
N    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator*()     {return *this;}
X    __attribute__ ((__always_inline__)) front_insert_iterator& operator*()     {return *this;}
N    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator++()    {return *this;}
X    __attribute__ ((__always_inline__)) front_insert_iterator& operator++()    {return *this;}
N    _LIBCPP_INLINE_VISIBILITY front_insert_iterator  operator++(int) {return *this;}
X    __attribute__ ((__always_inline__)) front_insert_iterator  operator++(int) {return *this;}
N};
N
Ntemplate <class _Container>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nfront_insert_iterator<_Container>
Nfront_inserter(_Container& __x)
N{
N    return front_insert_iterator<_Container>(__x);
N}
N
Ntemplate <class _Container>
Nclass _LIBCPP_TEMPLATE_VIS insert_iterator
Xclass  insert_iterator
N    : public iterator<output_iterator_tag,
N                      void,
N                      void,
N                      void,
N                      void>
N{
Nprotected:
N    _Container* container;
N    typename _Container::iterator iter;
Npublic:
N    typedef _Container container_type;
N
N    _LIBCPP_INLINE_VISIBILITY insert_iterator(_Container& __x, typename _Container::iterator __i)
X    __attribute__ ((__always_inline__)) insert_iterator(_Container& __x, typename _Container::iterator __i)
N        : container(_VSTD::addressof(__x)), iter(__i) {}
X        : container(std::__2::addressof(__x)), iter(__i) {}
N    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator=(const typename _Container::value_type& __value_)
X    __attribute__ ((__always_inline__)) insert_iterator& operator=(const typename _Container::value_type& __value_)
N        {iter = container->insert(iter, __value_); ++iter; return *this;}
N#ifndef _LIBCPP_CXX03_LANG
N    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator=(typename _Container::value_type&& __value_)
X    __attribute__ ((__always_inline__)) insert_iterator& operator=(typename _Container::value_type&& __value_)
N        {iter = container->insert(iter, _VSTD::move(__value_)); ++iter; return *this;}
X        {iter = container->insert(iter, std::__2::move(__value_)); ++iter; return *this;}
N#endif  // _LIBCPP_CXX03_LANG
N    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator*()        {return *this;}
X    __attribute__ ((__always_inline__)) insert_iterator& operator*()        {return *this;}
N    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator++()       {return *this;}
X    __attribute__ ((__always_inline__)) insert_iterator& operator++()       {return *this;}
N    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator++(int)    {return *this;}
X    __attribute__ ((__always_inline__)) insert_iterator& operator++(int)    {return *this;}
N};
N
Ntemplate <class _Container>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ninsert_iterator<_Container>
Ninserter(_Container& __x, typename _Container::iterator __i)
N{
N    return insert_iterator<_Container>(__x, __i);
N}
N
Ntemplate <class _Tp, class _CharT = char,
N          class _Traits = char_traits<_CharT>, class _Distance = ptrdiff_t>
Nclass _LIBCPP_TEMPLATE_VIS istream_iterator
Xclass  istream_iterator
N    : public iterator<input_iterator_tag, _Tp, _Distance, const _Tp*, const _Tp&>
N{
Npublic:
N    typedef _CharT char_type;
N    typedef _Traits traits_type;
N    typedef basic_istream<_CharT,_Traits> istream_type;
Nprivate:
N    istream_type* __in_stream_;
N    _Tp __value_;
Npublic:
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR istream_iterator() : __in_stream_(0), __value_() {}
X    __attribute__ ((__always_inline__)) constexpr istream_iterator() : __in_stream_(0), __value_() {}
N    _LIBCPP_INLINE_VISIBILITY istream_iterator(istream_type& __s) : __in_stream_(_VSTD::addressof(__s))
X    __attribute__ ((__always_inline__)) istream_iterator(istream_type& __s) : __in_stream_(std::__2::addressof(__s))
N        {
N            if (!(*__in_stream_ >> __value_))
N                __in_stream_ = 0;
N        }
N
N    _LIBCPP_INLINE_VISIBILITY const _Tp& operator*() const {return __value_;}
X    __attribute__ ((__always_inline__)) const _Tp& operator*() const {return __value_;}
N    _LIBCPP_INLINE_VISIBILITY const _Tp* operator->() const {return _VSTD::addressof((operator*()));}
X    __attribute__ ((__always_inline__)) const _Tp* operator->() const {return std::__2::addressof((operator*()));}
N    _LIBCPP_INLINE_VISIBILITY istream_iterator& operator++()
X    __attribute__ ((__always_inline__)) istream_iterator& operator++()
N        {
N            if (!(*__in_stream_ >> __value_))
N                __in_stream_ = 0;
N            return *this;
N        }
N    _LIBCPP_INLINE_VISIBILITY istream_iterator  operator++(int)
X    __attribute__ ((__always_inline__)) istream_iterator  operator++(int)
N        {istream_iterator __t(*this); ++(*this); return __t;}
N
N    friend _LIBCPP_INLINE_VISIBILITY
X    friend __attribute__ ((__always_inline__))
N    bool operator==(const istream_iterator& __x, const istream_iterator& __y)
N        {return __x.__in_stream_ == __y.__in_stream_;}
N
N    friend _LIBCPP_INLINE_VISIBILITY
X    friend __attribute__ ((__always_inline__))
N    bool operator!=(const istream_iterator& __x, const istream_iterator& __y)
N        {return !(__x == __y);}
N};
N
Ntemplate <class _Tp, class _CharT = char, class _Traits = char_traits<_CharT> >
Nclass _LIBCPP_TEMPLATE_VIS ostream_iterator
Xclass  ostream_iterator
N    : public iterator<output_iterator_tag, void, void, void, void>
N{
Npublic:
N    typedef _CharT char_type;
N    typedef _Traits traits_type;
N    typedef basic_ostream<_CharT,_Traits> ostream_type;
Nprivate:
N    ostream_type* __out_stream_;
N    const char_type* __delim_;
Npublic:
N    _LIBCPP_INLINE_VISIBILITY ostream_iterator(ostream_type& __s) _NOEXCEPT
X    __attribute__ ((__always_inline__)) ostream_iterator(ostream_type& __s) noexcept
N        : __out_stream_(_VSTD::addressof(__s)), __delim_(0) {}
X        : __out_stream_(std::__2::addressof(__s)), __delim_(0) {}
N    _LIBCPP_INLINE_VISIBILITY ostream_iterator(ostream_type& __s, const _CharT* __delimiter) _NOEXCEPT
X    __attribute__ ((__always_inline__)) ostream_iterator(ostream_type& __s, const _CharT* __delimiter) noexcept
N        : __out_stream_(_VSTD::addressof(__s)), __delim_(__delimiter) {}
X        : __out_stream_(std::__2::addressof(__s)), __delim_(__delimiter) {}
N    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator=(const _Tp& __value_)
X    __attribute__ ((__always_inline__)) ostream_iterator& operator=(const _Tp& __value_)
N        {
N            *__out_stream_ << __value_;
N            if (__delim_)
N                *__out_stream_ << __delim_;
N            return *this;
N        }
N
N    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator*()     {return *this;}
X    __attribute__ ((__always_inline__)) ostream_iterator& operator*()     {return *this;}
N    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator++()    {return *this;}
X    __attribute__ ((__always_inline__)) ostream_iterator& operator++()    {return *this;}
N    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator++(int) {return *this;}
X    __attribute__ ((__always_inline__)) ostream_iterator& operator++(int) {return *this;}
N};
N
Ntemplate<class _CharT, class _Traits>
Nclass _LIBCPP_TEMPLATE_VIS istreambuf_iterator
Xclass  istreambuf_iterator
N    : public iterator<input_iterator_tag, _CharT,
N                      typename _Traits::off_type, _CharT*,
N                      _CharT>
N{
Npublic:
N    typedef _CharT                          char_type;
N    typedef _Traits                         traits_type;
N    typedef typename _Traits::int_type      int_type;
N    typedef basic_streambuf<_CharT,_Traits> streambuf_type;
N    typedef basic_istream<_CharT,_Traits>   istream_type;
Nprivate:
N    mutable streambuf_type* __sbuf_;
N
N    class __proxy
N    {
N        char_type __keep_;
N        streambuf_type* __sbuf_;
N        _LIBCPP_INLINE_VISIBILITY __proxy(char_type __c, streambuf_type* __s)
X        __attribute__ ((__always_inline__)) __proxy(char_type __c, streambuf_type* __s)
N            : __keep_(__c), __sbuf_(__s) {}
N        friend class istreambuf_iterator;
N    public:
N        _LIBCPP_INLINE_VISIBILITY char_type operator*() const {return __keep_;}
X        __attribute__ ((__always_inline__)) char_type operator*() const {return __keep_;}
N    };
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    bool __test_for_eof() const
N    {
N        if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sgetc(), traits_type::eof()))
N            __sbuf_ = 0;
N        return __sbuf_ == 0;
N    }
Npublic:
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR istreambuf_iterator() _NOEXCEPT : __sbuf_(0) {}
X    __attribute__ ((__always_inline__)) constexpr istreambuf_iterator() noexcept : __sbuf_(0) {}
N    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator(istream_type& __s) _NOEXCEPT
X    __attribute__ ((__always_inline__)) istreambuf_iterator(istream_type& __s) noexcept
N        : __sbuf_(__s.rdbuf()) {}
N    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator(streambuf_type* __s) _NOEXCEPT
X    __attribute__ ((__always_inline__)) istreambuf_iterator(streambuf_type* __s) noexcept
N        : __sbuf_(__s) {}
N    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator(const __proxy& __p) _NOEXCEPT
X    __attribute__ ((__always_inline__)) istreambuf_iterator(const __proxy& __p) noexcept
N        : __sbuf_(__p.__sbuf_) {}
N
N    _LIBCPP_INLINE_VISIBILITY char_type  operator*() const
X    __attribute__ ((__always_inline__)) char_type  operator*() const
N        {return static_cast<char_type>(__sbuf_->sgetc());}
N    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator& operator++()
X    __attribute__ ((__always_inline__)) istreambuf_iterator& operator++()
N        {
N            __sbuf_->sbumpc();
N            return *this;
N        }
N    _LIBCPP_INLINE_VISIBILITY __proxy              operator++(int)
X    __attribute__ ((__always_inline__)) __proxy              operator++(int)
N        {
N            return __proxy(__sbuf_->sbumpc(), __sbuf_);
N        }
N
N    _LIBCPP_INLINE_VISIBILITY bool equal(const istreambuf_iterator& __b) const
X    __attribute__ ((__always_inline__)) bool equal(const istreambuf_iterator& __b) const
N        {return __test_for_eof() == __b.__test_for_eof();}
N};
N
Ntemplate <class _CharT, class _Traits>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool operator==(const istreambuf_iterator<_CharT,_Traits>& __a,
N                const istreambuf_iterator<_CharT,_Traits>& __b)
N                {return __a.equal(__b);}
N
Ntemplate <class _CharT, class _Traits>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool operator!=(const istreambuf_iterator<_CharT,_Traits>& __a,
N                const istreambuf_iterator<_CharT,_Traits>& __b)
N                {return !__a.equal(__b);}
N
Ntemplate <class _CharT, class _Traits>
Nclass _LIBCPP_TEMPLATE_VIS ostreambuf_iterator
Xclass  ostreambuf_iterator
N    : public iterator<output_iterator_tag, void, void, void, void>
N{
Npublic:
N    typedef _CharT                          char_type;
N    typedef _Traits                         traits_type;
N    typedef basic_streambuf<_CharT,_Traits> streambuf_type;
N    typedef basic_ostream<_CharT,_Traits>   ostream_type;
Nprivate:
N    streambuf_type* __sbuf_;
Npublic:
N    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator(ostream_type& __s) _NOEXCEPT
X    __attribute__ ((__always_inline__)) ostreambuf_iterator(ostream_type& __s) noexcept
N        : __sbuf_(__s.rdbuf()) {}
N    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator(streambuf_type* __s) _NOEXCEPT
X    __attribute__ ((__always_inline__)) ostreambuf_iterator(streambuf_type* __s) noexcept
N        : __sbuf_(__s) {}
N    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator=(_CharT __c)
X    __attribute__ ((__always_inline__)) ostreambuf_iterator& operator=(_CharT __c)
N        {
N            if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sputc(__c), traits_type::eof()))
N                __sbuf_ = 0;
N            return *this;
N        }
N    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator*()     {return *this;}
X    __attribute__ ((__always_inline__)) ostreambuf_iterator& operator*()     {return *this;}
N    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator++()    {return *this;}
X    __attribute__ ((__always_inline__)) ostreambuf_iterator& operator++()    {return *this;}
N    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator++(int) {return *this;}
X    __attribute__ ((__always_inline__)) ostreambuf_iterator& operator++(int) {return *this;}
N    _LIBCPP_INLINE_VISIBILITY bool failed() const _NOEXCEPT {return __sbuf_ == 0;}
X    __attribute__ ((__always_inline__)) bool failed() const noexcept {return __sbuf_ == 0;}
N
N#if !defined(__APPLE__) || \
N    (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && __MAC_OS_X_VERSION_MIN_REQUIRED > __MAC_10_8) || \
N    (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && __IPHONE_OS_VERSION_MIN_REQUIRED > __IPHONE_6_0)
X#if !0L ||     (0L && __MAC_OS_X_VERSION_MIN_REQUIRED > __MAC_10_8) ||     (0L && __IPHONE_OS_VERSION_MIN_REQUIRED > __IPHONE_6_0)
N
N    template <class _Ch, class _Tr>
N    friend
N    _LIBCPP_HIDDEN
X    
N    ostreambuf_iterator<_Ch, _Tr>
N    __pad_and_output(ostreambuf_iterator<_Ch, _Tr> __s,
N                     const _Ch* __ob, const _Ch* __op, const _Ch* __oe,
N                     ios_base& __iob, _Ch __fl);
N#endif
N};
N
Ntemplate <class _Iter>
Nclass _LIBCPP_TEMPLATE_VIS move_iterator
Xclass  move_iterator
N{
Nprivate:
N    _Iter __i;
Npublic:
N    typedef _Iter                                            iterator_type;
N    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;
N    typedef typename iterator_traits<iterator_type>::value_type value_type;
N    typedef typename iterator_traits<iterator_type>::difference_type difference_type;
N    typedef iterator_type pointer;
N#ifndef _LIBCPP_CXX03_LANG
N    typedef typename iterator_traits<iterator_type>::reference __reference;
N    typedef typename conditional<
N            is_reference<__reference>::value,
N            typename remove_reference<__reference>::type&&,
N            __reference
N        >::type reference;
N#else
S    typedef typename iterator_traits<iterator_type>::reference reference;
N#endif
N
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
X    __attribute__ ((__always_inline__)) 
N    move_iterator() : __i() {}
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
X    __attribute__ ((__always_inline__)) 
N    explicit move_iterator(_Iter __x) : __i(__x) {}
N    template <class _Up>
N      _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
X      __attribute__ ((__always_inline__)) 
N      move_iterator(const move_iterator<_Up>& __u) : __i(__u.base()) {}
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 _Iter base() const {return __i;}
X    __attribute__ ((__always_inline__))  _Iter base() const {return __i;}
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 
X    __attribute__ ((__always_inline__))  
N    reference operator*() const { return static_cast<reference>(*__i); }
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
X    __attribute__ ((__always_inline__)) 
N    pointer  operator->() const { return __i;}
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
X    __attribute__ ((__always_inline__)) 
N    move_iterator& operator++() {++__i; return *this;}
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
X    __attribute__ ((__always_inline__)) 
N    move_iterator  operator++(int) {move_iterator __tmp(*this); ++__i; return __tmp;}
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
X    __attribute__ ((__always_inline__)) 
N    move_iterator& operator--() {--__i; return *this;}
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
X    __attribute__ ((__always_inline__)) 
N    move_iterator  operator--(int) {move_iterator __tmp(*this); --__i; return __tmp;}
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
X    __attribute__ ((__always_inline__)) 
N    move_iterator  operator+ (difference_type __n) const {return move_iterator(__i + __n);}
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
X    __attribute__ ((__always_inline__)) 
N    move_iterator& operator+=(difference_type __n) {__i += __n; return *this;}
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
X    __attribute__ ((__always_inline__)) 
N    move_iterator  operator- (difference_type __n) const {return move_iterator(__i - __n);}
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
X    __attribute__ ((__always_inline__)) 
N    move_iterator& operator-=(difference_type __n) {__i -= __n; return *this;}
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
X    __attribute__ ((__always_inline__)) 
N    reference operator[](difference_type __n) const { return static_cast<reference>(__i[__n]); }
N};
N
Ntemplate <class _Iter1, class _Iter2>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
Xinline __attribute__ ((__always_inline__)) 
Nbool
Noperator==(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
N{
N    return __x.base() == __y.base();
N}
N
Ntemplate <class _Iter1, class _Iter2>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
Xinline __attribute__ ((__always_inline__)) 
Nbool
Noperator<(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
N{
N    return __x.base() < __y.base();
N}
N
Ntemplate <class _Iter1, class _Iter2>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
Xinline __attribute__ ((__always_inline__)) 
Nbool
Noperator!=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
N{
N    return __x.base() != __y.base();
N}
N
Ntemplate <class _Iter1, class _Iter2>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
Xinline __attribute__ ((__always_inline__)) 
Nbool
Noperator>(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
N{
N    return __x.base() > __y.base();
N}
N
Ntemplate <class _Iter1, class _Iter2>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
Xinline __attribute__ ((__always_inline__)) 
Nbool
Noperator>=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
N{
N    return __x.base() >= __y.base();
N}
N
Ntemplate <class _Iter1, class _Iter2>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
Xinline __attribute__ ((__always_inline__)) 
Nbool
Noperator<=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
N{
N    return __x.base() <= __y.base();
N}
N
N#ifndef _LIBCPP_CXX03_LANG
Ntemplate <class _Iter1, class _Iter2>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
Xinline __attribute__ ((__always_inline__)) 
Nauto
Noperator-(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
N-> decltype(__x.base() - __y.base())
N{
N    return __x.base() - __y.base();
N}
N#else
Stemplate <class _Iter1, class _Iter2>
Sinline _LIBCPP_INLINE_VISIBILITY
Stypename move_iterator<_Iter1>::difference_type
Soperator-(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
S{
S    return __x.base() - __y.base();
S}
N#endif
N
Ntemplate <class _Iter>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
Xinline __attribute__ ((__always_inline__)) 
Nmove_iterator<_Iter>
Noperator+(typename move_iterator<_Iter>::difference_type __n, const move_iterator<_Iter>& __x)
N{
N    return move_iterator<_Iter>(__x.base() + __n);
N}
N
Ntemplate <class _Iter>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
Xinline __attribute__ ((__always_inline__)) 
Nmove_iterator<_Iter>
Nmake_move_iterator(_Iter __i)
N{
N    return move_iterator<_Iter>(__i);
N}
N
N// __wrap_iter
N
Ntemplate <class _Iter> class __wrap_iter;
N
Ntemplate <class _Iter1, class _Iter2>
N_LIBCPP_INLINE_VISIBILITY
X__attribute__ ((__always_inline__))
Nbool
Noperator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;
Xoperator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;
N
Ntemplate <class _Iter1, class _Iter2>
N_LIBCPP_INLINE_VISIBILITY
X__attribute__ ((__always_inline__))
Nbool
Noperator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;
Xoperator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;
N
Ntemplate <class _Iter1, class _Iter2>
N_LIBCPP_INLINE_VISIBILITY
X__attribute__ ((__always_inline__))
Nbool
Noperator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;
Xoperator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;
N
Ntemplate <class _Iter1, class _Iter2>
N_LIBCPP_INLINE_VISIBILITY
X__attribute__ ((__always_inline__))
Nbool
Noperator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;
Xoperator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;
N
Ntemplate <class _Iter1, class _Iter2>
N_LIBCPP_INLINE_VISIBILITY
X__attribute__ ((__always_inline__))
Nbool
Noperator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;
Xoperator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;
N
Ntemplate <class _Iter1, class _Iter2>
N_LIBCPP_INLINE_VISIBILITY
X__attribute__ ((__always_inline__))
Nbool
Noperator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;
Xoperator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;
N
N#ifndef _LIBCPP_CXX03_LANG
Ntemplate <class _Iter1, class _Iter2>
N_LIBCPP_INLINE_VISIBILITY
X__attribute__ ((__always_inline__))
Nauto
Noperator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG
Xoperator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
N-> decltype(__x.base() - __y.base());
N#else
Stemplate <class _Iter1, class _Iter2>
S_LIBCPP_INLINE_VISIBILITY
Stypename __wrap_iter<_Iter1>::difference_type
Soperator-(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;
N#endif
N
Ntemplate <class _Iter>
N_LIBCPP_INLINE_VISIBILITY
X__attribute__ ((__always_inline__))
N__wrap_iter<_Iter>
Noperator+(typename __wrap_iter<_Iter>::difference_type, __wrap_iter<_Iter>) _NOEXCEPT_DEBUG;
Xoperator+(typename __wrap_iter<_Iter>::difference_type, __wrap_iter<_Iter>) noexcept;
N
Ntemplate <class _Ip, class _Op> _Op _LIBCPP_INLINE_VISIBILITY copy(_Ip, _Ip, _Op);
Xtemplate <class _Ip, class _Op> _Op __attribute__ ((__always_inline__)) copy(_Ip, _Ip, _Op);
Ntemplate <class _B1, class _B2> _B2 _LIBCPP_INLINE_VISIBILITY copy_backward(_B1, _B1, _B2);
Xtemplate <class _B1, class _B2> _B2 __attribute__ ((__always_inline__)) copy_backward(_B1, _B1, _B2);
Ntemplate <class _Ip, class _Op> _Op _LIBCPP_INLINE_VISIBILITY move(_Ip, _Ip, _Op);
Xtemplate <class _Ip, class _Op> _Op __attribute__ ((__always_inline__)) move(_Ip, _Ip, _Op);
Ntemplate <class _B1, class _B2> _B2 _LIBCPP_INLINE_VISIBILITY move_backward(_B1, _B1, _B2);
Xtemplate <class _B1, class _B2> _B2 __attribute__ ((__always_inline__)) move_backward(_B1, _B1, _B2);
N
N#if _LIBCPP_DEBUG_LEVEL < 2
N
Ntemplate <class _Tp>
N_LIBCPP_INLINE_VISIBILITY
X__attribute__ ((__always_inline__))
Ntypename enable_if
N<
N    is_trivially_copy_assignable<_Tp>::value,
N    _Tp*
N>::type
N__unwrap_iter(__wrap_iter<_Tp*>);
N
N#else
S
Stemplate <class _Tp>
Sinline _LIBCPP_INLINE_VISIBILITY
Stypename enable_if
S<
S    is_trivially_copy_assignable<_Tp>::value,
S    __wrap_iter<_Tp*>
S>::type
S__unwrap_iter(__wrap_iter<_Tp*> __i);
S
N#endif
N
Ntemplate <class _Iter>
Nclass __wrap_iter
N{
Npublic:
N    typedef _Iter                                                      iterator_type;
N    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;
N    typedef typename iterator_traits<iterator_type>::value_type        value_type;
N    typedef typename iterator_traits<iterator_type>::difference_type   difference_type;
N    typedef typename iterator_traits<iterator_type>::pointer           pointer;
N    typedef typename iterator_traits<iterator_type>::reference         reference;
Nprivate:
N    iterator_type __i;
Npublic:
N    _LIBCPP_INLINE_VISIBILITY __wrap_iter() _NOEXCEPT_DEBUG
X    __attribute__ ((__always_inline__)) __wrap_iter() noexcept
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
N                : __i{}
N#endif
N    {
N#if _LIBCPP_DEBUG_LEVEL >= 2
S        __get_db()->__insert_i(this);
N#endif
N    }
N    template <class _Up> _LIBCPP_INLINE_VISIBILITY __wrap_iter(const __wrap_iter<_Up>& __u,
X    template <class _Up> __attribute__ ((__always_inline__)) __wrap_iter(const __wrap_iter<_Up>& __u,
N        typename enable_if<is_convertible<_Up, iterator_type>::value>::type* = 0) _NOEXCEPT_DEBUG
X        typename enable_if<is_convertible<_Up, iterator_type>::value>::type* = 0) noexcept
N        : __i(__u.base())
N    {
N#if _LIBCPP_DEBUG_LEVEL >= 2
S        __get_db()->__iterator_copy(this, &__u);
N#endif
N    }
N#if _LIBCPP_DEBUG_LEVEL >= 2
S    _LIBCPP_INLINE_VISIBILITY
S    __wrap_iter(const __wrap_iter& __x)
S        : __i(__x.base())
S    {
S        __get_db()->__iterator_copy(this, &__x);
S    }
S    _LIBCPP_INLINE_VISIBILITY
S    __wrap_iter& operator=(const __wrap_iter& __x)
S    {
S        if (this != &__x)
S        {
S            __get_db()->__iterator_copy(this, &__x);
S            __i = __x.__i;
S        }
S        return *this;
S    }
S    _LIBCPP_INLINE_VISIBILITY
S    ~__wrap_iter()
S    {
S        __get_db()->__erase_i(this);
S    }
N#endif
N    _LIBCPP_INLINE_VISIBILITY reference operator*() const _NOEXCEPT_DEBUG
X    __attribute__ ((__always_inline__)) reference operator*() const noexcept
N    {
N#if _LIBCPP_DEBUG_LEVEL >= 2
S        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),
S                       "Attempted to dereference a non-dereferenceable iterator");
N#endif
N        return *__i;
N    }
N    _LIBCPP_INLINE_VISIBILITY pointer  operator->() const _NOEXCEPT_DEBUG
X    __attribute__ ((__always_inline__)) pointer  operator->() const noexcept
N    {
N#if _LIBCPP_DEBUG_LEVEL >= 2
S        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),
S                       "Attempted to dereference a non-dereferenceable iterator");
N#endif
N        return (pointer)_VSTD::addressof(*__i);
X        return (pointer)std::__2::addressof(*__i);
N    }
N    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator++() _NOEXCEPT_DEBUG
X    __attribute__ ((__always_inline__)) __wrap_iter& operator++() noexcept
N    {
N#if _LIBCPP_DEBUG_LEVEL >= 2
S        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),
S                       "Attempted to increment non-incrementable iterator");
N#endif
N        ++__i;
N        return *this;
N    }
N    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator++(int) _NOEXCEPT_DEBUG
X    __attribute__ ((__always_inline__)) __wrap_iter  operator++(int) noexcept
N        {__wrap_iter __tmp(*this); ++(*this); return __tmp;}
N    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator--() _NOEXCEPT_DEBUG
X    __attribute__ ((__always_inline__)) __wrap_iter& operator--() noexcept
N    {
N#if _LIBCPP_DEBUG_LEVEL >= 2
S        _LIBCPP_ASSERT(__get_const_db()->__decrementable(this),
S                       "Attempted to decrement non-decrementable iterator");
N#endif
N        --__i;
N        return *this;
N    }
N    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator--(int) _NOEXCEPT_DEBUG
X    __attribute__ ((__always_inline__)) __wrap_iter  operator--(int) noexcept
N        {__wrap_iter __tmp(*this); --(*this); return __tmp;}
N    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator+ (difference_type __n) const _NOEXCEPT_DEBUG
X    __attribute__ ((__always_inline__)) __wrap_iter  operator+ (difference_type __n) const noexcept
N        {__wrap_iter __w(*this); __w += __n; return __w;}
N    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator+=(difference_type __n) _NOEXCEPT_DEBUG
X    __attribute__ ((__always_inline__)) __wrap_iter& operator+=(difference_type __n) noexcept
N    {
N#if _LIBCPP_DEBUG_LEVEL >= 2
S        _LIBCPP_ASSERT(__get_const_db()->__addable(this, __n),
S                   "Attempted to add/subtract iterator outside of valid range");
N#endif
N        __i += __n;
N        return *this;
N    }
N    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator- (difference_type __n) const _NOEXCEPT_DEBUG
X    __attribute__ ((__always_inline__)) __wrap_iter  operator- (difference_type __n) const noexcept
N        {return *this + (-__n);}
N    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator-=(difference_type __n) _NOEXCEPT_DEBUG
X    __attribute__ ((__always_inline__)) __wrap_iter& operator-=(difference_type __n) noexcept
N        {*this += -__n; return *this;}
N    _LIBCPP_INLINE_VISIBILITY reference        operator[](difference_type __n) const _NOEXCEPT_DEBUG
X    __attribute__ ((__always_inline__)) reference        operator[](difference_type __n) const noexcept
N    {
N#if _LIBCPP_DEBUG_LEVEL >= 2
S        _LIBCPP_ASSERT(__get_const_db()->__subscriptable(this, __n),
S                   "Attempted to subscript iterator outside of valid range");
N#endif
N        return __i[__n];
N    }
N
N    _LIBCPP_INLINE_VISIBILITY iterator_type base() const _NOEXCEPT_DEBUG {return __i;}
X    __attribute__ ((__always_inline__)) iterator_type base() const noexcept {return __i;}
N
Nprivate:
N#if _LIBCPP_DEBUG_LEVEL >= 2
S    _LIBCPP_INLINE_VISIBILITY __wrap_iter(const void* __p, iterator_type __x) : __i(__x)
S    {
S        __get_db()->__insert_ic(this, __p);
S    }
N#else
N    _LIBCPP_INLINE_VISIBILITY __wrap_iter(iterator_type __x) _NOEXCEPT_DEBUG : __i(__x) {}
X    __attribute__ ((__always_inline__)) __wrap_iter(iterator_type __x) noexcept : __i(__x) {}
N#endif
N
N    template <class _Up> friend class __wrap_iter;
N    template <class _CharT, class _Traits, class _Alloc> friend class basic_string;
N    template <class _Tp, class _Alloc> friend class _LIBCPP_TEMPLATE_VIS vector;
X    template <class _Tp, class _Alloc> friend class  vector;
N
N    template <class _Iter1, class _Iter2>
N    friend
N    bool
N    operator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;
X    operator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;
N
N    template <class _Iter1, class _Iter2>
N    friend
N    bool
N    operator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;
X    operator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;
N
N    template <class _Iter1, class _Iter2>
N    friend
N    bool
N    operator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;
X    operator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;
N
N    template <class _Iter1, class _Iter2>
N    friend
N    bool
N    operator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;
X    operator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;
N
N    template <class _Iter1, class _Iter2>
N    friend
N    bool
N    operator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;
X    operator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;
N
N    template <class _Iter1, class _Iter2>
N    friend
N    bool
N    operator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;
X    operator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;
N
N#ifndef _LIBCPP_CXX03_LANG
N    template <class _Iter1, class _Iter2>
N    friend
N    auto
N    operator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG
X    operator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
N    -> decltype(__x.base() - __y.base());
N#else
S    template <class _Iter1, class _Iter2>
S    friend
S    typename __wrap_iter<_Iter1>::difference_type
S    operator-(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;
N#endif
N
N    template <class _Iter1>
N    friend
N    __wrap_iter<_Iter1>
N    operator+(typename __wrap_iter<_Iter1>::difference_type, __wrap_iter<_Iter1>) _NOEXCEPT_DEBUG;
X    operator+(typename __wrap_iter<_Iter1>::difference_type, __wrap_iter<_Iter1>) noexcept;
N
N    template <class _Ip, class _Op> friend _Op copy(_Ip, _Ip, _Op);
N    template <class _B1, class _B2> friend _B2 copy_backward(_B1, _B1, _B2);
N    template <class _Ip, class _Op> friend _Op move(_Ip, _Ip, _Op);
N    template <class _B1, class _B2> friend _B2 move_backward(_B1, _B1, _B2);
N
N#if _LIBCPP_DEBUG_LEVEL < 2
N    template <class _Tp>
N    friend
N    typename enable_if
N    <
N        is_trivially_copy_assignable<_Tp>::value,
N        _Tp*
N    >::type
N    __unwrap_iter(__wrap_iter<_Tp*>);
N#else
S  template <class _Tp>
S  inline _LIBCPP_INLINE_VISIBILITY
S  typename enable_if
S  <
S      is_trivially_copy_assignable<_Tp>::value,
S      __wrap_iter<_Tp*>
S  >::type
S  __unwrap_iter(__wrap_iter<_Tp*> __i);
N#endif
N};
N
Ntemplate <class _Iter1, class _Iter2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator==(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG
Xoperator==(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
N{
N    return __x.base() == __y.base();
N}
N
Ntemplate <class _Iter1, class _Iter2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator<(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG
Xoperator<(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
N{
N#if _LIBCPP_DEBUG_LEVEL >= 2
S    _LIBCPP_ASSERT(__get_const_db()->__less_than_comparable(&__x, &__y),
S                   "Attempted to compare incomparable iterators");
N#endif
N    return __x.base() < __y.base();
N}
N
Ntemplate <class _Iter1, class _Iter2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG
Xoperator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
N{
N    return !(__x == __y);
N}
N
Ntemplate <class _Iter1, class _Iter2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG
Xoperator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
N{
N    return __y < __x;
N}
N
Ntemplate <class _Iter1, class _Iter2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG
Xoperator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
N{
N    return !(__x < __y);
N}
N
Ntemplate <class _Iter1, class _Iter2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG
Xoperator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
N{
N    return !(__y < __x);
N}
N
Ntemplate <class _Iter1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT_DEBUG
Xoperator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) noexcept
N{
N    return !(__x == __y);
N}
N
Ntemplate <class _Iter1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT_DEBUG
Xoperator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) noexcept
N{
N    return __y < __x;
N}
N
Ntemplate <class _Iter1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT_DEBUG
Xoperator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) noexcept
N{
N    return !(__x < __y);
N}
N
Ntemplate <class _Iter1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT_DEBUG
Xoperator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) noexcept
N{
N    return !(__y < __x);
N}
N
N#ifndef _LIBCPP_CXX03_LANG
Ntemplate <class _Iter1, class _Iter2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nauto
Noperator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG
Xoperator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
N-> decltype(__x.base() - __y.base())
N{
N#if _LIBCPP_DEBUG_LEVEL >= 2
S    _LIBCPP_ASSERT(__get_const_db()->__less_than_comparable(&__x, &__y),
S                   "Attempted to subtract incompatible iterators");
N#endif
N    return __x.base() - __y.base();
N}
N#else
Stemplate <class _Iter1, class _Iter2>
Sinline _LIBCPP_INLINE_VISIBILITY
Stypename __wrap_iter<_Iter1>::difference_type
Soperator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG
S{
S#if _LIBCPP_DEBUG_LEVEL >= 2
S    _LIBCPP_ASSERT(__get_const_db()->__less_than_comparable(&__x, &__y),
S                   "Attempted to subtract incompatible iterators");
S#endif
S    return __x.base() - __y.base();
S}
N#endif
N
Ntemplate <class _Iter>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N__wrap_iter<_Iter>
Noperator+(typename __wrap_iter<_Iter>::difference_type __n,
N          __wrap_iter<_Iter> __x) _NOEXCEPT_DEBUG
X          __wrap_iter<_Iter> __x) noexcept
N{
N    __x += __n;
N    return __x;
N}
N
Ntemplate <class _Iter>
Nstruct __libcpp_is_trivial_iterator
N    : public _LIBCPP_BOOL_CONSTANT(is_pointer<_Iter>::value) {};
X    : public integral_constant<bool,(is_pointer<_Iter> ::value)> {};
N    
Ntemplate <class _Iter>
Nstruct __libcpp_is_trivial_iterator<move_iterator<_Iter> >
N    : public _LIBCPP_BOOL_CONSTANT(__libcpp_is_trivial_iterator<_Iter>::value) {};
X    : public integral_constant<bool,(__libcpp_is_trivial_iterator<_Iter> ::value)> {};
N
Ntemplate <class _Iter>
Nstruct __libcpp_is_trivial_iterator<reverse_iterator<_Iter> >
N    : public _LIBCPP_BOOL_CONSTANT(__libcpp_is_trivial_iterator<_Iter>::value) {};
X    : public integral_constant<bool,(__libcpp_is_trivial_iterator<_Iter> ::value)> {};
N
Ntemplate <class _Iter>
Nstruct __libcpp_is_trivial_iterator<__wrap_iter<_Iter> >
N    : public _LIBCPP_BOOL_CONSTANT(__libcpp_is_trivial_iterator<_Iter>::value) {};
X    : public integral_constant<bool,(__libcpp_is_trivial_iterator<_Iter> ::value)> {};
N
N
Ntemplate <class _Tp, size_t _Np>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
Xinline __attribute__ ((__always_inline__)) constexpr
N_Tp*
Nbegin(_Tp (&__array)[_Np])
N{
N    return __array;
N}
N
Ntemplate <class _Tp, size_t _Np>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
Xinline __attribute__ ((__always_inline__)) constexpr
N_Tp*
Nend(_Tp (&__array)[_Np])
N{
N    return __array + _Np;
N}
N
N#if !defined(_LIBCPP_CXX03_LANG)
X#if !0L
N
Ntemplate <class _Cp>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
Xinline __attribute__ ((__always_inline__)) 
Nauto
Nbegin(_Cp& __c) -> decltype(__c.begin())
N{
N    return __c.begin();
N}
N
Ntemplate <class _Cp>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
Xinline __attribute__ ((__always_inline__)) 
Nauto
Nbegin(const _Cp& __c) -> decltype(__c.begin())
N{
N    return __c.begin();
N}
N
Ntemplate <class _Cp>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
Xinline __attribute__ ((__always_inline__)) 
Nauto
Nend(_Cp& __c) -> decltype(__c.end())
N{
N    return __c.end();
N}
N
Ntemplate <class _Cp>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
Xinline __attribute__ ((__always_inline__)) 
Nauto
Nend(const _Cp& __c) -> decltype(__c.end())
N{
N    return __c.end();
N}
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
N
Ntemplate <class _Tp, size_t _Np>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
Xinline __attribute__ ((__always_inline__)) 
Nreverse_iterator<_Tp*> rbegin(_Tp (&__array)[_Np])
N{
N    return reverse_iterator<_Tp*>(__array + _Np);
N}
N
Ntemplate <class _Tp, size_t _Np>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
Xinline __attribute__ ((__always_inline__)) 
Nreverse_iterator<_Tp*> rend(_Tp (&__array)[_Np])
N{
N    return reverse_iterator<_Tp*>(__array);
N}
N
Ntemplate <class _Ep>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
Xinline __attribute__ ((__always_inline__)) 
Nreverse_iterator<const _Ep*> rbegin(initializer_list<_Ep> __il)
N{
N    return reverse_iterator<const _Ep*>(__il.end());
N}
N
Ntemplate <class _Ep>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
Xinline __attribute__ ((__always_inline__)) 
Nreverse_iterator<const _Ep*> rend(initializer_list<_Ep> __il)
N{
N    return reverse_iterator<const _Ep*>(__il.begin());
N}
N
Ntemplate <class _Cp>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
Xinline __attribute__ ((__always_inline__)) constexpr
Nauto cbegin(const _Cp& __c) -> decltype(_VSTD::begin(__c))
Xauto cbegin(const _Cp& __c) -> decltype(std::__2::begin(__c))
N{
N    return _VSTD::begin(__c);
X    return std::__2::begin(__c);
N}
N
Ntemplate <class _Cp>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
Xinline __attribute__ ((__always_inline__)) constexpr
Nauto cend(const _Cp& __c) -> decltype(_VSTD::end(__c))
Xauto cend(const _Cp& __c) -> decltype(std::__2::end(__c))
N{
N    return _VSTD::end(__c);
X    return std::__2::end(__c);
N}
N
Ntemplate <class _Cp>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
Xinline __attribute__ ((__always_inline__)) 
Nauto rbegin(_Cp& __c) -> decltype(__c.rbegin())
N{
N    return __c.rbegin();
N}
N
Ntemplate <class _Cp>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
Xinline __attribute__ ((__always_inline__)) 
Nauto rbegin(const _Cp& __c) -> decltype(__c.rbegin())
N{
N    return __c.rbegin();
N}
N
Ntemplate <class _Cp>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
Xinline __attribute__ ((__always_inline__)) 
Nauto rend(_Cp& __c) -> decltype(__c.rend())
N{
N    return __c.rend();
N}
N
Ntemplate <class _Cp>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
Xinline __attribute__ ((__always_inline__)) 
Nauto rend(const _Cp& __c) -> decltype(__c.rend())
N{
N    return __c.rend();
N}
N
Ntemplate <class _Cp>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
Xinline __attribute__ ((__always_inline__)) 
Nauto crbegin(const _Cp& __c) -> decltype(_VSTD::rbegin(__c))
Xauto crbegin(const _Cp& __c) -> decltype(std::__2::rbegin(__c))
N{
N    return _VSTD::rbegin(__c);
X    return std::__2::rbegin(__c);
N}
N
Ntemplate <class _Cp>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
Xinline __attribute__ ((__always_inline__)) 
Nauto crend(const _Cp& __c) -> decltype(_VSTD::rend(__c))
Xauto crend(const _Cp& __c) -> decltype(std::__2::rend(__c))
N{
N    return _VSTD::rend(__c);
X    return std::__2::rend(__c);
N}
N
N#endif
N
N
N#else  // defined(_LIBCPP_CXX03_LANG)
S
Stemplate <class _Cp>
Sinline _LIBCPP_INLINE_VISIBILITY
Stypename _Cp::iterator
Sbegin(_Cp& __c)
S{
S    return __c.begin();
S}
S
Stemplate <class _Cp>
Sinline _LIBCPP_INLINE_VISIBILITY
Stypename _Cp::const_iterator
Sbegin(const _Cp& __c)
S{
S    return __c.begin();
S}
S
Stemplate <class _Cp>
Sinline _LIBCPP_INLINE_VISIBILITY
Stypename _Cp::iterator
Send(_Cp& __c)
S{
S    return __c.end();
S}
S
Stemplate <class _Cp>
Sinline _LIBCPP_INLINE_VISIBILITY
Stypename _Cp::const_iterator
Send(const _Cp& __c)
S{
S    return __c.end();
S}
S
N#endif  // !defined(_LIBCPP_CXX03_LANG)
N
N#if _LIBCPP_STD_VER > 14
X#if 14 > 14
Stemplate <class _Cont>
Sconstexpr auto size(const _Cont& __c) -> decltype(__c.size()) { return __c.size(); }
S
Stemplate <class _Tp, size_t _Sz>
Sconstexpr size_t size(const _Tp (&)[_Sz]) noexcept { return _Sz; }
S
Stemplate <class _Cont>
Sconstexpr auto empty(const _Cont& __c) -> decltype(__c.empty()) { return __c.empty(); }
S
Stemplate <class _Tp, size_t _Sz>
Sconstexpr bool empty(const _Tp (&)[_Sz]) noexcept { return false; }
S
Stemplate <class _Ep>
Sconstexpr bool empty(initializer_list<_Ep> __il) noexcept { return __il.size() == 0; }
S
Stemplate <class _Cont> constexpr
Sauto data(_Cont& __c) -> decltype(__c.data()) { return __c.data(); }
S
Stemplate <class _Cont> constexpr
Sauto data(const _Cont& __c) -> decltype(__c.data()) { return __c.data(); }
S
Stemplate <class _Tp, size_t _Sz>
Sconstexpr _Tp* data(_Tp (&__array)[_Sz]) noexcept { return __array; }
S
Stemplate <class _Ep>
Sconstexpr const _Ep* data(initializer_list<_Ep> __il) noexcept { return __il.begin(); }
N#endif
N
N
N_LIBCPP_END_NAMESPACE_STD
X} }
N
N#endif  // _LIBCPP_ITERATOR
L 651 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/memory" 2
N#include <__functional_base>
N#include <iosfwd>
N#include <tuple>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/tuple" 1
N// -*- C++ -*-
N//===--------------------------- tuple ------------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is distributed under the University of Illinois Open Source
N// License. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP_TUPLE
N#define _LIBCPP_TUPLE
N
N/*
N    tuple synopsis
N
Nnamespace std
N{
N
Ntemplate <class... T>
Nclass tuple {
Npublic:
N    constexpr tuple();
N    explicit tuple(const T&...);  // constexpr in C++14
N    template <class... U>
N        explicit tuple(U&&...);  // constexpr in C++14
N    tuple(const tuple&) = default;
N    tuple(tuple&&) = default;
N    template <class... U>
N        tuple(const tuple<U...>&);  // constexpr in C++14
N    template <class... U>
N        tuple(tuple<U...>&&);  // constexpr in C++14
N    template <class U1, class U2>
N        tuple(const pair<U1, U2>&); // iff sizeof...(T) == 2 // constexpr in C++14
N    template <class U1, class U2>
N        tuple(pair<U1, U2>&&); // iff sizeof...(T) == 2  // constexpr in C++14
N
N    // allocator-extended constructors
N    template <class Alloc>
N        tuple(allocator_arg_t, const Alloc& a);
N    template <class Alloc>
N        tuple(allocator_arg_t, const Alloc& a, const T&...);
N    template <class Alloc, class... U>
N        tuple(allocator_arg_t, const Alloc& a, U&&...);
N    template <class Alloc>
N        tuple(allocator_arg_t, const Alloc& a, const tuple&);
N    template <class Alloc>
N        tuple(allocator_arg_t, const Alloc& a, tuple&&);
N    template <class Alloc, class... U>
N        tuple(allocator_arg_t, const Alloc& a, const tuple<U...>&);
N    template <class Alloc, class... U>
N        tuple(allocator_arg_t, const Alloc& a, tuple<U...>&&);
N    template <class Alloc, class U1, class U2>
N        tuple(allocator_arg_t, const Alloc& a, const pair<U1, U2>&);
N    template <class Alloc, class U1, class U2>
N        tuple(allocator_arg_t, const Alloc& a, pair<U1, U2>&&);
N
N    tuple& operator=(const tuple&);
N    tuple&
N        operator=(tuple&&) noexcept(AND(is_nothrow_move_assignable<T>::value ...));
N    template <class... U>
N        tuple& operator=(const tuple<U...>&);
N    template <class... U>
N        tuple& operator=(tuple<U...>&&);
N    template <class U1, class U2>
N        tuple& operator=(const pair<U1, U2>&); // iff sizeof...(T) == 2
N    template <class U1, class U2>
N        tuple& operator=(pair<U1, U2>&&); //iffsizeof...(T) == 2
N
N    void swap(tuple&) noexcept(AND(swap(declval<T&>(), declval<T&>())...));
N};
N
Nconst unspecified ignore;
N
Ntemplate <class... T> tuple<V...>  make_tuple(T&&...); // constexpr in C++14
Ntemplate <class... T> tuple<ATypes...> forward_as_tuple(T&&...) noexcept; // constexpr in C++14
Ntemplate <class... T> tuple<T&...> tie(T&...) noexcept; // constexpr in C++14
Ntemplate <class... Tuples> tuple<CTypes...> tuple_cat(Tuples&&... tpls); // constexpr in C++14
N
N// [tuple.apply], calling a function with a tuple of arguments:
Ntemplate <class F, class Tuple>
N  constexpr decltype(auto) apply(F&& f, Tuple&& t); // C++17
Ntemplate <class T, class Tuple>
N  constexpr T make_from_tuple(Tuple&& t); // C++17
N
N// 20.4.1.4, tuple helper classes:
Ntemplate <class T> class tuple_size; // undefined
Ntemplate <class... T> class tuple_size<tuple<T...>>;
Ntemplate <class T>
N constexpr size_t tuple_size_v = tuple_size<T>::value; // C++17
Ntemplate <size_t I, class T> class tuple_element; // undefined
Ntemplate <size_t I, class... T> class tuple_element<I, tuple<T...>>;
Ntemplate <size_t I, class T>
N  using tuple_element_t = typename tuple_element <I, T>::type; // C++14
N
N// 20.4.1.5, element access:
Ntemplate <size_t I, class... T>
N    typename tuple_element<I, tuple<T...>>::type&
N    get(tuple<T...>&) noexcept; // constexpr in C++14
Ntemplate <size_t I, class... T>
N    const typename tuple_element<I, tuple<T...>>::type&
N    get(const tuple<T...>&) noexcept; // constexpr in C++14
Ntemplate <size_t I, class... T>
N    typename tuple_element<I, tuple<T...>>::type&&
N    get(tuple<T...>&&) noexcept; // constexpr in C++14
Ntemplate <size_t I, class... T>
N    const typename tuple_element<I, tuple<T...>>::type&&
N    get(const tuple<T...>&&) noexcept; // constexpr in C++14
N
Ntemplate <class T1, class... T>
N    constexpr T1& get(tuple<T...>&) noexcept;  // C++14
Ntemplate <class T1, class... T>
N    constexpr const T1& get(const tuple<T...>&) noexcept;   // C++14
Ntemplate <class T1, class... T>
N    constexpr T1&& get(tuple<T...>&&) noexcept;   // C++14
Ntemplate <class T1, class... T>
N    constexpr const T1&& get(const tuple<T...>&&) noexcept;   // C++14
N
N// 20.4.1.6, relational operators:
Ntemplate<class... T, class... U> bool operator==(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14
Ntemplate<class... T, class... U> bool operator<(const tuple<T...>&, const tuple<U...>&);  // constexpr in C++14
Ntemplate<class... T, class... U> bool operator!=(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14
Ntemplate<class... T, class... U> bool operator>(const tuple<T...>&, const tuple<U...>&);  // constexpr in C++14
Ntemplate<class... T, class... U> bool operator<=(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14
Ntemplate<class... T, class... U> bool operator>=(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14
N
Ntemplate <class... Types, class Alloc>
N  struct uses_allocator<tuple<Types...>, Alloc>;
N
Ntemplate <class... Types>
N  void
N  swap(tuple<Types...>& x, tuple<Types...>& y) noexcept(noexcept(x.swap(y)));
N
N}  // std
N
N*/
N
N#include <__config>
N#include <__tuple>
N#include <cstddef>
N#include <type_traits>
N#include <__functional_base>
N#include <utility>
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N_LIBCPP_BEGIN_NAMESPACE_STD
Xnamespace std { inline namespace __2 {
N
N#ifndef _LIBCPP_CXX03_LANG
N
N
N// __tuple_leaf
N
Ntemplate <size_t _Ip, class _Hp,
N          bool=is_empty<_Hp>::value && !__libcpp_is_final<_Hp>::value
N         >
Nclass __tuple_leaf;
N
Ntemplate <size_t _Ip, class _Hp, bool _Ep>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid swap(__tuple_leaf<_Ip, _Hp, _Ep>& __x, __tuple_leaf<_Ip, _Hp, _Ep>& __y)
N    _NOEXCEPT_(__is_nothrow_swappable<_Hp>::value)
X    noexcept(__is_nothrow_swappable<_Hp> ::value)
N{
N    swap(__x.get(), __y.get());
N}
N
Ntemplate <size_t _Ip, class _Hp, bool>
Nclass __tuple_leaf
N{
N    _Hp __value_;
N
N    template <class _Tp>
N    static constexpr bool __can_bind_reference() {
N        using _RawTp = typename remove_reference<_Tp>::type;
N        using _RawHp = typename remove_reference<_Hp>::type;
N        using _CheckLValueArg = integral_constant<bool,
N            is_lvalue_reference<_Tp>::value
N        ||  is_same<_RawTp, reference_wrapper<_RawHp>>::value
N        ||  is_same<_RawTp, reference_wrapper<typename remove_const<_RawHp>::type>>::value
N        >;
N        return  !is_reference<_Hp>::value
N            || (is_lvalue_reference<_Hp>::value && _CheckLValueArg::value)
N            || (is_rvalue_reference<_Hp>::value && !is_lvalue_reference<_Tp>::value);
N    }
N
N    __tuple_leaf& operator=(const __tuple_leaf&);
Npublic:
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR __tuple_leaf()
X    __attribute__ ((__always_inline__)) constexpr __tuple_leaf()
N             _NOEXCEPT_(is_nothrow_default_constructible<_Hp>::value) : __value_()
X             noexcept(is_nothrow_default_constructible<_Hp> ::value) : __value_()
N       {static_assert(!is_reference<_Hp>::value,
N              "Attempted to default construct a reference element in a tuple");}
N
N    template <class _Alloc>
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        __tuple_leaf(integral_constant<int, 0>, const _Alloc&)
N            : __value_()
N        {static_assert(!is_reference<_Hp>::value,
N              "Attempted to default construct a reference element in a tuple");}
N
N    template <class _Alloc>
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a)
N            : __value_(allocator_arg_t(), __a)
N        {static_assert(!is_reference<_Hp>::value,
N              "Attempted to default construct a reference element in a tuple");}
N
N    template <class _Alloc>
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a)
N            : __value_(__a)
N        {static_assert(!is_reference<_Hp>::value,
N              "Attempted to default construct a reference element in a tuple");}
N
N    template <class _Tp,
N              class = typename enable_if<
N                  __lazy_and<
N                      __lazy_not<is_same<typename decay<_Tp>::type, __tuple_leaf>>
N                    , is_constructible<_Hp, _Tp>
N                    >::value
N                >::type
N            >
N        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
X        __attribute__ ((__always_inline__)) constexpr
N        explicit __tuple_leaf(_Tp&& __t) _NOEXCEPT_((is_nothrow_constructible<_Hp, _Tp>::value))
X        explicit __tuple_leaf(_Tp&& __t) noexcept((is_nothrow_constructible<_Hp, _Tp> ::value))
N            : __value_(_VSTD::forward<_Tp>(__t))
X            : __value_(std::__2::forward<_Tp>(__t))
N        {static_assert(__can_bind_reference<_Tp>(),
N       "Attempted to construct a reference element in a tuple with an rvalue");}
N
N    template <class _Tp, class _Alloc>
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        explicit __tuple_leaf(integral_constant<int, 0>, const _Alloc&, _Tp&& __t)
N            : __value_(_VSTD::forward<_Tp>(__t))
X            : __value_(std::__2::forward<_Tp>(__t))
N        {static_assert(__can_bind_reference<_Tp>(),
N       "Attempted to construct a reference element in a tuple with an rvalue");}
N
N    template <class _Tp, class _Alloc>
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        explicit __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a, _Tp&& __t)
N            : __value_(allocator_arg_t(), __a, _VSTD::forward<_Tp>(__t))
X            : __value_(allocator_arg_t(), __a, std::__2::forward<_Tp>(__t))
N        {static_assert(!is_reference<_Hp>::value,
N            "Attempted to uses-allocator construct a reference element in a tuple");}
N
N    template <class _Tp, class _Alloc>
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        explicit __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a, _Tp&& __t)
N            : __value_(_VSTD::forward<_Tp>(__t), __a)
X            : __value_(std::__2::forward<_Tp>(__t), __a)
N        {static_assert(!is_reference<_Hp>::value,
N           "Attempted to uses-allocator construct a reference element in a tuple");}
N
N    __tuple_leaf(const __tuple_leaf& __t) = default;
N    __tuple_leaf(__tuple_leaf&& __t) = default;
N
N    template <class _Tp>
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        __tuple_leaf&
N        operator=(_Tp&& __t) _NOEXCEPT_((is_nothrow_assignable<_Hp&, _Tp>::value))
X        operator=(_Tp&& __t) noexcept((is_nothrow_assignable<_Hp&, _Tp> ::value))
N        {
N            __value_ = _VSTD::forward<_Tp>(__t);
X            __value_ = std::__2::forward<_Tp>(__t);
N            return *this;
N        }
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    int swap(__tuple_leaf& __t) _NOEXCEPT_(__is_nothrow_swappable<__tuple_leaf>::value)
X    int swap(__tuple_leaf& __t) noexcept(__is_nothrow_swappable<__tuple_leaf> ::value)
N    {
N        _VSTD::swap(*this, __t);
X        std::__2::swap(*this, __t);
N        return 0;
N    }
N
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11       _Hp& get()       _NOEXCEPT {return __value_;}
X    __attribute__ ((__always_inline__)) constexpr       _Hp& get()       noexcept {return __value_;}
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 const _Hp& get() const _NOEXCEPT {return __value_;}
X    __attribute__ ((__always_inline__)) constexpr const _Hp& get() const noexcept {return __value_;}
N};
N
Ntemplate <size_t _Ip, class _Hp>
Nclass __tuple_leaf<_Ip, _Hp, true>
N    : private _Hp
N{
N
N    __tuple_leaf& operator=(const __tuple_leaf&);
Npublic:
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR __tuple_leaf()
X    __attribute__ ((__always_inline__)) constexpr __tuple_leaf()
N             _NOEXCEPT_(is_nothrow_default_constructible<_Hp>::value) {}
X             noexcept(is_nothrow_default_constructible<_Hp> ::value) {}
N
N    template <class _Alloc>
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        __tuple_leaf(integral_constant<int, 0>, const _Alloc&) {}
N
N    template <class _Alloc>
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a)
N            : _Hp(allocator_arg_t(), __a) {}
N
N    template <class _Alloc>
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a)
N            : _Hp(__a) {}
N
N    template <class _Tp,
N              class = typename enable_if<
N                  __lazy_and<
N                        __lazy_not<is_same<typename decay<_Tp>::type, __tuple_leaf>>
N                      , is_constructible<_Hp, _Tp>
N                    >::value
N                >::type
N            >
N        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
X        __attribute__ ((__always_inline__)) constexpr
N        explicit __tuple_leaf(_Tp&& __t) _NOEXCEPT_((is_nothrow_constructible<_Hp, _Tp>::value))
X        explicit __tuple_leaf(_Tp&& __t) noexcept((is_nothrow_constructible<_Hp, _Tp> ::value))
N            : _Hp(_VSTD::forward<_Tp>(__t)) {}
X            : _Hp(std::__2::forward<_Tp>(__t)) {}
N
N    template <class _Tp, class _Alloc>
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        explicit __tuple_leaf(integral_constant<int, 0>, const _Alloc&, _Tp&& __t)
N            : _Hp(_VSTD::forward<_Tp>(__t)) {}
X            : _Hp(std::__2::forward<_Tp>(__t)) {}
N
N    template <class _Tp, class _Alloc>
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        explicit __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a, _Tp&& __t)
N            : _Hp(allocator_arg_t(), __a, _VSTD::forward<_Tp>(__t)) {}
X            : _Hp(allocator_arg_t(), __a, std::__2::forward<_Tp>(__t)) {}
N
N    template <class _Tp, class _Alloc>
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        explicit __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a, _Tp&& __t)
N            : _Hp(_VSTD::forward<_Tp>(__t), __a) {}
X            : _Hp(std::__2::forward<_Tp>(__t), __a) {}
N
N    __tuple_leaf(__tuple_leaf const &) = default;
N    __tuple_leaf(__tuple_leaf &&) = default;
N
N    template <class _Tp>
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        __tuple_leaf&
N        operator=(_Tp&& __t) _NOEXCEPT_((is_nothrow_assignable<_Hp&, _Tp>::value))
X        operator=(_Tp&& __t) noexcept((is_nothrow_assignable<_Hp&, _Tp> ::value))
N        {
N            _Hp::operator=(_VSTD::forward<_Tp>(__t));
X            _Hp::operator=(std::__2::forward<_Tp>(__t));
N            return *this;
N        }
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    int
N    swap(__tuple_leaf& __t) _NOEXCEPT_(__is_nothrow_swappable<__tuple_leaf>::value)
X    swap(__tuple_leaf& __t) noexcept(__is_nothrow_swappable<__tuple_leaf> ::value)
N    {
N        _VSTD::swap(*this, __t);
X        std::__2::swap(*this, __t);
N        return 0;
N    }
N
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11       _Hp& get()       _NOEXCEPT {return static_cast<_Hp&>(*this);}
X    __attribute__ ((__always_inline__)) constexpr       _Hp& get()       noexcept {return static_cast<_Hp&>(*this);}
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 const _Hp& get() const _NOEXCEPT {return static_cast<const _Hp&>(*this);}
X    __attribute__ ((__always_inline__)) constexpr const _Hp& get() const noexcept {return static_cast<const _Hp&>(*this);}
N};
N
Ntemplate <class ..._Tp>
N_LIBCPP_INLINE_VISIBILITY
X__attribute__ ((__always_inline__))
Nvoid __swallow(_Tp&&...) _NOEXCEPT {}
Xvoid __swallow(_Tp&&...) noexcept {}
N
Ntemplate <class ..._Tp>
Nstruct __lazy_all : __all<_Tp::value...> {};
N
Ntemplate <class _Tp>
Nstruct __all_default_constructible;
N
Ntemplate <class ..._Tp>
Nstruct __all_default_constructible<__tuple_types<_Tp...>>
N    : __all<is_default_constructible<_Tp>::value...>
N{ };
N
N// __tuple_impl
N
Ntemplate<class _Indx, class ..._Tp> struct __tuple_impl;
N
Ntemplate<size_t ..._Indx, class ..._Tp>
Nstruct _LIBCPP_DECLSPEC_EMPTY_BASES __tuple_impl<__tuple_indices<_Indx...>, _Tp...>
Xstruct  __tuple_impl<__tuple_indices<_Indx...>, _Tp...>
N    : public __tuple_leaf<_Indx, _Tp>...
N{
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _LIBCPP_CONSTEXPR __tuple_impl()
X    constexpr __tuple_impl()
N        _NOEXCEPT_(__all<is_nothrow_default_constructible<_Tp>::value...>::value) {}
X        noexcept(__all<is_nothrow_default_constructible<_Tp> ::value ...> ::value) {}
N
N    template <size_t ..._Uf, class ..._Tf,
N              size_t ..._Ul, class ..._Tl, class ..._Up>
N        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
X        __attribute__ ((__always_inline__)) constexpr
N        explicit
N        __tuple_impl(__tuple_indices<_Uf...>, __tuple_types<_Tf...>,
N                     __tuple_indices<_Ul...>, __tuple_types<_Tl...>,
N                     _Up&&... __u)
N                     _NOEXCEPT_((__all<is_nothrow_constructible<_Tf, _Up>::value...>::value &&
N                                 __all<is_nothrow_default_constructible<_Tl>::value...>::value)) :
X                     noexcept((__all<is_nothrow_constructible<_Tf, _Up> ::value ...> ::value && __all<is_nothrow_default_constructible<_Tl> ::value ...> ::value)) :
N            __tuple_leaf<_Uf, _Tf>(_VSTD::forward<_Up>(__u))...,
X            __tuple_leaf<_Uf, _Tf>(std::__2::forward<_Up>(__u))...,
N            __tuple_leaf<_Ul, _Tl>()...
N            {}
N
N    template <class _Alloc, size_t ..._Uf, class ..._Tf,
N              size_t ..._Ul, class ..._Tl, class ..._Up>
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        explicit
N        __tuple_impl(allocator_arg_t, const _Alloc& __a,
N                     __tuple_indices<_Uf...>, __tuple_types<_Tf...>,
N                     __tuple_indices<_Ul...>, __tuple_types<_Tl...>,
N                     _Up&&... __u) :
N            __tuple_leaf<_Uf, _Tf>(__uses_alloc_ctor<_Tf, _Alloc, _Up>(), __a,
N            _VSTD::forward<_Up>(__u))...,
X            std::__2::forward<_Up>(__u))...,
N            __tuple_leaf<_Ul, _Tl>(__uses_alloc_ctor<_Tl, _Alloc>(), __a)...
N            {}
N
N    template <class _Tuple,
N              class = typename enable_if
N                      <
N                         __tuple_constructible<_Tuple, tuple<_Tp...> >::value
N                      >::type
N             >
N        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
X        __attribute__ ((__always_inline__)) constexpr
N        __tuple_impl(_Tuple&& __t) _NOEXCEPT_((__all<is_nothrow_constructible<_Tp, typename tuple_element<_Indx,
N                                       typename __make_tuple_types<_Tuple>::type>::type>::value...>::value))
X        __tuple_impl(_Tuple&& __t) noexcept((__all<is_nothrow_constructible<_Tp, typename tuple_element<_Indx, typename __make_tuple_types<_Tuple> ::type> ::type> ::value ...> ::value))
N            : __tuple_leaf<_Indx, _Tp>(_VSTD::forward<typename tuple_element<_Indx,
X            : __tuple_leaf<_Indx, _Tp>(std::__2::forward<typename tuple_element<_Indx,
N                                       typename __make_tuple_types<_Tuple>::type>::type>(_VSTD::get<_Indx>(__t)))...
X                                       typename __make_tuple_types<_Tuple>::type>::type>(std::__2::get<_Indx>(__t)))...
N            {}
N
N    template <class _Alloc, class _Tuple,
N              class = typename enable_if
N                      <
N                         __tuple_constructible<_Tuple, tuple<_Tp...> >::value
N                      >::type
N             >
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        __tuple_impl(allocator_arg_t, const _Alloc& __a, _Tuple&& __t)
N            : __tuple_leaf<_Indx, _Tp>(__uses_alloc_ctor<_Tp, _Alloc, typename tuple_element<_Indx,
N                                       typename __make_tuple_types<_Tuple>::type>::type>(), __a,
N                                       _VSTD::forward<typename tuple_element<_Indx,
X                                       std::__2::forward<typename tuple_element<_Indx,
N                                       typename __make_tuple_types<_Tuple>::type>::type>(_VSTD::get<_Indx>(__t)))...
X                                       typename __make_tuple_types<_Tuple>::type>::type>(std::__2::get<_Indx>(__t)))...
N            {}
N
N    template <class _Tuple>
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        typename enable_if
N        <
N            __tuple_assignable<_Tuple, tuple<_Tp...> >::value,
N            __tuple_impl&
N        >::type
N        operator=(_Tuple&& __t) _NOEXCEPT_((__all<is_nothrow_assignable<_Tp&, typename tuple_element<_Indx,
N                                       typename __make_tuple_types<_Tuple>::type>::type>::value...>::value))
X        operator=(_Tuple&& __t) noexcept((__all<is_nothrow_assignable<_Tp&, typename tuple_element<_Indx, typename __make_tuple_types<_Tuple> ::type> ::type> ::value ...> ::value))
N        {
N            __swallow(__tuple_leaf<_Indx, _Tp>::operator=(_VSTD::forward<typename tuple_element<_Indx,
X            __swallow(__tuple_leaf<_Indx, _Tp>::operator=(std::__2::forward<typename tuple_element<_Indx,
N                                       typename __make_tuple_types<_Tuple>::type>::type>(_VSTD::get<_Indx>(__t)))...);
X                                       typename __make_tuple_types<_Tuple>::type>::type>(std::__2::get<_Indx>(__t)))...);
N            return *this;
N        }
N
N    __tuple_impl(const __tuple_impl&) = default;
N    __tuple_impl(__tuple_impl&&) = default;
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    __tuple_impl&
N    operator=(const __tuple_impl& __t) _NOEXCEPT_((__all<is_nothrow_copy_assignable<_Tp>::value...>::value))
X    operator=(const __tuple_impl& __t) noexcept((__all<is_nothrow_copy_assignable<_Tp> ::value ...> ::value))
N    {
N        __swallow(__tuple_leaf<_Indx, _Tp>::operator=(static_cast<const __tuple_leaf<_Indx, _Tp>&>(__t).get())...);
N        return *this;
N    }
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    __tuple_impl&
N    operator=(__tuple_impl&& __t) _NOEXCEPT_((__all<is_nothrow_move_assignable<_Tp>::value...>::value))
X    operator=(__tuple_impl&& __t) noexcept((__all<is_nothrow_move_assignable<_Tp> ::value ...> ::value))
N    {
N        __swallow(__tuple_leaf<_Indx, _Tp>::operator=(_VSTD::forward<_Tp>(static_cast<__tuple_leaf<_Indx, _Tp>&>(__t).get()))...);
X        __swallow(__tuple_leaf<_Indx, _Tp>::operator=(std::__2::forward<_Tp>(static_cast<__tuple_leaf<_Indx, _Tp>&>(__t).get()))...);
N        return *this;
N    }
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    void swap(__tuple_impl& __t)
N        _NOEXCEPT_(__all<__is_nothrow_swappable<_Tp>::value...>::value)
X        noexcept(__all<__is_nothrow_swappable<_Tp> ::value ...> ::value)
N    {
N        __swallow(__tuple_leaf<_Indx, _Tp>::swap(static_cast<__tuple_leaf<_Indx, _Tp>&>(__t))...);
N    }
N};
N
N
N
Ntemplate <class ..._Tp>
Nclass _LIBCPP_TEMPLATE_VIS tuple
Xclass  tuple
N{
N    typedef __tuple_impl<typename __make_tuple_indices<sizeof...(_Tp)>::type, _Tp...> _BaseT;
N
N    _BaseT __base_;
N
N#if defined(_LIBCPP_ENABLE_TUPLE_IMPLICIT_REDUCED_ARITY_EXTENSION)
X#if 0L
S    static constexpr bool _EnableImplicitReducedArityExtension = true;
N#else
N    static constexpr bool _EnableImplicitReducedArityExtension = false;
N#endif
N
N    template <class ..._Args>
N    struct _PackExpandsToThisTuple : false_type {};
N
N    template <class _Arg>
N    struct _PackExpandsToThisTuple<_Arg>
N        : is_same<typename __uncvref<_Arg>::type, tuple> {};
N
N    template <bool _MaybeEnable, class _Dummy = void>
N    struct _CheckArgsConstructor : __check_tuple_constructor_fail {};
N
N    template <class _Dummy>
N    struct _CheckArgsConstructor<true, _Dummy>
N    {
N        template <class ..._Args>
N        static constexpr bool __enable_default() {
N            return __all<is_default_constructible<_Args>::value...>::value;
N        }
N
N        template <class ..._Args>
N        static constexpr bool __enable_explicit() {
N            return
N                __tuple_constructible<
N                    tuple<_Args...>,
N                    typename __make_tuple_types<tuple,
N                             sizeof...(_Args) < sizeof...(_Tp) ?
N                                 sizeof...(_Args) :
N                                 sizeof...(_Tp)>::type
N                >::value &&
N                !__tuple_convertible<
N                    tuple<_Args...>,
N                    typename __make_tuple_types<tuple,
N                             sizeof...(_Args) < sizeof...(_Tp) ?
N                                 sizeof...(_Args) :
N                                 sizeof...(_Tp)>::type
N                >::value &&
N                __all_default_constructible<
N                    typename __make_tuple_types<tuple, sizeof...(_Tp),
N                             sizeof...(_Args) < sizeof...(_Tp) ?
N                                 sizeof...(_Args) :
N                                 sizeof...(_Tp)>::type
N                >::value;
N        }
N
N        template <class ..._Args>
N        static constexpr bool __enable_implicit() {
N            return
N                __tuple_convertible<
N                    tuple<_Args...>,
N                    typename __make_tuple_types<tuple,
N                             sizeof...(_Args) < sizeof...(_Tp) ?
N                                 sizeof...(_Args) :
N                                 sizeof...(_Tp)>::type
N                >::value &&
N                __all_default_constructible<
N                    typename __make_tuple_types<tuple, sizeof...(_Tp),
N                             sizeof...(_Args) < sizeof...(_Tp) ?
N                                 sizeof...(_Args) :
N                                 sizeof...(_Tp)>::type
N                >::value;
N        }
N    };
N
N    template <bool _MaybeEnable,
N              bool = sizeof...(_Tp) == 1,
N              class _Dummy = void>
N    struct _CheckTupleLikeConstructor : __check_tuple_constructor_fail {};
N
N    template <class _Dummy>
N    struct _CheckTupleLikeConstructor<true, false, _Dummy>
N    {
N        template <class _Tuple>
N        static constexpr bool __enable_implicit() {
N            return __tuple_convertible<_Tuple, tuple>::value;
N        }
N
N        template <class _Tuple>
N        static constexpr bool __enable_explicit() {
N            return __tuple_constructible<_Tuple, tuple>::value
N               && !__tuple_convertible<_Tuple, tuple>::value;
N        }
N    };
N
N    template <class _Dummy>
N    struct _CheckTupleLikeConstructor<true, true, _Dummy>
N    {
N        // This trait is used to disable the tuple-like constructor when
N        // the UTypes... constructor should be selected instead.
N        // See LWG issue #2549.
N        template <class _Tuple>
N        using _PreferTupleLikeConstructor = __lazy_or<
N            // Don't attempt the two checks below if the tuple we are given
N            // has the same type as this tuple.
N            is_same<typename __uncvref<_Tuple>::type, tuple>,
N            __lazy_and<
N                __lazy_not<is_constructible<_Tp..., _Tuple>>,
N                __lazy_not<is_convertible<_Tuple, _Tp...>>
N            >
N        >;
N
N        template <class _Tuple>
N        static constexpr bool __enable_implicit() {
N            return __lazy_and<
N                __tuple_convertible<_Tuple, tuple>,
N                _PreferTupleLikeConstructor<_Tuple>
N            >::value;
N        }
N
N        template <class _Tuple>
N        static constexpr bool __enable_explicit() {
N            return __lazy_and<
N                __tuple_constructible<_Tuple, tuple>,
N                _PreferTupleLikeConstructor<_Tuple>,
N                __lazy_not<__tuple_convertible<_Tuple, tuple>>
N            >::value;
N        }
N    };
N
N    template <size_t _Jp, class ..._Up> friend _LIBCPP_CONSTEXPR_AFTER_CXX11
X    template <size_t _Jp, class ..._Up> friend constexpr
N        typename tuple_element<_Jp, tuple<_Up...> >::type& get(tuple<_Up...>&) _NOEXCEPT;
X        typename tuple_element<_Jp, tuple<_Up...> >::type& get(tuple<_Up...>&) noexcept;
N    template <size_t _Jp, class ..._Up> friend _LIBCPP_CONSTEXPR_AFTER_CXX11
X    template <size_t _Jp, class ..._Up> friend constexpr
N        const typename tuple_element<_Jp, tuple<_Up...> >::type& get(const tuple<_Up...>&) _NOEXCEPT;
X        const typename tuple_element<_Jp, tuple<_Up...> >::type& get(const tuple<_Up...>&) noexcept;
N    template <size_t _Jp, class ..._Up> friend _LIBCPP_CONSTEXPR_AFTER_CXX11
X    template <size_t _Jp, class ..._Up> friend constexpr
N        typename tuple_element<_Jp, tuple<_Up...> >::type&& get(tuple<_Up...>&&) _NOEXCEPT;
X        typename tuple_element<_Jp, tuple<_Up...> >::type&& get(tuple<_Up...>&&) noexcept;
N    template <size_t _Jp, class ..._Up> friend _LIBCPP_CONSTEXPR_AFTER_CXX11
X    template <size_t _Jp, class ..._Up> friend constexpr
N        const typename tuple_element<_Jp, tuple<_Up...> >::type&& get(const tuple<_Up...>&&) _NOEXCEPT;
X        const typename tuple_element<_Jp, tuple<_Up...> >::type&& get(const tuple<_Up...>&&) noexcept;
Npublic:
N
N    template <bool _Dummy = true, class = typename enable_if<
N        _CheckArgsConstructor<_Dummy>::template __enable_default<_Tp...>()
N    >::type>
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _LIBCPP_CONSTEXPR tuple()
X    constexpr tuple()
N        _NOEXCEPT_(__all<is_nothrow_default_constructible<_Tp>::value...>::value) {}
X        noexcept(__all<is_nothrow_default_constructible<_Tp> ::value ...> ::value) {}
N
N    tuple(tuple const&) = default;
N    tuple(tuple&&) = default;
N
N    template <class _AllocArgT, class _Alloc, bool _Dummy = true, class = typename enable_if<
N        __lazy_and<
N            is_same<allocator_arg_t, _AllocArgT>,
N            __lazy_all<__dependent_type<is_default_constructible<_Tp>, _Dummy>...>
N       >::value
N    >::type>
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    tuple(_AllocArgT, _Alloc const& __a)
N      : __base_(allocator_arg_t(), __a,
N                    __tuple_indices<>(), __tuple_types<>(),
N                    typename __make_tuple_indices<sizeof...(_Tp), 0>::type(),
N                    __tuple_types<_Tp...>()) {}
N
N    template <bool _Dummy = true,
N              typename enable_if
N                      <
N                         _CheckArgsConstructor<
N                            _Dummy
N                         >::template __enable_implicit<_Tp const&...>(),
N                         bool
N                      >::type = false
N        >
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
X    __attribute__ ((__always_inline__)) constexpr
N    tuple(const _Tp& ... __t) _NOEXCEPT_((__all<is_nothrow_copy_constructible<_Tp>::value...>::value))
X    tuple(const _Tp& ... __t) noexcept((__all<is_nothrow_copy_constructible<_Tp> ::value ...> ::value))
N        : __base_(typename __make_tuple_indices<sizeof...(_Tp)>::type(),
N                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
N                typename __make_tuple_indices<0>::type(),
N                typename __make_tuple_types<tuple, 0>::type(),
N                __t...
N               ) {}
N
N    template <bool _Dummy = true,
N              typename enable_if
N                      <
N                         _CheckArgsConstructor<
N                            _Dummy
N                         >::template __enable_explicit<_Tp const&...>(),
N                         bool
N                      >::type = false
N        >
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
X    __attribute__ ((__always_inline__)) constexpr
N    explicit tuple(const _Tp& ... __t) _NOEXCEPT_((__all<is_nothrow_copy_constructible<_Tp>::value...>::value))
X    explicit tuple(const _Tp& ... __t) noexcept((__all<is_nothrow_copy_constructible<_Tp> ::value ...> ::value))
N        : __base_(typename __make_tuple_indices<sizeof...(_Tp)>::type(),
N                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
N                typename __make_tuple_indices<0>::type(),
N                typename __make_tuple_types<tuple, 0>::type(),
N                __t...
N               ) {}
N
N    template <class _Alloc, bool _Dummy = true,
N              typename enable_if
N                      <
N                         _CheckArgsConstructor<
N                            _Dummy
N                         >::template __enable_implicit<_Tp const&...>(),
N                         bool
N                      >::type = false
N        >
N      _LIBCPP_INLINE_VISIBILITY
X      __attribute__ ((__always_inline__))
N      tuple(allocator_arg_t, const _Alloc& __a, const _Tp& ... __t)
N        : __base_(allocator_arg_t(), __a,
N                typename __make_tuple_indices<sizeof...(_Tp)>::type(),
N                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
N                typename __make_tuple_indices<0>::type(),
N                typename __make_tuple_types<tuple, 0>::type(),
N                __t...
N               ) {}
N
N    template <class _Alloc, bool _Dummy = true,
N              typename enable_if
N                      <
N                         _CheckArgsConstructor<
N                            _Dummy
N                         >::template __enable_explicit<_Tp const&...>(),
N                         bool
N                      >::type = false
N        >
N      _LIBCPP_INLINE_VISIBILITY
X      __attribute__ ((__always_inline__))
N      explicit
N      tuple(allocator_arg_t, const _Alloc& __a, const _Tp& ... __t)
N        : __base_(allocator_arg_t(), __a,
N                typename __make_tuple_indices<sizeof...(_Tp)>::type(),
N                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
N                typename __make_tuple_indices<0>::type(),
N                typename __make_tuple_types<tuple, 0>::type(),
N                __t...
N               ) {}
N
N    template <class ..._Up,
N              bool _PackIsTuple = _PackExpandsToThisTuple<_Up...>::value,
N              typename enable_if
N                      <
N                         _CheckArgsConstructor<
N                             sizeof...(_Up) == sizeof...(_Tp)
N                             && !_PackIsTuple
N                         >::template __enable_implicit<_Up...>() ||
N                        _CheckArgsConstructor<
N                            _EnableImplicitReducedArityExtension
N                            && sizeof...(_Up) < sizeof...(_Tp)
N                            && !_PackIsTuple
N                         >::template __enable_implicit<_Up...>(),
N                         bool
N                      >::type = false
N             >
N        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
X        __attribute__ ((__always_inline__)) constexpr
N        tuple(_Up&&... __u)
N            _NOEXCEPT_((
N                is_nothrow_constructible<_BaseT,
N                    typename __make_tuple_indices<sizeof...(_Up)>::type,
N                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type,
N                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type,
N                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type,
N                    _Up...
N                >::value
N            ))
X            noexcept(( is_nothrow_constructible<_BaseT, typename __make_tuple_indices<sizeof ...(_Up)> ::type, typename __make_tuple_types<tuple, sizeof ...(_Up)> ::type, typename __make_tuple_indices<sizeof ...(_Tp), sizeof ...(_Up)> ::type, typename __make_tuple_types<tuple, sizeof ...(_Tp), sizeof ...(_Up)> ::type, _Up ... > ::value ))
N            : __base_(typename __make_tuple_indices<sizeof...(_Up)>::type(),
N                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
N                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),
N                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),
N                    _VSTD::forward<_Up>(__u)...) {}
X                    std::__2::forward<_Up>(__u)...) {}
N
N    template <class ..._Up,
N              typename enable_if
N                      <
N                         _CheckArgsConstructor<
N                             sizeof...(_Up) <= sizeof...(_Tp)
N                             && !_PackExpandsToThisTuple<_Up...>::value
N                         >::template __enable_explicit<_Up...>() ||
N                         _CheckArgsConstructor<
N                            !_EnableImplicitReducedArityExtension
N                            && sizeof...(_Up) < sizeof...(_Tp)
N                            && !_PackExpandsToThisTuple<_Up...>::value
N                         >::template __enable_implicit<_Up...>(),
N                         bool
N                      >::type = false
N             >
N        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
X        __attribute__ ((__always_inline__)) constexpr
N        explicit
N        tuple(_Up&&... __u)
N            _NOEXCEPT_((
N                is_nothrow_constructible<_BaseT,
N                    typename __make_tuple_indices<sizeof...(_Up)>::type,
N                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type,
N                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type,
N                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type,
N                    _Up...
N                >::value
N            ))
X            noexcept(( is_nothrow_constructible<_BaseT, typename __make_tuple_indices<sizeof ...(_Up)> ::type, typename __make_tuple_types<tuple, sizeof ...(_Up)> ::type, typename __make_tuple_indices<sizeof ...(_Tp), sizeof ...(_Up)> ::type, typename __make_tuple_types<tuple, sizeof ...(_Tp), sizeof ...(_Up)> ::type, _Up ... > ::value ))
N            : __base_(typename __make_tuple_indices<sizeof...(_Up)>::type(),
N                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
N                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),
N                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),
N                    _VSTD::forward<_Up>(__u)...) {}
X                    std::__2::forward<_Up>(__u)...) {}
N
N    template <class _Alloc, class ..._Up,
N              typename enable_if
N                      <
N                         _CheckArgsConstructor<
N                             sizeof...(_Up) == sizeof...(_Tp) &&
N                             !_PackExpandsToThisTuple<_Up...>::value
N                         >::template __enable_implicit<_Up...>(),
N                         bool
N                      >::type = false
N             >
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        tuple(allocator_arg_t, const _Alloc& __a, _Up&&... __u)
N            : __base_(allocator_arg_t(), __a,
N                    typename __make_tuple_indices<sizeof...(_Up)>::type(),
N                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
N                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),
N                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),
N                    _VSTD::forward<_Up>(__u)...) {}
X                    std::__2::forward<_Up>(__u)...) {}
N
N    template <class _Alloc, class ..._Up,
N              typename enable_if
N                      <
N                         _CheckArgsConstructor<
N                             sizeof...(_Up) == sizeof...(_Tp) &&
N                             !_PackExpandsToThisTuple<_Up...>::value
N                         >::template __enable_explicit<_Up...>(),
N                         bool
N                      >::type = false
N             >
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        explicit
N        tuple(allocator_arg_t, const _Alloc& __a, _Up&&... __u)
N            : __base_(allocator_arg_t(), __a,
N                    typename __make_tuple_indices<sizeof...(_Up)>::type(),
N                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
N                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),
N                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),
N                    _VSTD::forward<_Up>(__u)...) {}
X                    std::__2::forward<_Up>(__u)...) {}
N
N    template <class _Tuple,
N              typename enable_if
N                      <
N                         _CheckTupleLikeConstructor<
N                             __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::value
N                             && !_PackExpandsToThisTuple<_Tuple>::value
N                         >::template __enable_implicit<_Tuple>(),
N                         bool
N                      >::type = false
N             >
N        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
X        __attribute__ ((__always_inline__)) constexpr
N        tuple(_Tuple&& __t) _NOEXCEPT_((is_nothrow_constructible<_BaseT, _Tuple>::value))
X        tuple(_Tuple&& __t) noexcept((is_nothrow_constructible<_BaseT, _Tuple> ::value))
N            : __base_(_VSTD::forward<_Tuple>(__t)) {}
X            : __base_(std::__2::forward<_Tuple>(__t)) {}
N
N    template <class _Tuple,
N              typename enable_if
N                      <
N                         _CheckTupleLikeConstructor<
N                             __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::value
N                             && !_PackExpandsToThisTuple<_Tuple>::value
N                         >::template __enable_explicit<_Tuple>(),
N                         bool
N                      >::type = false
N             >
N        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
X        __attribute__ ((__always_inline__)) constexpr
N        explicit
N        tuple(_Tuple&& __t) _NOEXCEPT_((is_nothrow_constructible<_BaseT, _Tuple>::value))
X        tuple(_Tuple&& __t) noexcept((is_nothrow_constructible<_BaseT, _Tuple> ::value))
N            : __base_(_VSTD::forward<_Tuple>(__t)) {}
X            : __base_(std::__2::forward<_Tuple>(__t)) {}
N
N    template <class _Alloc, class _Tuple,
N              typename enable_if
N                      <
N                         _CheckTupleLikeConstructor<
N                             __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::value
N                         >::template __enable_implicit<_Tuple>(),
N                         bool
N                      >::type = false
N             >
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        tuple(allocator_arg_t, const _Alloc& __a, _Tuple&& __t)
N            : __base_(allocator_arg_t(), __a, _VSTD::forward<_Tuple>(__t)) {}
X            : __base_(allocator_arg_t(), __a, std::__2::forward<_Tuple>(__t)) {}
N
N    template <class _Alloc, class _Tuple,
N              typename enable_if
N                      <
N                         _CheckTupleLikeConstructor<
N                             __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::value
N                         >::template __enable_explicit<_Tuple>(),
N                         bool
N                      >::type = false
N             >
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        explicit
N        tuple(allocator_arg_t, const _Alloc& __a, _Tuple&& __t)
N            : __base_(allocator_arg_t(), __a, _VSTD::forward<_Tuple>(__t)) {}
X            : __base_(allocator_arg_t(), __a, std::__2::forward<_Tuple>(__t)) {}
N
N    using _CanCopyAssign = __all<is_copy_assignable<_Tp>::value...>;
N    using _CanMoveAssign = __all<is_move_assignable<_Tp>::value...>;
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    tuple& operator=(typename conditional<_CanCopyAssign::value, tuple, __nat>::type const& __t)
N        _NOEXCEPT_((__all<is_nothrow_copy_assignable<_Tp>::value...>::value))
X        noexcept((__all<is_nothrow_copy_assignable<_Tp> ::value ...> ::value))
N    {
N        __base_.operator=(__t.__base_);
N        return *this;
N    }
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    tuple& operator=(typename conditional<_CanMoveAssign::value, tuple, __nat>::type&& __t)
N        _NOEXCEPT_((__all<is_nothrow_move_assignable<_Tp>::value...>::value))
X        noexcept((__all<is_nothrow_move_assignable<_Tp> ::value ...> ::value))
N    {
N        __base_.operator=(static_cast<_BaseT&&>(__t.__base_));
N        return *this;
N    }
N
N    template <class _Tuple,
N              class = typename enable_if
N                      <
N                         __tuple_assignable<_Tuple, tuple>::value
N                      >::type
N             >
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        tuple&
N        operator=(_Tuple&& __t) _NOEXCEPT_((is_nothrow_assignable<_BaseT&, _Tuple>::value))
X        operator=(_Tuple&& __t) noexcept((is_nothrow_assignable<_BaseT&, _Tuple> ::value))
N        {
N            __base_.operator=(_VSTD::forward<_Tuple>(__t));
X            __base_.operator=(std::__2::forward<_Tuple>(__t));
N            return *this;
N        }
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    void swap(tuple& __t) _NOEXCEPT_(__all<__is_nothrow_swappable<_Tp>::value...>::value)
X    void swap(tuple& __t) noexcept(__all<__is_nothrow_swappable<_Tp> ::value ...> ::value)
N        {__base_.swap(__t.__base_);}
N};
N
Ntemplate <>
Nclass _LIBCPP_TEMPLATE_VIS tuple<>
Xclass  tuple<>
N{
Npublic:
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _LIBCPP_CONSTEXPR tuple() _NOEXCEPT {}
X    constexpr tuple() noexcept {}
N    template <class _Alloc>
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N        tuple(allocator_arg_t, const _Alloc&) _NOEXCEPT {}
X        tuple(allocator_arg_t, const _Alloc&) noexcept {}
N    template <class _Alloc>
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N        tuple(allocator_arg_t, const _Alloc&, const tuple&) _NOEXCEPT {}
X        tuple(allocator_arg_t, const _Alloc&, const tuple&) noexcept {}
N    template <class _Up>
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N        tuple(array<_Up, 0>) _NOEXCEPT {}
X        tuple(array<_Up, 0>) noexcept {}
N    template <class _Alloc, class _Up>
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N        tuple(allocator_arg_t, const _Alloc&, array<_Up, 0>) _NOEXCEPT {}
X        tuple(allocator_arg_t, const _Alloc&, array<_Up, 0>) noexcept {}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    void swap(tuple&) _NOEXCEPT {}
X    void swap(tuple&) noexcept {}
N};
N
N#ifndef _LIBCPP_HAS_NO_DEDUCTION_GUIDES
S// NOTE: These are not yet standardized, but are required to simulate the
S// implicit deduction guide that should be generated had libc++ declared the
S// tuple-like constructors "correctly"
Stemplate <class _Alloc, class ..._Args>
Stuple(allocator_arg_t, const _Alloc&, tuple<_Args...> const&) -> tuple<_Args...>;
Stemplate <class _Alloc, class ..._Args>
Stuple(allocator_arg_t, const _Alloc&, tuple<_Args...>&&) -> tuple<_Args...>;
N#endif
N
Ntemplate <class ..._Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename enable_if
N<
N    __all<__is_swappable<_Tp>::value...>::value,
N    void
N>::type
Nswap(tuple<_Tp...>& __t, tuple<_Tp...>& __u)
N                 _NOEXCEPT_(__all<__is_nothrow_swappable<_Tp>::value...>::value)
X                 noexcept(__all<__is_nothrow_swappable<_Tp> ::value ...> ::value)
N    {__t.swap(__u);}
N
N// get
N
Ntemplate <size_t _Ip, class ..._Tp>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
Xinline __attribute__ ((__always_inline__)) constexpr
Ntypename tuple_element<_Ip, tuple<_Tp...> >::type&
Nget(tuple<_Tp...>& __t) _NOEXCEPT
Xget(tuple<_Tp...>& __t) noexcept
N{
N    typedef typename tuple_element<_Ip, tuple<_Tp...> >::type type;
N    return static_cast<__tuple_leaf<_Ip, type>&>(__t.__base_).get();
N}
N
Ntemplate <size_t _Ip, class ..._Tp>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
Xinline __attribute__ ((__always_inline__)) constexpr
Nconst typename tuple_element<_Ip, tuple<_Tp...> >::type&
Nget(const tuple<_Tp...>& __t) _NOEXCEPT
Xget(const tuple<_Tp...>& __t) noexcept
N{
N    typedef typename tuple_element<_Ip, tuple<_Tp...> >::type type;
N    return static_cast<const __tuple_leaf<_Ip, type>&>(__t.__base_).get();
N}
N
Ntemplate <size_t _Ip, class ..._Tp>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
Xinline __attribute__ ((__always_inline__)) constexpr
Ntypename tuple_element<_Ip, tuple<_Tp...> >::type&&
Nget(tuple<_Tp...>&& __t) _NOEXCEPT
Xget(tuple<_Tp...>&& __t) noexcept
N{
N    typedef typename tuple_element<_Ip, tuple<_Tp...> >::type type;
N    return static_cast<type&&>(
N             static_cast<__tuple_leaf<_Ip, type>&&>(__t.__base_).get());
N}
N
Ntemplate <size_t _Ip, class ..._Tp>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
Xinline __attribute__ ((__always_inline__)) constexpr
Nconst typename tuple_element<_Ip, tuple<_Tp...> >::type&&
Nget(const tuple<_Tp...>&& __t) _NOEXCEPT
Xget(const tuple<_Tp...>&& __t) noexcept
N{
N    typedef typename tuple_element<_Ip, tuple<_Tp...> >::type type;
N    return static_cast<const type&&>(
N             static_cast<const __tuple_leaf<_Ip, type>&&>(__t.__base_).get());
N}
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
N
Nnamespace __find_detail {
N
Nstatic constexpr size_t __not_found = (size_t)-1;
Nstatic constexpr size_t __ambiguous = __not_found - 1;
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nconstexpr size_t __find_idx_return(size_t __curr_i, size_t __res, bool __matches) {
N    return !__matches ? __res :
N        (__res == __not_found ? __curr_i : __ambiguous);
N}
N
Ntemplate <size_t _Nx>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nconstexpr size_t __find_idx(size_t __i, const bool (&__matches)[_Nx]) {
N  return __i == _Nx ? __not_found :
N      __find_idx_return(__i, __find_idx(__i + 1, __matches), __matches[__i]);
N}
N
Ntemplate <class _T1, class ..._Args>
Nstruct __find_exactly_one_checked {
N  static constexpr bool __matches[] = {is_same<_T1, _Args>::value...};
N    static constexpr size_t value = __find_detail::__find_idx(0, __matches);
N    static_assert (value != __not_found, "type not found in type list" );
N    static_assert(value != __ambiguous,"type occurs more than once in type list");
N};
N
Ntemplate <class _T1>
Nstruct __find_exactly_one_checked<_T1> {
N    static_assert(!is_same<_T1, _T1>::value, "type not in empty type list");
N};
N
N} // namespace __find_detail;
N
Ntemplate <typename _T1, typename... _Args>
Nstruct __find_exactly_one_t
N    : public __find_detail::__find_exactly_one_checked<_T1, _Args...> {
N};
N
Ntemplate <class _T1, class... _Args>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nconstexpr _T1& get(tuple<_Args...>& __tup) noexcept
N{
N    return _VSTD::get<__find_exactly_one_t<_T1, _Args...>::value>(__tup);
X    return std::__2::get<__find_exactly_one_t<_T1, _Args...>::value>(__tup);
N}
N
Ntemplate <class _T1, class... _Args>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nconstexpr _T1 const& get(tuple<_Args...> const& __tup) noexcept
N{
N    return _VSTD::get<__find_exactly_one_t<_T1, _Args...>::value>(__tup);
X    return std::__2::get<__find_exactly_one_t<_T1, _Args...>::value>(__tup);
N}
N
Ntemplate <class _T1, class... _Args>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nconstexpr _T1&& get(tuple<_Args...>&& __tup) noexcept
N{
N    return _VSTD::get<__find_exactly_one_t<_T1, _Args...>::value>(_VSTD::move(__tup));
X    return std::__2::get<__find_exactly_one_t<_T1, _Args...>::value>(std::__2::move(__tup));
N}
N
Ntemplate <class _T1, class... _Args>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nconstexpr _T1 const&& get(tuple<_Args...> const&& __tup) noexcept
N{
N    return _VSTD::get<__find_exactly_one_t<_T1, _Args...>::value>(_VSTD::move(__tup));
X    return std::__2::get<__find_exactly_one_t<_T1, _Args...>::value>(std::__2::move(__tup));
N}
N
N#endif
N
N// tie
N
Ntemplate <class ..._Tp>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
Xinline __attribute__ ((__always_inline__)) constexpr
Ntuple<_Tp&...>
Ntie(_Tp&... __t) _NOEXCEPT
Xtie(_Tp&... __t) noexcept
N{
N    return tuple<_Tp&...>(__t...);
N}
N
Ntemplate <class _Up>
Nstruct __ignore_t
N{
N    template <class _Tp>
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
X    __attribute__ ((__always_inline__)) constexpr
N    const __ignore_t& operator=(_Tp&&) const {return *this;}
N};
N
Nnamespace {
N  constexpr __ignore_t<unsigned char> ignore = __ignore_t<unsigned char>();
N}
N
Ntemplate <class _Tp>
Nstruct __make_tuple_return_impl
N{
N    typedef _Tp type;
N};
N
Ntemplate <class _Tp>
Nstruct __make_tuple_return_impl<reference_wrapper<_Tp> >
N{
N    typedef _Tp& type;
N};
N
Ntemplate <class _Tp>
Nstruct __make_tuple_return
N{
N    typedef typename __make_tuple_return_impl<typename decay<_Tp>::type>::type type;
N};
N
Ntemplate <class... _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
Xinline __attribute__ ((__always_inline__)) constexpr
Ntuple<typename __make_tuple_return<_Tp>::type...>
Nmake_tuple(_Tp&&... __t)
N{
N    return tuple<typename __make_tuple_return<_Tp>::type...>(_VSTD::forward<_Tp>(__t)...);
X    return tuple<typename __make_tuple_return<_Tp>::type...>(std::__2::forward<_Tp>(__t)...);
N}
N
Ntemplate <class... _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
Xinline __attribute__ ((__always_inline__)) constexpr
Ntuple<_Tp&&...>
Nforward_as_tuple(_Tp&&... __t) _NOEXCEPT
Xforward_as_tuple(_Tp&&... __t) noexcept
N{
N    return tuple<_Tp&&...>(_VSTD::forward<_Tp>(__t)...);
X    return tuple<_Tp&&...>(std::__2::forward<_Tp>(__t)...);
N}
N
Ntemplate <size_t _Ip>
Nstruct __tuple_equal
N{
N    template <class _Tp, class _Up>
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
X    __attribute__ ((__always_inline__)) constexpr
N    bool operator()(const _Tp& __x, const _Up& __y)
N    {
N        return __tuple_equal<_Ip - 1>()(__x, __y) && _VSTD::get<_Ip-1>(__x) == _VSTD::get<_Ip-1>(__y);
X        return __tuple_equal<_Ip - 1>()(__x, __y) && std::__2::get<_Ip-1>(__x) == std::__2::get<_Ip-1>(__y);
N    }
N};
N
Ntemplate <>
Nstruct __tuple_equal<0>
N{
N    template <class _Tp, class _Up>
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
X    __attribute__ ((__always_inline__)) constexpr
N    bool operator()(const _Tp&, const _Up&)
N    {
N        return true;
N    }
N};
N
Ntemplate <class ..._Tp, class ..._Up>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
Xinline __attribute__ ((__always_inline__)) constexpr
Nbool
Noperator==(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
N{
N    return __tuple_equal<sizeof...(_Tp)>()(__x, __y);
N}
N
Ntemplate <class ..._Tp, class ..._Up>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
Xinline __attribute__ ((__always_inline__)) constexpr
Nbool
Noperator!=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
N{
N    return !(__x == __y);
N}
N
Ntemplate <size_t _Ip>
Nstruct __tuple_less
N{
N    template <class _Tp, class _Up>
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
X    __attribute__ ((__always_inline__)) constexpr
N    bool operator()(const _Tp& __x, const _Up& __y)
N    {
N        const size_t __idx = tuple_size<_Tp>::value - _Ip;
N        if (_VSTD::get<__idx>(__x) < _VSTD::get<__idx>(__y))
X        if (std::__2::get<__idx>(__x) < std::__2::get<__idx>(__y))
N            return true;
N        if (_VSTD::get<__idx>(__y) < _VSTD::get<__idx>(__x))
X        if (std::__2::get<__idx>(__y) < std::__2::get<__idx>(__x))
N            return false;
N        return __tuple_less<_Ip-1>()(__x, __y);
N    }
N};
N
Ntemplate <>
Nstruct __tuple_less<0>
N{
N    template <class _Tp, class _Up>
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
X    __attribute__ ((__always_inline__)) constexpr
N    bool operator()(const _Tp&, const _Up&)
N    {
N        return false;
N    }
N};
N
Ntemplate <class ..._Tp, class ..._Up>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
Xinline __attribute__ ((__always_inline__)) constexpr
Nbool
Noperator<(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
N{
N    return __tuple_less<sizeof...(_Tp)>()(__x, __y);
N}
N
Ntemplate <class ..._Tp, class ..._Up>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
Xinline __attribute__ ((__always_inline__)) constexpr
Nbool
Noperator>(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
N{
N    return __y < __x;
N}
N
Ntemplate <class ..._Tp, class ..._Up>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
Xinline __attribute__ ((__always_inline__)) constexpr
Nbool
Noperator>=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
N{
N    return !(__x < __y);
N}
N
Ntemplate <class ..._Tp, class ..._Up>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
Xinline __attribute__ ((__always_inline__)) constexpr
Nbool
Noperator<=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
N{
N    return !(__y < __x);
N}
N
N// tuple_cat
N
Ntemplate <class _Tp, class _Up> struct __tuple_cat_type;
N
Ntemplate <class ..._Ttypes, class ..._Utypes>
Nstruct __tuple_cat_type<tuple<_Ttypes...>, __tuple_types<_Utypes...> >
N{
N    typedef tuple<_Ttypes..., _Utypes...> type;
N};
N
Ntemplate <class _ResultTuple, bool _Is_Tuple0TupleLike, class ..._Tuples>
Nstruct __tuple_cat_return_1
N{
N};
N
Ntemplate <class ..._Types, class _Tuple0>
Nstruct __tuple_cat_return_1<tuple<_Types...>, true, _Tuple0>
N{
N    typedef typename __tuple_cat_type<tuple<_Types...>,
N            typename __make_tuple_types<typename remove_reference<_Tuple0>::type>::type>::type
N                                                                           type;
N};
N
Ntemplate <class ..._Types, class _Tuple0, class _Tuple1, class ..._Tuples>
Nstruct __tuple_cat_return_1<tuple<_Types...>, true, _Tuple0, _Tuple1, _Tuples...>
N    : public __tuple_cat_return_1<
N                 typename __tuple_cat_type<
N                     tuple<_Types...>,
N                     typename __make_tuple_types<typename remove_reference<_Tuple0>::type>::type
N                 >::type,
N                 __tuple_like<typename remove_reference<_Tuple1>::type>::value,
N                 _Tuple1, _Tuples...>
N{
N};
N
Ntemplate <class ..._Tuples> struct __tuple_cat_return;
N
Ntemplate <class _Tuple0, class ..._Tuples>
Nstruct __tuple_cat_return<_Tuple0, _Tuples...>
N    : public __tuple_cat_return_1<tuple<>,
N         __tuple_like<typename remove_reference<_Tuple0>::type>::value, _Tuple0,
N                                                                     _Tuples...>
N{
N};
N
Ntemplate <>
Nstruct __tuple_cat_return<>
N{
N    typedef tuple<> type;
N};
N
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
Xinline __attribute__ ((__always_inline__)) constexpr
Ntuple<>
Ntuple_cat()
N{
N    return tuple<>();
N}
N
Ntemplate <class _Rp, class _Indices, class _Tuple0, class ..._Tuples>
Nstruct __tuple_cat_return_ref_imp;
N
Ntemplate <class ..._Types, size_t ..._I0, class _Tuple0>
Nstruct __tuple_cat_return_ref_imp<tuple<_Types...>, __tuple_indices<_I0...>, _Tuple0>
N{
N    typedef typename remove_reference<_Tuple0>::type _T0;
N    typedef tuple<_Types..., typename __apply_cv<_Tuple0,
N                          typename tuple_element<_I0, _T0>::type>::type&&...> type;
N};
N
Ntemplate <class ..._Types, size_t ..._I0, class _Tuple0, class _Tuple1, class ..._Tuples>
Nstruct __tuple_cat_return_ref_imp<tuple<_Types...>, __tuple_indices<_I0...>,
N                                  _Tuple0, _Tuple1, _Tuples...>
N    : public __tuple_cat_return_ref_imp<
N         tuple<_Types..., typename __apply_cv<_Tuple0,
N               typename tuple_element<_I0,
N                  typename remove_reference<_Tuple0>::type>::type>::type&&...>,
N         typename __make_tuple_indices<tuple_size<typename
N                                 remove_reference<_Tuple1>::type>::value>::type,
N         _Tuple1, _Tuples...>
N{
N};
N
Ntemplate <class _Tuple0, class ..._Tuples>
Nstruct __tuple_cat_return_ref
N    : public __tuple_cat_return_ref_imp<tuple<>,
N               typename __make_tuple_indices<
N                        tuple_size<typename remove_reference<_Tuple0>::type>::value
N               >::type, _Tuple0, _Tuples...>
N{
N};
N
Ntemplate <class _Types, class _I0, class _J0>
Nstruct __tuple_cat;
N
Ntemplate <class ..._Types, size_t ..._I0, size_t ..._J0>
Nstruct __tuple_cat<tuple<_Types...>, __tuple_indices<_I0...>, __tuple_indices<_J0...> >
N{
N    template <class _Tuple0>
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
X    __attribute__ ((__always_inline__)) constexpr
N    typename __tuple_cat_return_ref<tuple<_Types...>&&, _Tuple0&&>::type
N    operator()(tuple<_Types...> __t, _Tuple0&& __t0)
N    {
N        return forward_as_tuple(_VSTD::forward<_Types>(_VSTD::get<_I0>(__t))...,
X        return forward_as_tuple(std::__2::forward<_Types>(std::__2::get<_I0>(__t))...,
N                                      _VSTD::get<_J0>(_VSTD::forward<_Tuple0>(__t0))...);
X                                      std::__2::get<_J0>(std::__2::forward<_Tuple0>(__t0))...);
N    }
N
N    template <class _Tuple0, class _Tuple1, class ..._Tuples>
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
X    __attribute__ ((__always_inline__)) constexpr
N    typename __tuple_cat_return_ref<tuple<_Types...>&&, _Tuple0&&, _Tuple1&&, _Tuples&&...>::type
N    operator()(tuple<_Types...> __t, _Tuple0&& __t0, _Tuple1&& __t1, _Tuples&& ...__tpls)
N    {
N        typedef typename remove_reference<_Tuple0>::type _T0;
N        typedef typename remove_reference<_Tuple1>::type _T1;
N        return __tuple_cat<
N           tuple<_Types..., typename __apply_cv<_Tuple0, typename tuple_element<_J0, _T0>::type>::type&&...>,
N           typename __make_tuple_indices<sizeof ...(_Types) + tuple_size<_T0>::value>::type,
N           typename __make_tuple_indices<tuple_size<_T1>::value>::type>()
N                           (forward_as_tuple(
N                              _VSTD::forward<_Types>(_VSTD::get<_I0>(__t))...,
X                              std::__2::forward<_Types>(std::__2::get<_I0>(__t))...,
N                              _VSTD::get<_J0>(_VSTD::forward<_Tuple0>(__t0))...
X                              std::__2::get<_J0>(std::__2::forward<_Tuple0>(__t0))...
N                            ),
N                            _VSTD::forward<_Tuple1>(__t1),
X                            std::__2::forward<_Tuple1>(__t1),
N                            _VSTD::forward<_Tuples>(__tpls)...);
X                            std::__2::forward<_Tuples>(__tpls)...);
N    }
N};
N
Ntemplate <class _Tuple0, class... _Tuples>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
Xinline __attribute__ ((__always_inline__)) constexpr
Ntypename __tuple_cat_return<_Tuple0, _Tuples...>::type
Ntuple_cat(_Tuple0&& __t0, _Tuples&&... __tpls)
N{
N    typedef typename remove_reference<_Tuple0>::type _T0;
N    return __tuple_cat<tuple<>, __tuple_indices<>,
N                  typename __make_tuple_indices<tuple_size<_T0>::value>::type>()
N                  (tuple<>(), _VSTD::forward<_Tuple0>(__t0),
X                  (tuple<>(), std::__2::forward<_Tuple0>(__t0),
N                                            _VSTD::forward<_Tuples>(__tpls)...);
X                                            std::__2::forward<_Tuples>(__tpls)...);
N}
N
Ntemplate <class ..._Tp, class _Alloc>
Nstruct _LIBCPP_TEMPLATE_VIS uses_allocator<tuple<_Tp...>, _Alloc>
Xstruct  uses_allocator<tuple<_Tp...>, _Alloc>
N    : true_type {};
N
Ntemplate <class _T1, class _T2>
Ntemplate <class... _Args1, class... _Args2, size_t ..._I1, size_t ..._I2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Npair<_T1, _T2>::pair(piecewise_construct_t,
N                     tuple<_Args1...>& __first_args, tuple<_Args2...>& __second_args,
N                     __tuple_indices<_I1...>, __tuple_indices<_I2...>)
N    :  first(_VSTD::forward<_Args1>(_VSTD::get<_I1>( __first_args))...),
X    :  first(std::__2::forward<_Args1>(std::__2::get<_I1>( __first_args))...),
N      second(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...)
X      second(std::__2::forward<_Args2>(std::__2::get<_I2>(__second_args))...)
N{
N}
N
N#if _LIBCPP_STD_VER > 14
X#if 14 > 14
Stemplate <class _Tp>
Sconstexpr size_t tuple_size_v = tuple_size<_Tp>::value;
S
S#define _LIBCPP_NOEXCEPT_RETURN(...) noexcept(noexcept(__VA_ARGS__)) { return __VA_ARGS__; }
S
Stemplate <class _Fn, class _Tuple, size_t ..._Id>
Sinline _LIBCPP_INLINE_VISIBILITY
Sconstexpr decltype(auto) __apply_tuple_impl(_Fn && __f, _Tuple && __t,
S                                            __tuple_indices<_Id...>)
S_LIBCPP_NOEXCEPT_RETURN(
S    _VSTD::__invoke_constexpr(
S        _VSTD::forward<_Fn>(__f),
S        _VSTD::get<_Id>(_VSTD::forward<_Tuple>(__t))...)
S)
S
Stemplate <class _Fn, class _Tuple>
Sinline _LIBCPP_INLINE_VISIBILITY
Sconstexpr decltype(auto) apply(_Fn && __f, _Tuple && __t)
S_LIBCPP_NOEXCEPT_RETURN(
S    _VSTD::__apply_tuple_impl(
S        _VSTD::forward<_Fn>(__f), _VSTD::forward<_Tuple>(__t),
S        typename __make_tuple_indices<tuple_size_v<decay_t<_Tuple>>>::type{})
S)
S
Stemplate <class _Tp, class _Tuple, size_t... _Idx>
Sinline _LIBCPP_INLINE_VISIBILITY
Sconstexpr _Tp __make_from_tuple_impl(_Tuple&& __t, __tuple_indices<_Idx...>)
S_LIBCPP_NOEXCEPT_RETURN(
S    _Tp(_VSTD::get<_Idx>(_VSTD::forward<_Tuple>(__t))...)
S)
S
Stemplate <class _Tp, class _Tuple>
Sinline _LIBCPP_INLINE_VISIBILITY
Sconstexpr _Tp make_from_tuple(_Tuple&& __t)
S_LIBCPP_NOEXCEPT_RETURN(
S    _VSTD::__make_from_tuple_impl<_Tp>(_VSTD::forward<_Tuple>(__t),
S        typename __make_tuple_indices<tuple_size_v<decay_t<_Tuple>>>::type{})
S)
S
S#undef _LIBCPP_NOEXCEPT_RETURN
S
N#endif // _LIBCPP_STD_VER > 14
N
N#endif // !defined(_LIBCPP_CXX03_LANG)
N
N_LIBCPP_END_NAMESPACE_STD
X} }
N
N#endif  // _LIBCPP_TUPLE
L 654 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/memory" 2
N#include <stdexcept>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/stdexcept" 1
N// -*- C++ -*-
N//===--------------------------- stdexcept --------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is dual licensed under the MIT and the University of Illinois Open
N// Source Licenses. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP_STDEXCEPT
N#define _LIBCPP_STDEXCEPT
N
N/*
N    stdexcept synopsis
N
Nnamespace std
N{
N
Nclass logic_error;
N    class domain_error;
N    class invalid_argument;
N    class length_error;
N    class out_of_range;
Nclass runtime_error;
N    class range_error;
N    class overflow_error;
N    class underflow_error;
N
Nfor each class xxx_error:
N
Nclass xxx_error : public exception // at least indirectly
N{
Npublic:
N    explicit xxx_error(const string& what_arg);
N    explicit xxx_error(const char*   what_arg);
N
N    virtual const char* what() const noexcept // returns what_arg
N};
N
N}  // std
N
N*/
N
N#include <__config>
N#include <exception>
N#include <iosfwd>  // for string forward decl
N#ifdef _LIBCPP_NO_EXCEPTIONS
N#include <cstdlib>
N#endif
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N_LIBCPP_BEGIN_NAMESPACE_STD
Xnamespace std { inline namespace __2 {
N
Nclass _LIBCPP_HIDDEN __libcpp_refstring
Xclass  __libcpp_refstring
N{
N    const char* __imp_;
N
N    bool __uses_refcount() const;
Npublic:
N    explicit __libcpp_refstring(const char* __msg);
N    __libcpp_refstring(const __libcpp_refstring& __s) _NOEXCEPT;
X    __libcpp_refstring(const __libcpp_refstring& __s) noexcept;
N    __libcpp_refstring& operator=(const __libcpp_refstring& __s) _NOEXCEPT;
X    __libcpp_refstring& operator=(const __libcpp_refstring& __s) noexcept;
N    ~__libcpp_refstring();
N
N    const char* c_str() const _NOEXCEPT {return __imp_;}
X    const char* c_str() const noexcept {return __imp_;}
N};
N
N_LIBCPP_END_NAMESPACE_STD
X} }
N
Nnamespace std  // purposefully not using versioning namespace
N{
N
Nclass _LIBCPP_EXCEPTION_ABI logic_error
Xclass  logic_error
N    : public exception
N{
Nprivate:
N    _VSTD::__libcpp_refstring __imp_;
X    std::__2::__libcpp_refstring __imp_;
Npublic:
N    explicit logic_error(const string&);
N    explicit logic_error(const char*);
N
N    logic_error(const logic_error&) _NOEXCEPT;
X    logic_error(const logic_error&) noexcept;
N    logic_error& operator=(const logic_error&) _NOEXCEPT;
X    logic_error& operator=(const logic_error&) noexcept;
N
N    virtual ~logic_error() _NOEXCEPT;
X    virtual ~logic_error() noexcept;
N
N    virtual const char* what() const _NOEXCEPT;
X    virtual const char* what() const noexcept;
N};
N
Nclass _LIBCPP_EXCEPTION_ABI runtime_error
Xclass  runtime_error
N    : public exception
N{
Nprivate:
N    _VSTD::__libcpp_refstring __imp_;
X    std::__2::__libcpp_refstring __imp_;
Npublic:
N    explicit runtime_error(const string&);
N    explicit runtime_error(const char*);
N
N    runtime_error(const runtime_error&) _NOEXCEPT;
X    runtime_error(const runtime_error&) noexcept;
N    runtime_error& operator=(const runtime_error&) _NOEXCEPT;
X    runtime_error& operator=(const runtime_error&) noexcept;
N
N    virtual ~runtime_error() _NOEXCEPT;
X    virtual ~runtime_error() noexcept;
N
N    virtual const char* what() const _NOEXCEPT;
X    virtual const char* what() const noexcept;
N};
N
Nclass _LIBCPP_EXCEPTION_ABI domain_error
Xclass  domain_error
N    : public logic_error
N{
Npublic:
N    _LIBCPP_INLINE_VISIBILITY explicit domain_error(const string& __s) : logic_error(__s) {}
X    __attribute__ ((__always_inline__)) explicit domain_error(const string& __s) : logic_error(__s) {}
N    _LIBCPP_INLINE_VISIBILITY explicit domain_error(const char* __s)   : logic_error(__s) {}
X    __attribute__ ((__always_inline__)) explicit domain_error(const char* __s)   : logic_error(__s) {}
N
N    virtual ~domain_error() _NOEXCEPT;
X    virtual ~domain_error() noexcept;
N};
N
Nclass _LIBCPP_EXCEPTION_ABI invalid_argument
Xclass  invalid_argument
N    : public logic_error
N{
Npublic:
N    _LIBCPP_INLINE_VISIBILITY explicit invalid_argument(const string& __s) : logic_error(__s) {}
X    __attribute__ ((__always_inline__)) explicit invalid_argument(const string& __s) : logic_error(__s) {}
N    _LIBCPP_INLINE_VISIBILITY explicit invalid_argument(const char* __s)   : logic_error(__s) {}
X    __attribute__ ((__always_inline__)) explicit invalid_argument(const char* __s)   : logic_error(__s) {}
N
N    virtual ~invalid_argument() _NOEXCEPT;
X    virtual ~invalid_argument() noexcept;
N};
N
Nclass _LIBCPP_EXCEPTION_ABI length_error
Xclass  length_error
N    : public logic_error
N{
Npublic:
N    _LIBCPP_INLINE_VISIBILITY explicit length_error(const string& __s) : logic_error(__s) {}
X    __attribute__ ((__always_inline__)) explicit length_error(const string& __s) : logic_error(__s) {}
N    _LIBCPP_INLINE_VISIBILITY explicit length_error(const char* __s)   : logic_error(__s) {}
X    __attribute__ ((__always_inline__)) explicit length_error(const char* __s)   : logic_error(__s) {}
N
N    virtual ~length_error() _NOEXCEPT;
X    virtual ~length_error() noexcept;
N};
N
Nclass _LIBCPP_EXCEPTION_ABI out_of_range
Xclass  out_of_range
N    : public logic_error
N{
Npublic:
N    _LIBCPP_INLINE_VISIBILITY explicit out_of_range(const string& __s) : logic_error(__s) {}
X    __attribute__ ((__always_inline__)) explicit out_of_range(const string& __s) : logic_error(__s) {}
N    _LIBCPP_INLINE_VISIBILITY explicit out_of_range(const char* __s)   : logic_error(__s) {}
X    __attribute__ ((__always_inline__)) explicit out_of_range(const char* __s)   : logic_error(__s) {}
N
N    virtual ~out_of_range() _NOEXCEPT;
X    virtual ~out_of_range() noexcept;
N};
N
Nclass _LIBCPP_EXCEPTION_ABI range_error
Xclass  range_error
N    : public runtime_error
N{
Npublic:
N    _LIBCPP_INLINE_VISIBILITY explicit range_error(const string& __s) : runtime_error(__s) {}
X    __attribute__ ((__always_inline__)) explicit range_error(const string& __s) : runtime_error(__s) {}
N    _LIBCPP_INLINE_VISIBILITY explicit range_error(const char* __s)   : runtime_error(__s) {}
X    __attribute__ ((__always_inline__)) explicit range_error(const char* __s)   : runtime_error(__s) {}
N
N    virtual ~range_error() _NOEXCEPT;
X    virtual ~range_error() noexcept;
N};
N
Nclass _LIBCPP_EXCEPTION_ABI overflow_error
Xclass  overflow_error
N    : public runtime_error
N{
Npublic:
N    _LIBCPP_INLINE_VISIBILITY explicit overflow_error(const string& __s) : runtime_error(__s) {}
X    __attribute__ ((__always_inline__)) explicit overflow_error(const string& __s) : runtime_error(__s) {}
N    _LIBCPP_INLINE_VISIBILITY explicit overflow_error(const char* __s)   : runtime_error(__s) {}
X    __attribute__ ((__always_inline__)) explicit overflow_error(const char* __s)   : runtime_error(__s) {}
N
N    virtual ~overflow_error() _NOEXCEPT;
X    virtual ~overflow_error() noexcept;
N};
N
Nclass _LIBCPP_EXCEPTION_ABI underflow_error
Xclass  underflow_error
N    : public runtime_error
N{
Npublic:
N    _LIBCPP_INLINE_VISIBILITY explicit underflow_error(const string& __s) : runtime_error(__s) {}
X    __attribute__ ((__always_inline__)) explicit underflow_error(const string& __s) : runtime_error(__s) {}
N    _LIBCPP_INLINE_VISIBILITY explicit underflow_error(const char* __s)   : runtime_error(__s) {}
X    __attribute__ ((__always_inline__)) explicit underflow_error(const char* __s)   : runtime_error(__s) {}
N
N    virtual ~underflow_error() _NOEXCEPT;
X    virtual ~underflow_error() noexcept;
N};
N
N}  // std
N
N_LIBCPP_BEGIN_NAMESPACE_STD
Xnamespace std { inline namespace __2 {
N
N// in the dylib
N_LIBCPP_NORETURN _LIBCPP_FUNC_VIS void __throw_runtime_error(const char*);
X[[noreturn]]  void __throw_runtime_error(const char*);
N
N_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE
X[[noreturn]] inline __attribute__ ((__always_inline__))
Nvoid __throw_logic_error(const char*__msg)
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    throw logic_error(__msg);
N#else
N    ((void)__msg);
N	  _VSTD::abort();
X	  std::__2::abort();
N#endif
N}
N
N_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE
X[[noreturn]] inline __attribute__ ((__always_inline__))
Nvoid __throw_domain_error(const char*__msg)
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    throw domain_error(__msg);
N#else
N    ((void)__msg);
N	  _VSTD::abort();
X	  std::__2::abort();
N#endif
N}
N
N_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE
X[[noreturn]] inline __attribute__ ((__always_inline__))
Nvoid __throw_invalid_argument(const char*__msg)
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    throw invalid_argument(__msg);
N#else
N    ((void)__msg);
N	  _VSTD::abort();
X	  std::__2::abort();
N#endif
N}
N
N_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE
X[[noreturn]] inline __attribute__ ((__always_inline__))
Nvoid __throw_length_error(const char*__msg)
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    throw length_error(__msg);
N#else
N    ((void)__msg);
N	  _VSTD::abort();
X	  std::__2::abort();
N#endif
N}
N
N_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE
X[[noreturn]] inline __attribute__ ((__always_inline__))
Nvoid __throw_out_of_range(const char*__msg)
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    throw out_of_range(__msg);
N#else
N    ((void)__msg);
N	  _VSTD::abort();
X	  std::__2::abort();
N#endif
N}
N
N_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE
X[[noreturn]] inline __attribute__ ((__always_inline__))
Nvoid __throw_range_error(const char*__msg)
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    throw range_error(__msg);
N#else
N    ((void)__msg);
N	  _VSTD::abort();
X	  std::__2::abort();
N#endif
N}
N
N_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE
X[[noreturn]] inline __attribute__ ((__always_inline__))
Nvoid __throw_overflow_error(const char*__msg)
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    throw overflow_error(__msg);
N#else
N    ((void)__msg);
N    _VSTD::abort();
X    std::__2::abort();
N#endif
N}
N
N_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE
X[[noreturn]] inline __attribute__ ((__always_inline__))
Nvoid __throw_underflow_error(const char*__msg)
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    throw underflow_error(__msg);
N#else
N    ((void)__msg);
N    _VSTD::abort();
X    std::__2::abort();
N#endif
N}
N
N_LIBCPP_END_NAMESPACE_STD
X} }
N
N#endif  // _LIBCPP_STDEXCEPT
L 655 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/memory" 2
N#include <cstring>
N#include <cassert>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/cassert" 1
N// -*- C++ -*-
N//===-------------------------- cassert -----------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is dual licensed under the MIT and the University of Illinois Open
N// Source Licenses. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N/*
N    cassert synopsis
N
NMacros:
N
N    assert
N
N*/
N
N#include <__config>
N#include <assert.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/assert.h" 1
N/*****************************************************************************/
N/* assert.h                                                                  */
N/*                                                                           */
N/* Copyright (c) 1993 Texas Instruments Incorporated                         */
N/* http://www.ti.com/                                                        */
N/*                                                                           */
N/*  Redistribution and  use in source  and binary forms, with  or without    */
N/*  modification,  are permitted provided  that the  following conditions    */
N/*  are met:                                                                 */
N/*                                                                           */
N/*     Redistributions  of source  code must  retain the  above copyright    */
N/*     notice, this list of conditions and the following disclaimer.         */
N/*                                                                           */
N/*     Redistributions in binary form  must reproduce the above copyright    */
N/*     notice, this  list of conditions  and the following  disclaimer in    */
N/*     the  documentation  and/or   other  materials  provided  with  the    */
N/*     distribution.                                                         */
N/*                                                                           */
N/*     Neither the  name of Texas Instruments Incorporated  nor the names    */
N/*     of its  contributors may  be used to  endorse or  promote products    */
N/*     derived  from   this  software  without   specific  prior  written    */
N/*     permission.                                                           */
N/*                                                                           */
N/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS    */
N/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT    */
N/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    */
N/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT    */
N/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    */
N/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT    */
N/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    */
N/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    */
N/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT    */
N/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    */
N/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     */
N/*                                                                           */
N/*****************************************************************************/
N
N#ifndef _ASSERT
N#define _ASSERT
N
N#include <_ti_config.h>
N
N#if defined(__TMS320C2000__)
X#if 0L
S#if defined(__TMS320C28XX_CLA__)
S#error "Header file <assert.h> not supported by CLA compiler"
S#endif
N#endif
N
N#ifndef __cplusplus
S#if defined(_TI_C11LIB) || __TI_STRICT_ANSI_MODE__ == 0
S#define	static_assert	_Static_assert
S#endif
N#endif
N
N#pragma diag_push
N#pragma CHECK_MISRA("-6.3") /* standard types required for standard headers */
N#pragma CHECK_MISRA("-19.4") /* macros required for implementation */
N#pragma CHECK_MISRA("-19.7") /* macros required for implementation */
N#pragma CHECK_MISRA("-19.13") /* # and ## required for implementation */
N
N#ifdef __cplusplus
Nextern "C"
N{
N#endif
N
N#if defined(__TMS320C6X__) && !defined(__C6X_MIGRATION__) && defined(__TI_EABI__)
X#if 0L && !0L && 1L
Sextern _CODE_ACCESS void __c6xabi_abort_msg(const char *msg);
S#elif defined(__C7000__)
X#elif 0L
Sextern _CODE_ACCESS void __c7xabi_abort_msg(const char *msg);
S#elif defined(__ARP32__)
X#elif 0L
Sextern _CODE_ACCESS void __arp32abi_abort_msg(const char *msg);
N#else
Nextern _CODE_ACCESS void _abort_msg(const char *msg);
Xextern  void _abort_msg(const char *msg);
N#endif
N
N#define _STR(x)  __STR(x)
N#define __STR(x) #x
N
N#if defined(NDEBUG)
X#if 0L
S#define assert(_ignore) ((void)0)
S#elif defined(NASSERT)
X#elif 0L
S#define assert(_expr)   _nassert(_expr)
N#else
N#if (defined(__clang__) && defined(__arm__)) || \
N    (defined(_AEABI_PORTABILITY_LEVEL) && _AEABI_PORTABILITY_LEVEL != 0)
X#if (0L && 0L) ||     (0L && _AEABI_PORTABILITY_LEVEL != 0)
S     extern void __aeabi_assert(const char *expr, const char *file, int line);
S     #define assert(__e) ((__e) ? (void)0 : \
S	         __aeabi_assert(#__e, __FILE__, __LINE__))
X     #define assert(__e) ((__e) ? (void)0 : 	         __aeabi_assert(#__e, __FILE__, __LINE__))
N#else
N     #define assert(_expr)   _assert((_expr) != 0,      \
N                    "Assertion failed, (" _STR(_expr) "), file " __FILE__ \
N                    ", line " _STR(__LINE__) "\n")
X     #define assert(_expr)   _assert((_expr) != 0,                          "Assertion failed, (" _STR(_expr) "), file " __FILE__                     ", line " _STR(__LINE__) "\n")
N#endif /* _AEABI_PORTABILITY_LEVEL, __clang__ */
N#endif /* NDEBUG, NASSERT */
N
N#ifdef __cplusplus
N} /* extern "C" */
N#endif /* __cplusplus */
N
N#pragma diag_pop
N
N#if defined(_AEABI_PORTABILITY_LEVEL) && _AEABI_PORTABILITY_LEVEL != 0 && \
N   !defined(_AEABI_PORTABLE)
X#if 0L && _AEABI_PORTABILITY_LEVEL != 0 &&    !0L
S#define _AEABI_PORTABLE
N#endif
N
N#endif /* _ASSERT */
L 22 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/cassert" 2
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
L 657 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/memory" 2
N#if !defined(_LIBCPP_HAS_NO_ATOMIC_HEADER)
X#if !0L
N#  include <atomic>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/atomic" 1
N// -*- C++ -*-
N//===--------------------------- atomic -----------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is distributed under the University of Illinois Open Source
N// License. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP_ATOMIC
N#define _LIBCPP_ATOMIC
N
N/*
N    atomic synopsis
N
Nnamespace std
N{
N
N// feature test macro
N
N#define __cpp_lib_atomic_is_always_lock_free // as specified by SG10
N
N// order and consistency
N
Ntypedef enum __attribute__((packed)) memory_order
N{
N    memory_order_relaxed,
N    memory_order_consume,  // load-consume
N    memory_order_acquire,  // load-acquire
N    memory_order_release,  // store-release
N    memory_order_acq_rel,  // store-release load-acquire
N    memory_order_seq_cst   // store-release load-acquire
N} memory_order;
N
Ntemplate <class T> T kill_dependency(T y) noexcept;
N
N// lock-free property
N
N#define ATOMIC_BOOL_LOCK_FREE unspecified
N#define ATOMIC_CHAR_LOCK_FREE unspecified
N#define ATOMIC_CHAR16_T_LOCK_FREE unspecified
N#define ATOMIC_CHAR32_T_LOCK_FREE unspecified
N#define ATOMIC_WCHAR_T_LOCK_FREE unspecified
N#define ATOMIC_SHORT_LOCK_FREE unspecified
N#define ATOMIC_INT_LOCK_FREE unspecified
N#define ATOMIC_LONG_LOCK_FREE unspecified
N#define ATOMIC_LLONG_LOCK_FREE unspecified
N#define ATOMIC_POINTER_LOCK_FREE unspecified
N
N// flag type and operations
N
Ntypedef struct atomic_flag
N{
N    bool test_and_set(memory_order m = memory_order_seq_cst) volatile noexcept;
N    bool test_and_set(memory_order m = memory_order_seq_cst) noexcept;
N    void clear(memory_order m = memory_order_seq_cst) volatile noexcept;
N    void clear(memory_order m = memory_order_seq_cst) noexcept;
N    atomic_flag()  noexcept = default;
N    atomic_flag(const atomic_flag&) = delete;
N    atomic_flag& operator=(const atomic_flag&) = delete;
N    atomic_flag& operator=(const atomic_flag&) volatile = delete;
N} atomic_flag;
N
Nbool
N    atomic_flag_test_and_set(volatile atomic_flag* obj) noexcept;
N
Nbool
N    atomic_flag_test_and_set(atomic_flag* obj) noexcept;
N
Nbool
N    atomic_flag_test_and_set_explicit(volatile atomic_flag* obj,
N                                      memory_order m) noexcept;
N
Nbool
N    atomic_flag_test_and_set_explicit(atomic_flag* obj, memory_order m) noexcept;
N
Nvoid
N    atomic_flag_clear(volatile atomic_flag* obj) noexcept;
N
Nvoid
N    atomic_flag_clear(atomic_flag* obj) noexcept;
N
Nvoid
N    atomic_flag_clear_explicit(volatile atomic_flag* obj, memory_order m) noexcept;
N
Nvoid
N    atomic_flag_clear_explicit(atomic_flag* obj, memory_order m) noexcept;
N
N#define ATOMIC_FLAG_INIT see below
N#define ATOMIC_VAR_INIT(value) see below
N
Ntemplate <class T>
Nstruct atomic
N{
N    static constexpr bool is_always_lock_free;
N    bool is_lock_free() const volatile noexcept;
N    bool is_lock_free() const noexcept;
N    void store(T desr, memory_order m = memory_order_seq_cst) volatile noexcept;
N    void store(T desr, memory_order m = memory_order_seq_cst) noexcept;
N    T load(memory_order m = memory_order_seq_cst) const volatile noexcept;
N    T load(memory_order m = memory_order_seq_cst) const noexcept;
N    operator T() const volatile noexcept;
N    operator T() const noexcept;
N    T exchange(T desr, memory_order m = memory_order_seq_cst) volatile noexcept;
N    T exchange(T desr, memory_order m = memory_order_seq_cst) noexcept;
N    bool compare_exchange_weak(T& expc, T desr,
N                               memory_order s, memory_order f) volatile noexcept;
N    bool compare_exchange_weak(T& expc, T desr, memory_order s, memory_order f) noexcept;
N    bool compare_exchange_strong(T& expc, T desr,
N                                 memory_order s, memory_order f) volatile noexcept;
N    bool compare_exchange_strong(T& expc, T desr,
N                                 memory_order s, memory_order f) noexcept;
N    bool compare_exchange_weak(T& expc, T desr,
N                               memory_order m = memory_order_seq_cst) volatile noexcept;
N    bool compare_exchange_weak(T& expc, T desr,
N                               memory_order m = memory_order_seq_cst) noexcept;
N    bool compare_exchange_strong(T& expc, T desr,
N                                memory_order m = memory_order_seq_cst) volatile noexcept;
N    bool compare_exchange_strong(T& expc, T desr,
N                                 memory_order m = memory_order_seq_cst) noexcept;
N
N    atomic() noexcept = default;
N    constexpr atomic(T desr) noexcept;
N    atomic(const atomic&) = delete;
N    atomic& operator=(const atomic&) = delete;
N    atomic& operator=(const atomic&) volatile = delete;
N    T operator=(T) volatile noexcept;
N    T operator=(T) noexcept;
N};
N
Ntemplate <>
Nstruct atomic<integral>
N{
N    static constexpr bool is_always_lock_free;
N    bool is_lock_free() const volatile noexcept;
N    bool is_lock_free() const noexcept;
N    void store(integral desr, memory_order m = memory_order_seq_cst) volatile noexcept;
N    void store(integral desr, memory_order m = memory_order_seq_cst) noexcept;
N    integral load(memory_order m = memory_order_seq_cst) const volatile noexcept;
N    integral load(memory_order m = memory_order_seq_cst) const noexcept;
N    operator integral() const volatile noexcept;
N    operator integral() const noexcept;
N    integral exchange(integral desr,
N                      memory_order m = memory_order_seq_cst) volatile noexcept;
N    integral exchange(integral desr, memory_order m = memory_order_seq_cst) noexcept;
N    bool compare_exchange_weak(integral& expc, integral desr,
N                               memory_order s, memory_order f) volatile noexcept;
N    bool compare_exchange_weak(integral& expc, integral desr,
N                               memory_order s, memory_order f) noexcept;
N    bool compare_exchange_strong(integral& expc, integral desr,
N                                 memory_order s, memory_order f) volatile noexcept;
N    bool compare_exchange_strong(integral& expc, integral desr,
N                                 memory_order s, memory_order f) noexcept;
N    bool compare_exchange_weak(integral& expc, integral desr,
N                               memory_order m = memory_order_seq_cst) volatile noexcept;
N    bool compare_exchange_weak(integral& expc, integral desr,
N                               memory_order m = memory_order_seq_cst) noexcept;
N    bool compare_exchange_strong(integral& expc, integral desr,
N                                memory_order m = memory_order_seq_cst) volatile noexcept;
N    bool compare_exchange_strong(integral& expc, integral desr,
N                                 memory_order m = memory_order_seq_cst) noexcept;
N
N    integral
N        fetch_add(integral op, memory_order m = memory_order_seq_cst) volatile noexcept;
N    integral fetch_add(integral op, memory_order m = memory_order_seq_cst) noexcept;
N    integral
N        fetch_sub(integral op, memory_order m = memory_order_seq_cst) volatile noexcept;
N    integral fetch_sub(integral op, memory_order m = memory_order_seq_cst) noexcept;
N    integral
N        fetch_and(integral op, memory_order m = memory_order_seq_cst) volatile noexcept;
N    integral fetch_and(integral op, memory_order m = memory_order_seq_cst) noexcept;
N    integral
N        fetch_or(integral op, memory_order m = memory_order_seq_cst) volatile noexcept;
N    integral fetch_or(integral op, memory_order m = memory_order_seq_cst) noexcept;
N    integral
N        fetch_xor(integral op, memory_order m = memory_order_seq_cst) volatile noexcept;
N    integral fetch_xor(integral op, memory_order m = memory_order_seq_cst) noexcept;
N
N    atomic() noexcept = default;
N    constexpr atomic(integral desr) noexcept;
N    atomic(const atomic&) = delete;
N    atomic& operator=(const atomic&) = delete;
N    atomic& operator=(const atomic&) volatile = delete;
N    integral operator=(integral desr) volatile noexcept;
N    integral operator=(integral desr) noexcept;
N
N    integral operator++(int) volatile noexcept;
N    integral operator++(int) noexcept;
N    integral operator--(int) volatile noexcept;
N    integral operator--(int) noexcept;
N    integral operator++() volatile noexcept;
N    integral operator++() noexcept;
N    integral operator--() volatile noexcept;
N    integral operator--() noexcept;
N    integral operator+=(integral op) volatile noexcept;
N    integral operator+=(integral op) noexcept;
N    integral operator-=(integral op) volatile noexcept;
N    integral operator-=(integral op) noexcept;
N    integral operator&=(integral op) volatile noexcept;
N    integral operator&=(integral op) noexcept;
N    integral operator|=(integral op) volatile noexcept;
N    integral operator|=(integral op) noexcept;
N    integral operator^=(integral op) volatile noexcept;
N    integral operator^=(integral op) noexcept;
N};
N
Ntemplate <class T>
Nstruct atomic<T*>
N{
N    static constexpr bool is_always_lock_free;
N    bool is_lock_free() const volatile noexcept;
N    bool is_lock_free() const noexcept;
N    void store(T* desr, memory_order m = memory_order_seq_cst) volatile noexcept;
N    void store(T* desr, memory_order m = memory_order_seq_cst) noexcept;
N    T* load(memory_order m = memory_order_seq_cst) const volatile noexcept;
N    T* load(memory_order m = memory_order_seq_cst) const noexcept;
N    operator T*() const volatile noexcept;
N    operator T*() const noexcept;
N    T* exchange(T* desr, memory_order m = memory_order_seq_cst) volatile noexcept;
N    T* exchange(T* desr, memory_order m = memory_order_seq_cst) noexcept;
N    bool compare_exchange_weak(T*& expc, T* desr,
N                               memory_order s, memory_order f) volatile noexcept;
N    bool compare_exchange_weak(T*& expc, T* desr,
N                               memory_order s, memory_order f) noexcept;
N    bool compare_exchange_strong(T*& expc, T* desr,
N                                 memory_order s, memory_order f) volatile noexcept;
N    bool compare_exchange_strong(T*& expc, T* desr,
N                                 memory_order s, memory_order f) noexcept;
N    bool compare_exchange_weak(T*& expc, T* desr,
N                               memory_order m = memory_order_seq_cst) volatile noexcept;
N    bool compare_exchange_weak(T*& expc, T* desr,
N                               memory_order m = memory_order_seq_cst) noexcept;
N    bool compare_exchange_strong(T*& expc, T* desr,
N                                memory_order m = memory_order_seq_cst) volatile noexcept;
N    bool compare_exchange_strong(T*& expc, T* desr,
N                                 memory_order m = memory_order_seq_cst) noexcept;
N    T* fetch_add(ptrdiff_t op, memory_order m = memory_order_seq_cst) volatile noexcept;
N    T* fetch_add(ptrdiff_t op, memory_order m = memory_order_seq_cst) noexcept;
N    T* fetch_sub(ptrdiff_t op, memory_order m = memory_order_seq_cst) volatile noexcept;
N    T* fetch_sub(ptrdiff_t op, memory_order m = memory_order_seq_cst) noexcept;
N
N    atomic() noexcept = default;
N    constexpr atomic(T* desr) noexcept;
N    atomic(const atomic&) = delete;
N    atomic& operator=(const atomic&) = delete;
N    atomic& operator=(const atomic&) volatile = delete;
N
N    T* operator=(T*) volatile noexcept;
N    T* operator=(T*) noexcept;
N    T* operator++(int) volatile noexcept;
N    T* operator++(int) noexcept;
N    T* operator--(int) volatile noexcept;
N    T* operator--(int) noexcept;
N    T* operator++() volatile noexcept;
N    T* operator++() noexcept;
N    T* operator--() volatile noexcept;
N    T* operator--() noexcept;
N    T* operator+=(ptrdiff_t op) volatile noexcept;
N    T* operator+=(ptrdiff_t op) noexcept;
N    T* operator-=(ptrdiff_t op) volatile noexcept;
N    T* operator-=(ptrdiff_t op) noexcept;
N};
N
N
Ntemplate <class T>
N    bool
N    atomic_is_lock_free(const volatile atomic<T>* obj) noexcept;
N
Ntemplate <class T>
N    bool
N    atomic_is_lock_free(const atomic<T>* obj) noexcept;
N
Ntemplate <class T>
N    void
N    atomic_init(volatile atomic<T>* obj, T desr) noexcept;
N
Ntemplate <class T>
N    void
N    atomic_init(atomic<T>* obj, T desr) noexcept;
N
Ntemplate <class T>
N    void
N    atomic_store(volatile atomic<T>* obj, T desr) noexcept;
N
Ntemplate <class T>
N    void
N    atomic_store(atomic<T>* obj, T desr) noexcept;
N
Ntemplate <class T>
N    void
N    atomic_store_explicit(volatile atomic<T>* obj, T desr, memory_order m) noexcept;
N
Ntemplate <class T>
N    void
N    atomic_store_explicit(atomic<T>* obj, T desr, memory_order m) noexcept;
N
Ntemplate <class T>
N    T
N    atomic_load(const volatile atomic<T>* obj) noexcept;
N
Ntemplate <class T>
N    T
N    atomic_load(const atomic<T>* obj) noexcept;
N
Ntemplate <class T>
N    T
N    atomic_load_explicit(const volatile atomic<T>* obj, memory_order m) noexcept;
N
Ntemplate <class T>
N    T
N    atomic_load_explicit(const atomic<T>* obj, memory_order m) noexcept;
N
Ntemplate <class T>
N    T
N    atomic_exchange(volatile atomic<T>* obj, T desr) noexcept;
N
Ntemplate <class T>
N    T
N    atomic_exchange(atomic<T>* obj, T desr) noexcept;
N
Ntemplate <class T>
N    T
N    atomic_exchange_explicit(volatile atomic<T>* obj, T desr, memory_order m) noexcept;
N
Ntemplate <class T>
N    T
N    atomic_exchange_explicit(atomic<T>* obj, T desr, memory_order m) noexcept;
N
Ntemplate <class T>
N    bool
N    atomic_compare_exchange_weak(volatile atomic<T>* obj, T* expc, T desr) noexcept;
N
Ntemplate <class T>
N    bool
N    atomic_compare_exchange_weak(atomic<T>* obj, T* expc, T desr) noexcept;
N
Ntemplate <class T>
N    bool
N    atomic_compare_exchange_strong(volatile atomic<T>* obj, T* expc, T desr) noexcept;
N
Ntemplate <class T>
N    bool
N    atomic_compare_exchange_strong(atomic<T>* obj, T* expc, T desr) noexcept;
N
Ntemplate <class T>
N    bool
N    atomic_compare_exchange_weak_explicit(volatile atomic<T>* obj, T* expc,
N                                          T desr,
N                                          memory_order s, memory_order f) noexcept;
N
Ntemplate <class T>
N    bool
N    atomic_compare_exchange_weak_explicit(atomic<T>* obj, T* expc, T desr,
N                                          memory_order s, memory_order f) noexcept;
N
Ntemplate <class T>
N    bool
N    atomic_compare_exchange_strong_explicit(volatile atomic<T>* obj,
N                                            T* expc, T desr,
N                                            memory_order s, memory_order f) noexcept;
N
Ntemplate <class T>
N    bool
N    atomic_compare_exchange_strong_explicit(atomic<T>* obj, T* expc,
N                                            T desr,
N                                            memory_order s, memory_order f) noexcept;
N
Ntemplate <class Integral>
N    Integral
N    atomic_fetch_add(volatile atomic<Integral>* obj, Integral op) noexcept;
N
Ntemplate <class Integral>
N    Integral
N    atomic_fetch_add(atomic<Integral>* obj, Integral op) noexcept;
N
Ntemplate <class Integral>
N    Integral
N    atomic_fetch_add_explicit(volatile atomic<Integral>* obj, Integral op,
N                              memory_order m) noexcept;
Ntemplate <class Integral>
N    Integral
N    atomic_fetch_add_explicit(atomic<Integral>* obj, Integral op,
N                              memory_order m) noexcept;
Ntemplate <class Integral>
N    Integral
N    atomic_fetch_sub(volatile atomic<Integral>* obj, Integral op) noexcept;
N
Ntemplate <class Integral>
N    Integral
N    atomic_fetch_sub(atomic<Integral>* obj, Integral op) noexcept;
N
Ntemplate <class Integral>
N    Integral
N    atomic_fetch_sub_explicit(volatile atomic<Integral>* obj, Integral op,
N                              memory_order m) noexcept;
Ntemplate <class Integral>
N    Integral
N    atomic_fetch_sub_explicit(atomic<Integral>* obj, Integral op,
N                              memory_order m) noexcept;
Ntemplate <class Integral>
N    Integral
N    atomic_fetch_and(volatile atomic<Integral>* obj, Integral op) noexcept;
N
Ntemplate <class Integral>
N    Integral
N    atomic_fetch_and(atomic<Integral>* obj, Integral op) noexcept;
N
Ntemplate <class Integral>
N    Integral
N    atomic_fetch_and_explicit(volatile atomic<Integral>* obj, Integral op,
N                              memory_order m) noexcept;
Ntemplate <class Integral>
N    Integral
N    atomic_fetch_and_explicit(atomic<Integral>* obj, Integral op,
N                              memory_order m) noexcept;
Ntemplate <class Integral>
N    Integral
N    atomic_fetch_or(volatile atomic<Integral>* obj, Integral op) noexcept;
N
Ntemplate <class Integral>
N    Integral
N    atomic_fetch_or(atomic<Integral>* obj, Integral op) noexcept;
N
Ntemplate <class Integral>
N    Integral
N    atomic_fetch_or_explicit(volatile atomic<Integral>* obj, Integral op,
N                             memory_order m) noexcept;
Ntemplate <class Integral>
N    Integral
N    atomic_fetch_or_explicit(atomic<Integral>* obj, Integral op,
N                             memory_order m) noexcept;
Ntemplate <class Integral>
N    Integral
N    atomic_fetch_xor(volatile atomic<Integral>* obj, Integral op) noexcept;
N
Ntemplate <class Integral>
N    Integral
N    atomic_fetch_xor(atomic<Integral>* obj, Integral op) noexcept;
N
Ntemplate <class Integral>
N    Integral
N    atomic_fetch_xor_explicit(volatile atomic<Integral>* obj, Integral op,
N                              memory_order m) noexcept;
Ntemplate <class Integral>
N    Integral
N    atomic_fetch_xor_explicit(atomic<Integral>* obj, Integral op,
N                              memory_order m) noexcept;
N
Ntemplate <class T>
N    T*
N    atomic_fetch_add(volatile atomic<T*>* obj, ptrdiff_t op) noexcept;
N
Ntemplate <class T>
N    T*
N    atomic_fetch_add(atomic<T*>* obj, ptrdiff_t op) noexcept;
N
Ntemplate <class T>
N    T*
N    atomic_fetch_add_explicit(volatile atomic<T*>* obj, ptrdiff_t op,
N                              memory_order m) noexcept;
Ntemplate <class T>
N    T*
N    atomic_fetch_add_explicit(atomic<T*>* obj, ptrdiff_t op, memory_order m) noexcept;
N
Ntemplate <class T>
N    T*
N    atomic_fetch_sub(volatile atomic<T*>* obj, ptrdiff_t op) noexcept;
N
Ntemplate <class T>
N    T*
N    atomic_fetch_sub(atomic<T*>* obj, ptrdiff_t op) noexcept;
N
Ntemplate <class T>
N    T*
N    atomic_fetch_sub_explicit(volatile atomic<T*>* obj, ptrdiff_t op,
N                              memory_order m) noexcept;
Ntemplate <class T>
N    T*
N    atomic_fetch_sub_explicit(atomic<T*>* obj, ptrdiff_t op, memory_order m) noexcept;
N
N// Atomics for standard typedef types
N
Ntypedef atomic<bool>               atomic_bool;
Ntypedef atomic<char>               atomic_char;
Ntypedef atomic<signed char>        atomic_schar;
Ntypedef atomic<unsigned char>      atomic_uchar;
Ntypedef atomic<short>              atomic_short;
Ntypedef atomic<unsigned short>     atomic_ushort;
Ntypedef atomic<int>                atomic_int;
Ntypedef atomic<unsigned int>       atomic_uint;
Ntypedef atomic<long>               atomic_long;
Ntypedef atomic<unsigned long>      atomic_ulong;
Ntypedef atomic<long long>          atomic_llong;
Ntypedef atomic<unsigned long long> atomic_ullong;
Ntypedef atomic<char16_t>           atomic_char16_t;
Ntypedef atomic<char32_t>           atomic_char32_t;
Ntypedef atomic<wchar_t>            atomic_wchar_t;
N
Ntypedef atomic<int_least8_t>   atomic_int_least8_t;
Ntypedef atomic<uint_least8_t>  atomic_uint_least8_t;
Ntypedef atomic<int_least16_t>  atomic_int_least16_t;
Ntypedef atomic<uint_least16_t> atomic_uint_least16_t;
Ntypedef atomic<int_least32_t>  atomic_int_least32_t;
Ntypedef atomic<uint_least32_t> atomic_uint_least32_t;
Ntypedef atomic<int_least64_t>  atomic_int_least64_t;
Ntypedef atomic<uint_least64_t> atomic_uint_least64_t;
N
Ntypedef atomic<int_fast8_t>   atomic_int_fast8_t;
Ntypedef atomic<uint_fast8_t>  atomic_uint_fast8_t;
Ntypedef atomic<int_fast16_t>  atomic_int_fast16_t;
Ntypedef atomic<uint_fast16_t> atomic_uint_fast16_t;
Ntypedef atomic<int_fast32_t>  atomic_int_fast32_t;
Ntypedef atomic<uint_fast32_t> atomic_uint_fast32_t;
Ntypedef atomic<int_fast64_t>  atomic_int_fast64_t;
Ntypedef atomic<uint_fast64_t> atomic_uint_fast64_t;
N
Ntypedef atomic<int8_t>   atomic_int8_t;
Ntypedef atomic<uint8_t>  atomic_uint8_t;
Ntypedef atomic<int16_t>  atomic_int16_t;
Ntypedef atomic<uint16_t> atomic_uint16_t;
Ntypedef atomic<int32_t>  atomic_int32_t;
Ntypedef atomic<uint32_t> atomic_uint32_t;
Ntypedef atomic<int64_t>  atomic_int64_t;
Ntypedef atomic<uint64_t> atomic_uint64_t;
N
Ntypedef atomic<intptr_t>  atomic_intptr_t;
Ntypedef atomic<uintptr_t> atomic_uintptr_t;
Ntypedef atomic<size_t>    atomic_size_t;
Ntypedef atomic<ptrdiff_t> atomic_ptrdiff_t;
Ntypedef atomic<intmax_t>  atomic_intmax_t;
Ntypedef atomic<uintmax_t> atomic_uintmax_t;
N
N// fences
N
Nvoid atomic_thread_fence(memory_order m) noexcept;
Nvoid atomic_signal_fence(memory_order m) noexcept;
N
N}  // std
N
N*/
N
N#include <__config>
N#include <cstddef>
N#include <cstdint>
N#include <type_traits>
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N#if defined(_LIBCPP_HAS_NO_THREADS) && !defined(__TI_COMPILER_VERSION__)
X#if 1L && !1L
S#error <atomic> is not supported on this single threaded system
N#endif
N#if !defined(_LIBCPP_HAS_C_ATOMIC_IMP) && !defined(_LIBCPP_HAS_GCC_ATOMIC_IMP)
X#if !0L && !1L
S#error <atomic> is not implemented
N#endif
N
N#ifdef __TI_COMPILER_VERSION__
N#include <_atomic.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/_atomic.h" 1
N/******************************************************************************/
N/*                                                                            */
N/* _ATOMIC.H                                                                  */
N/* Copyright (c) 2018 Texas Instruments Incorporated                          */
N/* http://www.ti.com/                                                         */
N/*                                                                            */
N/*  Redistribution and  use in source  and binary forms, with  or without     */
N/*  modification,  are permitted provided  that the  following conditions     */
N/*  are met:                                                                  */
N/*                                                                            */
N/*     Redistributions  of source  code must  retain the  above copyright     */
N/*     notice, this list of conditions and the following disclaimer.          */
N/*                                                                            */
N/*     Redistributions in binary form  must reproduce the above copyright     */
N/*     notice, this  list of conditions  and the following  disclaimer in     */
N/*     the  documentation  and/or   other  materials  provided  with  the     */
N/*     distribution.                                                          */
N/*                                                                            */
N/*     Neither the  name of Texas Instruments Incorporated  nor the names     */
N/*     of its  contributors may  be used to  endorse or  promote products     */
N/*     derived  from   this  software  without   specific  prior  written     */
N/*     permission.                                                            */
N/*                                                                            */
N/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS     */
N/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT     */
N/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR     */
N/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT     */
N/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,     */
N/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT     */
N/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     */
N/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY     */
N/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT     */
N/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE     */
N/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.      */
N/*                                                                            */
N/*                                                                            */
N/******************************************************************************/
N#ifndef __ATOMICHDR
N#define __ATOMICHDR
N#ifndef __cplusplus
S#include <stdlib.h>
S#include <stdint.h>
S#include <stdbool.h>
N#else
N#include <cstdlib>
N#include <cstdint>
N#include <cstdbool>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/cstdbool" 1
N// -*- C++ -*-
N//===--------------------------- cstdbool ---------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is dual licensed under the MIT and the University of Illinois Open
N// Source Licenses. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP_CSTDBOOL
N#define _LIBCPP_CSTDBOOL
N
N/*
N    cstdbool synopsis
N
NMacros:
N
N    __bool_true_false_are_defined
N
N*/
N
N#include <__config>
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N#undef __bool_true_false_are_defined
N#define __bool_true_false_are_defined 1
N
N#endif  // _LIBCPP_CSTDBOOL
L 48 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/_atomic.h" 2
N#endif
N
N/* Implement the GCC Atomic builtins required to implement C++1x */
N
N#define __ATOMIC_RELAXED 0
N#define __ATOMIC_CONSUME 1
N#define __ATOMIC_ACQUIRE 2
N#define __ATOMIC_RELEASE 3
N#define __ATOMIC_ACQ_REL 4
N#define __ATOMIC_SEQ_CST 5
N
N#ifdef __ARM_FEATURE_LDREX
N#define __ATOMIC_ALWAYS_LOCK_FREE(n) \
N    (((n) == 1 ? (__ARM_FEATURE_LDREX & 0x01) : \
N      (n) == 2 ? (__ARM_FEATURE_LDREX & 0x02) : \
N      (n) == 4 ? (__ARM_FEATURE_LDREX & 0x04) : \
N      (n) == 8 ? (__ARM_FEATURE_LDREX & 0x08) : 0) != 0)
X#define __ATOMIC_ALWAYS_LOCK_FREE(n)     (((n) == 1 ? (__ARM_FEATURE_LDREX & 0x01) :       (n) == 2 ? (__ARM_FEATURE_LDREX & 0x02) :       (n) == 4 ? (__ARM_FEATURE_LDREX & 0x04) :       (n) == 8 ? (__ARM_FEATURE_LDREX & 0x08) : 0) != 0)
N#else
S/* Using disable/restore interrupts */
S#define __ATOMIC_ALWAYS_LOCK_FREE(n) \
S    ((n) == 1 || \
S     (n) == 2 || \
S     (n) == 4 || \
S     (n) == 8 )
X#define __ATOMIC_ALWAYS_LOCK_FREE(n)     ((n) == 1 ||      (n) == 2 ||      (n) == 4 ||      (n) == 8 )
N#endif
N
N#define __GCC_ATOMIC_BOOL_LOCK_FREE       __ATOMIC_ALWAYS_LOCK_FREE(1)
N#define __GCC_ATOMIC_CHAR_LOCK_FREE       __ATOMIC_ALWAYS_LOCK_FREE(1)
N#define __GCC_ATOMIC_CHAR16_T_LOCK_FREE   __ATOMIC_ALWAYS_LOCK_FREE(2)
N#define __GCC_ATOMIC_CHAR32_T_LOCK_FREE   __ATOMIC_ALWAYS_LOCK_FREE(4)
N#define __GCC_ATOMIC_WCHAR_T_LOCK_FREE    \
N   __ATOMIC_ALWAYS_LOCK_FREE(__SIZEOF_WCHAR_T__)
X#define __GCC_ATOMIC_WCHAR_T_LOCK_FREE       __ATOMIC_ALWAYS_LOCK_FREE(__SIZEOF_WCHAR_T__)
N#define __GCC_ATOMIC_SHORT_LOCK_FREE      \
N   __ATOMIC_ALWAYS_LOCK_FREE(__SIZEOF_SHORT__)
X#define __GCC_ATOMIC_SHORT_LOCK_FREE         __ATOMIC_ALWAYS_LOCK_FREE(__SIZEOF_SHORT__)
N#define __GCC_ATOMIC_INT_LOCK_FREE        \
N   __ATOMIC_ALWAYS_LOCK_FREE(__SIZEOF_INT__)
X#define __GCC_ATOMIC_INT_LOCK_FREE           __ATOMIC_ALWAYS_LOCK_FREE(__SIZEOF_INT__)
N#define __GCC_ATOMIC_LONG_LOCK_FREE       \
N   __ATOMIC_ALWAYS_LOCK_FREE(__SIZEOF_LONG__)
X#define __GCC_ATOMIC_LONG_LOCK_FREE          __ATOMIC_ALWAYS_LOCK_FREE(__SIZEOF_LONG__)
N#define __GCC_ATOMIC_LLONG_LOCK_FREE      \
N   __ATOMIC_ALWAYS_LOCK_FREE(__SIZEOF_LONG_LONG__)
X#define __GCC_ATOMIC_LLONG_LOCK_FREE         __ATOMIC_ALWAYS_LOCK_FREE(__SIZEOF_LONG_LONG__)
N#ifdef __SIZEOF_POINTER__
S#define __GCC_ATOMIC_POINTER_LOCK_FREE    \
S   __ATOMIC_ALWAYS_LOCK_FREE(__SIZEOF_POINTER__)
X#define __GCC_ATOMIC_POINTER_LOCK_FREE       __ATOMIC_ALWAYS_LOCK_FREE(__SIZEOF_POINTER__)
N#else
N#define __GCC_ATOMIC_POINTER_LOCK_FREE    \
N   __ATOMIC_ALWAYS_LOCK_FREE(__SIZEOF_PTRDIFF_T__)
X#define __GCC_ATOMIC_POINTER_LOCK_FREE       __ATOMIC_ALWAYS_LOCK_FREE(__SIZEOF_PTRDIFF_T__)
N#endif
N
Nstatic inline bool 
N__atomic_always_lock_free(size_t n, const void *ptr)
N{
N  return __ATOMIC_ALWAYS_LOCK_FREE(n);
X  return (((n) == 1 ? (7 & 0x01) : (n) == 2 ? (7 & 0x02) : (n) == 4 ? (7 & 0x04) : (n) == 8 ? (7 & 0x08) : 0) != 0);
N}
N
Nstatic inline bool 
N__atomic_is_lock_free(size_t n, const void *ptr)
N{
N  return __ATOMIC_ALWAYS_LOCK_FREE(n);
X  return (((n) == 1 ? (7 & 0x01) : (n) == 2 ? (7 & 0x02) : (n) == 4 ? (7 & 0x04) : (n) == 8 ? (7 & 0x08) : 0) != 0);
N}
N
N#define __TI_ATOMIC_FUNC(type, name) \
N__attribute__((always_inline)) static inline type name
X#define __TI_ATOMIC_FUNC(type, name) __attribute__((always_inline)) static inline type name
N
N#ifdef __ARM_FEATURE_LDREX
N
N#define __atomic_thread_fence(order) _dmb()
N#define __atomic_signal_fence(order) _dmb()
N
N#ifdef __ATOMIC_ALWAYS_SEQ_CST
S#define __ti_release_fence(order) __atomic_thread_fence(order)
S#define __ti_acquire_fence(order) __atomic_thread_fence(order)
N#else
N#define __ti_release_fence(order) \
Ndo { \
N  switch (order) { \
N    case __ATOMIC_RELEASE: \
N    case __ATOMIC_ACQ_REL: \
N    case __ATOMIC_SEQ_CST:  \
N      __atomic_thread_fence(order); \
N      break; \
N    case __ATOMIC_RELAXED: \
N    case __ATOMIC_CONSUME: \
N    case __ATOMIC_ACQUIRE: \
N    default:  \
N      break; \
N  } \
N} while (0)
X#define __ti_release_fence(order) do {   switch (order) {     case __ATOMIC_RELEASE:     case __ATOMIC_ACQ_REL:     case __ATOMIC_SEQ_CST:        __atomic_thread_fence(order);       break;     case __ATOMIC_RELAXED:     case __ATOMIC_CONSUME:     case __ATOMIC_ACQUIRE:     default:        break;   } } while (0)
N
N#define __ti_acquire_fence(order) \
Ndo { \
N  switch (order) { \
N    case __ATOMIC_ACQUIRE: \
N    case __ATOMIC_ACQ_REL: \
N    case __ATOMIC_SEQ_CST: \
N      __atomic_thread_fence(order); \
N      break; \
N    case __ATOMIC_RELAXED: \
N    case __ATOMIC_CONSUME: \
N    case __ATOMIC_RELEASE: \
N    default: \
N      break; \
N  } \
N} while (0)
X#define __ti_acquire_fence(order) do {   switch (order) {     case __ATOMIC_ACQUIRE:     case __ATOMIC_ACQ_REL:     case __ATOMIC_SEQ_CST:       __atomic_thread_fence(order);       break;     case __ATOMIC_RELAXED:     case __ATOMIC_CONSUME:     case __ATOMIC_RELEASE:     default:       break;   } } while (0)
N#endif
N
N#define __LDREX1 __ldrexb
N#define __LDREX2 __ldrexh
N#define __LDREX4 __ldrex
N#define __LDREX8 __ldrexd
N
N#define __STREX1 __strexb
N#define __STREX2 __strexh
N#define __STREX4 __strex
N#define __STREX8 __strexd
N
N#define __CLREX __clrex
N
N/* __atomic_load_[1,2,4]() builtins */
N
N#define __TI_ATOMIC_LOAD_N(n, type) \
N__TI_ATOMIC_FUNC(type, __atomic_load_##n) \
N(const void *ptr, int memorder) \
N{ \
N  /* __ti_release_fence(memorder); */ \
N  type t0 = *(const volatile type*)ptr; \
N  __ti_acquire_fence(memorder); \
N  return t0; \
N}
X#define __TI_ATOMIC_LOAD_N(n, type) __TI_ATOMIC_FUNC(type, __atomic_load_##n) (const void *ptr, int memorder) {       type t0 = *(const volatile type*)ptr;   __ti_acquire_fence(memorder);   return t0; }
N
N/* __atomic_load_8() builtin */
N
N#define __TI_ATOMIC_LOAD_8(type) \
N__TI_ATOMIC_FUNC(type, __atomic_load_8) \
N(const void *ptr, int memorder) \
N{ \
N  /* __ti_release_fence(memorder); */ \
N  type t0 = __LDREX8((volatile void*)ptr); \
N  __CLREX(); \
N  __ti_acquire_fence(memorder); \
N  return t0; \
N}
X#define __TI_ATOMIC_LOAD_8(type) __TI_ATOMIC_FUNC(type, __atomic_load_8) (const void *ptr, int memorder) {       type t0 = __LDREX8((volatile void*)ptr);   __CLREX();   __ti_acquire_fence(memorder);   return t0; }
N
N/* __atomic_store_[1,2,4]() builtins */
N
N#define __TI_ATOMIC_STORE_N(n, type) \
N__TI_ATOMIC_FUNC(void, __atomic_store_##n) \
N(void *ptr, type val, int memorder) \
N{ \
N  __ti_release_fence(memorder); \
N  *(volatile type*)ptr = val; \
N  __ti_acquire_fence(memorder); \
N  return; \
N}
X#define __TI_ATOMIC_STORE_N(n, type) __TI_ATOMIC_FUNC(void, __atomic_store_##n) (void *ptr, type val, int memorder) {   __ti_release_fence(memorder);   *(volatile type*)ptr = val;   __ti_acquire_fence(memorder);   return; }
N
N/* __atomic_store_8() builtin */
N
N#define __TI_ATOMIC_STORE_8(type) \
N__TI_ATOMIC_FUNC(void, __atomic_store_8) \
N(void *ptr, type val, int memorder) \
N{ \
N  __ti_release_fence(memorder); \
N  uint32_t exflag; \
N  retry: \
N    (void)__LDREX8(ptr); \
N    exflag = __STREX8(val, ptr); \
N  if (exflag) goto retry; \
N  __ti_acquire_fence(memorder); \
N  return; \
N}
X#define __TI_ATOMIC_STORE_8(type) __TI_ATOMIC_FUNC(void, __atomic_store_8) (void *ptr, type val, int memorder) {   __ti_release_fence(memorder);   uint32_t exflag;   retry:     (void)__LDREX8(ptr);     exflag = __STREX8(val, ptr);   if (exflag) goto retry;   __ti_acquire_fence(memorder);   return; }
N
N/* __atomic_exchange_[1,2,4,8]() builtins */
N
N#define __TI_ATOMIC_EXCHANGE_N(n, type) \
N__TI_ATOMIC_FUNC(type, __atomic_exchange_##n) \
N(void *ptr, type val, int memorder) \
N{ \
N  type t0; \
N  uint32_t exflag; \
N  __ti_release_fence(memorder); \
N  retry: \
N    t0 = __LDREX##n(ptr); \
N    exflag = __STREX##n(val, ptr); \
N  if (exflag) goto retry; \
N  __ti_acquire_fence(memorder); \
N  return t0; \
N}
X#define __TI_ATOMIC_EXCHANGE_N(n, type) __TI_ATOMIC_FUNC(type, __atomic_exchange_##n) (void *ptr, type val, int memorder) {   type t0;   uint32_t exflag;   __ti_release_fence(memorder);   retry:     t0 = __LDREX##n(ptr);     exflag = __STREX##n(val, ptr);   if (exflag) goto retry;   __ti_acquire_fence(memorder);   return t0; }
N
N/* __atomic_compare_exchange_[1,2,4,8] builtins */
N/* Match libatomic - drop the (4th parameter) strong/weak flag */
N
N#define __TI_ATOMIC_COMPARE_EXCHANGE_N(n, type) \
N__TI_ATOMIC_FUNC(bool, __atomic_compare_exchange_##n) \
N(void *ptr, void *expected, type desired, /* bool weak,*/ \
N  int success_memorder, int failure_memorder) \
N{ \
N  type t0, t1; \
N  uint32_t exflag = 0; \
N  __ti_release_fence(success_memorder); \
N  t1 = *(type*)expected; \
N  retry:\
N  t0 = __LDREX##n(ptr); \
N  if (t0 == t1) {\
N    exflag = __STREX##n(desired, ptr); \
N    if (exflag) goto retry; \
N    __ti_acquire_fence(success_memorder); \
N    return 1;\
N  } else { \
N    __CLREX(); \
N    *(type*)expected = t0; \
N    __ti_acquire_fence(failure_memorder); \
N    return 0; \
N  }\
N}
X#define __TI_ATOMIC_COMPARE_EXCHANGE_N(n, type) __TI_ATOMIC_FUNC(bool, __atomic_compare_exchange_##n) (void *ptr, void *expected, type desired,     int success_memorder, int failure_memorder) {   type t0, t1;   uint32_t exflag = 0;   __ti_release_fence(success_memorder);   t1 = *(type*)expected;   retry:  t0 = __LDREX##n(ptr);   if (t0 == t1) {    exflag = __STREX##n(desired, ptr);     if (exflag) goto retry;     __ti_acquire_fence(success_memorder);     return 1;  } else {     __CLREX();     *(type*)expected = t0;     __ti_acquire_fence(failure_memorder);     return 0;   }}
N
N/* __atomic_fetch_[add,sub,add,xor,or][1,2,4,8] builtins */
N
N#define __TI_ATOMIC_RMW(n, type, opname, op) \
N__TI_ATOMIC_FUNC(type, __atomic_##opname##_##n) \
N(void *ptr, type val, int memorder) \
N{ \
N  type t0, t1; \
N  uint32_t exflag = 0; \
N  __ti_release_fence(memorder); \
N  retry: \
N    t0 = __LDREX##n(ptr); \
N    t1 = t0 op val; \
N    exflag = __STREX##n(t1, ptr); \
N  if (exflag) goto retry; \
N  __ti_acquire_fence(memorder); \
N  return t0;\
N}
X#define __TI_ATOMIC_RMW(n, type, opname, op) __TI_ATOMIC_FUNC(type, __atomic_##opname##_##n) (void *ptr, type val, int memorder) {   type t0, t1;   uint32_t exflag = 0;   __ti_release_fence(memorder);   retry:     t0 = __LDREX##n(ptr);     t1 = t0 op val;     exflag = __STREX##n(t1, ptr);   if (exflag) goto retry;   __ti_acquire_fence(memorder);   return t0;}
N
N/*------------------------------------------------------------*/
N/* V4, V5e, V6 and V6-M0                                      */
N/* no LDREX/SRTEX/CLREX - disable/restore interrupts          */
N/*------------------------------------------------------------*/
N#else
S
S#if defined(__TI_ARM_V6M0__)
S#define __atomic_thread_fence(order) _dmb()
S#define __atomic_signal_fence(order) _dmb()
S#define __disable_interrupts _disable_interrupts
S#define __restore_interrupts _restore_interrupts
S#else
S#define __atomic_thread_fence(order)
S#define __atomic_signal_fence(order)
S#if !defined(__ARM_32BIT_STATE)
S#define __ATTRIBUTE_NOINLINE__ __attribute__((noinline))
S#else
S#define __ATTRIBUTE_NOINLINE__ 
S#endif
S__attribute__((target("arm"))) __ATTRIBUTE_NOINLINE__
Sstatic uint32_t __disable_interrupts() { return _disable_interrupts(); }
S__attribute__((target("arm"))) __ATTRIBUTE_NOINLINE__
Sstatic void __restore_interrupts(uint32_t t) { _restore_interrupts(t); }
S#undef __ATTRIBUTE_NOINLINE__
S#endif
S
S/* __atomic_load_[1,2,4,8]() builtins */
S
S#define __TI_ATOMIC_LOAD_N(n, type) \
S__TI_ATOMIC_FUNC(type, __atomic_load_##n) \
S(const void *ptr, int memorder) \
S{ \
S  uint32_t tmp = __disable_interrupts(); \
S  type t0 = *(const volatile type*)ptr; \
S  __restore_interrupts(tmp); \
S  return t0; \
S}
X#define __TI_ATOMIC_LOAD_N(n, type) __TI_ATOMIC_FUNC(type, __atomic_load_##n) (const void *ptr, int memorder) {   uint32_t tmp = __disable_interrupts();   type t0 = *(const volatile type*)ptr;   __restore_interrupts(tmp);   return t0; }
S
S/* __atomic_store_[1,2,4,8]() builtins */
S
S#define __TI_ATOMIC_STORE_N(n, type) \
S__TI_ATOMIC_FUNC(void, __atomic_store_##n) \
S(void *ptr, type val, int memorder) \
S{ \
S  uint32_t tmp = __disable_interrupts(); \
S  *(volatile type*)ptr = val; \
S  __restore_interrupts(tmp); \
S  return; \
S}
X#define __TI_ATOMIC_STORE_N(n, type) __TI_ATOMIC_FUNC(void, __atomic_store_##n) (void *ptr, type val, int memorder) {   uint32_t tmp = __disable_interrupts();   *(volatile type*)ptr = val;   __restore_interrupts(tmp);   return; }
S
S/* __atomic_exchange_[1,2,4,8]() builtins */
S
S#define __TI_ATOMIC_EXCHANGE_N(n, type) \
S__TI_ATOMIC_FUNC(type, __atomic_exchange_##n) \
S(void *ptr, type val, int memorder) \
S{ \
S  uint32_t tmp = __disable_interrupts(); \
S  type t0 = *(volatile type*)ptr; \
S  *(volatile type*)ptr = val; \
S  __restore_interrupts(tmp); \
S  return t0; \
S}
X#define __TI_ATOMIC_EXCHANGE_N(n, type) __TI_ATOMIC_FUNC(type, __atomic_exchange_##n) (void *ptr, type val, int memorder) {   uint32_t tmp = __disable_interrupts();   type t0 = *(volatile type*)ptr;   *(volatile type*)ptr = val;   __restore_interrupts(tmp);   return t0; }
S
S/* __atomic_compare_exchange_[1,2,4,8] builtins */
S/* Match libatomic - drop the (4th parameter) strong/weak flag */
S
S#define __TI_ATOMIC_COMPARE_EXCHANGE_N(n, type) \
S__TI_ATOMIC_FUNC(bool, __atomic_compare_exchange_##n) \
S(void *ptr, void *expected, type desired, /* bool weak,*/ \
S int success_memorder, int failure_memorder) \
S{ \
S  type t1 = *(type*)expected; \
S  uint32_t tmp = __disable_interrupts(); \
S  type t0 = *(volatile type*)ptr; \
S  if (t0 == t1) {\
S    *(volatile type*)ptr = desired; \
S    __restore_interrupts(tmp); \
S    return 1;\
S  } else { \
S    *(type*)expected = t0; \
S    __restore_interrupts(tmp); \
S    return 0; \
S  }\
S}
X#define __TI_ATOMIC_COMPARE_EXCHANGE_N(n, type) __TI_ATOMIC_FUNC(bool, __atomic_compare_exchange_##n) (void *ptr, void *expected, type desired,    int success_memorder, int failure_memorder) {   type t1 = *(type*)expected;   uint32_t tmp = __disable_interrupts();   type t0 = *(volatile type*)ptr;   if (t0 == t1) {    *(volatile type*)ptr = desired;     __restore_interrupts(tmp);     return 1;  } else {     *(type*)expected = t0;     __restore_interrupts(tmp);     return 0;   }}
S
S/* __atomic_fetch_[add,sub,add,xor,or][1,2,4,8] builtins */
S
S#define __TI_ATOMIC_RMW(n, type, opname, op) \
S__TI_ATOMIC_FUNC(type, __atomic_##opname##_##n) \
S(void *ptr, type val, int memorder) \
S{ \
S  type t0, t1; \
S  uint32_t tmp = __disable_interrupts(); \
S  t0 = *(volatile type*)ptr; \
S  t1 = t0 op val; \
S  *(volatile type*)ptr = t1; \
S  __restore_interrupts(tmp); \
S  return t0;\
S}
X#define __TI_ATOMIC_RMW(n, type, opname, op) __TI_ATOMIC_FUNC(type, __atomic_##opname##_##n) (void *ptr, type val, int memorder) {   type t0, t1;   uint32_t tmp = __disable_interrupts();   t0 = *(volatile type*)ptr;   t1 = t0 op val;   *(volatile type*)ptr = t1;   __restore_interrupts(tmp);   return t0;}
N#endif
N
N/* Define lock free atomic builtins */
N
N#define __TI_ATOMIC_N(n, type) \
N__TI_ATOMIC_EXCHANGE_N(n, type) \
N__TI_ATOMIC_COMPARE_EXCHANGE_N(n, type) \
N__TI_ATOMIC_RMW(n, type, fetch_add, +) \
N__TI_ATOMIC_RMW(n, type, fetch_sub, -) \
N__TI_ATOMIC_RMW(n, type, fetch_and, &) \
N__TI_ATOMIC_RMW(n, type, fetch_xor, ^) \
N__TI_ATOMIC_RMW(n, type, fetch_or,  |)
X#define __TI_ATOMIC_N(n, type) __TI_ATOMIC_EXCHANGE_N(n, type) __TI_ATOMIC_COMPARE_EXCHANGE_N(n, type) __TI_ATOMIC_RMW(n, type, fetch_add, +) __TI_ATOMIC_RMW(n, type, fetch_sub, -) __TI_ATOMIC_RMW(n, type, fetch_and, &) __TI_ATOMIC_RMW(n, type, fetch_xor, ^) __TI_ATOMIC_RMW(n, type, fetch_or,  |)
N
N#if __ATOMIC_ALWAYS_LOCK_FREE(1)
X#if (((1) == 1 ? (7 & 0x01) : (1) == 2 ? (7 & 0x02) : (1) == 4 ? (7 & 0x04) : (1) == 8 ? (7 & 0x08) : 0) != 0)
N__TI_ATOMIC_LOAD_N(1, uint8_t)
X__attribute__((always_inline)) static inline uint8_t __atomic_load_1 (const void *ptr, int memorder) { uint8_t t0 = *(const volatile uint8_t*)ptr; do { switch (memorder) { case 2: case 4: case 5: _dmb(); break; case 0: case 1: case 3: default: break; } } while (0); return t0; }
N__TI_ATOMIC_STORE_N(1, uint8_t)
X__attribute__((always_inline)) static inline void __atomic_store_1 (void *ptr, uint8_t val, int memorder) { do { switch (memorder) { case 3: case 4: case 5: _dmb(); break; case 0: case 1: case 2: default: break; } } while (0); *(volatile uint8_t*)ptr = val; do { switch (memorder) { case 2: case 4: case 5: _dmb(); break; case 0: case 1: case 3: default: break; } } while (0); return; }
R "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/_atomic.h" 395 1 (ULP 5.4) Detected an assignment to a type with size less than int. To avoid unnecessary sign extension, use int-sized types for local varaibles and convert to smaller types for static storage.
R "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/_atomic.h" 395 1 (ULP 5.4) Detected an assignment to a type with size less than int. To avoid unnecessary sign extension, use int-sized types for local varaibles and convert to smaller types for static storage.
R "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/_atomic.h" 395 1 (ULP 5.4) Detected an assignment to a type with size less than int. To avoid unnecessary sign extension, use int-sized types for local varaibles and convert to smaller types for static storage.
R "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/_atomic.h" 395 1 (ULP 5.4) Detected an assignment to a type with size less than int. To avoid unnecessary sign extension, use int-sized types for local varaibles and convert to smaller types for static storage.
R "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/_atomic.h" 395 1 (ULP 5.4) Detected an assignment to a type with size less than int. To avoid unnecessary sign extension, use int-sized types for local varaibles and convert to smaller types for static storage.
N__TI_ATOMIC_N(1, uint8_t)
X__attribute__((always_inline)) static inline uint8_t __atomic_exchange_1 (void *ptr, uint8_t val, int memorder) { uint8_t t0; uint32_t exflag; do { switch (memorder) { case 3: case 4: case 5: _dmb(); break; case 0: case 1: case 2: default: break; } } while (0); retry: t0 = __ldrexb(ptr); exflag = __strexb(val, ptr); if (exflag) goto retry; do { switch (memorder) { case 2: case 4: case 5: _dmb(); break; case 0: case 1: case 3: default: break; } } while (0); return t0; } __attribute__((always_inline)) static inline bool __atomic_compare_exchange_1 (void *ptr, void *expected, uint8_t desired, int success_memorder, int failure_memorder) { uint8_t t0, t1; uint32_t exflag = 0; do { switch (success_memorder) { case 3: case 4: case 5: _dmb(); break; case 0: case 1: case 2: default: break; } } while (0); t1 = *(uint8_t*)expected; retry: t0 = __ldrexb(ptr); if (t0 == t1) { exflag = __strexb(desired, ptr); if (exflag) goto retry; do { switch (success_memorder) { case 2: case 4: case 5: _dmb(); break; case 0: case 1: case 3: default: break; } } while (0); return 1; } else { __clrex(); *(uint8_t*)expected = t0; do { switch (failure_memorder) { case 2: case 4: case 5: _dmb(); break; case 0: case 1: case 3: default: break; } } while (0); return 0; }} __attribute__((always_inline)) static inline uint8_t __atomic_fetch_add_1 (void *ptr, uint8_t val, int memorder) { uint8_t t0, t1; uint32_t exflag = 0; do { switch (memorder) { case 3: case 4: case 5: _dmb(); break; case 0: case 1: case 2: default: break; } } while (0); retry: t0 = __ldrexb(ptr); t1 = t0 + val; exflag = __strexb(t1, ptr); if (exflag) goto retry; do { switch (memorder) { case 2: case 4: case 5: _dmb(); break; case 0: case 1: case 3: default: break; } } while (0); return t0;} __attribute__((always_inline)) static inline uint8_t __atomic_fetch_sub_1 (void *ptr, uint8_t val, int memorder) { uint8_t t0, t1; uint32_t exflag = 0; do { switch (memorder) { case 3: case 4: case 5: _dmb(); break; case 0: case 1: case 2: default: break; } } while (0); retry: t0 = __ldrexb(ptr); t1 = t0 - val; exflag = __strexb(t1, ptr); if (exflag) goto retry; do { switch (memorder) { case 2: case 4: case 5: _dmb(); break; case 0: case 1: case 3: default: break; } } while (0); return t0;} __attribute__((always_inline)) static inline uint8_t __atomic_fetch_and_1 (void *ptr, uint8_t val, int memorder) { uint8_t t0, t1; uint32_t exflag = 0; do { switch (memorder) { case 3: case 4: case 5: _dmb(); break; case 0: case 1: case 2: default: break; } } while (0); retry: t0 = __ldrexb(ptr); t1 = t0 & val; exflag = __strexb(t1, ptr); if (exflag) goto retry; do { switch (memorder) { case 2: case 4: case 5: _dmb(); break; case 0: case 1: case 3: default: break; } } while (0); return t0;} __attribute__((always_inline)) static inline uint8_t __atomic_fetch_xor_1 (void *ptr, uint8_t val, int memorder) { uint8_t t0, t1; uint32_t exflag = 0; do { switch (memorder) { case 3: case 4: case 5: _dmb(); break; case 0: case 1: case 2: default: break; } } while (0); retry: t0 = __ldrexb(ptr); t1 = t0 ^ val; exflag = __strexb(t1, ptr); if (exflag) goto retry; do { switch (memorder) { case 2: case 4: case 5: _dmb(); break; case 0: case 1: case 3: default: break; } } while (0); return t0;} __attribute__((always_inline)) static inline uint8_t __atomic_fetch_or_1 (void *ptr, uint8_t val, int memorder) { uint8_t t0, t1; uint32_t exflag = 0; do { switch (memorder) { case 3: case 4: case 5: _dmb(); break; case 0: case 1: case 2: default: break; } } while (0); retry: t0 = __ldrexb(ptr); t1 = t0 | val; exflag = __strexb(t1, ptr); if (exflag) goto retry; do { switch (memorder) { case 2: case 4: case 5: _dmb(); break; case 0: case 1: case 3: default: break; } } while (0); return t0;}
N#endif
N#if __ATOMIC_ALWAYS_LOCK_FREE(2)
X#if (((2) == 1 ? (7 & 0x01) : (2) == 2 ? (7 & 0x02) : (2) == 4 ? (7 & 0x04) : (2) == 8 ? (7 & 0x08) : 0) != 0)
N__TI_ATOMIC_LOAD_N(2, uint16_t) 
X__attribute__((always_inline)) static inline uint16_t __atomic_load_2 (const void *ptr, int memorder) { uint16_t t0 = *(const volatile uint16_t*)ptr; do { switch (memorder) { case 2: case 4: case 5: _dmb(); break; case 0: case 1: case 3: default: break; } } while (0); return t0; } 
N__TI_ATOMIC_STORE_N(2, uint16_t)
X__attribute__((always_inline)) static inline void __atomic_store_2 (void *ptr, uint16_t val, int memorder) { do { switch (memorder) { case 3: case 4: case 5: _dmb(); break; case 0: case 1: case 2: default: break; } } while (0); *(volatile uint16_t*)ptr = val; do { switch (memorder) { case 2: case 4: case 5: _dmb(); break; case 0: case 1: case 3: default: break; } } while (0); return; }
R "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/_atomic.h" 400 1 (ULP 5.4) Detected an assignment to a type with size less than int. To avoid unnecessary sign extension, use int-sized types for local varaibles and convert to smaller types for static storage.
R "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/_atomic.h" 400 1 (ULP 5.4) Detected an assignment to a type with size less than int. To avoid unnecessary sign extension, use int-sized types for local varaibles and convert to smaller types for static storage.
R "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/_atomic.h" 400 1 (ULP 5.4) Detected an assignment to a type with size less than int. To avoid unnecessary sign extension, use int-sized types for local varaibles and convert to smaller types for static storage.
R "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/_atomic.h" 400 1 (ULP 5.4) Detected an assignment to a type with size less than int. To avoid unnecessary sign extension, use int-sized types for local varaibles and convert to smaller types for static storage.
R "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/_atomic.h" 400 1 (ULP 5.4) Detected an assignment to a type with size less than int. To avoid unnecessary sign extension, use int-sized types for local varaibles and convert to smaller types for static storage.
N__TI_ATOMIC_N(2, uint16_t)
X__attribute__((always_inline)) static inline uint16_t __atomic_exchange_2 (void *ptr, uint16_t val, int memorder) { uint16_t t0; uint32_t exflag; do { switch (memorder) { case 3: case 4: case 5: _dmb(); break; case 0: case 1: case 2: default: break; } } while (0); retry: t0 = __ldrexh(ptr); exflag = __strexh(val, ptr); if (exflag) goto retry; do { switch (memorder) { case 2: case 4: case 5: _dmb(); break; case 0: case 1: case 3: default: break; } } while (0); return t0; } __attribute__((always_inline)) static inline bool __atomic_compare_exchange_2 (void *ptr, void *expected, uint16_t desired, int success_memorder, int failure_memorder) { uint16_t t0, t1; uint32_t exflag = 0; do { switch (success_memorder) { case 3: case 4: case 5: _dmb(); break; case 0: case 1: case 2: default: break; } } while (0); t1 = *(uint16_t*)expected; retry: t0 = __ldrexh(ptr); if (t0 == t1) { exflag = __strexh(desired, ptr); if (exflag) goto retry; do { switch (success_memorder) { case 2: case 4: case 5: _dmb(); break; case 0: case 1: case 3: default: break; } } while (0); return 1; } else { __clrex(); *(uint16_t*)expected = t0; do { switch (failure_memorder) { case 2: case 4: case 5: _dmb(); break; case 0: case 1: case 3: default: break; } } while (0); return 0; }} __attribute__((always_inline)) static inline uint16_t __atomic_fetch_add_2 (void *ptr, uint16_t val, int memorder) { uint16_t t0, t1; uint32_t exflag = 0; do { switch (memorder) { case 3: case 4: case 5: _dmb(); break; case 0: case 1: case 2: default: break; } } while (0); retry: t0 = __ldrexh(ptr); t1 = t0 + val; exflag = __strexh(t1, ptr); if (exflag) goto retry; do { switch (memorder) { case 2: case 4: case 5: _dmb(); break; case 0: case 1: case 3: default: break; } } while (0); return t0;} __attribute__((always_inline)) static inline uint16_t __atomic_fetch_sub_2 (void *ptr, uint16_t val, int memorder) { uint16_t t0, t1; uint32_t exflag = 0; do { switch (memorder) { case 3: case 4: case 5: _dmb(); break; case 0: case 1: case 2: default: break; } } while (0); retry: t0 = __ldrexh(ptr); t1 = t0 - val; exflag = __strexh(t1, ptr); if (exflag) goto retry; do { switch (memorder) { case 2: case 4: case 5: _dmb(); break; case 0: case 1: case 3: default: break; } } while (0); return t0;} __attribute__((always_inline)) static inline uint16_t __atomic_fetch_and_2 (void *ptr, uint16_t val, int memorder) { uint16_t t0, t1; uint32_t exflag = 0; do { switch (memorder) { case 3: case 4: case 5: _dmb(); break; case 0: case 1: case 2: default: break; } } while (0); retry: t0 = __ldrexh(ptr); t1 = t0 & val; exflag = __strexh(t1, ptr); if (exflag) goto retry; do { switch (memorder) { case 2: case 4: case 5: _dmb(); break; case 0: case 1: case 3: default: break; } } while (0); return t0;} __attribute__((always_inline)) static inline uint16_t __atomic_fetch_xor_2 (void *ptr, uint16_t val, int memorder) { uint16_t t0, t1; uint32_t exflag = 0; do { switch (memorder) { case 3: case 4: case 5: _dmb(); break; case 0: case 1: case 2: default: break; } } while (0); retry: t0 = __ldrexh(ptr); t1 = t0 ^ val; exflag = __strexh(t1, ptr); if (exflag) goto retry; do { switch (memorder) { case 2: case 4: case 5: _dmb(); break; case 0: case 1: case 3: default: break; } } while (0); return t0;} __attribute__((always_inline)) static inline uint16_t __atomic_fetch_or_2 (void *ptr, uint16_t val, int memorder) { uint16_t t0, t1; uint32_t exflag = 0; do { switch (memorder) { case 3: case 4: case 5: _dmb(); break; case 0: case 1: case 2: default: break; } } while (0); retry: t0 = __ldrexh(ptr); t1 = t0 | val; exflag = __strexh(t1, ptr); if (exflag) goto retry; do { switch (memorder) { case 2: case 4: case 5: _dmb(); break; case 0: case 1: case 3: default: break; } } while (0); return t0;}
N#endif
N#if __ATOMIC_ALWAYS_LOCK_FREE(4)
X#if (((4) == 1 ? (7 & 0x01) : (4) == 2 ? (7 & 0x02) : (4) == 4 ? (7 & 0x04) : (4) == 8 ? (7 & 0x08) : 0) != 0)
N__TI_ATOMIC_LOAD_N(4, uint32_t)
X__attribute__((always_inline)) static inline uint32_t __atomic_load_4 (const void *ptr, int memorder) { uint32_t t0 = *(const volatile uint32_t*)ptr; do { switch (memorder) { case 2: case 4: case 5: _dmb(); break; case 0: case 1: case 3: default: break; } } while (0); return t0; }
N__TI_ATOMIC_STORE_N(4, uint32_t)
X__attribute__((always_inline)) static inline void __atomic_store_4 (void *ptr, uint32_t val, int memorder) { do { switch (memorder) { case 3: case 4: case 5: _dmb(); break; case 0: case 1: case 2: default: break; } } while (0); *(volatile uint32_t*)ptr = val; do { switch (memorder) { case 2: case 4: case 5: _dmb(); break; case 0: case 1: case 3: default: break; } } while (0); return; }
N__TI_ATOMIC_N(4, uint32_t)
X__attribute__((always_inline)) static inline uint32_t __atomic_exchange_4 (void *ptr, uint32_t val, int memorder) { uint32_t t0; uint32_t exflag; do { switch (memorder) { case 3: case 4: case 5: _dmb(); break; case 0: case 1: case 2: default: break; } } while (0); retry: t0 = __ldrex(ptr); exflag = __strex(val, ptr); if (exflag) goto retry; do { switch (memorder) { case 2: case 4: case 5: _dmb(); break; case 0: case 1: case 3: default: break; } } while (0); return t0; } __attribute__((always_inline)) static inline bool __atomic_compare_exchange_4 (void *ptr, void *expected, uint32_t desired, int success_memorder, int failure_memorder) { uint32_t t0, t1; uint32_t exflag = 0; do { switch (success_memorder) { case 3: case 4: case 5: _dmb(); break; case 0: case 1: case 2: default: break; } } while (0); t1 = *(uint32_t*)expected; retry: t0 = __ldrex(ptr); if (t0 == t1) { exflag = __strex(desired, ptr); if (exflag) goto retry; do { switch (success_memorder) { case 2: case 4: case 5: _dmb(); break; case 0: case 1: case 3: default: break; } } while (0); return 1; } else { __clrex(); *(uint32_t*)expected = t0; do { switch (failure_memorder) { case 2: case 4: case 5: _dmb(); break; case 0: case 1: case 3: default: break; } } while (0); return 0; }} __attribute__((always_inline)) static inline uint32_t __atomic_fetch_add_4 (void *ptr, uint32_t val, int memorder) { uint32_t t0, t1; uint32_t exflag = 0; do { switch (memorder) { case 3: case 4: case 5: _dmb(); break; case 0: case 1: case 2: default: break; } } while (0); retry: t0 = __ldrex(ptr); t1 = t0 + val; exflag = __strex(t1, ptr); if (exflag) goto retry; do { switch (memorder) { case 2: case 4: case 5: _dmb(); break; case 0: case 1: case 3: default: break; } } while (0); return t0;} __attribute__((always_inline)) static inline uint32_t __atomic_fetch_sub_4 (void *ptr, uint32_t val, int memorder) { uint32_t t0, t1; uint32_t exflag = 0; do { switch (memorder) { case 3: case 4: case 5: _dmb(); break; case 0: case 1: case 2: default: break; } } while (0); retry: t0 = __ldrex(ptr); t1 = t0 - val; exflag = __strex(t1, ptr); if (exflag) goto retry; do { switch (memorder) { case 2: case 4: case 5: _dmb(); break; case 0: case 1: case 3: default: break; } } while (0); return t0;} __attribute__((always_inline)) static inline uint32_t __atomic_fetch_and_4 (void *ptr, uint32_t val, int memorder) { uint32_t t0, t1; uint32_t exflag = 0; do { switch (memorder) { case 3: case 4: case 5: _dmb(); break; case 0: case 1: case 2: default: break; } } while (0); retry: t0 = __ldrex(ptr); t1 = t0 & val; exflag = __strex(t1, ptr); if (exflag) goto retry; do { switch (memorder) { case 2: case 4: case 5: _dmb(); break; case 0: case 1: case 3: default: break; } } while (0); return t0;} __attribute__((always_inline)) static inline uint32_t __atomic_fetch_xor_4 (void *ptr, uint32_t val, int memorder) { uint32_t t0, t1; uint32_t exflag = 0; do { switch (memorder) { case 3: case 4: case 5: _dmb(); break; case 0: case 1: case 2: default: break; } } while (0); retry: t0 = __ldrex(ptr); t1 = t0 ^ val; exflag = __strex(t1, ptr); if (exflag) goto retry; do { switch (memorder) { case 2: case 4: case 5: _dmb(); break; case 0: case 1: case 3: default: break; } } while (0); return t0;} __attribute__((always_inline)) static inline uint32_t __atomic_fetch_or_4 (void *ptr, uint32_t val, int memorder) { uint32_t t0, t1; uint32_t exflag = 0; do { switch (memorder) { case 3: case 4: case 5: _dmb(); break; case 0: case 1: case 2: default: break; } } while (0); retry: t0 = __ldrex(ptr); t1 = t0 | val; exflag = __strex(t1, ptr); if (exflag) goto retry; do { switch (memorder) { case 2: case 4: case 5: _dmb(); break; case 0: case 1: case 3: default: break; } } while (0); return t0;}
N#endif
N#if __ATOMIC_ALWAYS_LOCK_FREE(8)
X#if (((8) == 1 ? (7 & 0x01) : (8) == 2 ? (7 & 0x02) : (8) == 4 ? (7 & 0x04) : (8) == 8 ? (7 & 0x08) : 0) != 0)
S#if __ARM_FEATURE_LDREX
S__TI_ATOMIC_LOAD_8(uint64_t)
S__TI_ATOMIC_STORE_8(uint64_t)
S#else
S__TI_ATOMIC_LOAD_N(8, uint64_t)
S__TI_ATOMIC_STORE_N(8, uint64_t)
S#endif
S__TI_ATOMIC_N(8, uint64_t)
N#endif
N
N/* Match libatomic - drop the (4th parameter) strong/weak flag */
N#define __atomic_compare_exchange(ptr, expected, desired, weak, suc, fail)\
N   __atomic_compare_exchange(ptr, expected, desired, suc, fail)
X#define __atomic_compare_exchange(ptr, expected, desired, weak, suc, fail)   __atomic_compare_exchange(ptr, expected, desired, suc, fail)
N
N#define __atomic_compare_exchange_n(ptr, expected, desired, weak, suc, fail)\
N   __atomic_compare_exchange_n(ptr, expected, desired, suc, fail)
X#define __atomic_compare_exchange_n(ptr, expected, desired, weak, suc, fail)   __atomic_compare_exchange_n(ptr, expected, desired, suc, fail)
N
N#undef __ti_release_fence
N#undef __ti_aqcuire_fence
N#undef __TI_ATOMIC_LOAD_N
N#undef __TI_ATOMIC_LOAD_8
N#undef __TI_ATOMIC_STORE_N
N#undef __TI_ATOMIC_STORE_8
N#undef __TI_ATOMIC_N
N#undef __TI_ATOMIC_EXCHANGE_N
N#undef __TI_ATOMIC_COMPARE_EXCHANGE_N
N#undef __TI_ATOMIC_RMW
N#undef __LDREX1
N#undef __LDREX2
N#undef __LDREX4
N#undef __LDREX8
N#undef __STREX1
N#undef __STREX2
N#undef __STREX4
N#undef __STREX8
N#undef __CLREX
N#undef __TI_ATOMIC_FUNC
N#undef __disable_interrupts
N#undef __restore_interrupts
N
N#endif /* __ATOMICHDR */
L 561 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/atomic" 2
N#endif
N
N#if _LIBCPP_STD_VER > 14
X#if 14 > 14
S# define __cpp_lib_atomic_is_always_lock_free 201603L
N#endif
N
N#define _LIBCPP_CHECK_STORE_MEMORY_ORDER(__m) \
N  _LIBCPP_DIAGNOSE_WARNING(__m == memory_order_consume || \
N                           __m == memory_order_acquire || \
N                           __m == memory_order_acq_rel,   \
N                        "memory order argument to atomic operation is invalid")
X#define _LIBCPP_CHECK_STORE_MEMORY_ORDER(__m)   _LIBCPP_DIAGNOSE_WARNING(__m == memory_order_consume ||                            __m == memory_order_acquire ||                            __m == memory_order_acq_rel,                           "memory order argument to atomic operation is invalid")
N
N#define _LIBCPP_CHECK_LOAD_MEMORY_ORDER(__m) \
N  _LIBCPP_DIAGNOSE_WARNING(__m == memory_order_release || \
N                           __m == memory_order_acq_rel,   \
N                        "memory order argument to atomic operation is invalid")
X#define _LIBCPP_CHECK_LOAD_MEMORY_ORDER(__m)   _LIBCPP_DIAGNOSE_WARNING(__m == memory_order_release ||                            __m == memory_order_acq_rel,                           "memory order argument to atomic operation is invalid")
N
N#define _LIBCPP_CHECK_EXCHANGE_MEMORY_ORDER(__m, __f) \
N  _LIBCPP_DIAGNOSE_WARNING(__f == memory_order_release || \
N                           __f == memory_order_acq_rel,   \
N                        "memory order argument to atomic operation is invalid")
X#define _LIBCPP_CHECK_EXCHANGE_MEMORY_ORDER(__m, __f)   _LIBCPP_DIAGNOSE_WARNING(__f == memory_order_release ||                            __f == memory_order_acq_rel,                           "memory order argument to atomic operation is invalid")
N
N_LIBCPP_BEGIN_NAMESPACE_STD
Xnamespace std { inline namespace __2 {
N
Ntypedef enum __attribute__((packed)) memory_order
N{
N    memory_order_relaxed, memory_order_consume, memory_order_acquire,
N    memory_order_release, memory_order_acq_rel, memory_order_seq_cst
N} memory_order;
N
N#if defined(_LIBCPP_HAS_GCC_ATOMIC_IMP)
X#if 1L
Nnamespace __gcc_atomic {
Ntemplate <typename _Tp>
Nstruct __gcc_atomic_t {
N
N#if _GNUC_VER >= 501
X#if 0 >= 501
S    static_assert(is_trivially_copyable<_Tp>::value,
S      "std::atomic<Tp> requires that 'Tp' be a trivially copyable type");
N#endif
N
N  _LIBCPP_INLINE_VISIBILITY
X  __attribute__ ((__always_inline__))
N#ifndef _LIBCPP_CXX03_LANG
N    __gcc_atomic_t() _NOEXCEPT = default;
X    __gcc_atomic_t() noexcept = default;
N#else
S    __gcc_atomic_t() _NOEXCEPT : __a_value() {}
N#endif // _LIBCPP_CXX03_LANG
N  _LIBCPP_CONSTEXPR explicit __gcc_atomic_t(_Tp value) _NOEXCEPT
X  constexpr explicit __gcc_atomic_t(_Tp value) noexcept
N    : __a_value(value) {}
N  _Tp __a_value;
N};
N#define _Atomic(x) __gcc_atomic::__gcc_atomic_t<x>
N
Ntemplate <typename _Tp> _Tp __create();
N
Ntemplate <typename _Tp, typename _Td>
Ntypename enable_if<sizeof(_Tp()->__a_value = __create<_Td>()), char>::type
N    __test_atomic_assignable(int);
Ntemplate <typename _Tp, typename _Up>
N__two __test_atomic_assignable(...);
N
Ntemplate <typename _Tp, typename _Td>
Nstruct __can_assign {
N  static const bool value =
N      sizeof(__test_atomic_assignable<_Tp, _Td>(1)) == sizeof(char);
N};
N
Nstatic inline _LIBCPP_CONSTEXPR int __to_gcc_order(memory_order __order) {
Xstatic inline constexpr int __to_gcc_order(memory_order __order) {
N  // Avoid switch statement to make this a constexpr.
N  return __order == memory_order_relaxed ? __ATOMIC_RELAXED:
X  return __order == memory_order_relaxed ? 0:
N         (__order == memory_order_acquire ? __ATOMIC_ACQUIRE:
X         (__order == memory_order_acquire ? 2:
N          (__order == memory_order_release ? __ATOMIC_RELEASE:
X          (__order == memory_order_release ? 3:
N           (__order == memory_order_seq_cst ? __ATOMIC_SEQ_CST:
X           (__order == memory_order_seq_cst ? 5:
N            (__order == memory_order_acq_rel ? __ATOMIC_ACQ_REL:
X            (__order == memory_order_acq_rel ? 4:
N              __ATOMIC_CONSUME))));
X              1))));
N}
N
Nstatic inline _LIBCPP_CONSTEXPR int __to_gcc_failure_order(memory_order __order) {
Xstatic inline constexpr int __to_gcc_failure_order(memory_order __order) {
N  // Avoid switch statement to make this a constexpr.
N  return __order == memory_order_relaxed ? __ATOMIC_RELAXED:
X  return __order == memory_order_relaxed ? 0:
N         (__order == memory_order_acquire ? __ATOMIC_ACQUIRE:
X         (__order == memory_order_acquire ? 2:
N          (__order == memory_order_release ? __ATOMIC_RELAXED:
X          (__order == memory_order_release ? 0:
N           (__order == memory_order_seq_cst ? __ATOMIC_SEQ_CST:
X           (__order == memory_order_seq_cst ? 5:
N            (__order == memory_order_acq_rel ? __ATOMIC_ACQUIRE:
X            (__order == memory_order_acq_rel ? 2:
N              __ATOMIC_CONSUME))));
X              1))));
N}
N
N} // namespace __gcc_atomic
N
Ntemplate <typename _Tp>
Nstatic inline
Ntypename enable_if<
N    __gcc_atomic::__can_assign<volatile _Atomic(_Tp)*, _Tp>::value>::type
X    __gcc_atomic::__can_assign<volatile __gcc_atomic::__gcc_atomic_t<_Tp> *, _Tp>::value>::type
N__c11_atomic_init(volatile _Atomic(_Tp)* __a,  _Tp __val) {
X__c11_atomic_init(volatile __gcc_atomic::__gcc_atomic_t<_Tp> * __a,  _Tp __val) {
N  __a->__a_value = __val;
N}
N
Ntemplate <typename _Tp>
Nstatic inline
Ntypename enable_if<
N    !__gcc_atomic::__can_assign<volatile _Atomic(_Tp)*, _Tp>::value &&
X    !__gcc_atomic::__can_assign<volatile __gcc_atomic::__gcc_atomic_t<_Tp> *, _Tp>::value &&
N     __gcc_atomic::__can_assign<         _Atomic(_Tp)*, _Tp>::value>::type
X     __gcc_atomic::__can_assign<         __gcc_atomic::__gcc_atomic_t<_Tp> *, _Tp>::value>::type
N__c11_atomic_init(volatile _Atomic(_Tp)* __a,  _Tp __val) {
X__c11_atomic_init(volatile __gcc_atomic::__gcc_atomic_t<_Tp> * __a,  _Tp __val) {
N  // [atomics.types.generic]p1 guarantees _Tp is trivially copyable. Because
N  // the default operator= in an object is not volatile, a byte-by-byte copy
N  // is required.
N  volatile char* to = reinterpret_cast<volatile char*>(&__a->__a_value);
N  volatile char* end = to + sizeof(_Tp);
N  char* from = reinterpret_cast<char*>(&__val);
N  while (to != end) {
N    *to++ = *from++;
N  }
N}
N
Ntemplate <typename _Tp>
Nstatic inline void __c11_atomic_init(_Atomic(_Tp)* __a,  _Tp __val) {
Xstatic inline void __c11_atomic_init(__gcc_atomic::__gcc_atomic_t<_Tp> * __a,  _Tp __val) {
N  __a->__a_value = __val;
N}
N
Nstatic inline void __c11_atomic_thread_fence(memory_order __order) {
N  __atomic_thread_fence(__gcc_atomic::__to_gcc_order(__order));
X  _dmb();
N}
N
Nstatic inline void __c11_atomic_signal_fence(memory_order __order) {
N  __atomic_signal_fence(__gcc_atomic::__to_gcc_order(__order));
X  _dmb();
N}
N
Ntemplate <typename _Tp>
Nstatic inline void __c11_atomic_store(volatile _Atomic(_Tp)* __a,  _Tp __val,
Xstatic inline void __c11_atomic_store(volatile __gcc_atomic::__gcc_atomic_t<_Tp> * __a,  _Tp __val,
N                                      memory_order __order) {
N  return __atomic_store(&__a->__a_value, &__val,
N                        __gcc_atomic::__to_gcc_order(__order));
N}
N
Ntemplate <typename _Tp>
Nstatic inline void __c11_atomic_store(_Atomic(_Tp)* __a,  _Tp __val,
Xstatic inline void __c11_atomic_store(__gcc_atomic::__gcc_atomic_t<_Tp> * __a,  _Tp __val,
N                                      memory_order __order) {
N  __atomic_store(&__a->__a_value, &__val,
N                 __gcc_atomic::__to_gcc_order(__order));
N}
N
Ntemplate <typename _Tp>
Nstatic inline _Tp __c11_atomic_load(volatile _Atomic(_Tp)* __a,
Xstatic inline _Tp __c11_atomic_load(volatile __gcc_atomic::__gcc_atomic_t<_Tp> * __a,
N                                    memory_order __order) {
N  _Tp __ret;
N  __atomic_load(&__a->__a_value, &__ret,
N                __gcc_atomic::__to_gcc_order(__order));
N  return __ret;
N}
N
Ntemplate <typename _Tp>
Nstatic inline _Tp __c11_atomic_load(_Atomic(_Tp)* __a, memory_order __order) {
Xstatic inline _Tp __c11_atomic_load(__gcc_atomic::__gcc_atomic_t<_Tp> * __a, memory_order __order) {
N  _Tp __ret;
N  __atomic_load(&__a->__a_value, &__ret,
N                __gcc_atomic::__to_gcc_order(__order));
N  return __ret;
N}
N
Ntemplate <typename _Tp>
Nstatic inline _Tp __c11_atomic_exchange(volatile _Atomic(_Tp)* __a,
Xstatic inline _Tp __c11_atomic_exchange(volatile __gcc_atomic::__gcc_atomic_t<_Tp> * __a,
N                                        _Tp __value, memory_order __order) {
N  _Tp __ret;
N  __atomic_exchange(&__a->__a_value, &__value, &__ret,
N                    __gcc_atomic::__to_gcc_order(__order));
N  return __ret;
N}
N
Ntemplate <typename _Tp>
Nstatic inline _Tp __c11_atomic_exchange(_Atomic(_Tp)* __a, _Tp __value,
Xstatic inline _Tp __c11_atomic_exchange(__gcc_atomic::__gcc_atomic_t<_Tp> * __a, _Tp __value,
N                                        memory_order __order) {
N  _Tp __ret;
N  __atomic_exchange(&__a->__a_value, &__value, &__ret,
N                    __gcc_atomic::__to_gcc_order(__order));
N  return __ret;
N}
N
Ntemplate <typename _Tp>
Nstatic inline bool __c11_atomic_compare_exchange_strong(
N    volatile _Atomic(_Tp)* __a, _Tp* __expected, _Tp __value,
X    volatile __gcc_atomic::__gcc_atomic_t<_Tp> * __a, _Tp* __expected, _Tp __value,
N    memory_order __success, memory_order __failure) {
N  return __atomic_compare_exchange(&__a->__a_value, __expected, &__value,
N                                   false,
N                                   __gcc_atomic::__to_gcc_order(__success),
N                                   __gcc_atomic::__to_gcc_failure_order(__failure));
X  return __atomic_compare_exchange(&__a->__a_value, __expected, &__value, __gcc_atomic::__to_gcc_order(__success), __gcc_atomic::__to_gcc_failure_order(__failure));
N}
N
Ntemplate <typename _Tp>
Nstatic inline bool __c11_atomic_compare_exchange_strong(
N    _Atomic(_Tp)* __a, _Tp* __expected, _Tp __value, memory_order __success,
X    __gcc_atomic::__gcc_atomic_t<_Tp> * __a, _Tp* __expected, _Tp __value, memory_order __success,
N    memory_order __failure) {
N  return __atomic_compare_exchange(&__a->__a_value, __expected, &__value,
N                                   false,
N                                   __gcc_atomic::__to_gcc_order(__success),
N                                   __gcc_atomic::__to_gcc_failure_order(__failure));
X  return __atomic_compare_exchange(&__a->__a_value, __expected, &__value, __gcc_atomic::__to_gcc_order(__success), __gcc_atomic::__to_gcc_failure_order(__failure));
N}
N
Ntemplate <typename _Tp>
Nstatic inline bool __c11_atomic_compare_exchange_weak(
N    volatile _Atomic(_Tp)* __a, _Tp* __expected, _Tp __value,
X    volatile __gcc_atomic::__gcc_atomic_t<_Tp> * __a, _Tp* __expected, _Tp __value,
N    memory_order __success, memory_order __failure) {
N  return __atomic_compare_exchange(&__a->__a_value, __expected, &__value,
N                                   true,
N                                   __gcc_atomic::__to_gcc_order(__success),
N                                   __gcc_atomic::__to_gcc_failure_order(__failure));
X  return __atomic_compare_exchange(&__a->__a_value, __expected, &__value, __gcc_atomic::__to_gcc_order(__success), __gcc_atomic::__to_gcc_failure_order(__failure));
N}
N
Ntemplate <typename _Tp>
Nstatic inline bool __c11_atomic_compare_exchange_weak(
N    _Atomic(_Tp)* __a, _Tp* __expected, _Tp __value, memory_order __success,
X    __gcc_atomic::__gcc_atomic_t<_Tp> * __a, _Tp* __expected, _Tp __value, memory_order __success,
N    memory_order __failure) {
N  return __atomic_compare_exchange(&__a->__a_value, __expected, &__value,
N                                   true,
N                                   __gcc_atomic::__to_gcc_order(__success),
N                                   __gcc_atomic::__to_gcc_failure_order(__failure));
X  return __atomic_compare_exchange(&__a->__a_value, __expected, &__value, __gcc_atomic::__to_gcc_order(__success), __gcc_atomic::__to_gcc_failure_order(__failure));
N}
N
Ntemplate <typename _Tp>
Nstruct __skip_amt { enum __attribute__((packed)) {value = 1}; };
N
Ntemplate <typename _Tp>
Nstruct __skip_amt<_Tp*> { enum __attribute__((packed)) {value = sizeof(_Tp)}; };
N
N// FIXME: Haven't figured out what the spec says about using arrays with
N// atomic_fetch_add. Force a failure rather than creating bad behavior.
Ntemplate <typename _Tp>
Nstruct __skip_amt<_Tp[]> { };
Ntemplate <typename _Tp, int n>
Nstruct __skip_amt<_Tp[n]> { };
N
Ntemplate <typename _Tp, typename _Td>
Nstatic inline _Tp __c11_atomic_fetch_add(volatile _Atomic(_Tp)* __a,
Xstatic inline _Tp __c11_atomic_fetch_add(volatile __gcc_atomic::__gcc_atomic_t<_Tp> * __a,
N                                         _Td __delta, memory_order __order) {
N  return __atomic_fetch_add(&__a->__a_value, __delta * __skip_amt<_Tp>::value,
N                            __gcc_atomic::__to_gcc_order(__order));
N}
N
Ntemplate <typename _Tp, typename _Td>
Nstatic inline _Tp __c11_atomic_fetch_add(_Atomic(_Tp)* __a, _Td __delta,
Xstatic inline _Tp __c11_atomic_fetch_add(__gcc_atomic::__gcc_atomic_t<_Tp> * __a, _Td __delta,
N                                         memory_order __order) {
N  return __atomic_fetch_add(&__a->__a_value, __delta * __skip_amt<_Tp>::value,
N                            __gcc_atomic::__to_gcc_order(__order));
N}
N
Ntemplate <typename _Tp, typename _Td>
Nstatic inline _Tp __c11_atomic_fetch_sub(volatile _Atomic(_Tp)* __a,
Xstatic inline _Tp __c11_atomic_fetch_sub(volatile __gcc_atomic::__gcc_atomic_t<_Tp> * __a,
N                                         _Td __delta, memory_order __order) {
N  return __atomic_fetch_sub(&__a->__a_value, __delta * __skip_amt<_Tp>::value,
N                            __gcc_atomic::__to_gcc_order(__order));
N}
N
Ntemplate <typename _Tp, typename _Td>
Nstatic inline _Tp __c11_atomic_fetch_sub(_Atomic(_Tp)* __a, _Td __delta,
Xstatic inline _Tp __c11_atomic_fetch_sub(__gcc_atomic::__gcc_atomic_t<_Tp> * __a, _Td __delta,
N                                         memory_order __order) {
N  return __atomic_fetch_sub(&__a->__a_value, __delta * __skip_amt<_Tp>::value,
N                            __gcc_atomic::__to_gcc_order(__order));
N}
N
Ntemplate <typename _Tp>
Nstatic inline _Tp __c11_atomic_fetch_and(volatile _Atomic(_Tp)* __a,
Xstatic inline _Tp __c11_atomic_fetch_and(volatile __gcc_atomic::__gcc_atomic_t<_Tp> * __a,
N                                         _Tp __pattern, memory_order __order) {
N  return __atomic_fetch_and(&__a->__a_value, __pattern,
N                            __gcc_atomic::__to_gcc_order(__order));
N}
N
Ntemplate <typename _Tp>
Nstatic inline _Tp __c11_atomic_fetch_and(_Atomic(_Tp)* __a,
Xstatic inline _Tp __c11_atomic_fetch_and(__gcc_atomic::__gcc_atomic_t<_Tp> * __a,
N                                         _Tp __pattern, memory_order __order) {
N  return __atomic_fetch_and(&__a->__a_value, __pattern,
N                            __gcc_atomic::__to_gcc_order(__order));
N}
N
Ntemplate <typename _Tp>
Nstatic inline _Tp __c11_atomic_fetch_or(volatile _Atomic(_Tp)* __a,
Xstatic inline _Tp __c11_atomic_fetch_or(volatile __gcc_atomic::__gcc_atomic_t<_Tp> * __a,
N                                        _Tp __pattern, memory_order __order) {
N  return __atomic_fetch_or(&__a->__a_value, __pattern,
N                           __gcc_atomic::__to_gcc_order(__order));
N}
N
Ntemplate <typename _Tp>
Nstatic inline _Tp __c11_atomic_fetch_or(_Atomic(_Tp)* __a, _Tp __pattern,
Xstatic inline _Tp __c11_atomic_fetch_or(__gcc_atomic::__gcc_atomic_t<_Tp> * __a, _Tp __pattern,
N                                        memory_order __order) {
N  return __atomic_fetch_or(&__a->__a_value, __pattern,
N                           __gcc_atomic::__to_gcc_order(__order));
N}
N
Ntemplate <typename _Tp>
Nstatic inline _Tp __c11_atomic_fetch_xor(volatile _Atomic(_Tp)* __a,
Xstatic inline _Tp __c11_atomic_fetch_xor(volatile __gcc_atomic::__gcc_atomic_t<_Tp> * __a,
N                                         _Tp __pattern, memory_order __order) {
N  return __atomic_fetch_xor(&__a->__a_value, __pattern,
N                            __gcc_atomic::__to_gcc_order(__order));
N}
N
Ntemplate <typename _Tp>
Nstatic inline _Tp __c11_atomic_fetch_xor(_Atomic(_Tp)* __a, _Tp __pattern,
Xstatic inline _Tp __c11_atomic_fetch_xor(__gcc_atomic::__gcc_atomic_t<_Tp> * __a, _Tp __pattern,
N                                         memory_order __order) {
N  return __atomic_fetch_xor(&__a->__a_value, __pattern,
N                            __gcc_atomic::__to_gcc_order(__order));
N}
N#endif // _LIBCPP_HAS_GCC_ATOMIC_IMP
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_Tp
Nkill_dependency(_Tp __y) _NOEXCEPT
Xkill_dependency(_Tp __y) noexcept
N{
N    return __y;
N}
N
N#if defined(__CLANG_ATOMIC_BOOL_LOCK_FREE)
X#if 0L
S# define ATOMIC_BOOL_LOCK_FREE      __CLANG_ATOMIC_BOOL_LOCK_FREE
S# define ATOMIC_CHAR_LOCK_FREE      __CLANG_ATOMIC_CHAR_LOCK_FREE
S# define ATOMIC_CHAR16_T_LOCK_FREE  __CLANG_ATOMIC_CHAR16_T_LOCK_FREE
S# define ATOMIC_CHAR32_T_LOCK_FREE  __CLANG_ATOMIC_CHAR32_T_LOCK_FREE
S# define ATOMIC_WCHAR_T_LOCK_FREE   __CLANG_ATOMIC_WCHAR_T_LOCK_FREE
S# define ATOMIC_SHORT_LOCK_FREE     __CLANG_ATOMIC_SHORT_LOCK_FREE
S# define ATOMIC_INT_LOCK_FREE       __CLANG_ATOMIC_INT_LOCK_FREE
S# define ATOMIC_LONG_LOCK_FREE      __CLANG_ATOMIC_LONG_LOCK_FREE
S# define ATOMIC_LLONG_LOCK_FREE     __CLANG_ATOMIC_LLONG_LOCK_FREE
S# define ATOMIC_POINTER_LOCK_FREE   __CLANG_ATOMIC_POINTER_LOCK_FREE
N#else
N# define ATOMIC_BOOL_LOCK_FREE      __GCC_ATOMIC_BOOL_LOCK_FREE
N# define ATOMIC_CHAR_LOCK_FREE      __GCC_ATOMIC_CHAR_LOCK_FREE
N# define ATOMIC_CHAR16_T_LOCK_FREE  __GCC_ATOMIC_CHAR16_T_LOCK_FREE
N# define ATOMIC_CHAR32_T_LOCK_FREE  __GCC_ATOMIC_CHAR32_T_LOCK_FREE
N# define ATOMIC_WCHAR_T_LOCK_FREE   __GCC_ATOMIC_WCHAR_T_LOCK_FREE
N# define ATOMIC_SHORT_LOCK_FREE     __GCC_ATOMIC_SHORT_LOCK_FREE
N# define ATOMIC_INT_LOCK_FREE       __GCC_ATOMIC_INT_LOCK_FREE
N# define ATOMIC_LONG_LOCK_FREE      __GCC_ATOMIC_LONG_LOCK_FREE
N# define ATOMIC_LLONG_LOCK_FREE     __GCC_ATOMIC_LLONG_LOCK_FREE
N# define ATOMIC_POINTER_LOCK_FREE   __GCC_ATOMIC_POINTER_LOCK_FREE
N#endif
N
N// general atomic<T>
N
Ntemplate <class _Tp, bool = is_integral<_Tp>::value && !is_same<_Tp, bool>::value>
Nstruct __atomic_base  // false
N{
N    mutable _Atomic(_Tp) __a_;
X    mutable __gcc_atomic::__gcc_atomic_t<_Tp> __a_;
N
N#if defined(__cpp_lib_atomic_is_always_lock_free)
X#if 0L
S  static _LIBCPP_CONSTEXPR bool is_always_lock_free = __atomic_always_lock_free(sizeof(__a_), 0);
N#endif
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    bool is_lock_free() const volatile _NOEXCEPT
X    bool is_lock_free() const volatile noexcept
N    {
N#if defined(_LIBCPP_HAS_C_ATOMIC_IMP)
X#if 0L
S    return __c11_atomic_is_lock_free(sizeof(_Tp));
N#else
N    return __atomic_is_lock_free(sizeof(_Tp), 0);
N#endif
N    }
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    bool is_lock_free() const _NOEXCEPT
X    bool is_lock_free() const noexcept
N        {return static_cast<__atomic_base const volatile*>(this)->is_lock_free();}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    void store(_Tp __d, memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
X    void store(_Tp __d, memory_order __m = memory_order_seq_cst) volatile noexcept
N      _LIBCPP_CHECK_STORE_MEMORY_ORDER(__m)
X      
N        {__c11_atomic_store(&__a_, __d, __m);}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    void store(_Tp __d, memory_order __m = memory_order_seq_cst) _NOEXCEPT
X    void store(_Tp __d, memory_order __m = memory_order_seq_cst) noexcept
N      _LIBCPP_CHECK_STORE_MEMORY_ORDER(__m)
X      
N        {__c11_atomic_store(&__a_, __d, __m);}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _Tp load(memory_order __m = memory_order_seq_cst) const volatile _NOEXCEPT
X    _Tp load(memory_order __m = memory_order_seq_cst) const volatile noexcept
N      _LIBCPP_CHECK_LOAD_MEMORY_ORDER(__m)
X      
N        {return __c11_atomic_load(&__a_, __m);}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _Tp load(memory_order __m = memory_order_seq_cst) const _NOEXCEPT
X    _Tp load(memory_order __m = memory_order_seq_cst) const noexcept
N      _LIBCPP_CHECK_LOAD_MEMORY_ORDER(__m)
X      
N        {return __c11_atomic_load(&__a_, __m);}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    operator _Tp() const volatile _NOEXCEPT {return load();}
X    operator _Tp() const volatile noexcept {return load();}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    operator _Tp() const _NOEXCEPT          {return load();}
X    operator _Tp() const noexcept          {return load();}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _Tp exchange(_Tp __d, memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
X    _Tp exchange(_Tp __d, memory_order __m = memory_order_seq_cst) volatile noexcept
N        {return __c11_atomic_exchange(&__a_, __d, __m);}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _Tp exchange(_Tp __d, memory_order __m = memory_order_seq_cst) _NOEXCEPT
X    _Tp exchange(_Tp __d, memory_order __m = memory_order_seq_cst) noexcept
N        {return __c11_atomic_exchange(&__a_, __d, __m);}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    bool compare_exchange_weak(_Tp& __e, _Tp __d,
N                               memory_order __s, memory_order __f) volatile _NOEXCEPT
X                               memory_order __s, memory_order __f) volatile noexcept
N      _LIBCPP_CHECK_EXCHANGE_MEMORY_ORDER(__s, __f)
X      
N        {return __c11_atomic_compare_exchange_weak(&__a_, &__e, __d, __s, __f);}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    bool compare_exchange_weak(_Tp& __e, _Tp __d,
N                               memory_order __s, memory_order __f) _NOEXCEPT
X                               memory_order __s, memory_order __f) noexcept
N      _LIBCPP_CHECK_EXCHANGE_MEMORY_ORDER(__s, __f)
X      
N        {return __c11_atomic_compare_exchange_weak(&__a_, &__e, __d, __s, __f);}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    bool compare_exchange_strong(_Tp& __e, _Tp __d,
N                                 memory_order __s, memory_order __f) volatile _NOEXCEPT
X                                 memory_order __s, memory_order __f) volatile noexcept
N      _LIBCPP_CHECK_EXCHANGE_MEMORY_ORDER(__s, __f)
X      
N        {return __c11_atomic_compare_exchange_strong(&__a_, &__e, __d, __s, __f);}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    bool compare_exchange_strong(_Tp& __e, _Tp __d,
N                                 memory_order __s, memory_order __f) _NOEXCEPT
X                                 memory_order __s, memory_order __f) noexcept
N      _LIBCPP_CHECK_EXCHANGE_MEMORY_ORDER(__s, __f)
X      
N        {return __c11_atomic_compare_exchange_strong(&__a_, &__e, __d, __s, __f);}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    bool compare_exchange_weak(_Tp& __e, _Tp __d,
N                              memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
X                              memory_order __m = memory_order_seq_cst) volatile noexcept
N        {return __c11_atomic_compare_exchange_weak(&__a_, &__e, __d, __m, __m);}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    bool compare_exchange_weak(_Tp& __e, _Tp __d,
N                               memory_order __m = memory_order_seq_cst) _NOEXCEPT
X                               memory_order __m = memory_order_seq_cst) noexcept
N        {return __c11_atomic_compare_exchange_weak(&__a_, &__e, __d, __m, __m);}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    bool compare_exchange_strong(_Tp& __e, _Tp __d,
N                              memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
X                              memory_order __m = memory_order_seq_cst) volatile noexcept
N        {return __c11_atomic_compare_exchange_strong(&__a_, &__e, __d, __m, __m);}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    bool compare_exchange_strong(_Tp& __e, _Tp __d,
N                                 memory_order __m = memory_order_seq_cst) _NOEXCEPT
X                                 memory_order __m = memory_order_seq_cst) noexcept
N        {return __c11_atomic_compare_exchange_strong(&__a_, &__e, __d, __m, __m);}
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N#ifndef _LIBCPP_CXX03_LANG
N    __atomic_base() _NOEXCEPT = default;
X    __atomic_base() noexcept = default;
N#else
S    __atomic_base() _NOEXCEPT : __a_() {}
N#endif // _LIBCPP_CXX03_LANG
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _LIBCPP_CONSTEXPR __atomic_base(_Tp __d) _NOEXCEPT : __a_(__d) {}
X    constexpr __atomic_base(_Tp __d) noexcept : __a_(__d) {}
N#ifndef _LIBCPP_CXX03_LANG
N    __atomic_base(const __atomic_base&) = delete;
N    __atomic_base& operator=(const __atomic_base&) = delete;
N    __atomic_base& operator=(const __atomic_base&) volatile = delete;
N#else
Sprivate:
S    __atomic_base(const __atomic_base&);
S    __atomic_base& operator=(const __atomic_base&);
S    __atomic_base& operator=(const __atomic_base&) volatile;
N#endif
N};
N
N#if defined(__cpp_lib_atomic_is_always_lock_free)
X#if 0L
Stemplate <class _Tp, bool __b>
S_LIBCPP_CONSTEXPR bool __atomic_base<_Tp, __b>::is_always_lock_free;
N#endif
N
N// atomic<Integral>
N
Ntemplate <class _Tp>
Nstruct __atomic_base<_Tp, true>
N    : public __atomic_base<_Tp, false>
N{
N    typedef __atomic_base<_Tp, false> __base;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    __atomic_base() _NOEXCEPT _LIBCPP_DEFAULT
X    __atomic_base() noexcept = default;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _LIBCPP_CONSTEXPR __atomic_base(_Tp __d) _NOEXCEPT : __base(__d) {}
X    constexpr __atomic_base(_Tp __d) noexcept : __base(__d) {}
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _Tp fetch_add(_Tp __op, memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
X    _Tp fetch_add(_Tp __op, memory_order __m = memory_order_seq_cst) volatile noexcept
N        {return __c11_atomic_fetch_add(&this->__a_, __op, __m);}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _Tp fetch_add(_Tp __op, memory_order __m = memory_order_seq_cst) _NOEXCEPT
X    _Tp fetch_add(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept
N        {return __c11_atomic_fetch_add(&this->__a_, __op, __m);}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _Tp fetch_sub(_Tp __op, memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
X    _Tp fetch_sub(_Tp __op, memory_order __m = memory_order_seq_cst) volatile noexcept
N        {return __c11_atomic_fetch_sub(&this->__a_, __op, __m);}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _Tp fetch_sub(_Tp __op, memory_order __m = memory_order_seq_cst) _NOEXCEPT
X    _Tp fetch_sub(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept
N        {return __c11_atomic_fetch_sub(&this->__a_, __op, __m);}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _Tp fetch_and(_Tp __op, memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
X    _Tp fetch_and(_Tp __op, memory_order __m = memory_order_seq_cst) volatile noexcept
N        {return __c11_atomic_fetch_and(&this->__a_, __op, __m);}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _Tp fetch_and(_Tp __op, memory_order __m = memory_order_seq_cst) _NOEXCEPT
X    _Tp fetch_and(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept
N        {return __c11_atomic_fetch_and(&this->__a_, __op, __m);}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _Tp fetch_or(_Tp __op, memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
X    _Tp fetch_or(_Tp __op, memory_order __m = memory_order_seq_cst) volatile noexcept
N        {return __c11_atomic_fetch_or(&this->__a_, __op, __m);}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _Tp fetch_or(_Tp __op, memory_order __m = memory_order_seq_cst) _NOEXCEPT
X    _Tp fetch_or(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept
N        {return __c11_atomic_fetch_or(&this->__a_, __op, __m);}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _Tp fetch_xor(_Tp __op, memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
X    _Tp fetch_xor(_Tp __op, memory_order __m = memory_order_seq_cst) volatile noexcept
N        {return __c11_atomic_fetch_xor(&this->__a_, __op, __m);}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _Tp fetch_xor(_Tp __op, memory_order __m = memory_order_seq_cst) _NOEXCEPT
X    _Tp fetch_xor(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept
N        {return __c11_atomic_fetch_xor(&this->__a_, __op, __m);}
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _Tp operator++(int) volatile _NOEXCEPT      {return fetch_add(_Tp(1));}
X    _Tp operator++(int) volatile noexcept      {return fetch_add(_Tp(1));}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _Tp operator++(int) _NOEXCEPT               {return fetch_add(_Tp(1));}
X    _Tp operator++(int) noexcept               {return fetch_add(_Tp(1));}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _Tp operator--(int) volatile _NOEXCEPT      {return fetch_sub(_Tp(1));}
X    _Tp operator--(int) volatile noexcept      {return fetch_sub(_Tp(1));}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _Tp operator--(int) _NOEXCEPT               {return fetch_sub(_Tp(1));}
X    _Tp operator--(int) noexcept               {return fetch_sub(_Tp(1));}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _Tp operator++() volatile _NOEXCEPT         {return fetch_add(_Tp(1)) + _Tp(1);}
X    _Tp operator++() volatile noexcept         {return fetch_add(_Tp(1)) + _Tp(1);}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _Tp operator++() _NOEXCEPT                  {return fetch_add(_Tp(1)) + _Tp(1);}
X    _Tp operator++() noexcept                  {return fetch_add(_Tp(1)) + _Tp(1);}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _Tp operator--() volatile _NOEXCEPT         {return fetch_sub(_Tp(1)) - _Tp(1);}
X    _Tp operator--() volatile noexcept         {return fetch_sub(_Tp(1)) - _Tp(1);}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _Tp operator--() _NOEXCEPT                  {return fetch_sub(_Tp(1)) - _Tp(1);}
X    _Tp operator--() noexcept                  {return fetch_sub(_Tp(1)) - _Tp(1);}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _Tp operator+=(_Tp __op) volatile _NOEXCEPT {return fetch_add(__op) + __op;}
X    _Tp operator+=(_Tp __op) volatile noexcept {return fetch_add(__op) + __op;}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _Tp operator+=(_Tp __op) _NOEXCEPT          {return fetch_add(__op) + __op;}
X    _Tp operator+=(_Tp __op) noexcept          {return fetch_add(__op) + __op;}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _Tp operator-=(_Tp __op) volatile _NOEXCEPT {return fetch_sub(__op) - __op;}
X    _Tp operator-=(_Tp __op) volatile noexcept {return fetch_sub(__op) - __op;}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _Tp operator-=(_Tp __op) _NOEXCEPT          {return fetch_sub(__op) - __op;}
X    _Tp operator-=(_Tp __op) noexcept          {return fetch_sub(__op) - __op;}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _Tp operator&=(_Tp __op) volatile _NOEXCEPT {return fetch_and(__op) & __op;}
X    _Tp operator&=(_Tp __op) volatile noexcept {return fetch_and(__op) & __op;}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _Tp operator&=(_Tp __op) _NOEXCEPT          {return fetch_and(__op) & __op;}
X    _Tp operator&=(_Tp __op) noexcept          {return fetch_and(__op) & __op;}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _Tp operator|=(_Tp __op) volatile _NOEXCEPT {return fetch_or(__op) | __op;}
X    _Tp operator|=(_Tp __op) volatile noexcept {return fetch_or(__op) | __op;}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _Tp operator|=(_Tp __op) _NOEXCEPT          {return fetch_or(__op) | __op;}
X    _Tp operator|=(_Tp __op) noexcept          {return fetch_or(__op) | __op;}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _Tp operator^=(_Tp __op) volatile _NOEXCEPT {return fetch_xor(__op) ^ __op;}
X    _Tp operator^=(_Tp __op) volatile noexcept {return fetch_xor(__op) ^ __op;}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _Tp operator^=(_Tp __op) _NOEXCEPT          {return fetch_xor(__op) ^ __op;}
X    _Tp operator^=(_Tp __op) noexcept          {return fetch_xor(__op) ^ __op;}
N};
N
N// atomic<T>
N
Ntemplate <class _Tp>
Nstruct atomic
N    : public __atomic_base<_Tp>
N{
N    typedef __atomic_base<_Tp> __base;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    atomic() _NOEXCEPT _LIBCPP_DEFAULT
X    atomic() noexcept = default;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _LIBCPP_CONSTEXPR atomic(_Tp __d) _NOEXCEPT : __base(__d) {}
X    constexpr atomic(_Tp __d) noexcept : __base(__d) {}
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _Tp operator=(_Tp __d) volatile _NOEXCEPT
X    _Tp operator=(_Tp __d) volatile noexcept
N        {__base::store(__d); return __d;}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _Tp operator=(_Tp __d) _NOEXCEPT
X    _Tp operator=(_Tp __d) noexcept
N        {__base::store(__d); return __d;}
N};
N
N// atomic<T*>
N
Ntemplate <class _Tp>
Nstruct atomic<_Tp*>
N    : public __atomic_base<_Tp*>
N{
N    typedef __atomic_base<_Tp*> __base;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    atomic() _NOEXCEPT _LIBCPP_DEFAULT
X    atomic() noexcept = default;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _LIBCPP_CONSTEXPR atomic(_Tp* __d) _NOEXCEPT : __base(__d) {}
X    constexpr atomic(_Tp* __d) noexcept : __base(__d) {}
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _Tp* operator=(_Tp* __d) volatile _NOEXCEPT
X    _Tp* operator=(_Tp* __d) volatile noexcept
N        {__base::store(__d); return __d;}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _Tp* operator=(_Tp* __d) _NOEXCEPT
X    _Tp* operator=(_Tp* __d) noexcept
N        {__base::store(__d); return __d;}
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _Tp* fetch_add(ptrdiff_t __op, memory_order __m = memory_order_seq_cst)
N                                                                        volatile _NOEXCEPT
X                                                                        volatile noexcept
N        {return __c11_atomic_fetch_add(&this->__a_, __op, __m);}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _Tp* fetch_add(ptrdiff_t __op, memory_order __m = memory_order_seq_cst) _NOEXCEPT
X    _Tp* fetch_add(ptrdiff_t __op, memory_order __m = memory_order_seq_cst) noexcept
N        {return __c11_atomic_fetch_add(&this->__a_, __op, __m);}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _Tp* fetch_sub(ptrdiff_t __op, memory_order __m = memory_order_seq_cst)
N                                                                        volatile _NOEXCEPT
X                                                                        volatile noexcept
N        {return __c11_atomic_fetch_sub(&this->__a_, __op, __m);}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _Tp* fetch_sub(ptrdiff_t __op, memory_order __m = memory_order_seq_cst) _NOEXCEPT
X    _Tp* fetch_sub(ptrdiff_t __op, memory_order __m = memory_order_seq_cst) noexcept
N        {return __c11_atomic_fetch_sub(&this->__a_, __op, __m);}
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _Tp* operator++(int) volatile _NOEXCEPT            {return fetch_add(1);}
X    _Tp* operator++(int) volatile noexcept            {return fetch_add(1);}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _Tp* operator++(int) _NOEXCEPT                     {return fetch_add(1);}
X    _Tp* operator++(int) noexcept                     {return fetch_add(1);}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _Tp* operator--(int) volatile _NOEXCEPT            {return fetch_sub(1);}
X    _Tp* operator--(int) volatile noexcept            {return fetch_sub(1);}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _Tp* operator--(int) _NOEXCEPT                     {return fetch_sub(1);}
X    _Tp* operator--(int) noexcept                     {return fetch_sub(1);}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _Tp* operator++() volatile _NOEXCEPT               {return fetch_add(1) + 1;}
X    _Tp* operator++() volatile noexcept               {return fetch_add(1) + 1;}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _Tp* operator++() _NOEXCEPT                        {return fetch_add(1) + 1;}
X    _Tp* operator++() noexcept                        {return fetch_add(1) + 1;}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _Tp* operator--() volatile _NOEXCEPT               {return fetch_sub(1) - 1;}
X    _Tp* operator--() volatile noexcept               {return fetch_sub(1) - 1;}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _Tp* operator--() _NOEXCEPT                        {return fetch_sub(1) - 1;}
X    _Tp* operator--() noexcept                        {return fetch_sub(1) - 1;}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _Tp* operator+=(ptrdiff_t __op) volatile _NOEXCEPT {return fetch_add(__op) + __op;}
X    _Tp* operator+=(ptrdiff_t __op) volatile noexcept {return fetch_add(__op) + __op;}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _Tp* operator+=(ptrdiff_t __op) _NOEXCEPT          {return fetch_add(__op) + __op;}
X    _Tp* operator+=(ptrdiff_t __op) noexcept          {return fetch_add(__op) + __op;}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _Tp* operator-=(ptrdiff_t __op) volatile _NOEXCEPT {return fetch_sub(__op) - __op;}
X    _Tp* operator-=(ptrdiff_t __op) volatile noexcept {return fetch_sub(__op) - __op;}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _Tp* operator-=(ptrdiff_t __op) _NOEXCEPT          {return fetch_sub(__op) - __op;}
X    _Tp* operator-=(ptrdiff_t __op) noexcept          {return fetch_sub(__op) - __op;}
N};
N
N// atomic_is_lock_free
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Natomic_is_lock_free(const volatile atomic<_Tp>* __o) _NOEXCEPT
Xatomic_is_lock_free(const volatile atomic<_Tp>* __o) noexcept
N{
N    return __o->is_lock_free();
N}
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Natomic_is_lock_free(const atomic<_Tp>* __o) _NOEXCEPT
Xatomic_is_lock_free(const atomic<_Tp>* __o) noexcept
N{
N    return __o->is_lock_free();
N}
N
N// atomic_init
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Natomic_init(volatile atomic<_Tp>* __o, _Tp __d) _NOEXCEPT
Xatomic_init(volatile atomic<_Tp>* __o, _Tp __d) noexcept
N{
N    __c11_atomic_init(&__o->__a_, __d);
N}
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Natomic_init(atomic<_Tp>* __o, _Tp __d) _NOEXCEPT
Xatomic_init(atomic<_Tp>* __o, _Tp __d) noexcept
N{
N    __c11_atomic_init(&__o->__a_, __d);
N}
N
N// atomic_store
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Natomic_store(volatile atomic<_Tp>* __o, _Tp __d) _NOEXCEPT
Xatomic_store(volatile atomic<_Tp>* __o, _Tp __d) noexcept
N{
N    __o->store(__d);
N}
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Natomic_store(atomic<_Tp>* __o, _Tp __d) _NOEXCEPT
Xatomic_store(atomic<_Tp>* __o, _Tp __d) noexcept
N{
N    __o->store(__d);
N}
N
N// atomic_store_explicit
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Natomic_store_explicit(volatile atomic<_Tp>* __o, _Tp __d, memory_order __m) _NOEXCEPT
Xatomic_store_explicit(volatile atomic<_Tp>* __o, _Tp __d, memory_order __m) noexcept
N  _LIBCPP_CHECK_STORE_MEMORY_ORDER(__m)
X  
N{
N    __o->store(__d, __m);
N}
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Natomic_store_explicit(atomic<_Tp>* __o, _Tp __d, memory_order __m) _NOEXCEPT
Xatomic_store_explicit(atomic<_Tp>* __o, _Tp __d, memory_order __m) noexcept
N  _LIBCPP_CHECK_STORE_MEMORY_ORDER(__m)
X  
N{
N    __o->store(__d, __m);
N}
N
N// atomic_load
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_Tp
Natomic_load(const volatile atomic<_Tp>* __o) _NOEXCEPT
Xatomic_load(const volatile atomic<_Tp>* __o) noexcept
N{
N    return __o->load();
N}
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_Tp
Natomic_load(const atomic<_Tp>* __o) _NOEXCEPT
Xatomic_load(const atomic<_Tp>* __o) noexcept
N{
N    return __o->load();
N}
N
N// atomic_load_explicit
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_Tp
Natomic_load_explicit(const volatile atomic<_Tp>* __o, memory_order __m) _NOEXCEPT
Xatomic_load_explicit(const volatile atomic<_Tp>* __o, memory_order __m) noexcept
N  _LIBCPP_CHECK_LOAD_MEMORY_ORDER(__m)
X  
N{
N    return __o->load(__m);
N}
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_Tp
Natomic_load_explicit(const atomic<_Tp>* __o, memory_order __m) _NOEXCEPT
Xatomic_load_explicit(const atomic<_Tp>* __o, memory_order __m) noexcept
N  _LIBCPP_CHECK_LOAD_MEMORY_ORDER(__m)
X  
N{
N    return __o->load(__m);
N}
N
N// atomic_exchange
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_Tp
Natomic_exchange(volatile atomic<_Tp>* __o, _Tp __d) _NOEXCEPT
Xatomic_exchange(volatile atomic<_Tp>* __o, _Tp __d) noexcept
N{
N    return __o->exchange(__d);
N}
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_Tp
Natomic_exchange(atomic<_Tp>* __o, _Tp __d) _NOEXCEPT
Xatomic_exchange(atomic<_Tp>* __o, _Tp __d) noexcept
N{
N    return __o->exchange(__d);
N}
N
N// atomic_exchange_explicit
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_Tp
Natomic_exchange_explicit(volatile atomic<_Tp>* __o, _Tp __d, memory_order __m) _NOEXCEPT
Xatomic_exchange_explicit(volatile atomic<_Tp>* __o, _Tp __d, memory_order __m) noexcept
N{
N    return __o->exchange(__d, __m);
N}
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_Tp
Natomic_exchange_explicit(atomic<_Tp>* __o, _Tp __d, memory_order __m) _NOEXCEPT
Xatomic_exchange_explicit(atomic<_Tp>* __o, _Tp __d, memory_order __m) noexcept
N{
N    return __o->exchange(__d, __m);
N}
N
N// atomic_compare_exchange_weak
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Natomic_compare_exchange_weak(volatile atomic<_Tp>* __o, _Tp* __e, _Tp __d) _NOEXCEPT
Xatomic_compare_exchange_weak(volatile atomic<_Tp>* __o, _Tp* __e, _Tp __d) noexcept
N{
N    return __o->compare_exchange_weak(*__e, __d);
N}
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Natomic_compare_exchange_weak(atomic<_Tp>* __o, _Tp* __e, _Tp __d) _NOEXCEPT
Xatomic_compare_exchange_weak(atomic<_Tp>* __o, _Tp* __e, _Tp __d) noexcept
N{
N    return __o->compare_exchange_weak(*__e, __d);
N}
N
N// atomic_compare_exchange_strong
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Natomic_compare_exchange_strong(volatile atomic<_Tp>* __o, _Tp* __e, _Tp __d) _NOEXCEPT
Xatomic_compare_exchange_strong(volatile atomic<_Tp>* __o, _Tp* __e, _Tp __d) noexcept
N{
N    return __o->compare_exchange_strong(*__e, __d);
N}
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Natomic_compare_exchange_strong(atomic<_Tp>* __o, _Tp* __e, _Tp __d) _NOEXCEPT
Xatomic_compare_exchange_strong(atomic<_Tp>* __o, _Tp* __e, _Tp __d) noexcept
N{
N    return __o->compare_exchange_strong(*__e, __d);
N}
N
N// atomic_compare_exchange_weak_explicit
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Natomic_compare_exchange_weak_explicit(volatile atomic<_Tp>* __o, _Tp* __e,
N                                      _Tp __d,
N                                      memory_order __s, memory_order __f) _NOEXCEPT
X                                      memory_order __s, memory_order __f) noexcept
N  _LIBCPP_CHECK_EXCHANGE_MEMORY_ORDER(__s, __f)
X  
N{
N    return __o->compare_exchange_weak(*__e, __d, __s, __f);
N}
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Natomic_compare_exchange_weak_explicit(atomic<_Tp>* __o, _Tp* __e, _Tp __d,
N                                      memory_order __s, memory_order __f) _NOEXCEPT
X                                      memory_order __s, memory_order __f) noexcept
N  _LIBCPP_CHECK_EXCHANGE_MEMORY_ORDER(__s, __f)
X  
N{
N    return __o->compare_exchange_weak(*__e, __d, __s, __f);
N}
N
N// atomic_compare_exchange_strong_explicit
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Natomic_compare_exchange_strong_explicit(volatile atomic<_Tp>* __o,
N                                        _Tp* __e, _Tp __d,
N                                        memory_order __s, memory_order __f) _NOEXCEPT
X                                        memory_order __s, memory_order __f) noexcept
N  _LIBCPP_CHECK_EXCHANGE_MEMORY_ORDER(__s, __f)
X  
N{
N    return __o->compare_exchange_strong(*__e, __d, __s, __f);
N}
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Natomic_compare_exchange_strong_explicit(atomic<_Tp>* __o, _Tp* __e,
N                                        _Tp __d,
N                                        memory_order __s, memory_order __f) _NOEXCEPT
X                                        memory_order __s, memory_order __f) noexcept
N  _LIBCPP_CHECK_EXCHANGE_MEMORY_ORDER(__s, __f)
X  
N{
N    return __o->compare_exchange_strong(*__e, __d, __s, __f);
N}
N
N// atomic_fetch_add
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename enable_if
N<
N    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
N    _Tp
N>::type
Natomic_fetch_add(volatile atomic<_Tp>* __o, _Tp __op) _NOEXCEPT
Xatomic_fetch_add(volatile atomic<_Tp>* __o, _Tp __op) noexcept
N{
N    return __o->fetch_add(__op);
N}
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename enable_if
N<
N    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
N    _Tp
N>::type
Natomic_fetch_add(atomic<_Tp>* __o, _Tp __op) _NOEXCEPT
Xatomic_fetch_add(atomic<_Tp>* __o, _Tp __op) noexcept
N{
N    return __o->fetch_add(__op);
N}
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_Tp*
Natomic_fetch_add(volatile atomic<_Tp*>* __o, ptrdiff_t __op) _NOEXCEPT
Xatomic_fetch_add(volatile atomic<_Tp*>* __o, ptrdiff_t __op) noexcept
N{
N    return __o->fetch_add(__op);
N}
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_Tp*
Natomic_fetch_add(atomic<_Tp*>* __o, ptrdiff_t __op) _NOEXCEPT
Xatomic_fetch_add(atomic<_Tp*>* __o, ptrdiff_t __op) noexcept
N{
N    return __o->fetch_add(__op);
N}
N
N// atomic_fetch_add_explicit
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename enable_if
N<
N    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
N    _Tp
N>::type
Natomic_fetch_add_explicit(volatile atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT
Xatomic_fetch_add_explicit(volatile atomic<_Tp>* __o, _Tp __op, memory_order __m) noexcept
N{
N    return __o->fetch_add(__op, __m);
N}
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename enable_if
N<
N    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
N    _Tp
N>::type
Natomic_fetch_add_explicit(atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT
Xatomic_fetch_add_explicit(atomic<_Tp>* __o, _Tp __op, memory_order __m) noexcept
N{
N    return __o->fetch_add(__op, __m);
N}
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_Tp*
Natomic_fetch_add_explicit(volatile atomic<_Tp*>* __o, ptrdiff_t __op,
N                          memory_order __m) _NOEXCEPT
X                          memory_order __m) noexcept
N{
N    return __o->fetch_add(__op, __m);
N}
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_Tp*
Natomic_fetch_add_explicit(atomic<_Tp*>* __o, ptrdiff_t __op, memory_order __m) _NOEXCEPT
Xatomic_fetch_add_explicit(atomic<_Tp*>* __o, ptrdiff_t __op, memory_order __m) noexcept
N{
N    return __o->fetch_add(__op, __m);
N}
N
N// atomic_fetch_sub
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename enable_if
N<
N    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
N    _Tp
N>::type
Natomic_fetch_sub(volatile atomic<_Tp>* __o, _Tp __op) _NOEXCEPT
Xatomic_fetch_sub(volatile atomic<_Tp>* __o, _Tp __op) noexcept
N{
N    return __o->fetch_sub(__op);
N}
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename enable_if
N<
N    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
N    _Tp
N>::type
Natomic_fetch_sub(atomic<_Tp>* __o, _Tp __op) _NOEXCEPT
Xatomic_fetch_sub(atomic<_Tp>* __o, _Tp __op) noexcept
N{
N    return __o->fetch_sub(__op);
N}
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_Tp*
Natomic_fetch_sub(volatile atomic<_Tp*>* __o, ptrdiff_t __op) _NOEXCEPT
Xatomic_fetch_sub(volatile atomic<_Tp*>* __o, ptrdiff_t __op) noexcept
N{
N    return __o->fetch_sub(__op);
N}
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_Tp*
Natomic_fetch_sub(atomic<_Tp*>* __o, ptrdiff_t __op) _NOEXCEPT
Xatomic_fetch_sub(atomic<_Tp*>* __o, ptrdiff_t __op) noexcept
N{
N    return __o->fetch_sub(__op);
N}
N
N// atomic_fetch_sub_explicit
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename enable_if
N<
N    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
N    _Tp
N>::type
Natomic_fetch_sub_explicit(volatile atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT
Xatomic_fetch_sub_explicit(volatile atomic<_Tp>* __o, _Tp __op, memory_order __m) noexcept
N{
N    return __o->fetch_sub(__op, __m);
N}
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename enable_if
N<
N    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
N    _Tp
N>::type
Natomic_fetch_sub_explicit(atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT
Xatomic_fetch_sub_explicit(atomic<_Tp>* __o, _Tp __op, memory_order __m) noexcept
N{
N    return __o->fetch_sub(__op, __m);
N}
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_Tp*
Natomic_fetch_sub_explicit(volatile atomic<_Tp*>* __o, ptrdiff_t __op,
N                          memory_order __m) _NOEXCEPT
X                          memory_order __m) noexcept
N{
N    return __o->fetch_sub(__op, __m);
N}
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_Tp*
Natomic_fetch_sub_explicit(atomic<_Tp*>* __o, ptrdiff_t __op, memory_order __m) _NOEXCEPT
Xatomic_fetch_sub_explicit(atomic<_Tp*>* __o, ptrdiff_t __op, memory_order __m) noexcept
N{
N    return __o->fetch_sub(__op, __m);
N}
N
N// atomic_fetch_and
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename enable_if
N<
N    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
N    _Tp
N>::type
Natomic_fetch_and(volatile atomic<_Tp>* __o, _Tp __op) _NOEXCEPT
Xatomic_fetch_and(volatile atomic<_Tp>* __o, _Tp __op) noexcept
N{
N    return __o->fetch_and(__op);
N}
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename enable_if
N<
N    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
N    _Tp
N>::type
Natomic_fetch_and(atomic<_Tp>* __o, _Tp __op) _NOEXCEPT
Xatomic_fetch_and(atomic<_Tp>* __o, _Tp __op) noexcept
N{
N    return __o->fetch_and(__op);
N}
N
N// atomic_fetch_and_explicit
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename enable_if
N<
N    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
N    _Tp
N>::type
Natomic_fetch_and_explicit(volatile atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT
Xatomic_fetch_and_explicit(volatile atomic<_Tp>* __o, _Tp __op, memory_order __m) noexcept
N{
N    return __o->fetch_and(__op, __m);
N}
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename enable_if
N<
N    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
N    _Tp
N>::type
Natomic_fetch_and_explicit(atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT
Xatomic_fetch_and_explicit(atomic<_Tp>* __o, _Tp __op, memory_order __m) noexcept
N{
N    return __o->fetch_and(__op, __m);
N}
N
N// atomic_fetch_or
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename enable_if
N<
N    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
N    _Tp
N>::type
Natomic_fetch_or(volatile atomic<_Tp>* __o, _Tp __op) _NOEXCEPT
Xatomic_fetch_or(volatile atomic<_Tp>* __o, _Tp __op) noexcept
N{
N    return __o->fetch_or(__op);
N}
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename enable_if
N<
N    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
N    _Tp
N>::type
Natomic_fetch_or(atomic<_Tp>* __o, _Tp __op) _NOEXCEPT
Xatomic_fetch_or(atomic<_Tp>* __o, _Tp __op) noexcept
N{
N    return __o->fetch_or(__op);
N}
N
N// atomic_fetch_or_explicit
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename enable_if
N<
N    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
N    _Tp
N>::type
Natomic_fetch_or_explicit(volatile atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT
Xatomic_fetch_or_explicit(volatile atomic<_Tp>* __o, _Tp __op, memory_order __m) noexcept
N{
N    return __o->fetch_or(__op, __m);
N}
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename enable_if
N<
N    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
N    _Tp
N>::type
Natomic_fetch_or_explicit(atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT
Xatomic_fetch_or_explicit(atomic<_Tp>* __o, _Tp __op, memory_order __m) noexcept
N{
N    return __o->fetch_or(__op, __m);
N}
N
N// atomic_fetch_xor
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename enable_if
N<
N    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
N    _Tp
N>::type
Natomic_fetch_xor(volatile atomic<_Tp>* __o, _Tp __op) _NOEXCEPT
Xatomic_fetch_xor(volatile atomic<_Tp>* __o, _Tp __op) noexcept
N{
N    return __o->fetch_xor(__op);
N}
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename enable_if
N<
N    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
N    _Tp
N>::type
Natomic_fetch_xor(atomic<_Tp>* __o, _Tp __op) _NOEXCEPT
Xatomic_fetch_xor(atomic<_Tp>* __o, _Tp __op) noexcept
N{
N    return __o->fetch_xor(__op);
N}
N
N// atomic_fetch_xor_explicit
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename enable_if
N<
N    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
N    _Tp
N>::type
Natomic_fetch_xor_explicit(volatile atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT
Xatomic_fetch_xor_explicit(volatile atomic<_Tp>* __o, _Tp __op, memory_order __m) noexcept
N{
N    return __o->fetch_xor(__op, __m);
N}
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename enable_if
N<
N    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
N    _Tp
N>::type
Natomic_fetch_xor_explicit(atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT
Xatomic_fetch_xor_explicit(atomic<_Tp>* __o, _Tp __op, memory_order __m) noexcept
N{
N    return __o->fetch_xor(__op, __m);
N}
N
N// flag type and operations
N
Ntypedef struct atomic_flag
N{
N    _Atomic(bool) __a_;
X    __gcc_atomic::__gcc_atomic_t<bool> __a_;
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    bool test_and_set(memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
X    bool test_and_set(memory_order __m = memory_order_seq_cst) volatile noexcept
N        {return __c11_atomic_exchange(&__a_, true, __m);}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    bool test_and_set(memory_order __m = memory_order_seq_cst) _NOEXCEPT
X    bool test_and_set(memory_order __m = memory_order_seq_cst) noexcept
N        {return __c11_atomic_exchange(&__a_, true, __m);}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    void clear(memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
X    void clear(memory_order __m = memory_order_seq_cst) volatile noexcept
N        {__c11_atomic_store(&__a_, false, __m);}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    void clear(memory_order __m = memory_order_seq_cst) _NOEXCEPT
X    void clear(memory_order __m = memory_order_seq_cst) noexcept
N        {__c11_atomic_store(&__a_, false, __m);}
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N#ifndef _LIBCPP_CXX03_LANG
N    atomic_flag() _NOEXCEPT = default;
X    atomic_flag() noexcept = default;
N#else
S    atomic_flag() _NOEXCEPT : __a_() {}
N#endif // _LIBCPP_CXX03_LANG
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    atomic_flag(bool __b) _NOEXCEPT : __a_(__b) {} // EXTENSION
X    atomic_flag(bool __b) noexcept : __a_(__b) {} 
N
N#ifndef _LIBCPP_CXX03_LANG
N    atomic_flag(const atomic_flag&) = delete;
N    atomic_flag& operator=(const atomic_flag&) = delete;
N    atomic_flag& operator=(const atomic_flag&) volatile = delete;
N#else
Sprivate:
S    atomic_flag(const atomic_flag&);
S    atomic_flag& operator=(const atomic_flag&);
S    atomic_flag& operator=(const atomic_flag&) volatile;
N#endif
N} atomic_flag;
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Natomic_flag_test_and_set(volatile atomic_flag* __o) _NOEXCEPT
Xatomic_flag_test_and_set(volatile atomic_flag* __o) noexcept
N{
N    return __o->test_and_set();
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Natomic_flag_test_and_set(atomic_flag* __o) _NOEXCEPT
Xatomic_flag_test_and_set(atomic_flag* __o) noexcept
N{
N    return __o->test_and_set();
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Natomic_flag_test_and_set_explicit(volatile atomic_flag* __o, memory_order __m) _NOEXCEPT
Xatomic_flag_test_and_set_explicit(volatile atomic_flag* __o, memory_order __m) noexcept
N{
N    return __o->test_and_set(__m);
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Natomic_flag_test_and_set_explicit(atomic_flag* __o, memory_order __m) _NOEXCEPT
Xatomic_flag_test_and_set_explicit(atomic_flag* __o, memory_order __m) noexcept
N{
N    return __o->test_and_set(__m);
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Natomic_flag_clear(volatile atomic_flag* __o) _NOEXCEPT
Xatomic_flag_clear(volatile atomic_flag* __o) noexcept
N{
N    __o->clear();
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Natomic_flag_clear(atomic_flag* __o) _NOEXCEPT
Xatomic_flag_clear(atomic_flag* __o) noexcept
N{
N    __o->clear();
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Natomic_flag_clear_explicit(volatile atomic_flag* __o, memory_order __m) _NOEXCEPT
Xatomic_flag_clear_explicit(volatile atomic_flag* __o, memory_order __m) noexcept
N{
N    __o->clear(__m);
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Natomic_flag_clear_explicit(atomic_flag* __o, memory_order __m) _NOEXCEPT
Xatomic_flag_clear_explicit(atomic_flag* __o, memory_order __m) noexcept
N{
N    __o->clear(__m);
N}
N
N// fences
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Natomic_thread_fence(memory_order __m) _NOEXCEPT
Xatomic_thread_fence(memory_order __m) noexcept
N{
N    __c11_atomic_thread_fence(__m);
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Natomic_signal_fence(memory_order __m) _NOEXCEPT
Xatomic_signal_fence(memory_order __m) noexcept
N{
N    __c11_atomic_signal_fence(__m);
N}
N
N// Atomics for standard typedef types
N
Ntypedef atomic<bool>               atomic_bool;
Ntypedef atomic<char>               atomic_char;
Ntypedef atomic<signed char>        atomic_schar;
Ntypedef atomic<unsigned char>      atomic_uchar;
Ntypedef atomic<short>              atomic_short;
Ntypedef atomic<unsigned short>     atomic_ushort;
Ntypedef atomic<int>                atomic_int;
Ntypedef atomic<unsigned int>       atomic_uint;
Ntypedef atomic<long>               atomic_long;
Ntypedef atomic<unsigned long>      atomic_ulong;
Ntypedef atomic<long long>          atomic_llong;
Ntypedef atomic<unsigned long long> atomic_ullong;
Ntypedef atomic<char16_t>           atomic_char16_t;
Ntypedef atomic<char32_t>           atomic_char32_t;
Ntypedef atomic<wchar_t>            atomic_wchar_t;
N
Ntypedef atomic<int_least8_t>   atomic_int_least8_t;
Ntypedef atomic<uint_least8_t>  atomic_uint_least8_t;
Ntypedef atomic<int_least16_t>  atomic_int_least16_t;
Ntypedef atomic<uint_least16_t> atomic_uint_least16_t;
Ntypedef atomic<int_least32_t>  atomic_int_least32_t;
Ntypedef atomic<uint_least32_t> atomic_uint_least32_t;
Ntypedef atomic<int_least64_t>  atomic_int_least64_t;
Ntypedef atomic<uint_least64_t> atomic_uint_least64_t;
N
Ntypedef atomic<int_fast8_t>   atomic_int_fast8_t;
Ntypedef atomic<uint_fast8_t>  atomic_uint_fast8_t;
Ntypedef atomic<int_fast16_t>  atomic_int_fast16_t;
Ntypedef atomic<uint_fast16_t> atomic_uint_fast16_t;
Ntypedef atomic<int_fast32_t>  atomic_int_fast32_t;
Ntypedef atomic<uint_fast32_t> atomic_uint_fast32_t;
Ntypedef atomic<int_fast64_t>  atomic_int_fast64_t;
Ntypedef atomic<uint_fast64_t> atomic_uint_fast64_t;
N
Ntypedef atomic< int8_t>  atomic_int8_t;
Ntypedef atomic<uint8_t>  atomic_uint8_t;
Ntypedef atomic< int16_t> atomic_int16_t;
Ntypedef atomic<uint16_t> atomic_uint16_t;
Ntypedef atomic< int32_t> atomic_int32_t;
Ntypedef atomic<uint32_t> atomic_uint32_t;
Ntypedef atomic< int64_t> atomic_int64_t;
Ntypedef atomic<uint64_t> atomic_uint64_t;
N
Ntypedef atomic<intptr_t>  atomic_intptr_t;
Ntypedef atomic<uintptr_t> atomic_uintptr_t;
Ntypedef atomic<size_t>    atomic_size_t;
Ntypedef atomic<ptrdiff_t> atomic_ptrdiff_t;
Ntypedef atomic<intmax_t>  atomic_intmax_t;
Ntypedef atomic<uintmax_t> atomic_uintmax_t;
N
N#define ATOMIC_FLAG_INIT {false}
N#define ATOMIC_VAR_INIT(__v) {__v}
N
N_LIBCPP_END_NAMESPACE_STD
X} }
N
N#endif  // _LIBCPP_ATOMIC
L 659 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/memory" 2
N#endif
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N_LIBCPP_PUSH_MACROS
X_Pragma("push_macro(\"min\")") _Pragma("push_macro(\"max\")")
N#include <__undef_macros>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/__undef_macros" 1
N// -*- C++ -*-
N//===------------------------ __undef_macros ------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is distributed under the University of Illinois Open Source
N// License. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N
N#ifdef min
S#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
S#if defined(_LIBCPP_WARNING)
S_LIBCPP_WARNING("macro min is incompatible with C++.  Try #define NOMINMAX "
S                "before any Windows header. #undefing min")
S#else
S#warning: macro min is incompatible with C++.  #undefing min
S#endif
S#endif
S#undef min
N#endif
N
N#ifdef max
S#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
S#if defined(_LIBCPP_WARNING)
S_LIBCPP_WARNING("macro max is incompatible with C++.  Try #define NOMINMAX "
S                "before any Windows header. #undefing max")
S#else
S#warning: macro max is incompatible with C++.  #undefing max
S#endif
S#endif
S#undef max
N#endif
L 667 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/memory" 2
N
N
N_LIBCPP_BEGIN_NAMESPACE_STD
Xnamespace std { inline namespace __2 {
N
Ntemplate <class _ValueType>
Ninline _LIBCPP_ALWAYS_INLINE
Xinline __attribute__ ((__always_inline__))
N_ValueType __libcpp_relaxed_load(_ValueType const* __value) {
N#if !defined(_LIBCPP_HAS_NO_THREADS) && \
N    defined(__ATOMIC_RELAXED) &&        \
N    (__has_builtin(__atomic_load_n) || _GNUC_VER >= 407)
X#if !1L &&     1L &&            (1 || 0 >= 407)
S    return __atomic_load_n(__value, __ATOMIC_RELAXED);
N#else
N    return *__value;
N#endif
N}
N
Ntemplate <class _ValueType>
Ninline _LIBCPP_ALWAYS_INLINE
Xinline __attribute__ ((__always_inline__))
N_ValueType __libcpp_acquire_load(_ValueType const* __value) {
N#if !defined(_LIBCPP_HAS_NO_THREADS) && \
N    defined(__ATOMIC_ACQUIRE) &&        \
N    (__has_builtin(__atomic_load_n) || _GNUC_VER >= 407)
X#if !1L &&     1L &&            (1 || 0 >= 407)
S    return __atomic_load_n(__value, __ATOMIC_ACQUIRE);
N#else
N    return *__value;
N#endif
N}
N
N// addressof moved to <type_traits>
N
Ntemplate <class _Tp> class allocator;
N
Ntemplate <>
Nclass _LIBCPP_TEMPLATE_VIS allocator<void>
Xclass  allocator<void>
N{
Npublic:
N    typedef void*             pointer;
N    typedef const void*       const_pointer;
N    typedef void              value_type;
N
N    template <class _Up> struct rebind {typedef allocator<_Up> other;};
N};
N
Ntemplate <>
Nclass _LIBCPP_TEMPLATE_VIS allocator<const void>
Xclass  allocator<const void>
N{
Npublic:
N    typedef const void*       pointer;
N    typedef const void*       const_pointer;
N    typedef const void        value_type;
N
N    template <class _Up> struct rebind {typedef allocator<_Up> other;};
N};
N
N// pointer_traits
N
Ntemplate <class _Tp, class = void>
Nstruct __has_element_type : false_type {};
N
Ntemplate <class _Tp>
Nstruct __has_element_type<_Tp,
N              typename __void_t<typename _Tp::element_type>::type> : true_type {};
N
Ntemplate <class _Ptr, bool = __has_element_type<_Ptr>::value>
Nstruct __pointer_traits_element_type;
N
Ntemplate <class _Ptr>
Nstruct __pointer_traits_element_type<_Ptr, true>
N{
N    typedef typename _Ptr::element_type type;
N};
N
N#ifndef _LIBCPP_HAS_NO_VARIADICS
N
Ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args>
Nstruct __pointer_traits_element_type<_Sp<_Tp, _Args...>, true>
N{
N    typedef typename _Sp<_Tp, _Args...>::element_type type;
N};
N
Ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args>
Nstruct __pointer_traits_element_type<_Sp<_Tp, _Args...>, false>
N{
N    typedef _Tp type;
N};
N
N#else  // _LIBCPP_HAS_NO_VARIADICS
S
Stemplate <template <class> class _Sp, class _Tp>
Sstruct __pointer_traits_element_type<_Sp<_Tp>, true>
S{
S    typedef typename _Sp<_Tp>::element_type type;
S};
S
Stemplate <template <class> class _Sp, class _Tp>
Sstruct __pointer_traits_element_type<_Sp<_Tp>, false>
S{
S    typedef _Tp type;
S};
S
Stemplate <template <class, class> class _Sp, class _Tp, class _A0>
Sstruct __pointer_traits_element_type<_Sp<_Tp, _A0>, true>
S{
S    typedef typename _Sp<_Tp, _A0>::element_type type;
S};
S
Stemplate <template <class, class> class _Sp, class _Tp, class _A0>
Sstruct __pointer_traits_element_type<_Sp<_Tp, _A0>, false>
S{
S    typedef _Tp type;
S};
S
Stemplate <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1>
Sstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1>, true>
S{
S    typedef typename _Sp<_Tp, _A0, _A1>::element_type type;
S};
S
Stemplate <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1>
Sstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1>, false>
S{
S    typedef _Tp type;
S};
S
Stemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,
S                                                           class _A1, class _A2>
Sstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1, _A2>, true>
S{
S    typedef typename _Sp<_Tp, _A0, _A1, _A2>::element_type type;
S};
S
Stemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,
S                                                           class _A1, class _A2>
Sstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1, _A2>, false>
S{
S    typedef _Tp type;
S};
S
N#endif  // _LIBCPP_HAS_NO_VARIADICS
N
Ntemplate <class _Tp, class = void>
Nstruct __has_difference_type : false_type {};
N
Ntemplate <class _Tp>
Nstruct __has_difference_type<_Tp,
N            typename __void_t<typename _Tp::difference_type>::type> : true_type {};
N
Ntemplate <class _Ptr, bool = __has_difference_type<_Ptr>::value>
Nstruct __pointer_traits_difference_type
N{
N    typedef ptrdiff_t type;
N};
N
Ntemplate <class _Ptr>
Nstruct __pointer_traits_difference_type<_Ptr, true>
N{
N    typedef typename _Ptr::difference_type type;
N};
N
Ntemplate <class _Tp, class _Up>
Nstruct __has_rebind
N{
Nprivate:
N    struct __two {char __lx; char __lxx;};
N    template <class _Xp> static __two __test(...);
N    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>* = 0);
Npublic:
N    static const bool value = sizeof(__test<_Tp>(0)) == 1;
N};
N
Ntemplate <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>
Nstruct __pointer_traits_rebind
N{
N#ifndef _LIBCPP_CXX03_LANG
N    typedef typename _Tp::template rebind<_Up> type;
N#else
S    typedef typename _Tp::template rebind<_Up>::other type;
N#endif
N};
N
N#ifndef _LIBCPP_HAS_NO_VARIADICS
N
Ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>
Nstruct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, true>
N{
N#ifndef _LIBCPP_CXX03_LANG
N    typedef typename _Sp<_Tp, _Args...>::template rebind<_Up> type;
N#else
S    typedef typename _Sp<_Tp, _Args...>::template rebind<_Up>::other type;
N#endif
N};
N
Ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>
Nstruct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, false>
N{
N    typedef _Sp<_Up, _Args...> type;
N};
N
N#else  // _LIBCPP_HAS_NO_VARIADICS
S
Stemplate <template <class> class _Sp, class _Tp, class _Up>
Sstruct __pointer_traits_rebind<_Sp<_Tp>, _Up, true>
S{
S#ifndef _LIBCPP_CXX03_LANG
S    typedef typename _Sp<_Tp>::template rebind<_Up> type;
S#else
S    typedef typename _Sp<_Tp>::template rebind<_Up>::other type;
S#endif
S};
S
Stemplate <template <class> class _Sp, class _Tp, class _Up>
Sstruct __pointer_traits_rebind<_Sp<_Tp>, _Up, false>
S{
S    typedef _Sp<_Up> type;
S};
S
Stemplate <template <class, class> class _Sp, class _Tp, class _A0, class _Up>
Sstruct __pointer_traits_rebind<_Sp<_Tp, _A0>, _Up, true>
S{
S#ifndef _LIBCPP_CXX03_LANG
S    typedef typename _Sp<_Tp, _A0>::template rebind<_Up> type;
S#else
S    typedef typename _Sp<_Tp, _A0>::template rebind<_Up>::other type;
S#endif
S};
S
Stemplate <template <class, class> class _Sp, class _Tp, class _A0, class _Up>
Sstruct __pointer_traits_rebind<_Sp<_Tp, _A0>, _Up, false>
S{
S    typedef _Sp<_Up, _A0> type;
S};
S
Stemplate <template <class, class, class> class _Sp, class _Tp, class _A0,
S                                         class _A1, class _Up>
Sstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1>, _Up, true>
S{
S#ifndef _LIBCPP_CXX03_LANG
S    typedef typename _Sp<_Tp, _A0, _A1>::template rebind<_Up> type;
S#else
S    typedef typename _Sp<_Tp, _A0, _A1>::template rebind<_Up>::other type;
S#endif
S};
S
Stemplate <template <class, class, class> class _Sp, class _Tp, class _A0,
S                                         class _A1, class _Up>
Sstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1>, _Up, false>
S{
S    typedef _Sp<_Up, _A0, _A1> type;
S};
S
Stemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,
S                                                class _A1, class _A2, class _Up>
Sstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1, _A2>, _Up, true>
S{
S#ifndef _LIBCPP_CXX03_LANG
S    typedef typename _Sp<_Tp, _A0, _A1, _A2>::template rebind<_Up> type;
S#else
S    typedef typename _Sp<_Tp, _A0, _A1, _A2>::template rebind<_Up>::other type;
S#endif
S};
S
Stemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,
S                                                class _A1, class _A2, class _Up>
Sstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1, _A2>, _Up, false>
S{
S    typedef _Sp<_Up, _A0, _A1, _A2> type;
S};
S
N#endif  // _LIBCPP_HAS_NO_VARIADICS
N
Ntemplate <class _Ptr>
Nstruct _LIBCPP_TEMPLATE_VIS pointer_traits
Xstruct  pointer_traits
N{
N    typedef _Ptr                                                     pointer;
N    typedef typename __pointer_traits_element_type<pointer>::type    element_type;
N    typedef typename __pointer_traits_difference_type<pointer>::type difference_type;
N
N#ifndef _LIBCPP_CXX03_LANG
N    template <class _Up> using rebind = typename __pointer_traits_rebind<pointer, _Up>::type;
N#else
S    template <class _Up> struct rebind
S        {typedef typename __pointer_traits_rebind<pointer, _Up>::type other;};
N#endif  // _LIBCPP_CXX03_LANG
N
Nprivate:
N    struct __nat {};
Npublic:
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    static pointer pointer_to(typename conditional<is_void<element_type>::value,
N                                           __nat, element_type>::type& __r)
N        {return pointer::pointer_to(__r);}
N};
N
Ntemplate <class _Tp>
Nstruct _LIBCPP_TEMPLATE_VIS pointer_traits<_Tp*>
Xstruct  pointer_traits<_Tp*>
N{
N    typedef _Tp*      pointer;
N    typedef _Tp       element_type;
N    typedef ptrdiff_t difference_type;
N
N#ifndef _LIBCPP_CXX03_LANG
N    template <class _Up> using rebind = _Up*;
N#else
S    template <class _Up> struct rebind {typedef _Up* other;};
N#endif
N
Nprivate:
N    struct __nat {};
Npublic:
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    static pointer pointer_to(typename conditional<is_void<element_type>::value,
N                                      __nat, element_type>::type& __r) _NOEXCEPT
X                                      __nat, element_type>::type& __r) noexcept
N        {return _VSTD::addressof(__r);}
X        {return std::__2::addressof(__r);}
N};
N
Ntemplate <class _From, class _To>
Nstruct __rebind_pointer {
N#ifndef _LIBCPP_CXX03_LANG
N    typedef typename pointer_traits<_From>::template rebind<_To>        type;
N#else
S    typedef typename pointer_traits<_From>::template rebind<_To>::other type;
N#endif
N};
N
N// allocator_traits
N
Ntemplate <class _Tp, class = void>
Nstruct __has_pointer_type : false_type {};
N
Ntemplate <class _Tp>
Nstruct __has_pointer_type<_Tp,
N          typename __void_t<typename _Tp::pointer>::type> : true_type {};
N
Nnamespace __pointer_type_imp
N{
N
Ntemplate <class _Tp, class _Dp, bool = __has_pointer_type<_Dp>::value>
Nstruct __pointer_type
N{
N    typedef typename _Dp::pointer type;
N};
N
Ntemplate <class _Tp, class _Dp>
Nstruct __pointer_type<_Tp, _Dp, false>
N{
N    typedef _Tp* type;
N};
N
N}  // __pointer_type_imp
N
Ntemplate <class _Tp, class _Dp>
Nstruct __pointer_type
N{
N    typedef typename __pointer_type_imp::__pointer_type<_Tp, typename remove_reference<_Dp>::type>::type type;
N};
N
Ntemplate <class _Tp, class = void>
Nstruct __has_const_pointer : false_type {};
N
Ntemplate <class _Tp>
Nstruct __has_const_pointer<_Tp,
N            typename __void_t<typename _Tp::const_pointer>::type> : true_type {};
N
Ntemplate <class _Tp, class _Ptr, class _Alloc, bool = __has_const_pointer<_Alloc>::value>
Nstruct __const_pointer
N{
N    typedef typename _Alloc::const_pointer type;
N};
N
Ntemplate <class _Tp, class _Ptr, class _Alloc>
Nstruct __const_pointer<_Tp, _Ptr, _Alloc, false>
N{
N#ifndef _LIBCPP_CXX03_LANG
N    typedef typename pointer_traits<_Ptr>::template rebind<const _Tp> type;
N#else
S    typedef typename pointer_traits<_Ptr>::template rebind<const _Tp>::other type;
N#endif
N};
N
Ntemplate <class _Tp, class = void>
Nstruct __has_void_pointer : false_type {};
N
Ntemplate <class _Tp>
Nstruct __has_void_pointer<_Tp,
N               typename __void_t<typename _Tp::void_pointer>::type> : true_type {};
N
Ntemplate <class _Ptr, class _Alloc, bool = __has_void_pointer<_Alloc>::value>
Nstruct __void_pointer
N{
N    typedef typename _Alloc::void_pointer type;
N};
N
Ntemplate <class _Ptr, class _Alloc>
Nstruct __void_pointer<_Ptr, _Alloc, false>
N{
N#ifndef _LIBCPP_CXX03_LANG
N    typedef typename pointer_traits<_Ptr>::template rebind<void> type;
N#else
S    typedef typename pointer_traits<_Ptr>::template rebind<void>::other type;
N#endif
N};
N
Ntemplate <class _Tp, class = void>
Nstruct __has_const_void_pointer : false_type {};
N
Ntemplate <class _Tp>
Nstruct __has_const_void_pointer<_Tp,
N            typename __void_t<typename _Tp::const_void_pointer>::type> : true_type {};
N
Ntemplate <class _Ptr, class _Alloc, bool = __has_const_void_pointer<_Alloc>::value>
Nstruct __const_void_pointer
N{
N    typedef typename _Alloc::const_void_pointer type;
N};
N
Ntemplate <class _Ptr, class _Alloc>
Nstruct __const_void_pointer<_Ptr, _Alloc, false>
N{
N#ifndef _LIBCPP_CXX03_LANG
N    typedef typename pointer_traits<_Ptr>::template rebind<const void> type;
N#else
S    typedef typename pointer_traits<_Ptr>::template rebind<const void>::other type;
N#endif
N};
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_Tp*
N__to_raw_pointer(_Tp* __p) _NOEXCEPT
X__to_raw_pointer(_Tp* __p) noexcept
N{
N    return __p;
N}
N
Ntemplate <class _Pointer>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename pointer_traits<_Pointer>::element_type*
N__to_raw_pointer(_Pointer __p) _NOEXCEPT
X__to_raw_pointer(_Pointer __p) noexcept
N{
N    return _VSTD::__to_raw_pointer(__p.operator->());
X    return std::__2::__to_raw_pointer(__p.operator->());
N}
N
Ntemplate <class _Tp, class = void>
Nstruct __has_size_type : false_type {};
N
Ntemplate <class _Tp>
Nstruct __has_size_type<_Tp,
N               typename __void_t<typename _Tp::size_type>::type> : true_type {};
N
Ntemplate <class _Alloc, class _DiffType, bool = __has_size_type<_Alloc>::value>
Nstruct __size_type
N{
N    typedef typename make_unsigned<_DiffType>::type type;
N};
N
Ntemplate <class _Alloc, class _DiffType>
Nstruct __size_type<_Alloc, _DiffType, true>
N{
N    typedef typename _Alloc::size_type type;
N};
N
Ntemplate <class _Tp, class = void>
Nstruct __has_propagate_on_container_copy_assignment : false_type {};
N
Ntemplate <class _Tp>
Nstruct __has_propagate_on_container_copy_assignment<_Tp,
N    typename __void_t<typename _Tp::propagate_on_container_copy_assignment>::type>
N        : true_type {};
N
Ntemplate <class _Alloc, bool = __has_propagate_on_container_copy_assignment<_Alloc>::value>
Nstruct __propagate_on_container_copy_assignment
N{
N    typedef false_type type;
N};
N
Ntemplate <class _Alloc>
Nstruct __propagate_on_container_copy_assignment<_Alloc, true>
N{
N    typedef typename _Alloc::propagate_on_container_copy_assignment type;
N};
N
Ntemplate <class _Tp, class = void>
Nstruct __has_propagate_on_container_move_assignment : false_type {};
N
Ntemplate <class _Tp>
Nstruct __has_propagate_on_container_move_assignment<_Tp,
N           typename __void_t<typename _Tp::propagate_on_container_move_assignment>::type>
N               : true_type {};
N
Ntemplate <class _Alloc, bool = __has_propagate_on_container_move_assignment<_Alloc>::value>
Nstruct __propagate_on_container_move_assignment
N{
N    typedef false_type type;
N};
N
Ntemplate <class _Alloc>
Nstruct __propagate_on_container_move_assignment<_Alloc, true>
N{
N    typedef typename _Alloc::propagate_on_container_move_assignment type;
N};
N
Ntemplate <class _Tp, class = void>
Nstruct __has_propagate_on_container_swap : false_type {};
N
Ntemplate <class _Tp>
Nstruct __has_propagate_on_container_swap<_Tp,
N           typename __void_t<typename _Tp::propagate_on_container_swap>::type>
N               : true_type {};
N
Ntemplate <class _Alloc, bool = __has_propagate_on_container_swap<_Alloc>::value>
Nstruct __propagate_on_container_swap
N{
N    typedef false_type type;
N};
N
Ntemplate <class _Alloc>
Nstruct __propagate_on_container_swap<_Alloc, true>
N{
N    typedef typename _Alloc::propagate_on_container_swap type;
N};
N
Ntemplate <class _Tp, class = void>
Nstruct __has_is_always_equal : false_type {};
N
Ntemplate <class _Tp>
Nstruct __has_is_always_equal<_Tp,
N           typename __void_t<typename _Tp::is_always_equal>::type>
N               : true_type {};
N
Ntemplate <class _Alloc, bool = __has_is_always_equal<_Alloc>::value>
Nstruct __is_always_equal
N{
N    typedef typename _VSTD::is_empty<_Alloc>::type type;
X    typedef typename std::__2::is_empty<_Alloc>::type type;
N};
N
Ntemplate <class _Alloc>
Nstruct __is_always_equal<_Alloc, true>
N{
N    typedef typename _Alloc::is_always_equal type;
N};
N
Ntemplate <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>
Nstruct __has_rebind_other
N{
Nprivate:
N    struct __two {char __lx; char __lxx;};
N    template <class _Xp> static __two __test(...);
N    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>::other* = 0);
Npublic:
N    static const bool value = sizeof(__test<_Tp>(0)) == 1;
N};
N
Ntemplate <class _Tp, class _Up>
Nstruct __has_rebind_other<_Tp, _Up, false>
N{
N    static const bool value = false;
N};
N
Ntemplate <class _Tp, class _Up, bool = __has_rebind_other<_Tp, _Up>::value>
Nstruct __allocator_traits_rebind
N{
N    typedef typename _Tp::template rebind<_Up>::other type;
N};
N
N#ifndef _LIBCPP_HAS_NO_VARIADICS
N
Ntemplate <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>
Nstruct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, true>
N{
N    typedef typename _Alloc<_Tp, _Args...>::template rebind<_Up>::other type;
N};
N
Ntemplate <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>
Nstruct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, false>
N{
N    typedef _Alloc<_Up, _Args...> type;
N};
N
N#else  // _LIBCPP_HAS_NO_VARIADICS
S
Stemplate <template <class> class _Alloc, class _Tp, class _Up>
Sstruct __allocator_traits_rebind<_Alloc<_Tp>, _Up, true>
S{
S    typedef typename _Alloc<_Tp>::template rebind<_Up>::other type;
S};
S
Stemplate <template <class> class _Alloc, class _Tp, class _Up>
Sstruct __allocator_traits_rebind<_Alloc<_Tp>, _Up, false>
S{
S    typedef _Alloc<_Up> type;
S};
S
Stemplate <template <class, class> class _Alloc, class _Tp, class _A0, class _Up>
Sstruct __allocator_traits_rebind<_Alloc<_Tp, _A0>, _Up, true>
S{
S    typedef typename _Alloc<_Tp, _A0>::template rebind<_Up>::other type;
S};
S
Stemplate <template <class, class> class _Alloc, class _Tp, class _A0, class _Up>
Sstruct __allocator_traits_rebind<_Alloc<_Tp, _A0>, _Up, false>
S{
S    typedef _Alloc<_Up, _A0> type;
S};
S
Stemplate <template <class, class, class> class _Alloc, class _Tp, class _A0,
S                                         class _A1, class _Up>
Sstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1>, _Up, true>
S{
S    typedef typename _Alloc<_Tp, _A0, _A1>::template rebind<_Up>::other type;
S};
S
Stemplate <template <class, class, class> class _Alloc, class _Tp, class _A0,
S                                         class _A1, class _Up>
Sstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1>, _Up, false>
S{
S    typedef _Alloc<_Up, _A0, _A1> type;
S};
S
Stemplate <template <class, class, class, class> class _Alloc, class _Tp, class _A0,
S                                                class _A1, class _A2, class _Up>
Sstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1, _A2>, _Up, true>
S{
S    typedef typename _Alloc<_Tp, _A0, _A1, _A2>::template rebind<_Up>::other type;
S};
S
Stemplate <template <class, class, class, class> class _Alloc, class _Tp, class _A0,
S                                                class _A1, class _A2, class _Up>
Sstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1, _A2>, _Up, false>
S{
S    typedef _Alloc<_Up, _A0, _A1, _A2> type;
S};
S
N#endif  // _LIBCPP_HAS_NO_VARIADICS
N
N#ifndef _LIBCPP_CXX03_LANG
N
Ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>
Nauto
N__has_allocate_hint_test(_Alloc&& __a, _SizeType&& __sz, _ConstVoidPtr&& __p)
N    -> decltype((void)__a.allocate(__sz, __p), true_type());
N
Ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>
Nauto
N__has_allocate_hint_test(const _Alloc& __a, _SizeType&& __sz, _ConstVoidPtr&& __p)
N    -> false_type;
N
Ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>
Nstruct __has_allocate_hint
N    : integral_constant<bool,
N        is_same<
N            decltype(_VSTD::__has_allocate_hint_test(declval<_Alloc>(),
X            decltype(std::__2::__has_allocate_hint_test(declval<_Alloc>(),
N                                          declval<_SizeType>(),
N                                          declval<_ConstVoidPtr>())),
N            true_type>::value>
N{
N};
N
N#else  // _LIBCPP_CXX03_LANG
S
Stemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>
Sstruct __has_allocate_hint
S    : true_type
S{
S};
S
N#endif  // _LIBCPP_CXX03_LANG
N
N#if !defined(_LIBCPP_CXX03_LANG)
X#if !0L
N
Ntemplate <class _Alloc, class _Tp, class ..._Args>
Ndecltype(_VSTD::declval<_Alloc>().construct(_VSTD::declval<_Tp*>(),
Xdecltype(std::__2::declval<_Alloc>().construct(std::__2::declval<_Tp*>(),
N                                           _VSTD::declval<_Args>()...),
X                                           std::__2::declval<_Args>()...),
N                                           true_type())
N__has_construct_test(_Alloc&& __a, _Tp* __p, _Args&& ...__args);
N
Ntemplate <class _Alloc, class _Pointer, class ..._Args>
Nfalse_type
N__has_construct_test(const _Alloc& __a, _Pointer&& __p, _Args&& ...__args);
N
Ntemplate <class _Alloc, class _Pointer, class ..._Args>
Nstruct __has_construct
N    : integral_constant<bool,
N        is_same<
N            decltype(_VSTD::__has_construct_test(declval<_Alloc>(),
X            decltype(std::__2::__has_construct_test(declval<_Alloc>(),
N                                          declval<_Pointer>(),
N                                          declval<_Args>()...)),
N            true_type>::value>
N{
N};
N
Ntemplate <class _Alloc, class _Pointer>
Nauto
N__has_destroy_test(_Alloc&& __a, _Pointer&& __p)
N    -> decltype(__a.destroy(__p), true_type());
N
Ntemplate <class _Alloc, class _Pointer>
Nauto
N__has_destroy_test(const _Alloc& __a, _Pointer&& __p)
N    -> false_type;
N
Ntemplate <class _Alloc, class _Pointer>
Nstruct __has_destroy
N    : integral_constant<bool,
N        is_same<
N            decltype(_VSTD::__has_destroy_test(declval<_Alloc>(),
X            decltype(std::__2::__has_destroy_test(declval<_Alloc>(),
N                                        declval<_Pointer>())),
N            true_type>::value>
N{
N};
N
Ntemplate <class _Alloc>
Nauto
N__has_max_size_test(_Alloc&& __a)
N    -> decltype(__a.max_size(), true_type());
N
Ntemplate <class _Alloc>
Nauto
N__has_max_size_test(const volatile _Alloc& __a)
N    -> false_type;
N
Ntemplate <class _Alloc>
Nstruct __has_max_size
N    : integral_constant<bool,
N        is_same<
N            decltype(_VSTD::__has_max_size_test(declval<_Alloc&>())),
X            decltype(std::__2::__has_max_size_test(declval<_Alloc&>())),
N            true_type>::value>
N{
N};
N
Ntemplate <class _Alloc>
Nauto
N__has_select_on_container_copy_construction_test(_Alloc&& __a)
N    -> decltype(__a.select_on_container_copy_construction(), true_type());
N
Ntemplate <class _Alloc>
Nauto
N__has_select_on_container_copy_construction_test(const volatile _Alloc& __a)
N    -> false_type;
N
Ntemplate <class _Alloc>
Nstruct __has_select_on_container_copy_construction
N    : integral_constant<bool,
N        is_same<
N            decltype(_VSTD::__has_select_on_container_copy_construction_test(declval<_Alloc&>())),
X            decltype(std::__2::__has_select_on_container_copy_construction_test(declval<_Alloc&>())),
N            true_type>::value>
N{
N};
N
N#else  // _LIBCPP_CXX03_LANG
S
S#ifndef _LIBCPP_HAS_NO_VARIADICS
S
Stemplate <class _Alloc, class _Pointer, class ..._Args>
Sstruct __has_construct
S    : false_type
S{
S};
S
S#else  // _LIBCPP_HAS_NO_VARIADICS
S
Stemplate <class _Alloc, class _Pointer, class _Args>
Sstruct __has_construct
S    : false_type
S{
S};
S
S#endif  // _LIBCPP_HAS_NO_VARIADICS
S
Stemplate <class _Alloc, class _Pointer>
Sstruct __has_destroy
S    : false_type
S{
S};
S
Stemplate <class _Alloc>
Sstruct __has_max_size
S    : true_type
S{
S};
S
Stemplate <class _Alloc>
Sstruct __has_select_on_container_copy_construction
S    : false_type
S{
S};
S
N#endif  // _LIBCPP_CXX03_LANG
N
Ntemplate <class _Alloc, class _Ptr, bool = __has_difference_type<_Alloc>::value>
Nstruct __alloc_traits_difference_type
N{
N    typedef typename pointer_traits<_Ptr>::difference_type type;
N};
N
Ntemplate <class _Alloc, class _Ptr>
Nstruct __alloc_traits_difference_type<_Alloc, _Ptr, true>
N{
N    typedef typename _Alloc::difference_type type;
N};
N
Ntemplate <class _Alloc>
Nstruct _LIBCPP_TEMPLATE_VIS allocator_traits
Xstruct  allocator_traits
N{
N    typedef _Alloc                              allocator_type;
N    typedef typename allocator_type::value_type value_type;
N
N    typedef typename __pointer_type<value_type, allocator_type>::type pointer;
N    typedef typename __const_pointer<value_type, pointer, allocator_type>::type const_pointer;
N    typedef typename __void_pointer<pointer, allocator_type>::type void_pointer;
N    typedef typename __const_void_pointer<pointer, allocator_type>::type const_void_pointer;
N
N    typedef typename __alloc_traits_difference_type<allocator_type, pointer>::type difference_type;
N    typedef typename __size_type<allocator_type, difference_type>::type size_type;
N
N    typedef typename __propagate_on_container_copy_assignment<allocator_type>::type
N                     propagate_on_container_copy_assignment;
N    typedef typename __propagate_on_container_move_assignment<allocator_type>::type
N                     propagate_on_container_move_assignment;
N    typedef typename __propagate_on_container_swap<allocator_type>::type
N                     propagate_on_container_swap;
N    typedef typename __is_always_equal<allocator_type>::type
N                     is_always_equal;
N
N#ifndef _LIBCPP_CXX03_LANG
N    template <class _Tp> using rebind_alloc =
N                  typename __allocator_traits_rebind<allocator_type, _Tp>::type;
N    template <class _Tp> using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;
N#else  // _LIBCPP_CXX03_LANG
S    template <class _Tp> struct rebind_alloc
S        {typedef typename __allocator_traits_rebind<allocator_type, _Tp>::type other;};
S    template <class _Tp> struct rebind_traits
S        {typedef allocator_traits<typename rebind_alloc<_Tp>::other> other;};
N#endif  // _LIBCPP_CXX03_LANG
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    static pointer allocate(allocator_type& __a, size_type __n)
N        {return __a.allocate(__n);}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    static pointer allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)
N        {return __allocate(__a, __n, __hint,
N            __has_allocate_hint<allocator_type, size_type, const_void_pointer>());}
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    static void deallocate(allocator_type& __a, pointer __p, size_type __n) _NOEXCEPT
X    static void deallocate(allocator_type& __a, pointer __p, size_type __n) noexcept
N        {__a.deallocate(__p, __n);}
N
N#ifndef _LIBCPP_HAS_NO_VARIADICS
N    template <class _Tp, class... _Args>
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        static void construct(allocator_type& __a, _Tp* __p, _Args&&... __args)
N            {__construct(__has_construct<allocator_type, _Tp*, _Args...>(),
N                         __a, __p, _VSTD::forward<_Args>(__args)...);}
X                         __a, __p, std::__2::forward<_Args>(__args)...);}
N#else  // _LIBCPP_HAS_NO_VARIADICS
S    template <class _Tp>
S        _LIBCPP_INLINE_VISIBILITY
S        static void construct(allocator_type&, _Tp* __p)
S            {
S                ::new ((void*)__p) _Tp();
S            }
S    template <class _Tp, class _A0>
S        _LIBCPP_INLINE_VISIBILITY
S        static void construct(allocator_type&, _Tp* __p, const _A0& __a0)
S            {
S                ::new ((void*)__p) _Tp(__a0);
S            }
S    template <class _Tp, class _A0, class _A1>
S        _LIBCPP_INLINE_VISIBILITY
S        static void construct(allocator_type&, _Tp* __p, const _A0& __a0,
S                              const _A1& __a1)
S            {
S                ::new ((void*)__p) _Tp(__a0, __a1);
S            }
S    template <class _Tp, class _A0, class _A1, class _A2>
S        _LIBCPP_INLINE_VISIBILITY
S        static void construct(allocator_type&, _Tp* __p, const _A0& __a0,
S                              const _A1& __a1, const _A2& __a2)
S            {
S                ::new ((void*)__p) _Tp(__a0, __a1, __a2);
S            }
N#endif  // _LIBCPP_HAS_NO_VARIADICS
N
N    template <class _Tp>
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        static void destroy(allocator_type& __a, _Tp* __p)
N            {__destroy(__has_destroy<allocator_type, _Tp*>(), __a, __p);}
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    static size_type max_size(const allocator_type& __a) _NOEXCEPT
X    static size_type max_size(const allocator_type& __a) noexcept
N        {return __max_size(__has_max_size<const allocator_type>(), __a);}
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    static allocator_type
N        select_on_container_copy_construction(const allocator_type& __a)
N            {return __select_on_container_copy_construction(
N                __has_select_on_container_copy_construction<const allocator_type>(),
N                __a);}
N
N    template <class _Ptr>
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        static
N        void
N        __construct_forward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __begin2)
N        {
N            for (; __begin1 != __end1; ++__begin1, ++__begin2)
N                construct(__a, _VSTD::__to_raw_pointer(__begin2), _VSTD::move_if_noexcept(*__begin1));
X                construct(__a, std::__2::__to_raw_pointer(__begin2), std::__2::move_if_noexcept(*__begin1));
N        }
N
N    template <class _Tp>
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        static
N        typename enable_if
N        <
N            (is_same<allocator_type, allocator<_Tp> >::value
N                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&
N             is_trivially_move_constructible<_Tp>::value,
N            void
N        >::type
N        __construct_forward(allocator_type&, _Tp* __begin1, _Tp* __end1, _Tp*& __begin2)
N        {
N            ptrdiff_t _Np = __end1 - __begin1;
N            if (_Np > 0)
N            {
N                _VSTD::memcpy(__begin2, __begin1, _Np * sizeof(_Tp));
X                std::__2::memcpy(__begin2, __begin1, _Np * sizeof(_Tp));
N                __begin2 += _Np;
N            }
N        }
N
N    template <class _Iter, class _Ptr>
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        static
N        void
N        __construct_range_forward(allocator_type& __a, _Iter __begin1, _Iter __end1, _Ptr& __begin2)
N        {
N            for (; __begin1 != __end1; ++__begin1, (void) ++__begin2)
N                construct(__a, _VSTD::__to_raw_pointer(__begin2), *__begin1);
X                construct(__a, std::__2::__to_raw_pointer(__begin2), *__begin1);
N        }
N
N    template <class _Tp>
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        static
N        typename enable_if
N        <
N            (is_same<allocator_type, allocator<_Tp> >::value
N                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&
N             is_trivially_move_constructible<_Tp>::value,
N            void
N        >::type
N        __construct_range_forward(allocator_type&, _Tp* __begin1, _Tp* __end1, _Tp*& __begin2)
N        {
N            typedef typename remove_const<_Tp>::type _Vp;
N            ptrdiff_t _Np = __end1 - __begin1;
N            if (_Np > 0)
N            {
N                _VSTD::memcpy(const_cast<_Vp*>(__begin2), __begin1, _Np * sizeof(_Tp));
X                std::__2::memcpy(const_cast<_Vp*>(__begin2), __begin1, _Np * sizeof(_Tp));
N                __begin2 += _Np;
N            }
N        }
N
N    template <class _Ptr>
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        static
N        void
N        __construct_backward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __end2)
N        {
N            while (__end1 != __begin1)
N            {
N                construct(__a, _VSTD::__to_raw_pointer(__end2-1), _VSTD::move_if_noexcept(*--__end1));
X                construct(__a, std::__2::__to_raw_pointer(__end2-1), std::__2::move_if_noexcept(*--__end1));
N                --__end2;
N            }
N        }
N
N    template <class _Tp>
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        static
N        typename enable_if
N        <
N            (is_same<allocator_type, allocator<_Tp> >::value
N                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&
N             is_trivially_move_constructible<_Tp>::value,
N            void
N        >::type
N        __construct_backward(allocator_type&, _Tp* __begin1, _Tp* __end1, _Tp*& __end2)
N        {
N            ptrdiff_t _Np = __end1 - __begin1;
N            __end2 -= _Np;
N            if (_Np > 0)
N                _VSTD::memcpy(__end2, __begin1, _Np * sizeof(_Tp));
X                std::__2::memcpy(__end2, __begin1, _Np * sizeof(_Tp));
N        }
N
Nprivate:
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    static pointer __allocate(allocator_type& __a, size_type __n,
N        const_void_pointer __hint, true_type)
N        {return __a.allocate(__n, __hint);}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    static pointer __allocate(allocator_type& __a, size_type __n,
N        const_void_pointer, false_type)
N        {return __a.allocate(__n);}
N
N#ifndef _LIBCPP_HAS_NO_VARIADICS
N    template <class _Tp, class... _Args>
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        static void __construct(true_type, allocator_type& __a, _Tp* __p, _Args&&... __args)
N            {__a.construct(__p, _VSTD::forward<_Args>(__args)...);}
X            {__a.construct(__p, std::__2::forward<_Args>(__args)...);}
N    template <class _Tp, class... _Args>
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        static void __construct(false_type, allocator_type&, _Tp* __p, _Args&&... __args)
N            {
N                ::new ((void*)__p) _Tp(_VSTD::forward<_Args>(__args)...);
X                ::new ((void*)__p) _Tp(std::__2::forward<_Args>(__args)...);
N            }
N#endif  // _LIBCPP_HAS_NO_VARIADICS
N
N    template <class _Tp>
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        static void __destroy(true_type, allocator_type& __a, _Tp* __p)
N            {__a.destroy(__p);}
N    template <class _Tp>
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        static void __destroy(false_type, allocator_type&, _Tp* __p)
N            {
N                __p->~_Tp();
N            }
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    static size_type __max_size(true_type, const allocator_type& __a)
N            {return __a.max_size();}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    static size_type __max_size(false_type, const allocator_type&)
N            {return numeric_limits<size_type>::max(); }
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    static allocator_type
N        __select_on_container_copy_construction(true_type, const allocator_type& __a)
N            {return __a.select_on_container_copy_construction();}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    static allocator_type
N        __select_on_container_copy_construction(false_type, const allocator_type& __a)
N            {return __a;}
N};
N
Ntemplate <class _Traits, class _Tp>
Nstruct __rebind_alloc_helper
N{
N#ifndef _LIBCPP_CXX03_LANG
N    typedef typename _Traits::template rebind_alloc<_Tp>        type;
N#else
S    typedef typename _Traits::template rebind_alloc<_Tp>::other type;
N#endif
N};
N
N// allocator
N
Ntemplate <class _Tp>
Nclass _LIBCPP_TEMPLATE_VIS allocator
Xclass  allocator
N{
Npublic:
N    typedef size_t            size_type;
N    typedef ptrdiff_t         difference_type;
N    typedef _Tp*              pointer;
N    typedef const _Tp*        const_pointer;
N    typedef _Tp&              reference;
N    typedef const _Tp&        const_reference;
N    typedef _Tp               value_type;
N
N    typedef true_type propagate_on_container_move_assignment;
N    typedef true_type is_always_equal;
N
N    template <class _Up> struct rebind {typedef allocator<_Up> other;};
N
N    _LIBCPP_INLINE_VISIBILITY allocator() _NOEXCEPT {}
X    __attribute__ ((__always_inline__)) allocator() noexcept {}
N    template <class _Up> _LIBCPP_INLINE_VISIBILITY allocator(const allocator<_Up>&) _NOEXCEPT {}
X    template <class _Up> __attribute__ ((__always_inline__)) allocator(const allocator<_Up>&) noexcept {}
N    _LIBCPP_INLINE_VISIBILITY pointer address(reference __x) const _NOEXCEPT
X    __attribute__ ((__always_inline__)) pointer address(reference __x) const noexcept
N        {return _VSTD::addressof(__x);}
X        {return std::__2::addressof(__x);}
N    _LIBCPP_INLINE_VISIBILITY const_pointer address(const_reference __x) const _NOEXCEPT
X    __attribute__ ((__always_inline__)) const_pointer address(const_reference __x) const noexcept
N        {return _VSTD::addressof(__x);}
X        {return std::__2::addressof(__x);}
N    _LIBCPP_INLINE_VISIBILITY pointer allocate(size_type __n, allocator<void>::const_pointer = 0)
X    __attribute__ ((__always_inline__)) pointer allocate(size_type __n, allocator<void>::const_pointer = 0)
N        {
N        if (__n > max_size())
N            __throw_length_error("allocator<T>::allocate(size_t n)"
N                                 " 'n' exceeds maximum supported size");
N        return static_cast<pointer>(_VSTD::__allocate(__n * sizeof(_Tp)));
X        return static_cast<pointer>(std::__2::__allocate(__n * sizeof(_Tp)));
N        }
N    _LIBCPP_INLINE_VISIBILITY void deallocate(pointer __p, size_type) _NOEXCEPT
X    __attribute__ ((__always_inline__)) void deallocate(pointer __p, size_type) noexcept
N        {_VSTD::__libcpp_deallocate((void*)__p);}
X        {std::__2::__libcpp_deallocate((void*)__p);}
N    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT
X    __attribute__ ((__always_inline__)) size_type max_size() const noexcept
N        {return size_type(~0) / sizeof(_Tp);}
N#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)
X#if !0L && !0L
N    template <class _Up, class... _Args>
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        void
N        construct(_Up* __p, _Args&&... __args)
N        {
N            ::new((void*)__p) _Up(_VSTD::forward<_Args>(__args)...);
X            ::new((void*)__p) _Up(std::__2::forward<_Args>(__args)...);
N        }
N#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)
S        _LIBCPP_INLINE_VISIBILITY
S        void
S        construct(pointer __p)
S        {
S            ::new((void*)__p) _Tp();
S        }
S# if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)
S
S    template <class _A0>
S        _LIBCPP_INLINE_VISIBILITY
S        void
S        construct(pointer __p, _A0& __a0)
S        {
S            ::new((void*)__p) _Tp(__a0);
S        }
S    template <class _A0>
S        _LIBCPP_INLINE_VISIBILITY
S        void
S        construct(pointer __p, const _A0& __a0)
S        {
S            ::new((void*)__p) _Tp(__a0);
S        }
S# endif  // defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)
S    template <class _A0, class _A1>
S        _LIBCPP_INLINE_VISIBILITY
S        void
S        construct(pointer __p, _A0& __a0, _A1& __a1)
S        {
S            ::new((void*)__p) _Tp(__a0, __a1);
S        }
S    template <class _A0, class _A1>
S        _LIBCPP_INLINE_VISIBILITY
S        void
S        construct(pointer __p, const _A0& __a0, _A1& __a1)
S        {
S            ::new((void*)__p) _Tp(__a0, __a1);
S        }
S    template <class _A0, class _A1>
S        _LIBCPP_INLINE_VISIBILITY
S        void
S        construct(pointer __p, _A0& __a0, const _A1& __a1)
S        {
S            ::new((void*)__p) _Tp(__a0, __a1);
S        }
S    template <class _A0, class _A1>
S        _LIBCPP_INLINE_VISIBILITY
S        void
S        construct(pointer __p, const _A0& __a0, const _A1& __a1)
S        {
S            ::new((void*)__p) _Tp(__a0, __a1);
S        }
N#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)
N    _LIBCPP_INLINE_VISIBILITY void destroy(pointer __p) {__p->~_Tp();}
X    __attribute__ ((__always_inline__)) void destroy(pointer __p) {__p->~_Tp();}
N};
N
Ntemplate <class _Tp>
Nclass _LIBCPP_TEMPLATE_VIS allocator<const _Tp>
Xclass  allocator<const _Tp>
N{
Npublic:
N    typedef size_t            size_type;
N    typedef ptrdiff_t         difference_type;
N    typedef const _Tp*        pointer;
N    typedef const _Tp*        const_pointer;
N    typedef const _Tp&        reference;
N    typedef const _Tp&        const_reference;
N    typedef const _Tp         value_type;
N
N    typedef true_type propagate_on_container_move_assignment;
N    typedef true_type is_always_equal;
N
N    template <class _Up> struct rebind {typedef allocator<_Up> other;};
N
N    _LIBCPP_INLINE_VISIBILITY allocator() _NOEXCEPT {}
X    __attribute__ ((__always_inline__)) allocator() noexcept {}
N    template <class _Up> _LIBCPP_INLINE_VISIBILITY allocator(const allocator<_Up>&) _NOEXCEPT {}
X    template <class _Up> __attribute__ ((__always_inline__)) allocator(const allocator<_Up>&) noexcept {}
N    _LIBCPP_INLINE_VISIBILITY const_pointer address(const_reference __x) const _NOEXCEPT
X    __attribute__ ((__always_inline__)) const_pointer address(const_reference __x) const noexcept
N        {return _VSTD::addressof(__x);}
X        {return std::__2::addressof(__x);}
N    _LIBCPP_INLINE_VISIBILITY pointer allocate(size_type __n, allocator<void>::const_pointer = 0)
X    __attribute__ ((__always_inline__)) pointer allocate(size_type __n, allocator<void>::const_pointer = 0)
N    {
N        if (__n > max_size())
N            __throw_length_error("allocator<const T>::allocate(size_t n)"
N                                 " 'n' exceeds maximum supported size");
N        return static_cast<pointer>(_VSTD::__allocate(__n * sizeof(_Tp)));
X        return static_cast<pointer>(std::__2::__allocate(__n * sizeof(_Tp)));
N    }
N    _LIBCPP_INLINE_VISIBILITY void deallocate(pointer __p, size_type) _NOEXCEPT
X    __attribute__ ((__always_inline__)) void deallocate(pointer __p, size_type) noexcept
N        {_VSTD::__libcpp_deallocate((void*) const_cast<_Tp *>(__p));}
X        {std::__2::__libcpp_deallocate((void*) const_cast<_Tp *>(__p));}
N    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT
X    __attribute__ ((__always_inline__)) size_type max_size() const noexcept
N        {return size_type(~0) / sizeof(_Tp);}
N#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)
X#if !0L && !0L
N    template <class _Up, class... _Args>
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        void
N        construct(_Up* __p, _Args&&... __args)
N        {
N            ::new((void*)__p) _Up(_VSTD::forward<_Args>(__args)...);
X            ::new((void*)__p) _Up(std::__2::forward<_Args>(__args)...);
N        }
N#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)
S        _LIBCPP_INLINE_VISIBILITY
S        void
S        construct(pointer __p)
S        {
S            ::new((void*) const_cast<_Tp *>(__p)) _Tp();
S        }
S# if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)
S
S    template <class _A0>
S        _LIBCPP_INLINE_VISIBILITY
S        void
S        construct(pointer __p, _A0& __a0)
S        {
S            ::new((void*) const_cast<_Tp *>(__p)) _Tp(__a0);
S        }
S    template <class _A0>
S        _LIBCPP_INLINE_VISIBILITY
S        void
S        construct(pointer __p, const _A0& __a0)
S        {
S            ::new((void*) const_cast<_Tp *>(__p)) _Tp(__a0);
S        }
S# endif  // defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)
S    template <class _A0, class _A1>
S        _LIBCPP_INLINE_VISIBILITY
S        void
S        construct(pointer __p, _A0& __a0, _A1& __a1)
S        {
S            ::new((void*) const_cast<_Tp *>(__p)) _Tp(__a0, __a1);
S        }
S    template <class _A0, class _A1>
S        _LIBCPP_INLINE_VISIBILITY
S        void
S        construct(pointer __p, const _A0& __a0, _A1& __a1)
S        {
S            ::new((void*) const_cast<_Tp *>(__p)) _Tp(__a0, __a1);
S        }
S    template <class _A0, class _A1>
S        _LIBCPP_INLINE_VISIBILITY
S        void
S        construct(pointer __p, _A0& __a0, const _A1& __a1)
S        {
S            ::new((void*) const_cast<_Tp *>(__p)) _Tp(__a0, __a1);
S        }
S    template <class _A0, class _A1>
S        _LIBCPP_INLINE_VISIBILITY
S        void
S        construct(pointer __p, const _A0& __a0, const _A1& __a1)
S        {
S            ::new((void*) const_cast<_Tp *>(__p)) _Tp(__a0, __a1);
S        }
N#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)
N    _LIBCPP_INLINE_VISIBILITY void destroy(pointer __p) {__p->~_Tp();}
X    __attribute__ ((__always_inline__)) void destroy(pointer __p) {__p->~_Tp();}
N};
N
Ntemplate <class _Tp, class _Up>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool operator==(const allocator<_Tp>&, const allocator<_Up>&) _NOEXCEPT {return true;}
Xbool operator==(const allocator<_Tp>&, const allocator<_Up>&) noexcept {return true;}
N
Ntemplate <class _Tp, class _Up>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool operator!=(const allocator<_Tp>&, const allocator<_Up>&) _NOEXCEPT {return false;}
Xbool operator!=(const allocator<_Tp>&, const allocator<_Up>&) noexcept {return false;}
N
Ntemplate <class _OutputIterator, class _Tp>
Nclass _LIBCPP_TEMPLATE_VIS raw_storage_iterator
Xclass  raw_storage_iterator
N    : public iterator<output_iterator_tag,
N                      _Tp,                                         // purposefully not C++03
N                      ptrdiff_t,                                   // purposefully not C++03
N                      _Tp*,                                        // purposefully not C++03
N                      raw_storage_iterator<_OutputIterator, _Tp>&> // purposefully not C++03
N{
Nprivate:
N    _OutputIterator __x_;
Npublic:
N    _LIBCPP_INLINE_VISIBILITY explicit raw_storage_iterator(_OutputIterator __x) : __x_(__x) {}
X    __attribute__ ((__always_inline__)) explicit raw_storage_iterator(_OutputIterator __x) : __x_(__x) {}
N    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator*() {return *this;}
X    __attribute__ ((__always_inline__)) raw_storage_iterator& operator*() {return *this;}
N    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator=(const _Tp& __element)
X    __attribute__ ((__always_inline__)) raw_storage_iterator& operator=(const _Tp& __element)
N        {::new(&*__x_) _Tp(__element); return *this;}
N#if _LIBCPP_STD_VER >= 14
X#if 14 >= 14
N    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator=(_Tp&& __element)
X    __attribute__ ((__always_inline__)) raw_storage_iterator& operator=(_Tp&& __element)
N        {::new(&*__x_) _Tp(_VSTD::move(__element)); return *this;}
X        {::new(&*__x_) _Tp(std::__2::move(__element)); return *this;}
N#endif
N    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator++() {++__x_; return *this;}
X    __attribute__ ((__always_inline__)) raw_storage_iterator& operator++() {++__x_; return *this;}
N    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator  operator++(int)
X    __attribute__ ((__always_inline__)) raw_storage_iterator  operator++(int)
N        {raw_storage_iterator __t(*this); ++__x_; return __t;}
N#if _LIBCPP_STD_VER >= 14
X#if 14 >= 14
N    _LIBCPP_INLINE_VISIBILITY _OutputIterator base() const { return __x_; }
X    __attribute__ ((__always_inline__)) _OutputIterator base() const { return __x_; }
N#endif
N};
N
Ntemplate <class _Tp>
Npair<_Tp*, ptrdiff_t>
Nget_temporary_buffer(ptrdiff_t __n) _NOEXCEPT
Xget_temporary_buffer(ptrdiff_t __n) noexcept
N{
N    pair<_Tp*, ptrdiff_t> __r(0, 0);
N    const ptrdiff_t __m = (~ptrdiff_t(0) ^
N                           ptrdiff_t(ptrdiff_t(1) << (sizeof(ptrdiff_t) * __CHAR_BIT__ - 1)))
X                           ptrdiff_t(ptrdiff_t(1) << (sizeof(ptrdiff_t) * 8 - 1)))
N                           / sizeof(_Tp);
N    if (__n > __m)
N        __n = __m;
N    while (__n > 0)
N    {
N        __r.first = static_cast<_Tp*>(::operator new(__n * sizeof(_Tp), nothrow));
N        if (__r.first)
N        {
N            __r.second = __n;
N            break;
N        }
N        __n /= 2;
N    }
N    return __r;
N}
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid return_temporary_buffer(_Tp* __p) _NOEXCEPT {::operator delete(__p);}
Xvoid return_temporary_buffer(_Tp* __p) noexcept {::operator delete(__p);}
N
N#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)
X#if 14 <= 14 || 0L
Ntemplate <class _Tp>
Nstruct auto_ptr_ref
N{
N    _Tp* __ptr_;
N};
N
Ntemplate<class _Tp>
Nclass _LIBCPP_TEMPLATE_VIS auto_ptr
Xclass  auto_ptr
N{
Nprivate:
N    _Tp* __ptr_;
Npublic:
N    typedef _Tp element_type;
N
N    _LIBCPP_INLINE_VISIBILITY explicit auto_ptr(_Tp* __p = 0) throw() : __ptr_(__p) {}
X    __attribute__ ((__always_inline__)) explicit auto_ptr(_Tp* __p = 0) throw() : __ptr_(__p) {}
N    _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr& __p) throw() : __ptr_(__p.release()) {}
X    __attribute__ ((__always_inline__)) auto_ptr(auto_ptr& __p) throw() : __ptr_(__p.release()) {}
N    template<class _Up> _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr<_Up>& __p) throw()
X    template<class _Up> __attribute__ ((__always_inline__)) auto_ptr(auto_ptr<_Up>& __p) throw()
N        : __ptr_(__p.release()) {}
N    _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr& __p) throw()
X    __attribute__ ((__always_inline__)) auto_ptr& operator=(auto_ptr& __p) throw()
N        {reset(__p.release()); return *this;}
N    template<class _Up> _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr<_Up>& __p) throw()
X    template<class _Up> __attribute__ ((__always_inline__)) auto_ptr& operator=(auto_ptr<_Up>& __p) throw()
N        {reset(__p.release()); return *this;}
N    _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr_ref<_Tp> __p) throw()
X    __attribute__ ((__always_inline__)) auto_ptr& operator=(auto_ptr_ref<_Tp> __p) throw()
N        {reset(__p.__ptr_); return *this;}
N    _LIBCPP_INLINE_VISIBILITY ~auto_ptr() throw() {delete __ptr_;}
X    __attribute__ ((__always_inline__)) ~auto_ptr() throw() {delete __ptr_;}
N
N    _LIBCPP_INLINE_VISIBILITY _Tp& operator*() const throw()
X    __attribute__ ((__always_inline__)) _Tp& operator*() const throw()
N        {return *__ptr_;}
N    _LIBCPP_INLINE_VISIBILITY _Tp* operator->() const throw() {return __ptr_;}
X    __attribute__ ((__always_inline__)) _Tp* operator->() const throw() {return __ptr_;}
N    _LIBCPP_INLINE_VISIBILITY _Tp* get() const throw() {return __ptr_;}
X    __attribute__ ((__always_inline__)) _Tp* get() const throw() {return __ptr_;}
N    _LIBCPP_INLINE_VISIBILITY _Tp* release() throw()
X    __attribute__ ((__always_inline__)) _Tp* release() throw()
N    {
N        _Tp* __t = __ptr_;
N        __ptr_ = 0;
N        return __t;
N    }
N    _LIBCPP_INLINE_VISIBILITY void reset(_Tp* __p = 0) throw()
X    __attribute__ ((__always_inline__)) void reset(_Tp* __p = 0) throw()
N    {
N        if (__ptr_ != __p)
N            delete __ptr_;
N        __ptr_ = __p;
N    }
N
N    _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr_ref<_Tp> __p) throw() : __ptr_(__p.__ptr_) {}
X    __attribute__ ((__always_inline__)) auto_ptr(auto_ptr_ref<_Tp> __p) throw() : __ptr_(__p.__ptr_) {}
N    template<class _Up> _LIBCPP_INLINE_VISIBILITY operator auto_ptr_ref<_Up>() throw()
X    template<class _Up> __attribute__ ((__always_inline__)) operator auto_ptr_ref<_Up>() throw()
N        {auto_ptr_ref<_Up> __t; __t.__ptr_ = release(); return __t;}
N    template<class _Up> _LIBCPP_INLINE_VISIBILITY operator auto_ptr<_Up>() throw()
X    template<class _Up> __attribute__ ((__always_inline__)) operator auto_ptr<_Up>() throw()
N        {return auto_ptr<_Up>(release());}
N};
N
Ntemplate <>
Nclass _LIBCPP_TEMPLATE_VIS auto_ptr<void>
Xclass  auto_ptr<void>
N{
Npublic:
N    typedef void element_type;
N};
N#endif
N
Ntemplate <class _Tp, int _Idx,
N          bool _CanBeEmptyBase =
N              is_empty<_Tp>::value && !__libcpp_is_final<_Tp>::value>
Nstruct __compressed_pair_elem {
N  typedef _Tp _ParamT;
N  typedef _Tp& reference;
N  typedef const _Tp& const_reference;
N
N#ifndef _LIBCPP_CXX03_LANG
N  constexpr __compressed_pair_elem() : __value_() {}
N
N  template <class _Up, class = typename enable_if<
N      !is_same<__compressed_pair_elem, typename decay<_Up>::type>::value
N  >::type>
N  constexpr explicit
N  __compressed_pair_elem(_Up&& __u)
N      : __value_(_VSTD::forward<_Up>(__u)){};
X      : __value_(std::__2::forward<_Up>(__u)){};
N
N  template <class... _Args, size_t... _Indexes>
N  _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
X  __attribute__ ((__always_inline__)) 
N  __compressed_pair_elem(piecewise_construct_t, tuple<_Args...> __args,
N                         __tuple_indices<_Indexes...>)
N      : __value_(_VSTD::forward<_Args>(_VSTD::get<_Indexes>(__args))...) {}
X      : __value_(std::__2::forward<_Args>(std::__2::get<_Indexes>(__args))...) {}
N#else
S  __compressed_pair_elem() : __value_() {}
S  __compressed_pair_elem(_ParamT __p) : __value_(std::forward<_ParamT>(__p)) {}
N#endif
N
N  reference __get() _NOEXCEPT { return __value_; }
X  reference __get() noexcept { return __value_; }
N  const_reference __get() const _NOEXCEPT { return __value_; }
X  const_reference __get() const noexcept { return __value_; }
N
Nprivate:
N  _Tp __value_;
N};
N
Ntemplate <class _Tp, int _Idx>
Nstruct __compressed_pair_elem<_Tp, _Idx, true> : private _Tp {
N  typedef _Tp _ParamT;
N  typedef _Tp& reference;
N  typedef const _Tp& const_reference;
N  typedef _Tp __value_type;
N
N#ifndef _LIBCPP_CXX03_LANG
N  constexpr __compressed_pair_elem() = default;
N
N  template <class _Up, class = typename enable_if<
N        !is_same<__compressed_pair_elem, typename decay<_Up>::type>::value
N  >::type>
N  constexpr explicit
N  __compressed_pair_elem(_Up&& __u)
N      : __value_type(_VSTD::forward<_Up>(__u)){};
X      : __value_type(std::__2::forward<_Up>(__u)){};
N
N  template <class... _Args, size_t... _Indexes>
N  _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
X  __attribute__ ((__always_inline__)) 
N  __compressed_pair_elem(piecewise_construct_t, tuple<_Args...> __args,
N                         __tuple_indices<_Indexes...>)
N      : __value_type(_VSTD::forward<_Args>(_VSTD::get<_Indexes>(__args))...) {}
X      : __value_type(std::__2::forward<_Args>(std::__2::get<_Indexes>(__args))...) {}
N#else
S  __compressed_pair_elem() : __value_type() {}
S  __compressed_pair_elem(_ParamT __p)
S      : __value_type(std::forward<_ParamT>(__p)) {}
N#endif
N
N  reference __get() _NOEXCEPT { return *this; }
X  reference __get() noexcept { return *this; }
N  const_reference __get() const _NOEXCEPT { return *this; }
X  const_reference __get() const noexcept { return *this; }
N};
N
N// Tag used to construct the second element of the compressed pair.
Nstruct __second_tag {};
N
Ntemplate <class _T1, class _T2>
Nclass __compressed_pair : private __compressed_pair_elem<_T1, 0>,
N                          private __compressed_pair_elem<_T2, 1> {
N  typedef __compressed_pair_elem<_T1, 0> _Base1;
N  typedef __compressed_pair_elem<_T2, 1> _Base2;
N
N  // NOTE: This static assert should never fire because __compressed_pair
N  // is *almost never* used in a scenario where it's possible for T1 == T2.
N  // (The exception is std::function where it is possible that the function
N  //  object and the allocator have the same type).
N  static_assert((!is_same<_T1, _T2>::value),
N    "__compressed_pair cannot be instantated when T1 and T2 are the same type; "
N    "The current implementation is NOT ABI-compatible with the previous "
N    "implementation for this configuration");
N
Npublic:
N#ifndef _LIBCPP_CXX03_LANG
N  template <bool _Dummy = true,
N      class = typename enable_if<
N          __dependent_type<is_default_constructible<_T1>, _Dummy>::value &&
N          __dependent_type<is_default_constructible<_T2>, _Dummy>::value
N      >::type
N  >
N  _LIBCPP_INLINE_VISIBILITY
X  __attribute__ ((__always_inline__))
N  constexpr __compressed_pair() {}
N
N  template <class _Tp, typename enable_if<!is_same<typename decay<_Tp>::type,
N                                                   __compressed_pair>::value,
N                                          bool>::type = true>
N  _LIBCPP_INLINE_VISIBILITY constexpr explicit
X  __attribute__ ((__always_inline__)) constexpr explicit
N  __compressed_pair(_Tp&& __t)
N      : _Base1(std::forward<_Tp>(__t)), _Base2() {}
N
N  template <class _Tp>
N  _LIBCPP_INLINE_VISIBILITY constexpr
X  __attribute__ ((__always_inline__)) constexpr
N  __compressed_pair(__second_tag, _Tp&& __t)
N      : _Base1(), _Base2(std::forward<_Tp>(__t)) {}
N
N  template <class _U1, class _U2>
N  _LIBCPP_INLINE_VISIBILITY constexpr
X  __attribute__ ((__always_inline__)) constexpr
N  __compressed_pair(_U1&& __t1, _U2&& __t2)
N      : _Base1(std::forward<_U1>(__t1)), _Base2(std::forward<_U2>(__t2)) {}
N
N  template <class... _Args1, class... _Args2>
N  _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14
X  __attribute__ ((__always_inline__)) 
N  __compressed_pair(piecewise_construct_t __pc, tuple<_Args1...> __first_args,
N                    tuple<_Args2...> __second_args)
N      : _Base1(__pc, _VSTD::move(__first_args),
X      : _Base1(__pc, std::__2::move(__first_args),
N               typename __make_tuple_indices<sizeof...(_Args1)>::type()),
N        _Base2(__pc, _VSTD::move(__second_args),
X        _Base2(__pc, std::__2::move(__second_args),
N               typename __make_tuple_indices<sizeof...(_Args2)>::type()) {}
N
N#else
S  _LIBCPP_INLINE_VISIBILITY
S  __compressed_pair() {}
S
S  _LIBCPP_INLINE_VISIBILITY explicit
S  __compressed_pair(_T1 __t1) : _Base1(_VSTD::forward<_T1>(__t1)) {}
S
S  _LIBCPP_INLINE_VISIBILITY
S  __compressed_pair(__second_tag, _T2 __t2)
S      : _Base1(), _Base2(_VSTD::forward<_T2>(__t2)) {}
S
S  _LIBCPP_INLINE_VISIBILITY
S  __compressed_pair(_T1 __t1, _T2 __t2)
S      : _Base1(_VSTD::forward<_T1>(__t1)), _Base2(_VSTD::forward<_T2>(__t2)) {}
N#endif
N
N  _LIBCPP_INLINE_VISIBILITY
X  __attribute__ ((__always_inline__))
N  typename _Base1::reference first() _NOEXCEPT {
X  typename _Base1::reference first() noexcept {
N    return static_cast<_Base1&>(*this).__get();
N  }
N
N  _LIBCPP_INLINE_VISIBILITY
X  __attribute__ ((__always_inline__))
N  typename _Base1::const_reference first() const _NOEXCEPT {
X  typename _Base1::const_reference first() const noexcept {
N    return static_cast<_Base1 const&>(*this).__get();
N  }
N
N  _LIBCPP_INLINE_VISIBILITY
X  __attribute__ ((__always_inline__))
N  typename _Base2::reference second() _NOEXCEPT {
X  typename _Base2::reference second() noexcept {
N    return static_cast<_Base2&>(*this).__get();
N  }
N
N  _LIBCPP_INLINE_VISIBILITY
X  __attribute__ ((__always_inline__))
N  typename _Base2::const_reference second() const _NOEXCEPT {
X  typename _Base2::const_reference second() const noexcept {
N    return static_cast<_Base2 const&>(*this).__get();
N  }
N
N  _LIBCPP_INLINE_VISIBILITY
X  __attribute__ ((__always_inline__))
N  void swap(__compressed_pair& __x)
N    _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&
N               __is_nothrow_swappable<_T2>::value)
X    noexcept(__is_nothrow_swappable<_T1> ::value && __is_nothrow_swappable<_T2> ::value)
N  {
N    using std::swap;
N    swap(first(), __x.first());
N    swap(second(), __x.second());
N  }
N};
N
Ntemplate <class _T1, class _T2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid swap(__compressed_pair<_T1, _T2>& __x, __compressed_pair<_T1, _T2>& __y)
N    _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&
N               __is_nothrow_swappable<_T2>::value) {
X    noexcept(__is_nothrow_swappable<_T1> ::value && __is_nothrow_swappable<_T2> ::value) {
N  __x.swap(__y);
N}
N
N// default_delete
N
Ntemplate <class _Tp>
Nstruct _LIBCPP_TEMPLATE_VIS default_delete {
Xstruct  default_delete {
N    static_assert(!is_function<_Tp>::value,
N                  "default_delete cannot be instantiated for function types");
N#ifndef _LIBCPP_CXX03_LANG
N  _LIBCPP_INLINE_VISIBILITY constexpr default_delete() noexcept = default;
X  __attribute__ ((__always_inline__)) constexpr default_delete() noexcept = default;
N#else
S  _LIBCPP_INLINE_VISIBILITY default_delete() {}
N#endif
N  template <class _Up>
N  _LIBCPP_INLINE_VISIBILITY
X  __attribute__ ((__always_inline__))
N  default_delete(const default_delete<_Up>&,
N                 typename enable_if<is_convertible<_Up*, _Tp*>::value>::type* =
N                     0) _NOEXCEPT {}
X                     0) noexcept {}
N
N  _LIBCPP_INLINE_VISIBILITY void operator()(_Tp* __ptr) const _NOEXCEPT {
X  __attribute__ ((__always_inline__)) void operator()(_Tp* __ptr) const noexcept {
N    static_assert(sizeof(_Tp) > 0,
N                  "default_delete can not delete incomplete type");
N    static_assert(!is_void<_Tp>::value,
N                  "default_delete can not delete incomplete type");
N    delete __ptr;
N  }
N};
N
Ntemplate <class _Tp>
Nstruct _LIBCPP_TEMPLATE_VIS default_delete<_Tp[]> {
Xstruct  default_delete<_Tp[]> {
Nprivate:
N  template <class _Up>
N  struct _EnableIfConvertible
N      : enable_if<is_convertible<_Up(*)[], _Tp(*)[]>::value> {};
N
Npublic:
N#ifndef _LIBCPP_CXX03_LANG
N  _LIBCPP_INLINE_VISIBILITY constexpr default_delete() noexcept = default;
X  __attribute__ ((__always_inline__)) constexpr default_delete() noexcept = default;
N#else
S  _LIBCPP_INLINE_VISIBILITY default_delete() {}
N#endif
N
N  template <class _Up>
N  _LIBCPP_INLINE_VISIBILITY
X  __attribute__ ((__always_inline__))
N  default_delete(const default_delete<_Up[]>&,
N                 typename _EnableIfConvertible<_Up>::type* = 0) _NOEXCEPT {}
X                 typename _EnableIfConvertible<_Up>::type* = 0) noexcept {}
N
N  template <class _Up>
N  _LIBCPP_INLINE_VISIBILITY
X  __attribute__ ((__always_inline__))
N  typename _EnableIfConvertible<_Up>::type
N  operator()(_Up* __ptr) const _NOEXCEPT {
X  operator()(_Up* __ptr) const noexcept {
N    static_assert(sizeof(_Tp) > 0,
N                  "default_delete can not delete incomplete type");
N    static_assert(!is_void<_Tp>::value,
N                  "default_delete can not delete void type");
N    delete[] __ptr;
N  }
N};
N
N
N
N#ifndef _LIBCPP_CXX03_LANG
Ntemplate <class _Deleter>
Nstruct __unique_ptr_deleter_sfinae {
N  static_assert(!is_reference<_Deleter>::value, "incorrect specialization");
N  typedef const _Deleter& __lval_ref_type;
N  typedef _Deleter&& __good_rval_ref_type;
N  typedef true_type __enable_rval_overload;
N};
N
Ntemplate <class _Deleter>
Nstruct __unique_ptr_deleter_sfinae<_Deleter const&> {
N  typedef const _Deleter& __lval_ref_type;
N  typedef const _Deleter&& __bad_rval_ref_type;
N  typedef false_type __enable_rval_overload;
N};
N
Ntemplate <class _Deleter>
Nstruct __unique_ptr_deleter_sfinae<_Deleter&> {
N  typedef _Deleter& __lval_ref_type;
N  typedef _Deleter&& __bad_rval_ref_type;
N  typedef false_type __enable_rval_overload;
N};
N#endif // !defined(_LIBCPP_CXX03_LANG)
N
Ntemplate <class _Tp, class _Dp = default_delete<_Tp> >
Nclass _LIBCPP_TEMPLATE_VIS unique_ptr {
Xclass  unique_ptr {
Npublic:
N  typedef _Tp element_type;
N  typedef _Dp deleter_type;
N  typedef typename __pointer_type<_Tp, deleter_type>::type pointer;
N
N  static_assert(!is_rvalue_reference<deleter_type>::value,
N                "the specified deleter type cannot be an rvalue reference");
N
Nprivate:
N  __compressed_pair<pointer, deleter_type> __ptr_;
N
N  struct __nat { int __for_bool_; };
N
N#ifndef _LIBCPP_CXX03_LANG
N  typedef __unique_ptr_deleter_sfinae<_Dp> _DeleterSFINAE;
N
N  template <bool _Dummy>
N  using _LValRefType =
N      typename __dependent_type<_DeleterSFINAE, _Dummy>::__lval_ref_type;
N
N  template <bool _Dummy>
N  using _GoodRValRefType =
N      typename __dependent_type<_DeleterSFINAE, _Dummy>::__good_rval_ref_type;
N
N  template <bool _Dummy>
N  using _BadRValRefType =
N      typename __dependent_type<_DeleterSFINAE, _Dummy>::__bad_rval_ref_type;
N
N  template <bool _Dummy, class _Deleter = typename __dependent_type<
N                             __identity<deleter_type>, _Dummy>::type>
N  using _EnableIfDeleterDefaultConstructible =
N      typename enable_if<is_default_constructible<_Deleter>::value &&
N                         !is_pointer<_Deleter>::value>::type;
N
N  template <class _ArgType>
N  using _EnableIfDeleterConstructible =
N      typename enable_if<is_constructible<deleter_type, _ArgType>::value>::type;
N
N  template <class _UPtr, class _Up>
N  using _EnableIfMoveConvertible = typename enable_if<
N      is_convertible<typename _UPtr::pointer, pointer>::value &&
N      !is_array<_Up>::value
N  >::type;
N
N  template <class _UDel>
N  using _EnableIfDeleterConvertible = typename enable_if<
N      (is_reference<_Dp>::value && is_same<_Dp, _UDel>::value) ||
N      (!is_reference<_Dp>::value && is_convertible<_UDel, _Dp>::value)
N    >::type;
N
N  template <class _UDel>
N  using _EnableIfDeleterAssignable = typename enable_if<
N      is_assignable<_Dp&, _UDel&&>::value
N    >::type;
N
Npublic:
N  template <bool _Dummy = true,
N            class = _EnableIfDeleterDefaultConstructible<_Dummy>>
N  _LIBCPP_INLINE_VISIBILITY
X  __attribute__ ((__always_inline__))
N  constexpr unique_ptr() noexcept : __ptr_(pointer()) {}
N
N  template <bool _Dummy = true,
N            class = _EnableIfDeleterDefaultConstructible<_Dummy>>
N  _LIBCPP_INLINE_VISIBILITY
X  __attribute__ ((__always_inline__))
N  constexpr unique_ptr(nullptr_t) noexcept : __ptr_(pointer()) {}
N
N  template <bool _Dummy = true,
N            class = _EnableIfDeleterDefaultConstructible<_Dummy>>
N  _LIBCPP_INLINE_VISIBILITY
X  __attribute__ ((__always_inline__))
N  explicit unique_ptr(pointer __p) noexcept : __ptr_(__p) {}
N
N  template <bool _Dummy = true,
N            class = _EnableIfDeleterConstructible<_LValRefType<_Dummy>>>
N  _LIBCPP_INLINE_VISIBILITY
X  __attribute__ ((__always_inline__))
N  unique_ptr(pointer __p, _LValRefType<_Dummy> __d) noexcept
N      : __ptr_(__p, __d) {}
N
N  template <bool _Dummy = true,
N            class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy>>>
N  _LIBCPP_INLINE_VISIBILITY
X  __attribute__ ((__always_inline__))
N  unique_ptr(pointer __p, _GoodRValRefType<_Dummy> __d) noexcept
N      : __ptr_(__p, _VSTD::move(__d)) {
X      : __ptr_(__p, std::__2::move(__d)) {
N    static_assert(!is_reference<deleter_type>::value,
N                  "rvalue deleter bound to reference");
N  }
N
N  template <bool _Dummy = true,
N            class = _EnableIfDeleterConstructible<_BadRValRefType<_Dummy>>>
N  _LIBCPP_INLINE_VISIBILITY
X  __attribute__ ((__always_inline__))
N  unique_ptr(pointer __p, _BadRValRefType<_Dummy> __d) = delete;
N
N  _LIBCPP_INLINE_VISIBILITY
X  __attribute__ ((__always_inline__))
N  unique_ptr(unique_ptr&& __u) noexcept
N      : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {
X      : __ptr_(__u.release(), std::__2::forward<deleter_type>(__u.get_deleter())) {
N  }
N
N  template <class _Up, class _Ep,
N      class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,
N      class = _EnableIfDeleterConvertible<_Ep>
N  >
N  _LIBCPP_INLINE_VISIBILITY
X  __attribute__ ((__always_inline__))
N  unique_ptr(unique_ptr<_Up, _Ep>&& __u) _NOEXCEPT
X  unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept
N      : __ptr_(__u.release(), _VSTD::forward<_Ep>(__u.get_deleter())) {}
X      : __ptr_(__u.release(), std::__2::forward<_Ep>(__u.get_deleter())) {}
N
N#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)
X#if 14 <= 14 || 0L
N  template <class _Up>
N  _LIBCPP_INLINE_VISIBILITY
X  __attribute__ ((__always_inline__))
N  unique_ptr(auto_ptr<_Up>&& __p,
N             typename enable_if<is_convertible<_Up*, _Tp*>::value &&
N                                    is_same<_Dp, default_delete<_Tp>>::value,
N                                __nat>::type = __nat()) _NOEXCEPT
X                                __nat>::type = __nat()) noexcept
N      : __ptr_(__p.release()) {}
N#endif
N
N  _LIBCPP_INLINE_VISIBILITY
X  __attribute__ ((__always_inline__))
N  unique_ptr& operator=(unique_ptr&& __u) _NOEXCEPT {
X  unique_ptr& operator=(unique_ptr&& __u) noexcept {
N    reset(__u.release());
N    __ptr_.second() = _VSTD::forward<deleter_type>(__u.get_deleter());
X    __ptr_.second() = std::__2::forward<deleter_type>(__u.get_deleter());
N    return *this;
N  }
N
N  template <class _Up, class _Ep,
N      class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,
N      class = _EnableIfDeleterAssignable<_Ep>
N  >
N  _LIBCPP_INLINE_VISIBILITY
X  __attribute__ ((__always_inline__))
N  unique_ptr& operator=(unique_ptr<_Up, _Ep>&& __u) _NOEXCEPT {
X  unique_ptr& operator=(unique_ptr<_Up, _Ep>&& __u) noexcept {
N    reset(__u.release());
N    __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());
X    __ptr_.second() = std::__2::forward<_Ep>(__u.get_deleter());
N    return *this;
N  }
N
N#else  // _LIBCPP_CXX03_LANG
Sprivate:
S  unique_ptr(unique_ptr&);
S  template <class _Up, class _Ep> unique_ptr(unique_ptr<_Up, _Ep>&);
S
S  unique_ptr& operator=(unique_ptr&);
S  template <class _Up, class _Ep> unique_ptr& operator=(unique_ptr<_Up, _Ep>&);
S
Spublic:
S  _LIBCPP_INLINE_VISIBILITY
S  unique_ptr() : __ptr_(pointer())
S  {
S    static_assert(!is_pointer<deleter_type>::value,
S                  "unique_ptr constructed with null function pointer deleter");
S    static_assert(is_default_constructible<deleter_type>::value,
S                  "unique_ptr::deleter_type is not default constructible");
S  }
S  _LIBCPP_INLINE_VISIBILITY
S  unique_ptr(nullptr_t) : __ptr_(pointer())
S  {
S    static_assert(!is_pointer<deleter_type>::value,
S                  "unique_ptr constructed with null function pointer deleter");
S  }
S  _LIBCPP_INLINE_VISIBILITY
S  explicit unique_ptr(pointer __p)
S      : __ptr_(_VSTD::move(__p)) {
S    static_assert(!is_pointer<deleter_type>::value,
S                  "unique_ptr constructed with null function pointer deleter");
S  }
S
S  _LIBCPP_INLINE_VISIBILITY
S  operator __rv<unique_ptr>() {
S    return __rv<unique_ptr>(*this);
S  }
S
S  _LIBCPP_INLINE_VISIBILITY
S  unique_ptr(__rv<unique_ptr> __u)
S      : __ptr_(__u->release(),
S               _VSTD::forward<deleter_type>(__u->get_deleter())) {}
S
S  template <class _Up, class _Ep>
S  _LIBCPP_INLINE_VISIBILITY
S  typename enable_if<
S      !is_array<_Up>::value &&
S          is_convertible<typename unique_ptr<_Up, _Ep>::pointer,
S                         pointer>::value &&
S          is_assignable<deleter_type&, _Ep&>::value,
S      unique_ptr&>::type
S  operator=(unique_ptr<_Up, _Ep> __u) {
S    reset(__u.release());
S    __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());
S    return *this;
S  }
S
S  _LIBCPP_INLINE_VISIBILITY
S  unique_ptr(pointer __p, deleter_type __d)
S      : __ptr_(_VSTD::move(__p), _VSTD::move(__d)) {}
N#endif // _LIBCPP_CXX03_LANG
N
N#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)
X#if 14 <= 14 || 0L
N  template <class _Up>
N  _LIBCPP_INLINE_VISIBILITY
X  __attribute__ ((__always_inline__))
N      typename enable_if<is_convertible<_Up*, _Tp*>::value &&
N                             is_same<_Dp, default_delete<_Tp> >::value,
N                         unique_ptr&>::type
N      operator=(auto_ptr<_Up> __p) {
N    reset(__p.release());
N    return *this;
N  }
N#endif
N
N  _LIBCPP_INLINE_VISIBILITY
X  __attribute__ ((__always_inline__))
N  ~unique_ptr() { reset(); }
N
N  _LIBCPP_INLINE_VISIBILITY
X  __attribute__ ((__always_inline__))
N  unique_ptr& operator=(nullptr_t) _NOEXCEPT {
X  unique_ptr& operator=(nullptr_t) noexcept {
N    reset();
N    return *this;
N  }
N
N  _LIBCPP_INLINE_VISIBILITY
X  __attribute__ ((__always_inline__))
N  typename add_lvalue_reference<_Tp>::type
N  operator*() const {
N    return *__ptr_.first();
N  }
N  _LIBCPP_INLINE_VISIBILITY
X  __attribute__ ((__always_inline__))
N  pointer operator->() const _NOEXCEPT {
X  pointer operator->() const noexcept {
N    return __ptr_.first();
N  }
N  _LIBCPP_INLINE_VISIBILITY
X  __attribute__ ((__always_inline__))
N  pointer get() const _NOEXCEPT {
X  pointer get() const noexcept {
N    return __ptr_.first();
N  }
N  _LIBCPP_INLINE_VISIBILITY
X  __attribute__ ((__always_inline__))
N  deleter_type& get_deleter() _NOEXCEPT {
X  deleter_type& get_deleter() noexcept {
N    return __ptr_.second();
N  }
N  _LIBCPP_INLINE_VISIBILITY
X  __attribute__ ((__always_inline__))
N  const deleter_type& get_deleter() const _NOEXCEPT {
X  const deleter_type& get_deleter() const noexcept {
N    return __ptr_.second();
N  }
N  _LIBCPP_INLINE_VISIBILITY
X  __attribute__ ((__always_inline__))
N  _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT {
X  explicit operator bool() const noexcept {
N    return __ptr_.first() != nullptr;
N  }
N
N  _LIBCPP_INLINE_VISIBILITY
X  __attribute__ ((__always_inline__))
N  pointer release() _NOEXCEPT {
X  pointer release() noexcept {
N    pointer __t = __ptr_.first();
N    __ptr_.first() = pointer();
N    return __t;
N  }
N
N  _LIBCPP_INLINE_VISIBILITY
X  __attribute__ ((__always_inline__))
N  void reset(pointer __p = pointer()) _NOEXCEPT {
X  void reset(pointer __p = pointer()) noexcept {
N    pointer __tmp = __ptr_.first();
N    __ptr_.first() = __p;
N    if (__tmp)
N      __ptr_.second()(__tmp);
N  }
N
N  _LIBCPP_INLINE_VISIBILITY
X  __attribute__ ((__always_inline__))
N  void swap(unique_ptr& __u) _NOEXCEPT {
X  void swap(unique_ptr& __u) noexcept {
N    __ptr_.swap(__u.__ptr_);
N  }
N};
N
N
Ntemplate <class _Tp, class _Dp>
Nclass _LIBCPP_TEMPLATE_VIS unique_ptr<_Tp[], _Dp> {
Xclass  unique_ptr<_Tp[], _Dp> {
Npublic:
N  typedef _Tp element_type;
N  typedef _Dp deleter_type;
N  typedef typename __pointer_type<_Tp, deleter_type>::type pointer;
N
Nprivate:
N  __compressed_pair<pointer, deleter_type> __ptr_;
N
N  template <class _From>
N  struct _CheckArrayPointerConversion : is_same<_From, pointer> {};
N
N  template <class _FromElem>
N  struct _CheckArrayPointerConversion<_FromElem*>
N      : integral_constant<bool,
N          is_same<_FromElem*, pointer>::value ||
N            (is_same<pointer, element_type*>::value &&
N             is_convertible<_FromElem(*)[], element_type(*)[]>::value)
N      >
N  {};
N
N#ifndef _LIBCPP_CXX03_LANG
N  typedef __unique_ptr_deleter_sfinae<_Dp> _DeleterSFINAE;
N
N  template <bool _Dummy>
N  using _LValRefType =
N      typename __dependent_type<_DeleterSFINAE, _Dummy>::__lval_ref_type;
N
N  template <bool _Dummy>
N  using _GoodRValRefType =
N      typename __dependent_type<_DeleterSFINAE, _Dummy>::__good_rval_ref_type;
N
N  template <bool _Dummy>
N  using _BadRValRefType =
N      typename __dependent_type<_DeleterSFINAE, _Dummy>::__bad_rval_ref_type;
N
N  template <bool _Dummy, class _Deleter = typename __dependent_type<
N                             __identity<deleter_type>, _Dummy>::type>
N  using _EnableIfDeleterDefaultConstructible =
N      typename enable_if<is_default_constructible<_Deleter>::value &&
N                         !is_pointer<_Deleter>::value>::type;
N
N  template <class _ArgType>
N  using _EnableIfDeleterConstructible =
N      typename enable_if<is_constructible<deleter_type, _ArgType>::value>::type;
N
N  template <class _Pp>
N  using _EnableIfPointerConvertible = typename enable_if<
N      _CheckArrayPointerConversion<_Pp>::value
N  >::type;
N
N  template <class _UPtr, class _Up,
N        class _ElemT = typename _UPtr::element_type>
N  using _EnableIfMoveConvertible = typename enable_if<
N      is_array<_Up>::value &&
N      is_same<pointer, element_type*>::value &&
N      is_same<typename _UPtr::pointer, _ElemT*>::value &&
N      is_convertible<_ElemT(*)[], element_type(*)[]>::value
N    >::type;
N
N  template <class _UDel>
N  using _EnableIfDeleterConvertible = typename enable_if<
N      (is_reference<_Dp>::value && is_same<_Dp, _UDel>::value) ||
N      (!is_reference<_Dp>::value && is_convertible<_UDel, _Dp>::value)
N    >::type;
N
N  template <class _UDel>
N  using _EnableIfDeleterAssignable = typename enable_if<
N      is_assignable<_Dp&, _UDel&&>::value
N    >::type;
N
Npublic:
N  template <bool _Dummy = true,
N            class = _EnableIfDeleterDefaultConstructible<_Dummy>>
N  _LIBCPP_INLINE_VISIBILITY
X  __attribute__ ((__always_inline__))
N  constexpr unique_ptr() noexcept : __ptr_(pointer()) {}
N
N  template <bool _Dummy = true,
N            class = _EnableIfDeleterDefaultConstructible<_Dummy>>
N  _LIBCPP_INLINE_VISIBILITY
X  __attribute__ ((__always_inline__))
N  constexpr unique_ptr(nullptr_t) noexcept : __ptr_(pointer()) {}
N
N  template <class _Pp, bool _Dummy = true,
N            class = _EnableIfDeleterDefaultConstructible<_Dummy>,
N            class = _EnableIfPointerConvertible<_Pp>>
N  _LIBCPP_INLINE_VISIBILITY
X  __attribute__ ((__always_inline__))
N  explicit unique_ptr(_Pp __p) noexcept
N      : __ptr_(__p) {}
N
N  template <class _Pp, bool _Dummy = true,
N            class = _EnableIfDeleterConstructible<_LValRefType<_Dummy>>,
N            class = _EnableIfPointerConvertible<_Pp>>
N  _LIBCPP_INLINE_VISIBILITY
X  __attribute__ ((__always_inline__))
N  unique_ptr(_Pp __p, _LValRefType<_Dummy> __d) noexcept
N      : __ptr_(__p, __d) {}
N
N  template <bool _Dummy = true,
N            class = _EnableIfDeleterConstructible<_LValRefType<_Dummy>>>
N  _LIBCPP_INLINE_VISIBILITY
X  __attribute__ ((__always_inline__))
N  unique_ptr(nullptr_t, _LValRefType<_Dummy> __d) noexcept
N      : __ptr_(nullptr, __d) {}
N
N  template <class _Pp, bool _Dummy = true,
N            class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy>>,
N            class = _EnableIfPointerConvertible<_Pp>>
N  _LIBCPP_INLINE_VISIBILITY
X  __attribute__ ((__always_inline__))
N  unique_ptr(_Pp __p, _GoodRValRefType<_Dummy> __d) noexcept
N      : __ptr_(__p, _VSTD::move(__d)) {
X      : __ptr_(__p, std::__2::move(__d)) {
N    static_assert(!is_reference<deleter_type>::value,
N                  "rvalue deleter bound to reference");
N  }
N
N  template <bool _Dummy = true,
N            class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy>>>
N  _LIBCPP_INLINE_VISIBILITY
X  __attribute__ ((__always_inline__))
N  unique_ptr(nullptr_t, _GoodRValRefType<_Dummy> __d) noexcept
N      : __ptr_(nullptr, _VSTD::move(__d)) {
X      : __ptr_(nullptr, std::__2::move(__d)) {
N    static_assert(!is_reference<deleter_type>::value,
N                  "rvalue deleter bound to reference");
N  }
N
N  template <class _Pp, bool _Dummy = true,
N            class = _EnableIfDeleterConstructible<_BadRValRefType<_Dummy>>,
N            class = _EnableIfPointerConvertible<_Pp>>
N  _LIBCPP_INLINE_VISIBILITY
X  __attribute__ ((__always_inline__))
N  unique_ptr(_Pp __p, _BadRValRefType<_Dummy> __d) = delete;
N
N  _LIBCPP_INLINE_VISIBILITY
X  __attribute__ ((__always_inline__))
N  unique_ptr(unique_ptr&& __u) noexcept
N      : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {
X      : __ptr_(__u.release(), std::__2::forward<deleter_type>(__u.get_deleter())) {
N  }
N
N  _LIBCPP_INLINE_VISIBILITY
X  __attribute__ ((__always_inline__))
N  unique_ptr& operator=(unique_ptr&& __u) noexcept {
N    reset(__u.release());
N    __ptr_.second() = _VSTD::forward<deleter_type>(__u.get_deleter());
X    __ptr_.second() = std::__2::forward<deleter_type>(__u.get_deleter());
N    return *this;
N  }
N
N  template <class _Up, class _Ep,
N      class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,
N      class = _EnableIfDeleterConvertible<_Ep>
N  >
N  _LIBCPP_INLINE_VISIBILITY
X  __attribute__ ((__always_inline__))
N  unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept
N      : __ptr_(__u.release(), _VSTD::forward<_Ep>(__u.get_deleter())) {
X      : __ptr_(__u.release(), std::__2::forward<_Ep>(__u.get_deleter())) {
N  }
N
N  template <class _Up, class _Ep,
N      class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,
N      class = _EnableIfDeleterAssignable<_Ep>
N  >
N  _LIBCPP_INLINE_VISIBILITY
X  __attribute__ ((__always_inline__))
N  unique_ptr&
N  operator=(unique_ptr<_Up, _Ep>&& __u) noexcept {
N    reset(__u.release());
N    __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());
X    __ptr_.second() = std::__2::forward<_Ep>(__u.get_deleter());
N    return *this;
N  }
N
N#else // _LIBCPP_CXX03_LANG
Sprivate:
S  template <class _Up> explicit unique_ptr(_Up);
S
S  unique_ptr(unique_ptr&);
S  template <class _Up> unique_ptr(unique_ptr<_Up>&);
S
S  unique_ptr& operator=(unique_ptr&);
S  template <class _Up> unique_ptr& operator=(unique_ptr<_Up>&);
S
S  template <class _Up>
S  unique_ptr(_Up __u,
S             typename conditional<
S                 is_reference<deleter_type>::value, deleter_type,
S                 typename add_lvalue_reference<const deleter_type>::type>::type,
S             typename enable_if<is_convertible<_Up, pointer>::value,
S                                __nat>::type = __nat());
Spublic:
S  _LIBCPP_INLINE_VISIBILITY
S  unique_ptr() : __ptr_(pointer()) {
S    static_assert(!is_pointer<deleter_type>::value,
S                  "unique_ptr constructed with null function pointer deleter");
S  }
S  _LIBCPP_INLINE_VISIBILITY
S  unique_ptr(nullptr_t) : __ptr_(pointer()) {
S    static_assert(!is_pointer<deleter_type>::value,
S                  "unique_ptr constructed with null function pointer deleter");
S  }
S
S  _LIBCPP_INLINE_VISIBILITY
S  explicit unique_ptr(pointer __p) : __ptr_(__p) {
S    static_assert(!is_pointer<deleter_type>::value,
S                  "unique_ptr constructed with null function pointer deleter");
S  }
S
S  _LIBCPP_INLINE_VISIBILITY
S  unique_ptr(pointer __p, deleter_type __d)
S      : __ptr_(__p, _VSTD::forward<deleter_type>(__d)) {}
S
S  _LIBCPP_INLINE_VISIBILITY
S  unique_ptr(nullptr_t, deleter_type __d)
S      : __ptr_(pointer(), _VSTD::forward<deleter_type>(__d)) {}
S
S  _LIBCPP_INLINE_VISIBILITY
S  operator __rv<unique_ptr>() {
S    return __rv<unique_ptr>(*this);
S  }
S
S  _LIBCPP_INLINE_VISIBILITY
S  unique_ptr(__rv<unique_ptr> __u)
S      : __ptr_(__u->release(),
S               _VSTD::forward<deleter_type>(__u->get_deleter())) {}
S
S  _LIBCPP_INLINE_VISIBILITY
S  unique_ptr& operator=(__rv<unique_ptr> __u) {
S    reset(__u->release());
S    __ptr_.second() = _VSTD::forward<deleter_type>(__u->get_deleter());
S    return *this;
S  }
S
N#endif // _LIBCPP_CXX03_LANG
N
Npublic:
N  _LIBCPP_INLINE_VISIBILITY
X  __attribute__ ((__always_inline__))
N  ~unique_ptr() { reset(); }
N
N  _LIBCPP_INLINE_VISIBILITY
X  __attribute__ ((__always_inline__))
N  unique_ptr& operator=(nullptr_t) _NOEXCEPT {
X  unique_ptr& operator=(nullptr_t) noexcept {
N    reset();
N    return *this;
N  }
N
N  _LIBCPP_INLINE_VISIBILITY
X  __attribute__ ((__always_inline__))
N  typename add_lvalue_reference<_Tp>::type
N  operator[](size_t __i) const {
N    return __ptr_.first()[__i];
N  }
N  _LIBCPP_INLINE_VISIBILITY
X  __attribute__ ((__always_inline__))
N  pointer get() const _NOEXCEPT {
X  pointer get() const noexcept {
N    return __ptr_.first();
N  }
N
N  _LIBCPP_INLINE_VISIBILITY
X  __attribute__ ((__always_inline__))
N  deleter_type& get_deleter() _NOEXCEPT {
X  deleter_type& get_deleter() noexcept {
N    return __ptr_.second();
N  }
N
N  _LIBCPP_INLINE_VISIBILITY
X  __attribute__ ((__always_inline__))
N  const deleter_type& get_deleter() const _NOEXCEPT {
X  const deleter_type& get_deleter() const noexcept {
N    return __ptr_.second();
N  }
N  _LIBCPP_INLINE_VISIBILITY
X  __attribute__ ((__always_inline__))
N  _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT {
X  explicit operator bool() const noexcept {
N    return __ptr_.first() != nullptr;
N  }
N
N  _LIBCPP_INLINE_VISIBILITY
X  __attribute__ ((__always_inline__))
N  pointer release() _NOEXCEPT {
X  pointer release() noexcept {
N    pointer __t = __ptr_.first();
N    __ptr_.first() = pointer();
N    return __t;
N  }
N
N  template <class _Pp>
N  _LIBCPP_INLINE_VISIBILITY
X  __attribute__ ((__always_inline__))
N  typename enable_if<
N      _CheckArrayPointerConversion<_Pp>::value
N  >::type
N  reset(_Pp __p) _NOEXCEPT {
X  reset(_Pp __p) noexcept {
N    pointer __tmp = __ptr_.first();
N    __ptr_.first() = __p;
N    if (__tmp)
N      __ptr_.second()(__tmp);
N  }
N
N  _LIBCPP_INLINE_VISIBILITY
X  __attribute__ ((__always_inline__))
N  void reset(nullptr_t = nullptr) _NOEXCEPT {
X  void reset(nullptr_t = nullptr) noexcept {
N    pointer __tmp = __ptr_.first();
N    __ptr_.first() = nullptr;
N    if (__tmp)
N      __ptr_.second()(__tmp);
N  }
N
N  _LIBCPP_INLINE_VISIBILITY
X  __attribute__ ((__always_inline__))
N  void swap(unique_ptr& __u) _NOEXCEPT {
X  void swap(unique_ptr& __u) noexcept {
N    __ptr_.swap(__u.__ptr_);
N  }
N
N};
N
Ntemplate <class _Tp, class _Dp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename enable_if<
N    __is_swappable<_Dp>::value,
N    void
N>::type
Nswap(unique_ptr<_Tp, _Dp>& __x, unique_ptr<_Tp, _Dp>& __y) _NOEXCEPT {__x.swap(__y);}
Xswap(unique_ptr<_Tp, _Dp>& __x, unique_ptr<_Tp, _Dp>& __y) noexcept {__x.swap(__y);}
N
Ntemplate <class _T1, class _D1, class _T2, class _D2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator==(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __x.get() == __y.get();}
N
Ntemplate <class _T1, class _D1, class _T2, class _D2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator!=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x == __y);}
N
Ntemplate <class _T1, class _D1, class _T2, class _D2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator< (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y)
N{
N    typedef typename unique_ptr<_T1, _D1>::pointer _P1;
N    typedef typename unique_ptr<_T2, _D2>::pointer _P2;
N    typedef typename common_type<_P1, _P2>::type _Vp;
N    return less<_Vp>()(__x.get(), __y.get());
N}
N
Ntemplate <class _T1, class _D1, class _T2, class _D2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator> (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __y < __x;}
N
Ntemplate <class _T1, class _D1, class _T2, class _D2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator<=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__y < __x);}
N
Ntemplate <class _T1, class _D1, class _T2, class _D2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator>=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x < __y);}
N
Ntemplate <class _T1, class _D1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator==(const unique_ptr<_T1, _D1>& __x, nullptr_t) _NOEXCEPT
Xoperator==(const unique_ptr<_T1, _D1>& __x, nullptr_t) noexcept
N{
N    return !__x;
N}
N
Ntemplate <class _T1, class _D1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator==(nullptr_t, const unique_ptr<_T1, _D1>& __x) _NOEXCEPT
Xoperator==(nullptr_t, const unique_ptr<_T1, _D1>& __x) noexcept
N{
N    return !__x;
N}
N
Ntemplate <class _T1, class _D1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator!=(const unique_ptr<_T1, _D1>& __x, nullptr_t) _NOEXCEPT
Xoperator!=(const unique_ptr<_T1, _D1>& __x, nullptr_t) noexcept
N{
N    return static_cast<bool>(__x);
N}
N
Ntemplate <class _T1, class _D1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator!=(nullptr_t, const unique_ptr<_T1, _D1>& __x) _NOEXCEPT
Xoperator!=(nullptr_t, const unique_ptr<_T1, _D1>& __x) noexcept
N{
N    return static_cast<bool>(__x);
N}
N
Ntemplate <class _T1, class _D1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator<(const unique_ptr<_T1, _D1>& __x, nullptr_t)
N{
N    typedef typename unique_ptr<_T1, _D1>::pointer _P1;
N    return less<_P1>()(__x.get(), nullptr);
N}
N
Ntemplate <class _T1, class _D1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator<(nullptr_t, const unique_ptr<_T1, _D1>& __x)
N{
N    typedef typename unique_ptr<_T1, _D1>::pointer _P1;
N    return less<_P1>()(nullptr, __x.get());
N}
N
Ntemplate <class _T1, class _D1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator>(const unique_ptr<_T1, _D1>& __x, nullptr_t)
N{
N    return nullptr < __x;
N}
N
Ntemplate <class _T1, class _D1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator>(nullptr_t, const unique_ptr<_T1, _D1>& __x)
N{
N    return __x < nullptr;
N}
N
Ntemplate <class _T1, class _D1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator<=(const unique_ptr<_T1, _D1>& __x, nullptr_t)
N{
N    return !(nullptr < __x);
N}
N
Ntemplate <class _T1, class _D1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator<=(nullptr_t, const unique_ptr<_T1, _D1>& __x)
N{
N    return !(__x < nullptr);
N}
N
Ntemplate <class _T1, class _D1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator>=(const unique_ptr<_T1, _D1>& __x, nullptr_t)
N{
N    return !(__x < nullptr);
N}
N
Ntemplate <class _T1, class _D1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator>=(nullptr_t, const unique_ptr<_T1, _D1>& __x)
N{
N    return !(nullptr < __x);
N}
N
N#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES
S
Stemplate <class _Tp, class _Dp>
Sinline _LIBCPP_INLINE_VISIBILITY
Sunique_ptr<_Tp, _Dp>
Smove(unique_ptr<_Tp, _Dp>& __t)
S{
S    return unique_ptr<_Tp, _Dp>(__rv<unique_ptr<_Tp, _Dp> >(__t));
S}
S
N#endif
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
N
Ntemplate<class _Tp>
Nstruct __unique_if
N{
N    typedef unique_ptr<_Tp> __unique_single;
N};
N
Ntemplate<class _Tp>
Nstruct __unique_if<_Tp[]>
N{
N    typedef unique_ptr<_Tp[]> __unique_array_unknown_bound;
N};
N
Ntemplate<class _Tp, size_t _Np>
Nstruct __unique_if<_Tp[_Np]>
N{
N    typedef void __unique_array_known_bound;
N};
N
Ntemplate<class _Tp, class... _Args>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename __unique_if<_Tp>::__unique_single
Nmake_unique(_Args&&... __args)
N{
N    return unique_ptr<_Tp>(new _Tp(_VSTD::forward<_Args>(__args)...));
X    return unique_ptr<_Tp>(new _Tp(std::__2::forward<_Args>(__args)...));
N}
N
Ntemplate<class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename __unique_if<_Tp>::__unique_array_unknown_bound
Nmake_unique(size_t __n)
N{
N    typedef typename remove_extent<_Tp>::type _Up;
N    return unique_ptr<_Tp>(new _Up[__n]());
N}
N
Ntemplate<class _Tp, class... _Args>
N    typename __unique_if<_Tp>::__unique_array_known_bound
N    make_unique(_Args&&...) = delete;
N
N#endif  // _LIBCPP_STD_VER > 11
N
Ntemplate <class _Tp, class _Dp>
N#ifdef _LIBCPP_CXX03_LANG
Sstruct _LIBCPP_TEMPLATE_VIS hash<unique_ptr<_Tp, _Dp> >
N#else
Nstruct _LIBCPP_TEMPLATE_VIS hash<__enable_hash_helper<
Xstruct  hash<__enable_hash_helper<
N    unique_ptr<_Tp, _Dp>, typename unique_ptr<_Tp, _Dp>::pointer>>
N#endif
N{
N    typedef unique_ptr<_Tp, _Dp> argument_type;
N    typedef size_t               result_type;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    result_type operator()(const argument_type& __ptr) const
N    {
N        typedef typename argument_type::pointer pointer;
N        return hash<pointer>()(__ptr.get());
N    }
N};
N
Nstruct __destruct_n
N{
Nprivate:
N    size_t __size_;
N
N    template <class _Tp>
N    _LIBCPP_INLINE_VISIBILITY void __process(_Tp* __p, false_type) _NOEXCEPT
X    __attribute__ ((__always_inline__)) void __process(_Tp* __p, false_type) noexcept
N        {for (size_t __i = 0; __i < __size_; ++__i, ++__p) __p->~_Tp();}
N
N    template <class _Tp>
N    _LIBCPP_INLINE_VISIBILITY void __process(_Tp*, true_type) _NOEXCEPT
X    __attribute__ ((__always_inline__)) void __process(_Tp*, true_type) noexcept
N        {}
N
N    _LIBCPP_INLINE_VISIBILITY void __incr(false_type) _NOEXCEPT
X    __attribute__ ((__always_inline__)) void __incr(false_type) noexcept
N        {++__size_;}
N    _LIBCPP_INLINE_VISIBILITY void __incr(true_type) _NOEXCEPT
X    __attribute__ ((__always_inline__)) void __incr(true_type) noexcept
N        {}
N
N    _LIBCPP_INLINE_VISIBILITY void __set(size_t __s, false_type) _NOEXCEPT
X    __attribute__ ((__always_inline__)) void __set(size_t __s, false_type) noexcept
N        {__size_ = __s;}
N    _LIBCPP_INLINE_VISIBILITY void __set(size_t, true_type) _NOEXCEPT
X    __attribute__ ((__always_inline__)) void __set(size_t, true_type) noexcept
N        {}
Npublic:
N    _LIBCPP_INLINE_VISIBILITY explicit __destruct_n(size_t __s) _NOEXCEPT
X    __attribute__ ((__always_inline__)) explicit __destruct_n(size_t __s) noexcept
N        : __size_(__s) {}
N
N    template <class _Tp>
N    _LIBCPP_INLINE_VISIBILITY void __incr(_Tp*) _NOEXCEPT
X    __attribute__ ((__always_inline__)) void __incr(_Tp*) noexcept
N        {__incr(integral_constant<bool, is_trivially_destructible<_Tp>::value>());}
N
N    template <class _Tp>
N    _LIBCPP_INLINE_VISIBILITY void __set(size_t __s, _Tp*) _NOEXCEPT
X    __attribute__ ((__always_inline__)) void __set(size_t __s, _Tp*) noexcept
N        {__set(__s, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}
N
N    template <class _Tp>
N    _LIBCPP_INLINE_VISIBILITY void operator()(_Tp* __p) _NOEXCEPT
X    __attribute__ ((__always_inline__)) void operator()(_Tp* __p) noexcept
N        {__process(__p, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}
N};
N
Ntemplate <class _Alloc>
Nclass __allocator_destructor
N{
N    typedef allocator_traits<_Alloc> __alloc_traits;
Npublic:
N    typedef typename __alloc_traits::pointer pointer;
N    typedef typename __alloc_traits::size_type size_type;
Nprivate:
N    _Alloc& __alloc_;
N    size_type __s_;
Npublic:
N    _LIBCPP_INLINE_VISIBILITY __allocator_destructor(_Alloc& __a, size_type __s)
X    __attribute__ ((__always_inline__)) __allocator_destructor(_Alloc& __a, size_type __s)
N             _NOEXCEPT
X             noexcept
N        : __alloc_(__a), __s_(__s) {}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    void operator()(pointer __p) _NOEXCEPT
X    void operator()(pointer __p) noexcept
N        {__alloc_traits::deallocate(__alloc_, __p, __s_);}
N};
N
Ntemplate <class _InputIterator, class _ForwardIterator>
N_ForwardIterator
Nuninitialized_copy(_InputIterator __f, _InputIterator __l, _ForwardIterator __r)
N{
N    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    _ForwardIterator __s = __r;
S    try
S    {
N#endif
N        for (; __f != __l; ++__f, (void) ++__r)
N            ::new (static_cast<void*>(_VSTD::addressof(*__r))) value_type(*__f);
X            ::new (static_cast<void*>(std::__2::addressof(*__r))) value_type(*__f);
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        for (; __s != __r; ++__s)
S            __s->~value_type();
S        throw;
S    }
N#endif
N    return __r;
N}
N
Ntemplate <class _InputIterator, class _Size, class _ForwardIterator>
N_ForwardIterator
Nuninitialized_copy_n(_InputIterator __f, _Size __n, _ForwardIterator __r)
N{
N    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    _ForwardIterator __s = __r;
S    try
S    {
N#endif
N        for (; __n > 0; ++__f, (void) ++__r, (void) --__n)
N            ::new (static_cast<void*>(_VSTD::addressof(*__r))) value_type(*__f);
X            ::new (static_cast<void*>(std::__2::addressof(*__r))) value_type(*__f);
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        for (; __s != __r; ++__s)
S            __s->~value_type();
S        throw;
S    }
N#endif
N    return __r;
N}
N
Ntemplate <class _ForwardIterator, class _Tp>
Nvoid
Nuninitialized_fill(_ForwardIterator __f, _ForwardIterator __l, const _Tp& __x)
N{
N    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    _ForwardIterator __s = __f;
S    try
S    {
N#endif
N        for (; __f != __l; ++__f)
N            ::new (static_cast<void*>(_VSTD::addressof(*__f))) value_type(__x);
X            ::new (static_cast<void*>(std::__2::addressof(*__f))) value_type(__x);
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        for (; __s != __f; ++__s)
S            __s->~value_type();
S        throw;
S    }
N#endif
N}
N
Ntemplate <class _ForwardIterator, class _Size, class _Tp>
N_ForwardIterator
Nuninitialized_fill_n(_ForwardIterator __f, _Size __n, const _Tp& __x)
N{
N    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    _ForwardIterator __s = __f;
S    try
S    {
N#endif
N        for (; __n > 0; ++__f, (void) --__n)
N            ::new (static_cast<void*>(_VSTD::addressof(*__f))) value_type(__x);
X            ::new (static_cast<void*>(std::__2::addressof(*__f))) value_type(__x);
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        for (; __s != __f; ++__s)
S            __s->~value_type();
S        throw;
S    }
N#endif
N    return __f;
N}
N
N#if _LIBCPP_STD_VER > 14
X#if 14 > 14
S
Stemplate <class _Tp>
Sinline _LIBCPP_INLINE_VISIBILITY
Svoid destroy_at(_Tp* __loc) {
S    _LIBCPP_ASSERT(__loc, "null pointer given to destroy_at");
S    __loc->~_Tp();
S}
S
Stemplate <class _ForwardIterator>
Sinline _LIBCPP_INLINE_VISIBILITY
Svoid destroy(_ForwardIterator __first, _ForwardIterator __last) {
S    for (; __first != __last; ++__first)
S        _VSTD::destroy_at(_VSTD::addressof(*__first));
S}
S
Stemplate <class _ForwardIterator, class _Size>
Sinline _LIBCPP_INLINE_VISIBILITY
S_ForwardIterator destroy_n(_ForwardIterator __first, _Size __n) {
S    for (; __n > 0; (void)++__first, --__n)
S        _VSTD::destroy_at(_VSTD::addressof(*__first));
S    return __first;
S}
S
Stemplate <class _ForwardIterator>
Sinline _LIBCPP_INLINE_VISIBILITY
Svoid uninitialized_default_construct(_ForwardIterator __first, _ForwardIterator __last) {
S    using _Vt = typename iterator_traits<_ForwardIterator>::value_type;
S    auto __idx = __first;
S#ifndef _LIBCPP_NO_EXCEPTIONS
S    try {
S#endif
S    for (; __idx != __last; ++__idx)
S        ::new((void*)_VSTD::addressof(*__idx)) _Vt;
S#ifndef _LIBCPP_NO_EXCEPTIONS
S    } catch (...) {
S        _VSTD::destroy(__first, __idx);
S        throw;
S    }
S#endif
S}
S
Stemplate <class _ForwardIterator, class _Size>
Sinline _LIBCPP_INLINE_VISIBILITY
S_ForwardIterator uninitialized_default_construct_n(_ForwardIterator __first, _Size __n) {
S    using _Vt = typename iterator_traits<_ForwardIterator>::value_type;
S    auto __idx = __first;
S#ifndef _LIBCPP_NO_EXCEPTIONS
S    try {
S#endif
S    for (; __n > 0; (void)++__idx, --__n)
S        ::new((void*)_VSTD::addressof(*__idx)) _Vt;
S    return __idx;
S#ifndef _LIBCPP_NO_EXCEPTIONS
S    } catch (...) {
S        _VSTD::destroy(__first, __idx);
S        throw;
S    }
S#endif
S}
S
S
Stemplate <class _ForwardIterator>
Sinline _LIBCPP_INLINE_VISIBILITY
Svoid uninitialized_value_construct(_ForwardIterator __first, _ForwardIterator __last) {
S    using _Vt = typename iterator_traits<_ForwardIterator>::value_type;
S    auto __idx = __first;
S#ifndef _LIBCPP_NO_EXCEPTIONS
S    try {
S#endif
S    for (; __idx != __last; ++__idx)
S        ::new((void*)_VSTD::addressof(*__idx)) _Vt();
S#ifndef _LIBCPP_NO_EXCEPTIONS
S    } catch (...) {
S        _VSTD::destroy(__first, __idx);
S        throw;
S    }
S#endif
S}
S
Stemplate <class _ForwardIterator, class _Size>
Sinline _LIBCPP_INLINE_VISIBILITY
S_ForwardIterator uninitialized_value_construct_n(_ForwardIterator __first, _Size __n) {
S    using _Vt = typename iterator_traits<_ForwardIterator>::value_type;
S    auto __idx = __first;
S#ifndef _LIBCPP_NO_EXCEPTIONS
S    try {
S#endif
S    for (; __n > 0; (void)++__idx, --__n)
S        ::new((void*)_VSTD::addressof(*__idx)) _Vt();
S    return __idx;
S#ifndef _LIBCPP_NO_EXCEPTIONS
S    } catch (...) {
S        _VSTD::destroy(__first, __idx);
S        throw;
S    }
S#endif
S}
S
S
Stemplate <class _InputIt, class _ForwardIt>
Sinline _LIBCPP_INLINE_VISIBILITY
S_ForwardIt uninitialized_move(_InputIt __first, _InputIt __last, _ForwardIt __first_res) {
S    using _Vt = typename iterator_traits<_ForwardIt>::value_type;
S    auto __idx = __first_res;
S#ifndef _LIBCPP_NO_EXCEPTIONS
S    try {
S#endif
S    for (; __first != __last; (void)++__idx, ++__first)
S        ::new((void*)_VSTD::addressof(*__idx)) _Vt(std::move(*__first));
S    return __idx;
S#ifndef _LIBCPP_NO_EXCEPTIONS
S    } catch (...) {
S        _VSTD::destroy(__first_res, __idx);
S        throw;
S    }
S#endif
S}
S
Stemplate <class _InputIt, class _Size, class _ForwardIt>
Sinline _LIBCPP_INLINE_VISIBILITY
Spair<_InputIt, _ForwardIt>
Suninitialized_move_n(_InputIt __first, _Size __n, _ForwardIt __first_res) {
S    using _Vt = typename iterator_traits<_ForwardIt>::value_type;
S    auto __idx = __first_res;
S#ifndef _LIBCPP_NO_EXCEPTIONS
S    try {
S#endif
S    for (; __n > 0; ++__idx, (void)++__first, --__n)
S        ::new((void*)_VSTD::addressof(*__idx)) _Vt(std::move(*__first));
S    return {__first, __idx};
S#ifndef _LIBCPP_NO_EXCEPTIONS
S    } catch (...) {
S        _VSTD::destroy(__first_res, __idx);
S        throw;
S    }
S#endif
S}
S
S
N#endif // _LIBCPP_STD_VER > 14
N
N// NOTE: Relaxed and acq/rel atomics (for increment and decrement respectively)
N// should be sufficient for thread safety.
N// See https://bugs.llvm.org/show_bug.cgi?id=22803
N#if defined(__clang__) && __has_builtin(__atomic_add_fetch)          \
N                       && defined(__ATOMIC_RELAXED)                  \
N                       && defined(__ATOMIC_ACQ_REL)
X#if 0L && 0                                 && 1L                                         && 1L
S#   define _LIBCPP_HAS_BUILTIN_ATOMIC_SUPPORT
S#elif !defined(__clang__) && defined(_GNUC_VER) && _GNUC_VER >= 407
X#elif !0L && 1L && 0 >= 407
S#   define _LIBCPP_HAS_BUILTIN_ATOMIC_SUPPORT
N#endif
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY _Tp
Xinline __attribute__ ((__always_inline__)) _Tp
N__libcpp_atomic_refcount_increment(_Tp& __t) _NOEXCEPT
X__libcpp_atomic_refcount_increment(_Tp& __t) noexcept
N{
N#if defined(_LIBCPP_HAS_BUILTIN_ATOMIC_SUPPORT) && !defined(_LIBCPP_HAS_NO_THREADS)
X#if 0L && !1L
S    return __atomic_add_fetch(&__t, 1, __ATOMIC_RELAXED);
N#else
N    return __t += 1;
N#endif
N}
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY _Tp
Xinline __attribute__ ((__always_inline__)) _Tp
N__libcpp_atomic_refcount_decrement(_Tp& __t) _NOEXCEPT
X__libcpp_atomic_refcount_decrement(_Tp& __t) noexcept
N{
N#if defined(_LIBCPP_HAS_BUILTIN_ATOMIC_SUPPORT) && !defined(_LIBCPP_HAS_NO_THREADS)
X#if 0L && !1L
S    return __atomic_add_fetch(&__t, -1, __ATOMIC_ACQ_REL);
N#else
N    return __t -= 1;
N#endif
N}
N
Nclass _LIBCPP_EXCEPTION_ABI bad_weak_ptr
Xclass  bad_weak_ptr
N    : public std::exception
N{
Npublic:
N    virtual ~bad_weak_ptr() _NOEXCEPT;
X    virtual ~bad_weak_ptr() noexcept;
N    virtual const char* what() const  _NOEXCEPT;
X    virtual const char* what() const  noexcept;
N};
N
N_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE
X[[noreturn]] inline __attribute__ ((__always_inline__))
Nvoid __throw_bad_weak_ptr()
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    throw bad_weak_ptr();
N#else
N    _VSTD::abort();
X    std::__2::abort();
N#endif
N}
N
Ntemplate<class _Tp> class _LIBCPP_TEMPLATE_VIS weak_ptr;
Xtemplate<class _Tp> class  weak_ptr;
N
Nclass _LIBCPP_TYPE_VIS __shared_count
Xclass  __shared_count
N{
N    __shared_count(const __shared_count&);
N    __shared_count& operator=(const __shared_count&);
N
Nprotected:
N    long __shared_owners_;
N    virtual ~__shared_count();
Nprivate:
N    virtual void __on_zero_shared() _NOEXCEPT = 0;
X    virtual void __on_zero_shared() noexcept = 0;
N
Npublic:
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    explicit __shared_count(long __refs = 0) _NOEXCEPT
X    explicit __shared_count(long __refs = 0) noexcept
N        : __shared_owners_(__refs) {}
N
N#if defined(_LIBCPP_BUILDING_MEMORY) && \
N    defined(_LIBCPP_DEPRECATED_ABI_LEGACY_LIBRARY_DEFINITIONS_FOR_INLINE_FUNCTIONS)
X#if 0L &&     0L
S    void __add_shared() _NOEXCEPT;
S    bool __release_shared() _NOEXCEPT;
N#else
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    void __add_shared() _NOEXCEPT {
X    void __add_shared() noexcept {
N      __libcpp_atomic_refcount_increment(__shared_owners_);
N    }
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    bool __release_shared() _NOEXCEPT {
X    bool __release_shared() noexcept {
N      if (__libcpp_atomic_refcount_decrement(__shared_owners_) == -1) {
N        __on_zero_shared();
N        return true;
N      }
N      return false;
N    }
N#endif
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    long use_count() const _NOEXCEPT {
X    long use_count() const noexcept {
N        return __libcpp_relaxed_load(&__shared_owners_) + 1;
N    }
N};
N
Nclass _LIBCPP_TYPE_VIS __shared_weak_count
Xclass  __shared_weak_count
N    : private __shared_count
N{
N    long __shared_weak_owners_;
N
Npublic:
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    explicit __shared_weak_count(long __refs = 0) _NOEXCEPT
X    explicit __shared_weak_count(long __refs = 0) noexcept
N        : __shared_count(__refs),
N          __shared_weak_owners_(__refs) {}
Nprotected:
N    virtual ~__shared_weak_count();
N
Npublic:
N#if defined(_LIBCPP_BUILDING_MEMORY) && \
N    defined(_LIBCPP_DEPRECATED_ABI_LEGACY_LIBRARY_DEFINITIONS_FOR_INLINE_FUNCTIONS)
X#if 0L &&     0L
S    void __add_shared() _NOEXCEPT;
S    void __add_weak() _NOEXCEPT;
S    void __release_shared() _NOEXCEPT;
N#else
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    void __add_shared() _NOEXCEPT {
X    void __add_shared() noexcept {
N      __shared_count::__add_shared();
N    }
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    void __add_weak() _NOEXCEPT {
X    void __add_weak() noexcept {
N      __libcpp_atomic_refcount_increment(__shared_weak_owners_);
N    }
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    void __release_shared() _NOEXCEPT {
X    void __release_shared() noexcept {
N      if (__shared_count::__release_shared())
N        __release_weak();
N    }
N#endif
N    void __release_weak() _NOEXCEPT;
X    void __release_weak() noexcept;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    long use_count() const _NOEXCEPT {return __shared_count::use_count();}
X    long use_count() const noexcept {return __shared_count::use_count();}
N    __shared_weak_count* lock() _NOEXCEPT;
X    __shared_weak_count* lock() noexcept;
N
N    // Define the function out only if we build static libc++ without RTTI.
N    // Otherwise we may break clients who need to compile their projects with
N    // -fno-rtti and yet link against a libc++.dylib compiled
N    // without -fno-rtti.
N#if !defined(_LIBCPP_NO_RTTI) || !defined(_LIBCPP_BUILD_STATIC)
X#if !0L || !0L
N    virtual const void* __get_deleter(const type_info&) const _NOEXCEPT;
X    virtual const void* __get_deleter(const type_info&) const noexcept;
N#endif
Nprivate:
N    virtual void __on_zero_shared_weak() _NOEXCEPT = 0;
X    virtual void __on_zero_shared_weak() noexcept = 0;
N};
N
Ntemplate <class _Tp, class _Dp, class _Alloc>
Nclass __shared_ptr_pointer
N    : public __shared_weak_count
N{
N    __compressed_pair<__compressed_pair<_Tp, _Dp>, _Alloc> __data_;
Npublic:
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    __shared_ptr_pointer(_Tp __p, _Dp __d, _Alloc __a)
N        :  __data_(__compressed_pair<_Tp, _Dp>(__p, _VSTD::move(__d)), _VSTD::move(__a)) {}
X        :  __data_(__compressed_pair<_Tp, _Dp>(__p, std::__2::move(__d)), std::__2::move(__a)) {}
N
N#ifndef _LIBCPP_NO_RTTI
N    virtual const void* __get_deleter(const type_info&) const _NOEXCEPT;
X    virtual const void* __get_deleter(const type_info&) const noexcept;
N#endif
N
Nprivate:
N    virtual void __on_zero_shared() _NOEXCEPT;
X    virtual void __on_zero_shared() noexcept;
N    virtual void __on_zero_shared_weak() _NOEXCEPT;
X    virtual void __on_zero_shared_weak() noexcept;
N};
N
N#ifndef _LIBCPP_NO_RTTI
N
Ntemplate <class _Tp, class _Dp, class _Alloc>
Nconst void*
N__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__get_deleter(const type_info& __t) const _NOEXCEPT
X__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__get_deleter(const type_info& __t) const noexcept
N{
N    return __t == typeid(_Dp) ? _VSTD::addressof(__data_.first().second()) : nullptr;
X    return __t == typeid(_Dp) ? std::__2::addressof(__data_.first().second()) : nullptr;
N}
N
N#endif  // _LIBCPP_NO_RTTI
N
Ntemplate <class _Tp, class _Dp, class _Alloc>
Nvoid
N__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared() _NOEXCEPT
X__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared() noexcept
N{
N    __data_.first().second()(__data_.first().first());
N    __data_.first().second().~_Dp();
N}
N
Ntemplate <class _Tp, class _Dp, class _Alloc>
Nvoid
N__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared_weak() _NOEXCEPT
X__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared_weak() noexcept
N{
N    typedef typename __allocator_traits_rebind<_Alloc, __shared_ptr_pointer>::type _Al;
N    typedef allocator_traits<_Al> _ATraits;
N    typedef pointer_traits<typename _ATraits::pointer> _PTraits;
N
N    _Al __a(__data_.second());
N    __data_.second().~_Alloc();
N    __a.deallocate(_PTraits::pointer_to(*this), 1);
N}
N
Ntemplate <class _Tp, class _Alloc>
Nclass __shared_ptr_emplace
N    : public __shared_weak_count
N{
N    __compressed_pair<_Alloc, _Tp> __data_;
Npublic:
N#ifndef _LIBCPP_HAS_NO_VARIADICS
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    __shared_ptr_emplace(_Alloc __a)
N        :  __data_(_VSTD::move(__a)) {}
X        :  __data_(std::__2::move(__a)) {}
N
N    template <class ..._Args>
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        __shared_ptr_emplace(_Alloc __a, _Args&& ...__args)
N            :  __data_(piecewise_construct, _VSTD::forward_as_tuple(__a),
X            :  __data_(piecewise_construct, std::__2::forward_as_tuple(__a),
N                   _VSTD::forward_as_tuple(_VSTD::forward<_Args>(__args)...)) {}
X                   std::__2::forward_as_tuple(std::__2::forward<_Args>(__args)...)) {}
N
N#else  // _LIBCPP_HAS_NO_VARIADICS
S
S    _LIBCPP_INLINE_VISIBILITY
S    __shared_ptr_emplace(_Alloc __a)
S        :  __data_(__a) {}
S
S    template <class _A0>
S        _LIBCPP_INLINE_VISIBILITY
S        __shared_ptr_emplace(_Alloc __a, _A0& __a0)
S            :  __data_(__a, _Tp(__a0)) {}
S
S    template <class _A0, class _A1>
S        _LIBCPP_INLINE_VISIBILITY
S        __shared_ptr_emplace(_Alloc __a, _A0& __a0, _A1& __a1)
S            :  __data_(__a, _Tp(__a0, __a1)) {}
S
S    template <class _A0, class _A1, class _A2>
S        _LIBCPP_INLINE_VISIBILITY
S        __shared_ptr_emplace(_Alloc __a, _A0& __a0, _A1& __a1, _A2& __a2)
S            :  __data_(__a, _Tp(__a0, __a1, __a2)) {}
S
N#endif  // _LIBCPP_HAS_NO_VARIADICS
N
Nprivate:
N    virtual void __on_zero_shared() _NOEXCEPT;
X    virtual void __on_zero_shared() noexcept;
N    virtual void __on_zero_shared_weak() _NOEXCEPT;
X    virtual void __on_zero_shared_weak() noexcept;
Npublic:
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _Tp* get() _NOEXCEPT {return &__data_.second();}
X    _Tp* get() noexcept {return &__data_.second();}
N};
N
Ntemplate <class _Tp, class _Alloc>
Nvoid
N__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared() _NOEXCEPT
X__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared() noexcept
N{
N    __data_.second().~_Tp();
N}
N
Ntemplate <class _Tp, class _Alloc>
Nvoid
N__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared_weak() _NOEXCEPT
X__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared_weak() noexcept
N{
N    typedef typename __allocator_traits_rebind<_Alloc, __shared_ptr_emplace>::type _Al;
N    typedef allocator_traits<_Al> _ATraits;
N    typedef pointer_traits<typename _ATraits::pointer> _PTraits;
N    _Al __a(__data_.first());
N    __data_.first().~_Alloc();
N    __a.deallocate(_PTraits::pointer_to(*this), 1);
N}
N
Nstruct __shared_ptr_dummy_rebind_allocator_type;
Ntemplate <>
Nclass _LIBCPP_TEMPLATE_VIS allocator<__shared_ptr_dummy_rebind_allocator_type>
Xclass  allocator<__shared_ptr_dummy_rebind_allocator_type>
N{
Npublic:
N    template <class _Other>
N    struct rebind
N    {
N        typedef allocator<_Other> other;
N    };
N};
N
Ntemplate<class _Tp> class _LIBCPP_TEMPLATE_VIS enable_shared_from_this;
Xtemplate<class _Tp> class  enable_shared_from_this;
N
Ntemplate<class _Tp>
Nclass _LIBCPP_TEMPLATE_VIS shared_ptr
Xclass  shared_ptr
N{
Npublic:
N    typedef _Tp element_type;
N
N#if _LIBCPP_STD_VER > 14
X#if 14 > 14
S    typedef weak_ptr<_Tp> weak_type;
N#endif
Nprivate:
N    element_type*      __ptr_;
N    __shared_weak_count* __cntrl_;
N
N    struct __nat {int __for_bool_;};
Npublic:
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _LIBCPP_CONSTEXPR shared_ptr() _NOEXCEPT;
X    constexpr shared_ptr() noexcept;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _LIBCPP_CONSTEXPR shared_ptr(nullptr_t) _NOEXCEPT;
X    constexpr shared_ptr(nullptr_t) noexcept;
N    template<class _Yp>
N        explicit shared_ptr(_Yp* __p,
N                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());
N    template<class _Yp, class _Dp>
N        shared_ptr(_Yp* __p, _Dp __d,
N                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());
N    template<class _Yp, class _Dp, class _Alloc>
N        shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,
N                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());
N    template <class _Dp> shared_ptr(nullptr_t __p, _Dp __d);
N    template <class _Dp, class _Alloc> shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a);
N    template<class _Yp> _LIBCPP_INLINE_VISIBILITY shared_ptr(const shared_ptr<_Yp>& __r, element_type* __p) _NOEXCEPT;
X    template<class _Yp> __attribute__ ((__always_inline__)) shared_ptr(const shared_ptr<_Yp>& __r, element_type* __p) noexcept;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    shared_ptr(const shared_ptr& __r) _NOEXCEPT;
X    shared_ptr(const shared_ptr& __r) noexcept;
N    template<class _Yp>
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        shared_ptr(const shared_ptr<_Yp>& __r,
N                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat())
N                       _NOEXCEPT;
X                       noexcept;
N#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    shared_ptr(shared_ptr&& __r) _NOEXCEPT;
X    shared_ptr(shared_ptr&& __r) noexcept;
N    template<class _Yp> _LIBCPP_INLINE_VISIBILITY  shared_ptr(shared_ptr<_Yp>&& __r,
X    template<class _Yp> __attribute__ ((__always_inline__))  shared_ptr(shared_ptr<_Yp>&& __r,
N                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat())
N                       _NOEXCEPT;
X                       noexcept;
N#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
N    template<class _Yp> explicit shared_ptr(const weak_ptr<_Yp>& __r,
N                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type= __nat());
N#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)
X#if 14 <= 14 || 0L
N#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
N    template<class _Yp>
N        shared_ptr(auto_ptr<_Yp>&& __r,
N                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());
N#else
S    template<class _Yp>
S        shared_ptr(auto_ptr<_Yp> __r,
S                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());
N#endif
N#endif
N#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
N    template <class _Yp, class _Dp>
N        shared_ptr(unique_ptr<_Yp, _Dp>&&,
N                   typename enable_if
N                   <
N                       !is_lvalue_reference<_Dp>::value &&
N                       !is_array<_Yp>::value &&
N                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,
N                       __nat
N                   >::type = __nat());
N    template <class _Yp, class _Dp>
N        shared_ptr(unique_ptr<_Yp, _Dp>&&,
N                   typename enable_if
N                   <
N                       is_lvalue_reference<_Dp>::value &&
N                       !is_array<_Yp>::value &&
N                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,
N                       __nat
N                   >::type = __nat());
N#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
S    template <class _Yp, class _Dp>
S        shared_ptr(unique_ptr<_Yp, _Dp>,
S                   typename enable_if
S                   <
S                       !is_lvalue_reference<_Dp>::value &&
S                       !is_array<_Yp>::value &&
S                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,
S                       __nat
S                   >::type = __nat());
S    template <class _Yp, class _Dp>
S        shared_ptr(unique_ptr<_Yp, _Dp>,
S                   typename enable_if
S                   <
S                       is_lvalue_reference<_Dp>::value &&
S                       !is_array<_Yp>::value &&
S                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,
S                       __nat
S                   >::type = __nat());
N#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
N
N    ~shared_ptr();
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    shared_ptr& operator=(const shared_ptr& __r) _NOEXCEPT;
X    shared_ptr& operator=(const shared_ptr& __r) noexcept;
N    template<class _Yp>
N        typename enable_if
N        <
N            is_convertible<_Yp*, element_type*>::value,
N            shared_ptr&
N        >::type
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        operator=(const shared_ptr<_Yp>& __r) _NOEXCEPT;
X        operator=(const shared_ptr<_Yp>& __r) noexcept;
N#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    shared_ptr& operator=(shared_ptr&& __r) _NOEXCEPT;
X    shared_ptr& operator=(shared_ptr&& __r) noexcept;
N    template<class _Yp>
N        typename enable_if
N        <
N            is_convertible<_Yp*, element_type*>::value,
N            shared_ptr<_Tp>&
N        >::type
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        operator=(shared_ptr<_Yp>&& __r);
N#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)
X#if 14 <= 14 || 0L
N    template<class _Yp>
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        typename enable_if
N        <
N            !is_array<_Yp>::value &&
N            is_convertible<_Yp*, element_type*>::value,
N            shared_ptr
N        >::type&
N        operator=(auto_ptr<_Yp>&& __r);
N#endif
N#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
S#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)
S    template<class _Yp>
S        _LIBCPP_INLINE_VISIBILITY
S        typename enable_if
S        <
S            !is_array<_Yp>::value &&
S            is_convertible<_Yp*, element_type*>::value,
S            shared_ptr&
S        >::type
S        operator=(auto_ptr<_Yp> __r);
S#endif
N#endif
N    template <class _Yp, class _Dp>
N        typename enable_if
N        <
N            !is_array<_Yp>::value &&
N            is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,
N            shared_ptr&
N        >::type
N#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        operator=(unique_ptr<_Yp, _Dp>&& __r);
N#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
S        _LIBCPP_INLINE_VISIBILITY
S        operator=(unique_ptr<_Yp, _Dp> __r);
N#endif
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    void swap(shared_ptr& __r) _NOEXCEPT;
X    void swap(shared_ptr& __r) noexcept;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    void reset() _NOEXCEPT;
X    void reset() noexcept;
N    template<class _Yp>
N        typename enable_if
N        <
N            is_convertible<_Yp*, element_type*>::value,
N            void
N        >::type
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        reset(_Yp* __p);
N    template<class _Yp, class _Dp>
N        typename enable_if
N        <
N            is_convertible<_Yp*, element_type*>::value,
N            void
N        >::type
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        reset(_Yp* __p, _Dp __d);
N    template<class _Yp, class _Dp, class _Alloc>
N        typename enable_if
N        <
N            is_convertible<_Yp*, element_type*>::value,
N            void
N        >::type
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        reset(_Yp* __p, _Dp __d, _Alloc __a);
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    element_type* get() const _NOEXCEPT {return __ptr_;}
X    element_type* get() const noexcept {return __ptr_;}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    typename add_lvalue_reference<element_type>::type operator*() const _NOEXCEPT
X    typename add_lvalue_reference<element_type>::type operator*() const noexcept
N        {return *__ptr_;}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    element_type* operator->() const _NOEXCEPT {return __ptr_;}
X    element_type* operator->() const noexcept {return __ptr_;}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    long use_count() const _NOEXCEPT {return __cntrl_ ? __cntrl_->use_count() : 0;}
X    long use_count() const noexcept {return __cntrl_ ? __cntrl_->use_count() : 0;}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    bool unique() const _NOEXCEPT {return use_count() == 1;}
X    bool unique() const noexcept {return use_count() == 1;}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT {return get() != 0;}
X    explicit operator bool() const noexcept {return get() != 0;}
N    template <class _Up>
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        bool owner_before(shared_ptr<_Up> const& __p) const _NOEXCEPT
X        bool owner_before(shared_ptr<_Up> const& __p) const noexcept
N        {return __cntrl_ < __p.__cntrl_;}
N    template <class _Up>
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        bool owner_before(weak_ptr<_Up> const& __p) const _NOEXCEPT
X        bool owner_before(weak_ptr<_Up> const& __p) const noexcept
N        {return __cntrl_ < __p.__cntrl_;}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    bool
N    __owner_equivalent(const shared_ptr& __p) const
N        {return __cntrl_ == __p.__cntrl_;}
N
N#ifndef _LIBCPP_NO_RTTI
N    template <class _Dp>
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        _Dp* __get_deleter() const _NOEXCEPT
X        _Dp* __get_deleter() const noexcept
N            {return static_cast<_Dp*>(__cntrl_
N                    ? const_cast<void *>(__cntrl_->__get_deleter(typeid(_Dp)))
N                      : nullptr);}
N#endif  // _LIBCPP_NO_RTTI
N
N#ifndef _LIBCPP_HAS_NO_VARIADICS
N
N    template<class ..._Args>
N        static
N        shared_ptr<_Tp>
N        make_shared(_Args&& ...__args);
N
N    template<class _Alloc, class ..._Args>
N        static
N        shared_ptr<_Tp>
N        allocate_shared(const _Alloc& __a, _Args&& ...__args);
N
N#else  // _LIBCPP_HAS_NO_VARIADICS
S
S    static shared_ptr<_Tp> make_shared();
S
S    template<class _A0>
S        static shared_ptr<_Tp> make_shared(_A0&);
S
S    template<class _A0, class _A1>
S        static shared_ptr<_Tp> make_shared(_A0&, _A1&);
S
S    template<class _A0, class _A1, class _A2>
S        static shared_ptr<_Tp> make_shared(_A0&, _A1&, _A2&);
S
S    template<class _Alloc>
S        static shared_ptr<_Tp>
S        allocate_shared(const _Alloc& __a);
S
S    template<class _Alloc, class _A0>
S        static shared_ptr<_Tp>
S        allocate_shared(const _Alloc& __a, _A0& __a0);
S
S    template<class _Alloc, class _A0, class _A1>
S        static shared_ptr<_Tp>
S        allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1);
S
S    template<class _Alloc, class _A0, class _A1, class _A2>
S        static shared_ptr<_Tp>
S        allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2);
S
N#endif  // _LIBCPP_HAS_NO_VARIADICS
N
Nprivate:
N    template <class _Yp, bool = is_function<_Yp>::value>
N        struct __shared_ptr_default_allocator
N        {
N            typedef allocator<_Yp> type;
N        };
N
N    template <class _Yp>
N        struct __shared_ptr_default_allocator<_Yp, true>
N        {
N            typedef allocator<__shared_ptr_dummy_rebind_allocator_type> type;
N        };
N
N    template <class _Yp, class _OrigPtr>
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        typename enable_if<is_convertible<_OrigPtr*,
N                                          const enable_shared_from_this<_Yp>*
N        >::value,
N            void>::type
N        __enable_weak_this(const enable_shared_from_this<_Yp>* __e,
N                           _OrigPtr* __ptr) _NOEXCEPT
X                           _OrigPtr* __ptr) noexcept
N        {
N            typedef typename remove_cv<_Yp>::type _RawYp;
N            if (__e && __e->__weak_this_.expired())
N            {
N                __e->__weak_this_ = shared_ptr<_RawYp>(*this,
N                    const_cast<_RawYp*>(static_cast<const _Yp*>(__ptr)));
N            }
N        }
N
N    _LIBCPP_INLINE_VISIBILITY void __enable_weak_this(...) _NOEXCEPT {}
X    __attribute__ ((__always_inline__)) void __enable_weak_this(...) noexcept {}
N
N    template <class _Up> friend class _LIBCPP_TEMPLATE_VIS shared_ptr;
X    template <class _Up> friend class  shared_ptr;
N    template <class _Up> friend class _LIBCPP_TEMPLATE_VIS weak_ptr;
X    template <class _Up> friend class  weak_ptr;
N};
N
N
Ntemplate<class _Tp>
Ninline
N_LIBCPP_CONSTEXPR
Xconstexpr
Nshared_ptr<_Tp>::shared_ptr() _NOEXCEPT
Xshared_ptr<_Tp>::shared_ptr() noexcept
N    : __ptr_(0),
N      __cntrl_(0)
N{
N}
N
Ntemplate<class _Tp>
Ninline
N_LIBCPP_CONSTEXPR
Xconstexpr
Nshared_ptr<_Tp>::shared_ptr(nullptr_t) _NOEXCEPT
Xshared_ptr<_Tp>::shared_ptr(nullptr_t) noexcept
N    : __ptr_(0),
N      __cntrl_(0)
N{
N}
N
Ntemplate<class _Tp>
Ntemplate<class _Yp>
Nshared_ptr<_Tp>::shared_ptr(_Yp* __p,
N                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)
N    : __ptr_(__p)
N{
N    unique_ptr<_Yp> __hold(__p);
N    typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;
N    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, _AllocT > _CntrlBlk;
N    __cntrl_ = new _CntrlBlk(__p, default_delete<_Yp>(), _AllocT());
N    __hold.release();
N    __enable_weak_this(__p, __p);
N}
N
Ntemplate<class _Tp>
Ntemplate<class _Yp, class _Dp>
Nshared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d,
N                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)
N    : __ptr_(__p)
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;
N        typedef __shared_ptr_pointer<_Yp*, _Dp, _AllocT > _CntrlBlk;
N        __cntrl_ = new _CntrlBlk(__p, __d, _AllocT());
N        __enable_weak_this(__p, __p);
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        __d(__p);
S        throw;
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N}
N
Ntemplate<class _Tp>
Ntemplate<class _Dp>
Nshared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d)
N    : __ptr_(0)
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        typedef typename __shared_ptr_default_allocator<_Tp>::type _AllocT;
N        typedef __shared_ptr_pointer<nullptr_t, _Dp, _AllocT > _CntrlBlk;
N        __cntrl_ = new _CntrlBlk(__p, __d, _AllocT());
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        __d(__p);
S        throw;
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N}
N
Ntemplate<class _Tp>
Ntemplate<class _Yp, class _Dp, class _Alloc>
Nshared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,
N                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)
N    : __ptr_(__p)
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        typedef __shared_ptr_pointer<_Yp*, _Dp, _Alloc> _CntrlBlk;
N        typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;
N        typedef __allocator_destructor<_A2> _D2;
N        _A2 __a2(__a);
N        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
N        ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))
X        ::new(static_cast<void*>(std::__2::addressof(*__hold2.get())))
N            _CntrlBlk(__p, __d, __a);
N        __cntrl_ = _VSTD::addressof(*__hold2.release());
X        __cntrl_ = std::__2::addressof(*__hold2.release());
N        __enable_weak_this(__p, __p);
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        __d(__p);
S        throw;
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N}
N
Ntemplate<class _Tp>
Ntemplate<class _Dp, class _Alloc>
Nshared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a)
N    : __ptr_(0)
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        typedef __shared_ptr_pointer<nullptr_t, _Dp, _Alloc> _CntrlBlk;
N        typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;
N        typedef __allocator_destructor<_A2> _D2;
N        _A2 __a2(__a);
N        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
N        ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))
X        ::new(static_cast<void*>(std::__2::addressof(*__hold2.get())))
N            _CntrlBlk(__p, __d, __a);
N        __cntrl_ = _VSTD::addressof(*__hold2.release());
X        __cntrl_ = std::__2::addressof(*__hold2.release());
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        __d(__p);
S        throw;
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N}
N
Ntemplate<class _Tp>
Ntemplate<class _Yp>
Ninline
Nshared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r, element_type *__p) _NOEXCEPT
Xshared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r, element_type *__p) noexcept
N    : __ptr_(__p),
N      __cntrl_(__r.__cntrl_)
N{
N    if (__cntrl_)
N        __cntrl_->__add_shared();
N}
N
Ntemplate<class _Tp>
Ninline
Nshared_ptr<_Tp>::shared_ptr(const shared_ptr& __r) _NOEXCEPT
Xshared_ptr<_Tp>::shared_ptr(const shared_ptr& __r) noexcept
N    : __ptr_(__r.__ptr_),
N      __cntrl_(__r.__cntrl_)
N{
N    if (__cntrl_)
N        __cntrl_->__add_shared();
N}
N
Ntemplate<class _Tp>
Ntemplate<class _Yp>
Ninline
Nshared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r,
N                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)
N         _NOEXCEPT
X         noexcept
N    : __ptr_(__r.__ptr_),
N      __cntrl_(__r.__cntrl_)
N{
N    if (__cntrl_)
N        __cntrl_->__add_shared();
N}
N
N#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
N
Ntemplate<class _Tp>
Ninline
Nshared_ptr<_Tp>::shared_ptr(shared_ptr&& __r) _NOEXCEPT
Xshared_ptr<_Tp>::shared_ptr(shared_ptr&& __r) noexcept
N    : __ptr_(__r.__ptr_),
N      __cntrl_(__r.__cntrl_)
N{
N    __r.__ptr_ = 0;
N    __r.__cntrl_ = 0;
N}
N
Ntemplate<class _Tp>
Ntemplate<class _Yp>
Ninline
Nshared_ptr<_Tp>::shared_ptr(shared_ptr<_Yp>&& __r,
N                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)
N         _NOEXCEPT
X         noexcept
N    : __ptr_(__r.__ptr_),
N      __cntrl_(__r.__cntrl_)
N{
N    __r.__ptr_ = 0;
N    __r.__cntrl_ = 0;
N}
N
N#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
N
N#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)
X#if 14 <= 14 || 0L
Ntemplate<class _Tp>
Ntemplate<class _Yp>
N#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
Nshared_ptr<_Tp>::shared_ptr(auto_ptr<_Yp>&& __r,
N#else
Sshared_ptr<_Tp>::shared_ptr(auto_ptr<_Yp> __r,
N#endif
N                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)
N    : __ptr_(__r.get())
N{
N    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;
N    __cntrl_ = new _CntrlBlk(__r.get(), default_delete<_Yp>(), allocator<_Yp>());
N    __enable_weak_this(__r.get(), __r.get());
N    __r.release();
N}
N#endif
N
Ntemplate<class _Tp>
Ntemplate <class _Yp, class _Dp>
N#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
Nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,
N#else
Sshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp> __r,
N#endif
N                            typename enable_if
N                            <
N                                !is_lvalue_reference<_Dp>::value &&
N                                !is_array<_Yp>::value &&
N                                is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,
N                                __nat
N                            >::type)
N    : __ptr_(__r.get())
N{
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
N    if (__ptr_ == nullptr)
N        __cntrl_ = nullptr;
N    else
N#endif
N    {
N        typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;
N        typedef __shared_ptr_pointer<_Yp*, _Dp, _AllocT > _CntrlBlk;
N        __cntrl_ = new _CntrlBlk(__r.get(), __r.get_deleter(), _AllocT());
N        __enable_weak_this(__r.get(), __r.get());
N    }
N    __r.release();
N}
N
Ntemplate<class _Tp>
Ntemplate <class _Yp, class _Dp>
N#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
Nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,
N#else
Sshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp> __r,
N#endif
N                            typename enable_if
N                            <
N                                is_lvalue_reference<_Dp>::value &&
N                                !is_array<_Yp>::value &&
N                                is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,
N                                __nat
N                            >::type)
N    : __ptr_(__r.get())
N{
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
N    if (__ptr_ == nullptr)
N        __cntrl_ = nullptr;
N    else
N#endif
N    {
N        typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;
N        typedef __shared_ptr_pointer<_Yp*,
N                                     reference_wrapper<typename remove_reference<_Dp>::type>,
N                                     _AllocT > _CntrlBlk;
N        __cntrl_ = new _CntrlBlk(__r.get(), ref(__r.get_deleter()), _AllocT());
N        __enable_weak_this(__r.get(), __r.get());
N    }
N    __r.release();
N}
N
N#ifndef _LIBCPP_HAS_NO_VARIADICS
N
Ntemplate<class _Tp>
Ntemplate<class ..._Args>
Nshared_ptr<_Tp>
Nshared_ptr<_Tp>::make_shared(_Args&& ...__args)
N{
N    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;
N    typedef allocator<_CntrlBlk> _A2;
N    typedef __allocator_destructor<_A2> _D2;
N    _A2 __a2;
N    unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
N    ::new(__hold2.get()) _CntrlBlk(__a2, _VSTD::forward<_Args>(__args)...);
X    ::new(__hold2.get()) _CntrlBlk(__a2, std::__2::forward<_Args>(__args)...);
N    shared_ptr<_Tp> __r;
N    __r.__ptr_ = __hold2.get()->get();
N    __r.__cntrl_ = __hold2.release();
N    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);
N    return __r;
N}
N
Ntemplate<class _Tp>
Ntemplate<class _Alloc, class ..._Args>
Nshared_ptr<_Tp>
Nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _Args&& ...__args)
N{
N    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;
N    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;
N    typedef __allocator_destructor<_A2> _D2;
N    _A2 __a2(__a);
N    unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
N    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))
X    ::new(static_cast<void*>(std::__2::addressof(*__hold2.get())))
N        _CntrlBlk(__a, _VSTD::forward<_Args>(__args)...);
X        _CntrlBlk(__a, std::__2::forward<_Args>(__args)...);
N    shared_ptr<_Tp> __r;
N    __r.__ptr_ = __hold2.get()->get();
N    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());
X    __r.__cntrl_ = std::__2::addressof(*__hold2.release());
N    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);
N    return __r;
N}
N
N#else  // _LIBCPP_HAS_NO_VARIADICS
S
Stemplate<class _Tp>
Sshared_ptr<_Tp>
Sshared_ptr<_Tp>::make_shared()
S{
S    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;
S    typedef allocator<_CntrlBlk> _Alloc2;
S    typedef __allocator_destructor<_Alloc2> _D2;
S    _Alloc2 __alloc2;
S    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));
S    ::new(__hold2.get()) _CntrlBlk(__alloc2);
S    shared_ptr<_Tp> __r;
S    __r.__ptr_ = __hold2.get()->get();
S    __r.__cntrl_ = __hold2.release();
S    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);
S    return __r;
S}
S
Stemplate<class _Tp>
Stemplate<class _A0>
Sshared_ptr<_Tp>
Sshared_ptr<_Tp>::make_shared(_A0& __a0)
S{
S    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;
S    typedef allocator<_CntrlBlk> _Alloc2;
S    typedef __allocator_destructor<_Alloc2> _D2;
S    _Alloc2 __alloc2;
S    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));
S    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0);
S    shared_ptr<_Tp> __r;
S    __r.__ptr_ = __hold2.get()->get();
S    __r.__cntrl_ = __hold2.release();
S    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);
S    return __r;
S}
S
Stemplate<class _Tp>
Stemplate<class _A0, class _A1>
Sshared_ptr<_Tp>
Sshared_ptr<_Tp>::make_shared(_A0& __a0, _A1& __a1)
S{
S    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;
S    typedef allocator<_CntrlBlk> _Alloc2;
S    typedef __allocator_destructor<_Alloc2> _D2;
S    _Alloc2 __alloc2;
S    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));
S    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0, __a1);
S    shared_ptr<_Tp> __r;
S    __r.__ptr_ = __hold2.get()->get();
S    __r.__cntrl_ = __hold2.release();
S    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);
S    return __r;
S}
S
Stemplate<class _Tp>
Stemplate<class _A0, class _A1, class _A2>
Sshared_ptr<_Tp>
Sshared_ptr<_Tp>::make_shared(_A0& __a0, _A1& __a1, _A2& __a2)
S{
S    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;
S    typedef allocator<_CntrlBlk> _Alloc2;
S    typedef __allocator_destructor<_Alloc2> _D2;
S    _Alloc2 __alloc2;
S    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));
S    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0, __a1, __a2);
S    shared_ptr<_Tp> __r;
S    __r.__ptr_ = __hold2.get()->get();
S    __r.__cntrl_ = __hold2.release();
S    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);
S    return __r;
S}
S
Stemplate<class _Tp>
Stemplate<class _Alloc>
Sshared_ptr<_Tp>
Sshared_ptr<_Tp>::allocate_shared(const _Alloc& __a)
S{
S    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;
S    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;
S    typedef __allocator_destructor<_Alloc2> _D2;
S    _Alloc2 __alloc2(__a);
S    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));
S    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))
S        _CntrlBlk(__a);
S    shared_ptr<_Tp> __r;
S    __r.__ptr_ = __hold2.get()->get();
S    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());
S    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);
S    return __r;
S}
S
Stemplate<class _Tp>
Stemplate<class _Alloc, class _A0>
Sshared_ptr<_Tp>
Sshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0)
S{
S    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;
S    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;
S    typedef __allocator_destructor<_Alloc2> _D2;
S    _Alloc2 __alloc2(__a);
S    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));
S    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))
S        _CntrlBlk(__a, __a0);
S    shared_ptr<_Tp> __r;
S    __r.__ptr_ = __hold2.get()->get();
S    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());
S    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);
S    return __r;
S}
S
Stemplate<class _Tp>
Stemplate<class _Alloc, class _A0, class _A1>
Sshared_ptr<_Tp>
Sshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1)
S{
S    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;
S    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;
S    typedef __allocator_destructor<_Alloc2> _D2;
S    _Alloc2 __alloc2(__a);
S    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));
S    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))
S        _CntrlBlk(__a, __a0, __a1);
S    shared_ptr<_Tp> __r;
S    __r.__ptr_ = __hold2.get()->get();
S    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());
S    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);
S    return __r;
S}
S
Stemplate<class _Tp>
Stemplate<class _Alloc, class _A0, class _A1, class _A2>
Sshared_ptr<_Tp>
Sshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2)
S{
S    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;
S    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;
S    typedef __allocator_destructor<_Alloc2> _D2;
S    _Alloc2 __alloc2(__a);
S    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));
S    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))
S        _CntrlBlk(__a, __a0, __a1, __a2);
S    shared_ptr<_Tp> __r;
S    __r.__ptr_ = __hold2.get()->get();
S    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());
S    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);
S    return __r;
S}
S
N#endif  // _LIBCPP_HAS_NO_VARIADICS
N
Ntemplate<class _Tp>
Nshared_ptr<_Tp>::~shared_ptr()
N{
N    if (__cntrl_)
N        __cntrl_->__release_shared();
N}
N
Ntemplate<class _Tp>
Ninline
Nshared_ptr<_Tp>&
Nshared_ptr<_Tp>::operator=(const shared_ptr& __r) _NOEXCEPT
Xshared_ptr<_Tp>::operator=(const shared_ptr& __r) noexcept
N{
N    shared_ptr(__r).swap(*this);
N    return *this;
N}
N
Ntemplate<class _Tp>
Ntemplate<class _Yp>
Ninline
Ntypename enable_if
N<
N    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,
N    shared_ptr<_Tp>&
N>::type
Nshared_ptr<_Tp>::operator=(const shared_ptr<_Yp>& __r) _NOEXCEPT
Xshared_ptr<_Tp>::operator=(const shared_ptr<_Yp>& __r) noexcept
N{
N    shared_ptr(__r).swap(*this);
N    return *this;
N}
N
N#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
N
Ntemplate<class _Tp>
Ninline
Nshared_ptr<_Tp>&
Nshared_ptr<_Tp>::operator=(shared_ptr&& __r) _NOEXCEPT
Xshared_ptr<_Tp>::operator=(shared_ptr&& __r) noexcept
N{
N    shared_ptr(_VSTD::move(__r)).swap(*this);
X    shared_ptr(std::__2::move(__r)).swap(*this);
N    return *this;
N}
N
Ntemplate<class _Tp>
Ntemplate<class _Yp>
Ninline
Ntypename enable_if
N<
N    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,
N    shared_ptr<_Tp>&
N>::type
Nshared_ptr<_Tp>::operator=(shared_ptr<_Yp>&& __r)
N{
N    shared_ptr(_VSTD::move(__r)).swap(*this);
X    shared_ptr(std::__2::move(__r)).swap(*this);
N    return *this;
N}
N
N#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)
X#if 14 <= 14 || 0L
Ntemplate<class _Tp>
Ntemplate<class _Yp>
Ninline
Ntypename enable_if
N<
N    !is_array<_Yp>::value &&
N    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,
N    shared_ptr<_Tp>
N>::type&
Nshared_ptr<_Tp>::operator=(auto_ptr<_Yp>&& __r)
N{
N    shared_ptr(_VSTD::move(__r)).swap(*this);
X    shared_ptr(std::__2::move(__r)).swap(*this);
N    return *this;
N}
N#endif
N
Ntemplate<class _Tp>
Ntemplate <class _Yp, class _Dp>
Ninline
Ntypename enable_if
N<
N    !is_array<_Yp>::value &&
N    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer,
N                   typename shared_ptr<_Tp>::element_type*>::value,
N    shared_ptr<_Tp>&
N>::type
Nshared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp>&& __r)
N{
N    shared_ptr(_VSTD::move(__r)).swap(*this);
X    shared_ptr(std::__2::move(__r)).swap(*this);
N    return *this;
N}
N
N#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
S
S#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)
Stemplate<class _Tp>
Stemplate<class _Yp>
Sinline _LIBCPP_INLINE_VISIBILITY
Stypename enable_if
S<
S    !is_array<_Yp>::value &&
S    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,
S    shared_ptr<_Tp>&
S>::type
Sshared_ptr<_Tp>::operator=(auto_ptr<_Yp> __r)
S{
S    shared_ptr(__r).swap(*this);
S    return *this;
S}
S#endif
S
Stemplate<class _Tp>
Stemplate <class _Yp, class _Dp>
Sinline _LIBCPP_INLINE_VISIBILITY
Stypename enable_if
S<
S    !is_array<_Yp>::value &&
S    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer,
S                   typename shared_ptr<_Tp>::element_type*>::value,
S    shared_ptr<_Tp>&
S>::type
Sshared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp> __r)
S{
S    shared_ptr(_VSTD::move(__r)).swap(*this);
S    return *this;
S}
S
N#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
N
Ntemplate<class _Tp>
Ninline
Nvoid
Nshared_ptr<_Tp>::swap(shared_ptr& __r) _NOEXCEPT
Xshared_ptr<_Tp>::swap(shared_ptr& __r) noexcept
N{
N    _VSTD::swap(__ptr_, __r.__ptr_);
X    std::__2::swap(__ptr_, __r.__ptr_);
N    _VSTD::swap(__cntrl_, __r.__cntrl_);
X    std::__2::swap(__cntrl_, __r.__cntrl_);
N}
N
Ntemplate<class _Tp>
Ninline
Nvoid
Nshared_ptr<_Tp>::reset() _NOEXCEPT
Xshared_ptr<_Tp>::reset() noexcept
N{
N    shared_ptr().swap(*this);
N}
N
Ntemplate<class _Tp>
Ntemplate<class _Yp>
Ninline
Ntypename enable_if
N<
N    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,
N    void
N>::type
Nshared_ptr<_Tp>::reset(_Yp* __p)
N{
N    shared_ptr(__p).swap(*this);
N}
N
Ntemplate<class _Tp>
Ntemplate<class _Yp, class _Dp>
Ninline
Ntypename enable_if
N<
N    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,
N    void
N>::type
Nshared_ptr<_Tp>::reset(_Yp* __p, _Dp __d)
N{
N    shared_ptr(__p, __d).swap(*this);
N}
N
Ntemplate<class _Tp>
Ntemplate<class _Yp, class _Dp, class _Alloc>
Ninline
Ntypename enable_if
N<
N    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,
N    void
N>::type
Nshared_ptr<_Tp>::reset(_Yp* __p, _Dp __d, _Alloc __a)
N{
N    shared_ptr(__p, __d, __a).swap(*this);
N}
N
N#ifndef _LIBCPP_HAS_NO_VARIADICS
N
Ntemplate<class _Tp, class ..._Args>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename enable_if
N<
N    !is_array<_Tp>::value,
N    shared_ptr<_Tp>
N>::type
Nmake_shared(_Args&& ...__args)
N{
N    return shared_ptr<_Tp>::make_shared(_VSTD::forward<_Args>(__args)...);
X    return shared_ptr<_Tp>::make_shared(std::__2::forward<_Args>(__args)...);
N}
N
Ntemplate<class _Tp, class _Alloc, class ..._Args>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename enable_if
N<
N    !is_array<_Tp>::value,
N    shared_ptr<_Tp>
N>::type
Nallocate_shared(const _Alloc& __a, _Args&& ...__args)
N{
N    return shared_ptr<_Tp>::allocate_shared(__a, _VSTD::forward<_Args>(__args)...);
X    return shared_ptr<_Tp>::allocate_shared(__a, std::__2::forward<_Args>(__args)...);
N}
N
N#else  // _LIBCPP_HAS_NO_VARIADICS
S
Stemplate<class _Tp>
Sinline _LIBCPP_INLINE_VISIBILITY
Sshared_ptr<_Tp>
Smake_shared()
S{
S    return shared_ptr<_Tp>::make_shared();
S}
S
Stemplate<class _Tp, class _A0>
Sinline _LIBCPP_INLINE_VISIBILITY
Sshared_ptr<_Tp>
Smake_shared(_A0& __a0)
S{
S    return shared_ptr<_Tp>::make_shared(__a0);
S}
S
Stemplate<class _Tp, class _A0, class _A1>
Sinline _LIBCPP_INLINE_VISIBILITY
Sshared_ptr<_Tp>
Smake_shared(_A0& __a0, _A1& __a1)
S{
S    return shared_ptr<_Tp>::make_shared(__a0, __a1);
S}
S
Stemplate<class _Tp, class _A0, class _A1, class _A2>
Sinline _LIBCPP_INLINE_VISIBILITY
Sshared_ptr<_Tp>
Smake_shared(_A0& __a0, _A1& __a1, _A2& __a2)
S{
S    return shared_ptr<_Tp>::make_shared(__a0, __a1, __a2);
S}
S
Stemplate<class _Tp, class _Alloc>
Sinline _LIBCPP_INLINE_VISIBILITY
Sshared_ptr<_Tp>
Sallocate_shared(const _Alloc& __a)
S{
S    return shared_ptr<_Tp>::allocate_shared(__a);
S}
S
Stemplate<class _Tp, class _Alloc, class _A0>
Sinline _LIBCPP_INLINE_VISIBILITY
Sshared_ptr<_Tp>
Sallocate_shared(const _Alloc& __a, _A0& __a0)
S{
S    return shared_ptr<_Tp>::allocate_shared(__a, __a0);
S}
S
Stemplate<class _Tp, class _Alloc, class _A0, class _A1>
Sinline _LIBCPP_INLINE_VISIBILITY
Sshared_ptr<_Tp>
Sallocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1)
S{
S    return shared_ptr<_Tp>::allocate_shared(__a, __a0, __a1);
S}
S
Stemplate<class _Tp, class _Alloc, class _A0, class _A1, class _A2>
Sinline _LIBCPP_INLINE_VISIBILITY
Sshared_ptr<_Tp>
Sallocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2)
S{
S    return shared_ptr<_Tp>::allocate_shared(__a, __a0, __a1, __a2);
S}
S
N#endif  // _LIBCPP_HAS_NO_VARIADICS
N
Ntemplate<class _Tp, class _Up>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator==(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT
Xoperator==(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) noexcept
N{
N    return __x.get() == __y.get();
N}
N
Ntemplate<class _Tp, class _Up>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator!=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT
Xoperator!=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) noexcept
N{
N    return !(__x == __y);
N}
N
Ntemplate<class _Tp, class _Up>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator<(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT
Xoperator<(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) noexcept
N{
N    typedef typename common_type<_Tp*, _Up*>::type _Vp;
N    return less<_Vp>()(__x.get(), __y.get());
N}
N
Ntemplate<class _Tp, class _Up>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator>(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT
Xoperator>(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) noexcept
N{
N    return __y < __x;
N}
N
Ntemplate<class _Tp, class _Up>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator<=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT
Xoperator<=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) noexcept
N{
N    return !(__y < __x);
N}
N
Ntemplate<class _Tp, class _Up>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator>=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT
Xoperator>=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) noexcept
N{
N    return !(__x < __y);
N}
N
Ntemplate<class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator==(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT
Xoperator==(const shared_ptr<_Tp>& __x, nullptr_t) noexcept
N{
N    return !__x;
N}
N
Ntemplate<class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator==(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT
Xoperator==(nullptr_t, const shared_ptr<_Tp>& __x) noexcept
N{
N    return !__x;
N}
N
Ntemplate<class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator!=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT
Xoperator!=(const shared_ptr<_Tp>& __x, nullptr_t) noexcept
N{
N    return static_cast<bool>(__x);
N}
N
Ntemplate<class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator!=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT
Xoperator!=(nullptr_t, const shared_ptr<_Tp>& __x) noexcept
N{
N    return static_cast<bool>(__x);
N}
N
Ntemplate<class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator<(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT
Xoperator<(const shared_ptr<_Tp>& __x, nullptr_t) noexcept
N{
N    return less<_Tp*>()(__x.get(), nullptr);
N}
N
Ntemplate<class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator<(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT
Xoperator<(nullptr_t, const shared_ptr<_Tp>& __x) noexcept
N{
N    return less<_Tp*>()(nullptr, __x.get());
N}
N
Ntemplate<class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator>(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT
Xoperator>(const shared_ptr<_Tp>& __x, nullptr_t) noexcept
N{
N    return nullptr < __x;
N}
N
Ntemplate<class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator>(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT
Xoperator>(nullptr_t, const shared_ptr<_Tp>& __x) noexcept
N{
N    return __x < nullptr;
N}
N
Ntemplate<class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator<=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT
Xoperator<=(const shared_ptr<_Tp>& __x, nullptr_t) noexcept
N{
N    return !(nullptr < __x);
N}
N
Ntemplate<class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator<=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT
Xoperator<=(nullptr_t, const shared_ptr<_Tp>& __x) noexcept
N{
N    return !(__x < nullptr);
N}
N
Ntemplate<class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator>=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT
Xoperator>=(const shared_ptr<_Tp>& __x, nullptr_t) noexcept
N{
N    return !(__x < nullptr);
N}
N
Ntemplate<class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator>=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT
Xoperator>=(nullptr_t, const shared_ptr<_Tp>& __x) noexcept
N{
N    return !(nullptr < __x);
N}
N
Ntemplate<class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Nswap(shared_ptr<_Tp>& __x, shared_ptr<_Tp>& __y) _NOEXCEPT
Xswap(shared_ptr<_Tp>& __x, shared_ptr<_Tp>& __y) noexcept
N{
N    __x.swap(__y);
N}
N
Ntemplate<class _Tp, class _Up>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename enable_if
N<
N    !is_array<_Tp>::value && !is_array<_Up>::value,
N    shared_ptr<_Tp>
N>::type
Nstatic_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT
Xstatic_pointer_cast(const shared_ptr<_Up>& __r) noexcept
N{
N    return shared_ptr<_Tp>(__r, static_cast<_Tp*>(__r.get()));
N}
N
Ntemplate<class _Tp, class _Up>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename enable_if
N<
N    !is_array<_Tp>::value && !is_array<_Up>::value,
N    shared_ptr<_Tp>
N>::type
Ndynamic_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT
Xdynamic_pointer_cast(const shared_ptr<_Up>& __r) noexcept
N{
N    _Tp* __p = dynamic_cast<_Tp*>(__r.get());
N    return __p ? shared_ptr<_Tp>(__r, __p) : shared_ptr<_Tp>();
N}
N
Ntemplate<class _Tp, class _Up>
Ntypename enable_if
N<
N    is_array<_Tp>::value == is_array<_Up>::value,
N    shared_ptr<_Tp>
N>::type
Nconst_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT
Xconst_pointer_cast(const shared_ptr<_Up>& __r) noexcept
N{
N    typedef typename remove_extent<_Tp>::type _RTp;
N    return shared_ptr<_Tp>(__r, const_cast<_RTp*>(__r.get()));
N}
N
N#ifndef _LIBCPP_NO_RTTI
N
Ntemplate<class _Dp, class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_Dp*
Nget_deleter(const shared_ptr<_Tp>& __p) _NOEXCEPT
Xget_deleter(const shared_ptr<_Tp>& __p) noexcept
N{
N    return __p.template __get_deleter<_Dp>();
N}
N
N#endif  // _LIBCPP_NO_RTTI
N
Ntemplate<class _Tp>
Nclass _LIBCPP_TEMPLATE_VIS weak_ptr
Xclass  weak_ptr
N{
Npublic:
N    typedef _Tp element_type;
Nprivate:
N    element_type*        __ptr_;
N    __shared_weak_count* __cntrl_;
N
Npublic:
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _LIBCPP_CONSTEXPR weak_ptr() _NOEXCEPT;
X    constexpr weak_ptr() noexcept;
N    template<class _Yp> _LIBCPP_INLINE_VISIBILITY weak_ptr(shared_ptr<_Yp> const& __r,
X    template<class _Yp> __attribute__ ((__always_inline__)) weak_ptr(shared_ptr<_Yp> const& __r,
N                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)
N                        _NOEXCEPT;
X                        noexcept;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    weak_ptr(weak_ptr const& __r) _NOEXCEPT;
X    weak_ptr(weak_ptr const& __r) noexcept;
N    template<class _Yp> _LIBCPP_INLINE_VISIBILITY weak_ptr(weak_ptr<_Yp> const& __r,
X    template<class _Yp> __attribute__ ((__always_inline__)) weak_ptr(weak_ptr<_Yp> const& __r,
N                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)
N                         _NOEXCEPT;
X                         noexcept;
N
N#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    weak_ptr(weak_ptr&& __r) _NOEXCEPT;
X    weak_ptr(weak_ptr&& __r) noexcept;
N    template<class _Yp> _LIBCPP_INLINE_VISIBILITY weak_ptr(weak_ptr<_Yp>&& __r,
X    template<class _Yp> __attribute__ ((__always_inline__)) weak_ptr(weak_ptr<_Yp>&& __r,
N                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)
N                         _NOEXCEPT;
X                         noexcept;
N#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
N    ~weak_ptr();
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    weak_ptr& operator=(weak_ptr const& __r) _NOEXCEPT;
X    weak_ptr& operator=(weak_ptr const& __r) noexcept;
N    template<class _Yp>
N        typename enable_if
N        <
N            is_convertible<_Yp*, element_type*>::value,
N            weak_ptr&
N        >::type
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        operator=(weak_ptr<_Yp> const& __r) _NOEXCEPT;
X        operator=(weak_ptr<_Yp> const& __r) noexcept;
N
N#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    weak_ptr& operator=(weak_ptr&& __r) _NOEXCEPT;
X    weak_ptr& operator=(weak_ptr&& __r) noexcept;
N    template<class _Yp>
N        typename enable_if
N        <
N            is_convertible<_Yp*, element_type*>::value,
N            weak_ptr&
N        >::type
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        operator=(weak_ptr<_Yp>&& __r) _NOEXCEPT;
X        operator=(weak_ptr<_Yp>&& __r) noexcept;
N
N#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
N
N    template<class _Yp>
N        typename enable_if
N        <
N            is_convertible<_Yp*, element_type*>::value,
N            weak_ptr&
N        >::type
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        operator=(shared_ptr<_Yp> const& __r) _NOEXCEPT;
X        operator=(shared_ptr<_Yp> const& __r) noexcept;
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    void swap(weak_ptr& __r) _NOEXCEPT;
X    void swap(weak_ptr& __r) noexcept;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    void reset() _NOEXCEPT;
X    void reset() noexcept;
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    long use_count() const _NOEXCEPT
X    long use_count() const noexcept
N        {return __cntrl_ ? __cntrl_->use_count() : 0;}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    bool expired() const _NOEXCEPT
X    bool expired() const noexcept
N        {return __cntrl_ == 0 || __cntrl_->use_count() == 0;}
N    shared_ptr<_Tp> lock() const _NOEXCEPT;
X    shared_ptr<_Tp> lock() const noexcept;
N    template<class _Up>
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        bool owner_before(const shared_ptr<_Up>& __r) const _NOEXCEPT
X        bool owner_before(const shared_ptr<_Up>& __r) const noexcept
N        {return __cntrl_ < __r.__cntrl_;}
N    template<class _Up>
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        bool owner_before(const weak_ptr<_Up>& __r) const _NOEXCEPT
X        bool owner_before(const weak_ptr<_Up>& __r) const noexcept
N        {return __cntrl_ < __r.__cntrl_;}
N
N    template <class _Up> friend class _LIBCPP_TEMPLATE_VIS weak_ptr;
X    template <class _Up> friend class  weak_ptr;
N    template <class _Up> friend class _LIBCPP_TEMPLATE_VIS shared_ptr;
X    template <class _Up> friend class  shared_ptr;
N};
N
Ntemplate<class _Tp>
Ninline
N_LIBCPP_CONSTEXPR
Xconstexpr
Nweak_ptr<_Tp>::weak_ptr() _NOEXCEPT
Xweak_ptr<_Tp>::weak_ptr() noexcept
N    : __ptr_(0),
N      __cntrl_(0)
N{
N}
N
Ntemplate<class _Tp>
Ninline
Nweak_ptr<_Tp>::weak_ptr(weak_ptr const& __r) _NOEXCEPT
Xweak_ptr<_Tp>::weak_ptr(weak_ptr const& __r) noexcept
N    : __ptr_(__r.__ptr_),
N      __cntrl_(__r.__cntrl_)
N{
N    if (__cntrl_)
N        __cntrl_->__add_weak();
N}
N
Ntemplate<class _Tp>
Ntemplate<class _Yp>
Ninline
Nweak_ptr<_Tp>::weak_ptr(shared_ptr<_Yp> const& __r,
N                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)
N                         _NOEXCEPT
X                         noexcept
N    : __ptr_(__r.__ptr_),
N      __cntrl_(__r.__cntrl_)
N{
N    if (__cntrl_)
N        __cntrl_->__add_weak();
N}
N
Ntemplate<class _Tp>
Ntemplate<class _Yp>
Ninline
Nweak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp> const& __r,
N                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)
N         _NOEXCEPT
X         noexcept
N    : __ptr_(__r.__ptr_),
N      __cntrl_(__r.__cntrl_)
N{
N    if (__cntrl_)
N        __cntrl_->__add_weak();
N}
N
N#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
N
Ntemplate<class _Tp>
Ninline
Nweak_ptr<_Tp>::weak_ptr(weak_ptr&& __r) _NOEXCEPT
Xweak_ptr<_Tp>::weak_ptr(weak_ptr&& __r) noexcept
N    : __ptr_(__r.__ptr_),
N      __cntrl_(__r.__cntrl_)
N{
N    __r.__ptr_ = 0;
N    __r.__cntrl_ = 0;
N}
N
Ntemplate<class _Tp>
Ntemplate<class _Yp>
Ninline
Nweak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp>&& __r,
N                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)
N         _NOEXCEPT
X         noexcept
N    : __ptr_(__r.__ptr_),
N      __cntrl_(__r.__cntrl_)
N{
N    __r.__ptr_ = 0;
N    __r.__cntrl_ = 0;
N}
N
N#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
N
Ntemplate<class _Tp>
Nweak_ptr<_Tp>::~weak_ptr()
N{
N    if (__cntrl_)
N        __cntrl_->__release_weak();
N}
N
Ntemplate<class _Tp>
Ninline
Nweak_ptr<_Tp>&
Nweak_ptr<_Tp>::operator=(weak_ptr const& __r) _NOEXCEPT
Xweak_ptr<_Tp>::operator=(weak_ptr const& __r) noexcept
N{
N    weak_ptr(__r).swap(*this);
N    return *this;
N}
N
Ntemplate<class _Tp>
Ntemplate<class _Yp>
Ninline
Ntypename enable_if
N<
N    is_convertible<_Yp*, _Tp*>::value,
N    weak_ptr<_Tp>&
N>::type
Nweak_ptr<_Tp>::operator=(weak_ptr<_Yp> const& __r) _NOEXCEPT
Xweak_ptr<_Tp>::operator=(weak_ptr<_Yp> const& __r) noexcept
N{
N    weak_ptr(__r).swap(*this);
N    return *this;
N}
N
N#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
N
Ntemplate<class _Tp>
Ninline
Nweak_ptr<_Tp>&
Nweak_ptr<_Tp>::operator=(weak_ptr&& __r) _NOEXCEPT
Xweak_ptr<_Tp>::operator=(weak_ptr&& __r) noexcept
N{
N    weak_ptr(_VSTD::move(__r)).swap(*this);
X    weak_ptr(std::__2::move(__r)).swap(*this);
N    return *this;
N}
N
Ntemplate<class _Tp>
Ntemplate<class _Yp>
Ninline
Ntypename enable_if
N<
N    is_convertible<_Yp*, _Tp*>::value,
N    weak_ptr<_Tp>&
N>::type
Nweak_ptr<_Tp>::operator=(weak_ptr<_Yp>&& __r) _NOEXCEPT
Xweak_ptr<_Tp>::operator=(weak_ptr<_Yp>&& __r) noexcept
N{
N    weak_ptr(_VSTD::move(__r)).swap(*this);
X    weak_ptr(std::__2::move(__r)).swap(*this);
N    return *this;
N}
N
N#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
N
Ntemplate<class _Tp>
Ntemplate<class _Yp>
Ninline
Ntypename enable_if
N<
N    is_convertible<_Yp*, _Tp*>::value,
N    weak_ptr<_Tp>&
N>::type
Nweak_ptr<_Tp>::operator=(shared_ptr<_Yp> const& __r) _NOEXCEPT
Xweak_ptr<_Tp>::operator=(shared_ptr<_Yp> const& __r) noexcept
N{
N    weak_ptr(__r).swap(*this);
N    return *this;
N}
N
Ntemplate<class _Tp>
Ninline
Nvoid
Nweak_ptr<_Tp>::swap(weak_ptr& __r) _NOEXCEPT
Xweak_ptr<_Tp>::swap(weak_ptr& __r) noexcept
N{
N    _VSTD::swap(__ptr_, __r.__ptr_);
X    std::__2::swap(__ptr_, __r.__ptr_);
N    _VSTD::swap(__cntrl_, __r.__cntrl_);
X    std::__2::swap(__cntrl_, __r.__cntrl_);
N}
N
Ntemplate<class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Nswap(weak_ptr<_Tp>& __x, weak_ptr<_Tp>& __y) _NOEXCEPT
Xswap(weak_ptr<_Tp>& __x, weak_ptr<_Tp>& __y) noexcept
N{
N    __x.swap(__y);
N}
N
Ntemplate<class _Tp>
Ninline
Nvoid
Nweak_ptr<_Tp>::reset() _NOEXCEPT
Xweak_ptr<_Tp>::reset() noexcept
N{
N    weak_ptr().swap(*this);
N}
N
Ntemplate<class _Tp>
Ntemplate<class _Yp>
Nshared_ptr<_Tp>::shared_ptr(const weak_ptr<_Yp>& __r,
N                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)
N    : __ptr_(__r.__ptr_),
N      __cntrl_(__r.__cntrl_ ? __r.__cntrl_->lock() : __r.__cntrl_)
N{
N    if (__cntrl_ == 0)
N        __throw_bad_weak_ptr();
N}
N
Ntemplate<class _Tp>
Nshared_ptr<_Tp>
Nweak_ptr<_Tp>::lock() const _NOEXCEPT
Xweak_ptr<_Tp>::lock() const noexcept
N{
N    shared_ptr<_Tp> __r;
N    __r.__cntrl_ = __cntrl_ ? __cntrl_->lock() : __cntrl_;
N    if (__r.__cntrl_)
N        __r.__ptr_ = __ptr_;
N    return __r;
N}
N
N#if _LIBCPP_STD_VER > 14
X#if 14 > 14
Stemplate <class _Tp = void> struct owner_less;
N#else
Ntemplate <class _Tp> struct owner_less;
N#endif
N
Ntemplate <class _Tp>
Nstruct _LIBCPP_TEMPLATE_VIS owner_less<shared_ptr<_Tp> >
Xstruct  owner_less<shared_ptr<_Tp> >
N    : binary_function<shared_ptr<_Tp>, shared_ptr<_Tp>, bool>
N{
N    typedef bool result_type;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    bool operator()(shared_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const _NOEXCEPT
X    bool operator()(shared_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const noexcept
N        {return __x.owner_before(__y);}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    bool operator()(shared_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const _NOEXCEPT
X    bool operator()(shared_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const noexcept
N        {return __x.owner_before(__y);}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    bool operator()(  weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const _NOEXCEPT
X    bool operator()(  weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const noexcept
N        {return __x.owner_before(__y);}
N};
N
Ntemplate <class _Tp>
Nstruct _LIBCPP_TEMPLATE_VIS owner_less<weak_ptr<_Tp> >
Xstruct  owner_less<weak_ptr<_Tp> >
N    : binary_function<weak_ptr<_Tp>, weak_ptr<_Tp>, bool>
N{
N    typedef bool result_type;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    bool operator()(  weak_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const _NOEXCEPT
X    bool operator()(  weak_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const noexcept
N        {return __x.owner_before(__y);}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    bool operator()(shared_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const _NOEXCEPT
X    bool operator()(shared_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const noexcept
N        {return __x.owner_before(__y);}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    bool operator()(  weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const _NOEXCEPT
X    bool operator()(  weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const noexcept
N        {return __x.owner_before(__y);}
N};
N
N#if _LIBCPP_STD_VER > 14
X#if 14 > 14
Stemplate <>
Sstruct _LIBCPP_TEMPLATE_VIS owner_less<void>
S{
S    template <class _Tp, class _Up>
S    _LIBCPP_INLINE_VISIBILITY
S    bool operator()( shared_ptr<_Tp> const& __x, shared_ptr<_Up> const& __y) const _NOEXCEPT
S        {return __x.owner_before(__y);}
S    template <class _Tp, class _Up>
S    _LIBCPP_INLINE_VISIBILITY
S    bool operator()( shared_ptr<_Tp> const& __x,   weak_ptr<_Up> const& __y) const _NOEXCEPT
S        {return __x.owner_before(__y);}
S    template <class _Tp, class _Up>
S    _LIBCPP_INLINE_VISIBILITY
S    bool operator()(   weak_ptr<_Tp> const& __x, shared_ptr<_Up> const& __y) const _NOEXCEPT
S        {return __x.owner_before(__y);}
S    template <class _Tp, class _Up>
S    _LIBCPP_INLINE_VISIBILITY
S    bool operator()(   weak_ptr<_Tp> const& __x,   weak_ptr<_Up> const& __y) const _NOEXCEPT
S        {return __x.owner_before(__y);}
S    typedef void is_transparent;
S};
N#endif
N
Ntemplate<class _Tp>
Nclass _LIBCPP_TEMPLATE_VIS enable_shared_from_this
Xclass  enable_shared_from_this
N{
N    mutable weak_ptr<_Tp> __weak_this_;
Nprotected:
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
X    __attribute__ ((__always_inline__)) constexpr
N    enable_shared_from_this() _NOEXCEPT {}
X    enable_shared_from_this() noexcept {}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    enable_shared_from_this(enable_shared_from_this const&) _NOEXCEPT {}
X    enable_shared_from_this(enable_shared_from_this const&) noexcept {}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    enable_shared_from_this& operator=(enable_shared_from_this const&) _NOEXCEPT
X    enable_shared_from_this& operator=(enable_shared_from_this const&) noexcept
N        {return *this;}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    ~enable_shared_from_this() {}
Npublic:
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    shared_ptr<_Tp> shared_from_this()
N        {return shared_ptr<_Tp>(__weak_this_);}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    shared_ptr<_Tp const> shared_from_this() const
N        {return shared_ptr<const _Tp>(__weak_this_);}
N
N#if _LIBCPP_STD_VER > 14
X#if 14 > 14
S    _LIBCPP_INLINE_VISIBILITY
S    weak_ptr<_Tp> weak_from_this() _NOEXCEPT
S       { return __weak_this_; }
S
S    _LIBCPP_INLINE_VISIBILITY
S    weak_ptr<const _Tp> weak_from_this() const _NOEXCEPT
S        { return __weak_this_; }
N#endif // _LIBCPP_STD_VER > 14
N
N    template <class _Up> friend class shared_ptr;
N};
N
Ntemplate <class _Tp>
Nstruct _LIBCPP_TEMPLATE_VIS hash<shared_ptr<_Tp> >
Xstruct  hash<shared_ptr<_Tp> >
N{
N    typedef shared_ptr<_Tp>      argument_type;
N    typedef size_t               result_type;
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    result_type operator()(const argument_type& __ptr) const _NOEXCEPT
X    result_type operator()(const argument_type& __ptr) const noexcept
N    {
N        return hash<_Tp*>()(__ptr.get());
N    }
N};
N
Ntemplate<class _CharT, class _Traits, class _Yp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbasic_ostream<_CharT, _Traits>&
Noperator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p);
N
N
N// Disable atomic(shared_ptr) until threads/mutexes are enabled.
N#if !defined(_LIBCPP_HAS_NO_ATOMIC_HEADER) && !defined(__TI_COMPILER_VERSION__)
X#if !0L && !1L
S
Sclass _LIBCPP_TYPE_VIS __sp_mut
S{
S    void* __lx;
Spublic:
S    void lock() _NOEXCEPT;
S    void unlock() _NOEXCEPT;
S
Sprivate:
S    _LIBCPP_CONSTEXPR __sp_mut(void*) _NOEXCEPT;
S    __sp_mut(const __sp_mut&);
S    __sp_mut& operator=(const __sp_mut&);
S
S    friend _LIBCPP_FUNC_VIS __sp_mut& __get_sp_mut(const void*);
S};
S
S_LIBCPP_FUNC_VIS _LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR
S__sp_mut& __get_sp_mut(const void*);
S
Stemplate <class _Tp>
Sinline _LIBCPP_INLINE_VISIBILITY
Sbool
Satomic_is_lock_free(const shared_ptr<_Tp>*)
S{
S    return false;
S}
S
Stemplate <class _Tp>
S_LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR
Sshared_ptr<_Tp>
Satomic_load(const shared_ptr<_Tp>* __p)
S{
S    __sp_mut& __m = __get_sp_mut(__p);
S    __m.lock();
S    shared_ptr<_Tp> __q = *__p;
S    __m.unlock();
S    return __q;
S}
S
Stemplate <class _Tp>
Sinline _LIBCPP_INLINE_VISIBILITY
S_LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR
Sshared_ptr<_Tp>
Satomic_load_explicit(const shared_ptr<_Tp>* __p, memory_order)
S{
S    return atomic_load(__p);
S}
S
Stemplate <class _Tp>
S_LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR
Svoid
Satomic_store(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)
S{
S    __sp_mut& __m = __get_sp_mut(__p);
S    __m.lock();
S    __p->swap(__r);
S    __m.unlock();
S}
S
Stemplate <class _Tp>
Sinline _LIBCPP_INLINE_VISIBILITY
S_LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR
Svoid
Satomic_store_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)
S{
S    atomic_store(__p, __r);
S}
S
Stemplate <class _Tp>
S_LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR
Sshared_ptr<_Tp>
Satomic_exchange(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)
S{
S    __sp_mut& __m = __get_sp_mut(__p);
S    __m.lock();
S    __p->swap(__r);
S    __m.unlock();
S    return __r;
S}
S
Stemplate <class _Tp>
Sinline _LIBCPP_INLINE_VISIBILITY
S_LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR
Sshared_ptr<_Tp>
Satomic_exchange_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)
S{
S    return atomic_exchange(__p, __r);
S}
S
Stemplate <class _Tp>
S_LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR
Sbool
Satomic_compare_exchange_strong(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)
S{
S    shared_ptr<_Tp> __temp;
S    __sp_mut& __m = __get_sp_mut(__p);
S    __m.lock();
S    if (__p->__owner_equivalent(*__v))
S    {
S        _VSTD::swap(__temp, *__p);
S        *__p = __w;
S        __m.unlock();
S        return true;
S    }
S    _VSTD::swap(__temp, *__v);
S    *__v = *__p;
S    __m.unlock();
S    return false;
S}
S
Stemplate <class _Tp>
Sinline _LIBCPP_INLINE_VISIBILITY
S_LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR
Sbool
Satomic_compare_exchange_weak(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)
S{
S    return atomic_compare_exchange_strong(__p, __v, __w);
S}
S
Stemplate <class _Tp>
Sinline _LIBCPP_INLINE_VISIBILITY
S_LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR
Sbool
Satomic_compare_exchange_strong_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,
S                                        shared_ptr<_Tp> __w, memory_order, memory_order)
S{
S    return atomic_compare_exchange_strong(__p, __v, __w);
S}
S
Stemplate <class _Tp>
Sinline _LIBCPP_INLINE_VISIBILITY
S_LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR
Sbool
Satomic_compare_exchange_weak_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,
S                                      shared_ptr<_Tp> __w, memory_order, memory_order)
S{
S    return atomic_compare_exchange_weak(__p, __v, __w);
S}
S
N#endif  // !defined(_LIBCPP_HAS_NO_ATOMIC_HEADER)
N
N//enum class
N#if defined(_LIBCPP_ABI_POINTER_SAFETY_ENUM_TYPE)
X#if 1L
N# ifndef _LIBCPP_CXX03_LANG
Nenum class pointer_safety : unsigned char {
N  relaxed,
N  preferred,
N  strict
N};
N# endif
N#else
Sstruct _LIBCPP_TYPE_VIS pointer_safety
S{
S    enum __attribute__((packed)) __lx
S    {
S        relaxed,
S        preferred,
S        strict
S    };
S
S    __lx __v_;
S
S    _LIBCPP_INLINE_VISIBILITY
S    pointer_safety() : __v_() {}
S
S    _LIBCPP_INLINE_VISIBILITY
S    pointer_safety(__lx __v) : __v_(__v) {}
S    _LIBCPP_INLINE_VISIBILITY
S    operator int() const {return __v_;}
S};
N#endif
N
N#if !defined(_LIBCPP_ABI_POINTER_SAFETY_ENUM_TYPE) && \
N    defined(_LIBCPP_BUILDING_MEMORY)
X#if !1L &&     0L
S_LIBCPP_FUNC_VIS pointer_safety get_pointer_safety() _NOEXCEPT;
N#else
N// This function is only offered in C++03 under ABI v1.
N# if !defined(_LIBCPP_ABI_POINTER_SAFETY_ENUM_TYPE) || !defined(_LIBCPP_CXX03_LANG)
X# if !1L || !0L
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Npointer_safety get_pointer_safety() _NOEXCEPT {
Xpointer_safety get_pointer_safety() noexcept {
N  return pointer_safety::relaxed;
N}
N# endif
N#endif
N
N
N_LIBCPP_FUNC_VIS void declare_reachable(void* __p);
X void declare_reachable(void* __p);
N_LIBCPP_FUNC_VIS void declare_no_pointers(char* __p, size_t __n);
X void declare_no_pointers(char* __p, size_t __n);
N_LIBCPP_FUNC_VIS void undeclare_no_pointers(char* __p, size_t __n);
X void undeclare_no_pointers(char* __p, size_t __n);
N_LIBCPP_FUNC_VIS void* __undeclare_reachable(void* __p);
X void* __undeclare_reachable(void* __p);
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_Tp*
Nundeclare_reachable(_Tp* __p)
N{
N    return static_cast<_Tp*>(__undeclare_reachable(__p));
N}
N
N_LIBCPP_FUNC_VIS void* align(size_t __align, size_t __sz, void*& __ptr, size_t& __space);
X void* align(size_t __align, size_t __sz, void*& __ptr, size_t& __space);
N
N// --- Helper for container swap --
Ntemplate <typename _Alloc>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid __swap_allocator(_Alloc & __a1, _Alloc & __a2)
N#if _LIBCPP_STD_VER >= 14
X#if 14 >= 14
N    _NOEXCEPT
X    noexcept
N#else
S    _NOEXCEPT_(__is_nothrow_swappable<_Alloc>::value)
N#endif
N{
N    __swap_allocator(__a1, __a2,
N      integral_constant<bool, _VSTD::allocator_traits<_Alloc>::propagate_on_container_swap::value>());
X      integral_constant<bool, std::__2::allocator_traits<_Alloc>::propagate_on_container_swap::value>());
N}
N
Ntemplate <typename _Alloc>
N_LIBCPP_INLINE_VISIBILITY
X__attribute__ ((__always_inline__))
Nvoid __swap_allocator(_Alloc & __a1, _Alloc & __a2, true_type)
N#if _LIBCPP_STD_VER >= 14
X#if 14 >= 14
N    _NOEXCEPT
X    noexcept
N#else
S    _NOEXCEPT_(__is_nothrow_swappable<_Alloc>::value)
N#endif
N{
N    using _VSTD::swap;
X    using std::__2::swap;
N    swap(__a1, __a2);
N}
N
Ntemplate <typename _Alloc>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid __swap_allocator(_Alloc &, _Alloc &, false_type) _NOEXCEPT {}
Xvoid __swap_allocator(_Alloc &, _Alloc &, false_type) noexcept {}
N
Ntemplate <typename _Alloc, typename _Traits=allocator_traits<_Alloc> >
Nstruct __noexcept_move_assign_container : public integral_constant<bool,
N    _Traits::propagate_on_container_move_assignment::value
N#if _LIBCPP_STD_VER > 14
X#if 14 > 14
S        || _Traits::is_always_equal::value
N#else
N        && is_nothrow_move_assignable<_Alloc>::value
N#endif
N    > {};
N
N
N#ifndef _LIBCPP_HAS_NO_VARIADICS
Ntemplate <class _Tp, class _Alloc>
Nstruct __temp_value {
N    typedef allocator_traits<_Alloc> _Traits;
N
N    typename aligned_storage<sizeof(_Tp), alignof(_Tp)>::type __v;
N    _Alloc &__a;
N
N    _Tp *__addr() { return reinterpret_cast<_Tp *>(addressof(__v)); }
N    _Tp &   get() { return *__addr(); }
N
N    template<class... _Args>
N    __temp_value(_Alloc &__alloc, _Args&& ... __args) : __a(__alloc)
N    { _Traits::construct(__a, __addr(), _VSTD::forward<_Args>(__args)...); }
X    { _Traits::construct(__a, __addr(), std::__2::forward<_Args>(__args)...); }
N
N    ~__temp_value() { _Traits::destroy(__a, __addr()); }
N    };
N#endif
N
N_LIBCPP_END_NAMESPACE_STD
X} }
N
N_LIBCPP_POP_MACROS
X_Pragma("pop_macro(\"min\")") _Pragma("pop_macro(\"max\")")
N
N#endif  // _LIBCPP_MEMORY
L 644 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/algorithm" 2
N#include <iterator>
N#include <cstddef>
N
N#if defined(__IBMCPP__)
X#if 0L
S#include "support/ibm/support.h"
N#endif
N#if defined(__TI_COMPILER_VERSION__)
X#if 1L
N#include "support/ti/support.h"
L 1 "C:\ti\ccs930\ccs\tools\compiler\ti-cgt-arm_18.12.5.LTS\include\libcxx\support/ti/support.h" 1
N// -*- C++ -*-
N//===----------------------- support/ibm/support.h ----------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is dual licensed under the MIT and the University of Illinois Open
N// Source Licenses. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP_SUPPORT_TI___SUPPORT_H
N#define _LIBCPP_SUPPORT_TI___SUPPORT_H
N
Ntemplate <typename T, int TBits = sizeof(T) * __CHAR_BIT__>
Xtemplate <typename T, int TBits = sizeof(T) * 8>
Nstruct __ti_support;
N
Ntemplate <typename T>
Nstruct __ti_support<T, 16> {
N    static int popcount(T input) {
N        T mask1 = 0x5555;
N        input -= ((input >> 1) & mask1);
N        T mask2 = 0x3333;
N        input = ((input & mask2) + ((input >> 2) & mask2));
N        T mask3 = 0x0f0f;
N        input = ((input + (input >> 4)) & mask3);
N        input += (input >> 8);
N        return (input & 0x1f);
N    }
N    static int clz(T input) {
N        unsigned int pos = 0;
N
N        if ((input & 0xff00) != 0) { pos += 8; input >>= 8; }
N        if ((input & 0x00f0) != 0) { pos += 4; input >>= 4; }
N        if      (input >= 8) pos += 4;
N        else if (input >= 4) pos += 3;
N        else if (input >= 2) pos += 2;
N        else if (input >= 1) pos += 1;
N
N        return (16 - pos);
N    }
N    static int ctz(T input) {
N        int pos = 0;
N
N        if ((input & 0x000000ff) == 0) { pos +=  8; input >>=  8; }
N        if ((input & 0x0000000f) == 0) { pos +=  4; input >>=  4; }
N        if ((input & 0x00000003) == 0) { pos +=  2; input >>=  2; }
N        if ((input & 0x00000001) == 0) { pos +=  1;               }
N
N        return pos;
N    }
N};
N
Ntemplate <typename T>
Nstruct __ti_support<T, 32> {
N    static int popcount(T input) {
N        T mask1 = 0x55555555;
N        input -= ((input >> 1) & mask1);
N        T mask2 = 0x33333333;
N        input = ((input & mask2) + ((input >> 2) & mask2));
N        T mask3 = 0x0f0f0f0f;
N        input = ((input + (input >> 4)) & mask3);
N        input += (input >> 8);
N        input += (input >> 16);
N        return (input & 0x3f);
N    }
N
N    static int clz(T input) {
N        unsigned int pos = 0;
N        if ((input & 0xffff0000) != 0) { pos += 16; input >>= 16; }
N        return (16 + __ti_support<T, 16>::clz(input) - pos);
N    }
N
N    static int ctz(T input) {
N        int pos = 0;
N        if ((input & 0x0000ffff) == 0) { pos += 16; input >>= 16; }
N        return pos + __ti_support<T, 16>::ctz(input);
N    }
N};
N
Ntemplate <typename T>
Nstruct __ti_support<T, 64> {
N    static int popcount(T input) {
N        T mask1 = 0x5555555555555555;
N        input -= ((input >> 1) & mask1);
N        T mask2 = 0x3333333333333333;
N        input = ((input & mask2) + ((input >> 2) & mask2));
N        T mask3 = 0x0f0f0f0f0f0f0f0f;
N        input = ((input + (input >> 4)) & mask3);
N        input += (input >> 8);
N        input += (input >> 16);
N        input += (input >> 32);
N        return (input & 0x7f);
N    }
N
N    static int clz(T input) {
N        T p1 = (input >> 32);
N        T p2 = (input & 0x00000000ffffffff);
N        unsigned int pos = 0;
N
N        if ((p1 & 0xffffffff) != 0)
N        {
N            pos += 32;
N            p2 = p1;
N        }
N        return (32 + __ti_support<T, 32>::clz(p2) - pos);
N    }
N
N    static int ctz(T input) {
N        T p1 = (input >> 32);
N        T p2 = (input & 0x00000000ffffffff);
N        unsigned int pos = 0;
N
N        if ((p2 & 0xffffffff) == 0)
N        {
N            pos += 32;
N            p2 = p1;
N        }
N        return pos + __ti_support<T, 32>::ctz(p2);
N    }
N};
N
N#define __builtin_popcount(x) (__ti_support<unsigned int>::popcount(x))
N#define __builtin_popcountl(x) (__ti_support<unsigned long>::popcount(x))
N#define __builtin_popcountll(x) (__ti_support<unsigned long long>::popcount(x))
N
N#define __builtin_ctz(x) (__ti_support<unsigned int>::ctz(x))
N#define __builtin_ctzl(x) (__ti_support<unsigned long>::ctz(x))
N#define __builtin_ctzll(x) (__ti_support<unsigned long long>::ctz(x))
N
N#define __builtin_clz(x) (__ti_support<unsigned int>::clz(x))
N#define __builtin_clzl(x) (__ti_support<unsigned long>::clz(x))
N#define __builtin_clzll(x) (__ti_support<unsigned long long>::clz(x))
N
N#endif /* !defined(_LIBCPP_SUPPORT_TI___SUPPORT_H) */
L 652 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/algorithm" 2
N#endif
N#if defined(_LIBCPP_COMPILER_MSVC)
X#if 0L
S#include <intrin.h>
N#endif
N
N#include <__debug>
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N_LIBCPP_PUSH_MACROS
X_Pragma("push_macro(\"min\")") _Pragma("push_macro(\"max\")")
N#include <__undef_macros>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/__undef_macros" 1
N// -*- C++ -*-
N//===------------------------ __undef_macros ------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is distributed under the University of Illinois Open Source
N// License. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N
N#ifdef min
S#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
S#if defined(_LIBCPP_WARNING)
S_LIBCPP_WARNING("macro min is incompatible with C++.  Try #define NOMINMAX "
S                "before any Windows header. #undefing min")
S#else
S#warning: macro min is incompatible with C++.  #undefing min
S#endif
S#endif
S#undef min
N#endif
N
N#ifdef max
S#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
S#if defined(_LIBCPP_WARNING)
S_LIBCPP_WARNING("macro max is incompatible with C++.  Try #define NOMINMAX "
S                "before any Windows header. #undefing max")
S#else
S#warning: macro max is incompatible with C++.  #undefing max
S#endif
S#endif
S#undef max
N#endif
L 665 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/algorithm" 2
N
N
N_LIBCPP_BEGIN_NAMESPACE_STD
Xnamespace std { inline namespace __2 {
N
N// I'd like to replace these with _VSTD::equal_to<void>, but can't because:
N//   * That only works with C++14 and later, and
N//   * We haven't included <functional> here.
Ntemplate <class _T1, class _T2 = _T1>
Nstruct __equal_to
N{
N    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}
X    __attribute__ ((__always_inline__)) bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}
N    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T2& __y) const {return __x == __y;}
X    __attribute__ ((__always_inline__)) bool operator()(const _T1& __x, const _T2& __y) const {return __x == __y;}
N    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T2& __x, const _T1& __y) const {return __x == __y;}
X    __attribute__ ((__always_inline__)) bool operator()(const _T2& __x, const _T1& __y) const {return __x == __y;}
N    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T2& __x, const _T2& __y) const {return __x == __y;}
X    __attribute__ ((__always_inline__)) bool operator()(const _T2& __x, const _T2& __y) const {return __x == __y;}
N};
N
Ntemplate <class _T1>
Nstruct __equal_to<_T1, _T1>
N{
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
X    __attribute__ ((__always_inline__)) constexpr
N    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}
N};
N
Ntemplate <class _T1>
Nstruct __equal_to<const _T1, _T1>
N{
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
X    __attribute__ ((__always_inline__)) constexpr
N    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}
N};
N
Ntemplate <class _T1>
Nstruct __equal_to<_T1, const _T1>
N{
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
X    __attribute__ ((__always_inline__)) constexpr
N    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}
N};
N
Ntemplate <class _T1, class _T2 = _T1>
Nstruct __less
N{
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
X    __attribute__ ((__always_inline__)) constexpr
N    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}
N
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
X    __attribute__ ((__always_inline__)) constexpr
N    bool operator()(const _T1& __x, const _T2& __y) const {return __x < __y;}
N
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
X    __attribute__ ((__always_inline__)) constexpr
N    bool operator()(const _T2& __x, const _T1& __y) const {return __x < __y;}
N
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
X    __attribute__ ((__always_inline__)) constexpr
N    bool operator()(const _T2& __x, const _T2& __y) const {return __x < __y;}
N};
N
Ntemplate <class _T1>
Nstruct __less<_T1, _T1>
N{
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
X    __attribute__ ((__always_inline__)) constexpr
N    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}
N};
N
Ntemplate <class _T1>
Nstruct __less<const _T1, _T1>
N{
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
X    __attribute__ ((__always_inline__)) constexpr
N    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}
N};
N
Ntemplate <class _T1>
Nstruct __less<_T1, const _T1>
N{
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
X    __attribute__ ((__always_inline__)) constexpr
N    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}
N};
N
Ntemplate <class _Predicate>
Nclass __invert // invert the sense of a comparison
N{
Nprivate:
N    _Predicate __p_;
Npublic:
N    _LIBCPP_INLINE_VISIBILITY __invert() {}
X    __attribute__ ((__always_inline__)) __invert() {}
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    explicit __invert(_Predicate __p) : __p_(__p) {}
N
N    template <class _T1>
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    bool operator()(const _T1& __x) {return !__p_(__x);}
N
N    template <class _T1, class _T2>
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    bool operator()(const _T1& __x, const _T2& __y) {return __p_(__y, __x);}
N};
N
N#ifdef _LIBCPP_DEBUG
S
Stemplate <class _Compare>
Sstruct __debug_less
S{
S    _Compare __comp_;
S    __debug_less(_Compare& __c) : __comp_(__c) {}
S
S    template <class _Tp, class _Up>
S    bool operator()(const _Tp& __x, const _Up& __y)
S    {
S        bool __r = __comp_(__x, __y);
S        if (__r)
S            __do_compare_assert(0, __y, __x);
S        return __r;
S    }
S
S    template <class _LHS, class _RHS>
S    inline _LIBCPP_INLINE_VISIBILITY
S    decltype((void)_VSTD::declval<_Compare&>()(
S        _VSTD::declval<_LHS const&>(), _VSTD::declval<_RHS const&>()))
S    __do_compare_assert(int, _LHS const& __l, _RHS const& __r) {
S        _LIBCPP_ASSERT(!__comp_(__l, __r),
S            "Comparator does not induce a strict weak ordering");
S    }
S
S    template <class _LHS, class _RHS>
S    inline _LIBCPP_INLINE_VISIBILITY
S    void __do_compare_assert(long, _LHS const&, _RHS const&) {}
S};
S
N#endif  // _LIBCPP_DEBUG
N
N// Precondition:  __x != 0
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nunsigned __ctz(unsigned __x) {
N#ifndef _LIBCPP_COMPILER_MSVC
N    return static_cast<unsigned>(__builtin_ctz(__x));
X    return static_cast<unsigned>((__ti_support<unsigned int> ::ctz(__x)));
N#else
S  static_assert(sizeof(unsigned) == sizeof(unsigned long), "");
S  static_assert(sizeof(unsigned long) == 4, "");
S  unsigned long where;
S  // Search from LSB to MSB for first set bit.
S  // Returns zero if no set bit is found.
S  if (_BitScanForward(&where, mask))
S    return where;
S  return 32;
N#endif
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nunsigned long __ctz(unsigned long __x) {
N#ifndef _LIBCPP_COMPILER_MSVC
N    return static_cast<unsigned long>(__builtin_ctzl(__x));
X    return static_cast<unsigned long>((__ti_support<unsigned long> ::ctz(__x)));
N#else
S    static_assert(sizeof(unsigned long) == sizeof(unsigned), "");
S    return __ctz(static_cast<unsigned>(__x));
N#endif
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nunsigned long long __ctz(unsigned long long __x) {
N#ifndef _LIBCPP_COMPILER_MSVC
N    return static_cast<unsigned long long>(__builtin_ctzll(__x));
X    return static_cast<unsigned long long>((__ti_support<unsigned long long> ::ctz(__x)));
N#else
S    unsigned long where;
S// Search from LSB to MSB for first set bit.
S// Returns zero if no set bit is found.
S#if defined(_LIBCPP_HAS_BITSCAN64)
S    (defined(_M_AMD64) || defined(__x86_64__))
S  if (_BitScanForward64(&where, mask))
S    return static_cast<int>(where);
S#else
S  // Win32 doesn't have _BitScanForward64 so emulate it with two 32 bit calls.
S  // Scan the Low Word.
S  if (_BitScanForward(&where, static_cast<unsigned long>(mask)))
S    return where;
S  // Scan the High Word.
S  if (_BitScanForward(&where, static_cast<unsigned long>(mask >> 32)))
S    return where + 32; // Create a bit offset from the LSB.
S#endif
S  return 64;
N#endif // _LIBCPP_COMPILER_MSVC
N}
N
N// Precondition:  __x != 0
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nunsigned __clz(unsigned __x) {
N#ifndef _LIBCPP_COMPILER_MSVC
N    return static_cast<unsigned>(__builtin_clz(__x));
X    return static_cast<unsigned>((__ti_support<unsigned int> ::clz(__x)));
N#else
S  static_assert(sizeof(unsigned) == sizeof(unsigned long), "");
S  static_assert(sizeof(unsigned long) == 4, "");
S  unsigned long where;
S  // Search from LSB to MSB for first set bit.
S  // Returns zero if no set bit is found.
S  if (_BitScanReverse(&where, mask))
S    return 31 - where;
S  return 32; // Undefined Behavior.
N#endif
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nunsigned long __clz(unsigned long __x) {
N#ifndef _LIBCPP_COMPILER_MSVC
N    return static_cast<unsigned long>(__builtin_clzl (__x));
X    return static_cast<unsigned long>((__ti_support<unsigned long> ::clz(__x)));
N#else
S    static_assert(sizeof(unsigned) == sizeof(unsigned long), "");
S    return __clz(static_cast<unsigned>(__x));
N#endif
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nunsigned long long __clz(unsigned long long __x) {
N#ifndef _LIBCPP_COMPILER_MSVC
N    return static_cast<unsigned long long>(__builtin_clzll(__x));
X    return static_cast<unsigned long long>((__ti_support<unsigned long long> ::clz(__x)));
N#else
S  unsigned long where;
S// BitScanReverse scans from MSB to LSB for first set bit.
S// Returns 0 if no set bit is found.
S#if defined(_LIBCPP_HAS_BITSCAN64)
S  if (_BitScanReverse64(&where, mask))
S    return static_cast<int>(63 - where);
S#else
S  // Scan the high 32 bits.
S  if (_BitScanReverse(&where, static_cast<unsigned long>(mask >> 32)))
S    return 63 - (where + 32); // Create a bit offset from the MSB.
S  // Scan the low 32 bits.
S  if (_BitScanReverse(&where, static_cast<unsigned long>(mask)))
S    return 63 - where;
S#endif
S  return 64; // Undefined Behavior.
N#endif // _LIBCPP_COMPILER_MSVC
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY int __pop_count(unsigned __x) {
Xinline __attribute__ ((__always_inline__)) int __pop_count(unsigned __x) {
N#ifndef _LIBCPP_COMPILER_MSVC
N  return __builtin_popcount  (__x);
X  return (__ti_support<unsigned int> ::popcount(__x));
N#else
S  static_assert(sizeof(unsigned) == 4, "");
S  return __popcnt(__x);
N#endif
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY int __pop_count(unsigned long __x) {
Xinline __attribute__ ((__always_inline__)) int __pop_count(unsigned long __x) {
N#ifndef _LIBCPP_COMPILER_MSVC
N  return __builtin_popcountl (__x);
X  return (__ti_support<unsigned long> ::popcount(__x));
N#else
S  static_assert(sizeof(unsigned long) == 4, "");
S  return __popcnt(__x);
N#endif
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY int __pop_count(unsigned long long __x) {
Xinline __attribute__ ((__always_inline__)) int __pop_count(unsigned long long __x) {
N#ifndef _LIBCPP_COMPILER_MSVC
N  return __builtin_popcountll(__x);
X  return (__ti_support<unsigned long long> ::popcount(__x));
N#else
S  static_assert(sizeof(unsigned long long) == 8, "");
S  return __popcnt64(__x);
N#endif
N}
N
N// all_of
N
Ntemplate <class _InputIterator, class _Predicate>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Nall_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
N{
N    for (; __first != __last; ++__first)
N        if (!__pred(*__first))
N            return false;
N    return true;
N}
N
N// any_of
N
Ntemplate <class _InputIterator, class _Predicate>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Nany_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
N{
N    for (; __first != __last; ++__first)
N        if (__pred(*__first))
N            return true;
N    return false;
N}
N
N// none_of
N
Ntemplate <class _InputIterator, class _Predicate>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Nnone_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
N{
N    for (; __first != __last; ++__first)
N        if (__pred(*__first))
N            return false;
N    return true;
N}
N
N// for_each
N
Ntemplate <class _InputIterator, class _Function>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_Function
Nfor_each(_InputIterator __first, _InputIterator __last, _Function __f)
N{
N    for (; __first != __last; ++__first)
N        __f(*__first);
N    return __f;
N}
N
N#if _LIBCPP_STD_VER > 14
X#if 14 > 14
S// for_each_n
S
Stemplate <class _InputIterator, class _Size, class _Function>
Sinline _LIBCPP_INLINE_VISIBILITY
S_InputIterator
Sfor_each_n(_InputIterator __first, _Size __orig_n, _Function __f)
S{
S    typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;
S    _IntegralSize __n = __orig_n;
S    while (__n > 0)
S    {
S         __f(*__first);
S         ++__first;
S         --__n;
S    }
S    return __first;
S}
N#endif
N
N// find
N
Ntemplate <class _InputIterator, class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_InputIterator
Nfind(_InputIterator __first, _InputIterator __last, const _Tp& __value_)
N{
N    for (; __first != __last; ++__first)
N        if (*__first == __value_)
N            break;
N    return __first;
N}
N
N// find_if
N
Ntemplate <class _InputIterator, class _Predicate>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_InputIterator
Nfind_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
N{
N    for (; __first != __last; ++__first)
N        if (__pred(*__first))
N            break;
N    return __first;
N}
N
N// find_if_not
N
Ntemplate<class _InputIterator, class _Predicate>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_InputIterator
Nfind_if_not(_InputIterator __first, _InputIterator __last, _Predicate __pred)
N{
N    for (; __first != __last; ++__first)
N        if (!__pred(*__first))
N            break;
N    return __first;
N}
N
N// find_end
N
Ntemplate <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>
N_ForwardIterator1
N__find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
N           _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred,
N           forward_iterator_tag, forward_iterator_tag)
N{
N    // modeled after search algorithm
N    _ForwardIterator1 __r = __last1;  // __last1 is the "default" answer
N    if (__first2 == __last2)
N        return __r;
N    while (true)
N    {
N        while (true)
N        {
N            if (__first1 == __last1)         // if source exhausted return last correct answer
N                return __r;                  //    (or __last1 if never found)
N            if (__pred(*__first1, *__first2))
N                break;
N            ++__first1;
N        }
N        // *__first1 matches *__first2, now match elements after here
N        _ForwardIterator1 __m1 = __first1;
N        _ForwardIterator2 __m2 = __first2;
N        while (true)
N        {
N            if (++__m2 == __last2)
N            {                         // Pattern exhaused, record answer and search for another one
N                __r = __first1;
N                ++__first1;
N                break;
N            }
N            if (++__m1 == __last1)     // Source exhausted, return last answer
N                return __r;
N            if (!__pred(*__m1, *__m2))  // mismatch, restart with a new __first
N            {
N                ++__first1;
N                break;
N            }  // else there is a match, check next elements
N        }
N    }
N}
N
Ntemplate <class _BinaryPredicate, class _BidirectionalIterator1, class _BidirectionalIterator2>
N_BidirectionalIterator1
N__find_end(_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1,
N           _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2, _BinaryPredicate __pred,
N           bidirectional_iterator_tag, bidirectional_iterator_tag)
N{
N    // modeled after search algorithm (in reverse)
N    if (__first2 == __last2)
N        return __last1;  // Everything matches an empty sequence
N    _BidirectionalIterator1 __l1 = __last1;
N    _BidirectionalIterator2 __l2 = __last2;
N    --__l2;
N    while (true)
N    {
N        // Find last element in sequence 1 that matchs *(__last2-1), with a mininum of loop checks
N        while (true)
N        {
N            if (__first1 == __l1)  // return __last1 if no element matches *__first2
N                return __last1;
N            if (__pred(*--__l1, *__l2))
N                break;
N        }
N        // *__l1 matches *__l2, now match elements before here
N        _BidirectionalIterator1 __m1 = __l1;
N        _BidirectionalIterator2 __m2 = __l2;
N        while (true)
N        {
N            if (__m2 == __first2)  // If pattern exhausted, __m1 is the answer (works for 1 element pattern)
N                return __m1;
N            if (__m1 == __first1)  // Otherwise if source exhaused, pattern not found
N                return __last1;
N            if (!__pred(*--__m1, *--__m2))  // if there is a mismatch, restart with a new __l1
N            {
N                break;
N            }  // else there is a match, check next elements
N        }
N    }
N}
N
Ntemplate <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>
N_LIBCPP_CONSTEXPR_AFTER_CXX11 _RandomAccessIterator1
Xconstexpr _RandomAccessIterator1
N__find_end(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,
N           _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,
N           random_access_iterator_tag, random_access_iterator_tag)
N{
N    // Take advantage of knowing source and pattern lengths.  Stop short when source is smaller than pattern
N    typename iterator_traits<_RandomAccessIterator2>::difference_type __len2 = __last2 - __first2;
N    if (__len2 == 0)
N        return __last1;
N    typename iterator_traits<_RandomAccessIterator1>::difference_type __len1 = __last1 - __first1;
N    if (__len1 < __len2)
N        return __last1;
N    const _RandomAccessIterator1 __s = __first1 + (__len2 - 1);  // End of pattern match can't go before here
N    _RandomAccessIterator1 __l1 = __last1;
N    _RandomAccessIterator2 __l2 = __last2;
N    --__l2;
N    while (true)
N    {
N        while (true)
N        {
N            if (__s == __l1)
N                return __last1;
N            if (__pred(*--__l1, *__l2))
N                break;
N        }
N        _RandomAccessIterator1 __m1 = __l1;
N        _RandomAccessIterator2 __m2 = __l2;
N        while (true)
N        {
N            if (__m2 == __first2)
N                return __m1;
N                                 // no need to check range on __m1 because __s guarantees we have enough source
N            if (!__pred(*--__m1, *--__m2))
N            {
N                break;
N            }
N        }
N    }
N}
N
Ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_ForwardIterator1
Nfind_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
N         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)
N{
N    return _VSTD::__find_end<typename add_lvalue_reference<_BinaryPredicate>::type>
X    return std::__2::__find_end<typename add_lvalue_reference<_BinaryPredicate>::type>
N                         (__first1, __last1, __first2, __last2, __pred,
N                          typename iterator_traits<_ForwardIterator1>::iterator_category(),
N                          typename iterator_traits<_ForwardIterator2>::iterator_category());
N}
N
Ntemplate <class _ForwardIterator1, class _ForwardIterator2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_ForwardIterator1
Nfind_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
N         _ForwardIterator2 __first2, _ForwardIterator2 __last2)
N{
N    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
N    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
N    return _VSTD::find_end(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());
X    return std::__2::find_end(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());
N}
N
N// find_first_of
N
Ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
N_LIBCPP_CONSTEXPR_AFTER_CXX11 _ForwardIterator1
Xconstexpr _ForwardIterator1
N__find_first_of_ce(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
N              _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)
N{
N    for (; __first1 != __last1; ++__first1)
N        for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)
N            if (__pred(*__first1, *__j))
N                return __first1;
N    return __last1;
N}
N
N
Ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_ForwardIterator1
Nfind_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
N              _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)
N{
N    return _VSTD::__find_first_of_ce(__first1, __last1, __first2, __last2, __pred);
X    return std::__2::__find_first_of_ce(__first1, __last1, __first2, __last2, __pred);
N}
N
Ntemplate <class _ForwardIterator1, class _ForwardIterator2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_ForwardIterator1
Nfind_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
N              _ForwardIterator2 __first2, _ForwardIterator2 __last2)
N{
N    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
N    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
N    return _VSTD::__find_first_of_ce(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());
X    return std::__2::__find_first_of_ce(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());
N}
N
N// adjacent_find
N
Ntemplate <class _ForwardIterator, class _BinaryPredicate>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_ForwardIterator
Nadjacent_find(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)
N{
N    if (__first != __last)
N    {
N        _ForwardIterator __i = __first;
N        while (++__i != __last)
N        {
N            if (__pred(*__first, *__i))
N                return __first;
N            __first = __i;
N        }
N    }
N    return __last;
N}
N
Ntemplate <class _ForwardIterator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_ForwardIterator
Nadjacent_find(_ForwardIterator __first, _ForwardIterator __last)
N{
N    typedef typename iterator_traits<_ForwardIterator>::value_type __v;
N    return _VSTD::adjacent_find(__first, __last, __equal_to<__v>());
X    return std::__2::adjacent_find(__first, __last, __equal_to<__v>());
N}
N
N// count
N
Ntemplate <class _InputIterator, class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename iterator_traits<_InputIterator>::difference_type
Ncount(_InputIterator __first, _InputIterator __last, const _Tp& __value_)
N{
N    typename iterator_traits<_InputIterator>::difference_type __r(0);
N    for (; __first != __last; ++__first)
N        if (*__first == __value_)
N            ++__r;
N    return __r;
N}
N
N// count_if
N
Ntemplate <class _InputIterator, class _Predicate>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename iterator_traits<_InputIterator>::difference_type
Ncount_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
N{
N    typename iterator_traits<_InputIterator>::difference_type __r(0);
N    for (; __first != __last; ++__first)
N        if (__pred(*__first))
N            ++__r;
N    return __r;
N}
N
N// mismatch
N
Ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Npair<_InputIterator1, _InputIterator2>
Nmismatch(_InputIterator1 __first1, _InputIterator1 __last1,
N         _InputIterator2 __first2, _BinaryPredicate __pred)
N{
N    for (; __first1 != __last1; ++__first1, (void) ++__first2)
N        if (!__pred(*__first1, *__first2))
N            break;
N    return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
N}
N
Ntemplate <class _InputIterator1, class _InputIterator2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Npair<_InputIterator1, _InputIterator2>
Nmismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)
N{
N    typedef typename iterator_traits<_InputIterator1>::value_type __v1;
N    typedef typename iterator_traits<_InputIterator2>::value_type __v2;
N    return _VSTD::mismatch(__first1, __last1, __first2, __equal_to<__v1, __v2>());
X    return std::__2::mismatch(__first1, __last1, __first2, __equal_to<__v1, __v2>());
N}
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Npair<_InputIterator1, _InputIterator2>
Nmismatch(_InputIterator1 __first1, _InputIterator1 __last1,
N         _InputIterator2 __first2, _InputIterator2 __last2,
N         _BinaryPredicate __pred)
N{
N    for (; __first1 != __last1 && __first2 != __last2; ++__first1, (void) ++__first2)
N        if (!__pred(*__first1, *__first2))
N            break;
N    return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
N}
N
Ntemplate <class _InputIterator1, class _InputIterator2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Npair<_InputIterator1, _InputIterator2>
Nmismatch(_InputIterator1 __first1, _InputIterator1 __last1,
N         _InputIterator2 __first2, _InputIterator2 __last2)
N{
N    typedef typename iterator_traits<_InputIterator1>::value_type __v1;
N    typedef typename iterator_traits<_InputIterator2>::value_type __v2;
N    return _VSTD::mismatch(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());
X    return std::__2::mismatch(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());
N}
N#endif
N
N// equal
N
Ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Nequal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __pred)
N{
N    for (; __first1 != __last1; ++__first1, (void) ++__first2)
N        if (!__pred(*__first1, *__first2))
N            return false;
N    return true;
N}
N
Ntemplate <class _InputIterator1, class _InputIterator2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Nequal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)
N{
N    typedef typename iterator_traits<_InputIterator1>::value_type __v1;
N    typedef typename iterator_traits<_InputIterator2>::value_type __v2;
N    return _VSTD::equal(__first1, __last1, __first2, __equal_to<__v1, __v2>());
X    return std::__2::equal(__first1, __last1, __first2, __equal_to<__v1, __v2>());
N}
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _BinaryPredicate, class _InputIterator1, class _InputIterator2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
N__equal(_InputIterator1 __first1, _InputIterator1 __last1,
N        _InputIterator2 __first2, _InputIterator2 __last2, _BinaryPredicate __pred,
N        input_iterator_tag, input_iterator_tag )
N{
N    for (; __first1 != __last1 && __first2 != __last2; ++__first1, (void) ++__first2)
N        if (!__pred(*__first1, *__first2))
N            return false;
N    return __first1 == __last1 && __first2 == __last2;
N}
N
Ntemplate <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
N__equal(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,
N        _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,
N      random_access_iterator_tag, random_access_iterator_tag )
N{
N    if ( _VSTD::distance(__first1, __last1) != _VSTD::distance(__first2, __last2))
X    if ( std::__2::distance(__first1, __last1) != std::__2::distance(__first2, __last2))
N        return false;
N    return _VSTD::equal<_RandomAccessIterator1, _RandomAccessIterator2,
X    return std::__2::equal<_RandomAccessIterator1, _RandomAccessIterator2,
N                        typename add_lvalue_reference<_BinaryPredicate>::type>
N                       (__first1, __last1, __first2, __pred );
N}
N
Ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Nequal(_InputIterator1 __first1, _InputIterator1 __last1,
N      _InputIterator2 __first2, _InputIterator2 __last2, _BinaryPredicate __pred )
N{
N    return _VSTD::__equal<typename add_lvalue_reference<_BinaryPredicate>::type>
X    return std::__2::__equal<typename add_lvalue_reference<_BinaryPredicate>::type>
N       (__first1, __last1, __first2, __last2, __pred,
N        typename iterator_traits<_InputIterator1>::iterator_category(),
N        typename iterator_traits<_InputIterator2>::iterator_category());
N}
N
Ntemplate <class _InputIterator1, class _InputIterator2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Nequal(_InputIterator1 __first1, _InputIterator1 __last1,
N      _InputIterator2 __first2, _InputIterator2 __last2)
N{
N    typedef typename iterator_traits<_InputIterator1>::value_type __v1;
N    typedef typename iterator_traits<_InputIterator2>::value_type __v2;
N    return _VSTD::__equal(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>(),
X    return std::__2::__equal(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>(),
N        typename iterator_traits<_InputIterator1>::iterator_category(),
N        typename iterator_traits<_InputIterator2>::iterator_category());
N}
N#endif
N
N// is_permutation
N
Ntemplate<class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
Nbool
Nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
N               _ForwardIterator2 __first2, _BinaryPredicate __pred)
N{
N    // shorten sequences as much as possible by lopping of any equal parts
N    for (; __first1 != __last1; ++__first1, (void) ++__first2)
N        if (!__pred(*__first1, *__first2))
N            goto __not_done;
N    return true;
N__not_done:
N    // __first1 != __last1 && *__first1 != *__first2
N    typedef typename iterator_traits<_ForwardIterator1>::difference_type _D1;
N    _D1 __l1 = _VSTD::distance(__first1, __last1);
X    _D1 __l1 = std::__2::distance(__first1, __last1);
N    if (__l1 == _D1(1))
N        return false;
N    _ForwardIterator2 __last2 = _VSTD::next(__first2, __l1);
X    _ForwardIterator2 __last2 = std::__2::next(__first2, __l1);
N    // For each element in [f1, l1) see if there are the same number of
N    //    equal elements in [f2, l2)
N    for (_ForwardIterator1 __i = __first1; __i != __last1; ++__i)
N    {
N        // Have we already counted the number of *__i in [f1, l1)?
N        for (_ForwardIterator1 __j = __first1; __j != __i; ++__j)
N            if (__pred(*__j, *__i))
N                goto __next_iter;
N        {
N            // Count number of *__i in [f2, l2)
N            _D1 __c2 = 0;
N            for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)
N                if (__pred(*__i, *__j))
N                    ++__c2;
N            if (__c2 == 0)
N                return false;
N            // Count number of *__i in [__i, l1) (we can start with 1)
N            _D1 __c1 = 1;
N            for (_ForwardIterator1 __j = _VSTD::next(__i); __j != __last1; ++__j)
X            for (_ForwardIterator1 __j = std::__2::next(__i); __j != __last1; ++__j)
N                if (__pred(*__i, *__j))
N                    ++__c1;
N            if (__c1 != __c2)
N                return false;
N        }
N__next_iter:;
N    }
N    return true;
N}
N
Ntemplate<class _ForwardIterator1, class _ForwardIterator2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
N               _ForwardIterator2 __first2)
N{
N    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
N    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
N    return _VSTD::is_permutation(__first1, __last1, __first2, __equal_to<__v1, __v2>());
X    return std::__2::is_permutation(__first1, __last1, __first2, __equal_to<__v1, __v2>());
N}
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate<class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>
Nbool
N__is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
N                 _ForwardIterator2 __first2, _ForwardIterator2 __last2,
N                 _BinaryPredicate __pred,
N                 forward_iterator_tag, forward_iterator_tag )
N{
N    // shorten sequences as much as possible by lopping of any equal parts
N    for (; __first1 != __last1 && __first2 != __last2; ++__first1, (void) ++__first2)
N        if (!__pred(*__first1, *__first2))
N            goto __not_done;
N    return __first1 == __last1 && __first2 == __last2;
N__not_done:
N    // __first1 != __last1 && __first2 != __last2 && *__first1 != *__first2
N    typedef typename iterator_traits<_ForwardIterator1>::difference_type _D1;
N    _D1 __l1 = _VSTD::distance(__first1, __last1);
X    _D1 __l1 = std::__2::distance(__first1, __last1);
N
N    typedef typename iterator_traits<_ForwardIterator2>::difference_type _D2;
N    _D2 __l2 = _VSTD::distance(__first2, __last2);
X    _D2 __l2 = std::__2::distance(__first2, __last2);
N    if (__l1 != __l2)
N        return false;
N
N    // For each element in [f1, l1) see if there are the same number of
N    //    equal elements in [f2, l2)
N    for (_ForwardIterator1 __i = __first1; __i != __last1; ++__i)
N    {
N        // Have we already counted the number of *__i in [f1, l1)?
N        for (_ForwardIterator1 __j = __first1; __j != __i; ++__j)
N            if (__pred(*__j, *__i))
N                goto __next_iter;
N        {
N            // Count number of *__i in [f2, l2)
N            _D1 __c2 = 0;
N            for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)
N                if (__pred(*__i, *__j))
N                    ++__c2;
N            if (__c2 == 0)
N                return false;
N            // Count number of *__i in [__i, l1) (we can start with 1)
N            _D1 __c1 = 1;
N            for (_ForwardIterator1 __j = _VSTD::next(__i); __j != __last1; ++__j)
X            for (_ForwardIterator1 __j = std::__2::next(__i); __j != __last1; ++__j)
N                if (__pred(*__i, *__j))
N                    ++__c1;
N            if (__c1 != __c2)
N                return false;
N        }
N__next_iter:;
N    }
N    return true;
N}
N
Ntemplate<class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>
Nbool
N__is_permutation(_RandomAccessIterator1 __first1, _RandomAccessIterator2 __last1,
N               _RandomAccessIterator1 __first2, _RandomAccessIterator2 __last2,
N               _BinaryPredicate __pred,
N               random_access_iterator_tag, random_access_iterator_tag )
N{
N    if ( _VSTD::distance(__first1, __last1) != _VSTD::distance(__first2, __last2))
X    if ( std::__2::distance(__first1, __last1) != std::__2::distance(__first2, __last2))
N        return false;
N    return _VSTD::is_permutation<_RandomAccessIterator1, _RandomAccessIterator2,
X    return std::__2::is_permutation<_RandomAccessIterator1, _RandomAccessIterator2,
N                                 typename add_lvalue_reference<_BinaryPredicate>::type>
N                                (__first1, __last1, __first2, __pred );
N}
N
Ntemplate<class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
N               _ForwardIterator2 __first2, _ForwardIterator2 __last2,
N               _BinaryPredicate __pred )
N{
N    return _VSTD::__is_permutation<typename add_lvalue_reference<_BinaryPredicate>::type>
X    return std::__2::__is_permutation<typename add_lvalue_reference<_BinaryPredicate>::type>
N       (__first1, __last1, __first2, __last2, __pred,
N        typename iterator_traits<_ForwardIterator1>::iterator_category(),
N        typename iterator_traits<_ForwardIterator2>::iterator_category());
N}
N
Ntemplate<class _ForwardIterator1, class _ForwardIterator2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
N               _ForwardIterator2 __first2, _ForwardIterator2 __last2)
N{
N    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
N    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
N    return _VSTD::__is_permutation(__first1, __last1, __first2, __last2,
X    return std::__2::__is_permutation(__first1, __last1, __first2, __last2,
N        __equal_to<__v1, __v2>(),
N        typename iterator_traits<_ForwardIterator1>::iterator_category(),
N        typename iterator_traits<_ForwardIterator2>::iterator_category());
N}
N#endif
N
N// search
N
Ntemplate <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>
Npair<_ForwardIterator1, _ForwardIterator1>
N__search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
N         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred,
N         forward_iterator_tag, forward_iterator_tag)
N{
N    if (__first2 == __last2)
N        return make_pair(__first1, __first1);  // Everything matches an empty sequence
N    while (true)
N    {
N        // Find first element in sequence 1 that matchs *__first2, with a mininum of loop checks
N        while (true)
N        {
N            if (__first1 == __last1)  // return __last1 if no element matches *__first2
N                return make_pair(__last1, __last1);
N            if (__pred(*__first1, *__first2))
N                break;
N            ++__first1;
N        }
N        // *__first1 matches *__first2, now match elements after here
N        _ForwardIterator1 __m1 = __first1;
N        _ForwardIterator2 __m2 = __first2;
N        while (true)
N        {
N            if (++__m2 == __last2)  // If pattern exhausted, __first1 is the answer (works for 1 element pattern)
N                return make_pair(__first1, __m1);
N            if (++__m1 == __last1)  // Otherwise if source exhaused, pattern not found
N                return make_pair(__last1, __last1);
N            if (!__pred(*__m1, *__m2))  // if there is a mismatch, restart with a new __first1
N            {
N                ++__first1;
N                break;
N            }  // else there is a match, check next elements
N        }
N    }
N}
N
Ntemplate <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>
N_LIBCPP_CONSTEXPR_AFTER_CXX11
Xconstexpr
Npair<_RandomAccessIterator1, _RandomAccessIterator1>
N__search(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,
N         _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,
N           random_access_iterator_tag, random_access_iterator_tag)
N{
N    typedef typename iterator_traits<_RandomAccessIterator1>::difference_type _D1;
N    typedef typename iterator_traits<_RandomAccessIterator2>::difference_type _D2;
N    // Take advantage of knowing source and pattern lengths.  Stop short when source is smaller than pattern
N    const _D2 __len2 = __last2 - __first2;
N    if (__len2 == 0)
N        return make_pair(__first1, __first1);
N    const _D1 __len1 = __last1 - __first1;
N    if (__len1 < __len2)
N        return make_pair(__last1, __last1);
N    const _RandomAccessIterator1 __s = __last1 - (__len2 - 1);  // Start of pattern match can't go beyond here
N
N    while (true)
N    {
N        while (true)
N        {
N            if (__first1 == __s)
N                return make_pair(__last1, __last1);
N            if (__pred(*__first1, *__first2))
N                break;
N            ++__first1;
N        }
N
N        _RandomAccessIterator1 __m1 = __first1;
N        _RandomAccessIterator2 __m2 = __first2;
N         while (true)
N         {
N             if (++__m2 == __last2)
N                 return make_pair(__first1, __first1 + __len2);
N             ++__m1;          // no need to check range on __m1 because __s guarantees we have enough source
N             if (!__pred(*__m1, *__m2))
N             {
N                 ++__first1;
N                 break;
N             }
N         }
N    }
N}
N
Ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_ForwardIterator1
Nsearch(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
N       _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)
N{
N    return _VSTD::__search<typename add_lvalue_reference<_BinaryPredicate>::type>
X    return std::__2::__search<typename add_lvalue_reference<_BinaryPredicate>::type>
N                         (__first1, __last1, __first2, __last2, __pred,
N                          typename iterator_traits<_ForwardIterator1>::iterator_category(),
N                          typename iterator_traits<_ForwardIterator2>::iterator_category())
N            .first;
N}
N
Ntemplate <class _ForwardIterator1, class _ForwardIterator2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_ForwardIterator1
Nsearch(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
N       _ForwardIterator2 __first2, _ForwardIterator2 __last2)
N{
N    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
N    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
N    return _VSTD::search(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());
X    return std::__2::search(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());
N}
N
N// search_n
N
Ntemplate <class _BinaryPredicate, class _ForwardIterator, class _Size, class _Tp>
N_ForwardIterator
N__search_n(_ForwardIterator __first, _ForwardIterator __last,
N           _Size __count, const _Tp& __value_, _BinaryPredicate __pred, forward_iterator_tag)
N{
N    if (__count <= 0)
N        return __first;
N    while (true)
N    {
N        // Find first element in sequence that matchs __value_, with a mininum of loop checks
N        while (true)
N        {
N            if (__first == __last)  // return __last if no element matches __value_
N                return __last;
N            if (__pred(*__first, __value_))
N                break;
N            ++__first;
N        }
N        // *__first matches __value_, now match elements after here
N        _ForwardIterator __m = __first;
N        _Size __c(0);
N        while (true)
N        {
N            if (++__c == __count)  // If pattern exhausted, __first is the answer (works for 1 element pattern)
N                return __first;
N            if (++__m == __last)  // Otherwise if source exhaused, pattern not found
N                return __last;
N            if (!__pred(*__m, __value_))  // if there is a mismatch, restart with a new __first
N            {
N                __first = __m;
N                ++__first;
N                break;
N            }  // else there is a match, check next elements
N        }
N    }
N}
N
Ntemplate <class _BinaryPredicate, class _RandomAccessIterator, class _Size, class _Tp>
N_RandomAccessIterator
N__search_n(_RandomAccessIterator __first, _RandomAccessIterator __last,
N           _Size __count, const _Tp& __value_, _BinaryPredicate __pred, random_access_iterator_tag)
N{
N    if (__count <= 0)
N        return __first;
N    _Size __len = static_cast<_Size>(__last - __first);
N    if (__len < __count)
N        return __last;
N    const _RandomAccessIterator __s = __last - (__count - 1);  // Start of pattern match can't go beyond here
N    while (true)
N    {
N        // Find first element in sequence that matchs __value_, with a mininum of loop checks
N        while (true)
N        {
N            if (__first >= __s)  // return __last if no element matches __value_
N                return __last;
N            if (__pred(*__first, __value_))
N                break;
N            ++__first;
N        }
N        // *__first matches __value_, now match elements after here
N        _RandomAccessIterator __m = __first;
N        _Size __c(0);
N        while (true)
N        {
N            if (++__c == __count)  // If pattern exhausted, __first is the answer (works for 1 element pattern)
N                return __first;
N             ++__m;          // no need to check range on __m because __s guarantees we have enough source
N            if (!__pred(*__m, __value_))  // if there is a mismatch, restart with a new __first
N            {
N                __first = __m;
N                ++__first;
N                break;
N            }  // else there is a match, check next elements
N        }
N    }
N}
N
Ntemplate <class _ForwardIterator, class _Size, class _Tp, class _BinaryPredicate>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_ForwardIterator
Nsearch_n(_ForwardIterator __first, _ForwardIterator __last,
N         _Size __count, const _Tp& __value_, _BinaryPredicate __pred)
N{
N    return _VSTD::__search_n<typename add_lvalue_reference<_BinaryPredicate>::type>
X    return std::__2::__search_n<typename add_lvalue_reference<_BinaryPredicate>::type>
N           (__first, __last, __convert_to_integral(__count), __value_, __pred,
N           typename iterator_traits<_ForwardIterator>::iterator_category());
N}
N
Ntemplate <class _ForwardIterator, class _Size, class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_ForwardIterator
Nsearch_n(_ForwardIterator __first, _ForwardIterator __last, _Size __count, const _Tp& __value_)
N{
N    typedef typename iterator_traits<_ForwardIterator>::value_type __v;
N    return _VSTD::search_n(__first, __last, __convert_to_integral(__count),
X    return std::__2::search_n(__first, __last, __convert_to_integral(__count),
N                           __value_, __equal_to<__v, _Tp>());
N}
N
N// copy
Ntemplate <class _Iter>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_Iter
N__unwrap_iter(_Iter __i)
N{
N    return __i;
N}
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename enable_if
N<
N    is_trivially_copy_assignable<_Tp>::value,
N    _Tp*
N>::type
N__unwrap_iter(move_iterator<_Tp*> __i)
N{
N    return __i.base();
N}
N
N#if _LIBCPP_DEBUG_LEVEL < 2
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename enable_if
N<
N    is_trivially_copy_assignable<_Tp>::value,
N    _Tp*
N>::type
N__unwrap_iter(__wrap_iter<_Tp*> __i)
N{
N    return __i.base();
N}
N
N#else
S
Stemplate <class _Tp>
Sinline _LIBCPP_INLINE_VISIBILITY
Stypename enable_if
S<
S    is_trivially_copy_assignable<_Tp>::value,
S    __wrap_iter<_Tp*>
S>::type
S__unwrap_iter(__wrap_iter<_Tp*> __i)
S{
S    return __i;
S}
S
N#endif  // _LIBCPP_DEBUG_LEVEL < 2
N
Ntemplate <class _InputIterator, class _OutputIterator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_OutputIterator
N__copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
N{
N    for (; __first != __last; ++__first, (void) ++__result)
N        *__result = *__first;
N    return __result;
N}
N
Ntemplate <class _Tp, class _Up>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename enable_if
N<
N    is_same<typename remove_const<_Tp>::type, _Up>::value &&
N    is_trivially_copy_assignable<_Up>::value,
N    _Up*
N>::type
N__copy(_Tp* __first, _Tp* __last, _Up* __result)
N{
N    const size_t __n = static_cast<size_t>(__last - __first);
N    if (__n > 0)
N        _VSTD::memmove(__result, __first, __n * sizeof(_Up));
X        std::__2::memmove(__result, __first, __n * sizeof(_Up));
N    return __result + __n;
N}
N
Ntemplate <class _InputIterator, class _OutputIterator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_OutputIterator
Ncopy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
N{
N    return _VSTD::__copy(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
X    return std::__2::__copy(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
N}
N
N// copy_backward
N
Ntemplate <class _BidirectionalIterator, class _OutputIterator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_OutputIterator
N__copy_backward(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)
N{
N    while (__first != __last)
N        *--__result = *--__last;
N    return __result;
N}
N
Ntemplate <class _Tp, class _Up>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename enable_if
N<
N    is_same<typename remove_const<_Tp>::type, _Up>::value &&
N    is_trivially_copy_assignable<_Up>::value,
N    _Up*
N>::type
N__copy_backward(_Tp* __first, _Tp* __last, _Up* __result)
N{
N    const size_t __n = static_cast<size_t>(__last - __first);
N    if (__n > 0)
N    {
N        __result -= __n;
N        _VSTD::memmove(__result, __first, __n * sizeof(_Up));
X        std::__2::memmove(__result, __first, __n * sizeof(_Up));
N    }
N    return __result;
N}
N
Ntemplate <class _BidirectionalIterator1, class _BidirectionalIterator2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_BidirectionalIterator2
Ncopy_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,
N              _BidirectionalIterator2 __result)
N{
N    return _VSTD::__copy_backward(__unwrap_iter(__first),
X    return std::__2::__copy_backward(__unwrap_iter(__first),
N                                  __unwrap_iter(__last),
N                                  __unwrap_iter(__result));
N}
N
N// copy_if
N
Ntemplate<class _InputIterator, class _OutputIterator, class _Predicate>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_OutputIterator
Ncopy_if(_InputIterator __first, _InputIterator __last,
N        _OutputIterator __result, _Predicate __pred)
N{
N    for (; __first != __last; ++__first)
N    {
N        if (__pred(*__first))
N        {
N            *__result = *__first;
N            ++__result;
N        }
N    }
N    return __result;
N}
N
N// copy_n
N
Ntemplate<class _InputIterator, class _Size, class _OutputIterator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename enable_if
N<
N    __is_input_iterator<_InputIterator>::value &&
N   !__is_random_access_iterator<_InputIterator>::value,
N    _OutputIterator
N>::type
Ncopy_n(_InputIterator __first, _Size __orig_n, _OutputIterator __result)
N{
N    typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;
N    _IntegralSize __n = __orig_n;
N    if (__n > 0)
N    {
N        *__result = *__first;
N        ++__result;
N        for (--__n; __n > 0; --__n)
N        {
N            ++__first;
N            *__result = *__first;
N            ++__result;
N        }
N    }
N    return __result;
N}
N
Ntemplate<class _InputIterator, class _Size, class _OutputIterator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename enable_if
N<
N    __is_random_access_iterator<_InputIterator>::value,
N    _OutputIterator
N>::type
Ncopy_n(_InputIterator __first, _Size __orig_n, _OutputIterator __result)
N{
N    typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;
N    _IntegralSize __n = __orig_n;
N    return _VSTD::copy(__first, __first + __n, __result);
X    return std::__2::copy(__first, __first + __n, __result);
N}
N
N// move
N
Ntemplate <class _InputIterator, class _OutputIterator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_OutputIterator
N__move(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
N{
N    for (; __first != __last; ++__first, (void) ++__result)
N        *__result = _VSTD::move(*__first);
X        *__result = std::__2::move(*__first);
N    return __result;
N}
N
Ntemplate <class _Tp, class _Up>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename enable_if
N<
N    is_same<typename remove_const<_Tp>::type, _Up>::value &&
N    is_trivially_copy_assignable<_Up>::value,
N    _Up*
N>::type
N__move(_Tp* __first, _Tp* __last, _Up* __result)
N{
N    const size_t __n = static_cast<size_t>(__last - __first);
N    if (__n > 0)
N        _VSTD::memmove(__result, __first, __n * sizeof(_Up));
X        std::__2::memmove(__result, __first, __n * sizeof(_Up));
N    return __result + __n;
N}
N
Ntemplate <class _InputIterator, class _OutputIterator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_OutputIterator
Nmove(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
N{
N    return _VSTD::__move(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
X    return std::__2::__move(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
N}
N
N// move_backward
N
Ntemplate <class _InputIterator, class _OutputIterator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_OutputIterator
N__move_backward(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
N{
N    while (__first != __last)
N        *--__result = _VSTD::move(*--__last);
X        *--__result = std::__2::move(*--__last);
N    return __result;
N}
N
Ntemplate <class _Tp, class _Up>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename enable_if
N<
N    is_same<typename remove_const<_Tp>::type, _Up>::value &&
N    is_trivially_copy_assignable<_Up>::value,
N    _Up*
N>::type
N__move_backward(_Tp* __first, _Tp* __last, _Up* __result)
N{
N    const size_t __n = static_cast<size_t>(__last - __first);
N    if (__n > 0)
N    {
N        __result -= __n;
N        _VSTD::memmove(__result, __first, __n * sizeof(_Up));
X        std::__2::memmove(__result, __first, __n * sizeof(_Up));
N    }
N    return __result;
N}
N
Ntemplate <class _BidirectionalIterator1, class _BidirectionalIterator2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_BidirectionalIterator2
Nmove_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,
N              _BidirectionalIterator2 __result)
N{
N    return _VSTD::__move_backward(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
X    return std::__2::__move_backward(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
N}
N
N// iter_swap
N
N// moved to <type_traits> for better swap / noexcept support
N
N// transform
N
Ntemplate <class _InputIterator, class _OutputIterator, class _UnaryOperation>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_OutputIterator
Ntransform(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _UnaryOperation __op)
N{
N    for (; __first != __last; ++__first, (void) ++__result)
N        *__result = __op(*__first);
N    return __result;
N}
N
Ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _BinaryOperation>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_OutputIterator
Ntransform(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2,
N          _OutputIterator __result, _BinaryOperation __binary_op)
N{
N    for (; __first1 != __last1; ++__first1, (void) ++__first2, ++__result)
N        *__result = __binary_op(*__first1, *__first2);
N    return __result;
N}
N
N// replace
N
Ntemplate <class _ForwardIterator, class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Nreplace(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __old_value, const _Tp& __new_value)
N{
N    for (; __first != __last; ++__first)
N        if (*__first == __old_value)
N            *__first = __new_value;
N}
N
N// replace_if
N
Ntemplate <class _ForwardIterator, class _Predicate, class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Nreplace_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, const _Tp& __new_value)
N{
N    for (; __first != __last; ++__first)
N        if (__pred(*__first))
N            *__first = __new_value;
N}
N
N// replace_copy
N
Ntemplate <class _InputIterator, class _OutputIterator, class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_OutputIterator
Nreplace_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result,
N             const _Tp& __old_value, const _Tp& __new_value)
N{
N    for (; __first != __last; ++__first, (void) ++__result)
N        if (*__first == __old_value)
N            *__result = __new_value;
N        else
N            *__result = *__first;
N    return __result;
N}
N
N// replace_copy_if
N
Ntemplate <class _InputIterator, class _OutputIterator, class _Predicate, class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_OutputIterator
Nreplace_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result,
N                _Predicate __pred, const _Tp& __new_value)
N{
N    for (; __first != __last; ++__first, (void) ++__result)
N        if (__pred(*__first))
N            *__result = __new_value;
N        else
N            *__result = *__first;
N    return __result;
N}
N
N// fill_n
N
Ntemplate <class _OutputIterator, class _Size, class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_OutputIterator
N__fill_n(_OutputIterator __first, _Size __n, const _Tp& __value_)
N{
N    for (; __n > 0; ++__first, (void) --__n)
N        *__first = __value_;
N    return __first;
N}
N
Ntemplate <class _Tp, class _Size, class _Up>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename enable_if
N<
N    is_integral<_Tp>::value && sizeof(_Tp) == 1 &&
N    !is_same<_Tp, bool>::value &&
N    is_integral<_Up>::value && sizeof(_Up) == 1,
N    _Tp*
N>::type
N__fill_n(_Tp* __first, _Size __n,_Up __value_)
N{
N    if (__n > 0)
N        _VSTD::memset(__first, (unsigned char)__value_, (size_t)(__n));
X        std::__2::memset(__first, (unsigned char)__value_, (size_t)(__n));
N    return __first + __n;
N}
N
Ntemplate <class _OutputIterator, class _Size, class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_OutputIterator
Nfill_n(_OutputIterator __first, _Size __n, const _Tp& __value_)
N{
N   return _VSTD::__fill_n(__first, __convert_to_integral(__n), __value_);
X   return std::__2::__fill_n(__first, __convert_to_integral(__n), __value_);
N}
N
N// fill
N
Ntemplate <class _ForwardIterator, class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
N__fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, forward_iterator_tag)
N{
N    for (; __first != __last; ++__first)
N        *__first = __value_;
N}
N
Ntemplate <class _RandomAccessIterator, class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
N__fill(_RandomAccessIterator __first, _RandomAccessIterator __last, const _Tp& __value_, random_access_iterator_tag)
N{
N    _VSTD::fill_n(__first, __last - __first, __value_);
X    std::__2::fill_n(__first, __last - __first, __value_);
N}
N
Ntemplate <class _ForwardIterator, class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Nfill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
N{
N    _VSTD::__fill(__first, __last, __value_, typename iterator_traits<_ForwardIterator>::iterator_category());
X    std::__2::__fill(__first, __last, __value_, typename iterator_traits<_ForwardIterator>::iterator_category());
N}
N
N// generate
N
Ntemplate <class _ForwardIterator, class _Generator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Ngenerate(_ForwardIterator __first, _ForwardIterator __last, _Generator __gen)
N{
N    for (; __first != __last; ++__first)
N        *__first = __gen();
N}
N
N// generate_n
N
Ntemplate <class _OutputIterator, class _Size, class _Generator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_OutputIterator
Ngenerate_n(_OutputIterator __first, _Size __orig_n, _Generator __gen)
N{
N    typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;
N    _IntegralSize __n = __orig_n;
N    for (; __n > 0; ++__first, (void) --__n)
N        *__first = __gen();
N    return __first;
N}
N
N// remove
N
Ntemplate <class _ForwardIterator, class _Tp>
N_ForwardIterator
Nremove(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
N{
N    __first = _VSTD::find(__first, __last, __value_);
X    __first = std::__2::find(__first, __last, __value_);
N    if (__first != __last)
N    {
N        _ForwardIterator __i = __first;
N        while (++__i != __last)
N        {
N            if (!(*__i == __value_))
N            {
N                *__first = _VSTD::move(*__i);
X                *__first = std::__2::move(*__i);
N                ++__first;
N            }
N        }
N    }
N    return __first;
N}
N
N// remove_if
N
Ntemplate <class _ForwardIterator, class _Predicate>
N_ForwardIterator
Nremove_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
N{
N    __first = _VSTD::find_if<_ForwardIterator, typename add_lvalue_reference<_Predicate>::type>
X    __first = std::__2::find_if<_ForwardIterator, typename add_lvalue_reference<_Predicate>::type>
N                           (__first, __last, __pred);
N    if (__first != __last)
N    {
N        _ForwardIterator __i = __first;
N        while (++__i != __last)
N        {
N            if (!__pred(*__i))
N            {
N                *__first = _VSTD::move(*__i);
X                *__first = std::__2::move(*__i);
N                ++__first;
N            }
N        }
N    }
N    return __first;
N}
N
N// remove_copy
N
Ntemplate <class _InputIterator, class _OutputIterator, class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_OutputIterator
Nremove_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, const _Tp& __value_)
N{
N    for (; __first != __last; ++__first)
N    {
N        if (!(*__first == __value_))
N        {
N            *__result = *__first;
N            ++__result;
N        }
N    }
N    return __result;
N}
N
N// remove_copy_if
N
Ntemplate <class _InputIterator, class _OutputIterator, class _Predicate>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_OutputIterator
Nremove_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred)
N{
N    for (; __first != __last; ++__first)
N    {
N        if (!__pred(*__first))
N        {
N            *__result = *__first;
N            ++__result;
N        }
N    }
N    return __result;
N}
N
N// unique
N
Ntemplate <class _ForwardIterator, class _BinaryPredicate>
N_ForwardIterator
Nunique(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)
N{
N    __first = _VSTD::adjacent_find<_ForwardIterator, typename add_lvalue_reference<_BinaryPredicate>::type>
X    __first = std::__2::adjacent_find<_ForwardIterator, typename add_lvalue_reference<_BinaryPredicate>::type>
N                                 (__first, __last, __pred);
N    if (__first != __last)
N    {
N        // ...  a  a  ?  ...
N        //      f     i
N        _ForwardIterator __i = __first;
N        for (++__i; ++__i != __last;)
N            if (!__pred(*__first, *__i))
N                *++__first = _VSTD::move(*__i);
X                *++__first = std::__2::move(*__i);
N        ++__first;
N    }
N    return __first;
N}
N
Ntemplate <class _ForwardIterator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_ForwardIterator
Nunique(_ForwardIterator __first, _ForwardIterator __last)
N{
N    typedef typename iterator_traits<_ForwardIterator>::value_type __v;
N    return _VSTD::unique(__first, __last, __equal_to<__v>());
X    return std::__2::unique(__first, __last, __equal_to<__v>());
N}
N
N// unique_copy
N
Ntemplate <class _BinaryPredicate, class _InputIterator, class _OutputIterator>
N_OutputIterator
N__unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred,
N              input_iterator_tag, output_iterator_tag)
N{
N    if (__first != __last)
N    {
N        typename iterator_traits<_InputIterator>::value_type __t(*__first);
N        *__result = __t;
N        ++__result;
N        while (++__first != __last)
N        {
N            if (!__pred(__t, *__first))
N            {
N                __t = *__first;
N                *__result = __t;
N                ++__result;
N            }
N        }
N    }
N    return __result;
N}
N
Ntemplate <class _BinaryPredicate, class _ForwardIterator, class _OutputIterator>
N_OutputIterator
N__unique_copy(_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result, _BinaryPredicate __pred,
N              forward_iterator_tag, output_iterator_tag)
N{
N    if (__first != __last)
N    {
N        _ForwardIterator __i = __first;
N        *__result = *__i;
N        ++__result;
N        while (++__first != __last)
N        {
N            if (!__pred(*__i, *__first))
N            {
N                *__result = *__first;
N                ++__result;
N                __i = __first;
N            }
N        }
N    }
N    return __result;
N}
N
Ntemplate <class _BinaryPredicate, class _InputIterator, class _ForwardIterator>
N_ForwardIterator
N__unique_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _BinaryPredicate __pred,
N              input_iterator_tag, forward_iterator_tag)
N{
N    if (__first != __last)
N    {
N        *__result = *__first;
N        while (++__first != __last)
N            if (!__pred(*__result, *__first))
N                *++__result = *__first;
N        ++__result;
N    }
N    return __result;
N}
N
Ntemplate <class _InputIterator, class _OutputIterator, class _BinaryPredicate>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_OutputIterator
Nunique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred)
N{
N    return _VSTD::__unique_copy<typename add_lvalue_reference<_BinaryPredicate>::type>
X    return std::__2::__unique_copy<typename add_lvalue_reference<_BinaryPredicate>::type>
N                              (__first, __last, __result, __pred,
N                               typename iterator_traits<_InputIterator>::iterator_category(),
N                               typename iterator_traits<_OutputIterator>::iterator_category());
N}
N
Ntemplate <class _InputIterator, class _OutputIterator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_OutputIterator
Nunique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
N{
N    typedef typename iterator_traits<_InputIterator>::value_type __v;
N    return _VSTD::unique_copy(__first, __last, __result, __equal_to<__v>());
X    return std::__2::unique_copy(__first, __last, __result, __equal_to<__v>());
N}
N
N// reverse
N
Ntemplate <class _BidirectionalIterator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
N__reverse(_BidirectionalIterator __first, _BidirectionalIterator __last, bidirectional_iterator_tag)
N{
N    while (__first != __last)
N    {
N        if (__first == --__last)
N            break;
N        _VSTD::iter_swap(__first, __last);
X        std::__2::iter_swap(__first, __last);
N        ++__first;
N    }
N}
N
Ntemplate <class _RandomAccessIterator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
N__reverse(_RandomAccessIterator __first, _RandomAccessIterator __last, random_access_iterator_tag)
N{
N    if (__first != __last)
N        for (; __first < --__last; ++__first)
N            _VSTD::iter_swap(__first, __last);
X            std::__2::iter_swap(__first, __last);
N}
N
Ntemplate <class _BidirectionalIterator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Nreverse(_BidirectionalIterator __first, _BidirectionalIterator __last)
N{
N    _VSTD::__reverse(__first, __last, typename iterator_traits<_BidirectionalIterator>::iterator_category());
X    std::__2::__reverse(__first, __last, typename iterator_traits<_BidirectionalIterator>::iterator_category());
N}
N
N// reverse_copy
N
Ntemplate <class _BidirectionalIterator, class _OutputIterator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_OutputIterator
Nreverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)
N{
N    for (; __first != __last; ++__result)
N        *__result = *--__last;
N    return __result;
N}
N
N// rotate
N
Ntemplate <class _ForwardIterator>
N_ForwardIterator
N__rotate_left(_ForwardIterator __first, _ForwardIterator __last)
N{
N    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
N    value_type __tmp = _VSTD::move(*__first);
X    value_type __tmp = std::__2::move(*__first);
N    _ForwardIterator __lm1 = _VSTD::move(_VSTD::next(__first), __last, __first);
X    _ForwardIterator __lm1 = std::__2::move(std::__2::next(__first), __last, __first);
N    *__lm1 = _VSTD::move(__tmp);
X    *__lm1 = std::__2::move(__tmp);
N    return __lm1;
N}
N
Ntemplate <class _BidirectionalIterator>
N_BidirectionalIterator
N__rotate_right(_BidirectionalIterator __first, _BidirectionalIterator __last)
N{
N    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
N    _BidirectionalIterator __lm1 = _VSTD::prev(__last);
X    _BidirectionalIterator __lm1 = std::__2::prev(__last);
N    value_type __tmp = _VSTD::move(*__lm1);
X    value_type __tmp = std::__2::move(*__lm1);
N    _BidirectionalIterator __fp1 = _VSTD::move_backward(__first, __lm1, __last);
X    _BidirectionalIterator __fp1 = std::__2::move_backward(__first, __lm1, __last);
N    *__first = _VSTD::move(__tmp);
X    *__first = std::__2::move(__tmp);
N    return __fp1;
N}
N
Ntemplate <class _ForwardIterator>
N_ForwardIterator
N__rotate_forward(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)
N{
N    _ForwardIterator __i = __middle;
N    while (true)
N    {
N        swap(*__first, *__i);
N        ++__first;
N        if (++__i == __last)
N            break;
N        if (__first == __middle)
N            __middle = __i;
N    }
N    _ForwardIterator __r = __first;
N    if (__first != __middle)
N    {
N        __i = __middle;
N        while (true)
N        {
N            swap(*__first, *__i);
N            ++__first;
N            if (++__i == __last)
N            {
N                if (__first == __middle)
N                    break;
N                __i = __middle;
N            }
N            else if (__first == __middle)
N                __middle = __i;
N        }
N    }
N    return __r;
N}
N
Ntemplate<typename _Integral>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_Integral
N__algo_gcd(_Integral __x, _Integral __y)
N{
N    do
N    {
N        _Integral __t = __x % __y;
N        __x = __y;
N        __y = __t;
N    } while (__y);
N    return __x;
N}
N
Ntemplate<typename _RandomAccessIterator>
N_RandomAccessIterator
N__rotate_gcd(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)
N{
N    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
N    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
N
N    const difference_type __m1 = __middle - __first;
N    const difference_type __m2 = __last - __middle;
N    if (__m1 == __m2)
N    {
N        _VSTD::swap_ranges(__first, __middle, __middle);
X        std::__2::swap_ranges(__first, __middle, __middle);
N        return __middle;
N    }
N    const difference_type __g = _VSTD::__algo_gcd(__m1, __m2);
X    const difference_type __g = std::__2::__algo_gcd(__m1, __m2);
N    for (_RandomAccessIterator __p = __first + __g; __p != __first;)
N    {
N        value_type __t(_VSTD::move(*--__p));
X        value_type __t(std::__2::move(*--__p));
N        _RandomAccessIterator __p1 = __p;
N        _RandomAccessIterator __p2 = __p1 + __m1;
N        do
N        {
N            *__p1 = _VSTD::move(*__p2);
X            *__p1 = std::__2::move(*__p2);
N            __p1 = __p2;
N            const difference_type __d = __last - __p2;
N            if (__m1 < __d)
N                __p2 += __m1;
N            else
N                __p2 = __first + (__m1 - __d);
N        } while (__p2 != __p);
N        *__p1 = _VSTD::move(__t);
X        *__p1 = std::__2::move(__t);
N    }
N    return __first + __m2;
N}
N
Ntemplate <class _ForwardIterator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_ForwardIterator
N__rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last,
N         _VSTD::forward_iterator_tag)
X         std::__2::forward_iterator_tag)
N{
N    typedef typename _VSTD::iterator_traits<_ForwardIterator>::value_type value_type;
X    typedef typename std::__2::iterator_traits<_ForwardIterator>::value_type value_type;
N    if (_VSTD::is_trivially_move_assignable<value_type>::value)
X    if (std::__2::is_trivially_move_assignable<value_type>::value)
N    {
N        if (_VSTD::next(__first) == __middle)
X        if (std::__2::next(__first) == __middle)
N            return _VSTD::__rotate_left(__first, __last);
X            return std::__2::__rotate_left(__first, __last);
N    }
N    return _VSTD::__rotate_forward(__first, __middle, __last);
X    return std::__2::__rotate_forward(__first, __middle, __last);
N}
N
Ntemplate <class _BidirectionalIterator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_BidirectionalIterator
N__rotate(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,
N         _VSTD::bidirectional_iterator_tag)
X         std::__2::bidirectional_iterator_tag)
N{
N    typedef typename _VSTD::iterator_traits<_BidirectionalIterator>::value_type value_type;
X    typedef typename std::__2::iterator_traits<_BidirectionalIterator>::value_type value_type;
N    if (_VSTD::is_trivially_move_assignable<value_type>::value)
X    if (std::__2::is_trivially_move_assignable<value_type>::value)
N    {
N        if (_VSTD::next(__first) == __middle)
X        if (std::__2::next(__first) == __middle)
N            return _VSTD::__rotate_left(__first, __last);
X            return std::__2::__rotate_left(__first, __last);
N        if (_VSTD::next(__middle) == __last)
X        if (std::__2::next(__middle) == __last)
N            return _VSTD::__rotate_right(__first, __last);
X            return std::__2::__rotate_right(__first, __last);
N    }
N    return _VSTD::__rotate_forward(__first, __middle, __last);
X    return std::__2::__rotate_forward(__first, __middle, __last);
N}
N
N#ifdef __TI_COMPILER_VERSION__
N#pragma diag_push
N#pragma diag_suppress 112
N#endif /* defined(__TI_COMPILER_VERSION__) */
N
Ntemplate <class _RandomAccessIterator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_RandomAccessIterator
N__rotate(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,
N         _VSTD::random_access_iterator_tag)
X         std::__2::random_access_iterator_tag)
N{
N    typedef typename _VSTD::iterator_traits<_RandomAccessIterator>::value_type value_type;
X    typedef typename std::__2::iterator_traits<_RandomAccessIterator>::value_type value_type;
N    if (_VSTD::is_trivially_move_assignable<value_type>::value)
X    if (std::__2::is_trivially_move_assignable<value_type>::value)
N    {
N        if (_VSTD::next(__first) == __middle)
X        if (std::__2::next(__first) == __middle)
N            return _VSTD::__rotate_left(__first, __last);
X            return std::__2::__rotate_left(__first, __last);
N        if (_VSTD::next(__middle) == __last)
X        if (std::__2::next(__middle) == __last)
N            return _VSTD::__rotate_right(__first, __last);
X            return std::__2::__rotate_right(__first, __last);
N        return _VSTD::__rotate_gcd(__first, __middle, __last);
X        return std::__2::__rotate_gcd(__first, __middle, __last);
N    }
N    return _VSTD::__rotate_forward(__first, __middle, __last);
X    return std::__2::__rotate_forward(__first, __middle, __last);
N}
N
N#ifdef __TI_COMPILER_VERSION__
N#pragma diag_pop
N#endif /* defined(__TI_COMPILER_VERSION__) */
N
Ntemplate <class _ForwardIterator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_ForwardIterator
Nrotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)
N{
N    if (__first == __middle)
N        return __last;
N    if (__middle == __last)
N        return __first;
N    return _VSTD::__rotate(__first, __middle, __last,
X    return std::__2::__rotate(__first, __middle, __last,
N                           typename _VSTD::iterator_traits<_ForwardIterator>::iterator_category());
X                           typename std::__2::iterator_traits<_ForwardIterator>::iterator_category());
N}
N
N// rotate_copy
N
Ntemplate <class _ForwardIterator, class _OutputIterator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_OutputIterator
Nrotate_copy(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last, _OutputIterator __result)
N{
N    return _VSTD::copy(__first, __middle, _VSTD::copy(__middle, __last, __result));
X    return std::__2::copy(__first, __middle, std::__2::copy(__middle, __last, __result));
N}
N
N// min_element
N
Ntemplate <class _ForwardIterator, class _Compare>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
Xinline __attribute__ ((__always_inline__)) constexpr
N_ForwardIterator
Nmin_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
N{
N    if (__first != __last)
N    {
N        _ForwardIterator __i = __first;
N        while (++__i != __last)
N            if (__comp(*__i, *__first))
N                __first = __i;
N    }
N    return __first;
N}
N
Ntemplate <class _ForwardIterator>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
Xinline __attribute__ ((__always_inline__)) constexpr
N_ForwardIterator
Nmin_element(_ForwardIterator __first, _ForwardIterator __last)
N{
N    return _VSTD::min_element(__first, __last,
X    return std::__2::min_element(__first, __last,
N              __less<typename iterator_traits<_ForwardIterator>::value_type>());
N}
N
N// min
N
Ntemplate <class _Tp, class _Compare>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
Xinline __attribute__ ((__always_inline__)) constexpr
Nconst _Tp&
Nmin(const _Tp& __a, const _Tp& __b, _Compare __comp)
N{
N    return __comp(__b, __a) ? __b : __a;
N}
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
Xinline __attribute__ ((__always_inline__)) constexpr
Nconst _Tp&
Nmin(const _Tp& __a, const _Tp& __b)
N{
N    return _VSTD::min(__a, __b, __less<_Tp>());
X    return std::__2::min(__a, __b, __less<_Tp>());
N}
N
N#ifndef _LIBCPP_CXX03_LANG
N
Ntemplate<class _Tp, class _Compare>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
Xinline __attribute__ ((__always_inline__)) constexpr
N_Tp
Nmin(initializer_list<_Tp> __t, _Compare __comp)
N{
N    return *_VSTD::min_element(__t.begin(), __t.end(), __comp);
X    return *std::__2::min_element(__t.begin(), __t.end(), __comp);
N}
N
Ntemplate<class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
Xinline __attribute__ ((__always_inline__)) constexpr
N_Tp
Nmin(initializer_list<_Tp> __t)
N{
N    return *_VSTD::min_element(__t.begin(), __t.end(), __less<_Tp>());
X    return *std::__2::min_element(__t.begin(), __t.end(), __less<_Tp>());
N}
N
N#endif  // _LIBCPP_CXX03_LANG
N
N// max_element
N
Ntemplate <class _ForwardIterator, class _Compare>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
Xinline __attribute__ ((__always_inline__)) constexpr
N_ForwardIterator
Nmax_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
N{
N    if (__first != __last)
N    {
N        _ForwardIterator __i = __first;
N        while (++__i != __last)
N            if (__comp(*__first, *__i))
N                __first = __i;
N    }
N    return __first;
N}
N
N
Ntemplate <class _ForwardIterator>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
Xinline __attribute__ ((__always_inline__)) constexpr
N_ForwardIterator
Nmax_element(_ForwardIterator __first, _ForwardIterator __last)
N{
N    return _VSTD::max_element(__first, __last,
X    return std::__2::max_element(__first, __last,
N              __less<typename iterator_traits<_ForwardIterator>::value_type>());
N}
N
N// max
N
Ntemplate <class _Tp, class _Compare>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
Xinline __attribute__ ((__always_inline__)) constexpr
Nconst _Tp&
Nmax(const _Tp& __a, const _Tp& __b, _Compare __comp)
N{
N    return __comp(__a, __b) ? __b : __a;
N}
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
Xinline __attribute__ ((__always_inline__)) constexpr
Nconst _Tp&
Nmax(const _Tp& __a, const _Tp& __b)
N{
N    return _VSTD::max(__a, __b, __less<_Tp>());
X    return std::__2::max(__a, __b, __less<_Tp>());
N}
N
N#ifndef _LIBCPP_CXX03_LANG
N
Ntemplate<class _Tp, class _Compare>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
Xinline __attribute__ ((__always_inline__)) constexpr
N_Tp
Nmax(initializer_list<_Tp> __t, _Compare __comp)
N{
N    return *_VSTD::max_element(__t.begin(), __t.end(), __comp);
X    return *std::__2::max_element(__t.begin(), __t.end(), __comp);
N}
N
Ntemplate<class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
Xinline __attribute__ ((__always_inline__)) constexpr
N_Tp
Nmax(initializer_list<_Tp> __t)
N{
N    return *_VSTD::max_element(__t.begin(), __t.end(), __less<_Tp>());
X    return *std::__2::max_element(__t.begin(), __t.end(), __less<_Tp>());
N}
N
N#endif  // _LIBCPP_CXX03_LANG
N
N#if _LIBCPP_STD_VER > 14
X#if 14 > 14
S// clamp
Stemplate<class _Tp, class _Compare>
Sinline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
Sconst _Tp&
Sclamp(const _Tp& __v, const _Tp& __lo, const _Tp& __hi, _Compare __comp)
S{
S    _LIBCPP_ASSERT(!__comp(__hi, __lo), "Bad bounds passed to std::clamp");
S    return __comp(__v, __lo) ? __lo : __comp(__hi, __v) ? __hi : __v;
S
S}
S
Stemplate<class _Tp>
Sinline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
Sconst _Tp&
Sclamp(const _Tp& __v, const _Tp& __lo, const _Tp& __hi)
S{
S    return _VSTD::clamp(__v, __lo, __hi, __less<_Tp>());
S}
N#endif
N
N// minmax_element
N
Ntemplate <class _ForwardIterator, class _Compare>
N_LIBCPP_CONSTEXPR_AFTER_CXX11
Xconstexpr
Nstd::pair<_ForwardIterator, _ForwardIterator>
Nminmax_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
N{
N  std::pair<_ForwardIterator, _ForwardIterator> __result(__first, __first);
N  if (__first != __last)
N  {
N      if (++__first != __last)
N      {
N          if (__comp(*__first, *__result.first))
N              __result.first = __first;
N          else
N              __result.second = __first;
N          while (++__first != __last)
N          {
N              _ForwardIterator __i = __first;
N              if (++__first == __last)
N              {
N                  if (__comp(*__i, *__result.first))
N                      __result.first = __i;
N                  else if (!__comp(*__i, *__result.second))
N                      __result.second = __i;
N                  break;
N              }
N              else
N              {
N                  if (__comp(*__first, *__i))
N                  {
N                      if (__comp(*__first, *__result.first))
N                          __result.first = __first;
N                      if (!__comp(*__i, *__result.second))
N                          __result.second = __i;
N                  }
N                  else
N                  {
N                      if (__comp(*__i, *__result.first))
N                          __result.first = __i;
N                      if (!__comp(*__first, *__result.second))
N                          __result.second = __first;
N                  }
N              }
N          }
N      }
N  }
N  return __result;
N}
N
Ntemplate <class _ForwardIterator>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
Xinline __attribute__ ((__always_inline__)) constexpr
Nstd::pair<_ForwardIterator, _ForwardIterator>
Nminmax_element(_ForwardIterator __first, _ForwardIterator __last)
N{
N    return _VSTD::minmax_element(__first, __last,
X    return std::__2::minmax_element(__first, __last,
N              __less<typename iterator_traits<_ForwardIterator>::value_type>());
N}
N
N// minmax
N
Ntemplate<class _Tp, class _Compare>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
Xinline __attribute__ ((__always_inline__)) constexpr
Npair<const _Tp&, const _Tp&>
Nminmax(const _Tp& __a, const _Tp& __b, _Compare __comp)
N{
N    return __comp(__b, __a) ? pair<const _Tp&, const _Tp&>(__b, __a) :
N                              pair<const _Tp&, const _Tp&>(__a, __b);
N}
N
Ntemplate<class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
Xinline __attribute__ ((__always_inline__)) constexpr
Npair<const _Tp&, const _Tp&>
Nminmax(const _Tp& __a, const _Tp& __b)
N{
N    return _VSTD::minmax(__a, __b, __less<_Tp>());
X    return std::__2::minmax(__a, __b, __less<_Tp>());
N}
N
N#ifndef _LIBCPP_CXX03_LANG
N
Ntemplate<class _Tp, class _Compare>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
Xinline __attribute__ ((__always_inline__)) constexpr
Npair<_Tp, _Tp>
Nminmax(initializer_list<_Tp> __t, _Compare __comp)
N{
N    typedef typename initializer_list<_Tp>::const_iterator _Iter;
N    _Iter __first = __t.begin();
N    _Iter __last  = __t.end();
N    std::pair<_Tp, _Tp> __result(*__first, *__first);
N
N    ++__first;
N    if (__t.size() % 2 == 0)
N    {
N        if (__comp(*__first,  __result.first))
N            __result.first  = *__first;
N        else
N            __result.second = *__first;
N        ++__first;
N    }
N
N    while (__first != __last)
N    {
N        _Tp __prev = *__first++;
N        if (__comp(*__first, __prev)) {
N            if ( __comp(*__first, __result.first)) __result.first  = *__first;
N            if (!__comp(__prev, __result.second))  __result.second = __prev;
N            }
N        else {
N            if ( __comp(__prev, __result.first))    __result.first  = __prev;
N            if (!__comp(*__first, __result.second)) __result.second = *__first;
N            }
N
N        __first++;
N    }
N    return __result;
N}
N
Ntemplate<class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
Xinline __attribute__ ((__always_inline__)) constexpr
Npair<_Tp, _Tp>
Nminmax(initializer_list<_Tp> __t)
N{
N    return _VSTD::minmax(__t, __less<_Tp>());
X    return std::__2::minmax(__t, __less<_Tp>());
N}
N
N#endif  // _LIBCPP_CXX03_LANG
N
N// random_shuffle
N
N// __independent_bits_engine
N
Ntemplate <unsigned long long _Xp, size_t _Rp>
Nstruct __log2_imp
N{
N    static const size_t value = _Xp & ((unsigned long long)(1) << _Rp) ? _Rp
N                                           : __log2_imp<_Xp, _Rp - 1>::value;
N};
N
Ntemplate <unsigned long long _Xp>
Nstruct __log2_imp<_Xp, 0>
N{
N    static const size_t value = 0;
N};
N
Ntemplate <size_t _Rp>
Nstruct __log2_imp<0, _Rp>
N{
N    static const size_t value = _Rp + 1;
N};
N
Ntemplate <class _UIntType, _UIntType _Xp>
Nstruct __log2
N{
N    static const size_t value = __log2_imp<_Xp,
N                                         sizeof(_UIntType) * __CHAR_BIT__ - 1>::value;
X                                         sizeof(_UIntType) * 8 - 1>::value;
N};
N
Ntemplate<class _Engine, class _UIntType>
Nclass __independent_bits_engine
N{
Npublic:
N    // types
N    typedef _UIntType result_type;
N
Nprivate:
N    typedef typename _Engine::result_type _Engine_result_type;
N    typedef typename conditional
N        <
N            sizeof(_Engine_result_type) <= sizeof(result_type),
N                result_type,
N                _Engine_result_type
N        >::type _Working_result_type;
N
N    _Engine& __e_;
N    size_t __w_;
N    size_t __w0_;
N    size_t __n_;
N    size_t __n0_;
N    _Working_result_type __y0_;
N    _Working_result_type __y1_;
N    _Engine_result_type __mask0_;
N    _Engine_result_type __mask1_;
N
N#ifdef _LIBCPP_CXX03_LANG
S    static const _Working_result_type _Rp = _Engine::_Max - _Engine::_Min
S                                          + _Working_result_type(1);
N#else
N    static _LIBCPP_CONSTEXPR const _Working_result_type _Rp = _Engine::max() - _Engine::min()
X    static constexpr const _Working_result_type _Rp = _Engine::max() - _Engine::min()
N                                                      + _Working_result_type(1);
N#endif
N    static _LIBCPP_CONSTEXPR const size_t __m = __log2<_Working_result_type, _Rp>::value;
X    static constexpr const size_t __m = __log2<_Working_result_type, _Rp>::value;
N    static _LIBCPP_CONSTEXPR const size_t _WDt = numeric_limits<_Working_result_type>::digits;
X    static constexpr const size_t _WDt = numeric_limits<_Working_result_type>::digits;
N    static _LIBCPP_CONSTEXPR const size_t _EDt = numeric_limits<_Engine_result_type>::digits;
X    static constexpr const size_t _EDt = numeric_limits<_Engine_result_type>::digits;
N
Npublic:
N    // constructors and seeding functions
N    __independent_bits_engine(_Engine& __e, size_t __w);
N
N    // generating functions
N    result_type operator()() {return __eval(integral_constant<bool, _Rp != 0>());}
N
Nprivate:
N    result_type __eval(false_type);
N    result_type __eval(true_type);
N};
N
Ntemplate<class _Engine, class _UIntType>
N__independent_bits_engine<_Engine, _UIntType>
N    ::__independent_bits_engine(_Engine& __e, size_t __w)
N        : __e_(__e),
N          __w_(__w)
N{
N    __n_ = __w_ / __m + (__w_ % __m != 0);
N    __w0_ = __w_ / __n_;
N    if (_Rp == 0)
N        __y0_ = _Rp;
N    else if (__w0_ < _WDt)
N        __y0_ = (_Rp >> __w0_) << __w0_;
N    else
N        __y0_ = 0;
N    if (_Rp - __y0_ > __y0_ / __n_)
N    {
N        ++__n_;
N        __w0_ = __w_ / __n_;
N        if (__w0_ < _WDt)
N            __y0_ = (_Rp >> __w0_) << __w0_;
N        else
N            __y0_ = 0;
N    }
N    __n0_ = __n_ - __w_ % __n_;
N    if (__w0_ < _WDt - 1)
N        __y1_ = (_Rp >> (__w0_ + 1)) << (__w0_ + 1);
N    else
N        __y1_ = 0;
N    __mask0_ = __w0_ > 0 ? _Engine_result_type(~0) >> (_EDt - __w0_) :
N                          _Engine_result_type(0);
N    __mask1_ = __w0_ < _EDt - 1 ?
N                               _Engine_result_type(~0) >> (_EDt - (__w0_ + 1)) :
N                               _Engine_result_type(~0);
N}
N
Ntemplate<class _Engine, class _UIntType>
Ninline
N_UIntType
N__independent_bits_engine<_Engine, _UIntType>::__eval(false_type)
N{
N    return static_cast<result_type>(__e_() & __mask0_);
N}
N
Ntemplate<class _Engine, class _UIntType>
N_UIntType
N__independent_bits_engine<_Engine, _UIntType>::__eval(true_type)
N{
N    const size_t _WRt = numeric_limits<result_type>::digits;
N    result_type _Sp = 0;
N    for (size_t __k = 0; __k < __n0_; ++__k)
N    {
N        _Engine_result_type __u;
N        do
N        {
N            __u = __e_() - _Engine::min();
N        } while (__u >= __y0_);
N        if (__w0_ < _WRt)
N            _Sp <<= __w0_;
N        else
N            _Sp = 0;
N        _Sp += __u & __mask0_;
N    }
N    for (size_t __k = __n0_; __k < __n_; ++__k)
N    {
N        _Engine_result_type __u;
N        do
N        {
N            __u = __e_() - _Engine::min();
N        } while (__u >= __y1_);
N        if (__w0_ < _WRt - 1)
N            _Sp <<= __w0_ + 1;
N        else
N            _Sp = 0;
N        _Sp += __u & __mask1_;
N    }
N    return _Sp;
N}
N
N// uniform_int_distribution
N
Ntemplate<class _IntType = int>
Nclass uniform_int_distribution
N{
Npublic:
N    // types
N    typedef _IntType result_type;
N
N    class param_type
N    {
N        result_type __a_;
N        result_type __b_;
N    public:
N        typedef uniform_int_distribution distribution_type;
N
N        explicit param_type(result_type __a = 0,
N                            result_type __b = numeric_limits<result_type>::max())
N            : __a_(__a), __b_(__b) {}
N
N        result_type a() const {return __a_;}
N        result_type b() const {return __b_;}
N
N        friend bool operator==(const param_type& __x, const param_type& __y)
N            {return __x.__a_ == __y.__a_ && __x.__b_ == __y.__b_;}
N        friend bool operator!=(const param_type& __x, const param_type& __y)
N            {return !(__x == __y);}
N    };
N
Nprivate:
N    param_type __p_;
N
Npublic:
N    // constructors and reset functions
N    explicit uniform_int_distribution(result_type __a = 0,
N                                      result_type __b = numeric_limits<result_type>::max())
N        : __p_(param_type(__a, __b)) {}
N    explicit uniform_int_distribution(const param_type& __p) : __p_(__p) {}
N    void reset() {}
N
N    // generating functions
N    template<class _URNG> result_type operator()(_URNG& __g)
N        {return (*this)(__g, __p_);}
N    template<class _URNG> result_type operator()(_URNG& __g, const param_type& __p);
N
N    // property functions
N    result_type a() const {return __p_.a();}
N    result_type b() const {return __p_.b();}
N
N    param_type param() const {return __p_;}
N    void param(const param_type& __p) {__p_ = __p;}
N
N    result_type min() const {return a();}
N    result_type max() const {return b();}
N
N    friend bool operator==(const uniform_int_distribution& __x,
N                           const uniform_int_distribution& __y)
N        {return __x.__p_ == __y.__p_;}
N    friend bool operator!=(const uniform_int_distribution& __x,
N                           const uniform_int_distribution& __y)
N            {return !(__x == __y);}
N};
N
Ntemplate<class _IntType>
Ntemplate<class _URNG>
Ntypename uniform_int_distribution<_IntType>::result_type
Nuniform_int_distribution<_IntType>::operator()(_URNG& __g, const param_type& __p)
N{
N    typedef typename conditional<sizeof(result_type) <= sizeof(uint32_t),
N                                            uint32_t, uint64_t>::type _UIntType;
N    const _UIntType _Rp = __p.b() - __p.a() + _UIntType(1);
N    if (_Rp == 1)
N        return __p.a();
N    const size_t _Dt = numeric_limits<_UIntType>::digits;
N    typedef __independent_bits_engine<_URNG, _UIntType> _Eng;
N    if (_Rp == 0)
N        return static_cast<result_type>(_Eng(__g, _Dt)());
N    size_t __w = _Dt - __clz(_Rp) - 1;
N    if ((_Rp & (std::numeric_limits<_UIntType>::max() >> (_Dt - __w))) != 0)
N        ++__w;
N    _Eng __e(__g, __w);
N    _UIntType __u;
N    do
N    {
N        __u = __e();
N    } while (__u >= _Rp);
N    return static_cast<result_type>(__u + __p.a());
N}
N
N#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_RANDOM_SHUFFLE) \
N  || defined(_LIBCPP_BUILDING_LIBRARY)
X#if 14 <= 14 || 0L   || 0L
Nclass _LIBCPP_TYPE_VIS __rs_default;
Xclass  __rs_default;
N
N_LIBCPP_FUNC_VIS __rs_default __rs_get();
X __rs_default __rs_get();
N
Nclass _LIBCPP_TYPE_VIS __rs_default
Xclass  __rs_default
N{
N    static _DATA_ACCESS unsigned __c_;
X    static  unsigned __c_;
N
N    __rs_default();
Npublic:
N    typedef uint_fast32_t result_type;
N
N    static const result_type _Min = 0;
N    static const result_type _Max = 0xFFFFFFFF;
N
N    __rs_default(const __rs_default&);
N    ~__rs_default();
N
N    result_type operator()();
N
N    static _LIBCPP_CONSTEXPR result_type min() {return _Min;}
X    static constexpr result_type min() {return _Min;}
N    static _LIBCPP_CONSTEXPR result_type max() {return _Max;}
X    static constexpr result_type max() {return _Max;}
N
N    friend _LIBCPP_FUNC_VIS __rs_default __rs_get();
X    friend  __rs_default __rs_get();
N};
N
N_LIBCPP_FUNC_VIS __rs_default __rs_get();
X __rs_default __rs_get();
N
Ntemplate <class _RandomAccessIterator>
Nvoid
Nrandom_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)
N{
N    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
N    typedef uniform_int_distribution<ptrdiff_t> _Dp;
N    typedef typename _Dp::param_type _Pp;
N    difference_type __d = __last - __first;
N    if (__d > 1)
N    {
N        _Dp __uid;
N        __rs_default __g = __rs_get();
N        for (--__last, --__d; __first < __last; ++__first, --__d)
N        {
N            difference_type __i = __uid(__g, _Pp(0, __d));
N            if (__i != difference_type(0))
N                swap(*__first, *(__first + __i));
N        }
N    }
N}
N
Ntemplate <class _RandomAccessIterator, class _RandomNumberGenerator>
Nvoid
Nrandom_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,
N#ifndef _LIBCPP_CXX03_LANG
N               _RandomNumberGenerator&& __rand)
N#else
S               _RandomNumberGenerator& __rand)
N#endif
N{
N    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
N    difference_type __d = __last - __first;
N    if (__d > 1)
N    {
N        for (--__last; __first < __last; ++__first, --__d)
N        {
N            difference_type __i = __rand(__d);
N            swap(*__first, *(__first + __i));
N        }
N    }
N}
N#endif
N
Ntemplate <class _PopulationIterator, class _SampleIterator, class _Distance,
N          class _UniformRandomNumberGenerator>
N_LIBCPP_INLINE_VISIBILITY
X__attribute__ ((__always_inline__))
N_SampleIterator __sample(_PopulationIterator __first,
N                         _PopulationIterator __last, _SampleIterator __output,
N                         _Distance __n,
N                         _UniformRandomNumberGenerator & __g,
N                         input_iterator_tag) {
N
N  _Distance __k = 0;
N  for (; __first != __last && __k < __n; ++__first, (void)++__k)
N    __output[__k] = *__first;
N  _Distance __sz = __k;
N  for (; __first != __last; ++__first, (void)++__k) {
N    _Distance __r = _VSTD::uniform_int_distribution<_Distance>(0, __k)(__g);
X    _Distance __r = std::__2::uniform_int_distribution<_Distance>(0, __k)(__g);
N    if (__r < __sz)
N      __output[__r] = *__first;
N  }
N  return __output + _VSTD::min(__n, __k);
X  return __output + std::__2::min(__n, __k);
N}
N
Ntemplate <class _PopulationIterator, class _SampleIterator, class _Distance,
N          class _UniformRandomNumberGenerator>
N_LIBCPP_INLINE_VISIBILITY
X__attribute__ ((__always_inline__))
N_SampleIterator __sample(_PopulationIterator __first,
N                         _PopulationIterator __last, _SampleIterator __output,
N                         _Distance __n,
N                         _UniformRandomNumberGenerator& __g,
N                         forward_iterator_tag) {
N  _Distance __unsampled_sz = _VSTD::distance(__first, __last);
X  _Distance __unsampled_sz = std::__2::distance(__first, __last);
N  for (__n = _VSTD::min(__n, __unsampled_sz); __n != 0; ++__first) {
X  for (__n = std::__2::min(__n, __unsampled_sz); __n != 0; ++__first) {
N    _Distance __r =
N        _VSTD::uniform_int_distribution<_Distance>(0, --__unsampled_sz)(__g);
X        std::__2::uniform_int_distribution<_Distance>(0, --__unsampled_sz)(__g);
N    if (__r < __n) {
N      *__output++ = *__first;
N      --__n;
N    }
N  }
N  return __output;
N}
N
Ntemplate <class _PopulationIterator, class _SampleIterator, class _Distance,
N          class _UniformRandomNumberGenerator>
N_LIBCPP_INLINE_VISIBILITY
X__attribute__ ((__always_inline__))
N_SampleIterator __sample(_PopulationIterator __first,
N                         _PopulationIterator __last, _SampleIterator __output,
N                         _Distance __n, _UniformRandomNumberGenerator& __g) {
N  typedef typename iterator_traits<_PopulationIterator>::iterator_category
N        _PopCategory;
N  typedef typename iterator_traits<_PopulationIterator>::difference_type
N        _Difference;
N  static_assert(__is_forward_iterator<_PopulationIterator>::value ||
N                __is_random_access_iterator<_SampleIterator>::value,
N                "SampleIterator must meet the requirements of RandomAccessIterator");
N  typedef typename common_type<_Distance, _Difference>::type _CommonType;
N  _LIBCPP_ASSERT(__n >= 0, "N must be a positive number.");
X  ((void)0);
N  return _VSTD::__sample(
X  return std::__2::__sample(
N      __first, __last, __output, _CommonType(__n),
N      __g, _PopCategory());
N}
N
N#if _LIBCPP_STD_VER > 14
X#if 14 > 14
Stemplate <class _PopulationIterator, class _SampleIterator, class _Distance,
S          class _UniformRandomNumberGenerator>
Sinline _LIBCPP_INLINE_VISIBILITY
S_SampleIterator sample(_PopulationIterator __first,
S                       _PopulationIterator __last, _SampleIterator __output,
S                       _Distance __n, _UniformRandomNumberGenerator&& __g) {
S    return _VSTD::__sample(__first, __last, __output, __n, __g);
S}
N#endif // _LIBCPP_STD_VER > 14
N
Ntemplate<class _RandomAccessIterator, class _UniformRandomNumberGenerator>
N    void shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,
N#ifndef _LIBCPP_CXX03_LANG
N                 _UniformRandomNumberGenerator&& __g)
N#else
S                 _UniformRandomNumberGenerator& __g)
N#endif
N{
N    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
N    typedef uniform_int_distribution<ptrdiff_t> _Dp;
N    typedef typename _Dp::param_type _Pp;
N    difference_type __d = __last - __first;
N    if (__d > 1)
N    {
N        _Dp __uid;
N        for (--__last, --__d; __first < __last; ++__first, --__d)
N        {
N            difference_type __i = __uid(__g, _Pp(0, __d));
N            if (__i != difference_type(0))
N                swap(*__first, *(__first + __i));
N        }
N    }
N}
N
Ntemplate <class _InputIterator, class _Predicate>
Nbool
Nis_partitioned(_InputIterator __first, _InputIterator __last, _Predicate __pred)
N{
N    for (; __first != __last; ++__first)
N        if (!__pred(*__first))
N            break;
N    if ( __first == __last )
N        return true;
N    ++__first;
N    for (; __first != __last; ++__first)
N        if (__pred(*__first))
N            return false;
N    return true;
N}
N
N// partition
N
Ntemplate <class _Predicate, class _ForwardIterator>
N_ForwardIterator
N__partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, forward_iterator_tag)
N{
N    while (true)
N    {
N        if (__first == __last)
N            return __first;
N        if (!__pred(*__first))
N            break;
N        ++__first;
N    }
N    for (_ForwardIterator __p = __first; ++__p != __last;)
N    {
N        if (__pred(*__p))
N        {
N            swap(*__first, *__p);
N            ++__first;
N        }
N    }
N    return __first;
N}
N
Ntemplate <class _Predicate, class _BidirectionalIterator>
N_BidirectionalIterator
N__partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,
N            bidirectional_iterator_tag)
N{
N    while (true)
N    {
N        while (true)
N        {
N            if (__first == __last)
N                return __first;
N            if (!__pred(*__first))
N                break;
N            ++__first;
N        }
N        do
N        {
N            if (__first == --__last)
N                return __first;
N        } while (!__pred(*__last));
N        swap(*__first, *__last);
N        ++__first;
N    }
N}
N
Ntemplate <class _ForwardIterator, class _Predicate>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_ForwardIterator
Npartition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
N{
N    return _VSTD::__partition<typename add_lvalue_reference<_Predicate>::type>
X    return std::__2::__partition<typename add_lvalue_reference<_Predicate>::type>
N                            (__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());
N}
N
N// partition_copy
N
Ntemplate <class _InputIterator, class _OutputIterator1,
N          class _OutputIterator2, class _Predicate>
Npair<_OutputIterator1, _OutputIterator2>
Npartition_copy(_InputIterator __first, _InputIterator __last,
N               _OutputIterator1 __out_true, _OutputIterator2 __out_false,
N               _Predicate __pred)
N{
N    for (; __first != __last; ++__first)
N    {
N        if (__pred(*__first))
N        {
N            *__out_true = *__first;
N            ++__out_true;
N        }
N        else
N        {
N            *__out_false = *__first;
N            ++__out_false;
N        }
N    }
N    return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);
N}
N
N// partition_point
N
Ntemplate<class _ForwardIterator, class _Predicate>
N_ForwardIterator
Npartition_point(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
N{
N    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
N    difference_type __len = _VSTD::distance(__first, __last);
X    difference_type __len = std::__2::distance(__first, __last);
N    while (__len != 0)
N    {
N        difference_type __l2 = __len / 2;
N        _ForwardIterator __m = __first;
N        _VSTD::advance(__m, __l2);
X        std::__2::advance(__m, __l2);
N        if (__pred(*__m))
N        {
N            __first = ++__m;
N            __len -= __l2 + 1;
N        }
N        else
N            __len = __l2;
N    }
N    return __first;
N}
N
N// stable_partition
N
Ntemplate <class _Predicate, class _ForwardIterator, class _Distance, class _Pair>
N_ForwardIterator
N__stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,
N                   _Distance __len, _Pair __p, forward_iterator_tag __fit)
N{
N    // *__first is known to be false
N    // __len >= 1
N    if (__len == 1)
N        return __first;
N    if (__len == 2)
N    {
N        _ForwardIterator __m = __first;
N        if (__pred(*++__m))
N        {
N            swap(*__first, *__m);
N            return __m;
N        }
N        return __first;
N    }
N    if (__len <= __p.second)
N    {   // The buffer is big enough to use
N        typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
N        __destruct_n __d(0);
N        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);
N        // Move the falses into the temporary buffer, and the trues to the front of the line
N        // Update __first to always point to the end of the trues
N        value_type* __t = __p.first;
N        ::new(__t) value_type(_VSTD::move(*__first));
X        ::new(__t) value_type(std::__2::move(*__first));
N        __d.__incr((value_type*)0);
N        ++__t;
N        _ForwardIterator __i = __first;
N        while (++__i != __last)
N        {
N            if (__pred(*__i))
N            {
N                *__first = _VSTD::move(*__i);
X                *__first = std::__2::move(*__i);
N                ++__first;
N            }
N            else
N            {
N                ::new(__t) value_type(_VSTD::move(*__i));
X                ::new(__t) value_type(std::__2::move(*__i));
N                __d.__incr((value_type*)0);
N                ++__t;
N            }
N        }
N        // All trues now at start of range, all falses in buffer
N        // Move falses back into range, but don't mess up __first which points to first false
N        __i = __first;
N        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, ++__i)
N            *__i = _VSTD::move(*__t2);
X            *__i = std::__2::move(*__t2);
N        // __h destructs moved-from values out of the temp buffer, but doesn't deallocate buffer
N        return __first;
N    }
N    // Else not enough buffer, do in place
N    // __len >= 3
N    _ForwardIterator __m = __first;
N    _Distance __len2 = __len / 2;  // __len2 >= 2
N    _VSTD::advance(__m, __len2);
X    std::__2::advance(__m, __len2);
N    // recurse on [__first, __m), *__first know to be false
N    // F?????????????????
N    // f       m         l
N    typedef typename add_lvalue_reference<_Predicate>::type _PredRef;
N    _ForwardIterator __first_false = __stable_partition<_PredRef>(__first, __m, __pred, __len2, __p, __fit);
N    // TTTFFFFF??????????
N    // f  ff   m         l
N    // recurse on [__m, __last], except increase __m until *(__m) is false, *__last know to be true
N    _ForwardIterator __m1 = __m;
N    _ForwardIterator __second_false = __last;
N    _Distance __len_half = __len - __len2;
N    while (__pred(*__m1))
N    {
N        if (++__m1 == __last)
N            goto __second_half_done;
N        --__len_half;
N    }
N    // TTTFFFFFTTTF??????
N    // f  ff   m  m1     l
N    __second_false = __stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __fit);
N__second_half_done:
N    // TTTFFFFFTTTTTFFFFF
N    // f  ff   m    sf   l
N    return _VSTD::rotate(__first_false, __m, __second_false);
X    return std::__2::rotate(__first_false, __m, __second_false);
N    // TTTTTTTTFFFFFFFFFF
N    //         |
N}
N
Nstruct __return_temporary_buffer
N{
N    template <class _Tp>
N    _LIBCPP_INLINE_VISIBILITY void operator()(_Tp* __p) const {_VSTD::return_temporary_buffer(__p);}
X    __attribute__ ((__always_inline__)) void operator()(_Tp* __p) const {std::__2::return_temporary_buffer(__p);}
N};
N
Ntemplate <class _Predicate, class _ForwardIterator>
N_ForwardIterator
N__stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,
N                   forward_iterator_tag)
N{
N    const unsigned __alloc_limit = 3;  // might want to make this a function of trivial assignment
N    // Either prove all true and return __first or point to first false
N    while (true)
N    {
N        if (__first == __last)
N            return __first;
N        if (!__pred(*__first))
N            break;
N        ++__first;
N    }
N    // We now have a reduced range [__first, __last)
N    // *__first is known to be false
N    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
N    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
N    difference_type __len = _VSTD::distance(__first, __last);
X    difference_type __len = std::__2::distance(__first, __last);
N    pair<value_type*, ptrdiff_t> __p(0, 0);
N    unique_ptr<value_type, __return_temporary_buffer> __h;
N    if (__len >= __alloc_limit)
N    {
N        __p = _VSTD::get_temporary_buffer<value_type>(__len);
X        __p = std::__2::get_temporary_buffer<value_type>(__len);
N        __h.reset(__p.first);
N    }
N    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>
N                             (__first, __last, __pred, __len, __p, forward_iterator_tag());
N}
N
Ntemplate <class _Predicate, class _BidirectionalIterator, class _Distance, class _Pair>
N_BidirectionalIterator
N__stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,
N                   _Distance __len, _Pair __p, bidirectional_iterator_tag __bit)
N{
N    // *__first is known to be false
N    // *__last is known to be true
N    // __len >= 2
N    if (__len == 2)
N    {
N        swap(*__first, *__last);
N        return __last;
N    }
N    if (__len == 3)
N    {
N        _BidirectionalIterator __m = __first;
N        if (__pred(*++__m))
N        {
N            swap(*__first, *__m);
N            swap(*__m, *__last);
N            return __last;
N        }
N        swap(*__m, *__last);
N        swap(*__first, *__m);
N        return __m;
N    }
N    if (__len <= __p.second)
N    {   // The buffer is big enough to use
N        typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
N        __destruct_n __d(0);
N        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);
N        // Move the falses into the temporary buffer, and the trues to the front of the line
N        // Update __first to always point to the end of the trues
N        value_type* __t = __p.first;
N        ::new(__t) value_type(_VSTD::move(*__first));
X        ::new(__t) value_type(std::__2::move(*__first));
N        __d.__incr((value_type*)0);
N        ++__t;
N        _BidirectionalIterator __i = __first;
N        while (++__i != __last)
N        {
N            if (__pred(*__i))
N            {
N                *__first = _VSTD::move(*__i);
X                *__first = std::__2::move(*__i);
N                ++__first;
N            }
N            else
N            {
N                ::new(__t) value_type(_VSTD::move(*__i));
X                ::new(__t) value_type(std::__2::move(*__i));
N                __d.__incr((value_type*)0);
N                ++__t;
N            }
N        }
N        // move *__last, known to be true
N        *__first = _VSTD::move(*__i);
X        *__first = std::__2::move(*__i);
N        __i = ++__first;
N        // All trues now at start of range, all falses in buffer
N        // Move falses back into range, but don't mess up __first which points to first false
N        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, ++__i)
N            *__i = _VSTD::move(*__t2);
X            *__i = std::__2::move(*__t2);
N        // __h destructs moved-from values out of the temp buffer, but doesn't deallocate buffer
N        return __first;
N    }
N    // Else not enough buffer, do in place
N    // __len >= 4
N    _BidirectionalIterator __m = __first;
N    _Distance __len2 = __len / 2;  // __len2 >= 2
N    _VSTD::advance(__m, __len2);
X    std::__2::advance(__m, __len2);
N    // recurse on [__first, __m-1], except reduce __m-1 until *(__m-1) is true, *__first know to be false
N    // F????????????????T
N    // f       m        l
N    _BidirectionalIterator __m1 = __m;
N    _BidirectionalIterator __first_false = __first;
N    _Distance __len_half = __len2;
N    while (!__pred(*--__m1))
N    {
N        if (__m1 == __first)
N            goto __first_half_done;
N        --__len_half;
N    }
N    // F???TFFF?????????T
N    // f   m1  m        l
N    typedef typename add_lvalue_reference<_Predicate>::type _PredRef;
N    __first_false = __stable_partition<_PredRef>(__first, __m1, __pred, __len_half, __p, __bit);
N__first_half_done:
N    // TTTFFFFF?????????T
N    // f  ff   m        l
N    // recurse on [__m, __last], except increase __m until *(__m) is false, *__last know to be true
N    __m1 = __m;
N    _BidirectionalIterator __second_false = __last;
N    ++__second_false;
N    __len_half = __len - __len2;
N    while (__pred(*__m1))
N    {
N        if (++__m1 == __last)
N            goto __second_half_done;
N        --__len_half;
N    }
N    // TTTFFFFFTTTF?????T
N    // f  ff   m  m1    l
N    __second_false = __stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __bit);
N__second_half_done:
N    // TTTFFFFFTTTTTFFFFF
N    // f  ff   m    sf  l
N    return _VSTD::rotate(__first_false, __m, __second_false);
X    return std::__2::rotate(__first_false, __m, __second_false);
N    // TTTTTTTTFFFFFFFFFF
N    //         |
N}
N
Ntemplate <class _Predicate, class _BidirectionalIterator>
N_BidirectionalIterator
N__stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,
N                   bidirectional_iterator_tag)
N{
N    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;
N    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
N    const difference_type __alloc_limit = 4;  // might want to make this a function of trivial assignment
N    // Either prove all true and return __first or point to first false
N    while (true)
N    {
N        if (__first == __last)
N            return __first;
N        if (!__pred(*__first))
N            break;
N        ++__first;
N    }
N    // __first points to first false, everything prior to __first is already set.
N    // Either prove [__first, __last) is all false and return __first, or point __last to last true
N    do
N    {
N        if (__first == --__last)
N            return __first;
N    } while (!__pred(*__last));
N    // We now have a reduced range [__first, __last]
N    // *__first is known to be false
N    // *__last is known to be true
N    // __len >= 2
N    difference_type __len = _VSTD::distance(__first, __last) + 1;
X    difference_type __len = std::__2::distance(__first, __last) + 1;
N    pair<value_type*, ptrdiff_t> __p(0, 0);
N    unique_ptr<value_type, __return_temporary_buffer> __h;
N    if (__len >= __alloc_limit)
N    {
N        __p = _VSTD::get_temporary_buffer<value_type>(__len);
X        __p = std::__2::get_temporary_buffer<value_type>(__len);
N        __h.reset(__p.first);
N    }
N    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>
N                             (__first, __last, __pred, __len, __p, bidirectional_iterator_tag());
N}
N
Ntemplate <class _ForwardIterator, class _Predicate>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_ForwardIterator
Nstable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
N{
N    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>
N                             (__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());
N}
N
N// is_sorted_until
N
Ntemplate <class _ForwardIterator, class _Compare>
N_ForwardIterator
Nis_sorted_until(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
N{
N    if (__first != __last)
N    {
N        _ForwardIterator __i = __first;
N        while (++__i != __last)
N        {
N            if (__comp(*__i, *__first))
N                return __i;
N            __first = __i;
N        }
N    }
N    return __last;
N}
N
Ntemplate<class _ForwardIterator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_ForwardIterator
Nis_sorted_until(_ForwardIterator __first, _ForwardIterator __last)
N{
N    return _VSTD::is_sorted_until(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());
X    return std::__2::is_sorted_until(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());
N}
N
N// is_sorted
N
Ntemplate <class _ForwardIterator, class _Compare>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Nis_sorted(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
N{
N    return _VSTD::is_sorted_until(__first, __last, __comp) == __last;
X    return std::__2::is_sorted_until(__first, __last, __comp) == __last;
N}
N
Ntemplate<class _ForwardIterator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Nis_sorted(_ForwardIterator __first, _ForwardIterator __last)
N{
N    return _VSTD::is_sorted(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());
X    return std::__2::is_sorted(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());
N}
N
N// sort
N
N// stable, 2-3 compares, 0-2 swaps
N
Ntemplate <class _Compare, class _ForwardIterator>
Nunsigned
N__sort3(_ForwardIterator __x, _ForwardIterator __y, _ForwardIterator __z, _Compare __c)
N{
N    unsigned __r = 0;
N    if (!__c(*__y, *__x))          // if x <= y
N    {
N        if (!__c(*__z, *__y))      // if y <= z
N            return __r;            // x <= y && y <= z
N                                   // x <= y && y > z
N        swap(*__y, *__z);          // x <= z && y < z
N        __r = 1;
N        if (__c(*__y, *__x))       // if x > y
N        {
N            swap(*__x, *__y);      // x < y && y <= z
N            __r = 2;
N        }
N        return __r;                // x <= y && y < z
N    }
N    if (__c(*__z, *__y))           // x > y, if y > z
N    {
N        swap(*__x, *__z);          // x < y && y < z
N        __r = 1;
N        return __r;
N    }
N    swap(*__x, *__y);              // x > y && y <= z
N    __r = 1;                       // x < y && x <= z
N    if (__c(*__z, *__y))           // if y > z
N    {
N        swap(*__y, *__z);          // x <= y && y < z
N        __r = 2;
N    }
N    return __r;
N}                                  // x <= y && y <= z
N
N// stable, 3-6 compares, 0-5 swaps
N
Ntemplate <class _Compare, class _ForwardIterator>
Nunsigned
N__sort4(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,
N            _ForwardIterator __x4, _Compare __c)
N{
N    unsigned __r = __sort3<_Compare>(__x1, __x2, __x3, __c);
N    if (__c(*__x4, *__x3))
N    {
N        swap(*__x3, *__x4);
N        ++__r;
N        if (__c(*__x3, *__x2))
N        {
N            swap(*__x2, *__x3);
N            ++__r;
N            if (__c(*__x2, *__x1))
N            {
N                swap(*__x1, *__x2);
N                ++__r;
N            }
N        }
N    }
N    return __r;
N}
N
N// stable, 4-10 compares, 0-9 swaps
N
Ntemplate <class _Compare, class _ForwardIterator>
Nunsigned
N__sort5(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,
N            _ForwardIterator __x4, _ForwardIterator __x5, _Compare __c)
N{
N    unsigned __r = __sort4<_Compare>(__x1, __x2, __x3, __x4, __c);
N    if (__c(*__x5, *__x4))
N    {
N        swap(*__x4, *__x5);
N        ++__r;
N        if (__c(*__x4, *__x3))
N        {
N            swap(*__x3, *__x4);
N            ++__r;
N            if (__c(*__x3, *__x2))
N            {
N                swap(*__x2, *__x3);
N                ++__r;
N                if (__c(*__x2, *__x1))
N                {
N                    swap(*__x1, *__x2);
N                    ++__r;
N                }
N            }
N        }
N    }
N    return __r;
N}
N
N// Assumes size > 0
Ntemplate <class _Compare, class _BirdirectionalIterator>
Nvoid
N__selection_sort(_BirdirectionalIterator __first, _BirdirectionalIterator __last, _Compare __comp)
N{
N    _BirdirectionalIterator __lm1 = __last;
N    for (--__lm1; __first != __lm1; ++__first)
N    {
N        _BirdirectionalIterator __i = _VSTD::min_element<_BirdirectionalIterator,
X        _BirdirectionalIterator __i = std::__2::min_element<_BirdirectionalIterator,
N                                                        typename add_lvalue_reference<_Compare>::type>
N                                                       (__first, __last, __comp);
N        if (__i != __first)
N            swap(*__first, *__i);
N    }
N}
N
Ntemplate <class _Compare, class _BirdirectionalIterator>
Nvoid
N__insertion_sort(_BirdirectionalIterator __first, _BirdirectionalIterator __last, _Compare __comp)
N{
N    typedef typename iterator_traits<_BirdirectionalIterator>::value_type value_type;
N    if (__first != __last)
N    {
N        _BirdirectionalIterator __i = __first;
N        for (++__i; __i != __last; ++__i)
N        {
N            _BirdirectionalIterator __j = __i;
N            value_type __t(_VSTD::move(*__j));
X            value_type __t(std::__2::move(*__j));
N            for (_BirdirectionalIterator __k = __i; __k != __first && __comp(__t,  *--__k); --__j)
N                *__j = _VSTD::move(*__k);
X                *__j = std::__2::move(*__k);
N            *__j = _VSTD::move(__t);
X            *__j = std::__2::move(__t);
N        }
N    }
N}
N
Ntemplate <class _Compare, class _RandomAccessIterator>
Nvoid
N__insertion_sort_3(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
N{
N    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
N    _RandomAccessIterator __j = __first+2;
N    __sort3<_Compare>(__first, __first+1, __j, __comp);
N    for (_RandomAccessIterator __i = __j+1; __i != __last; ++__i)
N    {
N        if (__comp(*__i, *__j))
N        {
N            value_type __t(_VSTD::move(*__i));
X            value_type __t(std::__2::move(*__i));
N            _RandomAccessIterator __k = __j;
N            __j = __i;
N            do
N            {
N                *__j = _VSTD::move(*__k);
X                *__j = std::__2::move(*__k);
N                __j = __k;
N            } while (__j != __first && __comp(__t, *--__k));
N            *__j = _VSTD::move(__t);
X            *__j = std::__2::move(__t);
N        }
N        __j = __i;
N    }
N}
N
Ntemplate <class _Compare, class _RandomAccessIterator>
Nbool
N__insertion_sort_incomplete(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
N{
N    switch (__last - __first)
N    {
N    case 0:
N    case 1:
N        return true;
N    case 2:
N        if (__comp(*--__last, *__first))
N            swap(*__first, *__last);
N        return true;
N    case 3:
N        _VSTD::__sort3<_Compare>(__first, __first+1, --__last, __comp);
X        std::__2::__sort3<_Compare>(__first, __first+1, --__last, __comp);
N        return true;
N    case 4:
N        _VSTD::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);
X        std::__2::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);
N        return true;
N    case 5:
N        _VSTD::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);
X        std::__2::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);
N        return true;
N    }
N    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
N    _RandomAccessIterator __j = __first+2;
N    __sort3<_Compare>(__first, __first+1, __j, __comp);
N    const unsigned __limit = 8;
N    unsigned __count = 0;
N    for (_RandomAccessIterator __i = __j+1; __i != __last; ++__i)
N    {
N        if (__comp(*__i, *__j))
N        {
N            value_type __t(_VSTD::move(*__i));
X            value_type __t(std::__2::move(*__i));
N            _RandomAccessIterator __k = __j;
N            __j = __i;
N            do
N            {
N                *__j = _VSTD::move(*__k);
X                *__j = std::__2::move(*__k);
N                __j = __k;
N            } while (__j != __first && __comp(__t, *--__k));
N            *__j = _VSTD::move(__t);
X            *__j = std::__2::move(__t);
N            if (++__count == __limit)
N                return ++__i == __last;
N        }
N        __j = __i;
N    }
N    return true;
N}
N
Ntemplate <class _Compare, class _BirdirectionalIterator>
Nvoid
N__insertion_sort_move(_BirdirectionalIterator __first1, _BirdirectionalIterator __last1,
N                      typename iterator_traits<_BirdirectionalIterator>::value_type* __first2, _Compare __comp)
N{
N    typedef typename iterator_traits<_BirdirectionalIterator>::value_type value_type;
N    if (__first1 != __last1)
N    {
N        __destruct_n __d(0);
N        unique_ptr<value_type, __destruct_n&> __h(__first2, __d);
N        value_type* __last2 = __first2;
N        ::new(__last2) value_type(_VSTD::move(*__first1));
X        ::new(__last2) value_type(std::__2::move(*__first1));
N        __d.__incr((value_type*)0);
N        for (++__last2; ++__first1 != __last1; ++__last2)
N        {
N            value_type* __j2 = __last2;
N            value_type* __i2 = __j2;
N            if (__comp(*__first1, *--__i2))
N            {
N                ::new(__j2) value_type(_VSTD::move(*__i2));
X                ::new(__j2) value_type(std::__2::move(*__i2));
N                __d.__incr((value_type*)0);
N                for (--__j2; __i2 != __first2 && __comp(*__first1,  *--__i2); --__j2)
N                    *__j2 = _VSTD::move(*__i2);
X                    *__j2 = std::__2::move(*__i2);
N                *__j2 = _VSTD::move(*__first1);
X                *__j2 = std::__2::move(*__first1);
N            }
N            else
N            {
N                ::new(__j2) value_type(_VSTD::move(*__first1));
X                ::new(__j2) value_type(std::__2::move(*__first1));
N                __d.__incr((value_type*)0);
N            }
N        }
N        __h.release();
N    }
N}
N
Ntemplate <class _Compare, class _RandomAccessIterator>
Nvoid
N__sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
N{
N    // _Compare is known to be a reference type
N    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
N    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
N    const difference_type __limit = is_trivially_copy_constructible<value_type>::value &&
N                                    is_trivially_copy_assignable<value_type>::value ? 30 : 6;
N    while (true)
N    {
N    __restart:
N        difference_type __len = __last - __first;
N        switch (__len)
N        {
N        case 0:
N        case 1:
N            return;
N        case 2:
N            if (__comp(*--__last, *__first))
N                swap(*__first, *__last);
N            return;
N        case 3:
N            _VSTD::__sort3<_Compare>(__first, __first+1, --__last, __comp);
X            std::__2::__sort3<_Compare>(__first, __first+1, --__last, __comp);
N            return;
N        case 4:
N            _VSTD::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);
X            std::__2::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);
N            return;
N        case 5:
N            _VSTD::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);
X            std::__2::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);
N            return;
N        }
N        if (__len <= __limit)
N        {
N            _VSTD::__insertion_sort_3<_Compare>(__first, __last, __comp);
X            std::__2::__insertion_sort_3<_Compare>(__first, __last, __comp);
N            return;
N        }
N        // __len > 5
N        _RandomAccessIterator __m = __first;
N        _RandomAccessIterator __lm1 = __last;
N        --__lm1;
N        unsigned __n_swaps;
N        {
N        difference_type __delta;
N        if (__len >= 1000)
N        {
N            __delta = __len/2;
N            __m += __delta;
N            __delta /= 2;
N            __n_swaps = _VSTD::__sort5<_Compare>(__first, __first + __delta, __m, __m+__delta, __lm1, __comp);
X            __n_swaps = std::__2::__sort5<_Compare>(__first, __first + __delta, __m, __m+__delta, __lm1, __comp);
N        }
N        else
N        {
N            __delta = __len/2;
N            __m += __delta;
N            __n_swaps = _VSTD::__sort3<_Compare>(__first, __m, __lm1, __comp);
X            __n_swaps = std::__2::__sort3<_Compare>(__first, __m, __lm1, __comp);
N        }
N        }
N        // *__m is median
N        // partition [__first, __m) < *__m and *__m <= [__m, __last)
N        // (this inhibits tossing elements equivalent to __m around unnecessarily)
N        _RandomAccessIterator __i = __first;
N        _RandomAccessIterator __j = __lm1;
N        // j points beyond range to be tested, *__m is known to be <= *__lm1
N        // The search going up is known to be guarded but the search coming down isn't.
N        // Prime the downward search with a guard.
N        if (!__comp(*__i, *__m))  // if *__first == *__m
N        {
N            // *__first == *__m, *__first doesn't go in first part
N            // manually guard downward moving __j against __i
N            while (true)
N            {
N                if (__i == --__j)
N                {
N                    // *__first == *__m, *__m <= all other elements
N                    // Parition instead into [__first, __i) == *__first and *__first < [__i, __last)
N                    ++__i;  // __first + 1
N                    __j = __last;
N                    if (!__comp(*__first, *--__j))  // we need a guard if *__first == *(__last-1)
N                    {
N                        while (true)
N                        {
N                            if (__i == __j)
N                                return;  // [__first, __last) all equivalent elements
N                            if (__comp(*__first, *__i))
N                            {
N                                swap(*__i, *__j);
N                                ++__n_swaps;
N                                ++__i;
N                                break;
N                            }
N                            ++__i;
N                        }
N                    }
N                    // [__first, __i) == *__first and *__first < [__j, __last) and __j == __last - 1
N                    if (__i == __j)
N                        return;
N                    while (true)
N                    {
N                        while (!__comp(*__first, *__i))
N                            ++__i;
N                        while (__comp(*__first, *--__j))
N                            ;
N                        if (__i >= __j)
N                            break;
N                        swap(*__i, *__j);
N                        ++__n_swaps;
N                        ++__i;
N                    }
N                    // [__first, __i) == *__first and *__first < [__i, __last)
N                    // The first part is sorted, sort the secod part
N                    // _VSTD::__sort<_Compare>(__i, __last, __comp);
N                    __first = __i;
N                    goto __restart;
N                }
N                if (__comp(*__j, *__m))
N                {
N                    swap(*__i, *__j);
N                    ++__n_swaps;
N                    break;  // found guard for downward moving __j, now use unguarded partition
N                }
N            }
N        }
N        // It is known that *__i < *__m
N        ++__i;
N        // j points beyond range to be tested, *__m is known to be <= *__lm1
N        // if not yet partitioned...
N        if (__i < __j)
N        {
N            // known that *(__i - 1) < *__m
N            // known that __i <= __m
N            while (true)
N            {
N                // __m still guards upward moving __i
N                while (__comp(*__i, *__m))
N                    ++__i;
N                // It is now known that a guard exists for downward moving __j
N                while (!__comp(*--__j, *__m))
N                    ;
N                if (__i > __j)
N                    break;
N                swap(*__i, *__j);
N                ++__n_swaps;
N                // It is known that __m != __j
N                // If __m just moved, follow it
N                if (__m == __i)
N                    __m = __j;
N                ++__i;
N            }
N        }
N        // [__first, __i) < *__m and *__m <= [__i, __last)
N        if (__i != __m && __comp(*__m, *__i))
N        {
N            swap(*__i, *__m);
N            ++__n_swaps;
N        }
N        // [__first, __i) < *__i and *__i <= [__i+1, __last)
N        // If we were given a perfect partition, see if insertion sort is quick...
N        if (__n_swaps == 0)
N        {
N            bool __fs = _VSTD::__insertion_sort_incomplete<_Compare>(__first, __i, __comp);
X            bool __fs = std::__2::__insertion_sort_incomplete<_Compare>(__first, __i, __comp);
N            if (_VSTD::__insertion_sort_incomplete<_Compare>(__i+1, __last, __comp))
X            if (std::__2::__insertion_sort_incomplete<_Compare>(__i+1, __last, __comp))
N            {
N                if (__fs)
N                    return;
N                __last = __i;
N                continue;
N            }
N            else
N            {
N                if (__fs)
N                {
N                    __first = ++__i;
N                    continue;
N                }
N            }
N        }
N        // sort smaller range with recursive call and larger with tail recursion elimination
N        if (__i - __first < __last - __i)
N        {
N            _VSTD::__sort<_Compare>(__first, __i, __comp);
X            std::__2::__sort<_Compare>(__first, __i, __comp);
N            // _VSTD::__sort<_Compare>(__i+1, __last, __comp);
N            __first = ++__i;
N        }
N        else
N        {
N            _VSTD::__sort<_Compare>(__i+1, __last, __comp);
X            std::__2::__sort<_Compare>(__i+1, __last, __comp);
N            // _VSTD::__sort<_Compare>(__first, __i, __comp);
N            __last = __i;
N        }
N    }
N}
N
N// This forwarder keeps the top call and the recursive calls using the same instantiation, forcing a reference _Compare
Ntemplate <class _RandomAccessIterator, class _Compare>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Nsort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
N{
N#ifdef _LIBCPP_DEBUG
S    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;
S    __debug_less<_Compare> __c(__comp);
S    __sort<_Comp_ref>(__first, __last, __c);
N#else  // _LIBCPP_DEBUG
N    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
N    __sort<_Comp_ref>(__first, __last, __comp);
N#endif  // _LIBCPP_DEBUG
N}
N
Ntemplate <class _RandomAccessIterator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Nsort(_RandomAccessIterator __first, _RandomAccessIterator __last)
N{
N    _VSTD::sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
X    std::__2::sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
N}
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Nsort(_Tp** __first, _Tp** __last)
N{
N    _VSTD::sort((size_t*)__first, (size_t*)__last, __less<size_t>());
X    std::__2::sort((size_t*)__first, (size_t*)__last, __less<size_t>());
N}
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Nsort(__wrap_iter<_Tp*> __first, __wrap_iter<_Tp*> __last)
N{
N    _VSTD::sort(__first.base(), __last.base());
X    std::__2::sort(__first.base(), __last.base());
N}
N
Ntemplate <class _Tp, class _Compare>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Nsort(__wrap_iter<_Tp*> __first, __wrap_iter<_Tp*> __last, _Compare __comp)
N{
N    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
N    _VSTD::sort<_Tp*, _Comp_ref>(__first.base(), __last.base(), __comp);
X    std::__2::sort<_Tp*, _Comp_ref>(__first.base(), __last.base(), __comp);
N}
N
N_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<char>&, char*>(char*, char*, __less<char>&))
Xextern template void __sort<__less<char> &, char* >(char*, char*, __less<char> &);
N_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&))
Xextern template void __sort<__less<wchar_t> &, wchar_t* >(wchar_t*, wchar_t*, __less<wchar_t> &);
N_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&))
Xextern template void __sort<__less<signed char> &, signed char* >(signed char*, signed char*, __less<signed char> &);
N_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&))
Xextern template void __sort<__less<unsigned char> &, unsigned char* >(unsigned char*, unsigned char*, __less<unsigned char> &);
N_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<short>&, short*>(short*, short*, __less<short>&))
Xextern template void __sort<__less<short> &, short* >(short*, short*, __less<short> &);
N_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&))
Xextern template void __sort<__less<unsigned short> &, unsigned short* >(unsigned short*, unsigned short*, __less<unsigned short> &);
N_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<int>&, int*>(int*, int*, __less<int>&))
Xextern template void __sort<__less<int> &, int* >(int*, int*, __less<int> &);
N_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&))
Xextern template void __sort<__less<unsigned> &, unsigned* >(unsigned*, unsigned*, __less<unsigned> &);
N_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<long>&, long*>(long*, long*, __less<long>&))
Xextern template void __sort<__less<long> &, long* >(long*, long*, __less<long> &);
N_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&))
Xextern template void __sort<__less<unsigned long> &, unsigned long* >(unsigned long*, unsigned long*, __less<unsigned long> &);
N_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<long long>&, long long*>(long long*, long long*, __less<long long>&))
Xextern template void __sort<__less<long long> &, long long* >(long long*, long long*, __less<long long> &);
N_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&))
Xextern template void __sort<__less<unsigned long long> &, unsigned long long* >(unsigned long long*, unsigned long long*, __less<unsigned long long> &);
N_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<float>&, float*>(float*, float*, __less<float>&))
Xextern template void __sort<__less<float> &, float* >(float*, float*, __less<float> &);
N_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<double>&, double*>(double*, double*, __less<double>&))
Xextern template void __sort<__less<double> &, double* >(double*, double*, __less<double> &);
N_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<long double>&, long double*>(long double*, long double*, __less<long double>&))
Xextern template void __sort<__less<long double> &, long double* >(long double*, long double*, __less<long double> &);
N
N_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<char>&, char*>(char*, char*, __less<char>&))
Xextern template bool __insertion_sort_incomplete<__less<char> &, char* >(char*, char*, __less<char> &);
N_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&))
Xextern template bool __insertion_sort_incomplete<__less<wchar_t> &, wchar_t* >(wchar_t*, wchar_t*, __less<wchar_t> &);
N_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&))
Xextern template bool __insertion_sort_incomplete<__less<signed char> &, signed char* >(signed char*, signed char*, __less<signed char> &);
N_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&))
Xextern template bool __insertion_sort_incomplete<__less<unsigned char> &, unsigned char* >(unsigned char*, unsigned char*, __less<unsigned char> &);
N_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<short>&, short*>(short*, short*, __less<short>&))
Xextern template bool __insertion_sort_incomplete<__less<short> &, short* >(short*, short*, __less<short> &);
N_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&))
Xextern template bool __insertion_sort_incomplete<__less<unsigned short> &, unsigned short* >(unsigned short*, unsigned short*, __less<unsigned short> &);
N_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<int>&, int*>(int*, int*, __less<int>&))
Xextern template bool __insertion_sort_incomplete<__less<int> &, int* >(int*, int*, __less<int> &);
N_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&))
Xextern template bool __insertion_sort_incomplete<__less<unsigned> &, unsigned* >(unsigned*, unsigned*, __less<unsigned> &);
N_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<long>&, long*>(long*, long*, __less<long>&))
Xextern template bool __insertion_sort_incomplete<__less<long> &, long* >(long*, long*, __less<long> &);
N_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&))
Xextern template bool __insertion_sort_incomplete<__less<unsigned long> &, unsigned long* >(unsigned long*, unsigned long*, __less<unsigned long> &);
N_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<long long>&, long long*>(long long*, long long*, __less<long long>&))
Xextern template bool __insertion_sort_incomplete<__less<long long> &, long long* >(long long*, long long*, __less<long long> &);
N_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&))
Xextern template bool __insertion_sort_incomplete<__less<unsigned long long> &, unsigned long long* >(unsigned long long*, unsigned long long*, __less<unsigned long long> &);
N_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<float>&, float*>(float*, float*, __less<float>&))
Xextern template bool __insertion_sort_incomplete<__less<float> &, float* >(float*, float*, __less<float> &);
N_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<double>&, double*>(double*, double*, __less<double>&))
Xextern template bool __insertion_sort_incomplete<__less<double> &, double* >(double*, double*, __less<double> &);
N_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<long double>&, long double*>(long double*, long double*, __less<long double>&))
Xextern template bool __insertion_sort_incomplete<__less<long double> &, long double* >(long double*, long double*, __less<long double> &);
N
N_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS unsigned __sort5<__less<long double>&, long double*>(long double*, long double*, long double*, long double*, long double*, __less<long double>&))
Xextern template unsigned __sort5<__less<long double> &, long double* >(long double*, long double*, long double*, long double*, long double*, __less<long double> &);
N
N// lower_bound
N
Ntemplate <class _Compare, class _ForwardIterator, class _Tp>
N_ForwardIterator
N__lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
N{
N    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
N    difference_type __len = _VSTD::distance(__first, __last);
X    difference_type __len = std::__2::distance(__first, __last);
N    while (__len != 0)
N    {
N        difference_type __l2 = __len / 2;
N        _ForwardIterator __m = __first;
N        _VSTD::advance(__m, __l2);
X        std::__2::advance(__m, __l2);
N        if (__comp(*__m, __value_))
N        {
N            __first = ++__m;
N            __len -= __l2 + 1;
N        }
N        else
N            __len = __l2;
N    }
N    return __first;
N}
N
Ntemplate <class _ForwardIterator, class _Tp, class _Compare>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_ForwardIterator
Nlower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
N{
N#ifdef _LIBCPP_DEBUG
S    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;
S    __debug_less<_Compare> __c(__comp);
S    return __lower_bound<_Comp_ref>(__first, __last, __value_, __c);
N#else  // _LIBCPP_DEBUG
N    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
N    return __lower_bound<_Comp_ref>(__first, __last, __value_, __comp);
N#endif  // _LIBCPP_DEBUG
N}
N
Ntemplate <class _ForwardIterator, class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_ForwardIterator
Nlower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
N{
N    return _VSTD::lower_bound(__first, __last, __value_,
X    return std::__2::lower_bound(__first, __last, __value_,
N                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());
N}
N
N// upper_bound
N
Ntemplate <class _Compare, class _ForwardIterator, class _Tp>
N_ForwardIterator
N__upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
N{
N    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
N    difference_type __len = _VSTD::distance(__first, __last);
X    difference_type __len = std::__2::distance(__first, __last);
N    while (__len != 0)
N    {
N        difference_type __l2 = __len / 2;
N        _ForwardIterator __m = __first;
N        _VSTD::advance(__m, __l2);
X        std::__2::advance(__m, __l2);
N        if (__comp(__value_, *__m))
N            __len = __l2;
N        else
N        {
N            __first = ++__m;
N            __len -= __l2 + 1;
N        }
N    }
N    return __first;
N}
N
Ntemplate <class _ForwardIterator, class _Tp, class _Compare>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_ForwardIterator
Nupper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
N{
N#ifdef _LIBCPP_DEBUG
S    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;
S    __debug_less<_Compare> __c(__comp);
S    return __upper_bound<_Comp_ref>(__first, __last, __value_, __c);
N#else  // _LIBCPP_DEBUG
N    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
N    return __upper_bound<_Comp_ref>(__first, __last, __value_, __comp);
N#endif  // _LIBCPP_DEBUG
N}
N
Ntemplate <class _ForwardIterator, class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_ForwardIterator
Nupper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
N{
N    return _VSTD::upper_bound(__first, __last, __value_,
X    return std::__2::upper_bound(__first, __last, __value_,
N                             __less<_Tp, typename iterator_traits<_ForwardIterator>::value_type>());
N}
N
N// equal_range
N
Ntemplate <class _Compare, class _ForwardIterator, class _Tp>
Npair<_ForwardIterator, _ForwardIterator>
N__equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
N{
N    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
N    difference_type __len = _VSTD::distance(__first, __last);
X    difference_type __len = std::__2::distance(__first, __last);
N    while (__len != 0)
N    {
N        difference_type __l2 = __len / 2;
N        _ForwardIterator __m = __first;
N        _VSTD::advance(__m, __l2);
X        std::__2::advance(__m, __l2);
N        if (__comp(*__m, __value_))
N        {
N            __first = ++__m;
N            __len -= __l2 + 1;
N        }
N        else if (__comp(__value_, *__m))
N        {
N            __last = __m;
N            __len = __l2;
N        }
N        else
N        {
N            _ForwardIterator __mp1 = __m;
N            return pair<_ForwardIterator, _ForwardIterator>
N                   (
N                      __lower_bound<_Compare>(__first, __m, __value_, __comp),
N                      __upper_bound<_Compare>(++__mp1, __last, __value_, __comp)
N                   );
N        }
N    }
N    return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
N}
N
Ntemplate <class _ForwardIterator, class _Tp, class _Compare>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Npair<_ForwardIterator, _ForwardIterator>
Nequal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
N{
N#ifdef _LIBCPP_DEBUG
S    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;
S    __debug_less<_Compare> __c(__comp);
S    return __equal_range<_Comp_ref>(__first, __last, __value_, __c);
N#else  // _LIBCPP_DEBUG
N    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
N    return __equal_range<_Comp_ref>(__first, __last, __value_, __comp);
N#endif  // _LIBCPP_DEBUG
N}
N
Ntemplate <class _ForwardIterator, class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Npair<_ForwardIterator, _ForwardIterator>
Nequal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
N{
N    return _VSTD::equal_range(__first, __last, __value_,
X    return std::__2::equal_range(__first, __last, __value_,
N                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());
N}
N
N// binary_search
N
Ntemplate <class _Compare, class _ForwardIterator, class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
N__binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
N{
N    __first = __lower_bound<_Compare>(__first, __last, __value_, __comp);
N    return __first != __last && !__comp(__value_, *__first);
N}
N
Ntemplate <class _ForwardIterator, class _Tp, class _Compare>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Nbinary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
N{
N#ifdef _LIBCPP_DEBUG
S    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;
S    __debug_less<_Compare> __c(__comp);
S    return __binary_search<_Comp_ref>(__first, __last, __value_, __c);
N#else  // _LIBCPP_DEBUG
N    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
N    return __binary_search<_Comp_ref>(__first, __last, __value_, __comp);
N#endif  // _LIBCPP_DEBUG
N}
N
Ntemplate <class _ForwardIterator, class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Nbinary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
N{
N    return _VSTD::binary_search(__first, __last, __value_,
X    return std::__2::binary_search(__first, __last, __value_,
N                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());
N}
N
N// merge
N
Ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
N_OutputIterator
N__merge(_InputIterator1 __first1, _InputIterator1 __last1,
N        _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
N{
N    for (; __first1 != __last1; ++__result)
N    {
N        if (__first2 == __last2)
N            return _VSTD::copy(__first1, __last1, __result);
X            return std::__2::copy(__first1, __last1, __result);
N        if (__comp(*__first2, *__first1))
N        {
N            *__result = *__first2;
N            ++__first2;
N        }
N        else
N        {
N            *__result = *__first1;
N            ++__first1;
N        }
N    }
N    return _VSTD::copy(__first2, __last2, __result);
X    return std::__2::copy(__first2, __last2, __result);
N}
N
Ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_OutputIterator
Nmerge(_InputIterator1 __first1, _InputIterator1 __last1,
N      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
N{
N#ifdef _LIBCPP_DEBUG
S    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;
S    __debug_less<_Compare> __c(__comp);
S    return _VSTD::__merge<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);
N#else  // _LIBCPP_DEBUG
N    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
N    return _VSTD::__merge<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);
X    return std::__2::__merge<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);
N#endif  // _LIBCPP_DEBUG
N}
N
Ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_OutputIterator
Nmerge(_InputIterator1 __first1, _InputIterator1 __last1,
N      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
N{
N    typedef typename iterator_traits<_InputIterator1>::value_type __v1;
N    typedef typename iterator_traits<_InputIterator2>::value_type __v2;
N    return merge(__first1, __last1, __first2, __last2, __result, __less<__v1, __v2>());
N}
N
N// inplace_merge
N
Ntemplate <class _Compare, class _InputIterator1, class _InputIterator2,
N          class _OutputIterator>
Nvoid __half_inplace_merge(_InputIterator1 __first1, _InputIterator1 __last1,
N                          _InputIterator2 __first2, _InputIterator2 __last2,
N                          _OutputIterator __result, _Compare __comp)
N{
N    for (; __first1 != __last1; ++__result)
N    {
N        if (__first2 == __last2)
N        {
N            _VSTD::move(__first1, __last1, __result);
X            std::__2::move(__first1, __last1, __result);
N            return;
N        }
N
N        if (__comp(*__first2, *__first1))
N        {
N            *__result = _VSTD::move(*__first2);
X            *__result = std::__2::move(*__first2);
N            ++__first2;
N        }
N        else
N        {
N            *__result = _VSTD::move(*__first1);
X            *__result = std::__2::move(*__first1);
N            ++__first1;
N        }
N    }
N    // __first2 through __last2 are already in the right spot.
N}
N
Ntemplate <class _Compare, class _BidirectionalIterator>
Nvoid
N__buffered_inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,
N                _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1,
N                                 typename iterator_traits<_BidirectionalIterator>::difference_type __len2,
N                typename iterator_traits<_BidirectionalIterator>::value_type* __buff)
N{
N    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
N    __destruct_n __d(0);
N    unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);
N    if (__len1 <= __len2)
N    {
N        value_type* __p = __buff;
N        for (_BidirectionalIterator __i = __first; __i != __middle; __d.__incr((value_type*)0), (void) ++__i, ++__p)
N            ::new(__p) value_type(_VSTD::move(*__i));
X            ::new(__p) value_type(std::__2::move(*__i));
N        __half_inplace_merge(__buff, __p, __middle, __last, __first, __comp);
N    }
N    else
N    {
N        value_type* __p = __buff;
N        for (_BidirectionalIterator __i = __middle; __i != __last; __d.__incr((value_type*)0), (void) ++__i, ++__p)
N            ::new(__p) value_type(_VSTD::move(*__i));
X            ::new(__p) value_type(std::__2::move(*__i));
N        typedef reverse_iterator<_BidirectionalIterator> _RBi;
N        typedef reverse_iterator<value_type*> _Rv;
N        __half_inplace_merge(_Rv(__p), _Rv(__buff),
N                             _RBi(__middle), _RBi(__first),
N                             _RBi(__last), __invert<_Compare>(__comp));
N    }
N}
N
Ntemplate <class _Compare, class _BidirectionalIterator>
Nvoid
N__inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,
N                _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1,
N                                 typename iterator_traits<_BidirectionalIterator>::difference_type __len2,
N                typename iterator_traits<_BidirectionalIterator>::value_type* __buff, ptrdiff_t __buff_size)
N{
N    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;
N    while (true)
N    {
N        // if __middle == __last, we're done
N        if (__len2 == 0)
N            return;
N        if (__len1 <= __buff_size || __len2 <= __buff_size)
N            return __buffered_inplace_merge<_Compare>
N                   (__first, __middle, __last, __comp, __len1, __len2, __buff);
N        // shrink [__first, __middle) as much as possible (with no moves), returning if it shrinks to 0
N        for (; true; ++__first, (void) --__len1)
N        {
N            if (__len1 == 0)
N                return;
N            if (__comp(*__middle, *__first))
N                break;
N        }
N        // __first < __middle < __last
N        // *__first > *__middle
N        // partition [__first, __m1) [__m1, __middle) [__middle, __m2) [__m2, __last) such that
N        //     all elements in:
N        //         [__first, __m1)  <= [__middle, __m2)
N        //         [__middle, __m2) <  [__m1, __middle)
N        //         [__m1, __middle) <= [__m2, __last)
N        //     and __m1 or __m2 is in the middle of its range
N        _BidirectionalIterator __m1;  // "median" of [__first, __middle)
N        _BidirectionalIterator __m2;  // "median" of [__middle, __last)
N        difference_type __len11;      // distance(__first, __m1)
N        difference_type __len21;      // distance(__middle, __m2)
N        // binary search smaller range
N        if (__len1 < __len2)
N        {   // __len >= 1, __len2 >= 2
N            __len21 = __len2 / 2;
N            __m2 = __middle;
N            _VSTD::advance(__m2, __len21);
X            std::__2::advance(__m2, __len21);
N            __m1 = __upper_bound<_Compare>(__first, __middle, *__m2, __comp);
N            __len11 = _VSTD::distance(__first, __m1);
X            __len11 = std::__2::distance(__first, __m1);
N        }
N        else
N        {
N            if (__len1 == 1)
N            {   // __len1 >= __len2 && __len2 > 0, therefore __len2 == 1
N                // It is known *__first > *__middle
N                swap(*__first, *__middle);
N                return;
N            }
N            // __len1 >= 2, __len2 >= 1
N            __len11 = __len1 / 2;
N            __m1 = __first;
N            _VSTD::advance(__m1, __len11);
X            std::__2::advance(__m1, __len11);
N            __m2 = __lower_bound<_Compare>(__middle, __last, *__m1, __comp);
N            __len21 = _VSTD::distance(__middle, __m2);
X            __len21 = std::__2::distance(__middle, __m2);
N        }
N        difference_type __len12 = __len1 - __len11;  // distance(__m1, __middle)
N        difference_type __len22 = __len2 - __len21;  // distance(__m2, __last)
N        // [__first, __m1) [__m1, __middle) [__middle, __m2) [__m2, __last)
N        // swap middle two partitions
N        __middle = _VSTD::rotate(__m1, __middle, __m2);
X        __middle = std::__2::rotate(__m1, __middle, __m2);
N        // __len12 and __len21 now have swapped meanings
N        // merge smaller range with recurisve call and larger with tail recursion elimination
N        if (__len11 + __len21 < __len12 + __len22)
N        {
N            __inplace_merge<_Compare>(__first, __m1, __middle, __comp, __len11, __len21, __buff, __buff_size);
N//          __inplace_merge<_Compare>(__middle, __m2, __last, __comp, __len12, __len22, __buff, __buff_size);
N            __first = __middle;
N            __middle = __m2;
N            __len1 = __len12;
N            __len2 = __len22;
N        }
N        else
N        {
N            __inplace_merge<_Compare>(__middle, __m2, __last, __comp, __len12, __len22, __buff, __buff_size);
N//          __inplace_merge<_Compare>(__first, __m1, __middle, __comp, __len11, __len21, __buff, __buff_size);
N            __last = __middle;
N            __middle = __m1;
N            __len1 = __len11;
N            __len2 = __len21;
N        }
N    }
N}
N
Ntemplate <class _BidirectionalIterator, class _Compare>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Ninplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,
N              _Compare __comp)
N{
N    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
N    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;
N    difference_type __len1 = _VSTD::distance(__first, __middle);
X    difference_type __len1 = std::__2::distance(__first, __middle);
N    difference_type __len2 = _VSTD::distance(__middle, __last);
X    difference_type __len2 = std::__2::distance(__middle, __last);
N    difference_type __buf_size = _VSTD::min(__len1, __len2);
X    difference_type __buf_size = std::__2::min(__len1, __len2);
N    pair<value_type*, ptrdiff_t> __buf = _VSTD::get_temporary_buffer<value_type>(__buf_size);
X    pair<value_type*, ptrdiff_t> __buf = std::__2::get_temporary_buffer<value_type>(__buf_size);
N    unique_ptr<value_type, __return_temporary_buffer> __h(__buf.first);
N
N#ifdef _LIBCPP_DEBUG
S    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;
S    __debug_less<_Compare> __c(__comp);
S    return _VSTD::__inplace_merge<_Comp_ref>(__first, __middle, __last, __c, __len1, __len2,
S                                            __buf.first, __buf.second);
N#else  // _LIBCPP_DEBUG
N    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
N    return _VSTD::__inplace_merge<_Comp_ref>(__first, __middle, __last, __comp, __len1, __len2,
X    return std::__2::__inplace_merge<_Comp_ref>(__first, __middle, __last, __comp, __len1, __len2,
N                                            __buf.first, __buf.second);
N#endif  // _LIBCPP_DEBUG
N}
N
Ntemplate <class _BidirectionalIterator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Ninplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last)
N{
N    _VSTD::inplace_merge(__first, __middle, __last,
X    std::__2::inplace_merge(__first, __middle, __last,
N                        __less<typename iterator_traits<_BidirectionalIterator>::value_type>());
N}
N
N// stable_sort
N
Ntemplate <class _Compare, class _InputIterator1, class _InputIterator2>
Nvoid
N__merge_move_construct(_InputIterator1 __first1, _InputIterator1 __last1,
N        _InputIterator2 __first2, _InputIterator2 __last2,
N        typename iterator_traits<_InputIterator1>::value_type* __result, _Compare __comp)
N{
N    typedef typename iterator_traits<_InputIterator1>::value_type value_type;
N    __destruct_n __d(0);
N    unique_ptr<value_type, __destruct_n&> __h(__result, __d);
N    for (; true; ++__result)
N    {
N        if (__first1 == __last1)
N        {
N            for (; __first2 != __last2; ++__first2, ++__result, __d.__incr((value_type*)0))
N                ::new (__result) value_type(_VSTD::move(*__first2));
X                ::new (__result) value_type(std::__2::move(*__first2));
N            __h.release();
N            return;
N        }
N        if (__first2 == __last2)
N        {
N            for (; __first1 != __last1; ++__first1, ++__result, __d.__incr((value_type*)0))
N                ::new (__result) value_type(_VSTD::move(*__first1));
X                ::new (__result) value_type(std::__2::move(*__first1));
N            __h.release();
N            return;
N        }
N        if (__comp(*__first2, *__first1))
N        {
N            ::new (__result) value_type(_VSTD::move(*__first2));
X            ::new (__result) value_type(std::__2::move(*__first2));
N            __d.__incr((value_type*)0);
N            ++__first2;
N        }
N        else
N        {
N            ::new (__result) value_type(_VSTD::move(*__first1));
X            ::new (__result) value_type(std::__2::move(*__first1));
N            __d.__incr((value_type*)0);
N            ++__first1;
N        }
N    }
N}
N
Ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
Nvoid
N__merge_move_assign(_InputIterator1 __first1, _InputIterator1 __last1,
N        _InputIterator2 __first2, _InputIterator2 __last2,
N        _OutputIterator __result, _Compare __comp)
N{
N    for (; __first1 != __last1; ++__result)
N    {
N        if (__first2 == __last2)
N        {
N            for (; __first1 != __last1; ++__first1, ++__result)
N                *__result = _VSTD::move(*__first1);
X                *__result = std::__2::move(*__first1);
N            return;
N        }
N        if (__comp(*__first2, *__first1))
N        {
N            *__result = _VSTD::move(*__first2);
X            *__result = std::__2::move(*__first2);
N            ++__first2;
N        }
N        else
N        {
N            *__result = _VSTD::move(*__first1);
X            *__result = std::__2::move(*__first1);
N            ++__first1;
N        }
N    }
N    for (; __first2 != __last2; ++__first2, ++__result)
N        *__result = _VSTD::move(*__first2);
X        *__result = std::__2::move(*__first2);
N}
N
Ntemplate <class _Compare, class _RandomAccessIterator>
Nvoid
N__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,
N              typename iterator_traits<_RandomAccessIterator>::difference_type __len,
N              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size);
N
Ntemplate <class _Compare, class _RandomAccessIterator>
Nvoid
N__stable_sort_move(_RandomAccessIterator __first1, _RandomAccessIterator __last1, _Compare __comp,
N                   typename iterator_traits<_RandomAccessIterator>::difference_type __len,
N                   typename iterator_traits<_RandomAccessIterator>::value_type* __first2)
N{
N    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
N    switch (__len)
N    {
N    case 0:
N        return;
N    case 1:
N        ::new(__first2) value_type(_VSTD::move(*__first1));
X        ::new(__first2) value_type(std::__2::move(*__first1));
N        return;
N    case 2:
N       __destruct_n __d(0);
N        unique_ptr<value_type, __destruct_n&> __h2(__first2, __d);
N         if (__comp(*--__last1, *__first1))
N        {
N            ::new(__first2) value_type(_VSTD::move(*__last1));
X            ::new(__first2) value_type(std::__2::move(*__last1));
N            __d.__incr((value_type*)0);
N            ++__first2;
N            ::new(__first2) value_type(_VSTD::move(*__first1));
X            ::new(__first2) value_type(std::__2::move(*__first1));
N        }
N        else
N        {
N            ::new(__first2) value_type(_VSTD::move(*__first1));
X            ::new(__first2) value_type(std::__2::move(*__first1));
N            __d.__incr((value_type*)0);
N            ++__first2;
N            ::new(__first2) value_type(_VSTD::move(*__last1));
X            ::new(__first2) value_type(std::__2::move(*__last1));
N        }
N        __h2.release();
N        return;
N    }
N    if (__len <= 8)
N    {
N        __insertion_sort_move<_Compare>(__first1, __last1, __first2, __comp);
N        return;
N    }
N    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;
N    _RandomAccessIterator __m = __first1 + __l2;
N    __stable_sort<_Compare>(__first1, __m, __comp, __l2, __first2, __l2);
N    __stable_sort<_Compare>(__m, __last1, __comp, __len - __l2, __first2 + __l2, __len - __l2);
N    __merge_move_construct<_Compare>(__first1, __m, __m, __last1, __first2, __comp);
N}
N
Ntemplate <class _Tp>
Nstruct __stable_sort_switch
N{
N    static const unsigned value = 128*is_trivially_copy_assignable<_Tp>::value;
N};
N
Ntemplate <class _Compare, class _RandomAccessIterator>
Nvoid
N__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,
N              typename iterator_traits<_RandomAccessIterator>::difference_type __len,
N              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size)
N{
N    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
N    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
N    switch (__len)
N    {
N    case 0:
N    case 1:
N        return;
N    case 2:
N        if (__comp(*--__last, *__first))
N            swap(*__first, *__last);
N        return;
N    }
N    if (__len <= static_cast<difference_type>(__stable_sort_switch<value_type>::value))
N    {
N        __insertion_sort<_Compare>(__first, __last, __comp);
N        return;
N    }
N    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;
N    _RandomAccessIterator __m = __first + __l2;
N    if (__len <= __buff_size)
N    {
N        __destruct_n __d(0);
N        unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);
N        __stable_sort_move<_Compare>(__first, __m, __comp, __l2, __buff);
N        __d.__set(__l2, (value_type*)0);
N        __stable_sort_move<_Compare>(__m, __last, __comp, __len - __l2, __buff + __l2);
N        __d.__set(__len, (value_type*)0);
N        __merge_move_assign<_Compare>(__buff, __buff + __l2, __buff + __l2, __buff + __len, __first, __comp);
N//         __merge<_Compare>(move_iterator<value_type*>(__buff),
N//                           move_iterator<value_type*>(__buff + __l2),
N//                           move_iterator<_RandomAccessIterator>(__buff + __l2),
N//                           move_iterator<_RandomAccessIterator>(__buff + __len),
N//                           __first, __comp);
N        return;
N    }
N    __stable_sort<_Compare>(__first, __m, __comp, __l2, __buff, __buff_size);
N    __stable_sort<_Compare>(__m, __last, __comp, __len - __l2, __buff, __buff_size);
N    __inplace_merge<_Compare>(__first, __m, __last, __comp, __l2, __len - __l2, __buff, __buff_size);
N}
N
Ntemplate <class _RandomAccessIterator, class _Compare>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Nstable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
N{
N    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
N    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
N    difference_type __len = __last - __first;
N    pair<value_type*, ptrdiff_t> __buf(0, 0);
N    unique_ptr<value_type, __return_temporary_buffer> __h;
N    if (__len > static_cast<difference_type>(__stable_sort_switch<value_type>::value))
N    {
N        __buf = _VSTD::get_temporary_buffer<value_type>(__len);
X        __buf = std::__2::get_temporary_buffer<value_type>(__len);
N        __h.reset(__buf.first);
N    }
N#ifdef _LIBCPP_DEBUG
S    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;
S    __debug_less<_Compare> __c(__comp);
S    __stable_sort<_Comp_ref>(__first, __last, __c, __len, __buf.first, __buf.second);
N#else  // _LIBCPP_DEBUG
N    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
N    __stable_sort<_Comp_ref>(__first, __last, __comp, __len, __buf.first, __buf.second);
N#endif  // _LIBCPP_DEBUG
N}
N
Ntemplate <class _RandomAccessIterator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Nstable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
N{
N    _VSTD::stable_sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
X    std::__2::stable_sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
N}
N
N// is_heap_until
N
Ntemplate <class _RandomAccessIterator, class _Compare>
N_RandomAccessIterator
Nis_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
N{
N    typedef typename _VSTD::iterator_traits<_RandomAccessIterator>::difference_type difference_type;
X    typedef typename std::__2::iterator_traits<_RandomAccessIterator>::difference_type difference_type;
N    difference_type __len = __last - __first;
N    difference_type __p = 0;
N    difference_type __c = 1;
N    _RandomAccessIterator __pp = __first;
N    while (__c < __len)
N    {
N        _RandomAccessIterator __cp = __first + __c;
N        if (__comp(*__pp, *__cp))
N            return __cp;
N        ++__c;
N        ++__cp;
N        if (__c == __len)
N            return __last;
N        if (__comp(*__pp, *__cp))
N            return __cp;
N        ++__p;
N        ++__pp;
N        __c = 2 * __p + 1;
N    }
N    return __last;
N}
N
Ntemplate<class _RandomAccessIterator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_RandomAccessIterator
Nis_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last)
N{
N    return _VSTD::is_heap_until(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
X    return std::__2::is_heap_until(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
N}
N
N// is_heap
N
Ntemplate <class _RandomAccessIterator, class _Compare>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Nis_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
N{
N    return _VSTD::is_heap_until(__first, __last, __comp) == __last;
X    return std::__2::is_heap_until(__first, __last, __comp) == __last;
N}
N
Ntemplate<class _RandomAccessIterator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Nis_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
N{
N    return _VSTD::is_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
X    return std::__2::is_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
N}
N
N// push_heap
N
Ntemplate <class _Compare, class _RandomAccessIterator>
Nvoid
N__sift_up(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,
N          typename iterator_traits<_RandomAccessIterator>::difference_type __len)
N{
N    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
N    if (__len > 1)
N    {
N        __len = (__len - 2) / 2;
N        _RandomAccessIterator __ptr = __first + __len;
N        if (__comp(*__ptr, *--__last))
N        {
N            value_type __t(_VSTD::move(*__last));
X            value_type __t(std::__2::move(*__last));
N            do
N            {
N                *__last = _VSTD::move(*__ptr);
X                *__last = std::__2::move(*__ptr);
N                __last = __ptr;
N                if (__len == 0)
N                    break;
N                __len = (__len - 1) / 2;
N                __ptr = __first + __len;
N            } while (__comp(*__ptr, __t));
N            *__last = _VSTD::move(__t);
X            *__last = std::__2::move(__t);
N        }
N    }
N}
N
Ntemplate <class _RandomAccessIterator, class _Compare>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Npush_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
N{
N#ifdef _LIBCPP_DEBUG
S    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;
S    __debug_less<_Compare> __c(__comp);
S    __sift_up<_Comp_ref>(__first, __last, __c, __last - __first);
N#else  // _LIBCPP_DEBUG
N    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
N    __sift_up<_Comp_ref>(__first, __last, __comp, __last - __first);
N#endif  // _LIBCPP_DEBUG
N}
N
Ntemplate <class _RandomAccessIterator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Npush_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
N{
N    _VSTD::push_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
X    std::__2::push_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
N}
N
N// pop_heap
N
Ntemplate <class _Compare, class _RandomAccessIterator>
Nvoid
N__sift_down(_RandomAccessIterator __first, _RandomAccessIterator /*__last*/,
N            _Compare __comp,
N            typename iterator_traits<_RandomAccessIterator>::difference_type __len,
N            _RandomAccessIterator __start)
N{
N    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
N    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
N    // left-child of __start is at 2 * __start + 1
N    // right-child of __start is at 2 * __start + 2
N    difference_type __child = __start - __first;
N
N    if (__len < 2 || (__len - 2) / 2 < __child)
N        return;
N
N    __child = 2 * __child + 1;
N    _RandomAccessIterator __child_i = __first + __child;
N
N    if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + 1))) {
N        // right-child exists and is greater than left-child
N        ++__child_i;
N        ++__child;
N    }
N
N    // check if we are in heap-order
N    if (__comp(*__child_i, *__start))
N        // we are, __start is larger than it's largest child
N        return;
N
N    value_type __top(_VSTD::move(*__start));
X    value_type __top(std::__2::move(*__start));
N    do
N    {
N        // we are not in heap-order, swap the parent with it's largest child
N        *__start = _VSTD::move(*__child_i);
X        *__start = std::__2::move(*__child_i);
N        __start = __child_i;
N
N        if ((__len - 2) / 2 < __child)
N            break;
N
N        // recompute the child based off of the updated parent
N        __child = 2 * __child + 1;
N        __child_i = __first + __child;
N
N        if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + 1))) {
N            // right-child exists and is greater than left-child
N            ++__child_i;
N            ++__child;
N        }
N
N        // check if we are in heap-order
N    } while (!__comp(*__child_i, __top));
N    *__start = _VSTD::move(__top);
X    *__start = std::__2::move(__top);
N}
N
Ntemplate <class _Compare, class _RandomAccessIterator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
N__pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,
N           typename iterator_traits<_RandomAccessIterator>::difference_type __len)
N{
N    if (__len > 1)
N    {
N        swap(*__first, *--__last);
N        __sift_down<_Compare>(__first, __last, __comp, __len - 1, __first);
N    }
N}
N
Ntemplate <class _RandomAccessIterator, class _Compare>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Npop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
N{
N#ifdef _LIBCPP_DEBUG
S    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;
S    __debug_less<_Compare> __c(__comp);
S    __pop_heap<_Comp_ref>(__first, __last, __c, __last - __first);
N#else  // _LIBCPP_DEBUG
N    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
N    __pop_heap<_Comp_ref>(__first, __last, __comp, __last - __first);
N#endif  // _LIBCPP_DEBUG
N}
N
Ntemplate <class _RandomAccessIterator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Npop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
N{
N    _VSTD::pop_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
X    std::__2::pop_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
N}
N
N// make_heap
N
Ntemplate <class _Compare, class _RandomAccessIterator>
Nvoid
N__make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
N{
N    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
N    difference_type __n = __last - __first;
N    if (__n > 1)
N    {
N        // start from the first parent, there is no need to consider children
N        for (difference_type __start = (__n - 2) / 2; __start >= 0; --__start)
N        {
N            __sift_down<_Compare>(__first, __last, __comp, __n, __first + __start);
N        }
N    }
N}
N
Ntemplate <class _RandomAccessIterator, class _Compare>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Nmake_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
N{
N#ifdef _LIBCPP_DEBUG
S    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;
S    __debug_less<_Compare> __c(__comp);
S    __make_heap<_Comp_ref>(__first, __last, __c);
N#else  // _LIBCPP_DEBUG
N    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
N    __make_heap<_Comp_ref>(__first, __last, __comp);
N#endif  // _LIBCPP_DEBUG
N}
N
Ntemplate <class _RandomAccessIterator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Nmake_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
N{
N    _VSTD::make_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
X    std::__2::make_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
N}
N
N// sort_heap
N
Ntemplate <class _Compare, class _RandomAccessIterator>
Nvoid
N__sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
N{
N    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
N    for (difference_type __n = __last - __first; __n > 1; --__last, --__n)
N        __pop_heap<_Compare>(__first, __last, __comp, __n);
N}
N
Ntemplate <class _RandomAccessIterator, class _Compare>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Nsort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
N{
N#ifdef _LIBCPP_DEBUG
S    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;
S    __debug_less<_Compare> __c(__comp);
S    __sort_heap<_Comp_ref>(__first, __last, __c);
N#else  // _LIBCPP_DEBUG
N    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
N    __sort_heap<_Comp_ref>(__first, __last, __comp);
N#endif  // _LIBCPP_DEBUG
N}
N
Ntemplate <class _RandomAccessIterator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Nsort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
N{
N    _VSTD::sort_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
X    std::__2::sort_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
N}
N
N// partial_sort
N
Ntemplate <class _Compare, class _RandomAccessIterator>
Nvoid
N__partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,
N             _Compare __comp)
N{
N    __make_heap<_Compare>(__first, __middle, __comp);
N    typename iterator_traits<_RandomAccessIterator>::difference_type __len = __middle - __first;
N    for (_RandomAccessIterator __i = __middle; __i != __last; ++__i)
N    {
N        if (__comp(*__i, *__first))
N        {
N            swap(*__i, *__first);
N            __sift_down<_Compare>(__first, __middle, __comp, __len, __first);
N        }
N    }
N    __sort_heap<_Compare>(__first, __middle, __comp);
N}
N
Ntemplate <class _RandomAccessIterator, class _Compare>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Npartial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,
N             _Compare __comp)
N{
N#ifdef _LIBCPP_DEBUG
S    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;
S    __debug_less<_Compare> __c(__comp);
S    __partial_sort<_Comp_ref>(__first, __middle, __last, __c);
N#else  // _LIBCPP_DEBUG
N    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
N    __partial_sort<_Comp_ref>(__first, __middle, __last, __comp);
N#endif  // _LIBCPP_DEBUG
N}
N
Ntemplate <class _RandomAccessIterator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Npartial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)
N{
N    _VSTD::partial_sort(__first, __middle, __last,
X    std::__2::partial_sort(__first, __middle, __last,
N                       __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
N}
N
N// partial_sort_copy
N
Ntemplate <class _Compare, class _InputIterator, class _RandomAccessIterator>
N_RandomAccessIterator
N__partial_sort_copy(_InputIterator __first, _InputIterator __last,
N                    _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)
N{
N    _RandomAccessIterator __r = __result_first;
N    if (__r != __result_last)
N    {
N        for (; __first != __last && __r != __result_last; (void) ++__first, ++__r)
N            *__r = *__first;
N        __make_heap<_Compare>(__result_first, __r, __comp);
N        typename iterator_traits<_RandomAccessIterator>::difference_type __len = __r - __result_first;
N        for (; __first != __last; ++__first)
N            if (__comp(*__first, *__result_first))
N            {
N                *__result_first = *__first;
N                __sift_down<_Compare>(__result_first, __r, __comp, __len, __result_first);
N            }
N        __sort_heap<_Compare>(__result_first, __r, __comp);
N    }
N    return __r;
N}
N
Ntemplate <class _InputIterator, class _RandomAccessIterator, class _Compare>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_RandomAccessIterator
Npartial_sort_copy(_InputIterator __first, _InputIterator __last,
N                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)
N{
N#ifdef _LIBCPP_DEBUG
S    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;
S    __debug_less<_Compare> __c(__comp);
S    return __partial_sort_copy<_Comp_ref>(__first, __last, __result_first, __result_last, __c);
N#else  // _LIBCPP_DEBUG
N    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
N    return __partial_sort_copy<_Comp_ref>(__first, __last, __result_first, __result_last, __comp);
N#endif  // _LIBCPP_DEBUG
N}
N
Ntemplate <class _InputIterator, class _RandomAccessIterator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_RandomAccessIterator
Npartial_sort_copy(_InputIterator __first, _InputIterator __last,
N                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last)
N{
N    return _VSTD::partial_sort_copy(__first, __last, __result_first, __result_last,
X    return std::__2::partial_sort_copy(__first, __last, __result_first, __result_last,
N                                   __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
N}
N
N// nth_element
N
Ntemplate <class _Compare, class _RandomAccessIterator>
Nvoid
N__nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)
N{
N    // _Compare is known to be a reference type
N    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
N    const difference_type __limit = 7;
N    while (true)
N    {
N    __restart:
N        if (__nth == __last)
N            return;
N        difference_type __len = __last - __first;
N        switch (__len)
N        {
N        case 0:
N        case 1:
N            return;
N        case 2:
N            if (__comp(*--__last, *__first))
N                swap(*__first, *__last);
N            return;
N        case 3:
N            {
N            _RandomAccessIterator __m = __first;
N            _VSTD::__sort3<_Compare>(__first, ++__m, --__last, __comp);
X            std::__2::__sort3<_Compare>(__first, ++__m, --__last, __comp);
N            return;
N            }
N        }
N        if (__len <= __limit)
N        {
N            __selection_sort<_Compare>(__first, __last, __comp);
N            return;
N        }
N        // __len > __limit >= 3
N        _RandomAccessIterator __m = __first + __len/2;
N        _RandomAccessIterator __lm1 = __last;
N        unsigned __n_swaps = _VSTD::__sort3<_Compare>(__first, __m, --__lm1, __comp);
X        unsigned __n_swaps = std::__2::__sort3<_Compare>(__first, __m, --__lm1, __comp);
N        // *__m is median
N        // partition [__first, __m) < *__m and *__m <= [__m, __last)
N        // (this inhibits tossing elements equivalent to __m around unnecessarily)
N        _RandomAccessIterator __i = __first;
N        _RandomAccessIterator __j = __lm1;
N        // j points beyond range to be tested, *__lm1 is known to be <= *__m
N        // The search going up is known to be guarded but the search coming down isn't.
N        // Prime the downward search with a guard.
N        if (!__comp(*__i, *__m))  // if *__first == *__m
N        {
N            // *__first == *__m, *__first doesn't go in first part
N            // manually guard downward moving __j against __i
N            while (true)
N            {
N                if (__i == --__j)
N                {
N                    // *__first == *__m, *__m <= all other elements
N                    // Parition instead into [__first, __i) == *__first and *__first < [__i, __last)
N                    ++__i;  // __first + 1
N                    __j = __last;
N                    if (!__comp(*__first, *--__j))  // we need a guard if *__first == *(__last-1)
N                    {
N                        while (true)
N                        {
N                            if (__i == __j)
N                                return;  // [__first, __last) all equivalent elements
N                            if (__comp(*__first, *__i))
N                            {
N                                swap(*__i, *__j);
N                                ++__n_swaps;
N                                ++__i;
N                                break;
N                            }
N                            ++__i;
N                        }
N                    }
N                    // [__first, __i) == *__first and *__first < [__j, __last) and __j == __last - 1
N                    if (__i == __j)
N                        return;
N                    while (true)
N                    {
N                        while (!__comp(*__first, *__i))
N                            ++__i;
N                        while (__comp(*__first, *--__j))
N                            ;
N                        if (__i >= __j)
N                            break;
N                        swap(*__i, *__j);
N                        ++__n_swaps;
N                        ++__i;
N                    }
N                    // [__first, __i) == *__first and *__first < [__i, __last)
N                    // The first part is sorted,
N                    if (__nth < __i)
N                        return;
N                    // __nth_element the secod part
N                    // __nth_element<_Compare>(__i, __nth, __last, __comp);
N                    __first = __i;
N                    goto __restart;
N                }
N                if (__comp(*__j, *__m))
N                {
N                    swap(*__i, *__j);
N                    ++__n_swaps;
N                    break;  // found guard for downward moving __j, now use unguarded partition
N                }
N            }
N        }
N        ++__i;
N        // j points beyond range to be tested, *__lm1 is known to be <= *__m
N        // if not yet partitioned...
N        if (__i < __j)
N        {
N            // known that *(__i - 1) < *__m
N            while (true)
N            {
N                // __m still guards upward moving __i
N                while (__comp(*__i, *__m))
N                    ++__i;
N                // It is now known that a guard exists for downward moving __j
N                while (!__comp(*--__j, *__m))
N                    ;
N                if (__i >= __j)
N                    break;
N                swap(*__i, *__j);
N                ++__n_swaps;
N                // It is known that __m != __j
N                // If __m just moved, follow it
N                if (__m == __i)
N                    __m = __j;
N                ++__i;
N            }
N        }
N        // [__first, __i) < *__m and *__m <= [__i, __last)
N        if (__i != __m && __comp(*__m, *__i))
N        {
N            swap(*__i, *__m);
N            ++__n_swaps;
N        }
N        // [__first, __i) < *__i and *__i <= [__i+1, __last)
N        if (__nth == __i)
N            return;
N        if (__n_swaps == 0)
N        {
N            // We were given a perfectly partitioned sequence.  Coincidence?
N            if (__nth < __i)
N            {
N                // Check for [__first, __i) already sorted
N                __j = __m = __first;
N                while (++__j != __i)
N                {
N                    if (__comp(*__j, *__m))
N                        // not yet sorted, so sort
N                        goto not_sorted;
N                    __m = __j;
N                }
N                // [__first, __i) sorted
N                return;
N            }
N            else
N            {
N                // Check for [__i, __last) already sorted
N                __j = __m = __i;
N                while (++__j != __last)
N                {
N                    if (__comp(*__j, *__m))
N                        // not yet sorted, so sort
N                        goto not_sorted;
N                    __m = __j;
N                }
N                // [__i, __last) sorted
N                return;
N            }
N        }
Nnot_sorted:
N        // __nth_element on range containing __nth
N        if (__nth < __i)
N        {
N            // __nth_element<_Compare>(__first, __nth, __i, __comp);
N            __last = __i;
N        }
N        else
N        {
N            // __nth_element<_Compare>(__i+1, __nth, __last, __comp);
N            __first = ++__i;
N        }
N    }
N}
N
Ntemplate <class _RandomAccessIterator, class _Compare>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Nnth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)
N{
N#ifdef _LIBCPP_DEBUG
S    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;
S    __debug_less<_Compare> __c(__comp);
S    __nth_element<_Comp_ref>(__first, __nth, __last, __c);
N#else  // _LIBCPP_DEBUG
N    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
N    __nth_element<_Comp_ref>(__first, __nth, __last, __comp);
N#endif  // _LIBCPP_DEBUG
N}
N
Ntemplate <class _RandomAccessIterator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Nnth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last)
N{
N    _VSTD::nth_element(__first, __nth, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
X    std::__2::nth_element(__first, __nth, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
N}
N
N// includes
N
Ntemplate <class _Compare, class _InputIterator1, class _InputIterator2>
Nbool
N__includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,
N           _Compare __comp)
N{
N    for (; __first2 != __last2; ++__first1)
N    {
N        if (__first1 == __last1 || __comp(*__first2, *__first1))
N            return false;
N        if (!__comp(*__first1, *__first2))
N            ++__first2;
N    }
N    return true;
N}
N
Ntemplate <class _InputIterator1, class _InputIterator2, class _Compare>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Nincludes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,
N         _Compare __comp)
N{
N#ifdef _LIBCPP_DEBUG
S    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;
S    __debug_less<_Compare> __c(__comp);
S    return __includes<_Comp_ref>(__first1, __last1, __first2, __last2, __c);
N#else  // _LIBCPP_DEBUG
N    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
N    return __includes<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);
N#endif  // _LIBCPP_DEBUG
N}
N
Ntemplate <class _InputIterator1, class _InputIterator2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Nincludes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2)
N{
N    return _VSTD::includes(__first1, __last1, __first2, __last2,
X    return std::__2::includes(__first1, __last1, __first2, __last2,
N                          __less<typename iterator_traits<_InputIterator1>::value_type,
N                                 typename iterator_traits<_InputIterator2>::value_type>());
N}
N
N// set_union
N
Ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
N_OutputIterator
N__set_union(_InputIterator1 __first1, _InputIterator1 __last1,
N            _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
N{
N    for (; __first1 != __last1; ++__result)
N    {
N        if (__first2 == __last2)
N            return _VSTD::copy(__first1, __last1, __result);
X            return std::__2::copy(__first1, __last1, __result);
N        if (__comp(*__first2, *__first1))
N        {
N            *__result = *__first2;
N            ++__first2;
N        }
N        else
N        {
N            *__result = *__first1;
N            if (!__comp(*__first1, *__first2))
N                ++__first2;
N            ++__first1;
N        }
N    }
N    return _VSTD::copy(__first2, __last2, __result);
X    return std::__2::copy(__first2, __last2, __result);
N}
N
Ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_OutputIterator
Nset_union(_InputIterator1 __first1, _InputIterator1 __last1,
N          _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
N{
N#ifdef _LIBCPP_DEBUG
S    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;
S    __debug_less<_Compare> __c(__comp);
S    return __set_union<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);
N#else  // _LIBCPP_DEBUG
N    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
N    return __set_union<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);
N#endif  // _LIBCPP_DEBUG
N}
N
Ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_OutputIterator
Nset_union(_InputIterator1 __first1, _InputIterator1 __last1,
N          _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
N{
N    return _VSTD::set_union(__first1, __last1, __first2, __last2, __result,
X    return std::__2::set_union(__first1, __last1, __first2, __last2, __result,
N                          __less<typename iterator_traits<_InputIterator1>::value_type,
N                                 typename iterator_traits<_InputIterator2>::value_type>());
N}
N
N// set_intersection
N
Ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
N_OutputIterator
N__set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
N                   _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
N{
N    while (__first1 != __last1 && __first2 != __last2)
N    {
N        if (__comp(*__first1, *__first2))
N            ++__first1;
N        else
N        {
N            if (!__comp(*__first2, *__first1))
N            {
N                *__result = *__first1;
N                ++__result;
N                ++__first1;
N            }
N            ++__first2;
N        }
N    }
N    return __result;
N}
N
Ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_OutputIterator
Nset_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
N                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
N{
N#ifdef _LIBCPP_DEBUG
S    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;
S    __debug_less<_Compare> __c(__comp);
S    return __set_intersection<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);
N#else  // _LIBCPP_DEBUG
N    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
N    return __set_intersection<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);
N#endif  // _LIBCPP_DEBUG
N}
N
Ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_OutputIterator
Nset_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
N                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
N{
N    return _VSTD::set_intersection(__first1, __last1, __first2, __last2, __result,
X    return std::__2::set_intersection(__first1, __last1, __first2, __last2, __result,
N                                  __less<typename iterator_traits<_InputIterator1>::value_type,
N                                         typename iterator_traits<_InputIterator2>::value_type>());
N}
N
N// set_difference
N
Ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
N_OutputIterator
N__set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
N                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
N{
N    while (__first1 != __last1)
N    {
N        if (__first2 == __last2)
N            return _VSTD::copy(__first1, __last1, __result);
X            return std::__2::copy(__first1, __last1, __result);
N        if (__comp(*__first1, *__first2))
N        {
N            *__result = *__first1;
N            ++__result;
N            ++__first1;
N        }
N        else
N        {
N            if (!__comp(*__first2, *__first1))
N                ++__first1;
N            ++__first2;
N        }
N    }
N    return __result;
N}
N
Ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_OutputIterator
Nset_difference(_InputIterator1 __first1, _InputIterator1 __last1,
N               _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
N{
N#ifdef _LIBCPP_DEBUG
S    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;
S    __debug_less<_Compare> __c(__comp);
S    return __set_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);
N#else  // _LIBCPP_DEBUG
N    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
N    return __set_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);
N#endif  // _LIBCPP_DEBUG
N}
N
Ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_OutputIterator
Nset_difference(_InputIterator1 __first1, _InputIterator1 __last1,
N               _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
N{
N    return _VSTD::set_difference(__first1, __last1, __first2, __last2, __result,
X    return std::__2::set_difference(__first1, __last1, __first2, __last2, __result,
N                                __less<typename iterator_traits<_InputIterator1>::value_type,
N                                       typename iterator_traits<_InputIterator2>::value_type>());
N}
N
N// set_symmetric_difference
N
Ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
N_OutputIterator
N__set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
N                           _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
N{
N    while (__first1 != __last1)
N    {
N        if (__first2 == __last2)
N            return _VSTD::copy(__first1, __last1, __result);
X            return std::__2::copy(__first1, __last1, __result);
N        if (__comp(*__first1, *__first2))
N        {
N            *__result = *__first1;
N            ++__result;
N            ++__first1;
N        }
N        else
N        {
N            if (__comp(*__first2, *__first1))
N            {
N                *__result = *__first2;
N                ++__result;
N            }
N            else
N                ++__first1;
N            ++__first2;
N        }
N    }
N    return _VSTD::copy(__first2, __last2, __result);
X    return std::__2::copy(__first2, __last2, __result);
N}
N
Ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_OutputIterator
Nset_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
N                         _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
N{
N#ifdef _LIBCPP_DEBUG
S    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;
S    __debug_less<_Compare> __c(__comp);
S    return __set_symmetric_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);
N#else  // _LIBCPP_DEBUG
N    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
N    return __set_symmetric_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);
N#endif  // _LIBCPP_DEBUG
N}
N
Ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_OutputIterator
Nset_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
N                         _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
N{
N    return _VSTD::set_symmetric_difference(__first1, __last1, __first2, __last2, __result,
X    return std::__2::set_symmetric_difference(__first1, __last1, __first2, __last2, __result,
N                                          __less<typename iterator_traits<_InputIterator1>::value_type,
N                                                 typename iterator_traits<_InputIterator2>::value_type>());
N}
N
N// lexicographical_compare
N
Ntemplate <class _Compare, class _InputIterator1, class _InputIterator2>
Nbool
N__lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
N                          _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)
N{
N    for (; __first2 != __last2; ++__first1, (void) ++__first2)
N    {
N        if (__first1 == __last1 || __comp(*__first1, *__first2))
N            return true;
N        if (__comp(*__first2, *__first1))
N            return false;
N    }
N    return false;
N}
N
Ntemplate <class _InputIterator1, class _InputIterator2, class _Compare>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Nlexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
N                        _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)
N{
N#ifdef _LIBCPP_DEBUG
S    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;
S    __debug_less<_Compare> __c(__comp);
S    return __lexicographical_compare<_Comp_ref>(__first1, __last1, __first2, __last2, __c);
N#else  // _LIBCPP_DEBUG
N    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
N    return __lexicographical_compare<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);
N#endif  // _LIBCPP_DEBUG
N}
N
Ntemplate <class _InputIterator1, class _InputIterator2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Nlexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
N                        _InputIterator2 __first2, _InputIterator2 __last2)
N{
N    return _VSTD::lexicographical_compare(__first1, __last1, __first2, __last2,
X    return std::__2::lexicographical_compare(__first1, __last1, __first2, __last2,
N                                         __less<typename iterator_traits<_InputIterator1>::value_type,
N                                                typename iterator_traits<_InputIterator2>::value_type>());
N}
N
N// next_permutation
N
Ntemplate <class _Compare, class _BidirectionalIterator>
Nbool
N__next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
N{
N    _BidirectionalIterator __i = __last;
N    if (__first == __last || __first == --__i)
N        return false;
N    while (true)
N    {
N        _BidirectionalIterator __ip1 = __i;
N        if (__comp(*--__i, *__ip1))
N        {
N            _BidirectionalIterator __j = __last;
N            while (!__comp(*__i, *--__j))
N                ;
N            swap(*__i, *__j);
N            _VSTD::reverse(__ip1, __last);
X            std::__2::reverse(__ip1, __last);
N            return true;
N        }
N        if (__i == __first)
N        {
N            _VSTD::reverse(__first, __last);
X            std::__2::reverse(__first, __last);
N            return false;
N        }
N    }
N}
N
Ntemplate <class _BidirectionalIterator, class _Compare>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Nnext_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
N{
N#ifdef _LIBCPP_DEBUG
S    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;
S    __debug_less<_Compare> __c(__comp);
S    return __next_permutation<_Comp_ref>(__first, __last, __c);
N#else  // _LIBCPP_DEBUG
N    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
N    return __next_permutation<_Comp_ref>(__first, __last, __comp);
N#endif  // _LIBCPP_DEBUG
N}
N
Ntemplate <class _BidirectionalIterator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Nnext_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)
N{
N    return _VSTD::next_permutation(__first, __last,
X    return std::__2::next_permutation(__first, __last,
N                                  __less<typename iterator_traits<_BidirectionalIterator>::value_type>());
N}
N
N// prev_permutation
N
Ntemplate <class _Compare, class _BidirectionalIterator>
Nbool
N__prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
N{
N    _BidirectionalIterator __i = __last;
N    if (__first == __last || __first == --__i)
N        return false;
N    while (true)
N    {
N        _BidirectionalIterator __ip1 = __i;
N        if (__comp(*__ip1, *--__i))
N        {
N            _BidirectionalIterator __j = __last;
N            while (!__comp(*--__j, *__i))
N                ;
N            swap(*__i, *__j);
N            _VSTD::reverse(__ip1, __last);
X            std::__2::reverse(__ip1, __last);
N            return true;
N        }
N        if (__i == __first)
N        {
N            _VSTD::reverse(__first, __last);
X            std::__2::reverse(__first, __last);
N            return false;
N        }
N    }
N}
N
Ntemplate <class _BidirectionalIterator, class _Compare>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Nprev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
N{
N#ifdef _LIBCPP_DEBUG
S    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;
S    __debug_less<_Compare> __c(__comp);
S    return __prev_permutation<_Comp_ref>(__first, __last, __c);
N#else  // _LIBCPP_DEBUG
N    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
N    return __prev_permutation<_Comp_ref>(__first, __last, __comp);
N#endif  // _LIBCPP_DEBUG
N}
N
Ntemplate <class _BidirectionalIterator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Nprev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)
N{
N    return _VSTD::prev_permutation(__first, __last,
X    return std::__2::prev_permutation(__first, __last,
N                                  __less<typename iterator_traits<_BidirectionalIterator>::value_type>());
N}
N
N_LIBCPP_END_NAMESPACE_STD
X} }
N
N_LIBCPP_POP_MACROS
X_Pragma("pop_macro(\"min\")") _Pragma("pop_macro(\"max\")")
N
N#endif  // _LIBCPP_ALGORITHM
L 57 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/__string" 2
N#include <cstdio>     // For EOF.
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/cstdio" 1
N// -*- C++ -*-
N//===---------------------------- cstdio ----------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is dual licensed under the MIT and the University of Illinois Open
N// Source Licenses. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP_CSTDIO
N#define _LIBCPP_CSTDIO
N
N/*
N    cstdio synopsis
N
NMacros:
N
N    BUFSIZ
N    EOF
N    FILENAME_MAX
N    FOPEN_MAX
N    L_tmpnam
N    NULL
N    SEEK_CUR
N    SEEK_END
N    SEEK_SET
N    TMP_MAX
N    _IOFBF
N    _IOLBF
N    _IONBF
N    stderr
N    stdin
N    stdout
N
Nnamespace std
N{
N
NTypes:
N
NFILE
Nfpos_t
Nsize_t
N
Nint remove(const char* filename);
Nint rename(const char* old, const char* new);
NFILE* tmpfile(void);
Nchar* tmpnam(char* s);
Nint fclose(FILE* stream);
Nint fflush(FILE* stream);
NFILE* fopen(const char* restrict filename, const char* restrict mode);
NFILE* freopen(const char* restrict filename, const char * restrict mode,
N              FILE * restrict stream);
Nvoid setbuf(FILE* restrict stream, char* restrict buf);
Nint setvbuf(FILE* restrict stream, char* restrict buf, int mode, size_t size);
Nint fprintf(FILE* restrict stream, const char* restrict format, ...);
Nint fscanf(FILE* restrict stream, const char * restrict format, ...);
Nint printf(const char* restrict format, ...);
Nint scanf(const char* restrict format, ...);
Nint snprintf(char* restrict s, size_t n, const char* restrict format, ...);    // C99
Nint sprintf(char* restrict s, const char* restrict format, ...);
Nint sscanf(const char* restrict s, const char* restrict format, ...);
Nint vfprintf(FILE* restrict stream, const char* restrict format, va_list arg);
Nint vfscanf(FILE* restrict stream, const char* restrict format, va_list arg);  // C99
Nint vprintf(const char* restrict format, va_list arg);
Nint vscanf(const char* restrict format, va_list arg);                          // C99
Nint vsnprintf(char* restrict s, size_t n, const char* restrict format,         // C99
N              va_list arg);
Nint vsprintf(char* restrict s, const char* restrict format, va_list arg);
Nint vsscanf(const char* restrict s, const char* restrict format, va_list arg); // C99
Nint fgetc(FILE* stream);
Nchar* fgets(char* restrict s, int n, FILE* restrict stream);
Nint fputc(int c, FILE* stream);
Nint fputs(const char* restrict s, FILE* restrict stream);
Nint getc(FILE* stream);
Nint getchar(void);
Nchar* gets(char* s);  // removed in C++14
Nint putc(int c, FILE* stream);
Nint putchar(int c);
Nint puts(const char* s);
Nint ungetc(int c, FILE* stream);
Nsize_t fread(void* restrict ptr, size_t size, size_t nmemb,
N             FILE* restrict stream);
Nsize_t fwrite(const void* restrict ptr, size_t size, size_t nmemb,
N              FILE* restrict stream);
Nint fgetpos(FILE* restrict stream, fpos_t* restrict pos);
Nint fseek(FILE* stream, long offset, int whence);
Nint fsetpos(FILE*stream, const fpos_t* pos);
Nlong ftell(FILE* stream);
Nvoid rewind(FILE* stream);
Nvoid clearerr(FILE* stream);
Nint feof(FILE* stream);
Nint ferror(FILE* stream);
Nvoid perror(const char* s);
N
N}  // std
N*/
N
N#include <__config>
N#include <stdio.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/stdio.h" 1
N/* -*- C++ -*- */
N/*===--------------------------- complex.h --------------------------------===*/
N/*                                                                            */
N/*                     The LLVM Compiler Infrastructure                       */
N/*                                                                            */
N/* This file is dual licensed under the MIT and the University of Illinois Open
N** Source Licenses. See LICENSE.TXT for details.
N*/
N/*===----------------------------------------------------------------------===*/
N
N#if defined(__need_FILE) || defined(__need___FILE)
X#if 0L || 0L
S
S#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
S#pragma GCC system_header
S#endif
S
S#include_next <stdio.h>
S
N#elif !defined(_LIBCPP_STDIO_H)
X#elif !0L
N#define _LIBCPP_STDIO_H
N
N/*
N    stdio.h synopsis
N
NMacros:
N
N    BUFSIZ
N    EOF
N    FILENAME_MAX
N    FOPEN_MAX
N    L_tmpnam
N    NULL
N    SEEK_CUR
N    SEEK_END
N    SEEK_SET
N    TMP_MAX
N    _IOFBF
N    _IOLBF
N    _IONBF
N    stderr
N    stdin
N    stdout
N
NTypes:
N
NFILE
Nfpos_t
Nsize_t
N
Nint remove(const char* filename);
Nint rename(const char* old, const char* new);
NFILE* tmpfile(void);
Nchar* tmpnam(char* s);
Nint fclose(FILE* stream);
Nint fflush(FILE* stream);
NFILE* fopen(const char* restrict filename, const char* restrict mode);
NFILE* freopen(const char* restrict filename, const char * restrict mode,
N              FILE * restrict stream);
Nvoid setbuf(FILE* restrict stream, char* restrict buf);
Nint setvbuf(FILE* restrict stream, char* restrict buf, int mode, size_t size);
Nint fprintf(FILE* restrict stream, const char* restrict format, ...);
Nint fscanf(FILE* restrict stream, const char * restrict format, ...);
Nint printf(const char* restrict format, ...);
Nint scanf(const char* restrict format, ...);
Nint snprintf(char* restrict s, size_t n, const char* restrict format, ...);    // C99
Nint sprintf(char* restrict s, const char* restrict format, ...);
Nint sscanf(const char* restrict s, const char* restrict format, ...);
Nint vfprintf(FILE* restrict stream, const char* restrict format, va_list arg);
Nint vfscanf(FILE* restrict stream, const char* restrict format, va_list arg);  // C99
Nint vprintf(const char* restrict format, va_list arg);
Nint vscanf(const char* restrict format, va_list arg);                          // C99
Nint vsnprintf(char* restrict s, size_t n, const char* restrict format,         // C99
N              va_list arg);
Nint vsprintf(char* restrict s, const char* restrict format, va_list arg);
Nint vsscanf(const char* restrict s, const char* restrict format, va_list arg); // C99
Nint fgetc(FILE* stream);
Nchar* fgets(char* restrict s, int n, FILE* restrict stream);
Nint fputc(int c, FILE* stream);
Nint fputs(const char* restrict s, FILE* restrict stream);
Nint getc(FILE* stream);
Nint getchar(void);
Nchar* gets(char* s);  // removed in C++14
Nint putc(int c, FILE* stream);
Nint putchar(int c);
Nint puts(const char* s);
Nint ungetc(int c, FILE* stream);
Nsize_t fread(void* restrict ptr, size_t size, size_t nmemb,
N             FILE* restrict stream);
Nsize_t fwrite(const void* restrict ptr, size_t size, size_t nmemb,
N              FILE* restrict stream);
Nint fgetpos(FILE* restrict stream, fpos_t* restrict pos);
Nint fseek(FILE* stream, long offset, int whence);
Nint fsetpos(FILE*stream, const fpos_t* pos);
Nlong ftell(FILE* stream);
Nvoid rewind(FILE* stream);
Nvoid clearerr(FILE* stream);
Nint feof(FILE* stream);
Nint ferror(FILE* stream);
Nvoid perror(const char* s);
N*/
N
N#include <__config>
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N#include_next <stdio.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/stdio.h" 1
N/*****************************************************************************/
N/* STDIO.H                                                                   */
N/*                                                                           */
N/* Copyright (c) 1993 Texas Instruments Incorporated                         */
N/* http://www.ti.com/                                                        */
N/*                                                                           */
N/*  Redistribution and  use in source  and binary forms, with  or without    */
N/*  modification,  are permitted provided  that the  following conditions    */
N/*  are met:                                                                 */
N/*                                                                           */
N/*     Redistributions  of source  code must  retain the  above copyright    */
N/*     notice, this list of conditions and the following disclaimer.         */
N/*                                                                           */
N/*     Redistributions in binary form  must reproduce the above copyright    */
N/*     notice, this  list of conditions  and the following  disclaimer in    */
N/*     the  documentation  and/or   other  materials  provided  with  the    */
N/*     distribution.                                                         */
N/*                                                                           */
N/*     Neither the  name of Texas Instruments Incorporated  nor the names    */
N/*     of its  contributors may  be used to  endorse or  promote products    */
N/*     derived  from   this  software  without   specific  prior  written    */
N/*     permission.                                                           */
N/*                                                                           */
N/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS    */
N/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT    */
N/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    */
N/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT    */
N/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    */
N/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT    */
N/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    */
N/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    */
N/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT    */
N/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    */
N/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     */
N/*                                                                           */
N/*****************************************************************************/
N#ifndef _STDIO_H_
N#define _STDIO_H_
N
N#if defined(__TMS320C2000__)
X#if 0L
S#if defined(__TMS320C28XX_CLA__)
S#error "Header file <stdio.h> not supported by CLA compiler"
S#endif
N#endif
N
N#include <_ti_config.h>
N#include <stdarg.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/stdarg.h" 1
N/*****************************************************************************/
N/* stdarg.h                                                                  */
N/*                                                                           */
N/* Copyright (c) 1996 Texas Instruments Incorporated                         */
N/* http://www.ti.com/                                                        */
N/*                                                                           */
N/*  Redistribution and  use in source  and binary forms, with  or without    */
N/*  modification,  are permitted provided  that the  following conditions    */
N/*  are met:                                                                 */
N/*                                                                           */
N/*     Redistributions  of source  code must  retain the  above copyright    */
N/*     notice, this list of conditions and the following disclaimer.         */
N/*                                                                           */
N/*     Redistributions in binary form  must reproduce the above copyright    */
N/*     notice, this  list of conditions  and the following  disclaimer in    */
N/*     the  documentation  and/or   other  materials  provided  with  the    */
N/*     distribution.                                                         */
N/*                                                                           */
N/*     Neither the  name of Texas Instruments Incorporated  nor the names    */
N/*     of its  contributors may  be used to  endorse or  promote products    */
N/*     derived  from   this  software  without   specific  prior  written    */
N/*     permission.                                                           */
N/*                                                                           */
N/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS    */
N/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT    */
N/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    */
N/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT    */
N/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    */
N/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT    */
N/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    */
N/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    */
N/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT    */
N/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    */
N/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     */
N/*                                                                           */
N/*****************************************************************************/
N
N#ifndef _STDARG
N#define _STDARG
N
N#pragma diag_push
N#pragma CHECK_MISRA("-19.7") /* need function-like macros */
N#pragma CHECK_MISRA("-19.10") /* need types as macro arguments */
N#pragma CHECK_MISRA("-20.1") /* standard headers must define standard names */
N#pragma CHECK_MISRA("-20.2") /* standard headers must define standard names */
N
N#include <sys/_types.h>  /* For __va_list */
N
N#ifndef _VA_LIST_DECLARED
S#define _VA_LIST_DECLARED
Stypedef __va_list va_list;
N#endif
N
N#define _VA_RNDUP(sz) 	(((sz) + 3) & ~3)
N#define _VA_MASK(tp)     ((__ALIGNOF__(tp) == 8) ? 7 : 3)
N#define _VA_ALN(ap,tp)  (((int)(ap) + _VA_MASK(tp)) & ~(_VA_MASK(tp)))
N
N#define va_start(ap, parmN)						      \
N   ((ap).__ap = ((void *)((((int)__va_parmadr(parmN))&~3) +                   \
N		                              _VA_RNDUP(sizeof(parmN)))))
X#define va_start(ap, parmN)						         ((ap).__ap = ((void *)((((int)__va_parmadr(parmN))&~3) +                   		                              _VA_RNDUP(sizeof(parmN)))))
N
N#ifdef __big_endian__
S#define va_arg(_ap, _type)					 	      \
S    (((_ap).__ap = (void*)(_VA_ALN((_ap).__ap, _type) +                       \
S			                         _VA_RNDUP(sizeof(_type)))),  \
S     (*(_type *)((int)(_ap).__ap -                                            \
S		   (__va_argcsu(_type) ? _VA_RNDUP(sizeof(_type))	      \
S		                       : (sizeof(_type))))))
X#define va_arg(_ap, _type)					 	          (((_ap).__ap = (void*)(_VA_ALN((_ap).__ap, _type) +                       			                         _VA_RNDUP(sizeof(_type)))),       (*(_type *)((int)(_ap).__ap -                                            		   (__va_argcsu(_type) ? _VA_RNDUP(sizeof(_type))	      		                       : (sizeof(_type))))))
N#else
N#define va_arg(_ap, _type) 						      \
N   (((_ap).__ap = (void *)(_VA_ALN((_ap).__ap,_type) +                        \
N			   _VA_RNDUP(sizeof(_type)))),                        \
N	     (*(_type *) ((int)(_ap).__ap - _VA_RNDUP(sizeof(_type)))))
X#define va_arg(_ap, _type) 						         (((_ap).__ap = (void *)(_VA_ALN((_ap).__ap,_type) +                        			   _VA_RNDUP(sizeof(_type)))),                        	     (*(_type *) ((int)(_ap).__ap - _VA_RNDUP(sizeof(_type)))))
N#endif
N
N#define va_end(ap) ((void)0)
N#define va_copy(dst, src) ((dst)=(src))
N
N
N#pragma diag_pop
N
N#endif /* _STDARG */
N
L 48 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/stdio.h" 2
N
N#pragma diag_push
N#pragma CHECK_MISRA("-20.2") /* reuse of standard macros/objects/funcs */
N#pragma CHECK_MISRA("-20.1") /* redefining reserved identifiers */
N#pragma CHECK_MISRA("-19.7") /* use function instead of function-like macro */
N#pragma CHECK_MISRA("-19.4") /* macros should have only simple expansions */
N#pragma CHECK_MISRA("-19.1") /* include should follow directive or comment */
N#pragma CHECK_MISRA("-16.3") /* parameters without names */
N#pragma CHECK_MISRA("-6.3")  /* use size/sign-specific typedefs */
N
N/*---------------------------------------------------------------------------*/
N/* Attributes are only available in relaxed ANSI mode.                       */
N/*---------------------------------------------------------------------------*/
N#ifndef __ATTRIBUTE
S#define __ATTRIBUTE(attr) __attribute__(attr)
N#endif
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
N/****************************************************************************/
N/* TYPES THAT ANSI REQUIRES TO BE DEFINED                                   */
N/****************************************************************************/
N#ifndef _SIZE_T_DECLARED
S#define _SIZE_T_DECLARED
S#ifdef __clang__
Stypedef __SIZE_TYPE__ size_t;
S#else
Stypedef __SIZE_T_TYPE__ size_t;
S#endif
N#endif
N
Nstruct __sFILE {
N      int fd;                    /* File descriptor */
N      unsigned char* buf;        /* Pointer to start of buffer */
N      unsigned char* pos;        /* Position in buffer */
N      unsigned char* bufend;     /* Pointer to end of buffer */
N      unsigned char* buff_stop;  /* Pointer to last read char in buffer */
N      unsigned int   flags;      /* File status flags (see below) */
N};
N
N#ifndef _STDFILE_DECLARED
S#define _STDFILE_DECLARED
Stypedef struct __sFILE FILE;
N#endif
N
N#ifndef _FPOS_T
N#define _FPOS_T
N#if defined(_AEABI_PORTABILITY_LEVEL) && _AEABI_PORTABILITY_LEVEL != 0
X#if 0L && _AEABI_PORTABILITY_LEVEL != 0
Stypedef struct __fpos_t_struct {
S    unsigned long long __pos;
S    struct {
S        unsigned int __state1, __state2;
S    } __mbstate;
S} fpos_t;
S#elif !defined(__C6X_MIGRATION__) && (defined(_TMS320C6X) || defined(__TMS320C6X__))
X#elif !0L && (0L || 0L)
Stypedef int fpos_t;
N#else
Ntypedef long fpos_t;
N#endif /* c6x */
N#endif /* _FPOS_T */
N
N/****************************************************************************/
N/* DEVICE AND STREAM RELATED MACROS                                         */
N/****************************************************************************/
N/****************************************************************************/
N/* MACROS THAT DEFINE AND USE FILE STATUS FLAGS                             */
N/****************************************************************************/
N#if defined(_AEABI_PORTABILITY_LEVEL) && _AEABI_PORTABILITY_LEVEL != 0
X#if 0L && _AEABI_PORTABILITY_LEVEL != 0
Sextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
S#define stdin  (__aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__aeabi_L_tmpnam)
S
N#else /* _AEABI_PORTABILITY_LEVEL */
N
N#define _IOFBF       0x0001
N#define _IOLBF       0x0002
N#define _IONBF       0x0004
N#define _BUFFALOC    0x0008
N#define _MODER       0x0010
N#define _MODEW       0x0020
N#define _MODERW      0x0040
N#define _MODEA       0x0080
N#define _MODEBIN     0x0100
N#define _STATEOF     0x0200
N#define _STATERR     0x0400
N#define _UNGETC      0x0800
N#define _TMPFILE     0x1000
N
N#define _SET(_fp, _b)      (((_fp)->flags) |= (_b))
N#define _UNSET(_fp, _b)    (((_fp)->flags) &= ~(_b))
N#define _STCHK(_fp, _b)    (((_fp)->flags) & (_b))
N#define _BUFFMODE(_fp)     (((_fp)->flags) & (_IOFBF | _IOLBF | _IONBF))
N#define _ACCMODE(_fp)      (((_fp)->flags) & (_MODER | _MODEW))
N
N/****************************************************************************/
N/* MACROS THAT ANSI REQUIRES TO BE DEFINED                                  */
N/****************************************************************************/
N#define BUFSIZ          256
N
N#define FOPEN_MAX       _NFILE
N#define FILENAME_MAX    256
N#define TMP_MAX         65535
N
N#define stdin     (&_ftable[0])
N#define stdout    (&_ftable[1])
N#define stderr    (&_ftable[2])
N
N#define L_tmpnam  _LTMPNAM
N
N#endif /* _AEABI_PORTABILITY_LEVEL */
N
N#define SEEK_SET  (0x0000)
N#define SEEK_CUR  (0x0001)
N#define SEEK_END  (0x0002)
N
N#ifndef NULL
S#define NULL 0
N#endif
N
N#ifndef EOF
N#define EOF    (-1)
N#endif
N
N/******** END OF ANSI MACROS ************************************************/
N
N#define P_tmpdir        ""                   /* Path for temp files         */
N
N/****************************************************************************/
N/* DEVICE AND STREAM RELATED DATA STRUCTURES AND MACROS                     */
N/****************************************************************************/
N#if defined(__TMS320C6X__)
X#if 0L
S#define _NFILE           20                   /* Max number of files open   */
N#else
N#define _NFILE           10                   /* Max number of files open   */
N#endif
N#define _LTMPNAM         16                   /* Length of temp name        */
N
Nextern _DATA_ACCESS FILE _ftable[_NFILE];
Xextern  FILE _ftable[10];
Nextern _DATA_ACCESS char __TI_tmpnams[_NFILE][_LTMPNAM];
Xextern  char __TI_tmpnams[10][16];
N
N/****************************************************************************/
N/*   FUNCTION DEFINITIONS  - ANSI                                           */
N/****************************************************************************/
N/****************************************************************************/
N/* OPERATIONS ON FILES                                                      */
N/****************************************************************************/
Nextern _CODE_ACCESS int     remove(const char *_file);
Xextern  int     remove(const char *_file);
Nextern _CODE_ACCESS int     rename(const char *_old, const char *_new);
Xextern  int     rename(const char *_old, const char *_new);
Nextern _CODE_ACCESS FILE   *tmpfile(void);
Xextern  FILE   *tmpfile(void);
Nextern _CODE_ACCESS char   *tmpnam(char *_s);
Xextern  char   *tmpnam(char *_s);
N
N/****************************************************************************/
N/* FILE ACCESS FUNCTIONS                                                    */
N/****************************************************************************/
Nextern _CODE_ACCESS int     fclose(FILE * __restrict _fp);
Xextern  int     fclose(FILE * __restrict _fp);
Nextern _CODE_ACCESS FILE   *fopen(const char * __restrict _fname,
Xextern  FILE   *fopen(const char * __restrict _fname,
N                                  const char * __restrict _mode);
Nextern _CODE_ACCESS FILE   *freopen(const char * __restrict _fname,
Xextern  FILE   *freopen(const char * __restrict _fname,
N                                    const char * __restrict _mode,
N			            FILE * __restrict _fp);
Nextern _CODE_ACCESS void    setbuf(FILE * __restrict _fp,
Xextern  void    setbuf(FILE * __restrict _fp,
N                                   char * __restrict _buf);
Nextern _CODE_ACCESS int     setvbuf(FILE * __restrict _fp,
Xextern  int     setvbuf(FILE * __restrict _fp,
N                                    char * __restrict _buf,
N			            int _type, size_t _size);
Nextern _CODE_ACCESS int     fflush(FILE *_fp);
Xextern  int     fflush(FILE *_fp);
N
N/****************************************************************************/
N/* FORMATTED INPUT/OUTPUT FUNCTIONS                                         */
N/****************************************************************************/
Nextern _CODE_ACCESS int fprintf(FILE * __restrict _fp,
Xextern  int fprintf(FILE * __restrict _fp,
N                                const char * __restrict _format, ...)
N               __ATTRIBUTE ((__format__ (__printf__, 2, 3)));
X               __attribute__((__format__ (__printf__, 2, 3)));
Nextern _CODE_ACCESS int fscanf(FILE * __restrict _fp,
Xextern  int fscanf(FILE * __restrict _fp,
N                               const char * __restrict _fmt, ...)
N               __ATTRIBUTE ((__format__ (__scanf__, 2, 3)));
X               __attribute__((__format__ (__scanf__, 2, 3)));
Nextern _CODE_ACCESS int printf(const char * __restrict _format, ...)
Xextern  int printf(const char * __restrict _format, ...)
N               __ATTRIBUTE ((__format__ (__printf__, 1, 2)));
X               __attribute__((__format__ (__printf__, 1, 2)));
Nextern _CODE_ACCESS int scanf(const char * __restrict _fmt, ...)
Xextern  int scanf(const char * __restrict _fmt, ...)
N               __ATTRIBUTE ((__format__ (__scanf__, 1, 2)));
X               __attribute__((__format__ (__scanf__, 1, 2)));
Nextern _CODE_ACCESS int sprintf(char * __restrict _string,
Xextern  int sprintf(char * __restrict _string,
N                                const char * __restrict _format, ...)
N               __ATTRIBUTE ((__format__ (__printf__, 2, 3)));
X               __attribute__((__format__ (__printf__, 2, 3)));
Nextern _CODE_ACCESS int snprintf(char * __restrict _string, size_t _n,
Xextern  int snprintf(char * __restrict _string, size_t _n,
N				 const char * __restrict _format, ...)
N               __ATTRIBUTE ((__format__ (__printf__, 3, 4)));
X               __attribute__((__format__ (__printf__, 3, 4)));
Nextern _CODE_ACCESS int sscanf(const char * __restrict _str,
Xextern  int sscanf(const char * __restrict _str,
N                               const char * __restrict _fmt, ...)
N               __ATTRIBUTE ((__format__ (__scanf__, 2, 3)));
X               __attribute__((__format__ (__scanf__, 2, 3)));
Nextern _CODE_ACCESS int vfprintf(FILE * __restrict _fp,
Xextern  int vfprintf(FILE * __restrict _fp,
N                                 const char * __restrict _format, va_list _ap)
N               __ATTRIBUTE ((__format__ (__printf__, 2, 0)));
X               __attribute__((__format__ (__printf__, 2, 0)));
Nextern _CODE_ACCESS int vfscanf(FILE * __restrict _fp,
Xextern  int vfscanf(FILE * __restrict _fp,
N                                const char * __restrict _fmt, va_list _ap)
N               __ATTRIBUTE ((__format__ (__scanf__, 2, 0)));
X               __attribute__((__format__ (__scanf__, 2, 0)));
Nextern _CODE_ACCESS int vprintf(const char * __restrict _format, va_list _ap)
Xextern  int vprintf(const char * __restrict _format, va_list _ap)
N               __ATTRIBUTE ((__format__ (__printf__, 1, 0)));
X               __attribute__((__format__ (__printf__, 1, 0)));
Nextern _CODE_ACCESS int vscanf(const char * __restrict _format, va_list _ap)
Xextern  int vscanf(const char * __restrict _format, va_list _ap)
N               __ATTRIBUTE ((__format__ (__scanf__, 1, 0)));
X               __attribute__((__format__ (__scanf__, 1, 0)));
Nextern _CODE_ACCESS int vsprintf(char * __restrict _string,
Xextern  int vsprintf(char * __restrict _string,
N                                 const char * __restrict _format, va_list _ap)
N               __ATTRIBUTE ((__format__ (__printf__, 2, 0)));
X               __attribute__((__format__ (__printf__, 2, 0)));
Nextern _CODE_ACCESS int vsnprintf(char * __restrict _string, size_t _n,
Xextern  int vsnprintf(char * __restrict _string, size_t _n,
N				  const char * __restrict _format, va_list _ap)
N               __ATTRIBUTE ((__format__ (__printf__, 3, 0)));
X               __attribute__((__format__ (__printf__, 3, 0)));
Nextern _CODE_ACCESS int vsscanf(const char * __restrict _str,
Xextern  int vsscanf(const char * __restrict _str,
N                                const char * __restrict _fmt, va_list _ap)
N               __ATTRIBUTE ((__format__ (__scanf__, 2, 0)));
X               __attribute__((__format__ (__scanf__, 2, 0)));
Nextern _CODE_ACCESS int	asprintf(char **, const char *, ...)
Xextern  int	asprintf(char **, const char *, ...)
N               __ATTRIBUTE ((__format__ (__printf__, 2, 3)));
X               __attribute__((__format__ (__printf__, 2, 3)));
Nextern _CODE_ACCESS int	vasprintf(char **, const char *, va_list)
Xextern  int	vasprintf(char **, const char *, va_list)
N               __ATTRIBUTE ((__format__ (__printf__, 2, 0)));
X               __attribute__((__format__ (__printf__, 2, 0)));
N
N/****************************************************************************/
N/* CHARACTER INPUT/OUTPUT FUNCTIONS                                         */
N/****************************************************************************/
Nextern _CODE_ACCESS int     fgetc(FILE *_fp);
Xextern  int     fgetc(FILE *_fp);
Nextern _CODE_ACCESS char   *fgets(char * __restrict _ptr, int _size,
Xextern  char   *fgets(char * __restrict _ptr, int _size,
N				  FILE * __restrict _fp);
Nextern _CODE_ACCESS int     fputc(int _c, FILE *_fp);
Xextern  int     fputc(int _c, FILE *_fp);
Nextern _CODE_ACCESS int     fputs(const char * __restrict _ptr,
Xextern  int     fputs(const char * __restrict _ptr,
N                                  FILE * __restrict _fp);
Nextern _CODE_ACCESS int     getc(FILE *_p);
Xextern  int     getc(FILE *_p);
Nextern _CODE_ACCESS int     getchar(void);
Xextern  int     getchar(void);
Nextern _CODE_ACCESS char   *gets(char *_ptr);
Xextern  char   *gets(char *_ptr);
Nextern _CODE_ACCESS int     putc(int _x, FILE *_fp);
Xextern  int     putc(int _x, FILE *_fp);
Nextern _CODE_ACCESS int     putchar(int _x);
Xextern  int     putchar(int _x);
Nextern _CODE_ACCESS int     puts(const char *_ptr);
Xextern  int     puts(const char *_ptr);
Nextern _CODE_ACCESS int     ungetc(int _c, FILE *_fp);
Xextern  int     ungetc(int _c, FILE *_fp);
N
N/****************************************************************************/
N/* DIRECT INPUT/OUTPUT FUNCTIONS                                            */
N/****************************************************************************/
Nextern _CODE_ACCESS size_t  fread(void * __restrict _ptr,
Xextern  size_t  fread(void * __restrict _ptr,
N                                  size_t _size, size_t _count,
N				  FILE * __restrict _fp);
Nextern _CODE_ACCESS size_t  fwrite(const void * __restrict _ptr,
Xextern  size_t  fwrite(const void * __restrict _ptr,
N                                   size_t _size, size_t _count,
N                                   FILE * __restrict _fp);
N
N/****************************************************************************/
N/* FILE POSITIONING FUNCTIONS                                               */
N/****************************************************************************/
Nextern _CODE_ACCESS int     fgetpos(FILE * __restrict _fp,
Xextern  int     fgetpos(FILE * __restrict _fp,
N                                    fpos_t * __restrict _pos);
Nextern _CODE_ACCESS int     fseek(FILE *_fp, long _offset,
Xextern  int     fseek(FILE *_fp, long _offset,
N				  int _ptrname);
Nextern _CODE_ACCESS int     fsetpos(FILE * __restrict _fp,
Xextern  int     fsetpos(FILE * __restrict _fp,
N                                    const fpos_t * __restrict _pos);
Nextern _CODE_ACCESS long    ftell(FILE *_fp);
Xextern  long    ftell(FILE *_fp);
Nextern _CODE_ACCESS void    rewind(FILE *_fp);
Xextern  void    rewind(FILE *_fp);
N
N/****************************************************************************/
N/* ERROR-HANDLING FUNCTIONS                                                 */
N/****************************************************************************/
Nextern _CODE_ACCESS void    clearerr(FILE *_fp);
Xextern  void    clearerr(FILE *_fp);
Nextern _CODE_ACCESS int     feof(FILE *_fp);
Xextern  int     feof(FILE *_fp);
Nextern _CODE_ACCESS int     ferror(FILE *_fp);
Xextern  int     ferror(FILE *_fp);
Nextern _CODE_ACCESS void    perror(const char *_s);
Xextern  void    perror(const char *_s);
N
N#define _getchar()      getc(stdin)
N#define _putchar(_x)    putc((_x), stdout)
N#define _clearerr(_fp)   ((void) ((_fp)->flags &= ~(_STATERR | _STATEOF)))
N
N#define _ferror(_x)     ((_x)->flags & _STATERR)
N
N#define _remove(_fl)    (unlink((_fl)))
N
N#ifdef __cplusplus
N} /* extern "C" */
N#endif  /* __cplusplus */
N
N#pragma diag_pop
N
N#if defined(_AEABI_PORTABILITY_LEVEL) && _AEABI_PORTABILITY_LEVEL != 0 && \
N   !defined(_AEABI_PORTABLE)
X#if 0L && _AEABI_PORTABILITY_LEVEL != 0 &&    !0L
S#define _AEABI_PORTABLE
N#endif
N
N/*----------------------------------------------------------------------------*/
N/* If sys/cdefs.h is available, go ahead and include it. xlocale.h assumes    */
N/* this file will have already included sys/cdefs.h.                          */
N/*----------------------------------------------------------------------------*/
N#if __has_include(<sys/cdefs.h>)
X#if 1
N#include <sys/cdefs.h>
N#endif
N
N/*----------------------------------------------------------------------------*/
N/* Include xlocale/_stdio.h if xlocale.h has already been included. This is   */
N/* to conform with FreeBSD's xlocale implementation.                          */
N/*----------------------------------------------------------------------------*/
N#ifdef _XLOCALE_H_
S__BEGIN_DECLS
S#include <xlocale/_stdio.h>
S__END_DECLS
N#endif
N
N#endif  /* #ifndef _STDIO_H_ */
L 109 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/stdio.h" 2
N
N#ifdef __cplusplus
N
N/* snprintf */
N#if defined(_LIBCPP_MSVCRT_LIKE)
X#if 0L
Sextern "C" {
Sint vasprintf(char **sptr, const char *__restrict fmt, va_list ap);
S}
N#endif
N
N#undef getc
N#undef putc
N#undef clearerr
N#undef feof
N#undef ferror
N
N#endif
N
N#endif  /* _LIBCPP_STDIO_H */
L 101 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/cstdio" 2
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N_LIBCPP_BEGIN_NAMESPACE_STD
Xnamespace std { inline namespace __2 {
N
Nusing ::FILE;
Nusing ::fpos_t;
Nusing ::size_t;
N
Nusing ::fclose;
Nusing ::fflush;
Nusing ::setbuf;
Nusing ::setvbuf;
Nusing ::fprintf;
Nusing ::fscanf;
Nusing ::snprintf;
Nusing ::sprintf;
Nusing ::sscanf;
Nusing ::vfprintf;
Nusing ::vfscanf;
Nusing ::vsscanf;
Nusing ::vsnprintf;
Nusing ::vsprintf;
Nusing ::fgetc;
Nusing ::fgets;
Nusing ::fputc;
Nusing ::fputs;
Nusing ::getc;
Nusing ::putc;
Nusing ::ungetc;
Nusing ::fread;
Nusing ::fwrite;
Nusing ::fgetpos;
Nusing ::fseek;
Nusing ::fsetpos;
Nusing ::ftell;
Nusing ::rewind;
Nusing ::clearerr;
Nusing ::feof;
Nusing ::ferror;
Nusing ::perror;
N
N#ifndef _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE
Nusing ::fopen;
Nusing ::freopen;
Nusing ::remove;
Nusing ::rename;
Nusing ::tmpfile;
Nusing ::tmpnam;
N#endif
N
N#ifndef _LIBCPP_HAS_NO_STDIN
Nusing ::getchar;
N#if _LIBCPP_STD_VER <= 11 && !defined(_LIBCPP_MSVCRT)
X#if 14 <= 11 && !0L
Susing ::gets;
N#endif
Nusing ::scanf;
Nusing ::vscanf;
N#endif
N
N#ifndef _LIBCPP_HAS_NO_STDOUT
Nusing ::printf;
Nusing ::putchar;
Nusing ::puts;
Nusing ::vprintf;
N#endif
N
N_LIBCPP_END_NAMESPACE_STD
X} }
N
N#endif  // _LIBCPP_CSTDIO
L 58 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/__string" 2
N#include <memory>     // for __murmur2_or_cityhash
N
N#include <__debug>
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N_LIBCPP_PUSH_MACROS
X_Pragma("push_macro(\"min\")") _Pragma("push_macro(\"max\")")
N#include <__undef_macros>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/__undef_macros" 1
N// -*- C++ -*-
N//===------------------------ __undef_macros ------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is distributed under the University of Illinois Open Source
N// License. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N
N#ifdef min
S#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
S#if defined(_LIBCPP_WARNING)
S_LIBCPP_WARNING("macro min is incompatible with C++.  Try #define NOMINMAX "
S                "before any Windows header. #undefing min")
S#else
S#warning: macro min is incompatible with C++.  #undefing min
S#endif
S#endif
S#undef min
N#endif
N
N#ifdef max
S#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
S#if defined(_LIBCPP_WARNING)
S_LIBCPP_WARNING("macro max is incompatible with C++.  Try #define NOMINMAX "
S                "before any Windows header. #undefing max")
S#else
S#warning: macro max is incompatible with C++.  #undefing max
S#endif
S#endif
S#undef max
N#endif
L 68 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/__string" 2
N
N
N_LIBCPP_BEGIN_NAMESPACE_STD
Xnamespace std { inline namespace __2 {
N
N// char_traits
N
Ntemplate <class _CharT>
Nstruct _LIBCPP_TEMPLATE_VIS char_traits
Xstruct  char_traits
N{
N    typedef _CharT    char_type;
N    typedef int       int_type;
N    typedef streamoff off_type;
N    typedef streampos pos_type;
N    typedef mbstate_t state_type;
N
N    static inline void _LIBCPP_CONSTEXPR_AFTER_CXX14
X    static inline void 
N        assign(char_type& __c1, const char_type& __c2) _NOEXCEPT {__c1 = __c2;}
X        assign(char_type& __c1, const char_type& __c2) noexcept {__c1 = __c2;}
N    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT
X    static inline constexpr bool eq(char_type __c1, char_type __c2) noexcept
N        {return __c1 == __c2;}
N    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT
X    static inline constexpr bool lt(char_type __c1, char_type __c2) noexcept
N        {return __c1 < __c2;}
N
N    static _LIBCPP_CONSTEXPR_AFTER_CXX14
X    static 
N    int compare(const char_type* __s1, const char_type* __s2, size_t __n);
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14
X    __attribute__ ((__always_inline__)) static 
N    size_t length(const char_type* __s);
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14
X    __attribute__ ((__always_inline__)) static 
N    const char_type* find(const char_type* __s, size_t __n, const char_type& __a);
N    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n);
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n);
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    static char_type*       assign(char_type* __s, size_t __n, char_type __a);
N
N    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT
X    static inline constexpr int_type  not_eof(int_type __c) noexcept
N        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
N    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT
X    static inline constexpr char_type to_char_type(int_type __c) noexcept
N        {return char_type(__c);}
N    static inline _LIBCPP_CONSTEXPR int_type  to_int_type(char_type __c) _NOEXCEPT
X    static inline constexpr int_type  to_int_type(char_type __c) noexcept
N        {return int_type(__c);}
N    static inline _LIBCPP_CONSTEXPR bool      eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT
X    static inline constexpr bool      eq_int_type(int_type __c1, int_type __c2) noexcept
N        {return __c1 == __c2;}
N    static inline _LIBCPP_CONSTEXPR int_type  eof() _NOEXCEPT
X    static inline constexpr int_type  eof() noexcept
N        {return int_type(EOF);}
X        {return int_type((-1));}
N};
N
Ntemplate <class _CharT>
N_LIBCPP_CONSTEXPR_AFTER_CXX14 int
X int
Nchar_traits<_CharT>::compare(const char_type* __s1, const char_type* __s2, size_t __n)
N{
N    for (; __n; --__n, ++__s1, ++__s2)
N    {
N        if (lt(*__s1, *__s2))
N            return -1;
N        if (lt(*__s2, *__s1))
N            return 1;
N    }
N    return 0;
N}
N
Ntemplate <class _CharT>
Ninline
N_LIBCPP_CONSTEXPR_AFTER_CXX14 size_t
X size_t
Nchar_traits<_CharT>::length(const char_type* __s)
N{
N    size_t __len = 0;
N    for (; !eq(*__s, char_type(0)); ++__s)
N        ++__len;
N    return __len;
N}
N
Ntemplate <class _CharT>
Ninline
N_LIBCPP_CONSTEXPR_AFTER_CXX14 const _CharT*
X const _CharT*
Nchar_traits<_CharT>::find(const char_type* __s, size_t __n, const char_type& __a)
N{
N    for (; __n; --__n)
N    {
N        if (eq(*__s, __a))
N            return __s;
N        ++__s;
N    }
N    return 0;
N}
N
Ntemplate <class _CharT>
N_CharT*
Nchar_traits<_CharT>::move(char_type* __s1, const char_type* __s2, size_t __n)
N{
N    char_type* __r = __s1;
N    if (__s1 < __s2)
N    {
N        for (; __n; --__n, ++__s1, ++__s2)
N            assign(*__s1, *__s2);
N    }
N    else if (__s2 < __s1)
N    {
N        __s1 += __n;
N        __s2 += __n;
N        for (; __n; --__n)
N            assign(*--__s1, *--__s2);
N    }
N    return __r;
N}
N
Ntemplate <class _CharT>
Ninline
N_CharT*
Nchar_traits<_CharT>::copy(char_type* __s1, const char_type* __s2, size_t __n)
N{
N    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, "char_traits::copy overlapped range");
X    ((void)0);
N    char_type* __r = __s1;
N    for (; __n; --__n, ++__s1, ++__s2)
N        assign(*__s1, *__s2);
N    return __r;
N}
N
Ntemplate <class _CharT>
Ninline
N_CharT*
Nchar_traits<_CharT>::assign(char_type* __s, size_t __n, char_type __a)
N{
N    char_type* __r = __s;
N    for (; __n; --__n, ++__s)
N        assign(*__s, __a);
N    return __r;
N}
N
N// char_traits<char>
N
Ntemplate <>
Nstruct _LIBCPP_TEMPLATE_VIS char_traits<char>
Xstruct  char_traits<char>
N{
N    typedef char      char_type;
N    typedef int       int_type;
N    typedef streamoff off_type;
N    typedef streampos pos_type;
N    typedef mbstate_t state_type;
N
N    static inline _LIBCPP_CONSTEXPR_AFTER_CXX14
X    static inline 
N    void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT {__c1 = __c2;}
X    void assign(char_type& __c1, const char_type& __c2) noexcept {__c1 = __c2;}
N    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT
X    static inline constexpr bool eq(char_type __c1, char_type __c2) noexcept
N            {return __c1 == __c2;}
N    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT
X    static inline constexpr bool lt(char_type __c1, char_type __c2) noexcept
N        {return __c1 < __c2;}
N
N    static _LIBCPP_CONSTEXPR_AFTER_CXX14
X    static 
N    int compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;
X    int compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept;
N    static inline size_t _LIBCPP_CONSTEXPR_AFTER_CXX14
X    static inline size_t 
N    length(const char_type* __s)  _NOEXCEPT {return __builtin_strlen(__s);}
X    length(const char_type* __s)  noexcept {return strlen(__s);}
N    static _LIBCPP_CONSTEXPR_AFTER_CXX14
X    static 
N    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT;
X    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) noexcept;
N    static inline char_type* move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT
X    static inline char_type* move(char_type* __s1, const char_type* __s2, size_t __n) noexcept
N        {return __n == 0 ? __s1 : (char_type*) memmove(__s1, __s2, __n);}
N    static inline char_type* copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT
X    static inline char_type* copy(char_type* __s1, const char_type* __s2, size_t __n) noexcept
N        {
N            _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, "char_traits::copy overlapped range");
X            ((void)0);
N            return __n == 0 ? __s1 : (char_type*)memcpy(__s1, __s2, __n);
N        }
N    static inline char_type* assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT
X    static inline char_type* assign(char_type* __s, size_t __n, char_type __a) noexcept
N        {return __n == 0 ? __s : (char_type*)memset(__s, to_int_type(__a), __n);}
N
N    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT
X    static inline constexpr int_type  not_eof(int_type __c) noexcept
N        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
N    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT
X    static inline constexpr char_type to_char_type(int_type __c) noexcept
N        {return char_type(__c);}
N    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT
X    static inline constexpr int_type to_int_type(char_type __c) noexcept
N        {return int_type((unsigned char)__c);}
N    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT
X    static inline constexpr bool eq_int_type(int_type __c1, int_type __c2) noexcept
N        {return __c1 == __c2;}
N    static inline _LIBCPP_CONSTEXPR int_type  eof() _NOEXCEPT
X    static inline constexpr int_type  eof() noexcept
N        {return int_type(EOF);}
X        {return int_type((-1));}
N};
N
Ninline _LIBCPP_CONSTEXPR_AFTER_CXX14
Xinline 
Nint
Nchar_traits<char>::compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT
Xchar_traits<char>::compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept
N{
N    if (__n == 0)
N        return 0;
N#if __has_feature(cxx_constexpr_string_builtins)
X#if 0
S    return __builtin_memcmp(__s1, __s2, __n);
N#elif _LIBCPP_STD_VER <= 14
X#elif 14 <= 14
N    return memcmp(__s1, __s2, __n);
N#else
S    for (; __n; --__n, ++__s1, ++__s2)
S    {
S        if (lt(*__s1, *__s2))
S            return -1;
S        if (lt(*__s2, *__s1))
S            return 1;
S    }
S    return 0;
N#endif
N}
N
Ninline _LIBCPP_CONSTEXPR_AFTER_CXX14
Xinline 
Nconst char*
Nchar_traits<char>::find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT
Xchar_traits<char>::find(const char_type* __s, size_t __n, const char_type& __a) noexcept
N{
N    if (__n == 0)
N        return NULL;
X        return 0;
N#if __has_feature(cxx_constexpr_string_builtins)
X#if 0
S    return __builtin_char_memchr(__s, to_int_type(__a), __n);
N#elif _LIBCPP_STD_VER <= 14
X#elif 14 <= 14
N    return (const char_type*) memchr(__s, to_int_type(__a), __n);
N#else
S    for (; __n; --__n)
S    {
S        if (eq(*__s, __a))
S            return __s;
S        ++__s;
S    }
S    return NULL;
N#endif
N}
N
N
N// char_traits<wchar_t>
N
Ntemplate <>
Nstruct _LIBCPP_TEMPLATE_VIS char_traits<wchar_t>
Xstruct  char_traits<wchar_t>
N{
N    typedef wchar_t   char_type;
N    typedef wint_t    int_type;
N    typedef streamoff off_type;
N    typedef streampos pos_type;
N    typedef mbstate_t state_type;
N
N    static inline _LIBCPP_CONSTEXPR_AFTER_CXX14
X    static inline 
N    void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT {__c1 = __c2;}
X    void assign(char_type& __c1, const char_type& __c2) noexcept {__c1 = __c2;}
N    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT
X    static inline constexpr bool eq(char_type __c1, char_type __c2) noexcept
N        {return __c1 == __c2;}
N    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT
X    static inline constexpr bool lt(char_type __c1, char_type __c2) noexcept
N        {return __c1 < __c2;}
N
N    static _LIBCPP_CONSTEXPR_AFTER_CXX14
X    static 
N    int compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;
X    int compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept;
N    static _LIBCPP_CONSTEXPR_AFTER_CXX14
X    static 
N    size_t length(const char_type* __s) _NOEXCEPT;
X    size_t length(const char_type* __s) noexcept;
N    static _LIBCPP_CONSTEXPR_AFTER_CXX14
X    static 
N    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT;
X    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) noexcept;
N    static inline char_type* move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT
X    static inline char_type* move(char_type* __s1, const char_type* __s2, size_t __n) noexcept
N        {return __n == 0 ? __s1 : (char_type*)wmemmove(__s1, __s2, __n);}
N    static inline char_type* copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT
X    static inline char_type* copy(char_type* __s1, const char_type* __s2, size_t __n) noexcept
N        {
N            _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, "char_traits::copy overlapped range");
X            ((void)0);
N            return __n == 0 ? __s1 : (char_type*)wmemcpy(__s1, __s2, __n);
N        }
N    static inline char_type* assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT
X    static inline char_type* assign(char_type* __s, size_t __n, char_type __a) noexcept
N        {return __n == 0 ? __s : (char_type*)wmemset(__s, __a, __n);}
N
N    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT
X    static inline constexpr int_type  not_eof(int_type __c) noexcept
N        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
N    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT
X    static inline constexpr char_type to_char_type(int_type __c) noexcept
N        {return char_type(__c);}
N    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT
X    static inline constexpr int_type to_int_type(char_type __c) noexcept
N        {return int_type(__c);}
N    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT
X    static inline constexpr bool eq_int_type(int_type __c1, int_type __c2) noexcept
N        {return __c1 == __c2;}
N    static inline _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT
X    static inline constexpr int_type eof() noexcept
N        {return int_type(WEOF);}
X        {return int_type(((wint_t)-1));}
N};
N
Ninline _LIBCPP_CONSTEXPR_AFTER_CXX14
Xinline 
Nint
Nchar_traits<wchar_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT
Xchar_traits<wchar_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept
N{
N    if (__n == 0)
N        return 0;
N#if __has_feature(cxx_constexpr_string_builtins)
X#if 0
S    return __builtin_wmemcmp(__s1, __s2, __n);
N#elif _LIBCPP_STD_VER <= 14
X#elif 14 <= 14
N    return wmemcmp(__s1, __s2, __n);
N#else
S    for (; __n; --__n, ++__s1, ++__s2)
S    {
S        if (lt(*__s1, *__s2))
S            return -1;
S        if (lt(*__s2, *__s1))
S            return 1;
S    }
S    return 0;
N#endif
N}
N
Ninline _LIBCPP_CONSTEXPR_AFTER_CXX14
Xinline 
Nsize_t
Nchar_traits<wchar_t>::length(const char_type* __s) _NOEXCEPT
Xchar_traits<wchar_t>::length(const char_type* __s) noexcept
N{
N#if __has_feature(cxx_constexpr_string_builtins)
X#if 0
S    return __builtin_wcslen(__s);
N#elif _LIBCPP_STD_VER <= 14
X#elif 14 <= 14
N    return wcslen(__s);
N#else
S    size_t __len = 0;
S    for (; !eq(*__s, char_type(0)); ++__s)
S        ++__len;
S    return __len;
N#endif
N}
N
Ninline _LIBCPP_CONSTEXPR_AFTER_CXX14
Xinline 
Nconst wchar_t*
Nchar_traits<wchar_t>::find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT
Xchar_traits<wchar_t>::find(const char_type* __s, size_t __n, const char_type& __a) noexcept
N{
N    if (__n == 0)
N        return NULL;
X        return 0;
N#if __has_feature(cxx_constexpr_string_builtins)
X#if 0
S        return __builtin_wmemchr(__s, __a, __n);
N#elif _LIBCPP_STD_VER <= 14
X#elif 14 <= 14
N    return wmemchr(__s, __a, __n);
N#else
S    for (; __n; --__n)
S    {
S        if (eq(*__s, __a))
S            return __s;
S        ++__s;
S    }
S    return NULL;
N#endif
N}
N
N
N#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
N
Ntemplate <>
Nstruct _LIBCPP_TEMPLATE_VIS char_traits<char16_t>
Xstruct  char_traits<char16_t>
N{
N    typedef char16_t       char_type;
N    typedef uint_least16_t int_type;
N    typedef streamoff      off_type;
N    typedef u16streampos   pos_type;
N    typedef mbstate_t      state_type;
N
N    static inline _LIBCPP_CONSTEXPR_AFTER_CXX14
X    static inline 
N    void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT {__c1 = __c2;}
X    void assign(char_type& __c1, const char_type& __c2) noexcept {__c1 = __c2;}
N    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT
X    static inline constexpr bool eq(char_type __c1, char_type __c2) noexcept
N        {return __c1 == __c2;}
N    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT
X    static inline constexpr bool lt(char_type __c1, char_type __c2) noexcept
N        {return __c1 < __c2;}
N
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14
X    __attribute__ ((__always_inline__)) static 
N    int              compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;
X    int              compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14
X    __attribute__ ((__always_inline__)) static 
N    size_t           length(const char_type* __s) _NOEXCEPT;
X    size_t           length(const char_type* __s) noexcept;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14
X    __attribute__ ((__always_inline__)) static 
N    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT;
X    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) noexcept;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;
X    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n) noexcept;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;
X    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n) noexcept;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    static char_type*       assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT;
X    static char_type*       assign(char_type* __s, size_t __n, char_type __a) noexcept;
N
N    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT
X    static inline constexpr int_type  not_eof(int_type __c) noexcept
N        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
N    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT
X    static inline constexpr char_type to_char_type(int_type __c) noexcept
N        {return char_type(__c);}
N    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT
X    static inline constexpr int_type to_int_type(char_type __c) noexcept
N        {return int_type(__c);}
N    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT
X    static inline constexpr bool eq_int_type(int_type __c1, int_type __c2) noexcept
N        {return __c1 == __c2;}
N    static inline _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT
X    static inline constexpr int_type eof() noexcept
N        {return int_type(0xFFFF);}
N};
N
Ninline _LIBCPP_CONSTEXPR_AFTER_CXX14
Xinline 
Nint
Nchar_traits<char16_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT
Xchar_traits<char16_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept
N{
N    for (; __n; --__n, ++__s1, ++__s2)
N    {
N        if (lt(*__s1, *__s2))
N            return -1;
N        if (lt(*__s2, *__s1))
N            return 1;
N    }
N    return 0;
N}
N
Ninline _LIBCPP_CONSTEXPR_AFTER_CXX14
Xinline 
Nsize_t
Nchar_traits<char16_t>::length(const char_type* __s) _NOEXCEPT
Xchar_traits<char16_t>::length(const char_type* __s) noexcept
N{
N    size_t __len = 0;
N    for (; !eq(*__s, char_type(0)); ++__s)
N        ++__len;
N    return __len;
N}
N
Ninline _LIBCPP_CONSTEXPR_AFTER_CXX14
Xinline 
Nconst char16_t*
Nchar_traits<char16_t>::find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT
Xchar_traits<char16_t>::find(const char_type* __s, size_t __n, const char_type& __a) noexcept
N{
N    for (; __n; --__n)
N    {
N        if (eq(*__s, __a))
N            return __s;
N        ++__s;
N    }
N    return 0;
N}
N
Ninline
Nchar16_t*
Nchar_traits<char16_t>::move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT
Xchar_traits<char16_t>::move(char_type* __s1, const char_type* __s2, size_t __n) noexcept
N{
N    char_type* __r = __s1;
N    if (__s1 < __s2)
N    {
N        for (; __n; --__n, ++__s1, ++__s2)
N            assign(*__s1, *__s2);
N    }
N    else if (__s2 < __s1)
N    {
N        __s1 += __n;
N        __s2 += __n;
N        for (; __n; --__n)
N            assign(*--__s1, *--__s2);
N    }
N    return __r;
N}
N
Ninline
Nchar16_t*
Nchar_traits<char16_t>::copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT
Xchar_traits<char16_t>::copy(char_type* __s1, const char_type* __s2, size_t __n) noexcept
N{
N    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, "char_traits::copy overlapped range");
X    ((void)0);
N    char_type* __r = __s1;
N    for (; __n; --__n, ++__s1, ++__s2)
N        assign(*__s1, *__s2);
N    return __r;
N}
N
Ninline
Nchar16_t*
Nchar_traits<char16_t>::assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT
Xchar_traits<char16_t>::assign(char_type* __s, size_t __n, char_type __a) noexcept
N{
N    char_type* __r = __s;
N    for (; __n; --__n, ++__s)
N        assign(*__s, __a);
N    return __r;
N}
N
Ntemplate <>
Nstruct _LIBCPP_TEMPLATE_VIS char_traits<char32_t>
Xstruct  char_traits<char32_t>
N{
N    typedef char32_t       char_type;
N    typedef uint_least32_t int_type;
N    typedef streamoff      off_type;
N    typedef u32streampos   pos_type;
N    typedef mbstate_t      state_type;
N
N    static inline _LIBCPP_CONSTEXPR_AFTER_CXX14
X    static inline 
N    void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT {__c1 = __c2;}
X    void assign(char_type& __c1, const char_type& __c2) noexcept {__c1 = __c2;}
N    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT
X    static inline constexpr bool eq(char_type __c1, char_type __c2) noexcept
N        {return __c1 == __c2;}
N    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT
X    static inline constexpr bool lt(char_type __c1, char_type __c2) noexcept
N        {return __c1 < __c2;}
N
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14
X    __attribute__ ((__always_inline__)) static 
N    int              compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;
X    int              compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14
X    __attribute__ ((__always_inline__)) static 
N    size_t           length(const char_type* __s) _NOEXCEPT;
X    size_t           length(const char_type* __s) noexcept;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14
X    __attribute__ ((__always_inline__)) static 
N    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT;
X    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) noexcept;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;
X    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n) noexcept;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;
X    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n) noexcept;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    static char_type*       assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT;
X    static char_type*       assign(char_type* __s, size_t __n, char_type __a) noexcept;
N
N    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT
X    static inline constexpr int_type  not_eof(int_type __c) noexcept
N        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
N    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT
X    static inline constexpr char_type to_char_type(int_type __c) noexcept
N        {return char_type(__c);}
N    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT
X    static inline constexpr int_type to_int_type(char_type __c) noexcept
N        {return int_type(__c);}
N    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT
X    static inline constexpr bool eq_int_type(int_type __c1, int_type __c2) noexcept
N        {return __c1 == __c2;}
N    static inline _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT
X    static inline constexpr int_type eof() noexcept
N        {return int_type(0xFFFFFFFF);}
N};
N
Ninline _LIBCPP_CONSTEXPR_AFTER_CXX14
Xinline 
Nint
Nchar_traits<char32_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT
Xchar_traits<char32_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept
N{
N    for (; __n; --__n, ++__s1, ++__s2)
N    {
N        if (lt(*__s1, *__s2))
N            return -1;
N        if (lt(*__s2, *__s1))
N            return 1;
N    }
N    return 0;
N}
N
Ninline _LIBCPP_CONSTEXPR_AFTER_CXX14
Xinline 
Nsize_t
Nchar_traits<char32_t>::length(const char_type* __s) _NOEXCEPT
Xchar_traits<char32_t>::length(const char_type* __s) noexcept
N{
N    size_t __len = 0;
N    for (; !eq(*__s, char_type(0)); ++__s)
N        ++__len;
N    return __len;
N}
N
Ninline _LIBCPP_CONSTEXPR_AFTER_CXX14
Xinline 
Nconst char32_t*
Nchar_traits<char32_t>::find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT
Xchar_traits<char32_t>::find(const char_type* __s, size_t __n, const char_type& __a) noexcept
N{
N    for (; __n; --__n)
N    {
N        if (eq(*__s, __a))
N            return __s;
N        ++__s;
N    }
N    return 0;
N}
N
Ninline
Nchar32_t*
Nchar_traits<char32_t>::move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT
Xchar_traits<char32_t>::move(char_type* __s1, const char_type* __s2, size_t __n) noexcept
N{
N    char_type* __r = __s1;
N    if (__s1 < __s2)
N    {
N        for (; __n; --__n, ++__s1, ++__s2)
N            assign(*__s1, *__s2);
N    }
N    else if (__s2 < __s1)
N    {
N        __s1 += __n;
N        __s2 += __n;
N        for (; __n; --__n)
N            assign(*--__s1, *--__s2);
N    }
N    return __r;
N}
N
Ninline
Nchar32_t*
Nchar_traits<char32_t>::copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT
Xchar_traits<char32_t>::copy(char_type* __s1, const char_type* __s2, size_t __n) noexcept
N{
N    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, "char_traits::copy overlapped range");
X    ((void)0);
N    char_type* __r = __s1;
N    for (; __n; --__n, ++__s1, ++__s2)
N        assign(*__s1, *__s2);
N    return __r;
N}
N
Ninline
Nchar32_t*
Nchar_traits<char32_t>::assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT
Xchar_traits<char32_t>::assign(char_type* __s, size_t __n, char_type __a) noexcept
N{
N    char_type* __r = __s;
N    for (; __n; --__n, ++__s)
N        assign(*__s, __a);
N    return __r;
N}
N
N#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS
N
N// helper fns for basic_string and string_view
N
N// __str_find
Ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
Ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
Xinline _SizeT constexpr __attribute__ ((__always_inline__))
N__str_find(const _CharT *__p, _SizeT __sz, 
N             _CharT __c, _SizeT __pos) _NOEXCEPT
X             _CharT __c, _SizeT __pos) noexcept
N{
N    if (__pos >= __sz)
N        return __npos;
N    const _CharT* __r = _Traits::find(__p + __pos, __sz - __pos, __c);
N    if (__r == 0)
N        return __npos;
N    return static_cast<_SizeT>(__r - __p);
N}
N
Ntemplate <class _CharT, class _Traits>
Ninline _LIBCPP_CONSTEXPR_AFTER_CXX11 const _CharT *
Xinline constexpr const _CharT *
N__search_substring(const _CharT *__first1, const _CharT *__last1,
N                   const _CharT *__first2, const _CharT *__last2) {
N  // Take advantage of knowing source and pattern lengths.
N  // Stop short when source is smaller than pattern.
N  const ptrdiff_t __len2 = __last2 - __first2;
N  if (__len2 == 0)
N    return __first1;
N
N  ptrdiff_t __len1 = __last1 - __first1;
N  if (__len1 < __len2)
N    return __last1;
N
N  // First element of __first2 is loop invariant.
N  _CharT __f2 = *__first2;
N  while (true) {
N    __len1 = __last1 - __first1;
N    // Check whether __first1 still has at least __len2 bytes.
N    if (__len1 < __len2)
N      return __last1;
N
N    // Find __f2 the first byte matching in __first1.
N    __first1 = _Traits::find(__first1, __len1 - __len2 + 1, __f2);
N    if (__first1 == 0)
N      return __last1;
N
N    // It is faster to compare from the first byte of __first1 even if we
N    // already know that it matches the first byte of __first2: this is because
N    // __first2 is most likely aligned, as it is user's "pattern" string, and
N    // __first1 + 1 is most likely not aligned, as the match is in the middle of
N    // the string.
N    if (_Traits::compare(__first1, __first2, __len2) == 0)
N      return __first1;
N
N    ++__first1;
N  }
N}
N
Ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
Ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
Xinline _SizeT constexpr __attribute__ ((__always_inline__))
N__str_find(const _CharT *__p, _SizeT __sz, 
N       const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT
X       const _CharT* __s, _SizeT __pos, _SizeT __n) noexcept
N{
N    if (__pos > __sz)
N        return __npos;
N
N    if (__n == 0) // There is nothing to search, just return __pos.
N        return __pos;
N
N    const _CharT *__r = __search_substring<_CharT, _Traits>(
N        __p + __pos, __p + __sz, __s, __s + __n);
N
N    if (__r == __p + __sz)
N        return __npos;
N    return static_cast<_SizeT>(__r - __p);
N}
N
N
N// __str_rfind
N
Ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
Ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
Xinline _SizeT constexpr __attribute__ ((__always_inline__))
N__str_rfind(const _CharT *__p, _SizeT __sz, 
N              _CharT __c, _SizeT __pos) _NOEXCEPT
X              _CharT __c, _SizeT __pos) noexcept
N{
N    if (__sz < 1)
N        return __npos;
N    if (__pos < __sz)
N        ++__pos;
N    else
N        __pos = __sz;
N    for (const _CharT* __ps = __p + __pos; __ps != __p;)
N    {
N        if (_Traits::eq(*--__ps, __c))
N            return static_cast<_SizeT>(__ps - __p);
N    }
N    return __npos;
N}
N
Ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
Ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
Xinline _SizeT constexpr __attribute__ ((__always_inline__))
N__str_rfind(const _CharT *__p, _SizeT __sz, 
N        const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT
X        const _CharT* __s, _SizeT __pos, _SizeT __n) noexcept
N{
N    __pos = _VSTD::min(__pos, __sz);
X    __pos = std::__2::min(__pos, __sz);
N    if (__n < __sz - __pos)
N        __pos += __n;
N    else
N        __pos = __sz;
N    const _CharT* __r = _VSTD::__find_end(
X    const _CharT* __r = std::__2::__find_end(
N                  __p, __p + __pos, __s, __s + __n, _Traits::eq, 
N                        random_access_iterator_tag(), random_access_iterator_tag());
N    if (__n > 0 && __r == __p + __pos)
N        return __npos;
N    return static_cast<_SizeT>(__r - __p);
N}
N
N// __str_find_first_of
Ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
Ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
Xinline _SizeT constexpr __attribute__ ((__always_inline__))
N__str_find_first_of(const _CharT *__p, _SizeT __sz,
N                const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT
X                const _CharT* __s, _SizeT __pos, _SizeT __n) noexcept
N{
N    if (__pos >= __sz || __n == 0)
N        return __npos;
N    const _CharT* __r = _VSTD::__find_first_of_ce
X    const _CharT* __r = std::__2::__find_first_of_ce
N        (__p + __pos, __p + __sz, __s, __s + __n, _Traits::eq );
N    if (__r == __p + __sz)
N        return __npos;
N    return static_cast<_SizeT>(__r - __p);
N}
N
N
N// __str_find_last_of
Ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
Ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
Xinline _SizeT constexpr __attribute__ ((__always_inline__))
N__str_find_last_of(const _CharT *__p, _SizeT __sz,
N               const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT
X               const _CharT* __s, _SizeT __pos, _SizeT __n) noexcept
N    {
N    if (__n != 0)
N    {
N        if (__pos < __sz)
N            ++__pos;
N        else
N            __pos = __sz;
N        for (const _CharT* __ps = __p + __pos; __ps != __p;)
N        {
N            const _CharT* __r = _Traits::find(__s, __n, *--__ps);
N            if (__r)
N                return static_cast<_SizeT>(__ps - __p);
N        }
N    }
N    return __npos;
N}
N
N
N// __str_find_first_not_of
Ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
Ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
Xinline _SizeT constexpr __attribute__ ((__always_inline__))
N__str_find_first_not_of(const _CharT *__p, _SizeT __sz,
N                    const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT
X                    const _CharT* __s, _SizeT __pos, _SizeT __n) noexcept
N{
N    if (__pos < __sz)
N    {
N        const _CharT* __pe = __p + __sz;
N        for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)
N            if (_Traits::find(__s, __n, *__ps) == 0)
N                return static_cast<_SizeT>(__ps - __p);
N    }
N    return __npos;
N}
N
N
Ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
Ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
Xinline _SizeT constexpr __attribute__ ((__always_inline__))
N__str_find_first_not_of(const _CharT *__p, _SizeT __sz,
N                          _CharT __c, _SizeT __pos) _NOEXCEPT
X                          _CharT __c, _SizeT __pos) noexcept
N{
N    if (__pos < __sz)
N    {
N        const _CharT* __pe = __p + __sz;
N        for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)
N            if (!_Traits::eq(*__ps, __c))
N                return static_cast<_SizeT>(__ps - __p);
N    }
N    return __npos;
N}
N
N
N// __str_find_last_not_of
Ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
Ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
Xinline _SizeT constexpr __attribute__ ((__always_inline__))
N__str_find_last_not_of(const _CharT *__p, _SizeT __sz,
N                   const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT
X                   const _CharT* __s, _SizeT __pos, _SizeT __n) noexcept
N{
N    if (__pos < __sz)
N        ++__pos;
N    else
N        __pos = __sz;
N    for (const _CharT* __ps = __p + __pos; __ps != __p;)
N        if (_Traits::find(__s, __n, *--__ps) == 0)
N            return static_cast<_SizeT>(__ps - __p);
N    return __npos;
N}
N
N
Ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
Ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
Xinline _SizeT constexpr __attribute__ ((__always_inline__))
N__str_find_last_not_of(const _CharT *__p, _SizeT __sz,
N                         _CharT __c, _SizeT __pos) _NOEXCEPT
X                         _CharT __c, _SizeT __pos) noexcept
N{
N    if (__pos < __sz)
N        ++__pos;
N    else
N        __pos = __sz;
N    for (const _CharT* __ps = __p + __pos; __ps != __p;)
N        if (!_Traits::eq(*--__ps, __c))
N            return static_cast<_SizeT>(__ps - __p);
N    return __npos;
N}
N
Ntemplate<class _Ptr>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nsize_t __do_string_hash(_Ptr __p, _Ptr __e)
N{
N    typedef typename iterator_traits<_Ptr>::value_type value_type;
N    return __murmur2_or_cityhash<size_t>()(__p, (__e-__p)*sizeof(value_type));
N}
N
Ntemplate <class _CharT, class _Iter, class _Traits=char_traits<_CharT> >
Nstruct __quoted_output_proxy
N{
N    _Iter  __first;
N    _Iter  __last;
N    _CharT  __delim;
N    _CharT  __escape;
N
N    __quoted_output_proxy(_Iter __f, _Iter __l, _CharT __d, _CharT __e)
N    : __first(__f), __last(__l), __delim(__d), __escape(__e) {}
N    //  This would be a nice place for a string_ref 
N};
N
N_LIBCPP_END_NAMESPACE_STD
X} }
N
N_LIBCPP_POP_MACROS
X_Pragma("pop_macro(\"min\")") _Pragma("pop_macro(\"max\")")
N
N#endif  // _LIBCPP___STRING
L 170 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/string_view" 2
N#include <algorithm>
N#include <iterator>
N#include <limits>
N#include <stdexcept>
N#include <__debug>
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N_LIBCPP_PUSH_MACROS
X_Pragma("push_macro(\"min\")") _Pragma("push_macro(\"max\")")
N#include <__undef_macros>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/__undef_macros" 1
N// -*- C++ -*-
N//===------------------------ __undef_macros ------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is distributed under the University of Illinois Open Source
N// License. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N
N#ifdef min
S#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
S#if defined(_LIBCPP_WARNING)
S_LIBCPP_WARNING("macro min is incompatible with C++.  Try #define NOMINMAX "
S                "before any Windows header. #undefing min")
S#else
S#warning: macro min is incompatible with C++.  #undefing min
S#endif
S#endif
S#undef min
N#endif
N
N#ifdef max
S#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
S#if defined(_LIBCPP_WARNING)
S_LIBCPP_WARNING("macro max is incompatible with C++.  Try #define NOMINMAX "
S                "before any Windows header. #undefing max")
S#else
S#warning: macro max is incompatible with C++.  #undefing max
S#endif
S#endif
S#undef max
N#endif
L 182 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/string_view" 2
N
N
N_LIBCPP_BEGIN_NAMESPACE_STD
Xnamespace std { inline namespace __2 {
N
Ntemplate<class _CharT, class _Traits = char_traits<_CharT> >
Nclass _LIBCPP_TEMPLATE_VIS basic_string_view {
Xclass  basic_string_view {
Npublic:
N	// types
N	typedef _Traits                                    traits_type;
N	typedef _CharT                                     value_type;
N	typedef const _CharT*                              pointer;
N	typedef const _CharT*                              const_pointer;
N	typedef const _CharT&                              reference;
N	typedef const _CharT&                              const_reference;
N	typedef const_pointer                              const_iterator; // See [string.view.iterators]
N	typedef const_iterator                             iterator;
N	typedef _VSTD::reverse_iterator<const_iterator>    const_reverse_iterator;
X	typedef std::__2::reverse_iterator<const_iterator>    const_reverse_iterator;
N	typedef const_reverse_iterator                     reverse_iterator;
N	typedef size_t                                     size_type;
N	typedef ptrdiff_t                                  difference_type;
N	static _LIBCPP_CONSTEXPR const size_type npos = (size_type)-1; // size_type(-1);
X	static constexpr const size_type npos = (size_type)-1; 
N
N    static_assert(is_pod<value_type>::value, "Character type of basic_string_view must be a POD");
N    static_assert((is_same<_CharT, typename traits_type::char_type>::value),
N                  "traits_type::char_type must be the same type as CharT");
N
N	// [string.view.cons], construct/copy
N	_LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY
X	constexpr __attribute__ ((__always_inline__))
N	basic_string_view() _NOEXCEPT : __data (nullptr), __size(0) {}
X	basic_string_view() noexcept : __data (nullptr), __size(0) {}
N
N	_LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY
X	constexpr __attribute__ ((__always_inline__))
N	basic_string_view(const basic_string_view&) _NOEXCEPT = default;
X	basic_string_view(const basic_string_view&) noexcept = default;
N
N	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X	constexpr __attribute__ ((__always_inline__))
N	basic_string_view& operator=(const basic_string_view&) _NOEXCEPT = default;
X	basic_string_view& operator=(const basic_string_view&) noexcept = default;
N
N	_LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY
X	constexpr __attribute__ ((__always_inline__))
N	basic_string_view(const _CharT* __s, size_type __len) _NOEXCEPT
X	basic_string_view(const _CharT* __s, size_type __len) noexcept
N		: __data(__s), __size(__len)
N	{
N// #if _LIBCPP_STD_VER > 11
N//         _LIBCPP_ASSERT(__len == 0 || __s != nullptr, "string_view::string_view(_CharT *, size_t): received nullptr");
N// #endif
N	}
N
N	_LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY
X	constexpr __attribute__ ((__always_inline__))
N	basic_string_view(const _CharT* __s)
N		: __data(__s), __size(_Traits::length(__s)) {}
N
N	// [string.view.iterators], iterators
N	_LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY
X	constexpr __attribute__ ((__always_inline__))
N	const_iterator begin()  const _NOEXCEPT { return cbegin(); }
X	const_iterator begin()  const noexcept { return cbegin(); }
N
N	_LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY
X	constexpr __attribute__ ((__always_inline__))
N	const_iterator end()    const _NOEXCEPT { return cend(); }
X	const_iterator end()    const noexcept { return cend(); }
N
N	_LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY
X	constexpr __attribute__ ((__always_inline__))
N	const_iterator cbegin() const _NOEXCEPT { return __data; }
X	const_iterator cbegin() const noexcept { return __data; }
N
N	_LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY
X	constexpr __attribute__ ((__always_inline__))
N	const_iterator cend()   const _NOEXCEPT { return __data + __size; }
X	const_iterator cend()   const noexcept { return __data + __size; }
N
N	_LIBCPP_CONSTEXPR_AFTER_CXX14 _LIBCPP_INLINE_VISIBILITY
X	 __attribute__ ((__always_inline__))
N	const_reverse_iterator rbegin()   const _NOEXCEPT { return const_reverse_iterator(cend()); }
X	const_reverse_iterator rbegin()   const noexcept { return const_reverse_iterator(cend()); }
N
N	_LIBCPP_CONSTEXPR_AFTER_CXX14 _LIBCPP_INLINE_VISIBILITY
X	 __attribute__ ((__always_inline__))
N	const_reverse_iterator rend()     const _NOEXCEPT { return const_reverse_iterator(cbegin()); }
X	const_reverse_iterator rend()     const noexcept { return const_reverse_iterator(cbegin()); }
N
N	_LIBCPP_CONSTEXPR_AFTER_CXX14 _LIBCPP_INLINE_VISIBILITY
X	 __attribute__ ((__always_inline__))
N	const_reverse_iterator crbegin()  const _NOEXCEPT { return const_reverse_iterator(cend()); }
X	const_reverse_iterator crbegin()  const noexcept { return const_reverse_iterator(cend()); }
N
N	_LIBCPP_CONSTEXPR_AFTER_CXX14 _LIBCPP_INLINE_VISIBILITY
X	 __attribute__ ((__always_inline__))
N	const_reverse_iterator crend()    const _NOEXCEPT { return const_reverse_iterator(cbegin()); }
X	const_reverse_iterator crend()    const noexcept { return const_reverse_iterator(cbegin()); }
N
N	// [string.view.capacity], capacity
N	_LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY
X	constexpr __attribute__ ((__always_inline__))
N	size_type size()     const _NOEXCEPT { return __size; }
X	size_type size()     const noexcept { return __size; }
N
N	_LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY
X	constexpr __attribute__ ((__always_inline__))
N	size_type length()   const _NOEXCEPT { return __size; }
X	size_type length()   const noexcept { return __size; }
N
N	_LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY
X	constexpr __attribute__ ((__always_inline__))
N	size_type max_size() const _NOEXCEPT { return numeric_limits<size_type>::max(); }
X	size_type max_size() const noexcept { return numeric_limits<size_type>::max(); }
N
N	_LIBCPP_CONSTEXPR bool _LIBCPP_INLINE_VISIBILITY
X	constexpr bool __attribute__ ((__always_inline__))
N	empty()         const _NOEXCEPT { return __size == 0; }
X	empty()         const noexcept { return __size == 0; }
N
N	// [string.view.access], element access
N	_LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY
X	constexpr __attribute__ ((__always_inline__))
N	const_reference operator[](size_type __pos) const _NOEXCEPT { return __data[__pos]; }
X	const_reference operator[](size_type __pos) const noexcept { return __data[__pos]; }
N
N	_LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY
X	constexpr __attribute__ ((__always_inline__))
N	const_reference at(size_type __pos) const
N	{
N		return __pos >= size()
N			? (__throw_out_of_range("string_view::at"), __data[0])
N			: __data[__pos];
N	}
N
N	_LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY
X	constexpr __attribute__ ((__always_inline__))
N	const_reference front() const
N	{
N		return _LIBCPP_ASSERT(!empty(), "string_view::front(): string is empty"), __data[0];
X		return ((void)0), __data[0];
N	}
N
N	_LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY
X	constexpr __attribute__ ((__always_inline__))
N	const_reference back() const
N	{
N		return _LIBCPP_ASSERT(!empty(), "string_view::back(): string is empty"), __data[__size-1];
X		return ((void)0), __data[__size-1];
N	}
N
N	_LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY
X	constexpr __attribute__ ((__always_inline__))
N	const_pointer data() const _NOEXCEPT { return __data; }
X	const_pointer data() const noexcept { return __data; }
N
N	// [string.view.modifiers], modifiers:
N	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X	constexpr __attribute__ ((__always_inline__))
N	void remove_prefix(size_type __n) _NOEXCEPT
X	void remove_prefix(size_type __n) noexcept
N	{
N		_LIBCPP_ASSERT(__n <= size(), "remove_prefix() can't remove more than size()");
X		((void)0);
N		__data += __n;
N		__size -= __n;
N	}
N
N	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X	constexpr __attribute__ ((__always_inline__))
N	void remove_suffix(size_type __n) _NOEXCEPT
X	void remove_suffix(size_type __n) noexcept
N	{
N		_LIBCPP_ASSERT(__n <= size(), "remove_suffix() can't remove more than size()");
X		((void)0);
N		__size -= __n;
N	}
N
N	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X	constexpr __attribute__ ((__always_inline__))
N	void swap(basic_string_view& __other) _NOEXCEPT
X	void swap(basic_string_view& __other) noexcept
N	{
N		const value_type *__p = __data;
N		__data = __other.__data;
N		__other.__data = __p;
N
N		size_type __sz = __size;
N		__size = __other.__size;
N		__other.__size = __sz;
N	}
N
N	_LIBCPP_INLINE_VISIBILITY
X	__attribute__ ((__always_inline__))
N	size_type copy(_CharT* __s, size_type __n, size_type __pos = 0) const
N	{
N		if (__pos > size())
N			__throw_out_of_range("string_view::copy");
N		size_type __rlen = _VSTD::min(__n, size() - __pos);
X		size_type __rlen = std::__2::min(__n, size() - __pos);
N		_Traits::copy(__s, data() + __pos, __rlen);
N		return __rlen;
N	}
N
N	_LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY
X	constexpr __attribute__ ((__always_inline__))
N	basic_string_view substr(size_type __pos = 0, size_type __n = npos) const
N	{
N		return __pos > size()
N			? (__throw_out_of_range("string_view::substr"), basic_string_view())
N			: basic_string_view(data() + __pos, _VSTD::min(__n, size() - __pos));
X			: basic_string_view(data() + __pos, std::__2::min(__n, size() - __pos));
N	}
N
N	_LIBCPP_CONSTEXPR_AFTER_CXX11 int compare(basic_string_view __sv) const _NOEXCEPT
X	constexpr int compare(basic_string_view __sv) const noexcept
N	{
N		size_type __rlen = _VSTD::min( size(), __sv.size());
X		size_type __rlen = std::__2::min( size(), __sv.size());
N		int __retval = _Traits::compare(data(), __sv.data(), __rlen);
N		if ( __retval == 0 ) // first __rlen chars matched
N			__retval = size() == __sv.size() ? 0 : ( size() < __sv.size() ? -1 : 1 );
N		return __retval;
N	}
N
N	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X	constexpr __attribute__ ((__always_inline__))
N	int compare(size_type __pos1, size_type __n1, basic_string_view __sv) const
N	{
N		return substr(__pos1, __n1).compare(__sv);
N	}
N
N	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X	constexpr __attribute__ ((__always_inline__))
N	int compare(                       size_type __pos1, size_type __n1, 
N				basic_string_view __sv, size_type __pos2, size_type __n2) const
N	{
N		return substr(__pos1, __n1).compare(__sv.substr(__pos2, __n2));
N	}
N
N	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X	constexpr __attribute__ ((__always_inline__))
N	int compare(const _CharT* __s) const _NOEXCEPT
X	int compare(const _CharT* __s) const noexcept
N	{
N		return compare(basic_string_view(__s));
N	}
N
N	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X	constexpr __attribute__ ((__always_inline__))
N	int compare(size_type __pos1, size_type __n1, const _CharT* __s) const
N	{
N		return substr(__pos1, __n1).compare(basic_string_view(__s));
N	}
N
N	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X	constexpr __attribute__ ((__always_inline__))
N	int compare(size_type __pos1, size_type __n1, const _CharT* __s, size_type __n2) const
N	{
N		return substr(__pos1, __n1).compare(basic_string_view(__s, __n2));
N	}
N
N	// find
N	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X	constexpr __attribute__ ((__always_inline__))
N	size_type find(basic_string_view __s, size_type __pos = 0) const _NOEXCEPT
X	size_type find(basic_string_view __s, size_type __pos = 0) const noexcept
N	{
N		_LIBCPP_ASSERT(__s.size() == 0 || __s.data() != nullptr, "string_view::find(): received nullptr");
X		((void)0);
N		return __str_find<value_type, size_type, traits_type, npos>
N			(data(), size(), __s.data(), __pos, __s.size());
N	}
N
N	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X	constexpr __attribute__ ((__always_inline__))
N	size_type find(_CharT __c, size_type __pos = 0) const _NOEXCEPT
X	size_type find(_CharT __c, size_type __pos = 0) const noexcept
N	{
N		return __str_find<value_type, size_type, traits_type, npos>
N			(data(), size(), __c, __pos);
N	}
N
N	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X	constexpr __attribute__ ((__always_inline__))
N	size_type find(const _CharT* __s, size_type __pos, size_type __n) const
N	{
N		_LIBCPP_ASSERT(__n == 0 || __s != nullptr, "string_view::find(): received nullptr");
X		((void)0);
N		return __str_find<value_type, size_type, traits_type, npos>
N			(data(), size(), __s, __pos, __n);
N	}
N
N	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X	constexpr __attribute__ ((__always_inline__))
N	size_type find(const _CharT* __s, size_type __pos = 0) const
N	{
N		_LIBCPP_ASSERT(__s != nullptr, "string_view::find(): received nullptr");
X		((void)0);
N		return __str_find<value_type, size_type, traits_type, npos>
N			(data(), size(), __s, __pos, traits_type::length(__s));
N	}
N
N	// rfind
N	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X	constexpr __attribute__ ((__always_inline__))
N	size_type rfind(basic_string_view __s, size_type __pos = npos) const _NOEXCEPT
X	size_type rfind(basic_string_view __s, size_type __pos = npos) const noexcept
N	{
N		_LIBCPP_ASSERT(__s.size() == 0 || __s.data() != nullptr, "string_view::find(): received nullptr");
X		((void)0);
N		return __str_rfind<value_type, size_type, traits_type, npos>
N			(data(), size(), __s.data(), __pos, __s.size());
N	}
N
N	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X	constexpr __attribute__ ((__always_inline__))
N	size_type rfind(_CharT __c, size_type __pos = npos) const _NOEXCEPT
X	size_type rfind(_CharT __c, size_type __pos = npos) const noexcept
N	{
N		return __str_rfind<value_type, size_type, traits_type, npos>
N			(data(), size(), __c, __pos);
N	}
N
N	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X	constexpr __attribute__ ((__always_inline__))
N	size_type rfind(const _CharT* __s, size_type __pos, size_type __n) const
N	{
N		_LIBCPP_ASSERT(__n == 0 || __s != nullptr, "string_view::rfind(): received nullptr");
X		((void)0);
N		return __str_rfind<value_type, size_type, traits_type, npos>
N			(data(), size(), __s, __pos, __n);
N	}
N
N	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X	constexpr __attribute__ ((__always_inline__))
N	size_type rfind(const _CharT* __s, size_type __pos=npos) const
N	{
N		_LIBCPP_ASSERT(__s != nullptr, "string_view::rfind(): received nullptr");
X		((void)0);
N		return __str_rfind<value_type, size_type, traits_type, npos>
N			(data(), size(), __s, __pos, traits_type::length(__s));
N	}
N
N	// find_first_of
N	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X	constexpr __attribute__ ((__always_inline__))
N	size_type find_first_of(basic_string_view __s, size_type __pos = 0) const _NOEXCEPT
X	size_type find_first_of(basic_string_view __s, size_type __pos = 0) const noexcept
N	{
N		_LIBCPP_ASSERT(__s.size() == 0 || __s.data() != nullptr, "string_view::find_first_of(): received nullptr");
X		((void)0);
N		return __str_find_first_of<value_type, size_type, traits_type, npos>
N			(data(), size(), __s.data(), __pos, __s.size());
N	}
N
N	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X	constexpr __attribute__ ((__always_inline__))
N	size_type find_first_of(_CharT __c, size_type __pos = 0) const _NOEXCEPT
X	size_type find_first_of(_CharT __c, size_type __pos = 0) const noexcept
N	{ return find(__c, __pos); }
N
N	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X	constexpr __attribute__ ((__always_inline__))
N	size_type find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
N	{
N		_LIBCPP_ASSERT(__n == 0 || __s != nullptr, "string_view::find_first_of(): received nullptr");
X		((void)0);
N		return __str_find_first_of<value_type, size_type, traits_type, npos>
N			(data(), size(), __s, __pos, __n);
N	}
N
N	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X	constexpr __attribute__ ((__always_inline__))
N	size_type find_first_of(const _CharT* __s, size_type __pos=0) const
N	{
N		_LIBCPP_ASSERT(__s != nullptr, "string_view::find_first_of(): received nullptr");
X		((void)0);
N		return __str_find_first_of<value_type, size_type, traits_type, npos>
N			(data(), size(), __s, __pos, traits_type::length(__s));
N	}
N
N	// find_last_of
N	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X	constexpr __attribute__ ((__always_inline__))
N	size_type find_last_of(basic_string_view __s, size_type __pos=npos) const _NOEXCEPT
X	size_type find_last_of(basic_string_view __s, size_type __pos=npos) const noexcept
N	{
N		_LIBCPP_ASSERT(__s.size() == 0 || __s.data() != nullptr, "string_view::find_last_of(): received nullptr");
X		((void)0);
N		return __str_find_last_of<value_type, size_type, traits_type, npos>
N			(data(), size(), __s.data(), __pos, __s.size());
N	}
N
N	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X	constexpr __attribute__ ((__always_inline__))
N	size_type find_last_of(_CharT __c, size_type __pos = npos) const _NOEXCEPT
X	size_type find_last_of(_CharT __c, size_type __pos = npos) const noexcept
N	{ return rfind(__c, __pos); }
N
N	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X	constexpr __attribute__ ((__always_inline__))
N	size_type find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
N	{
N		_LIBCPP_ASSERT(__n == 0 || __s != nullptr, "string_view::find_last_of(): received nullptr");
X		((void)0);
N		return __str_find_last_of<value_type, size_type, traits_type, npos>
N			(data(), size(), __s, __pos, __n);
N	}
N
N	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X	constexpr __attribute__ ((__always_inline__))
N	size_type find_last_of(const _CharT* __s, size_type __pos=npos) const
N	{
N		_LIBCPP_ASSERT(__s != nullptr, "string_view::find_last_of(): received nullptr");
X		((void)0);
N		return __str_find_last_of<value_type, size_type, traits_type, npos>
N			(data(), size(), __s, __pos, traits_type::length(__s));
N	}
N
N	// find_first_not_of
N	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X	constexpr __attribute__ ((__always_inline__))
N	size_type find_first_not_of(basic_string_view __s, size_type __pos=0) const _NOEXCEPT
X	size_type find_first_not_of(basic_string_view __s, size_type __pos=0) const noexcept
N	{
N		_LIBCPP_ASSERT(__s.size() == 0 || __s.data() != nullptr, "string_view::find_first_not_of(): received nullptr");
X		((void)0);
N		return __str_find_first_not_of<value_type, size_type, traits_type, npos>
N			(data(), size(), __s.data(), __pos, __s.size());
N	}
N
N	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X	constexpr __attribute__ ((__always_inline__))
N	size_type find_first_not_of(_CharT __c, size_type __pos=0) const _NOEXCEPT
X	size_type find_first_not_of(_CharT __c, size_type __pos=0) const noexcept
N	{
N		return __str_find_first_not_of<value_type, size_type, traits_type, npos>
N			(data(), size(), __c, __pos);
N	}
N
N	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X	constexpr __attribute__ ((__always_inline__))
N	size_type find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
N	{
N		_LIBCPP_ASSERT(__n == 0 || __s != nullptr, "string_view::find_first_not_of(): received nullptr");
X		((void)0);
N		return __str_find_first_not_of<value_type, size_type, traits_type, npos>
N			(data(), size(), __s, __pos, __n);
N	}
N
N	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X	constexpr __attribute__ ((__always_inline__))
N	size_type find_first_not_of(const _CharT* __s, size_type __pos=0) const
N	{
N		_LIBCPP_ASSERT(__s != nullptr, "string_view::find_first_not_of(): received nullptr");
X		((void)0);
N		return __str_find_first_not_of<value_type, size_type, traits_type, npos>
N			(data(), size(), __s, __pos, traits_type::length(__s));
N	}
N
N	// find_last_not_of
N	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X	constexpr __attribute__ ((__always_inline__))
N	size_type find_last_not_of(basic_string_view __s, size_type __pos=npos) const _NOEXCEPT
X	size_type find_last_not_of(basic_string_view __s, size_type __pos=npos) const noexcept
N	{
N		_LIBCPP_ASSERT(__s.size() == 0 || __s.data() != nullptr, "string_view::find_last_not_of(): received nullptr");
X		((void)0);
N		return __str_find_last_not_of<value_type, size_type, traits_type, npos>
N			(data(), size(), __s.data(), __pos, __s.size());
N	}
N
N	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X	constexpr __attribute__ ((__always_inline__))
N	size_type find_last_not_of(_CharT __c, size_type __pos=npos) const _NOEXCEPT
X	size_type find_last_not_of(_CharT __c, size_type __pos=npos) const noexcept
N	{
N		return __str_find_last_not_of<value_type, size_type, traits_type, npos>
N			(data(), size(), __c, __pos);
N	}
N
N	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X	constexpr __attribute__ ((__always_inline__))
N	size_type find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
N	{
N		_LIBCPP_ASSERT(__n == 0 || __s != nullptr, "string_view::find_last_not_of(): received nullptr");
X		((void)0);
N		return __str_find_last_not_of<value_type, size_type, traits_type, npos>
N			(data(), size(), __s, __pos, __n);
N	}
N
N	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X	constexpr __attribute__ ((__always_inline__))
N	size_type find_last_not_of(const _CharT* __s, size_type __pos=npos) const
N	{
N		_LIBCPP_ASSERT(__s != nullptr, "string_view::find_last_not_of(): received nullptr");
X		((void)0);
N		return __str_find_last_not_of<value_type, size_type, traits_type, npos>
N			(data(), size(), __s, __pos, traits_type::length(__s));
N	}
N
Nprivate:
N	const   value_type* __data;
N	size_type           __size;
N};
N
N
N// [string.view.comparison]
N// operator ==
Ntemplate<class _CharT, class _Traits>
N_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
Xconstexpr __attribute__ ((__always_inline__))
Nbool operator==(basic_string_view<_CharT, _Traits> __lhs,
N				basic_string_view<_CharT, _Traits> __rhs) _NOEXCEPT
X				basic_string_view<_CharT, _Traits> __rhs) noexcept
N{
N	if ( __lhs.size() != __rhs.size()) return false;
N	return __lhs.compare(__rhs) == 0;
N}
N
Ntemplate<class _CharT, class _Traits>
N_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
Xconstexpr __attribute__ ((__always_inline__))
Nbool operator==(basic_string_view<_CharT, _Traits> __lhs,
N				typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) _NOEXCEPT
X				typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) noexcept
N{
N	if ( __lhs.size() != __rhs.size()) return false;
N	return __lhs.compare(__rhs) == 0;
N}
N
Ntemplate<class _CharT, class _Traits>
N_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
Xconstexpr __attribute__ ((__always_inline__))
Nbool operator==(typename common_type<basic_string_view<_CharT, _Traits> >::type __lhs, 
N				basic_string_view<_CharT, _Traits> __rhs) _NOEXCEPT
X				basic_string_view<_CharT, _Traits> __rhs) noexcept
N{
N	if ( __lhs.size() != __rhs.size()) return false;
N	return __lhs.compare(__rhs) == 0;
N}
N
N
N// operator !=
Ntemplate<class _CharT, class _Traits>
N_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
Xconstexpr __attribute__ ((__always_inline__))
Nbool operator!=(basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) _NOEXCEPT
Xbool operator!=(basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) noexcept
N{
N	if ( __lhs.size() != __rhs.size())
N		return true;
N	return __lhs.compare(__rhs) != 0;
N}
N
Ntemplate<class _CharT, class _Traits>
N_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
Xconstexpr __attribute__ ((__always_inline__))
Nbool operator!=(basic_string_view<_CharT, _Traits> __lhs,
N				typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) _NOEXCEPT
X				typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) noexcept
N{
N	if ( __lhs.size() != __rhs.size())
N		return true;
N	return __lhs.compare(__rhs) != 0;
N}
N
Ntemplate<class _CharT, class _Traits>
N_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
Xconstexpr __attribute__ ((__always_inline__))
Nbool operator!=(typename common_type<basic_string_view<_CharT, _Traits> >::type __lhs, 
N				basic_string_view<_CharT, _Traits> __rhs) _NOEXCEPT
X				basic_string_view<_CharT, _Traits> __rhs) noexcept
N{
N	if ( __lhs.size() != __rhs.size())
N		return true;
N	return __lhs.compare(__rhs) != 0;
N}
N
N
N// operator <
Ntemplate<class _CharT, class _Traits>
N_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
Xconstexpr __attribute__ ((__always_inline__))
Nbool operator<(basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) _NOEXCEPT
Xbool operator<(basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) noexcept
N{
N	return __lhs.compare(__rhs) < 0;
N}
N
Ntemplate<class _CharT, class _Traits>
N_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
Xconstexpr __attribute__ ((__always_inline__))
Nbool operator<(basic_string_view<_CharT, _Traits> __lhs,
N				typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) _NOEXCEPT
X				typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) noexcept
N{
N	return __lhs.compare(__rhs) < 0;
N}
N
Ntemplate<class _CharT, class _Traits>
N_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
Xconstexpr __attribute__ ((__always_inline__))
Nbool operator<(typename common_type<basic_string_view<_CharT, _Traits> >::type __lhs, 
N				basic_string_view<_CharT, _Traits> __rhs) _NOEXCEPT
X				basic_string_view<_CharT, _Traits> __rhs) noexcept
N{
N	return __lhs.compare(__rhs) < 0;
N}
N
N
N// operator >
Ntemplate<class _CharT, class _Traits>
N_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
Xconstexpr __attribute__ ((__always_inline__))
Nbool operator> (basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) _NOEXCEPT
Xbool operator> (basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) noexcept
N{
N	return __lhs.compare(__rhs) > 0;
N}
N
Ntemplate<class _CharT, class _Traits>
N_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
Xconstexpr __attribute__ ((__always_inline__))
Nbool operator>(basic_string_view<_CharT, _Traits> __lhs,
N				typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) _NOEXCEPT
X				typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) noexcept
N{
N	return __lhs.compare(__rhs) > 0;
N}
N
Ntemplate<class _CharT, class _Traits>
N_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
Xconstexpr __attribute__ ((__always_inline__))
Nbool operator>(typename common_type<basic_string_view<_CharT, _Traits> >::type __lhs, 
N				basic_string_view<_CharT, _Traits> __rhs) _NOEXCEPT
X				basic_string_view<_CharT, _Traits> __rhs) noexcept
N{
N	return __lhs.compare(__rhs) > 0;
N}
N
N
N// operator <=
Ntemplate<class _CharT, class _Traits>
N_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
Xconstexpr __attribute__ ((__always_inline__))
Nbool operator<=(basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) _NOEXCEPT
Xbool operator<=(basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) noexcept
N{
N	return __lhs.compare(__rhs) <= 0;
N}
N
Ntemplate<class _CharT, class _Traits>
N_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
Xconstexpr __attribute__ ((__always_inline__))
Nbool operator<=(basic_string_view<_CharT, _Traits> __lhs,
N				typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) _NOEXCEPT
X				typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) noexcept
N{
N	return __lhs.compare(__rhs) <= 0;
N}
N
Ntemplate<class _CharT, class _Traits>
N_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
Xconstexpr __attribute__ ((__always_inline__))
Nbool operator<=(typename common_type<basic_string_view<_CharT, _Traits> >::type __lhs, 
N				basic_string_view<_CharT, _Traits> __rhs) _NOEXCEPT
X				basic_string_view<_CharT, _Traits> __rhs) noexcept
N{
N	return __lhs.compare(__rhs) <= 0;
N}
N
N
N// operator >=
Ntemplate<class _CharT, class _Traits>
N_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
Xconstexpr __attribute__ ((__always_inline__))
Nbool operator>=(basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) _NOEXCEPT
Xbool operator>=(basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) noexcept
N{
N	return __lhs.compare(__rhs) >= 0;
N}
N
N
Ntemplate<class _CharT, class _Traits>
N_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
Xconstexpr __attribute__ ((__always_inline__))
Nbool operator>=(basic_string_view<_CharT, _Traits> __lhs,
N				typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) _NOEXCEPT
X				typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) noexcept
N{
N	return __lhs.compare(__rhs) >= 0;
N}
N
Ntemplate<class _CharT, class _Traits>
N_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
Xconstexpr __attribute__ ((__always_inline__))
Nbool operator>=(typename common_type<basic_string_view<_CharT, _Traits> >::type __lhs, 
N				basic_string_view<_CharT, _Traits> __rhs) _NOEXCEPT
X				basic_string_view<_CharT, _Traits> __rhs) noexcept
N{
N	return __lhs.compare(__rhs) >= 0;
N}
N
Ntypedef basic_string_view<char>     string_view;
Ntypedef basic_string_view<char16_t> u16string_view;
Ntypedef basic_string_view<char32_t> u32string_view;
Ntypedef basic_string_view<wchar_t>  wstring_view;
N
N// [string.view.hash]
Ntemplate<class _CharT, class _Traits>
Nstruct _LIBCPP_TEMPLATE_VIS hash<basic_string_view<_CharT, _Traits> >
Xstruct  hash<basic_string_view<_CharT, _Traits> >
N    : public unary_function<basic_string_view<_CharT, _Traits>, size_t>
N{
N    size_t operator()(const basic_string_view<_CharT, _Traits> __val) const _NOEXCEPT;
X    size_t operator()(const basic_string_view<_CharT, _Traits> __val) const noexcept;
N};
N
Ntemplate<class _CharT, class _Traits>
Nsize_t
Nhash<basic_string_view<_CharT, _Traits> >::operator()(
N        const basic_string_view<_CharT, _Traits> __val) const _NOEXCEPT
X        const basic_string_view<_CharT, _Traits> __val) const noexcept
N{
N    return __do_string_hash(__val.data(), __val.data() + __val.size());
N}
N
N
N#if _LIBCPP_STD_VER > 11 
X#if 14 > 11 
Ninline namespace literals
N{
N  inline namespace string_view_literals
N  {
N    inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
X    inline __attribute__ ((__always_inline__)) constexpr
N    basic_string_view<char> operator "" sv(const char *__str, size_t __len) _NOEXCEPT
X    basic_string_view<char> operator "" sv(const char *__str, size_t __len) noexcept
N    {
N        return basic_string_view<char> (__str, __len);
N    }
N
N    inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
X    inline __attribute__ ((__always_inline__)) constexpr
N    basic_string_view<wchar_t> operator "" sv(const wchar_t *__str, size_t __len) _NOEXCEPT
X    basic_string_view<wchar_t> operator "" sv(const wchar_t *__str, size_t __len) noexcept
N    {
N        return basic_string_view<wchar_t> (__str, __len);
N    }
N
N    inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
X    inline __attribute__ ((__always_inline__)) constexpr
N    basic_string_view<char16_t> operator "" sv(const char16_t *__str, size_t __len) _NOEXCEPT
X    basic_string_view<char16_t> operator "" sv(const char16_t *__str, size_t __len) noexcept
N    {
N        return basic_string_view<char16_t> (__str, __len);
N    }
N
N    inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
X    inline __attribute__ ((__always_inline__)) constexpr
N    basic_string_view<char32_t> operator "" sv(const char32_t *__str, size_t __len) _NOEXCEPT
X    basic_string_view<char32_t> operator "" sv(const char32_t *__str, size_t __len) noexcept
N    {
N        return basic_string_view<char32_t> (__str, __len);
N    }
N  }
N}
N#endif
N_LIBCPP_END_NAMESPACE_STD
X} }
N
N_LIBCPP_POP_MACROS
X_Pragma("pop_macro(\"min\")") _Pragma("pop_macro(\"max\")")
N
N#endif // _LIBCPP_STRING_VIEW
L 471 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/string" 2
N#include <iosfwd>
N#include <cstring>
N#include <cstdio>  // For EOF.
N#include <cwchar>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/cwchar" 1
N// -*- C++ -*-
N//===--------------------------- cwchar -----------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is dual licensed under the MIT and the University of Illinois Open
N// Source Licenses. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP_CWCHAR
N#define _LIBCPP_CWCHAR
N
N/*
N    cwchar synopsis
N
NMacros:
N
N    NULL
N    WCHAR_MAX
N    WCHAR_MIN
N    WEOF
N
Nnamespace std
N{
N
NTypes:
N
N    mbstate_t
N    size_t
N    tm
N    wint_t
N
Nint fwprintf(FILE* restrict stream, const wchar_t* restrict format, ...);
Nint fwscanf(FILE* restrict stream, const wchar_t* restrict format, ...);
Nint swprintf(wchar_t* restrict s, size_t n, const wchar_t* restrict format, ...);
Nint swscanf(const wchar_t* restrict s, const wchar_t* restrict format, ...);
Nint vfwprintf(FILE* restrict stream, const wchar_t* restrict format, va_list arg);
Nint vfwscanf(FILE* restrict stream, const wchar_t* restrict format, va_list arg);  // C99
Nint vswprintf(wchar_t* restrict s, size_t n, const wchar_t* restrict format, va_list arg);
Nint vswscanf(const wchar_t* restrict s, const wchar_t* restrict format, va_list arg);  // C99
Nint vwprintf(const wchar_t* restrict format, va_list arg);
Nint vwscanf(const wchar_t* restrict format, va_list arg);  // C99
Nint wprintf(const wchar_t* restrict format, ...);
Nint wscanf(const wchar_t* restrict format, ...);
Nwint_t fgetwc(FILE* stream);
Nwchar_t* fgetws(wchar_t* restrict s, int n, FILE* restrict stream);
Nwint_t fputwc(wchar_t c, FILE* stream);
Nint fputws(const wchar_t* restrict s, FILE* restrict stream);
Nint fwide(FILE* stream, int mode);
Nwint_t getwc(FILE* stream);
Nwint_t getwchar();
Nwint_t putwc(wchar_t c, FILE* stream);
Nwint_t putwchar(wchar_t c);
Nwint_t ungetwc(wint_t c, FILE* stream);
Ndouble wcstod(const wchar_t* restrict nptr, wchar_t** restrict endptr);
Nfloat wcstof(const wchar_t* restrict nptr, wchar_t** restrict endptr);         // C99
Nlong double wcstold(const wchar_t* restrict nptr, wchar_t** restrict endptr);  // C99
Nlong wcstol(const wchar_t* restrict nptr, wchar_t** restrict endptr, int base);
Nlong long wcstoll(const wchar_t* restrict nptr, wchar_t** restrict endptr, int base);  // C99
Nunsigned long wcstoul(const wchar_t* restrict nptr, wchar_t** restrict endptr, int base);
Nunsigned long long wcstoull(const wchar_t* restrict nptr, wchar_t** restrict endptr, int base);  // C99
Nwchar_t* wcscpy(wchar_t* restrict s1, const wchar_t* restrict s2);
Nwchar_t* wcsncpy(wchar_t* restrict s1, const wchar_t* restrict s2, size_t n);
Nwchar_t* wcscat(wchar_t* restrict s1, const wchar_t* restrict s2);
Nwchar_t* wcsncat(wchar_t* restrict s1, const wchar_t* restrict s2, size_t n);
Nint wcscmp(const wchar_t* s1, const wchar_t* s2);
Nint wcscoll(const wchar_t* s1, const wchar_t* s2);
Nint wcsncmp(const wchar_t* s1, const wchar_t* s2, size_t n);
Nsize_t wcsxfrm(wchar_t* restrict s1, const wchar_t* restrict s2, size_t n);
Nconst wchar_t* wcschr(const wchar_t* s, wchar_t c);
N      wchar_t* wcschr(      wchar_t* s, wchar_t c);
Nsize_t wcscspn(const wchar_t* s1, const wchar_t* s2);
Nsize_t wcslen(const wchar_t* s);
Nconst wchar_t* wcspbrk(const wchar_t* s1, const wchar_t* s2);
N      wchar_t* wcspbrk(      wchar_t* s1, const wchar_t* s2);
Nconst wchar_t* wcsrchr(const wchar_t* s, wchar_t c);
N      wchar_t* wcsrchr(      wchar_t* s, wchar_t c);
Nsize_t wcsspn(const wchar_t* s1, const wchar_t* s2);
Nconst wchar_t* wcsstr(const wchar_t* s1, const wchar_t* s2);
N      wchar_t* wcsstr(      wchar_t* s1, const wchar_t* s2);
Nwchar_t* wcstok(wchar_t* restrict s1, const wchar_t* restrict s2, wchar_t** restrict ptr);
Nconst wchar_t* wmemchr(const wchar_t* s, wchar_t c, size_t n);
N      wchar_t* wmemchr(      wchar_t* s, wchar_t c, size_t n);
Nint wmemcmp(wchar_t* restrict s1, const wchar_t* restrict s2, size_t n);
Nwchar_t* wmemcpy(wchar_t* restrict s1, const wchar_t* restrict s2, size_t n);
Nwchar_t* wmemmove(wchar_t* s1, const wchar_t* s2, size_t n);
Nwchar_t* wmemset(wchar_t* s, wchar_t c, size_t n);
Nsize_t wcsftime(wchar_t* restrict s, size_t maxsize, const wchar_t* restrict format,
N                const tm* restrict timeptr);
Nwint_t btowc(int c);
Nint wctob(wint_t c);
Nint mbsinit(const mbstate_t* ps);
Nsize_t mbrlen(const char* restrict s, size_t n, mbstate_t* restrict ps);
Nsize_t mbrtowc(wchar_t* restrict pwc, const char* restrict s, size_t n, mbstate_t* restrict ps);
Nsize_t wcrtomb(char* restrict s, wchar_t wc, mbstate_t* restrict ps);
Nsize_t mbsrtowcs(wchar_t* restrict dst, const char** restrict src, size_t len,
N                 mbstate_t* restrict ps);
Nsize_t wcsrtombs(char* restrict dst, const wchar_t** restrict src, size_t len,
N                 mbstate_t* restrict ps);
N
N}  // std
N
N*/
N
N#include <__config>
N#include <cwctype>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/cwctype" 1
N// -*- C++ -*-
N//===--------------------------- cwctype ----------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is dual licensed under the MIT and the University of Illinois Open
N// Source Licenses. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP_CWCTYPE
N#define _LIBCPP_CWCTYPE
N
N/*
N    cwctype synopsis
N
NMacros:
N
N    WEOF
N
Nnamespace std
N{
N
NTypes:
N
N    wint_t
N    wctrans_t
N    wctype_t
N
Nint iswalnum(wint_t wc);
Nint iswalpha(wint_t wc);
Nint iswblank(wint_t wc);  // C99
Nint iswcntrl(wint_t wc);
Nint iswdigit(wint_t wc);
Nint iswgraph(wint_t wc);
Nint iswlower(wint_t wc);
Nint iswprint(wint_t wc);
Nint iswpunct(wint_t wc);
Nint iswspace(wint_t wc);
Nint iswupper(wint_t wc);
Nint iswxdigit(wint_t wc);
Nint iswctype(wint_t wc, wctype_t desc);
Nwctype_t wctype(const char* property);
Nwint_t towlower(wint_t wc);
Nwint_t towupper(wint_t wc);
Nwint_t towctrans(wint_t wc, wctrans_t desc);
Nwctrans_t wctrans(const char* property);
N
N}  // std
N
N*/
N
N#include <__config>
N#include <cctype>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/cctype" 1
N// -*- C++ -*-
N//===---------------------------- cctype ----------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is dual licensed under the MIT and the University of Illinois Open
N// Source Licenses. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP_CCTYPE
N#define _LIBCPP_CCTYPE
N
N/*
N    cctype synopsis
N
Nnamespace std
N{
N
Nint isalnum(int c);
Nint isalpha(int c);
Nint isblank(int c);  // C99
Nint iscntrl(int c);
Nint isdigit(int c);
Nint isgraph(int c);
Nint islower(int c);
Nint isprint(int c);
Nint ispunct(int c);
Nint isspace(int c);
Nint isupper(int c);
Nint isxdigit(int c);
Nint tolower(int c);
Nint toupper(int c);
N
N}  // std
N*/
N
N#include <__config>
N#include <ctype.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/ctype.h" 1
N/* -*- C++ -*- */
N/*===--------------------------- complex.h --------------------------------===*/
N/*                                                                            */
N/*                     The LLVM Compiler Infrastructure                       */
N/*                                                                            */
N/* This file is dual licensed under the MIT and the University of Illinois Open
N** Source Licenses. See LICENSE.TXT for details.
N*/
N/*===----------------------------------------------------------------------===*/
N
N#ifndef _LIBCPP_CTYPE_H
N#define _LIBCPP_CTYPE_H
N
N/*
N    ctype.h synopsis
N
Nint isalnum(int c);
Nint isalpha(int c);
Nint isblank(int c);  // C99
Nint iscntrl(int c);
Nint isdigit(int c);
Nint isgraph(int c);
Nint islower(int c);
Nint isprint(int c);
Nint ispunct(int c);
Nint isspace(int c);
Nint isupper(int c);
Nint isxdigit(int c);
Nint tolower(int c);
Nint toupper(int c);
N*/
N
N#include <__config>
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N#include_next <ctype.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/ctype.h" 1
N/*****************************************************************************/
N/* ctype.h                                                                   */
N/*                                                                           */
N/* Copyright (c) 1993 Texas Instruments Incorporated                         */
N/* http://www.ti.com/                                                        */
N/*                                                                           */
N/*  Redistribution and  use in source  and binary forms, with  or without    */
N/*  modification,  are permitted provided  that the  following conditions    */
N/*  are met:                                                                 */
N/*                                                                           */
N/*     Redistributions  of source  code must  retain the  above copyright    */
N/*     notice, this list of conditions and the following disclaimer.         */
N/*                                                                           */
N/*     Redistributions in binary form  must reproduce the above copyright    */
N/*     notice, this  list of conditions  and the following  disclaimer in    */
N/*     the  documentation  and/or   other  materials  provided  with  the    */
N/*     distribution.                                                         */
N/*                                                                           */
N/*     Neither the  name of Texas Instruments Incorporated  nor the names    */
N/*     of its  contributors may  be used to  endorse or  promote products    */
N/*     derived  from   this  software  without   specific  prior  written    */
N/*     permission.                                                           */
N/*                                                                           */
N/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS    */
N/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT    */
N/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    */
N/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT    */
N/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    */
N/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT    */
N/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    */
N/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    */
N/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT    */
N/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    */
N/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     */
N/*                                                                           */
N/*****************************************************************************/
N
N/************************************************************************/
N/*                                                                      */
N/*  CHARACTER TYPING FUNCTIONS AND MACROS                               */
N/*                                                                      */
N/*  Note that in this implementation, either macros or functions may    */
N/*  be used.  Macros are prefixed with an underscore.                   */
N/*                                                                      */
N/************************************************************************/
N#ifndef _CTYPE_H_
N#define _CTYPE_H_
N
N#include <_ti_config.h>
N
N#if defined(__TMS320C2000__)
X#if 0L
S#if defined(__TMS320C28XX_CLA__)
S#error "Header file <ctype.h> not supported by CLA compiler"
S#endif
N#endif
N
N#pragma diag_push
N#pragma CHECK_MISRA("-6.3") /* standard types required for standard headers */
N#pragma CHECK_MISRA("-8.5") /* need to define inline function */
N#pragma CHECK_MISRA("-19.1") /* #includes required for implementation */
N#pragma CHECK_MISRA("-19.7") /* macros required for implementation */
N#pragma CHECK_MISRA("-20.2") /* standard headers must define standard names */
N
N#ifdef __cplusplus
Nextern "C"
N{
N#endif /* __cplusplus */
N
Nextern const _DATA_ACCESS unsigned char _ctypes_[257];
Xextern const  unsigned char _ctypes_[257];
N
N/************************************************************************/
N/*   FUNCTION DECLARATIONS                                              */
N/************************************************************************/
N#include "_isfuncdcl.h"
L 1 "C:\ti\ccs930\ccs\tools\compiler\ti-cgt-arm_18.12.5.LTS\include\_isfuncdcl.h" 1
N/****************************************************************************/
N/*  _ISFUNCDCL.H                                                            */
N/*                                                                          */
N/* Copyright (c) 2005 Texas Instruments Incorporated                        */
N/* http://www.ti.com/                                                       */
N/*                                                                          */
N/*  Redistribution and  use in source  and binary forms, with  or without   */
N/*  modification,  are permitted provided  that the  following conditions   */
N/*  are met:                                                                */
N/*                                                                          */
N/*     Redistributions  of source  code must  retain the  above copyright   */
N/*     notice, this list of conditions and the following disclaimer.        */
N/*                                                                          */
N/*     Redistributions in binary form  must reproduce the above copyright   */
N/*     notice, this  list of conditions  and the following  disclaimer in   */
N/*     the  documentation  and/or   other  materials  provided  with  the   */
N/*     distribution.                                                        */
N/*                                                                          */
N/*     Neither the  name of Texas Instruments Incorporated  nor the names   */
N/*     of its  contributors may  be used to  endorse or  promote products   */
N/*     derived  from   this  software  without   specific  prior  written   */
N/*     permission.                                                          */
N/*                                                                          */
N/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS   */
N/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT   */
N/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR   */
N/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT   */
N/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,   */
N/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT   */
N/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,   */
N/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY   */
N/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT   */
N/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE   */
N/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.    */
N/*                                                                          */
N/****************************************************************************/
N
N#ifndef __ISFUNCDCL
N#define __ISFUNCDCL
N
N#include <_ti_config.h>
N
N_IDECL int isalnum(int _c);
Xextern  int isalnum(int _c);
N_IDECL int isalpha(int _c);
Xextern  int isalpha(int _c);
N_IDECL int isblank(int _c);
Xextern  int isblank(int _c);
N_IDECL int iscntrl(int _c);
Xextern  int iscntrl(int _c);
N_IDECL int isdigit(int _c);
Xextern  int isdigit(int _c);
N_IDECL int isgraph(int _c);
Xextern  int isgraph(int _c);
N_IDECL int islower(int _c);
Xextern  int islower(int _c);
N_IDECL int isprint(int _c);
Xextern  int isprint(int _c);
N_IDECL int ispunct(int _c);
Xextern  int ispunct(int _c);
N_IDECL int isspace(int _c);
Xextern  int isspace(int _c);
N_IDECL int isupper(int _c);
Xextern  int isupper(int _c);
N_IDECL int isxdigit(int _c);
Xextern  int isxdigit(int _c);
N_IDECL int isascii(int _c);
Xextern  int isascii(int _c);
N_IDECL int toascii(int _c);
Xextern  int toascii(int _c);
N
N#endif
L 75 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/ctype.h" 2
N
N_IDECL int toupper(int ch);
Xextern  int toupper(int ch);
N_IDECL int tolower(int ch);
Xextern  int tolower(int ch);
N
N#ifdef __cplusplus
N} /* extern "C" */
N#endif /* __cplusplus */
N
N#if (defined(__clang__) && defined(__arm__)) || \
N    (defined(_AEABI_PORTABILITY_LEVEL) && _AEABI_PORTABILITY_LEVEL != 0)
X#if (0L && 0L) ||     (0L && _AEABI_PORTABILITY_LEVEL != 0)
Sextern unsigned char const __aeabi_ctype_table_C[257];  /* "C" locale */
Sextern unsigned char const __aeabi_ctype_table_[257];    /* default locale */
S
S  #ifdef _AEABI_LC_CTYPE
S     #define _AEABI_CTYPE_TABLE(_X) __aeabi_ctype_table_ ## _X
S     #define _AEABI_CTYPE(_X) _AEABI_CTYPE_TABLE(_X)
S     #define __aeabi_ctype_table _AEABI_CTYPE(_AEABI_LC_CTYPE)
S  #else
S     #define __aeabi_ctype_table __aeabi_ctype_table_
S  #endif
S
S/* AEABI portable ctype flag bits */
S#define _ABI_A  ((unsigned char)  1)       /* alphabetic        */
S#define _ABI_X  ((unsigned char)  2)       /* A-F, a-f and 0-9  */
S#define _ABI_P  ((unsigned char)  4)       /* punctuation       */
S#define _ABI_B  ((unsigned char)  8)       /* blank             */
S#define _ABI_S  ((unsigned char) 16)       /* white space       */
S#define _ABI_L  ((unsigned char) 32)       /* lower case letter */
S#define _ABI_U  ((unsigned char) 64)       /* upper case letter */
S#define _ABI_C  ((unsigned char)128)       /* control chars     */
S
S#define _isspace(x)  ((__aeabi_ctype_table+1)[(x)] & _ABI_S)
S#define _isalpha(x)  ((__aeabi_ctype_table+1)[(x)] & _ABI_A)
S#define _isalnum(x)  ((__aeabi_ctype_table+1)[(x)] << 30) /* test for _ABI_A and _ABI_X */
S#define _isprint(x)  ((__aeabi_ctype_table+1)[(x)] << 28) /* test for _ABI_A, _ABI_X, _ABI_P and _ABI_B */
S#define _isupper(x)  ((__aeabi_ctype_table+1)[(x)] & _ABI_U)
S#define _islower(x)  ((__aeabi_ctype_table+1)[(x)] & _ABI_L)
S#define _isxdigit(x) ((__aeabi_ctype_table+1)[(x)] & _ABI_X)
S#define _isgraph(x)  ((__aeabi_ctype_table+1)[(x)] << 29) /* test for _ABI_A, _ABI_X and _ABI_P */
S#define _iscntrl(x)  ((__aeabi_ctype_table+1)[(x)] & _ABI_C)
S#define _ispunct(x)  ((__aeabi_ctype_table+1)[(x)] & _ABI_P)
S#define _isdigit(c)  (((unsigned)(c) - (unsigned)'0') < 10)
S
N#else
N
N/************************************************************************/
N/*  On this ELSE path, all the TI ctype table and ctype bit flags are   */
N/*  defined.                                                            */
N/************************************************************************/
N/************************************************************************/
N/*  MACRO DEFINITIONS                                                   */
N/************************************************************************/
N#define _U_   ((unsigned char)0x01)       /* upper case letter */
N#define _L_   ((unsigned char)0x02)       /* lower case letter */
N#define _N_   ((unsigned char)0x04)       /* digit             */
N#define _S_   ((unsigned char)0x08)       /* white space       */
N#define _P_   ((unsigned char)0x10)       /* punctuation       */
N#define _C_   ((unsigned char)0x20)       /* control chars     */
N#define _H_   ((unsigned char)0x40)       /* A-F, a-f and 0-9  */
N#define _B_   ((unsigned char)0x80)       /* blank             */
N
N#define _isalnum(a)  (_ctypes_[(a)+1] & (_U_ | _L_ | _N_))
N#define _isalpha(a)  (_ctypes_[(a)+1] & (_U_ | _L_))
N#define _iscntrl(a)  (_ctypes_[(a)+1] & _C_)
N#define _isdigit(a)  (_ctypes_[(a)+1] & _N_)
N#define _isgraph(a)  (_ctypes_[(a)+1] & (_U_ | _L_ | _N_ | _P_))
N#define _islower(a)  (_ctypes_[(a)+1] & _L_)
N#define _isprint(a)  (_ctypes_[(a)+1] & (_B_ | _U_ | _L_ | _N_ | _P_))
N#define _ispunct(a)  (_ctypes_[(a)+1] & _P_)
N#define _isspace(a)  (_ctypes_[(a)+1] & _S_)
N#define _isupper(a)  (_ctypes_[(a)+1] & _U_)
N#define _isxdigit(a) (_ctypes_[(a)+1] & _H_)
N
N#endif /* _AEABI_PORTABILITY_LEVEL */
N
N#define _isascii(a)  (((unsigned int)(a) & ~(unsigned int)0x7F) == 0u)
N#define _toupper(b)  ((_islower(b)) ? (b) - ('a' - 'A') : (b))
N#define _tolower(b)  ((_isupper(b)) ? (b) + ('a' - 'A') : (b))
N#define _toascii(a)  ((unsigned int)(a) & (unsigned int)0x7F)
N
N#ifdef _INLINE
S
S#include "_isfuncdef.h"
S
S/****************************************************************************/
S/*  tolower                                                                 */
S/****************************************************************************/
Sstatic __inline int tolower(int ch)
S{
S   /*
S    This code depends on two assumptions: (1) all of the letters of the
S    alphabet of a given case are contiguous, and (2) the lower and upper
S    case forms of each letter are displaced from each other by the same
S    constant value.
S   */
S
S   if ( ((unsigned int)ch  - (unsigned int)'A') <=
S        ((unsigned int)'Z' - (unsigned int)'A'))
S   {
S      ch += (int)'a' - (int)'A';
S   }
S
S   return ch;
S}
S
S/****************************************************************************/
S/*  toupper                                                                 */
S/****************************************************************************/
Sstatic __inline int toupper(int ch)
S{
S   /*
S    This code depends on two assumptions: (1) all of the letters of the
S    alphabet of a given case are contiguous, and (2) the lower and upper
S    case forms of each letter are displaced from each other by the same
S    constant value.
S   */
S
S   if ( ((unsigned int)ch  - (unsigned int)'a') <=
S        ((unsigned int)'z' - (unsigned int)'a'))
S   {
S      ch -= (int)'a' - (int)'A';
S   }
S
S   return ch;
S}
S
N#endif /* _INLINE */
N
N#if defined(_AEABI_PORTABILITY_LEVEL) && _AEABI_PORTABILITY_LEVEL != 0 && \
N   !defined(_AEABI_PORTABLE)
X#if 0L && _AEABI_PORTABILITY_LEVEL != 0 &&    !0L
S#define _AEABI_PORTABLE
N#endif
N
N#pragma diag_pop
N
N#endif /* ! _CTYPE_H_ */
L 40 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/ctype.h" 2
N
N#ifdef __cplusplus
N
N#undef isalnum
N#undef isalpha
N#undef isblank
N#undef iscntrl
N#undef isdigit
N#undef isgraph
N#undef islower
N#undef isprint
N#undef ispunct
N#undef isspace
N#undef isupper
N#undef isxdigit
N#undef tolower
N#undef toupper
N
N#endif
N
N#endif  /* _LIBCPP_CTYPE_H */
L 40 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/cctype" 2
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N_LIBCPP_BEGIN_NAMESPACE_STD
Xnamespace std { inline namespace __2 {
N
N#ifdef isalnum
S#undef isalnum
N#endif
N
N#ifdef isalpha
S#undef isalpha
N#endif
N
N#ifdef isblank
S#undef isblank
N#endif
N
N#ifdef iscntrl
S#undef iscntrl
N#endif
N
N#ifdef isdigit
S#undef isdigit
N#endif
N
N#ifdef isgraph
S#undef isgraph
N#endif
N
N#ifdef islower
S#undef islower
N#endif
N
N#ifdef isprint
S#undef isprint
N#endif
N
N#ifdef ispunct
S#undef ispunct
N#endif
N
N#ifdef isspace
S#undef isspace
N#endif
N
N#ifdef isupper
S#undef isupper
N#endif
N
N#ifdef isxdigit
S#undef isxdigit
N#endif
N
N#ifdef tolower
S#undef tolower
N#endif
N
N#ifdef toupper
S#undef toupper
N#endif
N
N
Nusing ::isalnum;
Nusing ::isalpha;
Nusing ::isblank;
Nusing ::iscntrl;
Nusing ::isdigit;
Nusing ::isgraph;
Nusing ::islower;
Nusing ::isprint;
Nusing ::ispunct;
Nusing ::isspace;
Nusing ::isupper;
Nusing ::isxdigit;
Nusing ::tolower;
Nusing ::toupper;
N
N_LIBCPP_END_NAMESPACE_STD
X} }
N
N#endif  // _LIBCPP_CCTYPE
L 55 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/cwctype" 2
N#include <wctype.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/wctype.h" 1
N/* -*- C++ -*- */
N/*===--------------------------- complex.h --------------------------------===*/
N/*                                                                            */
N/*                     The LLVM Compiler Infrastructure                       */
N/*                                                                            */
N/* This file is dual licensed under the MIT and the University of Illinois Open
N** Source Licenses. See LICENSE.TXT for details.
N*/
N/*===----------------------------------------------------------------------===*/
N
N#ifndef _LIBCPP_WCTYPE_H
N#define _LIBCPP_WCTYPE_H
N
N/*
N    wctype.h synopsis
N
NMacros:
N
N    WEOF
N
NTypes:
N
N    wint_t
N    wctrans_t
N    wctype_t
N
Nint iswalnum(wint_t wc);
Nint iswalpha(wint_t wc);
Nint iswblank(wint_t wc);  // C99
Nint iswcntrl(wint_t wc);
Nint iswdigit(wint_t wc);
Nint iswgraph(wint_t wc);
Nint iswlower(wint_t wc);
Nint iswprint(wint_t wc);
Nint iswpunct(wint_t wc);
Nint iswspace(wint_t wc);
Nint iswupper(wint_t wc);
Nint iswxdigit(wint_t wc);
Nint iswctype(wint_t wc, wctype_t desc);
Nwctype_t wctype(const char* property);
Nwint_t towlower(wint_t wc);
Nwint_t towupper(wint_t wc);
Nwint_t towctrans(wint_t wc, wctrans_t desc);
Nwctrans_t wctrans(const char* property);
N
N*/
N
N#include <__config>
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N#include_next <wctype.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/wctype.h" 1
N/*****************************************************************************/
N/* wctype.h                                                                  */
N/*                                                                           */
N/* Copyright (c) 2007 Texas Instruments Incorporated                         */
N/* http://www.ti.com/                                                        */
N/*                                                                           */
N/*  Redistribution and  use in source  and binary forms, with  or without    */
N/*  modification,  are permitted provided  that the  following conditions    */
N/*  are met:                                                                 */
N/*                                                                           */
N/*     Redistributions  of source  code must  retain the  above copyright    */
N/*     notice, this list of conditions and the following disclaimer.         */
N/*                                                                           */
N/*     Redistributions in binary form  must reproduce the above copyright    */
N/*     notice, this  list of conditions  and the following  disclaimer in    */
N/*     the  documentation  and/or   other  materials  provided  with  the    */
N/*     distribution.                                                         */
N/*                                                                           */
N/*     Neither the  name of Texas Instruments Incorporated  nor the names    */
N/*     of its  contributors may  be used to  endorse or  promote products    */
N/*     derived  from   this  software  without   specific  prior  written    */
N/*     permission.                                                           */
N/*                                                                           */
N/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS    */
N/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT    */
N/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    */
N/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT    */
N/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    */
N/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT    */
N/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    */
N/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    */
N/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT    */
N/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    */
N/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     */
N/*                                                                           */
N/*****************************************************************************/
N
N/************************************************************************/
N/*                                                                      */
N/*  WIDE CHARACTER TYPING FUNCTIONS AND MACROS                          */
N/*                                                                      */
N/************************************************************************/
N#ifndef _WCTYPE_H_
N#define _WCTYPE_H_
N
N#include <_ti_config.h>
N
N#if defined(__TMS320C2000__)
X#if 0L
S#if defined(__TMS320C28XX_CLA__)
S#error "Header file <wctype.h> not supported by CLA compiler"
S#endif
N#endif
N
N#ifdef __cplusplus
Nextern "C"
N{
N#endif /* __cplusplus */
N
N#ifndef WEOF
S#define WEOF ((wint_t)(-1))
N#endif
N
N/************************************************************************/
N/*   TYPES                                                              */
N/************************************************************************/
N#ifndef _WINT_T_DECLARED
S#define _WINT_T_DECLARED
S#if defined(__TMS320C6X__) && !defined(__C6X_MIGRATION__) && defined(__TI_EABI__)
Stypedef unsigned int wint_t;
S#elif defined (__TMS320C2000__) && defined (__TI_EABI__)
Stypedef unsigned long wint_t;
S#else
Stypedef int wint_t;
S#endif
N#endif
N
Ntypedef void *wctrans_t;
Ntypedef void *wctype_t;
N
N/************************************************************************/
N/*   FUNCTION DECLARATIONS                                              */
N/************************************************************************/
N_CODE_ACCESS int       iswalnum(wint_t _c);
X int       iswalnum(wint_t _c);
N_CODE_ACCESS int       iswalpha(wint_t _c);
X int       iswalpha(wint_t _c);
N_CODE_ACCESS int       iswblank(wint_t _c);
X int       iswblank(wint_t _c);
N_CODE_ACCESS int       iswcntrl(wint_t _c);
X int       iswcntrl(wint_t _c);
N_CODE_ACCESS int       iswdigit(wint_t _c);
X int       iswdigit(wint_t _c);
N_CODE_ACCESS int       iswgraph(wint_t _c);
X int       iswgraph(wint_t _c);
N_CODE_ACCESS int       iswlower(wint_t _c);
X int       iswlower(wint_t _c);
N_CODE_ACCESS int       iswprint(wint_t _c);
X int       iswprint(wint_t _c);
N_CODE_ACCESS int       iswpunct(wint_t _c);
X int       iswpunct(wint_t _c);
N_CODE_ACCESS int       iswspace(wint_t _c);
X int       iswspace(wint_t _c);
N_CODE_ACCESS int       iswupper(wint_t _c);
X int       iswupper(wint_t _c);
N_CODE_ACCESS int       iswxdigit(wint_t _c);
X int       iswxdigit(wint_t _c);
N_CODE_ACCESS int       iswascii(wint_t _c);
X int       iswascii(wint_t _c);
N
N_CODE_ACCESS wctype_t  wctype(const char *property);
X wctype_t  wctype(const char *property);
N_CODE_ACCESS int       iswctype(wint_t c, wctype_t category);
X int       iswctype(wint_t c, wctype_t category);
N
N_CODE_ACCESS wint_t    towupper(wint_t _c);
X wint_t    towupper(wint_t _c);
N_CODE_ACCESS wint_t    towlower(wint_t _c);
X wint_t    towlower(wint_t _c);
N_CODE_ACCESS wint_t    towascii(wint_t _c);
X wint_t    towascii(wint_t _c);
N
N_CODE_ACCESS wctrans_t wctrans(const char *property);
X wctrans_t wctrans(const char *property);
N_CODE_ACCESS wint_t    towctrans(wint_t c, wctrans_t category);
X wint_t    towctrans(wint_t c, wctrans_t category);
N
N#ifdef __cplusplus
N} /* extern "C" */
N#endif /* __cplusplus */
N
N#endif /* ! _WCTYPE_H_ */
N
N/*----------------------------------------------------------------------------*/
N/* If sys/cdefs.h is available, go ahead and include it. xlocale.h assumes    */
N/* this file will have already included sys/cdefs.h.                          */
N/*----------------------------------------------------------------------------*/
N#if __has_include(<sys/cdefs.h>)
X#if 1
N#include <sys/cdefs.h>
N#endif
N
N/*----------------------------------------------------------------------------*/
N/* Include xlocale/_ctype.h> if POSIX is enabled. This will expose the        */
N/* xlocale wctype interface.                                                  */
N/*----------------------------------------------------------------------------*/
N#if defined(__POSIX_VISIBLE) && __POSIX_VISIBLE >= 200809
X#if 1L && 200809 >= 200809
N__BEGIN_DECLS
Xextern "C" {
N#define _XLOCALE_WCTYPES 1
N#include <xlocale/_ctype.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/xlocale/_ctype.h" 1
N/*****************************************************************************/
N/*  _CTYPE.H                                                                 */
N/*                                                                           */
N/* Copyright (c) 2017 Texas Instruments Incorporated                         */
N/* http://www.ti.com/                                                        */
N/*                                                                           */
N/*  Redistribution and  use in source  and binary forms, with  or without    */
N/*  modification,  are permitted provided  that the  following conditions    */
N/*  are met:                                                                 */
N/*                                                                           */
N/*     Redistributions  of source  code must  retain the  above copyright    */
N/*     notice, this list of conditions and the following disclaimer.         */
N/*                                                                           */
N/*     Redistributions in binary form  must reproduce the above copyright    */
N/*     notice, this  list of conditions  and the following  disclaimer in    */
N/*     the  documentation  and/or   other  materials  provided  with  the    */
N/*     distribution.                                                         */
N/*                                                                           */
N/*     Neither the  name of Texas Instruments Incorporated  nor the names    */
N/*     of its  contributors may  be used to  endorse or  promote products    */
N/*     derived  from   this  software  without   specific  prior  written    */
N/*     permission.                                                           */
N/*                                                                           */
N/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS    */
N/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT    */
N/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    */
N/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT    */
N/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    */
N/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT    */
N/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    */
N/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    */
N/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT    */
N/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    */
N/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     */
N/*                                                                           */
N/*****************************************************************************/
N
N/*-
N * SPDX-License-Identifier: BSD-2-Clause-FreeBSD
N *
N * Copyright (c) 2011 The FreeBSD Foundation
N * All rights reserved.
N *
N * This software was developed by David Chisnall under sponsorship from
N * the FreeBSD Foundation.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N * 1. Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
N * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
N * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
N * SUCH DAMAGE.
N *
N * $FreeBSD$
N */
N
N
N#if	(defined(_XLOCALE_WCTYPES) && !defined(_XLOCALE_WCTYPE_H)) || \
N	(!defined(_XLOCALE_WCTYPES) && !defined(_XLOCALE_CTYPE_H))
X#if	(1L && !0L) || 	(!1L && !0L)
N
N#ifdef _XLOCALE_WCTYPES
N#define _XLOCALE_WCTYPE_H
N#else
S#define _XLOCALE_CTYPE_H
N#endif
N
N#ifndef _LOCALE_T_DEFINED
S#define _LOCALE_T_DEFINED
Stypedef struct	_xlocale *locale_t;
N#endif
N
N#ifndef _XLOCALE_INLINE
N#define _XLOCALE_INLINE static __inline
N#endif /* _XLOCALE_INLINE */
N
N#ifdef _XLOCALE_WCTYPES
N
N#define XLOCALE_ISCTYPE(fname, cat) \
N		_XLOCALE_INLINE int isw##fname##_l(int, locale_t);\
N		_XLOCALE_INLINE int isw##fname##_l(int __c, locale_t __l)\
N                { return isw##fname(__c); }
X#define XLOCALE_ISCTYPE(fname, cat) 		_XLOCALE_INLINE int isw##fname##_l(int, locale_t);		_XLOCALE_INLINE int isw##fname##_l(int __c, locale_t __l)                { return isw##fname(__c); }
N#else
S#define XLOCALE_ISCTYPE(__fname, __cat)                             \
S		_XLOCALE_INLINE int is##__fname##_l(int, locale_t); \
S		_XLOCALE_INLINE int is##__fname##_l(int __c, locale_t __l)\
S		{ return is##__fname(__c); }
X#define XLOCALE_ISCTYPE(__fname, __cat)                             		_XLOCALE_INLINE int is##__fname##_l(int, locale_t); 		_XLOCALE_INLINE int is##__fname##_l(int __c, locale_t __l)		{ return is##__fname(__c); }
N#endif
N
NXLOCALE_ISCTYPE(alnum, _CTYPE_A|_CTYPE_D|_CTYPE_N)
Xstatic inline int iswalnum_l(int, locale_t); static inline int iswalnum_l(int __c, locale_t __l) { return iswalnum(__c); }
NXLOCALE_ISCTYPE(alpha, _CTYPE_A)
Xstatic inline int iswalpha_l(int, locale_t); static inline int iswalpha_l(int __c, locale_t __l) { return iswalpha(__c); }
NXLOCALE_ISCTYPE(blank, _CTYPE_B)
Xstatic inline int iswblank_l(int, locale_t); static inline int iswblank_l(int __c, locale_t __l) { return iswblank(__c); }
NXLOCALE_ISCTYPE(cntrl, _CTYPE_C)
Xstatic inline int iswcntrl_l(int, locale_t); static inline int iswcntrl_l(int __c, locale_t __l) { return iswcntrl(__c); }
NXLOCALE_ISCTYPE(digit, _CTYPE_D)
Xstatic inline int iswdigit_l(int, locale_t); static inline int iswdigit_l(int __c, locale_t __l) { return iswdigit(__c); }
NXLOCALE_ISCTYPE(graph, _CTYPE_G)
Xstatic inline int iswgraph_l(int, locale_t); static inline int iswgraph_l(int __c, locale_t __l) { return iswgraph(__c); }
NXLOCALE_ISCTYPE(lower, _CTYPE_L)
Xstatic inline int iswlower_l(int, locale_t); static inline int iswlower_l(int __c, locale_t __l) { return iswlower(__c); }
NXLOCALE_ISCTYPE(print, _CTYPE_R)
Xstatic inline int iswprint_l(int, locale_t); static inline int iswprint_l(int __c, locale_t __l) { return iswprint(__c); }
NXLOCALE_ISCTYPE(punct, _CTYPE_P)
Xstatic inline int iswpunct_l(int, locale_t); static inline int iswpunct_l(int __c, locale_t __l) { return iswpunct(__c); }
NXLOCALE_ISCTYPE(space, _CTYPE_S)
Xstatic inline int iswspace_l(int, locale_t); static inline int iswspace_l(int __c, locale_t __l) { return iswspace(__c); }
NXLOCALE_ISCTYPE(upper, _CTYPE_U)
Xstatic inline int iswupper_l(int, locale_t); static inline int iswupper_l(int __c, locale_t __l) { return iswupper(__c); }
NXLOCALE_ISCTYPE(xdigit, _CTYPE_X)
Xstatic inline int iswxdigit_l(int, locale_t); static inline int iswxdigit_l(int __c, locale_t __l) { return iswxdigit(__c); }
N#undef XLOCALE_ISCTYPE
N
N#ifdef _XLOCALE_WCTYPES
N_XLOCALE_INLINE int towlower_l(int, locale_t);
Xstatic inline int towlower_l(int, locale_t);
N_XLOCALE_INLINE int towupper_l(int, locale_t);
Xstatic inline int towupper_l(int, locale_t);
N
N_XLOCALE_INLINE int towlower_l(int __c, locale_t __l)
Xstatic inline int towlower_l(int __c, locale_t __l)
N{
N   return towlower(__c);
N}
N_XLOCALE_INLINE int towupper_l(int __c, locale_t __l)
Xstatic inline int towupper_l(int __c, locale_t __l)
N{
N   return towupper(__c);
N}
N
N_XLOCALE_INLINE int
Xstatic inline int
Niswctype_l(wint_t __wc, wctype_t __charclass, locale_t __l)
N{
N   return iswctype(__wc, __charclass);
N}
N
N_XLOCALE_INLINE wctype_t
Xstatic inline wctype_t
Nwctype_l(const char *property, locale_t __l)
N{
N   return wctype(property);
N}
N
N_XLOCALE_INLINE wint_t
Xstatic inline wint_t
Ntowctrans_l(wint_t __wc, wctrans_t desc, locale_t __l)
N{
N   return towctrans(__wc, desc);
N}
N
N_XLOCALE_INLINE wctrans_t
Xstatic inline wctrans_t
Nwctrans_l(const char *__charclass, locale_t __l)
N{
N   return wctrans(__charclass);
N}
N
N#undef _XLOCALE_WCTYPES
N#else
S_XLOCALE_INLINE int tolower_l(int, locale_t);
S_XLOCALE_INLINE int toupper_l(int, locale_t);
S
S_XLOCALE_INLINE int tolower_l(int __c, locale_t __l)
S{
S   return tolower(__c);
S}
S_XLOCALE_INLINE int toupper_l(int __c, locale_t __l)
S{
S   return toupper(__c);
S}
N#endif
N#endif /* (defined(_XLOCALE_WCTYPES) && !defined(_XLOCALE_WCTYPE_H)) || \
N	(!defined(_XLOCALE_WCTYPES) && !defined(_XLOCALE_CTYPE_H)) */
X#endif  
L 129 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/wctype.h" 2
N__END_DECLS
X}
N#endif
L 55 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/wctype.h" 2
N
N#ifdef __cplusplus
N
N#undef iswalnum
N#undef iswalpha
N#undef iswblank
N#undef iswcntrl
N#undef iswdigit
N#undef iswgraph
N#undef iswlower
N#undef iswprint
N#undef iswpunct
N#undef iswspace
N#undef iswupper
N#undef iswxdigit
N#undef iswctype
N#undef wctype
N#undef towlower
N#undef towupper
N#undef towctrans
N#undef wctrans
N
N#endif  /* __cplusplus */
N
N#endif  /* _LIBCPP_WCTYPE_H */
L 56 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/cwctype" 2
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N_LIBCPP_BEGIN_NAMESPACE_STD
Xnamespace std { inline namespace __2 {
N
Nusing ::wint_t;
Nusing ::wctrans_t;
Nusing ::wctype_t;
Nusing ::iswalnum;
Nusing ::iswalpha;
Nusing ::iswblank;
Nusing ::iswcntrl;
Nusing ::iswdigit;
Nusing ::iswgraph;
Nusing ::iswlower;
Nusing ::iswprint;
Nusing ::iswpunct;
Nusing ::iswspace;
Nusing ::iswupper;
Nusing ::iswxdigit;
Nusing ::iswctype;
Nusing ::wctype;
Nusing ::towlower;
Nusing ::towupper;
Nusing ::towctrans;
Nusing ::wctrans;
N
N_LIBCPP_END_NAMESPACE_STD
X} }
N
N#endif  // _LIBCPP_CWCTYPE
L 108 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/cwchar" 2
N#include <wchar.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/wchar.h" 1
N/* -*- C++ -*- */
N/*===--------------------------- complex.h --------------------------------===*/
N/*                                                                            */
N/*                     The LLVM Compiler Infrastructure                       */
N/*                                                                            */
N/* This file is dual licensed under the MIT and the University of Illinois Open
N** Source Licenses. See LICENSE.TXT for details.
N*/
N/*===----------------------------------------------------------------------===*/
N
N#if defined(__need_wint_t) || defined(__need_mbstate_t)
X#if 0L || 0L
S
S#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
S#pragma GCC system_header
S#endif
S
S#include_next <wchar.h>
S
S#elif !defined(_LIBCPP_WCHAR_H)
X#elif !1L
S#define _LIBCPP_WCHAR_H
S
S/*
S    wchar.h synopsis
S
SMacros:
S
S    NULL
S    WCHAR_MAX
S    WCHAR_MIN
S    WEOF
S
STypes:
S
S    mbstate_t
S    size_t
S    tm
S    wint_t
S
Sint fwprintf(FILE* restrict stream, const wchar_t* restrict format, ...);
Sint fwscanf(FILE* restrict stream, const wchar_t* restrict format, ...);
Sint swprintf(wchar_t* restrict s, size_t n, const wchar_t* restrict format, ...);
Sint swscanf(const wchar_t* restrict s, const wchar_t* restrict format, ...);
Sint vfwprintf(FILE* restrict stream, const wchar_t* restrict format, va_list arg);
Sint vfwscanf(FILE* restrict stream, const wchar_t* restrict format, va_list arg);  // C99
Sint vswprintf(wchar_t* restrict s, size_t n, const wchar_t* restrict format, va_list arg);
Sint vswscanf(const wchar_t* restrict s, const wchar_t* restrict format, va_list arg);  // C99
Sint vwprintf(const wchar_t* restrict format, va_list arg);
Sint vwscanf(const wchar_t* restrict format, va_list arg);  // C99
Sint wprintf(const wchar_t* restrict format, ...);
Sint wscanf(const wchar_t* restrict format, ...);
Swint_t fgetwc(FILE* stream);
Swchar_t* fgetws(wchar_t* restrict s, int n, FILE* restrict stream);
Swint_t fputwc(wchar_t c, FILE* stream);
Sint fputws(const wchar_t* restrict s, FILE* restrict stream);
Sint fwide(FILE* stream, int mode);
Swint_t getwc(FILE* stream);
Swint_t getwchar();
Swint_t putwc(wchar_t c, FILE* stream);
Swint_t putwchar(wchar_t c);
Swint_t ungetwc(wint_t c, FILE* stream);
Sdouble wcstod(const wchar_t* restrict nptr, wchar_t** restrict endptr);
Sfloat wcstof(const wchar_t* restrict nptr, wchar_t** restrict endptr);         // C99
Slong double wcstold(const wchar_t* restrict nptr, wchar_t** restrict endptr);  // C99
Slong wcstol(const wchar_t* restrict nptr, wchar_t** restrict endptr, int base);
Slong long wcstoll(const wchar_t* restrict nptr, wchar_t** restrict endptr, int base);  // C99
Sunsigned long wcstoul(const wchar_t* restrict nptr, wchar_t** restrict endptr, int base);
Sunsigned long long wcstoull(const wchar_t* restrict nptr, wchar_t** restrict endptr, int base);  // C99
Swchar_t* wcscpy(wchar_t* restrict s1, const wchar_t* restrict s2);
Swchar_t* wcsncpy(wchar_t* restrict s1, const wchar_t* restrict s2, size_t n);
Swchar_t* wcscat(wchar_t* restrict s1, const wchar_t* restrict s2);
Swchar_t* wcsncat(wchar_t* restrict s1, const wchar_t* restrict s2, size_t n);
Sint wcscmp(const wchar_t* s1, const wchar_t* s2);
Sint wcscoll(const wchar_t* s1, const wchar_t* s2);
Sint wcsncmp(const wchar_t* s1, const wchar_t* s2, size_t n);
Ssize_t wcsxfrm(wchar_t* restrict s1, const wchar_t* restrict s2, size_t n);
Sconst wchar_t* wcschr(const wchar_t* s, wchar_t c);
S      wchar_t* wcschr(      wchar_t* s, wchar_t c);
Ssize_t wcscspn(const wchar_t* s1, const wchar_t* s2);
Ssize_t wcslen(const wchar_t* s);
Sconst wchar_t* wcspbrk(const wchar_t* s1, const wchar_t* s2);
S      wchar_t* wcspbrk(      wchar_t* s1, const wchar_t* s2);
Sconst wchar_t* wcsrchr(const wchar_t* s, wchar_t c);
S      wchar_t* wcsrchr(      wchar_t* s, wchar_t c);
Ssize_t wcsspn(const wchar_t* s1, const wchar_t* s2);
Sconst wchar_t* wcsstr(const wchar_t* s1, const wchar_t* s2);
S      wchar_t* wcsstr(      wchar_t* s1, const wchar_t* s2);
Swchar_t* wcstok(wchar_t* restrict s1, const wchar_t* restrict s2, wchar_t** restrict ptr);
Sconst wchar_t* wmemchr(const wchar_t* s, wchar_t c, size_t n);
S      wchar_t* wmemchr(      wchar_t* s, wchar_t c, size_t n);
Sint wmemcmp(wchar_t* restrict s1, const wchar_t* restrict s2, size_t n);
Swchar_t* wmemcpy(wchar_t* restrict s1, const wchar_t* restrict s2, size_t n);
Swchar_t* wmemmove(wchar_t* s1, const wchar_t* s2, size_t n);
Swchar_t* wmemset(wchar_t* s, wchar_t c, size_t n);
Ssize_t wcsftime(wchar_t* restrict s, size_t maxsize, const wchar_t* restrict format,
S                const tm* restrict timeptr);
Swint_t btowc(int c);
Sint wctob(wint_t c);
Sint mbsinit(const mbstate_t* ps);
Ssize_t mbrlen(const char* restrict s, size_t n, mbstate_t* restrict ps);
Ssize_t mbrtowc(wchar_t* restrict pwc, const char* restrict s, size_t n, mbstate_t* restrict ps);
Ssize_t wcrtomb(char* restrict s, wchar_t wc, mbstate_t* restrict ps);
Ssize_t mbsrtowcs(wchar_t* restrict dst, const char** restrict src, size_t len,
S                 mbstate_t* restrict ps);
Ssize_t wcsrtombs(char* restrict dst, const wchar_t** restrict src, size_t len,
S                 mbstate_t* restrict ps);
S
S*/
S
S#include <__config>
S
S#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
S#pragma GCC system_header
S#endif
S
S#ifdef __cplusplus
S#define __CORRECT_ISO_CPP_WCHAR_H_PROTO
S#endif
S
S#include_next <wchar.h>
S
S/* Determine whether we have const-correct overloads for wcschr and friends. */
S#if defined(_WCHAR_H_CPLUSPLUS_98_CONFORMANCE_)
S#  define _LIBCPP_WCHAR_H_HAS_CONST_OVERLOADS 1
S#elif defined(__GLIBC_PREREQ)
S#  if __GLIBC_PREREQ(2, 10)
S#    define _LIBCPP_WCHAR_H_HAS_CONST_OVERLOADS 1
S#  endif
S#elif defined(_LIBCPP_MSVCRT)
S#  if defined(_CRT_CONST_CORRECT_OVERLOADS)
S#    define _LIBCPP_WCHAR_H_HAS_CONST_OVERLOADS 1
S#  endif
S#endif
S
S#if defined(__cplusplus) && !defined(_LIBCPP_WCHAR_H_HAS_CONST_OVERLOADS) && defined(_LIBCPP_PREFERRED_OVERLOAD)
Sextern "C++" {
Sinline _LIBCPP_INLINE_VISIBILITY
Swchar_t* __libcpp_wcschr(const wchar_t* __s, wchar_t __c) {return (wchar_t*)wcschr(__s, __c);}
Sinline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD
Sconst wchar_t* wcschr(const wchar_t* __s, wchar_t __c) {return __libcpp_wcschr(__s, __c);}
Sinline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD
S      wchar_t* wcschr(      wchar_t* __s, wchar_t __c) {return __libcpp_wcschr(__s, __c);}
S
Sinline _LIBCPP_INLINE_VISIBILITY
Swchar_t* __libcpp_wcspbrk(const wchar_t* __s1, const wchar_t* __s2) {return (wchar_t*)wcspbrk(__s1, __s2);}
Sinline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD
Sconst wchar_t* wcspbrk(const wchar_t* __s1, const wchar_t* __s2) {return __libcpp_wcspbrk(__s1, __s2);}
Sinline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD
S      wchar_t* wcspbrk(      wchar_t* __s1, const wchar_t* __s2) {return __libcpp_wcspbrk(__s1, __s2);}
S
Sinline _LIBCPP_INLINE_VISIBILITY
Swchar_t* __libcpp_wcsrchr(const wchar_t* __s, wchar_t __c) {return (wchar_t*)wcsrchr(__s, __c);}
Sinline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD
Sconst wchar_t* wcsrchr(const wchar_t* __s, wchar_t __c) {return __libcpp_wcsrchr(__s, __c);}
Sinline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD
S      wchar_t* wcsrchr(      wchar_t* __s, wchar_t __c) {return __libcpp_wcsrchr(__s, __c);}
S
Sinline _LIBCPP_INLINE_VISIBILITY
Swchar_t* __libcpp_wcsstr(const wchar_t* __s1, const wchar_t* __s2) {return (wchar_t*)wcsstr(__s1, __s2);}
Sinline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD
Sconst wchar_t* wcsstr(const wchar_t* __s1, const wchar_t* __s2) {return __libcpp_wcsstr(__s1, __s2);}
Sinline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD
S      wchar_t* wcsstr(      wchar_t* __s1, const wchar_t* __s2) {return __libcpp_wcsstr(__s1, __s2);}
S
Sinline _LIBCPP_INLINE_VISIBILITY
Swchar_t* __libcpp_wmemchr(const wchar_t* __s, wchar_t __c, size_t __n) {return (wchar_t*)wmemchr(__s, __c, __n);}
Sinline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD
Sconst wchar_t* wmemchr(const wchar_t* __s, wchar_t __c, size_t __n) {return __libcpp_wmemchr(__s, __c, __n);}
Sinline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD
S      wchar_t* wmemchr(      wchar_t* __s, wchar_t __c, size_t __n) {return __libcpp_wmemchr(__s, __c, __n);}
S}
S#endif
S
S#if defined(__cplusplus) && defined(_LIBCPP_MSVCRT_LIKE)
Sextern "C" {
Ssize_t mbsnrtowcs(wchar_t *__restrict dst, const char **__restrict src,
S                  size_t nmc, size_t len, mbstate_t *__restrict ps);
Ssize_t wcsnrtombs(char *__restrict dst, const wchar_t **__restrict src,
S                  size_t nwc, size_t len, mbstate_t *__restrict ps);
S}  /* extern "C++" */
S#endif  /* __cplusplus && _LIBCPP_MSVCRT */
S
N#endif  /* _LIBCPP_WCHAR_H */
L 109 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/cwchar" 2
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N_LIBCPP_BEGIN_NAMESPACE_STD
Xnamespace std { inline namespace __2 {
N
Nusing ::mbstate_t;
Nusing ::size_t;
Nusing ::tm;
Nusing ::wint_t;
Nusing ::FILE;
Nusing ::fwprintf;
Nusing ::fwscanf;
Nusing ::swprintf;
Nusing ::vfwprintf;
Nusing ::vswprintf;
Nusing ::swscanf;
Nusing ::vfwscanf;
Nusing ::vswscanf;
Nusing ::fgetwc;
Nusing ::fgetws;
Nusing ::fputwc;
Nusing ::fputws;
Nusing ::fwide;
Nusing ::getwc;
Nusing ::putwc;
Nusing ::ungetwc;
Nusing ::wcstod;
Nusing ::wcstof;
Nusing ::wcstold;
Nusing ::wcstol;
N#ifndef _LIBCPP_HAS_NO_LONG_LONG
Nusing ::wcstoll;
N#endif // _LIBCPP_HAS_NO_LONG_LONG
Nusing ::wcstoul;
N#ifndef _LIBCPP_HAS_NO_LONG_LONG
Nusing ::wcstoull;
N#endif // _LIBCPP_HAS_NO_LONG_LONG
Nusing ::wcscpy;
Nusing ::wcsncpy;
Nusing ::wcscat;
Nusing ::wcsncat;
Nusing ::wcscmp;
Nusing ::wcscoll;
Nusing ::wcsncmp;
Nusing ::wcsxfrm;
Nusing ::wcschr;
Nusing ::wcspbrk;
Nusing ::wcsrchr;
Nusing ::wcsstr;
Nusing ::wmemchr;
Nusing ::wcscspn;
Nusing ::wcslen;
Nusing ::wcsspn;
Nusing ::wcstok;
Nusing ::wmemcmp;
Nusing ::wmemcpy;
Nusing ::wmemmove;
Nusing ::wmemset;
Nusing ::wcsftime;
Nusing ::btowc;
Nusing ::wctob;
Nusing ::mbsinit;
Nusing ::mbrlen;
Nusing ::mbrtowc;
Nusing ::wcrtomb;
Nusing ::mbsrtowcs;
Nusing ::wcsrtombs;
N
N#ifndef _LIBCPP_HAS_NO_STDIN
Nusing ::getwchar;
Nusing ::vwscanf;
Nusing ::wscanf;
N#endif
N
N#ifndef _LIBCPP_HAS_NO_STDOUT
Nusing ::putwchar;
Nusing ::vwprintf;
Nusing ::wprintf;
N#endif
N
N_LIBCPP_END_NAMESPACE_STD
X} }
N
N#endif  // _LIBCPP_CWCHAR
L 475 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/string" 2
N#include <algorithm>
N#include <iterator>
N#include <utility>
N#include <memory>
N#include <stdexcept>
N#include <type_traits>
N#include <initializer_list>
N#include <__functional_base>
N#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
N#include <cstdint>
N#endif
N
N#include <__debug>
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N_LIBCPP_PUSH_MACROS
X_Pragma("push_macro(\"min\")") _Pragma("push_macro(\"max\")")
N#include <__undef_macros>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/__undef_macros" 1
N// -*- C++ -*-
N//===------------------------ __undef_macros ------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is distributed under the University of Illinois Open Source
N// License. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N
N#ifdef min
S#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
S#if defined(_LIBCPP_WARNING)
S_LIBCPP_WARNING("macro min is incompatible with C++.  Try #define NOMINMAX "
S                "before any Windows header. #undefing min")
S#else
S#warning: macro min is incompatible with C++.  #undefing min
S#endif
S#endif
S#undef min
N#endif
N
N#ifdef max
S#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
S#if defined(_LIBCPP_WARNING)
S_LIBCPP_WARNING("macro max is incompatible with C++.  Try #define NOMINMAX "
S                "before any Windows header. #undefing max")
S#else
S#warning: macro max is incompatible with C++.  #undefing max
S#endif
S#endif
S#undef max
N#endif
L 495 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/string" 2
N
N
N_LIBCPP_BEGIN_NAMESPACE_STD
Xnamespace std { inline namespace __2 {
N
N// fpos
N
Ntemplate <class _StateT>
Nclass _LIBCPP_TEMPLATE_VIS fpos
Xclass  fpos
N{
Nprivate:
N    _StateT __st_;
N    streamoff __off_;
Npublic:
N    _LIBCPP_INLINE_VISIBILITY fpos(streamoff __off = streamoff()) : __st_(), __off_(__off) {}
X    __attribute__ ((__always_inline__)) fpos(streamoff __off = streamoff()) : __st_(), __off_(__off) {}
N
N    _LIBCPP_INLINE_VISIBILITY operator streamoff() const {return __off_;}
X    __attribute__ ((__always_inline__)) operator streamoff() const {return __off_;}
N
N    _LIBCPP_INLINE_VISIBILITY _StateT state() const {return __st_;}
X    __attribute__ ((__always_inline__)) _StateT state() const {return __st_;}
N    _LIBCPP_INLINE_VISIBILITY void state(_StateT __st) {__st_ = __st;}
X    __attribute__ ((__always_inline__)) void state(_StateT __st) {__st_ = __st;}
N
N    _LIBCPP_INLINE_VISIBILITY fpos& operator+=(streamoff __off) {__off_ += __off; return *this;}
X    __attribute__ ((__always_inline__)) fpos& operator+=(streamoff __off) {__off_ += __off; return *this;}
N    _LIBCPP_INLINE_VISIBILITY fpos  operator+ (streamoff __off) const {fpos __t(*this); __t += __off; return __t;}
X    __attribute__ ((__always_inline__)) fpos  operator+ (streamoff __off) const {fpos __t(*this); __t += __off; return __t;}
N    _LIBCPP_INLINE_VISIBILITY fpos& operator-=(streamoff __off) {__off_ -= __off; return *this;}
X    __attribute__ ((__always_inline__)) fpos& operator-=(streamoff __off) {__off_ -= __off; return *this;}
N    _LIBCPP_INLINE_VISIBILITY fpos  operator- (streamoff __off) const {fpos __t(*this); __t -= __off; return __t;}
X    __attribute__ ((__always_inline__)) fpos  operator- (streamoff __off) const {fpos __t(*this); __t -= __off; return __t;}
N};
N
Ntemplate <class _StateT>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nstreamoff operator-(const fpos<_StateT>& __x, const fpos<_StateT>& __y)
N    {return streamoff(__x) - streamoff(__y);}
N
Ntemplate <class _StateT>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool operator==(const fpos<_StateT>& __x, const fpos<_StateT>& __y)
N    {return streamoff(__x) == streamoff(__y);}
N
Ntemplate <class _StateT>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool operator!=(const fpos<_StateT>& __x, const fpos<_StateT>& __y)
N    {return streamoff(__x) != streamoff(__y);}
N
N// basic_string
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>
Noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x,
N          const basic_string<_CharT, _Traits, _Allocator>& __y);
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>
Noperator+(const _CharT* __x, const basic_string<_CharT,_Traits,_Allocator>& __y);
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>
Noperator+(_CharT __x, const basic_string<_CharT,_Traits,_Allocator>& __y);
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>
Noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x, const _CharT* __y);
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>
Noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x, _CharT __y);
N
N_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS string operator+<char, char_traits<char>, allocator<char> >(char const*, string const&))
Xextern template string operator+ <char, char_traits<char>, allocator<char> >(char const*, string const&);
N
Ntemplate <bool>
Nclass _LIBCPP_TEMPLATE_VIS __basic_string_common
Xclass  __basic_string_common
N{
Nprotected:
N    _LIBCPP_NORETURN void __throw_length_error() const;
X    [[noreturn]] void __throw_length_error() const;
N    _LIBCPP_NORETURN void __throw_out_of_range() const;
X    [[noreturn]] void __throw_out_of_range() const;
N};
N
Ntemplate <bool __b>
Nvoid
N__basic_string_common<__b>::__throw_length_error() const
N{
N    _VSTD::__throw_length_error("basic_string");
X    std::__2::__throw_length_error("basic_string");
N}
N
Ntemplate <bool __b>
Nvoid
N__basic_string_common<__b>::__throw_out_of_range() const
N{
N    _VSTD::__throw_out_of_range("basic_string");
X    std::__2::__throw_out_of_range("basic_string");
N}
N
N_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __basic_string_common<true>)
Xextern template class __basic_string_common<true>;
N
N#ifdef _LIBCPP_NO_EXCEPTIONS
Ntemplate <class _Iter>
Nstruct __libcpp_string_gets_noexcept_iterator_impl : public true_type {};
N#elif defined(_LIBCPP_HAS_NO_NOEXCEPT)
Stemplate <class _Iter>
Sstruct __libcpp_string_gets_noexcept_iterator_impl : public false_type {};
S#else
Stemplate <class _Iter, bool = __is_forward_iterator<_Iter>::value>
Sstruct __libcpp_string_gets_noexcept_iterator_impl : public _LIBCPP_BOOL_CONSTANT((
S    noexcept(++(declval<_Iter&>())) && 
S    is_nothrow_assignable<_Iter&, _Iter>::value && 
S    noexcept(declval<_Iter>() == declval<_Iter>()) && 
S    noexcept(*declval<_Iter>())
S)) {};
S
Stemplate <class _Iter> 
Sstruct __libcpp_string_gets_noexcept_iterator_impl<_Iter, false> : public false_type {};
N#endif
N
N
Ntemplate <class _Iter>
Nstruct __libcpp_string_gets_noexcept_iterator
N    : public _LIBCPP_BOOL_CONSTANT(__libcpp_is_trivial_iterator<_Iter>::value || __libcpp_string_gets_noexcept_iterator_impl<_Iter>::value) {};
X    : public integral_constant<bool,(__libcpp_is_trivial_iterator<_Iter> ::value || __libcpp_string_gets_noexcept_iterator_impl<_Iter> ::value)> {};
N
Ntemplate <class _CharT, class _Traits, class _Tp>
Nstruct __can_be_converted_to_string_view : public _LIBCPP_BOOL_CONSTANT(
N	( is_convertible<const _Tp&, basic_string_view<_CharT, _Traits> >::value &&
N     !is_convertible<const _Tp&, const _CharT*>::value)) {};
Xstruct __can_be_converted_to_string_view : public integral_constant<bool,(( is_convertible<const _Tp&, basic_string_view<_CharT, _Traits> > ::value && !is_convertible<const _Tp&, const _CharT* > ::value))> {};
N
N#ifdef _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT
N
Ntemplate <class _CharT, size_t = sizeof(_CharT)>
Nstruct __padding
N{
N    unsigned char __xx[sizeof(_CharT)-1];
N};
N
Ntemplate <class _CharT>
Nstruct __padding<_CharT, 1>
N{
N};
N
N#endif  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Nclass _LIBCPP_TEMPLATE_VIS basic_string
Xclass  basic_string
N    : private __basic_string_common<true>
N{
Npublic:
N    typedef basic_string                                 __self;
N    typedef basic_string_view<_CharT, _Traits>           __self_view;
N    typedef _Traits                                      traits_type;
N    typedef _CharT                                       value_type;
N    typedef _Allocator                                   allocator_type;
N    typedef allocator_traits<allocator_type>             __alloc_traits;
N    typedef typename __alloc_traits::size_type           size_type;
N    typedef typename __alloc_traits::difference_type     difference_type;
N    typedef value_type&                                  reference;
N    typedef const value_type&                            const_reference;
N    typedef typename __alloc_traits::pointer             pointer;
N    typedef typename __alloc_traits::const_pointer       const_pointer;
N
N    static_assert(is_pod<value_type>::value, "Character type of basic_string must be a POD");
N    static_assert((is_same<_CharT, typename traits_type::char_type>::value),
N                  "traits_type::char_type must be the same type as CharT");
N    static_assert((is_same<typename allocator_type::value_type, value_type>::value),
N                  "Allocator::value_type must be same type as value_type");
N#if defined(_LIBCPP_RAW_ITERATORS)
X#if 0L
S    typedef pointer                                      iterator;
S    typedef const_pointer                                const_iterator;
N#else  // defined(_LIBCPP_RAW_ITERATORS)
N    typedef __wrap_iter<pointer>                         iterator;
N    typedef __wrap_iter<const_pointer>                   const_iterator;
N#endif  // defined(_LIBCPP_RAW_ITERATORS)
N    typedef _VSTD::reverse_iterator<iterator>             reverse_iterator;
X    typedef std::__2::reverse_iterator<iterator>             reverse_iterator;
N    typedef _VSTD::reverse_iterator<const_iterator>       const_reverse_iterator;
X    typedef std::__2::reverse_iterator<const_iterator>       const_reverse_iterator;
N
Nprivate:
N
N#ifdef _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT
N
N    struct __long
N    {
N        pointer   __data_;
N        size_type __size_;
N        size_type __cap_;
N    };
N
N#ifdef _LIBCPP_BIG_ENDIAN
S    static const size_type __short_mask = 0x01;
S    static const size_type __long_mask  = 0x1ul;
N#else  // _LIBCPP_BIG_ENDIAN
N    static const size_type __short_mask = 0x80;
N    static const size_type __long_mask  = ~(size_type(~0) >> 1);
N#endif  // _LIBCPP_BIG_ENDIAN
N
N    enum __attribute__((packed)) {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?
N                      (sizeof(__long) - 1)/sizeof(value_type) : 2};
N
N    struct __short
N    {
N        value_type __data_[__min_cap];
N        struct
N            : __padding<value_type>
N        {
N            unsigned char __size_;
N        } __attr_;
N    };
N
N#else
S
S    struct __long
S    {
S        size_type __cap_;
S        size_type __size_;
S        pointer   __data_;
S    };
S
S#ifdef _LIBCPP_BIG_ENDIAN
S    static const size_type __short_mask = 0x80;
S    static const size_type __long_mask  = ~(size_type(~0) >> 1);
S#else  // _LIBCPP_BIG_ENDIAN
S    static const size_type __short_mask = 0x01;
S    static const size_type __long_mask  = 0x1ul;
S#endif  // _LIBCPP_BIG_ENDIAN
S
S    enum __attribute__((packed)) {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?
S                      (sizeof(__long) - 1)/sizeof(value_type) : 2};
S
S    struct __short
S    {
S        union
S        {
S            unsigned char __size_;
S            value_type __lx;
S        } __attr_;
S        value_type __data_[__min_cap];
S    };
S
N#endif  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT
N
N    union __ulx{__long __lx; __short __lxx;};
N
N    enum __attribute__((packed)) {__n_words = sizeof(__ulx) / sizeof(size_type)};
N
N    struct __raw
N    {
N        size_type __words[__n_words];
N    };
N
N    struct __rep
N    {
N        union
N        {
N            __long  __l;
N            __short __s;
N            __raw   __r;
N        };
N    };
N
N    __compressed_pair<__rep, allocator_type> __r_;
N
Npublic:
N    _DATA_ACCESS static const size_type npos = (size_type)-1;
X     static const size_type npos = (size_type)-1;
N
N    _LIBCPP_INLINE_VISIBILITY basic_string()
X    __attribute__ ((__always_inline__)) basic_string()
N        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);
X        noexcept(is_nothrow_default_constructible<allocator_type> ::value);
N
N    _LIBCPP_INLINE_VISIBILITY explicit basic_string(const allocator_type& __a)
X    __attribute__ ((__always_inline__)) explicit basic_string(const allocator_type& __a)
N#if _LIBCPP_STD_VER <= 14
X#if 14 <= 14
N        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value);
X        noexcept(is_nothrow_copy_constructible<allocator_type> ::value);
N#else
S        _NOEXCEPT;
N#endif
N
N    basic_string(const basic_string& __str);
N    basic_string(const basic_string& __str, const allocator_type& __a);
N
N#ifndef _LIBCPP_CXX03_LANG
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    basic_string(basic_string&& __str)
N#if _LIBCPP_STD_VER <= 14
X#if 14 <= 14
N        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);
X        noexcept(is_nothrow_move_constructible<allocator_type> ::value);
N#else
S        _NOEXCEPT;
N#endif
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    basic_string(basic_string&& __str, const allocator_type& __a);
N#endif  // _LIBCPP_CXX03_LANG
N    _LIBCPP_INLINE_VISIBILITY basic_string(const _CharT* __s);
X    __attribute__ ((__always_inline__)) basic_string(const _CharT* __s);
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    basic_string(const _CharT* __s, const _Allocator& __a);
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    basic_string(const _CharT* __s, size_type __n);
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    basic_string(const _CharT* __s, size_type __n, const _Allocator& __a);
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    basic_string(size_type __n, _CharT __c);
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    basic_string(size_type __n, _CharT __c, const _Allocator& __a);
N    basic_string(const basic_string& __str, size_type __pos, size_type __n,
N                 const _Allocator& __a = _Allocator());
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    basic_string(const basic_string& __str, size_type __pos,
N                 const _Allocator& __a = _Allocator());
N    template<class _Tp>
N        _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
X        
N        basic_string(const _Tp& __t, size_type __pos, size_type __n,
N                     const allocator_type& __a = allocator_type(),
N                     typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, void>::type* = 0);
N    _LIBCPP_INLINE_VISIBILITY explicit
X    __attribute__ ((__always_inline__)) explicit
N    basic_string(__self_view __sv);
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    basic_string(__self_view __sv, const _Allocator& __a);
N    template<class _InputIterator>
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        basic_string(_InputIterator __first, _InputIterator __last);
N    template<class _InputIterator>
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        basic_string(_InputIterator __first, _InputIterator __last, const allocator_type& __a);
N#ifndef _LIBCPP_CXX03_LANG
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    basic_string(initializer_list<_CharT> __il);
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    basic_string(initializer_list<_CharT> __il, const _Allocator& __a);
N#endif  // _LIBCPP_CXX03_LANG
N
N    inline ~basic_string();
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    operator __self_view() const _NOEXCEPT { return __self_view(data(), size()); }
X    operator __self_view() const noexcept { return __self_view(data(), size()); }
N
N    basic_string& operator=(const basic_string& __str);
N
N#ifndef _LIBCPP_CXX03_LANG
N    template <class = void>
N#endif
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    basic_string& operator=(__self_view __sv)  {return assign(__sv);}
N#ifndef _LIBCPP_CXX03_LANG
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    basic_string& operator=(basic_string&& __str)
N        _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));
X        noexcept((__noexcept_move_assign_container<_Allocator, __alloc_traits> ::value));
N     _LIBCPP_INLINE_VISIBILITY
X     __attribute__ ((__always_inline__))
N    basic_string& operator=(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}
N#endif
N    _LIBCPP_INLINE_VISIBILITY basic_string& operator=(const value_type* __s) {return assign(__s);}
X    __attribute__ ((__always_inline__)) basic_string& operator=(const value_type* __s) {return assign(__s);}
N    basic_string& operator=(value_type __c);
N
N#if _LIBCPP_DEBUG_LEVEL >= 2
S    _LIBCPP_INLINE_VISIBILITY
S    iterator begin() _NOEXCEPT
S        {return iterator(this, __get_pointer());}
S    _LIBCPP_INLINE_VISIBILITY
S    const_iterator begin() const _NOEXCEPT
S        {return const_iterator(this, __get_pointer());}
S    _LIBCPP_INLINE_VISIBILITY
S    iterator end() _NOEXCEPT
S        {return iterator(this, __get_pointer() + size());}
S    _LIBCPP_INLINE_VISIBILITY
S    const_iterator end() const _NOEXCEPT
S        {return const_iterator(this, __get_pointer() + size());}
N#else
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    iterator begin() _NOEXCEPT
X    iterator begin() noexcept
N        {return iterator(__get_pointer());}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    const_iterator begin() const _NOEXCEPT
X    const_iterator begin() const noexcept
N        {return const_iterator(__get_pointer());}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    iterator end() _NOEXCEPT
X    iterator end() noexcept
N        {return iterator(__get_pointer() + size());}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    const_iterator end() const _NOEXCEPT
X    const_iterator end() const noexcept
N        {return const_iterator(__get_pointer() + size());}
N#endif  // _LIBCPP_DEBUG_LEVEL >= 2
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    reverse_iterator rbegin() _NOEXCEPT
X    reverse_iterator rbegin() noexcept
N        {return reverse_iterator(end());}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    const_reverse_iterator rbegin() const _NOEXCEPT
X    const_reverse_iterator rbegin() const noexcept
N        {return const_reverse_iterator(end());}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    reverse_iterator rend() _NOEXCEPT
X    reverse_iterator rend() noexcept
N        {return reverse_iterator(begin());}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    const_reverse_iterator rend() const _NOEXCEPT
X    const_reverse_iterator rend() const noexcept
N        {return const_reverse_iterator(begin());}
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    const_iterator cbegin() const _NOEXCEPT
X    const_iterator cbegin() const noexcept
N        {return begin();}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    const_iterator cend() const _NOEXCEPT
X    const_iterator cend() const noexcept
N        {return end();}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    const_reverse_iterator crbegin() const _NOEXCEPT
X    const_reverse_iterator crbegin() const noexcept
N        {return rbegin();}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    const_reverse_iterator crend() const _NOEXCEPT
X    const_reverse_iterator crend() const noexcept
N        {return rend();}
N
N    _LIBCPP_INLINE_VISIBILITY size_type size() const _NOEXCEPT
X    __attribute__ ((__always_inline__)) size_type size() const noexcept
N        {return __is_long() ? __get_long_size() : __get_short_size();}
N    _LIBCPP_INLINE_VISIBILITY size_type length() const _NOEXCEPT {return size();}
X    __attribute__ ((__always_inline__)) size_type length() const noexcept {return size();}
N    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT;
X    __attribute__ ((__always_inline__)) size_type max_size() const noexcept;
N    _LIBCPP_INLINE_VISIBILITY size_type capacity() const _NOEXCEPT
X    __attribute__ ((__always_inline__)) size_type capacity() const noexcept
N        {return (__is_long() ? __get_long_cap()
N                             : static_cast<size_type>(__min_cap)) - 1;}
N
N    void resize(size_type __n, value_type __c);
N    _LIBCPP_INLINE_VISIBILITY void resize(size_type __n) {resize(__n, value_type());}
X    __attribute__ ((__always_inline__)) void resize(size_type __n) {resize(__n, value_type());}
N
N    void reserve(size_type __res_arg = 0);
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    void shrink_to_fit() _NOEXCEPT {reserve();}
X    void shrink_to_fit() noexcept {reserve();}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    void clear() _NOEXCEPT;
X    void clear() noexcept;
N    _LIBCPP_INLINE_VISIBILITY bool empty() const _NOEXCEPT {return size() == 0;}
X    __attribute__ ((__always_inline__)) bool empty() const noexcept {return size() == 0;}
N
N    _LIBCPP_INLINE_VISIBILITY const_reference operator[](size_type __pos) const _NOEXCEPT;
X    __attribute__ ((__always_inline__)) const_reference operator[](size_type __pos) const noexcept;
N    _LIBCPP_INLINE_VISIBILITY reference       operator[](size_type __pos)       _NOEXCEPT;
X    __attribute__ ((__always_inline__)) reference       operator[](size_type __pos)       noexcept;
N
N    const_reference at(size_type __n) const;
N    reference       at(size_type __n);
N
N    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(const basic_string& __str) {return append(__str);}
X    __attribute__ ((__always_inline__)) basic_string& operator+=(const basic_string& __str) {return append(__str);}
N    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(__self_view __sv)          {return append(__sv);}
X    __attribute__ ((__always_inline__)) basic_string& operator+=(__self_view __sv)          {return append(__sv);}
N    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(const value_type* __s)     {return append(__s);}
X    __attribute__ ((__always_inline__)) basic_string& operator+=(const value_type* __s)     {return append(__s);}
N    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(value_type __c)            {push_back(__c); return *this;}
X    __attribute__ ((__always_inline__)) basic_string& operator+=(value_type __c)            {push_back(__c); return *this;}
N#ifndef _LIBCPP_CXX03_LANG
N    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(initializer_list<value_type> __il) {return append(__il);}
X    __attribute__ ((__always_inline__)) basic_string& operator+=(initializer_list<value_type> __il) {return append(__il);}
N#endif  // _LIBCPP_CXX03_LANG
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    basic_string& append(const basic_string& __str);
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    basic_string& append(__self_view __sv) { return append(__sv.data(), __sv.size()); }
N    basic_string& append(const basic_string& __str, size_type __pos, size_type __n=npos);
N    template <class _Tp>
N    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
X    
N    typename enable_if
N        <
N            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
N            basic_string&
N        >::type
N                  append(const _Tp& __t, size_type __pos, size_type __n=npos);
N    basic_string& append(const value_type* __s, size_type __n);
N    basic_string& append(const value_type* __s);
N    basic_string& append(size_type __n, value_type __c);
N    template <class _ForwardIterator>
N    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
X    
N    basic_string& __append_forward_unsafe(_ForwardIterator, _ForwardIterator);
N    template<class _InputIterator>
N    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
X    
N    typename enable_if
N        <
N            __is_exactly_input_iterator<_InputIterator>::value
N                || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,
N            basic_string&
N        >::type
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    append(_InputIterator __first, _InputIterator __last) {
N      const basic_string __temp (__first, __last, __alloc());
N      append(__temp.data(), __temp.size());
N      return *this;
N    }
N    template<class _ForwardIterator>
N    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
X    
N    typename enable_if
N        <
N            __is_forward_iterator<_ForwardIterator>::value
N                && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,
N            basic_string&
N        >::type
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    append(_ForwardIterator __first, _ForwardIterator __last) {
N      return __append_forward_unsafe(__first, __last);
N    }
N
N#ifndef _LIBCPP_CXX03_LANG
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    basic_string& append(initializer_list<value_type> __il) {return append(__il.begin(), __il.size());}
N#endif  // _LIBCPP_CXX03_LANG
N
N    void push_back(value_type __c);
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    void pop_back();
N    _LIBCPP_INLINE_VISIBILITY reference       front();
X    __attribute__ ((__always_inline__)) reference       front();
N    _LIBCPP_INLINE_VISIBILITY const_reference front() const;
X    __attribute__ ((__always_inline__)) const_reference front() const;
N    _LIBCPP_INLINE_VISIBILITY reference       back();
X    __attribute__ ((__always_inline__)) reference       back();
N    _LIBCPP_INLINE_VISIBILITY const_reference back() const;
X    __attribute__ ((__always_inline__)) const_reference back() const;
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    basic_string& assign(__self_view __sv) { return assign(__sv.data(), __sv.size()); }
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    basic_string& assign(const basic_string& __str) { return *this = __str; }
N#ifndef _LIBCPP_CXX03_LANG
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    basic_string& assign(basic_string&& __str)
N        _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))
X        noexcept((__noexcept_move_assign_container<_Allocator, __alloc_traits> ::value))
N        {*this = _VSTD::move(__str); return *this;}
X        {*this = std::__2::move(__str); return *this;}
N#endif
N    basic_string& assign(const basic_string& __str, size_type __pos, size_type __n=npos);
N    template <class _Tp>
N    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
X    
N    typename enable_if
N        <
N            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
N            basic_string&
N        >::type
N                  assign(const _Tp & __t, size_type __pos, size_type __n=npos);
N    basic_string& assign(const value_type* __s, size_type __n);
N    basic_string& assign(const value_type* __s);
N    basic_string& assign(size_type __n, value_type __c);
N    template<class _InputIterator>
N    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
X    
N    typename enable_if
N        <
N           __is_exactly_input_iterator<_InputIterator>::value
N                || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,
N            basic_string&
N        >::type
N        assign(_InputIterator __first, _InputIterator __last);
N    template<class _ForwardIterator>
N    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
X    
N    typename enable_if
N        <
N            __is_forward_iterator<_ForwardIterator>::value
N                 && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,
N            basic_string&
N        >::type
N        assign(_ForwardIterator __first, _ForwardIterator __last);
N#ifndef _LIBCPP_CXX03_LANG
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    basic_string& assign(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}
N#endif  // _LIBCPP_CXX03_LANG
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    basic_string& insert(size_type __pos1, const basic_string& __str);
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    basic_string& insert(size_type __pos1, __self_view __sv) { return insert(__pos1, __sv.data(), __sv.size()); }
N    template <class _Tp>
N    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
X    
N    typename enable_if
N        <
N            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
N            basic_string&
N        >::type
N                  insert(size_type __pos1, const _Tp& __t, size_type __pos2, size_type __n=npos);
N    basic_string& insert(size_type __pos1, const basic_string& __str, size_type __pos2, size_type __n=npos);
N    basic_string& insert(size_type __pos, const value_type* __s, size_type __n);
N    basic_string& insert(size_type __pos, const value_type* __s);
N    basic_string& insert(size_type __pos, size_type __n, value_type __c);
N    iterator      insert(const_iterator __pos, value_type __c);
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    iterator      insert(const_iterator __pos, size_type __n, value_type __c);
N    template<class _InputIterator>
N    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
X    
N    typename enable_if
N        <
N           __is_exactly_input_iterator<_InputIterator>::value
N                || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,
N            iterator
N        >::type
N        insert(const_iterator __pos, _InputIterator __first, _InputIterator __last);
N    template<class _ForwardIterator>
N    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
X    
N    typename enable_if
N        <
N            __is_forward_iterator<_ForwardIterator>::value
N                 && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,
N            iterator
N        >::type
N        insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last);
N#ifndef _LIBCPP_CXX03_LANG
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    iterator insert(const_iterator __pos, initializer_list<value_type> __il)
N                    {return insert(__pos, __il.begin(), __il.end());}
N#endif  // _LIBCPP_CXX03_LANG
N
N    basic_string& erase(size_type __pos = 0, size_type __n = npos);
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    iterator      erase(const_iterator __pos);
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    iterator      erase(const_iterator __first, const_iterator __last);
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str);
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    basic_string& replace(size_type __pos1, size_type __n1, __self_view __sv) { return replace(__pos1, __n1, __sv.data(), __sv.size()); }
N    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2=npos);
N    template <class _Tp>
N    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
X    
N    typename enable_if
N        <
N            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
N            basic_string&
N        >::type
N                  replace(size_type __pos1, size_type __n1, const _Tp& __t, size_type __pos2, size_type __n2=npos);
N    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2);
N    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s);
N    basic_string& replace(size_type __pos, size_type __n1, size_type __n2, value_type __c);
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    basic_string& replace(const_iterator __i1, const_iterator __i2, const basic_string& __str);
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    basic_string& replace(const_iterator __i1, const_iterator __i2, __self_view __sv) { return replace(__i1 - begin(), __i2 - __i1, __sv); }
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n);
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s);
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    basic_string& replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c);
N    template<class _InputIterator>
N    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
X    
N    typename enable_if
N        <
N            __is_input_iterator<_InputIterator>::value,
N            basic_string&
N        >::type
N        replace(const_iterator __i1, const_iterator __i2, _InputIterator __j1, _InputIterator __j2);
N#ifndef _LIBCPP_CXX03_LANG
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    basic_string& replace(const_iterator __i1, const_iterator __i2, initializer_list<value_type> __il)
N        {return replace(__i1, __i2, __il.begin(), __il.end());}
N#endif  // _LIBCPP_CXX03_LANG
N
N    size_type copy(value_type* __s, size_type __n, size_type __pos = 0) const;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    basic_string substr(size_type __pos = 0, size_type __n = npos) const;
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    void swap(basic_string& __str)
N#if _LIBCPP_STD_VER >= 14
X#if 14 >= 14
N        _NOEXCEPT_DEBUG;
X        noexcept;
N#else
S        _NOEXCEPT_DEBUG_(!__alloc_traits::propagate_on_container_swap::value ||
S                    __is_nothrow_swappable<allocator_type>::value);
N#endif
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    const value_type* c_str() const _NOEXCEPT {return data();}
X    const value_type* c_str() const noexcept {return data();}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    const value_type* data() const _NOEXCEPT  {return _VSTD::__to_raw_pointer(__get_pointer());}
X    const value_type* data() const noexcept  {return std::__2::__to_raw_pointer(__get_pointer());}
N#if _LIBCPP_STD_VER > 14
X#if 14 > 14
S    _LIBCPP_INLINE_VISIBILITY
S    value_type* data()             _NOEXCEPT  {return _VSTD::__to_raw_pointer(__get_pointer());}
N#endif
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    allocator_type get_allocator() const _NOEXCEPT {return __alloc();}
X    allocator_type get_allocator() const noexcept {return __alloc();}
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    size_type find(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;
X    size_type find(const basic_string& __str, size_type __pos = 0) const noexcept;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    size_type find(__self_view __sv, size_type __pos = 0) const _NOEXCEPT;
X    size_type find(__self_view __sv, size_type __pos = 0) const noexcept;
N    size_type find(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;
X    size_type find(const value_type* __s, size_type __pos, size_type __n) const noexcept;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    size_type find(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;
X    size_type find(const value_type* __s, size_type __pos = 0) const noexcept;
N    size_type find(value_type __c, size_type __pos = 0) const _NOEXCEPT;
X    size_type find(value_type __c, size_type __pos = 0) const noexcept;
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    size_type rfind(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;
X    size_type rfind(const basic_string& __str, size_type __pos = npos) const noexcept;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    size_type rfind(__self_view __sv, size_type __pos = npos) const _NOEXCEPT;
X    size_type rfind(__self_view __sv, size_type __pos = npos) const noexcept;
N    size_type rfind(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;
X    size_type rfind(const value_type* __s, size_type __pos, size_type __n) const noexcept;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    size_type rfind(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;
X    size_type rfind(const value_type* __s, size_type __pos = npos) const noexcept;
N    size_type rfind(value_type __c, size_type __pos = npos) const _NOEXCEPT;
X    size_type rfind(value_type __c, size_type __pos = npos) const noexcept;
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    size_type find_first_of(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;
X    size_type find_first_of(const basic_string& __str, size_type __pos = 0) const noexcept;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    size_type find_first_of(__self_view __sv, size_type __pos = 0) const _NOEXCEPT;
X    size_type find_first_of(__self_view __sv, size_type __pos = 0) const noexcept;
N    size_type find_first_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;
X    size_type find_first_of(const value_type* __s, size_type __pos, size_type __n) const noexcept;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    size_type find_first_of(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;
X    size_type find_first_of(const value_type* __s, size_type __pos = 0) const noexcept;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    size_type find_first_of(value_type __c, size_type __pos = 0) const _NOEXCEPT;
X    size_type find_first_of(value_type __c, size_type __pos = 0) const noexcept;
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    size_type find_last_of(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;
X    size_type find_last_of(const basic_string& __str, size_type __pos = npos) const noexcept;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    size_type find_last_of(__self_view __sv, size_type __pos = npos) const _NOEXCEPT;
X    size_type find_last_of(__self_view __sv, size_type __pos = npos) const noexcept;
N    size_type find_last_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;
X    size_type find_last_of(const value_type* __s, size_type __pos, size_type __n) const noexcept;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    size_type find_last_of(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;
X    size_type find_last_of(const value_type* __s, size_type __pos = npos) const noexcept;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    size_type find_last_of(value_type __c, size_type __pos = npos) const _NOEXCEPT;
X    size_type find_last_of(value_type __c, size_type __pos = npos) const noexcept;
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    size_type find_first_not_of(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;
X    size_type find_first_not_of(const basic_string& __str, size_type __pos = 0) const noexcept;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    size_type find_first_not_of(__self_view __sv, size_type __pos = 0) const _NOEXCEPT;
X    size_type find_first_not_of(__self_view __sv, size_type __pos = 0) const noexcept;
N    size_type find_first_not_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;
X    size_type find_first_not_of(const value_type* __s, size_type __pos, size_type __n) const noexcept;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    size_type find_first_not_of(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;
X    size_type find_first_not_of(const value_type* __s, size_type __pos = 0) const noexcept;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    size_type find_first_not_of(value_type __c, size_type __pos = 0) const _NOEXCEPT;
X    size_type find_first_not_of(value_type __c, size_type __pos = 0) const noexcept;
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    size_type find_last_not_of(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;
X    size_type find_last_not_of(const basic_string& __str, size_type __pos = npos) const noexcept;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    size_type find_last_not_of(__self_view __sv, size_type __pos = npos) const _NOEXCEPT;
X    size_type find_last_not_of(__self_view __sv, size_type __pos = npos) const noexcept;
N    size_type find_last_not_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;
X    size_type find_last_not_of(const value_type* __s, size_type __pos, size_type __n) const noexcept;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    size_type find_last_not_of(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;
X    size_type find_last_not_of(const value_type* __s, size_type __pos = npos) const noexcept;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    size_type find_last_not_of(value_type __c, size_type __pos = npos) const _NOEXCEPT;
X    size_type find_last_not_of(value_type __c, size_type __pos = npos) const noexcept;
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    int compare(const basic_string& __str) const _NOEXCEPT;
X    int compare(const basic_string& __str) const noexcept;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    int compare(__self_view __sv) const _NOEXCEPT;
X    int compare(__self_view __sv) const noexcept;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    int compare(size_type __pos1, size_type __n1, __self_view __sv) const;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    int compare(size_type __pos1, size_type __n1, const basic_string& __str) const;
N    int compare(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2=npos) const;
N    template <class _Tp>
N    inline _LIBCPP_INLINE_VISIBILITY
X    inline __attribute__ ((__always_inline__))
N        typename enable_if
N        <
N            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
N            int
N        >::type
N        compare(size_type __pos1, size_type __n1, const _Tp& __t, size_type __pos2, size_type __n2=npos) const;
N    int compare(const value_type* __s) const _NOEXCEPT;
X    int compare(const value_type* __s) const noexcept;
N    int compare(size_type __pos1, size_type __n1, const value_type* __s) const;
N    int compare(size_type __pos1, size_type __n1, const value_type* __s, size_type __n2) const;
N
N    _LIBCPP_INLINE_VISIBILITY bool __invariants() const;
X    __attribute__ ((__always_inline__)) bool __invariants() const;
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    bool __is_long() const _NOEXCEPT
X    bool __is_long() const noexcept
N        {return bool(__r_.first().__s.__attr_.__size_ & __short_mask);}
N
N#if _LIBCPP_DEBUG_LEVEL >= 2
S
S    bool __dereferenceable(const const_iterator* __i) const;
S    bool __decrementable(const const_iterator* __i) const;
S    bool __addable(const const_iterator* __i, ptrdiff_t __n) const;
S    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const;
S
N#endif  // _LIBCPP_DEBUG_LEVEL >= 2
N
Nprivate:
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    allocator_type& __alloc() _NOEXCEPT
X    allocator_type& __alloc() noexcept
N        {return __r_.second();}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    const allocator_type& __alloc() const _NOEXCEPT
X    const allocator_type& __alloc() const noexcept
N        {return __r_.second();}
N
N#ifdef _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    void __set_short_size(size_type __s) _NOEXCEPT
X    void __set_short_size(size_type __s) noexcept
N#   ifdef _LIBCPP_BIG_ENDIAN
S        {__r_.first().__s.__attr_.__size_ = (unsigned char)(__s << 1);}
N#   else
N        {__r_.first().__s.__attr_.__size_ = (unsigned char)(__s);}
N#   endif
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    size_type __get_short_size() const _NOEXCEPT
X    size_type __get_short_size() const noexcept
N#   ifdef _LIBCPP_BIG_ENDIAN
S        {return __r_.first().__s.__attr_.__size_ >> 1;}
N#   else
N        {return __r_.first().__s.__attr_.__size_;}
N#   endif
N
N#else  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT
S
S    _LIBCPP_INLINE_VISIBILITY
S    void __set_short_size(size_type __s) _NOEXCEPT
S#   ifdef _LIBCPP_BIG_ENDIAN
S        {__r_.first().__s.__attr_.__size_ = (unsigned char)(__s);}
S#   else
S        {__r_.first().__s.__attr_.__size_ = (unsigned char)(__s << 1);}
S#   endif
S
S    _LIBCPP_INLINE_VISIBILITY
S    size_type __get_short_size() const _NOEXCEPT
S#   ifdef _LIBCPP_BIG_ENDIAN
S        {return __r_.first().__s.__attr_.__size_;}
S#   else
S        {return __r_.first().__s.__attr_.__size_ >> 1;}
S#   endif
S
N#endif  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    void __set_long_size(size_type __s) _NOEXCEPT
X    void __set_long_size(size_type __s) noexcept
N        {__r_.first().__l.__size_ = __s;}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    size_type __get_long_size() const _NOEXCEPT
X    size_type __get_long_size() const noexcept
N        {return __r_.first().__l.__size_;}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    void __set_size(size_type __s) _NOEXCEPT
X    void __set_size(size_type __s) noexcept
N        {if (__is_long()) __set_long_size(__s); else __set_short_size(__s);}
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    void __set_long_cap(size_type __s) _NOEXCEPT
X    void __set_long_cap(size_type __s) noexcept
N        {__r_.first().__l.__cap_  = __long_mask | __s;}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    size_type __get_long_cap() const _NOEXCEPT
X    size_type __get_long_cap() const noexcept
N        {return __r_.first().__l.__cap_ & size_type(~__long_mask);}
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    void __set_long_pointer(pointer __p) _NOEXCEPT
X    void __set_long_pointer(pointer __p) noexcept
N        {__r_.first().__l.__data_ = __p;}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    pointer __get_long_pointer() _NOEXCEPT
X    pointer __get_long_pointer() noexcept
N        {return __r_.first().__l.__data_;}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    const_pointer __get_long_pointer() const _NOEXCEPT
X    const_pointer __get_long_pointer() const noexcept
N        {return __r_.first().__l.__data_;}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    pointer __get_short_pointer() _NOEXCEPT
X    pointer __get_short_pointer() noexcept
N        {return pointer_traits<pointer>::pointer_to(__r_.first().__s.__data_[0]);}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    const_pointer __get_short_pointer() const _NOEXCEPT
X    const_pointer __get_short_pointer() const noexcept
N        {return pointer_traits<const_pointer>::pointer_to(__r_.first().__s.__data_[0]);}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    pointer __get_pointer() _NOEXCEPT
X    pointer __get_pointer() noexcept
N        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    const_pointer __get_pointer() const _NOEXCEPT
X    const_pointer __get_pointer() const noexcept
N        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    void __zero() _NOEXCEPT
X    void __zero() noexcept
N        {
N            size_type (&__a)[__n_words] = __r_.first().__r.__words;
N            for (unsigned __i = 0; __i < __n_words; ++__i)
N                __a[__i] = 0;
N        }
N
N    template <size_type __a> static
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        size_type __align_it(size_type __s) _NOEXCEPT
X        size_type __align_it(size_type __s) noexcept
N            {return (__s + (__a-1)) & ~(__a-1);}
N    enum __attribute__((packed)) {__alignment = 16};
N    static _LIBCPP_INLINE_VISIBILITY
X    static __attribute__ ((__always_inline__))
N    size_type __recommend(size_type __s) _NOEXCEPT
X    size_type __recommend(size_type __s) noexcept
N        {return (__s < __min_cap ? static_cast<size_type>(__min_cap) :
N                 __align_it<sizeof(value_type) < __alignment ?
N                            __alignment/sizeof(value_type) : 1 > (__s+1)) - 1;}
N
N    inline
N    void __init(const value_type* __s, size_type __sz, size_type __reserve);
N    inline
N    void __init(const value_type* __s, size_type __sz);
N    inline
N    void __init(size_type __n, value_type __c);
N
N    template <class _InputIterator>
N    inline
N    typename enable_if
N    <
N        __is_exactly_input_iterator<_InputIterator>::value,
N        void
N    >::type
N    __init(_InputIterator __first, _InputIterator __last);
N
N    template <class _ForwardIterator>
N    inline
N    typename enable_if
N    <
N        __is_forward_iterator<_ForwardIterator>::value,
N        void
N    >::type
N    __init(_ForwardIterator __first, _ForwardIterator __last);
N
N    void __grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,
N                   size_type __n_copy,  size_type __n_del,     size_type __n_add = 0);
N    void __grow_by_and_replace(size_type __old_cap, size_type __delta_cap, size_type __old_sz,
N                               size_type __n_copy,  size_type __n_del,
N                               size_type __n_add, const value_type* __p_new_stuff);
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    void __erase_to_end(size_type __pos);
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    void __copy_assign_alloc(const basic_string& __str)
N        {__copy_assign_alloc(__str, integral_constant<bool,
N                      __alloc_traits::propagate_on_container_copy_assignment::value>());}
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    void __copy_assign_alloc(const basic_string& __str, true_type)
N        {
N            if (__alloc() == __str.__alloc())
N                __alloc() = __str.__alloc();
N            else
N            {
N                if (!__str.__is_long())
N                {
N                    clear();
N                    shrink_to_fit();
N                    __alloc() = __str.__alloc();
N                }
N                else
N                {
N                    allocator_type __a = __str.__alloc();
N                    pointer __p = __alloc_traits::allocate(__a, __str.__get_long_cap());
N                    clear();
N                    shrink_to_fit();
N                    __alloc() = _VSTD::move(__a);
X                    __alloc() = std::__2::move(__a);
N                    __set_long_pointer(__p);
N                    __set_long_cap(__str.__get_long_cap());
N                    __set_long_size(__str.size());
N                }
N            }
N        }
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    void __copy_assign_alloc(const basic_string&, false_type) _NOEXCEPT
X    void __copy_assign_alloc(const basic_string&, false_type) noexcept
N        {}
N
N#ifndef _LIBCPP_CXX03_LANG
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    void __move_assign(basic_string& __str, false_type)
N        _NOEXCEPT_(__alloc_traits::is_always_equal::value);
X        noexcept(__alloc_traits::is_always_equal::value);
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    void __move_assign(basic_string& __str, true_type)
N#if _LIBCPP_STD_VER > 14
X#if 14 > 14
S        _NOEXCEPT;
N#else
N        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);
X        noexcept(is_nothrow_move_assignable<allocator_type> ::value);
N#endif
N#endif
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    void
N    __move_assign_alloc(basic_string& __str)
N        _NOEXCEPT_(
N            !__alloc_traits::propagate_on_container_move_assignment::value ||
N            is_nothrow_move_assignable<allocator_type>::value)
X        noexcept(!__alloc_traits::propagate_on_container_move_assignment::value || is_nothrow_move_assignable<allocator_type> ::value)
N    {__move_assign_alloc(__str, integral_constant<bool,
N                      __alloc_traits::propagate_on_container_move_assignment::value>());}
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    void __move_assign_alloc(basic_string& __c, true_type)
N        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)
X        noexcept(is_nothrow_move_assignable<allocator_type> ::value)
N        {
N            __alloc() = _VSTD::move(__c.__alloc());
X            __alloc() = std::__2::move(__c.__alloc());
N        }
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    void __move_assign_alloc(basic_string&, false_type)
N        _NOEXCEPT
X        noexcept
N        {}
N
N    _LIBCPP_INLINE_VISIBILITY void __invalidate_all_iterators();
X    __attribute__ ((__always_inline__)) void __invalidate_all_iterators();
N    _LIBCPP_INLINE_VISIBILITY void __invalidate_iterators_past(size_type);
X    __attribute__ ((__always_inline__)) void __invalidate_iterators_past(size_type);
N
N    friend basic_string operator+<>(const basic_string&, const basic_string&);
N    friend basic_string operator+<>(const value_type*, const basic_string&);
N    friend basic_string operator+<>(value_type, const basic_string&);
N    friend basic_string operator+<>(const basic_string&, const value_type*);
N    friend basic_string operator+<>(const basic_string&, value_type);
N};
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Nbasic_string<_CharT, _Traits, _Allocator>::__invalidate_all_iterators()
N{
N#if _LIBCPP_DEBUG_LEVEL >= 2
S    __get_db()->__invalidate_all(this);
N#endif  // _LIBCPP_DEBUG_LEVEL >= 2
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Nbasic_string<_CharT, _Traits, _Allocator>::__invalidate_iterators_past(size_type
N#if _LIBCPP_DEBUG_LEVEL >= 2
S                                                                        __pos
N#endif
N                                                                      )
N{
N#if _LIBCPP_DEBUG_LEVEL >= 2
S    __c_node* __c = __get_db()->__find_c_and_lock(this);
S    if (__c)
S    {
S        const_pointer __new_last = __get_pointer() + __pos;
S        for (__i_node** __p = __c->end_; __p != __c->beg_; )
S        {
S            --__p;
S            const_iterator* __i = static_cast<const_iterator*>((*__p)->__i_);
S            if (__i->base() > __new_last)
S            {
S                (*__p)->__c_ = nullptr;
S                if (--__c->end_ != __p)
S                    memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));
S            }
S        }
S        __get_db()->unlock();
S    }
N#endif  // _LIBCPP_DEBUG_LEVEL >= 2
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbasic_string<_CharT, _Traits, _Allocator>::basic_string()
N    _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)
X    noexcept(is_nothrow_default_constructible<allocator_type> ::value)
N{
N#if _LIBCPP_DEBUG_LEVEL >= 2
S    __get_db()->__insert_c(this);
N#endif
N    __zero();
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const allocator_type& __a)
N#if _LIBCPP_STD_VER <= 14
X#if 14 <= 14
N        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value)
X        noexcept(is_nothrow_copy_constructible<allocator_type> ::value)
N#else
S        _NOEXCEPT
N#endif
N: __r_(__second_tag(), __a)
N{
N#if _LIBCPP_DEBUG_LEVEL >= 2
S    __get_db()->__insert_c(this);
N#endif
N    __zero();
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nvoid basic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s,
N                                                       size_type __sz,
N                                                       size_type __reserve)
N{
N    if (__reserve > max_size())
N        this->__throw_length_error();
N    pointer __p;
N    if (__reserve < __min_cap)
N    {
N        __set_short_size(__sz);
N        __p = __get_short_pointer();
N    }
N    else
N    {
N        size_type __cap = __recommend(__reserve);
N        __p = __alloc_traits::allocate(__alloc(), __cap+1);
N        __set_long_pointer(__p);
N        __set_long_cap(__cap+1);
N        __set_long_size(__sz);
N    }
N    traits_type::copy(_VSTD::__to_raw_pointer(__p), __s, __sz);
X    traits_type::copy(std::__2::__to_raw_pointer(__p), __s, __sz);
N    traits_type::assign(__p[__sz], value_type());
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nvoid
Nbasic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s, size_type __sz)
N{
N    if (__sz > max_size())
N        this->__throw_length_error();
N    pointer __p;
N    if (__sz < __min_cap)
N    {
N        __set_short_size(__sz);
N        __p = __get_short_pointer();
N    }
N    else
N    {
N        size_type __cap = __recommend(__sz);
N        __p = __alloc_traits::allocate(__alloc(), __cap+1);
N        __set_long_pointer(__p);
N        __set_long_cap(__cap+1);
N        __set_long_size(__sz);
N    }
N    traits_type::copy(_VSTD::__to_raw_pointer(__p), __s, __sz);
X    traits_type::copy(std::__2::__to_raw_pointer(__p), __s, __sz);
N    traits_type::assign(__p[__sz], value_type());
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const _CharT* __s)
N{
N    _LIBCPP_ASSERT(__s != nullptr, "basic_string(const char*) detected nullptr");
X    ((void)0);
N    __init(__s, traits_type::length(__s));
N#if _LIBCPP_DEBUG_LEVEL >= 2
S    __get_db()->__insert_c(this);
N#endif
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const _CharT* __s, const _Allocator& __a)
N    : __r_(__second_tag(), __a)
N{
N    _LIBCPP_ASSERT(__s != nullptr, "basic_string(const char*, allocator) detected nullptr");
X    ((void)0);
N    __init(__s, traits_type::length(__s));
N#if _LIBCPP_DEBUG_LEVEL >= 2
S    __get_db()->__insert_c(this);
N#endif
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const _CharT* __s, size_type __n)
N{
N    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, "basic_string(const char*, n) detected nullptr");
X    ((void)0);
N    __init(__s, __n);
N#if _LIBCPP_DEBUG_LEVEL >= 2
S    __get_db()->__insert_c(this);
N#endif
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const _CharT* __s, size_type __n, const _Allocator& __a)
N    : __r_(__second_tag(), __a)
N{
N    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, "basic_string(const char*, n, allocator) detected nullptr");
X    ((void)0);
N    __init(__s, __n);
N#if _LIBCPP_DEBUG_LEVEL >= 2
S    __get_db()->__insert_c(this);
N#endif
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str)
N    : __r_(__second_tag(), __alloc_traits::select_on_container_copy_construction(__str.__alloc()))
N{
N    if (!__str.__is_long())
N        __r_.first().__r = __str.__r_.first().__r;
N    else
N        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());
X        __init(std::__2::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());
N#if _LIBCPP_DEBUG_LEVEL >= 2
S    __get_db()->__insert_c(this);
N#endif
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>::basic_string(
N    const basic_string& __str, const allocator_type& __a)
N    : __r_(__second_tag(), __a)
N{
N    if (!__str.__is_long())
N        __r_.first().__r = __str.__r_.first().__r;
N    else
N        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());
X        __init(std::__2::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());
N#if _LIBCPP_DEBUG_LEVEL >= 2
S    __get_db()->__insert_c(this);
N#endif
N}
N
N#ifndef _LIBCPP_CXX03_LANG
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbasic_string<_CharT, _Traits, _Allocator>::basic_string(basic_string&& __str)
N#if _LIBCPP_STD_VER <= 14
X#if 14 <= 14
N        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)
X        noexcept(is_nothrow_move_constructible<allocator_type> ::value)
N#else
S        _NOEXCEPT
N#endif
N    : __r_(_VSTD::move(__str.__r_))
X    : __r_(std::__2::move(__str.__r_))
N{
N    __str.__zero();
N#if _LIBCPP_DEBUG_LEVEL >= 2
S    __get_db()->__insert_c(this);
S    if (__is_long())
S        __get_db()->swap(this, &__str);
N#endif
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbasic_string<_CharT, _Traits, _Allocator>::basic_string(basic_string&& __str, const allocator_type& __a)
N    : __r_(__second_tag(), __a)
N{
N    if (__str.__is_long() && __a != __str.__alloc()) // copy, not move
N        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());
X        __init(std::__2::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());
N    else
N    {
N        __r_.first().__r = __str.__r_.first().__r;
N        __str.__zero();
N    }
N#if _LIBCPP_DEBUG_LEVEL >= 2
S    __get_db()->__insert_c(this);
S    if (__is_long())
S        __get_db()->swap(this, &__str);
N#endif
N}
N
N#endif  // _LIBCPP_CXX03_LANG
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nvoid
Nbasic_string<_CharT, _Traits, _Allocator>::__init(size_type __n, value_type __c)
N{
N    if (__n > max_size())
N        this->__throw_length_error();
N    pointer __p;
N    if (__n < __min_cap)
N    {
N        __set_short_size(__n);
N        __p = __get_short_pointer();
N    }
N    else
N    {
N        size_type __cap = __recommend(__n);
N        __p = __alloc_traits::allocate(__alloc(), __cap+1);
N        __set_long_pointer(__p);
N        __set_long_cap(__cap+1);
N        __set_long_size(__n);
N    }
N    traits_type::assign(_VSTD::__to_raw_pointer(__p), __n, __c);
X    traits_type::assign(std::__2::__to_raw_pointer(__p), __n, __c);
N    traits_type::assign(__p[__n], value_type());
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbasic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, _CharT __c)
N{
N    __init(__n, __c);
N#if _LIBCPP_DEBUG_LEVEL >= 2
S    __get_db()->__insert_c(this);
N#endif
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbasic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, _CharT __c, const _Allocator& __a)
N    : __r_(__second_tag(), __a)
N{
N    __init(__n, __c);
N#if _LIBCPP_DEBUG_LEVEL >= 2
S    __get_db()->__insert_c(this);
N#endif
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str,
N                                                        size_type __pos, size_type __n,
N                                                        const _Allocator& __a)
N    : __r_(__second_tag(), __a)
N{
N    size_type __str_sz = __str.size();
N    if (__pos > __str_sz)
N        this->__throw_out_of_range();
N    __init(__str.data() + __pos, _VSTD::min(__n, __str_sz - __pos));
X    __init(__str.data() + __pos, std::__2::min(__n, __str_sz - __pos));
N#if _LIBCPP_DEBUG_LEVEL >= 2
S    __get_db()->__insert_c(this);
N#endif
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, size_type __pos,
N                                                        const _Allocator& __a)
N    : __r_(__second_tag(), __a)
N{
N    size_type __str_sz = __str.size();
N    if (__pos > __str_sz)
N        this->__throw_out_of_range();
N    __init(__str.data() + __pos, __str_sz - __pos);
N#if _LIBCPP_DEBUG_LEVEL >= 2
S    __get_db()->__insert_c(this);
N#endif
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ntemplate <class _Tp>
Nbasic_string<_CharT, _Traits, _Allocator>::basic_string(
N             const _Tp& __t, size_type __pos, size_type __n, const allocator_type& __a,
N			 typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, void>::type *)
N    : __r_(__second_tag(), __a)
N{
N	__self_view __sv = __self_view(__t).substr(__pos, __n);
N    __init(__sv.data(), __sv.size());
N#if _LIBCPP_DEBUG_LEVEL >= 2
S    __get_db()->__insert_c(this);
N#endif
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbasic_string<_CharT, _Traits, _Allocator>::basic_string(__self_view __sv)
N{
N    __init(__sv.data(), __sv.size());
N#if _LIBCPP_DEBUG_LEVEL >= 2
S    __get_db()->__insert_c(this);
N#endif
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbasic_string<_CharT, _Traits, _Allocator>::basic_string(__self_view __sv, const _Allocator& __a)
N    : __r_(__second_tag(), __a)
N{
N    __init(__sv.data(), __sv.size());
N#if _LIBCPP_DEBUG_LEVEL >= 2
S    __get_db()->__insert_c(this);
N#endif
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ntemplate <class _InputIterator>
Ntypename enable_if
N<
N    __is_exactly_input_iterator<_InputIterator>::value,
N    void
N>::type
Nbasic_string<_CharT, _Traits, _Allocator>::__init(_InputIterator __first, _InputIterator __last)
N{
N    __zero();
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    for (; __first != __last; ++__first)
N        push_back(*__first);
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        if (__is_long())
S            __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());
S        throw;
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ntemplate <class _ForwardIterator>
Ntypename enable_if
N<
N    __is_forward_iterator<_ForwardIterator>::value,
N    void
N>::type
Nbasic_string<_CharT, _Traits, _Allocator>::__init(_ForwardIterator __first, _ForwardIterator __last)
N{
N    size_type __sz = static_cast<size_type>(_VSTD::distance(__first, __last));
X    size_type __sz = static_cast<size_type>(std::__2::distance(__first, __last));
N    if (__sz > max_size())
N        this->__throw_length_error();
N    pointer __p;
N    if (__sz < __min_cap)
N    {
N        __set_short_size(__sz);
N        __p = __get_short_pointer();
N    }
N    else
N    {
N        size_type __cap = __recommend(__sz);
N        __p = __alloc_traits::allocate(__alloc(), __cap+1);
N        __set_long_pointer(__p);
N        __set_long_cap(__cap+1);
N        __set_long_size(__sz);
N    }
N    for (; __first != __last; ++__first, (void) ++__p)
N        traits_type::assign(*__p, *__first);
N    traits_type::assign(*__p, value_type());
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ntemplate<class _InputIterator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbasic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last)
N{
N    __init(__first, __last);
N#if _LIBCPP_DEBUG_LEVEL >= 2
S    __get_db()->__insert_c(this);
N#endif
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ntemplate<class _InputIterator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbasic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last,
N                                                        const allocator_type& __a)
N    : __r_(__second_tag(), __a)
N{
N    __init(__first, __last);
N#if _LIBCPP_DEBUG_LEVEL >= 2
S    __get_db()->__insert_c(this);
N#endif
N}
N
N#ifndef _LIBCPP_CXX03_LANG
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbasic_string<_CharT, _Traits, _Allocator>::basic_string(
N    initializer_list<_CharT> __il)
N{
N    __init(__il.begin(), __il.end());
N#if _LIBCPP_DEBUG_LEVEL >= 2
S    __get_db()->__insert_c(this);
N#endif
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N
Nbasic_string<_CharT, _Traits, _Allocator>::basic_string(
N    initializer_list<_CharT> __il, const _Allocator& __a)
N    : __r_(__second_tag(), __a)
N{
N    __init(__il.begin(), __il.end());
N#if _LIBCPP_DEBUG_LEVEL >= 2
S    __get_db()->__insert_c(this);
N#endif
N}
N
N#endif  // _LIBCPP_CXX03_LANG
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>::~basic_string()
N{
N#if _LIBCPP_DEBUG_LEVEL >= 2
S    __get_db()->__erase_c(this);
N#endif
N    if (__is_long())
N        __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nvoid
Nbasic_string<_CharT, _Traits, _Allocator>::__grow_by_and_replace
N    (size_type __old_cap, size_type __delta_cap, size_type __old_sz,
N     size_type __n_copy,  size_type __n_del,     size_type __n_add, const value_type* __p_new_stuff)
N{
N    size_type __ms = max_size();
N    if (__delta_cap > __ms - __old_cap - 1)
N        this->__throw_length_error();
N    pointer __old_p = __get_pointer();
N    size_type __cap = __old_cap < __ms / 2 - __alignment ?
N                          __recommend(_VSTD::max(__old_cap + __delta_cap, 2 * __old_cap)) :
X                          __recommend(std::__2::max(__old_cap + __delta_cap, 2 * __old_cap)) :
N                          __ms - 1;
N    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);
N    __invalidate_all_iterators();
N    if (__n_copy != 0)
N        traits_type::copy(_VSTD::__to_raw_pointer(__p),
X        traits_type::copy(std::__2::__to_raw_pointer(__p),
N                          _VSTD::__to_raw_pointer(__old_p), __n_copy);
X                          std::__2::__to_raw_pointer(__old_p), __n_copy);
N    if (__n_add != 0)
N        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy, __p_new_stuff, __n_add);
X        traits_type::copy(std::__2::__to_raw_pointer(__p) + __n_copy, __p_new_stuff, __n_add);
N    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;
N    if (__sec_cp_sz != 0)
N        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy + __n_add,
X        traits_type::copy(std::__2::__to_raw_pointer(__p) + __n_copy + __n_add,
N                          _VSTD::__to_raw_pointer(__old_p) + __n_copy + __n_del, __sec_cp_sz);
X                          std::__2::__to_raw_pointer(__old_p) + __n_copy + __n_del, __sec_cp_sz);
N    if (__old_cap+1 != __min_cap)
N        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);
N    __set_long_pointer(__p);
N    __set_long_cap(__cap+1);
N    __old_sz = __n_copy + __n_add + __sec_cp_sz;
N    __set_long_size(__old_sz);
N    traits_type::assign(__p[__old_sz], value_type());
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nvoid
Nbasic_string<_CharT, _Traits, _Allocator>::__grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,
N                                                     size_type __n_copy,  size_type __n_del,     size_type __n_add)
N{
N    size_type __ms = max_size();
N    if (__delta_cap > __ms - __old_cap)
N        this->__throw_length_error();
N    pointer __old_p = __get_pointer();
N    size_type __cap = __old_cap < __ms / 2 - __alignment ?
N                          __recommend(_VSTD::max(__old_cap + __delta_cap, 2 * __old_cap)) :
X                          __recommend(std::__2::max(__old_cap + __delta_cap, 2 * __old_cap)) :
N                          __ms - 1;
N    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);
N    __invalidate_all_iterators();
N    if (__n_copy != 0)
N        traits_type::copy(_VSTD::__to_raw_pointer(__p),
X        traits_type::copy(std::__2::__to_raw_pointer(__p),
N                          _VSTD::__to_raw_pointer(__old_p), __n_copy);
X                          std::__2::__to_raw_pointer(__old_p), __n_copy);
N    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;
N    if (__sec_cp_sz != 0)
N        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy + __n_add,
X        traits_type::copy(std::__2::__to_raw_pointer(__p) + __n_copy + __n_add,
N                          _VSTD::__to_raw_pointer(__old_p) + __n_copy + __n_del,
X                          std::__2::__to_raw_pointer(__old_p) + __n_copy + __n_del,
N                          __sec_cp_sz);
N    if (__old_cap+1 != __min_cap)
N        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);
N    __set_long_pointer(__p);
N    __set_long_cap(__cap+1);
N}
N
N// assign
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>&
Nbasic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s, size_type __n)
N{
N    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, "string::assign received nullptr");
X    ((void)0);
N    size_type __cap = capacity();
N    if (__cap >= __n)
N    {
N        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());
X        value_type* __p = std::__2::__to_raw_pointer(__get_pointer());
N        traits_type::move(__p, __s, __n);
N        traits_type::assign(__p[__n], value_type());
N        __set_size(__n);
N        __invalidate_iterators_past(__n);
N    }
N    else
N    {
N        size_type __sz = size();
N        __grow_by_and_replace(__cap, __n - __cap, __sz, 0, __sz, __n, __s);
N    }
N    return *this;
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>&
Nbasic_string<_CharT, _Traits, _Allocator>::assign(size_type __n, value_type __c)
N{
N    size_type __cap = capacity();
N    if (__cap < __n)
N    {
N        size_type __sz = size();
N        __grow_by(__cap, __n - __cap, __sz, 0, __sz);
N    }
N    else
N        __invalidate_iterators_past(__n);
N    value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());
X    value_type* __p = std::__2::__to_raw_pointer(__get_pointer());
N    traits_type::assign(__p, __n, __c);
N    traits_type::assign(__p[__n], value_type());
N    __set_size(__n);
N    return *this;
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>&
Nbasic_string<_CharT, _Traits, _Allocator>::operator=(value_type __c)
N{
N    pointer __p;
N    if (__is_long())
N    {
N        __p = __get_long_pointer();
N        __set_long_size(1);
N    }
N    else
N    {
N        __p = __get_short_pointer();
N        __set_short_size(1);
N    }
N    traits_type::assign(*__p, __c);
N    traits_type::assign(*++__p, value_type());
N    __invalidate_iterators_past(1);
N    return *this;
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>&
Nbasic_string<_CharT, _Traits, _Allocator>::operator=(const basic_string& __str)
N{
N    if (this != &__str)
N    {
N        __copy_assign_alloc(__str);
N        assign(__str.data(), __str.size());
N    }
N    return *this;
N}
N
N#ifndef _LIBCPP_CXX03_LANG
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Nbasic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, false_type)
N    _NOEXCEPT_(__alloc_traits::is_always_equal::value)
X    noexcept(__alloc_traits::is_always_equal::value)
N{
N    if (__alloc() != __str.__alloc())
N        assign(__str);
N    else
N        __move_assign(__str, true_type());
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Nbasic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, true_type)
N#if _LIBCPP_STD_VER > 14
X#if 14 > 14
S    _NOEXCEPT
N#else
N    _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)
X    noexcept(is_nothrow_move_assignable<allocator_type> ::value)
N#endif
N{
N    clear();
N    shrink_to_fit();
N    __r_.first() = __str.__r_.first();
N    __move_assign_alloc(__str);
N    __str.__zero();
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbasic_string<_CharT, _Traits, _Allocator>&
Nbasic_string<_CharT, _Traits, _Allocator>::operator=(basic_string&& __str)
N    _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))
X    noexcept((__noexcept_move_assign_container<_Allocator, __alloc_traits> ::value))
N{
N    __move_assign(__str, integral_constant<bool,
N          __alloc_traits::propagate_on_container_move_assignment::value>());
N    return *this;
N}
N
N#endif
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ntemplate<class _InputIterator>
Ntypename enable_if
N<
N     __is_exactly_input_iterator <_InputIterator>::value
N          || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,
N    basic_string<_CharT, _Traits, _Allocator>&
N>::type
Nbasic_string<_CharT, _Traits, _Allocator>::assign(_InputIterator __first, _InputIterator __last)
N{
N    const basic_string __temp(__first, __last, __alloc());
N    assign(__temp.data(), __temp.size());
N    return *this;
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ntemplate<class _ForwardIterator>
Ntypename enable_if
N<
N    __is_forward_iterator<_ForwardIterator>::value
N         && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,
N    basic_string<_CharT, _Traits, _Allocator>&
N>::type
Nbasic_string<_CharT, _Traits, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)
N{
N    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));
X    size_type __n = static_cast<size_type>(std::__2::distance(__first, __last));
N    size_type __cap = capacity();
N    if (__cap < __n)
N    {
N        size_type __sz = size();
N        __grow_by(__cap, __n - __cap, __sz, 0, __sz);
N    }
N    else
N        __invalidate_iterators_past(__n);
N    pointer __p = __get_pointer();
N    for (; __first != __last; ++__first, ++__p)
N        traits_type::assign(*__p, *__first);
N    traits_type::assign(*__p, value_type());
N    __set_size(__n);
N    return *this;
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>&
Nbasic_string<_CharT, _Traits, _Allocator>::assign(const basic_string& __str, size_type __pos, size_type __n)
N{
N    size_type __sz = __str.size();
N    if (__pos > __sz)
N        this->__throw_out_of_range();
N    return assign(__str.data() + __pos, _VSTD::min(__n, __sz - __pos));
X    return assign(__str.data() + __pos, std::__2::min(__n, __sz - __pos));
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ntemplate <class _Tp>
Ntypename enable_if
N<
N    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
N	basic_string<_CharT, _Traits, _Allocator>&
N>::type
Nbasic_string<_CharT, _Traits, _Allocator>::assign(const _Tp & __t, size_type __pos, size_type __n)
N{
N    __self_view __sv = __t;
N    size_type __sz = __sv.size();
N    if (__pos > __sz)
N        this->__throw_out_of_range();
N    return assign(__sv.data() + __pos, _VSTD::min(__n, __sz - __pos));
X    return assign(__sv.data() + __pos, std::__2::min(__n, __sz - __pos));
N}
N
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>&
Nbasic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s)
N{
N    _LIBCPP_ASSERT(__s != nullptr, "string::assign received nullptr");
X    ((void)0);
N    return assign(__s, traits_type::length(__s));
N}
N
N// append
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>&
Nbasic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s, size_type __n)
N{
N    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, "string::append received nullptr");
X    ((void)0);
N    size_type __cap = capacity();
N    size_type __sz = size();
N    if (__cap - __sz >= __n)
N    {
N        if (__n)
N        {
N            value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());
X            value_type* __p = std::__2::__to_raw_pointer(__get_pointer());
N            traits_type::copy(__p + __sz, __s, __n);
N            __sz += __n;
N            __set_size(__sz);
N            traits_type::assign(__p[__sz], value_type());
N        }
N    }
N    else
N        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __sz, 0, __n, __s);
N    return *this;
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>&
Nbasic_string<_CharT, _Traits, _Allocator>::append(size_type __n, value_type __c)
N{
N    if (__n)
N    {
N        size_type __cap = capacity();
N        size_type __sz = size();
N        if (__cap - __sz < __n)
N            __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);
N        pointer __p = __get_pointer();
N        traits_type::assign(_VSTD::__to_raw_pointer(__p) + __sz, __n, __c);
X        traits_type::assign(std::__2::__to_raw_pointer(__p) + __sz, __n, __c);
N        __sz += __n;
N        __set_size(__sz);
N        traits_type::assign(__p[__sz], value_type());
N    }
N    return *this;
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nvoid
Nbasic_string<_CharT, _Traits, _Allocator>::push_back(value_type __c)
N{
N    bool __is_short = !__is_long();
N    size_type __cap;
N    size_type __sz;
N    if (__is_short)
N    {
N        __cap = __min_cap - 1;
N        __sz = __get_short_size();
N    }
N    else
N    {
N        __cap = __get_long_cap() - 1;
N        __sz = __get_long_size();
N    }
N    if (__sz == __cap)
N    {
N        __grow_by(__cap, 1, __sz, __sz, 0);
N        __is_short = !__is_long();
N    }
N    pointer __p;
N    if (__is_short)
N    {
N        __p = __get_short_pointer() + __sz;
N        __set_short_size(__sz+1);
N    }
N    else
N    {
N        __p = __get_long_pointer() + __sz;
N        __set_long_size(__sz+1);
N    }
N    traits_type::assign(*__p, __c);
N    traits_type::assign(*++__p, value_type());
N}
N
Ntemplate <class _Tp>
Nbool __ptr_in_range (const _Tp* __p, const _Tp* __first, const _Tp* __last)
N{
N    return __first <= __p && __p < __last;
N}
N
Ntemplate <class _Tp1, class _Tp2>
Nbool __ptr_in_range (const _Tp1*, const _Tp2*, const _Tp2*)
N{
N    return false;
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ntemplate<class _ForwardIterator>
Nbasic_string<_CharT, _Traits, _Allocator>&
Nbasic_string<_CharT, _Traits, _Allocator>::__append_forward_unsafe(
N    _ForwardIterator __first, _ForwardIterator __last)
N{
N    static_assert(__is_forward_iterator<_ForwardIterator>::value,
N                  "function requires a ForwardIterator");
N    size_type __sz = size();
N    size_type __cap = capacity();
N    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));
X    size_type __n = static_cast<size_type>(std::__2::distance(__first, __last));
N    if (__n)
N    {
N        typedef typename iterator_traits<_ForwardIterator>::reference _CharRef;
N        _CharRef __tmp_ref = *__first;
N        if (__ptr_in_range(_VSTD::addressof(__tmp_ref), data(), data() + size()))
X        if (__ptr_in_range(std::__2::addressof(__tmp_ref), data(), data() + size()))
N        {
N            const basic_string __temp (__first, __last, __alloc());
N            append(__temp.data(), __temp.size());
N        }
N        else 
N        {
N            if (__cap - __sz < __n)
N                __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);
N            pointer __p = __get_pointer() + __sz;
N            for (; __first != __last; ++__p, ++__first)
N                traits_type::assign(*__p, *__first);
N            traits_type::assign(*__p, value_type());
N            __set_size(__sz + __n);
N        }
N    }
N    return *this;
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbasic_string<_CharT, _Traits, _Allocator>&
Nbasic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str)
N{
N    return append(__str.data(), __str.size());
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>&
Nbasic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str, size_type __pos, size_type __n)
N{
N    size_type __sz = __str.size();
N    if (__pos > __sz)
N        this->__throw_out_of_range();
N    return append(__str.data() + __pos, _VSTD::min(__n, __sz - __pos));
X    return append(__str.data() + __pos, std::__2::min(__n, __sz - __pos));
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ntemplate <class _Tp>
N    typename enable_if
N    <
N        __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
N        basic_string<_CharT, _Traits, _Allocator>&
N    >::type
Nbasic_string<_CharT, _Traits, _Allocator>::append(const _Tp & __t, size_type __pos, size_type __n)
N{
N    __self_view __sv = __t;
N    size_type __sz = __sv.size();
N    if (__pos > __sz)
N        this->__throw_out_of_range();
N    return append(__sv.data() + __pos, _VSTD::min(__n, __sz - __pos));
X    return append(__sv.data() + __pos, std::__2::min(__n, __sz - __pos));
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>&
Nbasic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s)
N{
N    _LIBCPP_ASSERT(__s != nullptr, "string::append received nullptr");
X    ((void)0);
N    return append(__s, traits_type::length(__s));
N}
N
N// insert
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>&
Nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s, size_type __n)
N{
N    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, "string::insert received nullptr");
X    ((void)0);
N    size_type __sz = size();
N    if (__pos > __sz)
N        this->__throw_out_of_range();
N    size_type __cap = capacity();
N    if (__cap - __sz >= __n)
N    {
N        if (__n)
N        {
N            value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());
X            value_type* __p = std::__2::__to_raw_pointer(__get_pointer());
N            size_type __n_move = __sz - __pos;
N            if (__n_move != 0)
N            {
N                if (__p + __pos <= __s && __s < __p + __sz)
N                    __s += __n;
N                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);
N            }
N            traits_type::move(__p + __pos, __s, __n);
N            __sz += __n;
N            __set_size(__sz);
N            traits_type::assign(__p[__sz], value_type());
N        }
N    }
N    else
N        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __pos, 0, __n, __s);
N    return *this;
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>&
Nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, size_type __n, value_type __c)
N{
N    size_type __sz = size();
N    if (__pos > __sz)
N        this->__throw_out_of_range();
N    if (__n)
N    {
N        size_type __cap = capacity();
N        value_type* __p;
N        if (__cap - __sz >= __n)
N        {
N            __p = _VSTD::__to_raw_pointer(__get_pointer());
X            __p = std::__2::__to_raw_pointer(__get_pointer());
N            size_type __n_move = __sz - __pos;
N            if (__n_move != 0)
N                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);
N        }
N        else
N        {
N            __grow_by(__cap, __sz + __n - __cap, __sz, __pos, 0, __n);
N            __p = _VSTD::__to_raw_pointer(__get_long_pointer());
X            __p = std::__2::__to_raw_pointer(__get_long_pointer());
N        }
N        traits_type::assign(__p + __pos, __n, __c);
N        __sz += __n;
N        __set_size(__sz);
N        traits_type::assign(__p[__sz], value_type());
N    }
N    return *this;
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ntemplate<class _InputIterator>
Ntypename enable_if
N<
N   __is_exactly_input_iterator<_InputIterator>::value
N        || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,
N   typename basic_string<_CharT, _Traits, _Allocator>::iterator
N>::type
Nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _InputIterator __first, _InputIterator __last)
N{
N#if _LIBCPP_DEBUG_LEVEL >= 2
S    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,
S        "string::insert(iterator, range) called with an iterator not"
S        " referring to this string");
N#endif
N    const basic_string __temp(__first, __last, __alloc());
N    return insert(__pos, __temp.data(), __temp.data() + __temp.size());
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ntemplate<class _ForwardIterator>
Ntypename enable_if
N<
N    __is_forward_iterator<_ForwardIterator>::value
N        && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,
N    typename basic_string<_CharT, _Traits, _Allocator>::iterator
N>::type
Nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last)
N{
N#if _LIBCPP_DEBUG_LEVEL >= 2
S    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,
S        "string::insert(iterator, range) called with an iterator not"
S        " referring to this string");
N#endif
N    size_type __ip = static_cast<size_type>(__pos - begin());
N    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));
X    size_type __n = static_cast<size_type>(std::__2::distance(__first, __last));
N    if (__n)
N    {
N        typedef typename iterator_traits<_ForwardIterator>::reference _CharRef;
N        _CharRef __tmp_char = *__first;
N        if (__ptr_in_range(_VSTD::addressof(__tmp_char), data(), data() + size()))
X        if (__ptr_in_range(std::__2::addressof(__tmp_char), data(), data() + size()))
N        {
N            const basic_string __temp(__first, __last, __alloc());
N            return insert(__pos, __temp.data(), __temp.data() + __temp.size());
N        }
N
N        size_type __sz = size();
N        size_type __cap = capacity();
N        value_type* __p;
N        if (__cap - __sz >= __n)
N        {
N            __p = _VSTD::__to_raw_pointer(__get_pointer());
X            __p = std::__2::__to_raw_pointer(__get_pointer());
N            size_type __n_move = __sz - __ip;
N            if (__n_move != 0)
N                traits_type::move(__p + __ip + __n, __p + __ip, __n_move);
N        }
N        else
N        {
N            __grow_by(__cap, __sz + __n - __cap, __sz, __ip, 0, __n);
N            __p = _VSTD::__to_raw_pointer(__get_long_pointer());
X            __p = std::__2::__to_raw_pointer(__get_long_pointer());
N        }
N        __sz += __n;
N        __set_size(__sz);
N        traits_type::assign(__p[__sz], value_type());
N        for (__p += __ip; __first != __last; ++__p, ++__first)
N            traits_type::assign(*__p, *__first);
N    }
N    return begin() + __ip;
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbasic_string<_CharT, _Traits, _Allocator>&
Nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str)
N{
N    return insert(__pos1, __str.data(), __str.size());
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>&
Nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str,
N                                                  size_type __pos2, size_type __n)
N{
N    size_type __str_sz = __str.size();
N    if (__pos2 > __str_sz)
N        this->__throw_out_of_range();
N    return insert(__pos1, __str.data() + __pos2, _VSTD::min(__n, __str_sz - __pos2));
X    return insert(__pos1, __str.data() + __pos2, std::__2::min(__n, __str_sz - __pos2));
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ntemplate <class _Tp>
Ntypename enable_if
N<
N    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
N	basic_string<_CharT, _Traits, _Allocator>&
N>::type
Nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const _Tp& __t,
N                                                  size_type __pos2, size_type __n)
N{
N    __self_view __sv = __t;
N    size_type __str_sz = __sv.size();
N    if (__pos2 > __str_sz)
N        this->__throw_out_of_range();
N    return insert(__pos1, __sv.data() + __pos2, _VSTD::min(__n, __str_sz - __pos2));
X    return insert(__pos1, __sv.data() + __pos2, std::__2::min(__n, __str_sz - __pos2));
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>&
Nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s)
N{
N    _LIBCPP_ASSERT(__s != nullptr, "string::insert received nullptr");
X    ((void)0);
N    return insert(__pos, __s, traits_type::length(__s));
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ntypename basic_string<_CharT, _Traits, _Allocator>::iterator
Nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, value_type __c)
N{
N    size_type __ip = static_cast<size_type>(__pos - begin());
N    size_type __sz = size();
N    size_type __cap = capacity();
N    value_type* __p;
N    if (__cap == __sz)
N    {
N        __grow_by(__cap, 1, __sz, __ip, 0, 1);
N        __p = _VSTD::__to_raw_pointer(__get_long_pointer());
X        __p = std::__2::__to_raw_pointer(__get_long_pointer());
N    }
N    else
N    {
N        __p = _VSTD::__to_raw_pointer(__get_pointer());
X        __p = std::__2::__to_raw_pointer(__get_pointer());
N        size_type __n_move = __sz - __ip;
N        if (__n_move != 0)
N            traits_type::move(__p + __ip + 1, __p + __ip, __n_move);
N    }
N    traits_type::assign(__p[__ip], __c);
N    traits_type::assign(__p[++__sz], value_type());
N    __set_size(__sz);
N    return begin() + static_cast<difference_type>(__ip);
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename basic_string<_CharT, _Traits, _Allocator>::iterator
Nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, size_type __n, value_type __c)
N{
N#if _LIBCPP_DEBUG_LEVEL >= 2
S    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,
S        "string::insert(iterator, n, value) called with an iterator not"
S        " referring to this string");
N#endif
N    difference_type __p = __pos - begin();
N    insert(static_cast<size_type>(__p), __n, __c);
N    return begin() + __p;
N}
N
N// replace
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>&
Nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2)
N    _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK
X    
N{
N    _LIBCPP_ASSERT(__n2 == 0 || __s != nullptr, "string::replace received nullptr");
X    ((void)0);
N    size_type __sz = size();
N    if (__pos > __sz)
N        this->__throw_out_of_range();
N    __n1 = _VSTD::min(__n1, __sz - __pos);
X    __n1 = std::__2::min(__n1, __sz - __pos);
N    size_type __cap = capacity();
N    if (__cap - __sz + __n1 >= __n2)
N    {
N        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());
X        value_type* __p = std::__2::__to_raw_pointer(__get_pointer());
N        if (__n1 != __n2)
N        {
N            size_type __n_move = __sz - __pos - __n1;
N            if (__n_move != 0)
N            {
N                if (__n1 > __n2)
N                {
N                    traits_type::move(__p + __pos, __s, __n2);
N                    traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);
N                    goto __finish;
N                }
N                if (__p + __pos < __s && __s < __p + __sz)
N                {
N                    if (__p + __pos + __n1 <= __s)
N                        __s += __n2 - __n1;
N                    else // __p + __pos < __s < __p + __pos + __n1
N                    {
N                        traits_type::move(__p + __pos, __s, __n1);
N                        __pos += __n1;
N                        __s += __n2;
N                        __n2 -= __n1;
N                        __n1 = 0;
N                    }
N                }
N                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);
N            }
N        }
N        traits_type::move(__p + __pos, __s, __n2);
N__finish:
N// __sz += __n2 - __n1; in this and the below function below can cause unsigned integer overflow,
N// but this is a safe operation, so we disable the check.
N        __sz += __n2 - __n1;
N        __set_size(__sz);
N        __invalidate_iterators_past(__sz);
N        traits_type::assign(__p[__sz], value_type());
N    }
N    else
N        __grow_by_and_replace(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2, __s);
N    return *this;
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>&
Nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, size_type __n2, value_type __c)
N    _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK
X    
N{
N    size_type __sz = size();
N    if (__pos > __sz)
N        this->__throw_out_of_range();
N    __n1 = _VSTD::min(__n1, __sz - __pos);
X    __n1 = std::__2::min(__n1, __sz - __pos);
N    size_type __cap = capacity();
N    value_type* __p;
N    if (__cap - __sz + __n1 >= __n2)
N    {
N        __p = _VSTD::__to_raw_pointer(__get_pointer());
X        __p = std::__2::__to_raw_pointer(__get_pointer());
N        if (__n1 != __n2)
N        {
N            size_type __n_move = __sz - __pos - __n1;
N            if (__n_move != 0)
N                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);
N        }
N    }
N    else
N    {
N        __grow_by(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2);
N        __p = _VSTD::__to_raw_pointer(__get_long_pointer());
X        __p = std::__2::__to_raw_pointer(__get_long_pointer());
N    }
N    traits_type::assign(__p + __pos, __n2, __c);
N    __sz += __n2 - __n1;
N    __set_size(__sz);
N    __invalidate_iterators_past(__sz);
N    traits_type::assign(__p[__sz], value_type());
N    return *this;
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ntemplate<class _InputIterator>
Ntypename enable_if
N<
N    __is_input_iterator<_InputIterator>::value,
N    basic_string<_CharT, _Traits, _Allocator>&
N>::type
Nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2,
N                                                   _InputIterator __j1, _InputIterator __j2)
N{
N    const basic_string __temp(__j1, __j2, __alloc());
N    return this->replace(__i1, __i2, __temp);
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbasic_string<_CharT, _Traits, _Allocator>&
Nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str)
N{
N    return replace(__pos1, __n1, __str.data(), __str.size());
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>&
Nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str,
N                                                   size_type __pos2, size_type __n2)
N{
N    size_type __str_sz = __str.size();
N    if (__pos2 > __str_sz)
N        this->__throw_out_of_range();
N    return replace(__pos1, __n1, __str.data() + __pos2, _VSTD::min(__n2, __str_sz - __pos2));
X    return replace(__pos1, __n1, __str.data() + __pos2, std::__2::min(__n2, __str_sz - __pos2));
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ntemplate <class _Tp>
Ntypename enable_if
N<
N	__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
N	basic_string<_CharT, _Traits, _Allocator>&
N>::type
Nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const _Tp& __t,
N                                                   size_type __pos2, size_type __n2)
N{
N    __self_view __sv = __t;
N    size_type __str_sz = __sv.size();
N    if (__pos2 > __str_sz)
N        this->__throw_out_of_range();
N    return replace(__pos1, __n1, __sv.data() + __pos2, _VSTD::min(__n2, __str_sz - __pos2));
X    return replace(__pos1, __n1, __sv.data() + __pos2, std::__2::min(__n2, __str_sz - __pos2));
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>&
Nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s)
N{
N    _LIBCPP_ASSERT(__s != nullptr, "string::replace received nullptr");
X    ((void)0);
N    return replace(__pos, __n1, __s, traits_type::length(__s));
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbasic_string<_CharT, _Traits, _Allocator>&
Nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const basic_string& __str)
N{
N    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1),
N                   __str.data(), __str.size());
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbasic_string<_CharT, _Traits, _Allocator>&
Nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n)
N{
N    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s, __n);
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbasic_string<_CharT, _Traits, _Allocator>&
Nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s)
N{
N    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s);
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbasic_string<_CharT, _Traits, _Allocator>&
Nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c)
N{
N    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __n, __c);
N}
N
N// erase
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>&
Nbasic_string<_CharT, _Traits, _Allocator>::erase(size_type __pos, size_type __n)
N{
N    size_type __sz = size();
N    if (__pos > __sz)
N        this->__throw_out_of_range();
N    if (__n)
N    {
N        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());
X        value_type* __p = std::__2::__to_raw_pointer(__get_pointer());
N        __n = _VSTD::min(__n, __sz - __pos);
X        __n = std::__2::min(__n, __sz - __pos);
N        size_type __n_move = __sz - __pos - __n;
N        if (__n_move != 0)
N            traits_type::move(__p + __pos, __p + __pos + __n, __n_move);
N        __sz -= __n;
N        __set_size(__sz);
N        __invalidate_iterators_past(__sz);
N        traits_type::assign(__p[__sz], value_type());
N    }
N    return *this;
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename basic_string<_CharT, _Traits, _Allocator>::iterator
Nbasic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __pos)
N{
N#if _LIBCPP_DEBUG_LEVEL >= 2
S    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,
S        "string::erase(iterator) called with an iterator not"
S        " referring to this string");
N#endif
N    _LIBCPP_ASSERT(__pos != end(),
N        "string::erase(iterator) called with a non-dereferenceable iterator");
X    ((void)0);
N    iterator __b = begin();
N    size_type __r = static_cast<size_type>(__pos - __b);
N    erase(__r, 1);
N    return __b + static_cast<difference_type>(__r);
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename basic_string<_CharT, _Traits, _Allocator>::iterator
Nbasic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __first, const_iterator __last)
N{
N#if _LIBCPP_DEBUG_LEVEL >= 2
S    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__first) == this,
S        "string::erase(iterator,  iterator) called with an iterator not"
S        " referring to this string");
N#endif
N    _LIBCPP_ASSERT(__first <= __last, "string::erase(first, last) called with invalid range");
X    ((void)0);
N    iterator __b = begin();
N    size_type __r = static_cast<size_type>(__first - __b);
N    erase(__r, static_cast<size_type>(__last - __first));
N    return __b + static_cast<difference_type>(__r);
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Nbasic_string<_CharT, _Traits, _Allocator>::pop_back()
N{
N    _LIBCPP_ASSERT(!empty(), "string::pop_back(): string is already empty");
X    ((void)0);
N    size_type __sz;
N    if (__is_long())
N    {
N        __sz = __get_long_size() - 1;
N        __set_long_size(__sz);
N        traits_type::assign(*(__get_long_pointer() + __sz), value_type());
N    }
N    else
N    {
N        __sz = __get_short_size() - 1;
N        __set_short_size(__sz);
N        traits_type::assign(*(__get_short_pointer() + __sz), value_type());
N    }
N    __invalidate_iterators_past(__sz);
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Nbasic_string<_CharT, _Traits, _Allocator>::clear() _NOEXCEPT
Xbasic_string<_CharT, _Traits, _Allocator>::clear() noexcept
N{
N    __invalidate_all_iterators();
N    if (__is_long())
N    {
N        traits_type::assign(*__get_long_pointer(), value_type());
N        __set_long_size(0);
N    }
N    else
N    {
N        traits_type::assign(*__get_short_pointer(), value_type());
N        __set_short_size(0);
N    }
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Nbasic_string<_CharT, _Traits, _Allocator>::__erase_to_end(size_type __pos)
N{
N    if (__is_long())
N    {
N        traits_type::assign(*(__get_long_pointer() + __pos), value_type());
N        __set_long_size(__pos);
N    }
N    else
N    {
N        traits_type::assign(*(__get_short_pointer() + __pos), value_type());
N        __set_short_size(__pos);
N    }
N    __invalidate_iterators_past(__pos);
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nvoid
Nbasic_string<_CharT, _Traits, _Allocator>::resize(size_type __n, value_type __c)
N{
N    size_type __sz = size();
N    if (__n > __sz)
N        append(__n - __sz, __c);
N    else
N        __erase_to_end(__n);
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::max_size() const _NOEXCEPT
Xbasic_string<_CharT, _Traits, _Allocator>::max_size() const noexcept
N{
N    size_type __m = __alloc_traits::max_size(__alloc());
N#ifdef _LIBCPP_BIG_ENDIAN
S    return (__m <= ~__long_mask ? __m : __m/2) - __alignment;
N#else
N    return __m - __alignment;
N#endif
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nvoid
Nbasic_string<_CharT, _Traits, _Allocator>::reserve(size_type __res_arg)
N{
N    if (__res_arg > max_size())
N        this->__throw_length_error();
N    size_type __cap = capacity();
N    size_type __sz = size();
N    __res_arg = _VSTD::max(__res_arg, __sz);
X    __res_arg = std::__2::max(__res_arg, __sz);
N    __res_arg = __recommend(__res_arg);
N    if (__res_arg != __cap)
N    {
N        pointer __new_data, __p;
N        bool __was_long, __now_long;
N        if (__res_arg == __min_cap - 1)
N        {
N            __was_long = true;
N            __now_long = false;
N            __new_data = __get_short_pointer();
N            __p = __get_long_pointer();
N        }
N        else
N        {
N            if (__res_arg > __cap)
N                __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);
N            else
N            {
N            #ifndef _LIBCPP_NO_EXCEPTIONS
S                try
S                {
N            #endif  // _LIBCPP_NO_EXCEPTIONS
N                    __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);
N            #ifndef _LIBCPP_NO_EXCEPTIONS
S                }
S                catch (...)
S                {
S                    return;
S                }
N            #else  // _LIBCPP_NO_EXCEPTIONS
N                if (__new_data == nullptr)
N                    return;
N            #endif  // _LIBCPP_NO_EXCEPTIONS
N            }
N            __now_long = true;
N            __was_long = __is_long();
N            __p = __get_pointer();
N        }
N        traits_type::copy(_VSTD::__to_raw_pointer(__new_data),
X        traits_type::copy(std::__2::__to_raw_pointer(__new_data),
N                          _VSTD::__to_raw_pointer(__p), size()+1);
X                          std::__2::__to_raw_pointer(__p), size()+1);
N        if (__was_long)
N            __alloc_traits::deallocate(__alloc(), __p, __cap+1);
N        if (__now_long)
N        {
N            __set_long_cap(__res_arg+1);
N            __set_long_size(__sz);
N            __set_long_pointer(__new_data);
N        }
N        else
N            __set_short_size(__sz);
N        __invalidate_all_iterators();
N    }
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference
Nbasic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos) const _NOEXCEPT
Xbasic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos) const noexcept
N{
N    _LIBCPP_ASSERT(__pos <= size(), "string index out of bounds");
X    ((void)0);
N    return *(data() + __pos);
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename basic_string<_CharT, _Traits, _Allocator>::reference
Nbasic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos) _NOEXCEPT
Xbasic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos) noexcept
N{
N    _LIBCPP_ASSERT(__pos <= size(), "string index out of bounds");
X    ((void)0);
N    return *(__get_pointer() + __pos);
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference
Nbasic_string<_CharT, _Traits, _Allocator>::at(size_type __n) const
N{
N    if (__n >= size())
N        this->__throw_out_of_range();
N    return (*this)[__n];
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ntypename basic_string<_CharT, _Traits, _Allocator>::reference
Nbasic_string<_CharT, _Traits, _Allocator>::at(size_type __n)
N{
N    if (__n >= size())
N        this->__throw_out_of_range();
N    return (*this)[__n];
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename basic_string<_CharT, _Traits, _Allocator>::reference
Nbasic_string<_CharT, _Traits, _Allocator>::front()
N{
N    _LIBCPP_ASSERT(!empty(), "string::front(): string is empty");
X    ((void)0);
N    return *__get_pointer();
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference
Nbasic_string<_CharT, _Traits, _Allocator>::front() const
N{
N    _LIBCPP_ASSERT(!empty(), "string::front(): string is empty");
X    ((void)0);
N    return *data();
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename basic_string<_CharT, _Traits, _Allocator>::reference
Nbasic_string<_CharT, _Traits, _Allocator>::back()
N{
N    _LIBCPP_ASSERT(!empty(), "string::back(): string is empty");
X    ((void)0);
N    return *(__get_pointer() + size() - 1);
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference
Nbasic_string<_CharT, _Traits, _Allocator>::back() const
N{
N    _LIBCPP_ASSERT(!empty(), "string::back(): string is empty");
X    ((void)0);
N    return *(data() + size() - 1);
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ntypename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::copy(value_type* __s, size_type __n, size_type __pos) const
N{
N    size_type __sz = size();
N    if (__pos > __sz)
N        this->__throw_out_of_range();
N    size_type __rlen = _VSTD::min(__n, __sz - __pos);
X    size_type __rlen = std::__2::min(__n, __sz - __pos);
N    traits_type::copy(__s, data() + __pos, __rlen);
N    return __rlen;
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbasic_string<_CharT, _Traits, _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>::substr(size_type __pos, size_type __n) const
N{
N    return basic_string(*this, __pos, __n, __alloc());
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Nbasic_string<_CharT, _Traits, _Allocator>::swap(basic_string& __str)
N#if _LIBCPP_STD_VER >= 14
X#if 14 >= 14
N        _NOEXCEPT_DEBUG
X        noexcept
N#else
S        _NOEXCEPT_DEBUG_(!__alloc_traits::propagate_on_container_swap::value ||
S                    __is_nothrow_swappable<allocator_type>::value)
N#endif
N{
N#if _LIBCPP_DEBUG_LEVEL >= 2
S    if (!__is_long())
S        __get_db()->__invalidate_all(this);
S    if (!__str.__is_long())
S        __get_db()->__invalidate_all(&__str);
S    __get_db()->swap(this, &__str);
N#endif
N    _LIBCPP_ASSERT(
N        __alloc_traits::propagate_on_container_swap::value ||
N        __alloc_traits::is_always_equal::value ||
N        __alloc() == __str.__alloc(), "swapping non-equal allocators");
X    ((void)0);
N    _VSTD::swap(__r_.first(), __str.__r_.first());
X    std::__2::swap(__r_.first(), __str.__r_.first());
N    __swap_allocator(__alloc(), __str.__alloc());
N}
N
N// find
N
Ntemplate <class _Traits>
Nstruct _LIBCPP_HIDDEN __traits_eq
Xstruct  __traits_eq
N{
N    typedef typename _Traits::char_type char_type;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    bool operator()(const char_type& __x, const char_type& __y) _NOEXCEPT
X    bool operator()(const char_type& __x, const char_type& __y) noexcept
N        {return _Traits::eq(__x, __y);}
N};
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ntypename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,
N                                                size_type __pos,
N                                                size_type __n) const _NOEXCEPT
X                                                size_type __n) const noexcept
N{
N    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, "string::find(): received nullptr");
X    ((void)0);
N    return __str_find<value_type, size_type, traits_type, npos>
N        (data(), size(), __s, __pos, __n);
N}
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::find(const basic_string& __str,
N                                                size_type __pos) const _NOEXCEPT
X                                                size_type __pos) const noexcept
N{
N    return __str_find<value_type, size_type, traits_type, npos>
N        (data(), size(), __str.data(), __pos, __str.size());
N}
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::find(__self_view __sv,
N                                                size_type __pos) const _NOEXCEPT
X                                                size_type __pos) const noexcept
N{
N    return __str_find<value_type, size_type, traits_type, npos>
N        (data(), size(), __sv.data(), __pos, __sv.size());
N}
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,
N                                                size_type __pos) const _NOEXCEPT
X                                                size_type __pos) const noexcept
N{
N    _LIBCPP_ASSERT(__s != nullptr, "string::find(): received nullptr");
X    ((void)0);
N    return __str_find<value_type, size_type, traits_type, npos>
N        (data(), size(), __s, __pos, traits_type::length(__s));
N}
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ntypename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::find(value_type __c,
N                                                size_type __pos) const _NOEXCEPT
X                                                size_type __pos) const noexcept
N{
N    return __str_find<value_type, size_type, traits_type, npos>
N        (data(), size(), __c, __pos);
N}
N
N// rfind
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ntypename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,
N                                                 size_type __pos,
N                                                 size_type __n) const _NOEXCEPT
X                                                 size_type __n) const noexcept
N{
N    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, "string::rfind(): received nullptr");
X    ((void)0);
N    return __str_rfind<value_type, size_type, traits_type, npos>
N        (data(), size(), __s, __pos, __n);
N}
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::rfind(const basic_string& __str,
N                                                 size_type __pos) const _NOEXCEPT
X                                                 size_type __pos) const noexcept
N{
N    return __str_rfind<value_type, size_type, traits_type, npos>
N        (data(), size(), __str.data(), __pos, __str.size());
N}
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::rfind(__self_view __sv,
N                                                size_type __pos) const _NOEXCEPT
X                                                size_type __pos) const noexcept
N{
N    return __str_rfind<value_type, size_type, traits_type, npos>
N        (data(), size(), __sv.data(), __pos, __sv.size());
N}
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,
N                                                 size_type __pos) const _NOEXCEPT
X                                                 size_type __pos) const noexcept
N{
N    _LIBCPP_ASSERT(__s != nullptr, "string::rfind(): received nullptr");
X    ((void)0);
N    return __str_rfind<value_type, size_type, traits_type, npos>
N        (data(), size(), __s, __pos, traits_type::length(__s));
N}
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ntypename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::rfind(value_type __c,
N                                                 size_type __pos) const _NOEXCEPT
X                                                 size_type __pos) const noexcept
N{
N    return __str_rfind<value_type, size_type, traits_type, npos>
N        (data(), size(), __c, __pos);
N}
N
N// find_first_of
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ntypename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,
N                                                         size_type __pos,
N                                                         size_type __n) const _NOEXCEPT
X                                                         size_type __n) const noexcept
N{
N    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, "string::find_first_of(): received nullptr");
X    ((void)0);
N    return __str_find_first_of<value_type, size_type, traits_type, npos>
N        (data(), size(), __s, __pos, __n);
N}
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const basic_string& __str,
N                                                         size_type __pos) const _NOEXCEPT
X                                                         size_type __pos) const noexcept
N{
N    return __str_find_first_of<value_type, size_type, traits_type, npos>
N        (data(), size(), __str.data(), __pos, __str.size());
N}
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(__self_view __sv,
N                                                size_type __pos) const _NOEXCEPT
X                                                size_type __pos) const noexcept
N{
N    return __str_find_first_of<value_type, size_type, traits_type, npos>
N        (data(), size(), __sv.data(), __pos, __sv.size());
N}
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,
N                                                         size_type __pos) const _NOEXCEPT
X                                                         size_type __pos) const noexcept
N{
N    _LIBCPP_ASSERT(__s != nullptr, "string::find_first_of(): received nullptr");
X    ((void)0);
N    return __str_find_first_of<value_type, size_type, traits_type, npos>
N        (data(), size(), __s, __pos, traits_type::length(__s));
N}
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(value_type __c,
N                                                         size_type __pos) const _NOEXCEPT
X                                                         size_type __pos) const noexcept
N{
N    return find(__c, __pos);
N}
N
N// find_last_of
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ntypename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,
N                                                        size_type __pos,
N                                                        size_type __n) const _NOEXCEPT
X                                                        size_type __n) const noexcept
N{
N    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, "string::find_last_of(): received nullptr");
X    ((void)0);
N    return __str_find_last_of<value_type, size_type, traits_type, npos>
N        (data(), size(), __s, __pos, __n);
N}
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const basic_string& __str,
N                                                        size_type __pos) const _NOEXCEPT
X                                                        size_type __pos) const noexcept
N{
N    return __str_find_last_of<value_type, size_type, traits_type, npos>
N        (data(), size(), __str.data(), __pos, __str.size());
N}
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(__self_view __sv,
N                                                size_type __pos) const _NOEXCEPT
X                                                size_type __pos) const noexcept
N{
N    return __str_find_last_of<value_type, size_type, traits_type, npos>
N        (data(), size(), __sv.data(), __pos, __sv.size());
N}
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,
N                                                        size_type __pos) const _NOEXCEPT
X                                                        size_type __pos) const noexcept
N{
N    _LIBCPP_ASSERT(__s != nullptr, "string::find_last_of(): received nullptr");
X    ((void)0);
N    return __str_find_last_of<value_type, size_type, traits_type, npos>
N        (data(), size(), __s, __pos, traits_type::length(__s));
N}
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(value_type __c,
N                                                        size_type __pos) const _NOEXCEPT
X                                                        size_type __pos) const noexcept
N{
N    return rfind(__c, __pos);
N}
N
N// find_first_not_of
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ntypename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,
N                                                             size_type __pos,
N                                                             size_type __n) const _NOEXCEPT
X                                                             size_type __n) const noexcept
N{
N    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, "string::find_first_not_of(): received nullptr");
X    ((void)0);
N    return __str_find_first_not_of<value_type, size_type, traits_type, npos>
N        (data(), size(), __s, __pos, __n);
N}
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const basic_string& __str,
N                                                             size_type __pos) const _NOEXCEPT
X                                                             size_type __pos) const noexcept
N{
N    return __str_find_first_not_of<value_type, size_type, traits_type, npos>
N        (data(), size(), __str.data(), __pos, __str.size());
N}
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(__self_view __sv,
N                                                size_type __pos) const _NOEXCEPT
X                                                size_type __pos) const noexcept
N{
N    return __str_find_first_not_of<value_type, size_type, traits_type, npos>
N        (data(), size(), __sv.data(), __pos, __sv.size());
N}
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,
N                                                             size_type __pos) const _NOEXCEPT
X                                                             size_type __pos) const noexcept
N{
N    _LIBCPP_ASSERT(__s != nullptr, "string::find_first_not_of(): received nullptr");
X    ((void)0);
N    return __str_find_first_not_of<value_type, size_type, traits_type, npos>
N        (data(), size(), __s, __pos, traits_type::length(__s));
N}
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(value_type __c,
N                                                             size_type __pos) const _NOEXCEPT
X                                                             size_type __pos) const noexcept
N{
N    return __str_find_first_not_of<value_type, size_type, traits_type, npos>
N        (data(), size(), __c, __pos);
N}
N
N// find_last_not_of
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ntypename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,
N                                                            size_type __pos,
N                                                            size_type __n) const _NOEXCEPT
X                                                            size_type __n) const noexcept
N{
N    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, "string::find_last_not_of(): received nullptr");
X    ((void)0);
N    return __str_find_last_not_of<value_type, size_type, traits_type, npos>
N        (data(), size(), __s, __pos, __n);
N}
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const basic_string& __str,
N                                                            size_type __pos) const _NOEXCEPT
X                                                            size_type __pos) const noexcept
N{
N    return __str_find_last_not_of<value_type, size_type, traits_type, npos>
N        (data(), size(), __str.data(), __pos, __str.size());
N}
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(__self_view __sv,
N                                                size_type __pos) const _NOEXCEPT
X                                                size_type __pos) const noexcept
N{
N    return __str_find_last_not_of<value_type, size_type, traits_type, npos>
N        (data(), size(), __sv.data(), __pos, __sv.size());
N}
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,
N                                                            size_type __pos) const _NOEXCEPT
X                                                            size_type __pos) const noexcept
N{
N    _LIBCPP_ASSERT(__s != nullptr, "string::find_last_not_of(): received nullptr");
X    ((void)0);
N    return __str_find_last_not_of<value_type, size_type, traits_type, npos>
N        (data(), size(), __s, __pos, traits_type::length(__s));
N}
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(value_type __c,
N                                                            size_type __pos) const _NOEXCEPT
X                                                            size_type __pos) const noexcept
N{
N    return __str_find_last_not_of<value_type, size_type, traits_type, npos>
N        (data(), size(), __c, __pos);
N}
N
N// compare
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nint
Nbasic_string<_CharT, _Traits, _Allocator>::compare(__self_view __sv) const _NOEXCEPT
Xbasic_string<_CharT, _Traits, _Allocator>::compare(__self_view __sv) const noexcept
N{
N    size_t __lhs_sz = size();
N    size_t __rhs_sz = __sv.size();
N    int __result = traits_type::compare(data(), __sv.data(),
N                                        _VSTD::min(__lhs_sz, __rhs_sz));
X                                        std::__2::min(__lhs_sz, __rhs_sz));
N    if (__result != 0)
N        return __result;
N    if (__lhs_sz < __rhs_sz)
N        return -1;
N    if (__lhs_sz > __rhs_sz)
N        return 1;
N    return 0;
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nint
Nbasic_string<_CharT, _Traits, _Allocator>::compare(const basic_string& __str) const _NOEXCEPT
Xbasic_string<_CharT, _Traits, _Allocator>::compare(const basic_string& __str) const noexcept
N{
N    return compare(__self_view(__str));
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nint
Nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
N                                                   size_type __n1,
N                                                   const value_type* __s,
N                                                   size_type __n2) const
N{
N    _LIBCPP_ASSERT(__n2 == 0 || __s != nullptr, "string::compare(): received nullptr");
X    ((void)0);
N    size_type __sz = size();
N    if (__pos1 > __sz || __n2 == npos)
N        this->__throw_out_of_range();
N    size_type __rlen = _VSTD::min(__n1, __sz - __pos1);
X    size_type __rlen = std::__2::min(__n1, __sz - __pos1);
N    int __r = traits_type::compare(data() + __pos1, __s, _VSTD::min(__rlen, __n2));
X    int __r = traits_type::compare(data() + __pos1, __s, std::__2::min(__rlen, __n2));
N    if (__r == 0)
N    {
N        if (__rlen < __n2)
N            __r = -1;
N        else if (__rlen > __n2)
N            __r = 1;
N    }
N    return __r;
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nint
Nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
N                                                   size_type __n1,
N                                                   __self_view __sv) const
N{
N    return compare(__pos1, __n1, __sv.data(), __sv.size());
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nint
Nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
N                                                   size_type __n1,
N                                                   const basic_string& __str) const
N{
N    return compare(__pos1, __n1, __str.data(), __str.size());
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ntemplate <class _Tp>
Ntypename enable_if
N<
N	__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
N	int
N>::type
Nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
N                                                   size_type __n1,
N                                                   const _Tp& __t,
N                                                   size_type __pos2,
N                                                   size_type __n2) const
N{
N    __self_view __sv = __t;
N    return __self_view(*this).substr(__pos1, __n1).compare(__sv.substr(__pos2, __n2));
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nint
Nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
N                                                   size_type __n1,
N                                                   const basic_string& __str,
N                                                   size_type __pos2,
N                                                   size_type __n2) const
N{
N        return compare(__pos1, __n1, __self_view(__str), __pos2, __n2);
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nint
Nbasic_string<_CharT, _Traits, _Allocator>::compare(const value_type* __s) const _NOEXCEPT
Xbasic_string<_CharT, _Traits, _Allocator>::compare(const value_type* __s) const noexcept
N{
N    _LIBCPP_ASSERT(__s != nullptr, "string::compare(): received nullptr");
X    ((void)0);
N    return compare(0, npos, __s, traits_type::length(__s));
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nint
Nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
N                                                   size_type __n1,
N                                                   const value_type* __s) const
N{
N    _LIBCPP_ASSERT(__s != nullptr, "string::compare(): received nullptr");
X    ((void)0);
N    return compare(__pos1, __n1, __s, traits_type::length(__s));
N}
N
N// __invariants
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Nbasic_string<_CharT, _Traits, _Allocator>::__invariants() const
N{
N    if (size() > capacity())
N        return false;
N    if (capacity() < __min_cap - 1)
N        return false;
N    if (data() == 0)
N        return false;
N    if (data()[size()] != value_type(0))
N        return false;
N    return true;
N}
N
N// operator==
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator==(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
N           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT
X           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
N{
N    size_t __lhs_sz = __lhs.size();
N    return __lhs_sz == __rhs.size() && _Traits::compare(__lhs.data(),
N                                                        __rhs.data(),
N                                                        __lhs_sz) == 0;
N}
N
Ntemplate<class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator==(const basic_string<char, char_traits<char>, _Allocator>& __lhs,
N           const basic_string<char, char_traits<char>, _Allocator>& __rhs) _NOEXCEPT
X           const basic_string<char, char_traits<char>, _Allocator>& __rhs) noexcept
N{
N    size_t __lhs_sz = __lhs.size();
N    if (__lhs_sz != __rhs.size())
N        return false;
N    const char* __lp = __lhs.data();
N    const char* __rp = __rhs.data();
N    if (__lhs.__is_long())
N        return char_traits<char>::compare(__lp, __rp, __lhs_sz) == 0;
N    for (; __lhs_sz != 0; --__lhs_sz, ++__lp, ++__rp)
N        if (*__lp != *__rp)
N            return false;
N    return true;
N}
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator==(const _CharT* __lhs,
N           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT
X           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
N{
N    typedef basic_string<_CharT, _Traits, _Allocator> _String;
N    _LIBCPP_ASSERT(__lhs != nullptr, "operator==(char*, basic_string): received nullptr");
X    ((void)0);
N    size_t __lhs_len = _Traits::length(__lhs);
N    if (__lhs_len != __rhs.size()) return false;
N    return __rhs.compare(0, _String::npos, __lhs, __lhs_len) == 0;
N}
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator==(const basic_string<_CharT,_Traits,_Allocator>& __lhs,
N           const _CharT* __rhs) _NOEXCEPT
X           const _CharT* __rhs) noexcept
N{
N    typedef basic_string<_CharT, _Traits, _Allocator> _String;
N    _LIBCPP_ASSERT(__rhs != nullptr, "operator==(basic_string, char*): received nullptr");
X    ((void)0);
N    size_t __rhs_len = _Traits::length(__rhs);
N    if (__rhs_len != __lhs.size()) return false;
N    return __lhs.compare(0, _String::npos, __rhs, __rhs_len) == 0;
N}
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator!=(const basic_string<_CharT,_Traits,_Allocator>& __lhs,
N           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT
X           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
N{
N    return !(__lhs == __rhs);
N}
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator!=(const _CharT* __lhs,
N           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT
X           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
N{
N    return !(__lhs == __rhs);
N}
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator!=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
N           const _CharT* __rhs) _NOEXCEPT
X           const _CharT* __rhs) noexcept
N{
N    return !(__lhs == __rhs);
N}
N
N// operator<
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
N           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT
X           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
N{
N    return __lhs.compare(__rhs) < 0;
N}
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
N           const _CharT* __rhs) _NOEXCEPT
X           const _CharT* __rhs) noexcept
N{
N    return __lhs.compare(__rhs) < 0;
N}
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator< (const _CharT* __lhs,
N           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT
X           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
N{
N    return __rhs.compare(__lhs) > 0;
N}
N
N// operator>
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
N           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT
X           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
N{
N    return __rhs < __lhs;
N}
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
N           const _CharT* __rhs) _NOEXCEPT
X           const _CharT* __rhs) noexcept
N{
N    return __rhs < __lhs;
N}
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator> (const _CharT* __lhs,
N           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT
X           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
N{
N    return __rhs < __lhs;
N}
N
N// operator<=
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
N           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT
X           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
N{
N    return !(__rhs < __lhs);
N}
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
N           const _CharT* __rhs) _NOEXCEPT
X           const _CharT* __rhs) noexcept
N{
N    return !(__rhs < __lhs);
N}
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator<=(const _CharT* __lhs,
N           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT
X           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
N{
N    return !(__rhs < __lhs);
N}
N
N// operator>=
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
N           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT
X           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
N{
N    return !(__lhs < __rhs);
N}
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
N           const _CharT* __rhs) _NOEXCEPT
X           const _CharT* __rhs) noexcept
N{
N    return !(__lhs < __rhs);
N}
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator>=(const _CharT* __lhs,
N           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT
X           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
N{
N    return !(__lhs < __rhs);
N}
N
N// operator +
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>
Noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
N          const basic_string<_CharT, _Traits, _Allocator>& __rhs)
N{
N    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());
N    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();
N    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();
N    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);
N    __r.append(__rhs.data(), __rhs_sz);
N    return __r;
N}
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>
Noperator+(const _CharT* __lhs , const basic_string<_CharT,_Traits,_Allocator>& __rhs)
N{
N    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());
N    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = _Traits::length(__lhs);
N    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();
N    __r.__init(__lhs, __lhs_sz, __lhs_sz + __rhs_sz);
N    __r.append(__rhs.data(), __rhs_sz);
N    return __r;
N}
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>
Noperator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Allocator>& __rhs)
N{
N    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());
N    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();
N    __r.__init(&__lhs, 1, 1 + __rhs_sz);
N    __r.append(__rhs.data(), __rhs_sz);
N    return __r;
N}
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>
Noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, const _CharT* __rhs)
N{
N    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());
N    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();
N    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = _Traits::length(__rhs);
N    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);
N    __r.append(__rhs, __rhs_sz);
N    return __r;
N}
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>
Noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, _CharT __rhs)
N{
N    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());
N    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();
N    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + 1);
N    __r.push_back(__rhs);
N    return __r;
N}
N
N#ifndef _LIBCPP_CXX03_LANG
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbasic_string<_CharT, _Traits, _Allocator>
Noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const basic_string<_CharT, _Traits, _Allocator>& __rhs)
N{
N    return _VSTD::move(__lhs.append(__rhs));
X    return std::__2::move(__lhs.append(__rhs));
N}
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbasic_string<_CharT, _Traits, _Allocator>
Noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)
N{
N    return _VSTD::move(__rhs.insert(0, __lhs));
X    return std::__2::move(__rhs.insert(0, __lhs));
N}
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbasic_string<_CharT, _Traits, _Allocator>
Noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)
N{
N    return _VSTD::move(__lhs.append(__rhs));
X    return std::__2::move(__lhs.append(__rhs));
N}
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbasic_string<_CharT, _Traits, _Allocator>
Noperator+(const _CharT* __lhs , basic_string<_CharT,_Traits,_Allocator>&& __rhs)
N{
N    return _VSTD::move(__rhs.insert(0, __lhs));
X    return std::__2::move(__rhs.insert(0, __lhs));
N}
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbasic_string<_CharT, _Traits, _Allocator>
Noperator+(_CharT __lhs, basic_string<_CharT,_Traits,_Allocator>&& __rhs)
N{
N    __rhs.insert(__rhs.begin(), __lhs);
N    return _VSTD::move(__rhs);
X    return std::__2::move(__rhs);
N}
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbasic_string<_CharT, _Traits, _Allocator>
Noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const _CharT* __rhs)
N{
N    return _VSTD::move(__lhs.append(__rhs));
X    return std::__2::move(__lhs.append(__rhs));
N}
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbasic_string<_CharT, _Traits, _Allocator>
Noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, _CharT __rhs)
N{
N    __lhs.push_back(__rhs);
N    return _VSTD::move(__lhs);
X    return std::__2::move(__lhs);
N}
N
N#endif  // _LIBCPP_CXX03_LANG
N
N// swap
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Nswap(basic_string<_CharT, _Traits, _Allocator>& __lhs,
N     basic_string<_CharT, _Traits, _Allocator>& __rhs)
N     _NOEXCEPT_(_NOEXCEPT_(__lhs.swap(__rhs)))
X     noexcept(noexcept(__lhs . swap(__rhs)))
N{
N    __lhs.swap(__rhs);
N}
N
N#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
N
Ntypedef basic_string<char16_t> u16string;
Ntypedef basic_string<char32_t> u32string;
N
N#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS
N
N_LIBCPP_FUNC_VIS int                stoi  (const string& __str, size_t* __idx = 0, int __base = 10);
X int                stoi  (const string& __str, size_t* __idx = 0, int __base = 10);
N_LIBCPP_FUNC_VIS long               stol  (const string& __str, size_t* __idx = 0, int __base = 10);
X long               stol  (const string& __str, size_t* __idx = 0, int __base = 10);
N_LIBCPP_FUNC_VIS unsigned long      stoul (const string& __str, size_t* __idx = 0, int __base = 10);
X unsigned long      stoul (const string& __str, size_t* __idx = 0, int __base = 10);
N_LIBCPP_FUNC_VIS long long          stoll (const string& __str, size_t* __idx = 0, int __base = 10);
X long long          stoll (const string& __str, size_t* __idx = 0, int __base = 10);
N_LIBCPP_FUNC_VIS unsigned long long stoull(const string& __str, size_t* __idx = 0, int __base = 10);
X unsigned long long stoull(const string& __str, size_t* __idx = 0, int __base = 10);
N
N_LIBCPP_FUNC_VIS float       stof (const string& __str, size_t* __idx = 0);
X float       stof (const string& __str, size_t* __idx = 0);
N_LIBCPP_FUNC_VIS double      stod (const string& __str, size_t* __idx = 0);
X double      stod (const string& __str, size_t* __idx = 0);
N_LIBCPP_FUNC_VIS long double stold(const string& __str, size_t* __idx = 0);
X long double stold(const string& __str, size_t* __idx = 0);
N
N_LIBCPP_FUNC_VIS string to_string(int __val);
X string to_string(int __val);
N_LIBCPP_FUNC_VIS string to_string(unsigned __val);
X string to_string(unsigned __val);
N_LIBCPP_FUNC_VIS string to_string(long __val);
X string to_string(long __val);
N_LIBCPP_FUNC_VIS string to_string(unsigned long __val);
X string to_string(unsigned long __val);
N_LIBCPP_FUNC_VIS string to_string(long long __val);
X string to_string(long long __val);
N_LIBCPP_FUNC_VIS string to_string(unsigned long long __val);
X string to_string(unsigned long long __val);
N_LIBCPP_FUNC_VIS string to_string(float __val);
X string to_string(float __val);
N_LIBCPP_FUNC_VIS string to_string(double __val);
X string to_string(double __val);
N_LIBCPP_FUNC_VIS string to_string(long double __val);
X string to_string(long double __val);
N
N_LIBCPP_FUNC_VIS int                stoi  (const wstring& __str, size_t* __idx = 0, int __base = 10);
X int                stoi  (const wstring& __str, size_t* __idx = 0, int __base = 10);
N_LIBCPP_FUNC_VIS long               stol  (const wstring& __str, size_t* __idx = 0, int __base = 10);
X long               stol  (const wstring& __str, size_t* __idx = 0, int __base = 10);
N_LIBCPP_FUNC_VIS unsigned long      stoul (const wstring& __str, size_t* __idx = 0, int __base = 10);
X unsigned long      stoul (const wstring& __str, size_t* __idx = 0, int __base = 10);
N_LIBCPP_FUNC_VIS long long          stoll (const wstring& __str, size_t* __idx = 0, int __base = 10);
X long long          stoll (const wstring& __str, size_t* __idx = 0, int __base = 10);
N_LIBCPP_FUNC_VIS unsigned long long stoull(const wstring& __str, size_t* __idx = 0, int __base = 10);
X unsigned long long stoull(const wstring& __str, size_t* __idx = 0, int __base = 10);
N
N_LIBCPP_FUNC_VIS float       stof (const wstring& __str, size_t* __idx = 0);
X float       stof (const wstring& __str, size_t* __idx = 0);
N_LIBCPP_FUNC_VIS double      stod (const wstring& __str, size_t* __idx = 0);
X double      stod (const wstring& __str, size_t* __idx = 0);
N_LIBCPP_FUNC_VIS long double stold(const wstring& __str, size_t* __idx = 0);
X long double stold(const wstring& __str, size_t* __idx = 0);
N
N_LIBCPP_FUNC_VIS wstring to_wstring(int __val);
X wstring to_wstring(int __val);
N_LIBCPP_FUNC_VIS wstring to_wstring(unsigned __val);
X wstring to_wstring(unsigned __val);
N_LIBCPP_FUNC_VIS wstring to_wstring(long __val);
X wstring to_wstring(long __val);
N_LIBCPP_FUNC_VIS wstring to_wstring(unsigned long __val);
X wstring to_wstring(unsigned long __val);
N_LIBCPP_FUNC_VIS wstring to_wstring(long long __val);
X wstring to_wstring(long long __val);
N_LIBCPP_FUNC_VIS wstring to_wstring(unsigned long long __val);
X wstring to_wstring(unsigned long long __val);
N_LIBCPP_FUNC_VIS wstring to_wstring(float __val);
X wstring to_wstring(float __val);
N_LIBCPP_FUNC_VIS wstring to_wstring(double __val);
X wstring to_wstring(double __val);
N_LIBCPP_FUNC_VIS wstring to_wstring(long double __val);
X wstring to_wstring(long double __val);
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
N    const typename basic_string<_CharT, _Traits, _Allocator>::size_type
N                   basic_string<_CharT, _Traits, _Allocator>::npos;
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Nstruct _LIBCPP_TEMPLATE_VIS hash<basic_string<_CharT, _Traits, _Allocator> >
Xstruct  hash<basic_string<_CharT, _Traits, _Allocator> >
N    : public unary_function<basic_string<_CharT, _Traits, _Allocator>, size_t>
N{
N    size_t
N        operator()(const basic_string<_CharT, _Traits, _Allocator>& __val) const _NOEXCEPT;
X        operator()(const basic_string<_CharT, _Traits, _Allocator>& __val) const noexcept;
N};
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Nsize_t
Nhash<basic_string<_CharT, _Traits, _Allocator> >::operator()(
N        const basic_string<_CharT, _Traits, _Allocator>& __val) const _NOEXCEPT
X        const basic_string<_CharT, _Traits, _Allocator>& __val) const noexcept
N{
N    return __do_string_hash(__val.data(), __val.data() + __val.size());
N}
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Nbasic_ostream<_CharT, _Traits>&
Noperator<<(basic_ostream<_CharT, _Traits>& __os,
N           const basic_string<_CharT, _Traits, _Allocator>& __str);
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Nbasic_istream<_CharT, _Traits>&
Noperator>>(basic_istream<_CharT, _Traits>& __is,
N           basic_string<_CharT, _Traits, _Allocator>& __str);
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Nbasic_istream<_CharT, _Traits>&
Ngetline(basic_istream<_CharT, _Traits>& __is,
N        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbasic_istream<_CharT, _Traits>&
Ngetline(basic_istream<_CharT, _Traits>& __is,
N        basic_string<_CharT, _Traits, _Allocator>& __str);
N
N#ifndef _LIBCPP_CXX03_LANG
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbasic_istream<_CharT, _Traits>&
Ngetline(basic_istream<_CharT, _Traits>&& __is,
N        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbasic_istream<_CharT, _Traits>&
Ngetline(basic_istream<_CharT, _Traits>&& __is,
N        basic_string<_CharT, _Traits, _Allocator>& __str);
N
N#endif  // _LIBCPP_CXX03_LANG
N
N#if _LIBCPP_DEBUG_LEVEL >= 2
S
Stemplate<class _CharT, class _Traits, class _Allocator>
Sbool
Sbasic_string<_CharT, _Traits, _Allocator>::__dereferenceable(const const_iterator* __i) const
S{
S    return this->data() <= _VSTD::__to_raw_pointer(__i->base()) &&
S           _VSTD::__to_raw_pointer(__i->base()) < this->data() + this->size();
S}
S
Stemplate<class _CharT, class _Traits, class _Allocator>
Sbool
Sbasic_string<_CharT, _Traits, _Allocator>::__decrementable(const const_iterator* __i) const
S{
S    return this->data() < _VSTD::__to_raw_pointer(__i->base()) &&
S           _VSTD::__to_raw_pointer(__i->base()) <= this->data() + this->size();
S}
S
Stemplate<class _CharT, class _Traits, class _Allocator>
Sbool
Sbasic_string<_CharT, _Traits, _Allocator>::__addable(const const_iterator* __i, ptrdiff_t __n) const
S{
S    const value_type* __p = _VSTD::__to_raw_pointer(__i->base()) + __n;
S    return this->data() <= __p && __p <= this->data() + this->size();
S}
S
Stemplate<class _CharT, class _Traits, class _Allocator>
Sbool
Sbasic_string<_CharT, _Traits, _Allocator>::__subscriptable(const const_iterator* __i, ptrdiff_t __n) const
S{
S    const value_type* __p = _VSTD::__to_raw_pointer(__i->base()) + __n;
S    return this->data() <= __p && __p < this->data() + this->size();
S}
S
N#endif  // _LIBCPP_DEBUG_LEVEL >= 2
N
N_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_string<char>)
Xextern template class basic_string<char>;
N_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_string<wchar_t>)
Xextern template class basic_string<wchar_t>;
N
N#if _LIBCPP_STD_VER > 11 
X#if 14 > 11 
N// Literal suffixes for basic_string [basic.string.literals]
Ninline namespace literals
N{
N  inline namespace string_literals
N  {
N    inline _LIBCPP_INLINE_VISIBILITY
X    inline __attribute__ ((__always_inline__))
N    basic_string<char> operator "" s( const char *__str, size_t __len )
N    {
N        return basic_string<char> (__str, __len);
N    }
N
N    inline _LIBCPP_INLINE_VISIBILITY
X    inline __attribute__ ((__always_inline__))
N    basic_string<wchar_t> operator "" s( const wchar_t *__str, size_t __len )
N    {
N        return basic_string<wchar_t> (__str, __len);
N    }
N
N    inline _LIBCPP_INLINE_VISIBILITY
X    inline __attribute__ ((__always_inline__))
N    basic_string<char16_t> operator "" s( const char16_t *__str, size_t __len )
N    {
N        return basic_string<char16_t> (__str, __len);
N    }
N
N    inline _LIBCPP_INLINE_VISIBILITY
X    inline __attribute__ ((__always_inline__))
N    basic_string<char32_t> operator "" s( const char32_t *__str, size_t __len )
N    {
N        return basic_string<char32_t> (__str, __len);
N    }
N  }
N}
N#endif
N
N_LIBCPP_END_NAMESPACE_STD
X} }
N
N_LIBCPP_POP_MACROS
X_Pragma("pop_macro(\"min\")") _Pragma("pop_macro(\"max\")")
N
N#endif  // _LIBCPP_STRING
L 12 "..\PID.h" 2
N#include <sstream>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/sstream" 1
N// -*- C++ -*-
N//===--------------------------- sstream ----------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is dual licensed under the MIT and the University of Illinois Open
N// Source Licenses. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP_SSTREAM
N#define _LIBCPP_SSTREAM
N
N/*
N    sstream synopsis
N
Ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >
Nclass basic_stringbuf
N    : public basic_streambuf<charT, traits>
N{
Npublic:
N    typedef charT                          char_type;
N    typedef traits                         traits_type;
N    typedef typename traits_type::int_type int_type;
N    typedef typename traits_type::pos_type pos_type;
N    typedef typename traits_type::off_type off_type;
N    typedef Allocator                      allocator_type;
N
N    // 27.8.1.1 Constructors:
N    explicit basic_stringbuf(ios_base::openmode which = ios_base::in | ios_base::out);
N    explicit basic_stringbuf(const basic_string<char_type, traits_type, allocator_type>& str,
N                             ios_base::openmode which = ios_base::in | ios_base::out);
N    basic_stringbuf(basic_stringbuf&& rhs);
N
N    // 27.8.1.2 Assign and swap:
N    basic_stringbuf& operator=(basic_stringbuf&& rhs);
N    void swap(basic_stringbuf& rhs);
N
N    // 27.8.1.3 Get and set:
N    basic_string<char_type, traits_type, allocator_type> str() const;
N    void str(const basic_string<char_type, traits_type, allocator_type>& s);
N
Nprotected:
N    // 27.8.1.4 Overridden virtual functions:
N    virtual int_type underflow();
N    virtual int_type pbackfail(int_type c = traits_type::eof());
N    virtual int_type overflow (int_type c = traits_type::eof());
N    virtual basic_streambuf<char_type, traits_type>* setbuf(char_type*, streamsize);
N    virtual pos_type seekoff(off_type off, ios_base::seekdir way,
N                             ios_base::openmode which = ios_base::in | ios_base::out);
N    virtual pos_type seekpos(pos_type sp,
N                             ios_base::openmode which = ios_base::in | ios_base::out);
N};
N
Ntemplate <class charT, class traits, class Allocator>
N  void swap(basic_stringbuf<charT, traits, Allocator>& x,
N            basic_stringbuf<charT, traits, Allocator>& y);
N
Ntypedef basic_stringbuf<char>    stringbuf;
Ntypedef basic_stringbuf<wchar_t> wstringbuf;
N
Ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >
Nclass basic_istringstream
N    : public basic_istream<charT, traits>
N{
Npublic:
N    typedef charT                          char_type;
N    typedef traits                         traits_type;
N    typedef typename traits_type::int_type int_type;
N    typedef typename traits_type::pos_type pos_type;
N    typedef typename traits_type::off_type off_type;
N    typedef Allocator                      allocator_type;
N
N    // 27.8.2.1 Constructors:
N    explicit basic_istringstream(ios_base::openmode which = ios_base::in);
N    explicit basic_istringstream(const basic_string<char_type, traits_type,allocator_type>& str,
N                                 ios_base::openmode which = ios_base::in);
N    basic_istringstream(basic_istringstream&& rhs);
N
N    // 27.8.2.2 Assign and swap:
N    basic_istringstream& operator=(basic_istringstream&& rhs);
N    void swap(basic_istringstream& rhs);
N
N    // 27.8.2.3 Members:
N    basic_stringbuf<char_type, traits_type, allocator_type>* rdbuf() const;
N    basic_string<char_type, traits_type, allocator_type> str() const;
N    void str(const basic_string<char_type, traits_type, allocator_type>& s);
N};
N
Ntemplate <class charT, class traits, class Allocator>
N  void swap(basic_istringstream<charT, traits, Allocator>& x,
N            basic_istringstream<charT, traits, Allocator>& y);
N
Ntypedef basic_istringstream<char>    istringstream;
Ntypedef basic_istringstream<wchar_t> wistringstream;
N
Ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >
Nclass basic_ostringstream
N    : public basic_ostream<charT, traits>
N{
Npublic:
N    // types:
N    typedef charT                          char_type;
N    typedef traits                         traits_type;
N    typedef typename traits_type::int_type int_type;
N    typedef typename traits_type::pos_type pos_type;
N    typedef typename traits_type::off_type off_type;
N    typedef Allocator                      allocator_type;
N
N    // 27.8.3.1 Constructors/destructor:
N    explicit basic_ostringstream(ios_base::openmode which = ios_base::out);
N    explicit basic_ostringstream(const basic_string<char_type, traits_type, allocator_type>& str,
N                                 ios_base::openmode which = ios_base::out);
N    basic_ostringstream(basic_ostringstream&& rhs);
N
N    // 27.8.3.2 Assign/swap:
N    basic_ostringstream& operator=(basic_ostringstream&& rhs);
N    void swap(basic_ostringstream& rhs);
N
N    // 27.8.3.3 Members:
N    basic_stringbuf<char_type, traits_type, allocator_type>* rdbuf() const;
N    basic_string<char_type, traits_type, allocator_type> str() const;
N    void str(const basic_string<char_type, traits_type, allocator_type>& s);
N};
N
Ntemplate <class charT, class traits, class Allocator>
N  void swap(basic_ostringstream<charT, traits, Allocator>& x,
N            basic_ostringstream<charT, traits, Allocator>& y);
N
Ntypedef basic_ostringstream<char>    ostringstream;
Ntypedef basic_ostringstream<wchar_t> wostringstream;
N
Ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >
Nclass basic_stringstream
N    : public basic_iostream<charT, traits>
N{
Npublic:
N    // types:
N    typedef charT                          char_type;
N    typedef traits                         traits_type;
N    typedef typename traits_type::int_type int_type;
N    typedef typename traits_type::pos_type pos_type;
N    typedef typename traits_type::off_type off_type;
N    typedef Allocator                      allocator_type;
N
N    // constructors/destructor
N    explicit basic_stringstream(ios_base::openmode which = ios_base::out|ios_base::in);
N    explicit basic_stringstream(const basic_string<char_type, traits_type, allocator_type>& str,
N                                ios_base::openmode which = ios_base::out|ios_base::in);
N    basic_stringstream(basic_stringstream&& rhs);
N
N    // 27.8.5.1 Assign/swap:
N    basic_stringstream& operator=(basic_stringstream&& rhs);
N    void swap(basic_stringstream& rhs);
N
N    // Members:
N    basic_stringbuf<char_type, traits_type, allocator_type>* rdbuf() const;
N    basic_string<char_type, traits_type, allocator_type> str() const;
N    void str(const basic_string<char_type, traits_type, allocator_type>& str);
N};
N
Ntemplate <class charT, class traits, class Allocator>
N  void swap(basic_stringstream<charT, traits, Allocator>& x,
N            basic_stringstream<charT, traits, Allocator>& y);
N
Ntypedef basic_stringstream<char>    stringstream;
Ntypedef basic_stringstream<wchar_t> wstringstream;
N
N}  // std
N
N*/
N
N#include <__config>
N#include <ostream>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/ostream" 1
N// -*- C++ -*-
N//===-------------------------- ostream -----------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is dual licensed under the MIT and the University of Illinois Open
N// Source Licenses. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP_OSTREAM
N#define _LIBCPP_OSTREAM
N
N/*
N    ostream synopsis
N
Ntemplate <class charT, class traits = char_traits<charT> >
Nclass basic_ostream
N    : virtual public basic_ios<charT,traits>
N{
Npublic:
N    // types (inherited from basic_ios (27.5.4)):
N    typedef charT                          char_type;
N    typedef traits                         traits_type;
N    typedef typename traits_type::int_type int_type;
N    typedef typename traits_type::pos_type pos_type;
N    typedef typename traits_type::off_type off_type;
N
N    // 27.7.2.2 Constructor/destructor:
N    explicit basic_ostream(basic_streambuf<char_type,traits>* sb);
N    basic_ostream(basic_ostream&& rhs);
N    virtual ~basic_ostream();
N
N    // 27.7.2.3 Assign/swap
N    basic_ostream& operator=(const basic_ostream& rhs) = delete; // C++14
N    basic_ostream& operator=(basic_ostream&& rhs);
N    void swap(basic_ostream& rhs);
N
N    // 27.7.2.4 Prefix/suffix:
N    class sentry;
N
N    // 27.7.2.6 Formatted output:
N    basic_ostream& operator<<(basic_ostream& (*pf)(basic_ostream&));
N    basic_ostream& operator<<(basic_ios<charT, traits>& (*pf)(basic_ios<charT,traits>&));
N    basic_ostream& operator<<(ios_base& (*pf)(ios_base&));
N    basic_ostream& operator<<(bool n);
N    basic_ostream& operator<<(short n);
N    basic_ostream& operator<<(unsigned short n);
N    basic_ostream& operator<<(int n);
N    basic_ostream& operator<<(unsigned int n);
N    basic_ostream& operator<<(long n);
N    basic_ostream& operator<<(unsigned long n);
N    basic_ostream& operator<<(long long n);
N    basic_ostream& operator<<(unsigned long long n);
N    basic_ostream& operator<<(float f);
N    basic_ostream& operator<<(double f);
N    basic_ostream& operator<<(long double f);
N    basic_ostream& operator<<(const void* p);
N    basic_ostream& operator<<(basic_streambuf<char_type,traits>* sb);
N
N    // 27.7.2.7 Unformatted output:
N    basic_ostream& put(char_type c);
N    basic_ostream& write(const char_type* s, streamsize n);
N    basic_ostream& flush();
N
N    // 27.7.2.5 seeks:
N    pos_type tellp();
N    basic_ostream& seekp(pos_type);
N    basic_ostream& seekp(off_type, ios_base::seekdir);
Nprotected:
N    basic_ostream(const basic_ostream& rhs) = delete;
N    basic_ostream(basic_ostream&& rhs);
N    // 27.7.3.3 Assign/swap
N    basic_ostream& operator=(basic_ostream& rhs) = delete;
N    basic_ostream& operator=(const basic_ostream&& rhs);
N    void swap(basic_ostream& rhs);
N};
N
N// 27.7.2.6.4 character inserters
N
Ntemplate<class charT, class traits>
N  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, charT);
N
Ntemplate<class charT, class traits>
N  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, char);
N
Ntemplate<class traits>
N  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, char);
N
N// signed and unsigned
N
Ntemplate<class traits>
N  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, signed char);
N
Ntemplate<class traits>
N  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, unsigned char);
N
N// NTBS
Ntemplate<class charT, class traits>
N  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, const charT*);
N
Ntemplate<class charT, class traits>
N  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, const char*);
N
Ntemplate<class traits>
N  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, const char*);
N
N// signed and unsigned
Ntemplate<class traits>
Nbasic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, const signed char*);
N
Ntemplate<class traits>
N  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, const unsigned char*);
N
N// swap:
Ntemplate <class charT, class traits>
N  void swap(basic_ostream<charT, traits>& x, basic_ostream<charT, traits>& y);
N
Ntemplate <class charT, class traits>
N  basic_ostream<charT,traits>& endl(basic_ostream<charT,traits>& os);
N
Ntemplate <class charT, class traits>
N  basic_ostream<charT,traits>& ends(basic_ostream<charT,traits>& os);
N
Ntemplate <class charT, class traits>
N  basic_ostream<charT,traits>& flush(basic_ostream<charT,traits>& os);
N
N// rvalue stream insertion
Ntemplate <class charT, class traits, class T>
N  basic_ostream<charT, traits>&
N  operator<<(basic_ostream<charT, traits>&& os, const T& x);
N
N}  // std
N
N*/
N
N#include <__config>
N#include <ios>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/ios" 1
N// -*- C++ -*-
N//===---------------------------- ios -------------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is dual licensed under the MIT and the University of Illinois Open
N// Source Licenses. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP_IOS
N#define _LIBCPP_IOS
N
N/*
N    ios synopsis
N
N#include <iosfwd>
N
Nnamespace std
N{
N
Ntypedef OFF_T streamoff;
Ntypedef SZ_T streamsize;
Ntemplate <class stateT> class fpos;
N
Nclass ios_base
N{
Npublic:
N    class failure;
N
N    typedef T1 fmtflags;
N    static constexpr fmtflags boolalpha;
N    static constexpr fmtflags dec;
N    static constexpr fmtflags fixed;
N    static constexpr fmtflags hex;
N    static constexpr fmtflags internal;
N    static constexpr fmtflags left;
N    static constexpr fmtflags oct;
N    static constexpr fmtflags right;
N    static constexpr fmtflags scientific;
N    static constexpr fmtflags showbase;
N    static constexpr fmtflags showpoint;
N    static constexpr fmtflags showpos;
N    static constexpr fmtflags skipws;
N    static constexpr fmtflags unitbuf;
N    static constexpr fmtflags uppercase;
N    static constexpr fmtflags adjustfield;
N    static constexpr fmtflags basefield;
N    static constexpr fmtflags floatfield;
N
N    typedef T2 iostate;
N    static constexpr iostate badbit;
N    static constexpr iostate eofbit;
N    static constexpr iostate failbit;
N    static constexpr iostate goodbit;
N
N    typedef T3 openmode;
N    static constexpr openmode app;
N    static constexpr openmode ate;
N    static constexpr openmode binary;
N    static constexpr openmode in;
N    static constexpr openmode out;
N    static constexpr openmode trunc;
N
N    typedef T4 seekdir;
N    static constexpr seekdir beg;
N    static constexpr seekdir cur;
N    static constexpr seekdir end;
N
N    class Init;
N
N    // 27.5.2.2 fmtflags state:
N    fmtflags flags() const;
N    fmtflags flags(fmtflags fmtfl);
N    fmtflags setf(fmtflags fmtfl);
N    fmtflags setf(fmtflags fmtfl, fmtflags mask);
N    void unsetf(fmtflags mask);
N
N    streamsize precision() const;
N    streamsize precision(streamsize prec);
N    streamsize width() const;
N    streamsize width(streamsize wide);
N
N    // 27.5.2.3 locales:
N    locale imbue(const locale& loc);
N    locale getloc() const;
N
N    // 27.5.2.5 storage:
N    static int xalloc();
N    long& iword(int index);
N    void*& pword(int index);
N
N    // destructor
N    virtual ~ios_base();
N
N    // 27.5.2.6 callbacks;
N    enum __attribute__((packed)) event { erase_event, imbue_event, copyfmt_event };
N    typedef void (*event_callback)(event, ios_base&, int index);
N    void register_callback(event_callback fn, int index);
N
N    ios_base(const ios_base&) = delete;
N    ios_base& operator=(const ios_base&) = delete;
N
N    static bool sync_with_stdio(bool sync = true);
N
Nprotected:
N    ios_base();
N};
N
Ntemplate <class charT, class traits = char_traits<charT> >
Nclass basic_ios
N    : public ios_base
N{
Npublic:
N    // types:
N    typedef charT char_type;
N    typedef typename traits::int_type int_type;  // removed in C++17
N    typedef typename traits::pos_type pos_type;  // removed in C++17
N    typedef typename traits::off_type off_type;  // removed in C++17
N    typedef traits traits_type;
N
N    operator unspecified-bool-type() const;
N    bool operator!() const;
N    iostate rdstate() const;
N    void clear(iostate state = goodbit);
N    void setstate(iostate state);
N    bool good() const;
N    bool eof() const;
N    bool fail() const;
N    bool bad() const;
N
N    iostate exceptions() const;
N    void exceptions(iostate except);
N
N    // 27.5.4.1 Constructor/destructor:
N    explicit basic_ios(basic_streambuf<charT,traits>* sb);
N    virtual ~basic_ios();
N
N    // 27.5.4.2 Members:
N    basic_ostream<charT,traits>* tie() const;
N    basic_ostream<charT,traits>* tie(basic_ostream<charT,traits>* tiestr);
N
N    basic_streambuf<charT,traits>* rdbuf() const;
N    basic_streambuf<charT,traits>* rdbuf(basic_streambuf<charT,traits>* sb);
N
N    basic_ios& copyfmt(const basic_ios& rhs);
N
N    char_type fill() const;
N    char_type fill(char_type ch);
N
N    locale imbue(const locale& loc);
N
N    char narrow(char_type c, char dfault) const;
N    char_type widen(char c) const;
N
N    basic_ios(const basic_ios& ) = delete;
N    basic_ios& operator=(const basic_ios&) = delete;
N
Nprotected:
N    basic_ios();
N    void init(basic_streambuf<charT,traits>* sb);
N    void move(basic_ios& rhs);
N    void swap(basic_ios& rhs) noexcept;
N    void set_rdbuf(basic_streambuf<charT, traits>* sb);
N};
N
N// 27.5.5, manipulators:
Nios_base& boolalpha (ios_base& str);
Nios_base& noboolalpha(ios_base& str);
Nios_base& showbase (ios_base& str);
Nios_base& noshowbase (ios_base& str);
Nios_base& showpoint (ios_base& str);
Nios_base& noshowpoint(ios_base& str);
Nios_base& showpos (ios_base& str);
Nios_base& noshowpos (ios_base& str);
Nios_base& skipws (ios_base& str);
Nios_base& noskipws (ios_base& str);
Nios_base& uppercase (ios_base& str);
Nios_base& nouppercase(ios_base& str);
Nios_base& unitbuf (ios_base& str);
Nios_base& nounitbuf (ios_base& str);
N
N// 27.5.5.2 adjustfield:
Nios_base& internal (ios_base& str);
Nios_base& left (ios_base& str);
Nios_base& right (ios_base& str);
N
N// 27.5.5.3 basefield:
Nios_base& dec (ios_base& str);
Nios_base& hex (ios_base& str);
Nios_base& oct (ios_base& str);
N
N// 27.5.5.4 floatfield:
Nios_base& fixed (ios_base& str);
Nios_base& scientific (ios_base& str);
Nios_base& hexfloat (ios_base& str);
Nios_base& defaultfloat(ios_base& str);
N
N// 27.5.5.5 error reporting:
Nenum class io_errc
N{
N    stream = 1
N};
N
Nconcept_map ErrorCodeEnum<io_errc> { };
Nerror_code make_error_code(io_errc e) noexcept; 
Nerror_condition make_error_condition(io_errc e) noexcept; 
Nstorage-class-specifier const error_category& iostream_category() noexcept;
N
N}  // std
N
N*/
N
N#include <__config>
N#include <iosfwd>
N#include <__locale>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/__locale" 1
N// -*- C++ -*-
N//===----------------------------------------------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is dual licensed under the MIT and the University of Illinois Open
N// Source Licenses. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP___LOCALE
N#define _LIBCPP___LOCALE
N
N#include <__config>
N#include <string>
N#include <memory>
N#include <utility>
N#include <mutex>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/mutex" 1
N// -*- C++ -*-
N//===--------------------------- mutex ------------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is dual licensed under the MIT and the University of Illinois Open
N// Source Licenses. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP_MUTEX
N#define _LIBCPP_MUTEX
N
N/*
N    mutex synopsis
N
Nnamespace std
N{
N
Nclass mutex
N{
Npublic:
N     constexpr mutex() noexcept;
N     ~mutex();
N
N    mutex(const mutex&) = delete;
N    mutex& operator=(const mutex&) = delete;
N
N    void lock();
N    bool try_lock();
N    void unlock();
N
N    typedef pthread_mutex_t* native_handle_type;
N    native_handle_type native_handle();
N};
N
Nclass recursive_mutex
N{
Npublic:
N     recursive_mutex();
N     ~recursive_mutex();
N
N    recursive_mutex(const recursive_mutex&) = delete;
N    recursive_mutex& operator=(const recursive_mutex&) = delete;
N
N    void lock();
N    bool try_lock() noexcept;
N    void unlock();
N
N    typedef pthread_mutex_t* native_handle_type;
N    native_handle_type native_handle();
N};
N
Nclass timed_mutex
N{
Npublic:
N     timed_mutex();
N     ~timed_mutex();
N
N    timed_mutex(const timed_mutex&) = delete;
N    timed_mutex& operator=(const timed_mutex&) = delete;
N
N    void lock();
N    bool try_lock();
N    template <class Rep, class Period>
N        bool try_lock_for(const chrono::duration<Rep, Period>& rel_time);
N    template <class Clock, class Duration>
N        bool try_lock_until(const chrono::time_point<Clock, Duration>& abs_time);
N    void unlock();
N};
N
Nclass recursive_timed_mutex
N{
Npublic:
N     recursive_timed_mutex();
N     ~recursive_timed_mutex();
N
N    recursive_timed_mutex(const recursive_timed_mutex&) = delete;
N    recursive_timed_mutex& operator=(const recursive_timed_mutex&) = delete;
N
N    void lock();
N    bool try_lock() noexcept;
N    template <class Rep, class Period>
N        bool try_lock_for(const chrono::duration<Rep, Period>& rel_time);
N    template <class Clock, class Duration>
N        bool try_lock_until(const chrono::time_point<Clock, Duration>& abs_time);
N    void unlock();
N};
N
Nstruct defer_lock_t {};
Nstruct try_to_lock_t {};
Nstruct adopt_lock_t {};
N
Nconstexpr defer_lock_t  defer_lock{};
Nconstexpr try_to_lock_t try_to_lock{};
Nconstexpr adopt_lock_t  adopt_lock{};
N
Ntemplate <class Mutex>
Nclass lock_guard
N{
Npublic:
N    typedef Mutex mutex_type;
N
N    explicit lock_guard(mutex_type& m);
N    lock_guard(mutex_type& m, adopt_lock_t);
N    ~lock_guard();
N
N    lock_guard(lock_guard const&) = delete;
N    lock_guard& operator=(lock_guard const&) = delete;
N};
N
Ntemplate <class... MutexTypes>
Nclass scoped_lock // C++17
N{
Npublic:
N    using mutex_type = Mutex;  // If MutexTypes... consists of the single type Mutex
N
N    explicit scoped_lock(MutexTypes&... m);
N    scoped_lock(adopt_lock_t, MutexTypes&... m);
N    ~scoped_lock();
N    scoped_lock(scoped_lock const&) = delete;
N    scoped_lock& operator=(scoped_lock const&) = delete;
Nprivate:
N    tuple<MutexTypes&...> pm; // exposition only
N};
N
Ntemplate <class Mutex>
Nclass unique_lock
N{
Npublic:
N    typedef Mutex mutex_type;
N    unique_lock() noexcept;
N    explicit unique_lock(mutex_type& m);
N    unique_lock(mutex_type& m, defer_lock_t) noexcept;
N    unique_lock(mutex_type& m, try_to_lock_t);
N    unique_lock(mutex_type& m, adopt_lock_t);
N    template <class Clock, class Duration>
N        unique_lock(mutex_type& m, const chrono::time_point<Clock, Duration>& abs_time);
N    template <class Rep, class Period>
N        unique_lock(mutex_type& m, const chrono::duration<Rep, Period>& rel_time);
N    ~unique_lock();
N
N    unique_lock(unique_lock const&) = delete;
N    unique_lock& operator=(unique_lock const&) = delete;
N
N    unique_lock(unique_lock&& u) noexcept;
N    unique_lock& operator=(unique_lock&& u) noexcept;
N
N    void lock();
N    bool try_lock();
N
N    template <class Rep, class Period>
N        bool try_lock_for(const chrono::duration<Rep, Period>& rel_time);
N    template <class Clock, class Duration>
N        bool try_lock_until(const chrono::time_point<Clock, Duration>& abs_time);
N
N    void unlock();
N
N    void swap(unique_lock& u) noexcept;
N    mutex_type* release() noexcept;
N
N    bool owns_lock() const noexcept;
N    explicit operator bool () const noexcept;
N    mutex_type* mutex() const noexcept;
N};
N
Ntemplate <class Mutex>
N  void swap(unique_lock<Mutex>& x, unique_lock<Mutex>& y) noexcept;
N
Ntemplate <class L1, class L2, class... L3>
N  int try_lock(L1&, L2&, L3&...);
Ntemplate <class L1, class L2, class... L3>
N  void lock(L1&, L2&, L3&...);
N
Nstruct once_flag
N{
N    constexpr once_flag() noexcept;
N
N    once_flag(const once_flag&) = delete;
N    once_flag& operator=(const once_flag&) = delete;
N};
N
Ntemplate<class Callable, class ...Args>
N  void call_once(once_flag& flag, Callable&& func, Args&&... args);
N
N}  // std
N
N*/
N
N#include <__config>
N#include <__mutex_base>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/__mutex_base" 1
N// -*- C++ -*-
N//===----------------------------------------------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is dual licensed under the MIT and the University of Illinois Open
N// Source Licenses. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP___MUTEX_BASE
N#define _LIBCPP___MUTEX_BASE
N
N#include <__config>
N#include <chrono>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/chrono" 1
N// -*- C++ -*-
N//===---------------------------- chrono ----------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is dual licensed under the MIT and the University of Illinois Open
N// Source Licenses. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP_CHRONO
N#define _LIBCPP_CHRONO
N
N/*
N    chrono synopsis
N
Nnamespace std
N{
Nnamespace chrono
N{
N
Ntemplate <class ToDuration, class Rep, class Period>
Nconstexpr
NToDuration
Nduration_cast(const duration<Rep, Period>& fd);
N
Ntemplate <class Rep> struct treat_as_floating_point : is_floating_point<Rep> {};
N
Ntemplate <class Rep> constexpr bool treat_as_floating_point_v
N    = treat_as_floating_point<Rep>::value;                       // C++17
N
Ntemplate <class Rep>
Nstruct duration_values
N{
Npublic:
N    static constexpr Rep zero();
N    static constexpr Rep max();
N    static constexpr Rep min();
N};
N
N// duration
N
Ntemplate <class Rep, class Period = ratio<1>>
Nclass duration
N{
N    static_assert(!__is_duration<Rep>::value, "A duration representation can not be a duration");
N    static_assert(__is_ratio<Period>::value, "Second template parameter of duration must be a std::ratio");
N    static_assert(Period::num > 0, "duration period must be positive");
Npublic:
N    typedef Rep rep;
N    typedef typename _Period::type period;
N
N    constexpr duration() = default;
N    template <class Rep2>
N        constexpr explicit duration(const Rep2& r,
N            typename enable_if
N            <
N               is_convertible<Rep2, rep>::value &&
N               (treat_as_floating_point<rep>::value ||
N               !treat_as_floating_point<rep>::value && !treat_as_floating_point<Rep2>::value)
N            >::type* = 0);
N
N    // conversions
N    template <class Rep2, class Period2>
N        constexpr duration(const duration<Rep2, Period2>& d,
N            typename enable_if
N            <
N                treat_as_floating_point<rep>::value ||
N                ratio_divide<Period2, period>::type::den == 1
N            >::type* = 0);
N
N    // observer
N
N    constexpr rep count() const;
N
N    // arithmetic
N
N    constexpr common_type<duration>::type  operator+() const;
N    constexpr common_type<duration>::type  operator-() const;
N    constexpr duration& operator++();
N    constexpr duration  operator++(int);
N    constexpr duration& operator--();
N    constexpr duration  operator--(int);
N
N    constexpr duration& operator+=(const duration& d);
N    constexpr duration& operator-=(const duration& d);
N
N    duration& operator*=(const rep& rhs);
N    duration& operator/=(const rep& rhs);
N
N    // special values
N
N    static constexpr duration zero();
N    static constexpr duration min();
N    static constexpr duration max();
N};
N
Ntypedef duration<long long,         nano> nanoseconds;
Ntypedef duration<long long,        micro> microseconds;
Ntypedef duration<long long,        milli> milliseconds;
Ntypedef duration<long long              > seconds;
Ntypedef duration<     long, ratio<  60> > minutes;
Ntypedef duration<     long, ratio<3600> > hours;
N
Ntemplate <class Clock, class Duration = typename Clock::duration>
Nclass time_point
N{
Npublic:
N    typedef Clock                     clock;
N    typedef Duration                  duration;
N    typedef typename duration::rep    rep;
N    typedef typename duration::period period;
Nprivate:
N    duration d_;  // exposition only
N
Npublic:
N    time_point();  // has value "epoch" // constexpr in C++14
N    explicit time_point(const duration& d);  // same as time_point() + d // constexpr in C++14
N
N    // conversions
N    template <class Duration2>
N       time_point(const time_point<clock, Duration2>& t); // constexpr in C++14
N
N    // observer
N
N    duration time_since_epoch() const; // constexpr in C++14
N
N    // arithmetic
N
N    time_point& operator+=(const duration& d);
N    time_point& operator-=(const duration& d);
N
N    // special values
N
N    static constexpr time_point min();
N    static constexpr time_point max();
N};
N
N} // chrono
N
N// common_type traits
Ntemplate <class Rep1, class Period1, class Rep2, class Period2>
N  struct common_type<chrono::duration<Rep1, Period1>, chrono::duration<Rep2, Period2>>;
N
Ntemplate <class Clock, class Duration1, class Duration2>
N  struct common_type<chrono::time_point<Clock, Duration1>, chrono::time_point<Clock, Duration2>>;
N
Nnamespace chrono {
N
N// duration arithmetic
Ntemplate <class Rep1, class Period1, class Rep2, class Period2>
N  constexpr
N  typename common_type<duration<Rep1, Period1>, duration<Rep2, Period2>>::type
N  operator+(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
Ntemplate <class Rep1, class Period1, class Rep2, class Period2>
N  constexpr
N  typename common_type<duration<Rep1, Period1>, duration<Rep2, Period2>>::type
N  operator-(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
Ntemplate <class Rep1, class Period, class Rep2>
N  constexpr
N  duration<typename common_type<Rep1, Rep2>::type, Period>
N  operator*(const duration<Rep1, Period>& d, const Rep2& s);
Ntemplate <class Rep1, class Period, class Rep2>
N  constexpr
N  duration<typename common_type<Rep1, Rep2>::type, Period>
N  operator*(const Rep1& s, const duration<Rep2, Period>& d);
Ntemplate <class Rep1, class Period, class Rep2>
N  constexpr
N  duration<typename common_type<Rep1, Rep2>::type, Period>
N  operator/(const duration<Rep1, Period>& d, const Rep2& s);
Ntemplate <class Rep1, class Period1, class Rep2, class Period2>
N  constexpr
N  typename common_type<Rep1, Rep2>::type
N  operator/(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
N
N// duration comparisons
Ntemplate <class Rep1, class Period1, class Rep2, class Period2>
N   constexpr
N   bool operator==(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
Ntemplate <class Rep1, class Period1, class Rep2, class Period2>
N   constexpr
N   bool operator!=(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
Ntemplate <class Rep1, class Period1, class Rep2, class Period2>
N   constexpr
N   bool operator< (const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
Ntemplate <class Rep1, class Period1, class Rep2, class Period2>
N   constexpr
N   bool operator<=(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
Ntemplate <class Rep1, class Period1, class Rep2, class Period2>
N   constexpr
N   bool operator> (const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
Ntemplate <class Rep1, class Period1, class Rep2, class Period2>
N   constexpr
N   bool operator>=(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
N
N// duration_cast
Ntemplate <class ToDuration, class Rep, class Period>
N  ToDuration duration_cast(const duration<Rep, Period>& d);
N
Ntemplate <class ToDuration, class Rep, class Period>
N    constexpr ToDuration floor(const duration<Rep, Period>& d);    // C++17
Ntemplate <class ToDuration, class Rep, class Period>
N    constexpr ToDuration ceil(const duration<Rep, Period>& d);     // C++17
Ntemplate <class ToDuration, class Rep, class Period>
N    constexpr ToDuration round(const duration<Rep, Period>& d);    // C++17
N
N// time_point arithmetic (all constexpr in C++14)
Ntemplate <class Clock, class Duration1, class Rep2, class Period2>
N  time_point<Clock, typename common_type<Duration1, duration<Rep2, Period2>>::type>
N  operator+(const time_point<Clock, Duration1>& lhs, const duration<Rep2, Period2>& rhs);
Ntemplate <class Rep1, class Period1, class Clock, class Duration2>
N  time_point<Clock, typename common_type<duration<Rep1, Period1>, Duration2>::type>
N  operator+(const duration<Rep1, Period1>& lhs, const time_point<Clock, Duration2>& rhs);
Ntemplate <class Clock, class Duration1, class Rep2, class Period2>
N  time_point<Clock, typename common_type<Duration1, duration<Rep2, Period2>>::type>
N  operator-(const time_point<Clock, Duration1>& lhs, const duration<Rep2, Period2>& rhs);
Ntemplate <class Clock, class Duration1, class Duration2>
N  typename common_type<Duration1, Duration2>::type
N  operator-(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);
N
N// time_point comparisons (all constexpr in C++14)
Ntemplate <class Clock, class Duration1, class Duration2>
N   bool operator==(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);
Ntemplate <class Clock, class Duration1, class Duration2>
N   bool operator!=(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);
Ntemplate <class Clock, class Duration1, class Duration2>
N   bool operator< (const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);
Ntemplate <class Clock, class Duration1, class Duration2>
N   bool operator<=(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);
Ntemplate <class Clock, class Duration1, class Duration2>
N   bool operator> (const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);
Ntemplate <class Clock, class Duration1, class Duration2>
N   bool operator>=(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);
N
N// time_point_cast (constexpr in C++14)
N
Ntemplate <class ToDuration, class Clock, class Duration>
N  time_point<Clock, ToDuration> time_point_cast(const time_point<Clock, Duration>& t);
N
Ntemplate <class ToDuration, class Clock, class Duration>
N    constexpr time_point<Clock, ToDuration>
N    floor(const time_point<Clock, Duration>& tp);                  // C++17
N
Ntemplate <class ToDuration, class Clock, class Duration>
N    constexpr time_point<Clock, ToDuration>
N    ceil(const time_point<Clock, Duration>& tp);                   // C++17
N
Ntemplate <class ToDuration, class Clock, class Duration>
N    constexpr time_point<Clock, ToDuration>
N    round(const time_point<Clock, Duration>& tp);                  // C++17
N
Ntemplate <class Rep, class Period>
N    constexpr duration<Rep, Period> abs(duration<Rep, Period> d);  // C++17
N// Clocks
N
Nclass system_clock
N{
Npublic:
N    typedef microseconds                     duration;
N    typedef duration::rep                    rep;
N    typedef duration::period                 period;
N    typedef chrono::time_point<system_clock> time_point;
N    static const bool is_steady =            false; // constexpr in C++14
N
N    static time_point now() noexcept;
N    static time_t     to_time_t  (const time_point& __t) noexcept;
N    static time_point from_time_t(time_t __t) noexcept;
N};
N
Nclass steady_clock
N{
Npublic:
N    typedef nanoseconds                                   duration;
N    typedef duration::rep                                 rep;
N    typedef duration::period                              period;
N    typedef chrono::time_point<steady_clock, duration>    time_point;
N    static const bool is_steady =                         true; // constexpr in C++14
N
N    static time_point now() noexcept;
N};
N
Ntypedef steady_clock high_resolution_clock;
N
N}  // chrono
N
Nconstexpr chrono::hours                                 operator ""h(unsigned long long); // C++14
Nconstexpr chrono::duration<unspecified , ratio<3600,1>> operator ""h(long double); // C++14
Nconstexpr chrono::minutes                               operator ""min(unsigned long long); // C++14
Nconstexpr chrono::duration<unspecified , ratio<60,1>>   operator ""min(long double); // C++14
Nconstexpr chrono::seconds                               operator ""s(unsigned long long); // C++14
Nconstexpr chrono::duration<unspecified >                operator ""s(long double); // C++14
Nconstexpr chrono::milliseconds                          operator ""ms(unsigned long long); // C++14
Nconstexpr chrono::duration<unspecified , milli>         operator ""ms(long double); // C++14
Nconstexpr chrono::microseconds                          operator ""us(unsigned long long); // C++14
Nconstexpr chrono::duration<unspecified , micro>         operator ""us(long double); // C++14
Nconstexpr chrono::nanoseconds                           operator ""ns(unsigned long long); // C++14
Nconstexpr chrono::duration<unspecified , nano>          operator ""ns(long double); // C++14
N
N}  // std
N*/
N
N#include <__config>
N#include <ctime>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/ctime" 1
N// -*- C++ -*-
N//===---------------------------- ctime -----------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is dual licensed under the MIT and the University of Illinois Open
N// Source Licenses. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP_CTIME
N#define _LIBCPP_CTIME
N
N/*
N    ctime synopsis
N
NMacros:
N
N    NULL
N    CLOCKS_PER_SEC
N
Nnamespace std
N{
N
NTypes:
N
N    clock_t
N    size_t
N    time_t
N    tm
N
Nclock_t clock();
Ndouble difftime(time_t time1, time_t time0);
Ntime_t mktime(tm* timeptr);
Ntime_t time(time_t* timer);
Nchar* asctime(const tm* timeptr);
Nchar* ctime(const time_t* timer);
Ntm*    gmtime(const time_t* timer);
Ntm* localtime(const time_t* timer);
Nsize_t strftime(char* restrict s, size_t maxsize, const char* restrict format,
N                const tm* restrict timeptr);
N
N}  // std
N
N*/
N
N#include <__config>
N#include <time.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/time.h" 1
N/*****************************************************************************/
N/* time.h                                                                    */
N/*                                                                           */
N/* Copyright (c) 1990 Texas Instruments Incorporated                         */
N/* http://www.ti.com/                                                        */
N/*                                                                           */
N/*  Redistribution and  use in source  and binary forms, with  or without    */
N/*  modification,  are permitted provided  that the  following conditions    */
N/*  are met:                                                                 */
N/*                                                                           */
N/*     Redistributions  of source  code must  retain the  above copyright    */
N/*     notice, this list of conditions and the following disclaimer.         */
N/*                                                                           */
N/*     Redistributions in binary form  must reproduce the above copyright    */
N/*     notice, this  list of conditions  and the following  disclaimer in    */
N/*     the  documentation  and/or   other  materials  provided  with  the    */
N/*     distribution.                                                         */
N/*                                                                           */
N/*     Neither the  name of Texas Instruments Incorporated  nor the names    */
N/*     of its  contributors may  be used to  endorse or  promote products    */
N/*     derived  from   this  software  without   specific  prior  written    */
N/*     permission.                                                           */
N/*                                                                           */
N/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS    */
N/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT    */
N/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    */
N/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT    */
N/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    */
N/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT    */
N/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    */
N/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    */
N/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT    */
N/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    */
N/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     */
N/*                                                                           */
N/*****************************************************************************/
N
N#ifndef _TIME_H_
N#define _TIME_H_
N
N#include <_ti_config.h>
N#include <abi_prefix.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/abi_prefix.h" 1
N/*****************************************************************************/
N/* ABI_PREFIX.H                                                              */
N/*                                                                           */
N/* Copyright (c) 2016 Texas Instruments Incorporated                         */
N/* http://www.ti.com/                                                        */
N/*                                                                           */
N/*  Redistribution and  use in source  and binary forms, with  or without    */
N/*  modification,  are permitted provided  that the  following conditions    */
N/*  are met:                                                                 */
N/*                                                                           */
N/*     Redistributions  of source  code must  retain the  above copyright    */
N/*     notice, this list of conditions and the following disclaimer.         */
N/*                                                                           */
N/*     Redistributions in binary form  must reproduce the above copyright    */
N/*     notice, this  list of conditions  and the following  disclaimer in    */
N/*     the  documentation  and/or   other  materials  provided  with  the    */
N/*     distribution.                                                         */
N/*                                                                           */
N/*     Neither the  name of Texas Instruments Incorporated  nor the names    */
N/*     of its  contributors may  be used to  endorse or  promote products    */
N/*     derived  from   this  software  without   specific  prior  written    */
N/*     permission.                                                           */
N/*                                                                           */
N/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS    */
N/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT    */
N/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    */
N/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT    */
N/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    */
N/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT    */
N/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    */
N/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    */
N/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT    */
N/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    */
N/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     */
N/*                                                                           */
N/*****************************************************************************/
N
N#ifndef __abi_prefix__
N#define __abi_prefix__
N
N#if defined(__C7000__) /* Keep __C7000__ ordered before __TMS320C6X__ */
X#if 0L  
S#  define __TI_P(x) __c7xabi_##x
S#elif defined(__TMS320C6X__)
X#elif 0L
S#  define __TI_P(x) __c6xabi_##x
S#elif defined(__ARP32__)
X#elif 0L
S#  define __TI_P(x) __arp32abi_##x
S#elif defined(__MSP430__)
X#elif 0L
S#  define __TI_P(x) __mspabi_##x
S#elif defined(__PRU__)
X#elif 0L
S#  define __TI_P(x) __pruabi_##x
N#elif defined(__ARM_ARCH)
X#elif 1L
N#  define __TI_P(x) __aeabi_##x
N#elif defined(__TMS320C2000__)
S#  if defined(__TMS320C28XX_CLA__)
S#    define __TI_P(x) __claabi_##x
S#  else
S#    define __TI_P(x) __c28xabi_##x
S#  endif
S#else
S#error "TARGET NOT DEFINED"
N#endif
N
N#endif
L 43 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/time.h" 2
N#if __has_include(<sys/_types.h>)
X#if 1
N#include <sys/_types.h>
N#endif
N
N#if defined(__TMS320C2000__)
X#if 0L
S#if defined(__TMS320C28XX_CLA__)
S#error "Header file <time.h> not supported by CLA compiler"
S#endif
N#endif
N
N#ifndef NULL
S#define NULL      0
N#endif
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
N/* Use sys/_types.h for clock_t and time_t if it exists */
N#if __has_include(<sys/_types.h>)
X#if 1
N#ifndef _CLOCK_T_DECLARED
Ntypedef __clock_t clock_t;
N#define _CLOCK_T_DECLARED
N#endif
N
N#ifndef _TIME_T_DECLARED
Ntypedef __time_t  time_t;
N#define _TIME_T_DECLARED
N#endif
N
Ntypedef __int64_t __time64_t;
Ntypedef __uint32_t __time32_t;
N
N#ifndef _SIZE_T_DECLARED
S#define _SIZE_T_DECLARED
S#ifdef __clang__
Stypedef __SIZE_TYPE__ size_t;
S#else
Stypedef __size_t size_t;
S#endif
N#endif
N
N#else
S
S#if (!defined(__C6X_MIGRATION__) && (defined(_TMS320C6X) || defined(__TMS320C6X__))) || defined(__ARM_ARCH)
Stypedef unsigned int clock_t;
Stypedef unsigned int __time32_t;
S#else
Stypedef unsigned long clock_t;
Stypedef unsigned long __time32_t;
S#endif /* int is 32 bits */
S
Stypedef long long __time64_t;
S
S#if defined(__C7000__) || (defined(__TMS320C2000__) && defined(__TI_EABI__))
S#define _TARGET_DEFAULTS_TO_TIME64
S#endif
S
S#if defined(_TARGET_DEFAULTS_TO_TIME64) || \
S    (defined(__TI_TIME_USES_64) && __TI_TIME_USES_64)
X#if defined(_TARGET_DEFAULTS_TO_TIME64) ||     (defined(__TI_TIME_USES_64) && __TI_TIME_USES_64)
Stypedef __time64_t time_t;
S#else
Stypedef __time32_t time_t;
S#endif
S
S#ifndef _SIZE_T_DECLARED
S#define _SIZE_T_DECLARED
S#ifdef __clang__
Stypedef __SIZE_TYPE__ size_t;
S#else
Stypedef __SIZE_T_TYPE__ size_t;
S#endif
S#endif
S
N#endif
N
N/*---------------------------------------------------------------------------*/
N/* The ARM ABI says __aeabi_CLOCKS_PER_SEC is a const int. C99 says that     */
N/* CLOCKS_PER_SEC is a constant of type clock_t. Therefore on ARM we define  */
N/* type of __clocks_per_sec_t as int and for all other targets it is clock_t */
N/*---------------------------------------------------------------------------*/
N#if defined(__ARM_ARCH)
X#if 1L
Ntypedef int          __clocks_per_sec_t;
N#else
Stypedef clock_t      __clocks_per_sec_t;
N#endif
N
Nextern _DATA_ACCESS const __clocks_per_sec_t __TI_P(CLOCKS_PER_SEC);
Xextern  const __clocks_per_sec_t __aeabi_CLOCKS_PER_SEC;
N#define CLOCKS_PER_SEC __TI_P(CLOCKS_PER_SEC)
N
Nstruct tm 
N{
N    int tm_sec;      /* seconds after the minute   - [0,59]  */
N    int tm_min;      /* minutes after the hour     - [0,59]  */
N    int tm_hour;     /* hours after the midnight   - [0,23]  */
N    int tm_mday;     /* day of the month           - [1,31]  */
N    int tm_mon;      /* months since January       - [0,11]  */
N    int tm_year;     /* years since 1900                     */
N    int tm_wday;     /* days since Sunday          - [0,6]   */
N    int tm_yday;     /* days since Jan 1st         - [0,365] */
N    int tm_isdst;    /* Daylight Savings Time flag           */
N#if defined(_AEABI_PORTABILITY_LEVEL) && _AEABI_PORTABILITY_LEVEL != 0
X#if 0L && _AEABI_PORTABILITY_LEVEL != 0
S    int __extra_1, __extra_2;            /* ABI-required extra fields */
N#endif
N
N};
N
N/*************************************************************************/
N/* TIME ZONE STRUCTURE DEFINITION                                        */
N/*************************************************************************/
Ntypedef struct 
N{
N    short daylight;
N    long  timezone; /* seconds WEST of UTC.  Strange but traditional */
N    char  tzname[4];
N    char  dstname[4];
N} TZ;
N
Nextern _DATA_ACCESS TZ _tz;
Xextern  TZ _tz;
N
N/****************************************************************************/
N/* FUNCTION DECLARATIONS.  (NOTE : clock AND time ARE SYSTEM SPECIFIC)      */
N/****************************************************************************/
N_CODE_ACCESS clock_t    clock(void);             
X clock_t    clock(void);             
N
N_CODE_ACCESS __time32_t __time32(__time32_t *_timer);   
X __time32_t __time32(__time32_t *_timer);   
N_CODE_ACCESS __time32_t __mktime32(struct tm *_tptr);
X __time32_t __mktime32(struct tm *_tptr);
N_CODE_ACCESS double     __difftime32(__time32_t _time1, __time32_t _time0);
X double     __difftime32(__time32_t _time1, __time32_t _time0);
N      _IDECL char      *__ctime32(const __time32_t *_timer);
X      extern  char      *__ctime32(const __time32_t *_timer);
N_CODE_ACCESS struct tm *__gmtime32(const __time32_t *_timer);
X struct tm *__gmtime32(const __time32_t *_timer);
N_CODE_ACCESS struct tm *__localtime32(const __time32_t *_timer);
X struct tm *__localtime32(const __time32_t *_timer);
N
N_CODE_ACCESS __time64_t __time64(__time64_t *_timer);   
X __time64_t __time64(__time64_t *_timer);   
N_CODE_ACCESS __time64_t __mktime64(struct tm *_tptr);
X __time64_t __mktime64(struct tm *_tptr);
N_CODE_ACCESS double     __difftime64(__time64_t _time1, __time64_t _time0);
X double     __difftime64(__time64_t _time1, __time64_t _time0);
N      _IDECL char      *__ctime64(const __time64_t *_timer);
X      extern  char      *__ctime64(const __time64_t *_timer);
N_CODE_ACCESS struct tm *__gmtime64(const __time64_t *_timer);
X struct tm *__gmtime64(const __time64_t *_timer);
N_CODE_ACCESS struct tm *__localtime64(const __time64_t *_timer);
X struct tm *__localtime64(const __time64_t *_timer);
N
N_CODE_ACCESS char      *asctime(const struct tm *_timeptr);
X char      *asctime(const struct tm *_timeptr);
N_CODE_ACCESS size_t     strftime(char * __restrict _out, size_t _maxsize,
X size_t     strftime(char * __restrict _out, size_t _maxsize,
N				 const char * __restrict _format,
N				 const struct tm * __restrict _timeptr);
N
N#if defined(_INLINE) || defined(_CTIME32_IMPLEMENTATION)
X#if 0L || 0L
S_IDEFN char *__ctime32(const __time32_t *timer)
S{
S   return asctime(__localtime32(timer));
S}
N#endif /* _INLINE || _CTIME32_IMPLEMENTATION */
N
N#if defined(_INLINE) || defined(_CTIME64_IMPLEMENTATION)
X#if 0L || 0L
S_IDEFN char *__ctime64(const __time64_t *timer)
S{
S   return asctime(__localtime64(timer));
S}
N#endif /* _INLINE || _CTIME64_IMPLEMENTATION */
N
N/*-----------------------------------------------------------------------*/
N/* The user may define __TI_TIME_USES_64=1 to redirects all time        */
N/* functions to time64 functions.                                        */
N/*-----------------------------------------------------------------------*/
N#if defined(_TIME_IMPLEMENTATION) && defined(__TI_TIME_USES_64) && __TI_TIME_USES_64
X#if 0L && 0L && __TI_TIME_USES_64
S#error "Do not build the RTS with __TI_TIME_USES_64 set"
S#elif defined(__TI_TIME_USES_64) && __TI_TIME_USES_64
X#elif 0L && __TI_TIME_USES_64
Sstatic __inline time_t     time(time_t *timer) { return __time64(timer); }
Sstatic __inline time_t     mktime(struct tm *tptr) { return __mktime64(tptr); }
Sstatic __inline double     difftime(time_t time1, time_t time0) { return __difftime64(time1, time0); }
Sstatic __inline char      *ctime(const time_t *timer) { return __ctime64(timer); }
Sstatic __inline struct tm *gmtime(const time_t *timer) { return __gmtime64(timer); }
Sstatic __inline struct tm *localtime(const time_t *timer) { return __localtime64(timer); }
N#else
N_CODE_ACCESS time_t     time(time_t *_timer);   
X time_t     time(time_t *_timer);   
N_CODE_ACCESS time_t     mktime(struct tm *_tptr);
X time_t     mktime(struct tm *_tptr);
N_CODE_ACCESS double     difftime(time_t _time1, time_t _time0);
X double     difftime(time_t _time1, time_t _time0);
N      _IDECL char      *ctime(const time_t *_timer);
X      extern  char      *ctime(const time_t *_timer);
N_CODE_ACCESS struct tm *gmtime(const time_t *_timer);
X struct tm *gmtime(const time_t *_timer);
N_CODE_ACCESS struct tm *localtime(const time_t *_timer);
X struct tm *localtime(const time_t *_timer);
N  #if defined(_INLINE) && !defined(_TIME_IMPLEMENTATION)
X  #if 0L && !0L
S  _IDEFN char *ctime(const time_t *timer)
S  {
S     return asctime(localtime(timer));
S  }
N  #endif /* _INLINE */
N#endif
N
N#ifdef __cplusplus
N} /* extern "C" */
N#endif /* __cplusplus */
N
N#if defined(_AEABI_PORTABILITY_LEVEL) && _AEABI_PORTABILITY_LEVEL != 0 && \
N   !defined(_AEABI_PORTABLE)
X#if 0L && _AEABI_PORTABILITY_LEVEL != 0 &&    !0L
S#define _AEABI_PORTABLE
N#endif
N
N/*----------------------------------------------------------------------------*/
N/* If sys/cdefs.h is available, go ahead and include it. xlocale.h assumes    */
N/* this file will have already included sys/cdefs.h.                          */
N/*----------------------------------------------------------------------------*/
N#if __has_include(<sys/cdefs.h>)
X#if 1
N#include <sys/cdefs.h>
N#endif
N
N/*----------------------------------------------------------------------------*/
N/* Include xlocale/_time.h> if POSIX is enabled. This will expose the         */
N/* xlocale time interface.                                                    */
N/*----------------------------------------------------------------------------*/
N#if (defined(__POSIX_VISIBLE) && __POSIX_VISIBLE >= 200809) || defined(_XLOCALE_H_)
X#if (1L && 200809 >= 200809) || 0L
N__BEGIN_DECLS
Xextern "C" {
N#include <xlocale/_time.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/xlocale/_time.h" 1
N/*-
N * SPDX-License-Identifier: BSD-2-Clause-FreeBSD
N *
N * Copyright (c) 2011, 2012 The FreeBSD Foundation
N * All rights reserved.
N *
N * This software was developed by David Chisnall under sponsorship from
N * the FreeBSD Foundation.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N * 1. Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
N * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
N * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
N * SUCH DAMAGE.
N *
N * $FreeBSD$
N */
N
N#ifndef _LOCALE_T_DEFINED
S#define _LOCALE_T_DEFINED
Stypedef struct	_xlocale *locale_t;
N#endif
N
N/*
N * This file is included from both locale.h and xlocale.h.  We need to expose
N * the declarations unconditionally if we are included from xlocale.h, but only
N * if we are in POSIX2008 mode if included from locale.h.
N */
N#ifndef _XLOCALE_LOCALE1_H
N#define _XLOCALE_LOCALE1_H
N
Nsize_t	 strftime_l(char * __restrict, size_t, const char * __restrict,
N	    const struct tm * __restrict, locale_t) __strftimelike(3, 0);
X	    const struct tm * __restrict, locale_t) ;
N
N#endif /* _XLOCALE_LOCALE1_H */
N
N#ifdef _XLOCALE_H_
S#ifndef _XLOCALE_LOCALE2_H
S#define _XLOCALE_LOCALE2_H
S
Schar	*strptime_l(const char * __restrict, const char * __restrict,
S           struct tm * __restrict, locale_t);
S
S#endif /* _XLOCALE_LOCALE2_H */
N#endif /* _XLOCALE_H_ */
L 253 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/time.h" 2
N__END_DECLS
X}
N#endif
N
N#endif /* _TIME_H_ */
N
L 49 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/ctime" 2
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N_LIBCPP_BEGIN_NAMESPACE_STD
Xnamespace std { inline namespace __2 {
N
Nusing ::clock_t;
Nusing ::size_t;
Nusing ::time_t;
Nusing ::tm;
Nusing ::clock;
Nusing ::difftime;
Nusing ::mktime;
Nusing ::time;
N#ifndef _LIBCPP_HAS_NO_THREAD_UNSAFE_C_FUNCTIONS
Nusing ::asctime;
Nusing ::ctime;
Nusing ::gmtime;
Nusing ::localtime;
N#endif
Nusing ::strftime;
N
N_LIBCPP_END_NAMESPACE_STD
X} }
N
N#endif  // _LIBCPP_CTIME
L 304 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/chrono" 2
N#include <type_traits>
N#include <ratio>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/ratio" 1
N// -*- C++ -*-
N//===---------------------------- ratio -----------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is dual licensed under the MIT and the University of Illinois Open
N// Source Licenses. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP_RATIO
N#define _LIBCPP_RATIO
N
N/*
N    ratio synopsis
N
Nnamespace std
N{
N
Ntemplate <intmax_t N, intmax_t D = 1>
Nclass ratio
N{
Npublic:
N    static constexpr intmax_t num;
N    static constexpr intmax_t den;
N    typedef ratio<num, den> type;
N};
N
N// ratio arithmetic
Ntemplate <class R1, class R2> using ratio_add = ...;
Ntemplate <class R1, class R2> using ratio_subtract = ...;
Ntemplate <class R1, class R2> using ratio_multiply = ...;
Ntemplate <class R1, class R2> using ratio_divide = ...;
N
N// ratio comparison
Ntemplate <class R1, class R2> struct ratio_equal;
Ntemplate <class R1, class R2> struct ratio_not_equal;
Ntemplate <class R1, class R2> struct ratio_less;
Ntemplate <class R1, class R2> struct ratio_less_equal;
Ntemplate <class R1, class R2> struct ratio_greater;
Ntemplate <class R1, class R2> struct ratio_greater_equal;
N
N// convenience SI typedefs
Ntypedef ratio<1, 1000000000000000000000000> yocto;  // not supported
Ntypedef ratio<1,    1000000000000000000000> zepto;  // not supported
Ntypedef ratio<1,       1000000000000000000> atto;
Ntypedef ratio<1,          1000000000000000> femto;
Ntypedef ratio<1,             1000000000000> pico;
Ntypedef ratio<1,                1000000000> nano;
Ntypedef ratio<1,                   1000000> micro;
Ntypedef ratio<1,                      1000> milli;
Ntypedef ratio<1,                       100> centi;
Ntypedef ratio<1,                        10> deci;
Ntypedef ratio<                       10, 1> deca;
Ntypedef ratio<                      100, 1> hecto;
Ntypedef ratio<                     1000, 1> kilo;
Ntypedef ratio<                  1000000, 1> mega;
Ntypedef ratio<               1000000000, 1> giga;
Ntypedef ratio<            1000000000000, 1> tera;
Ntypedef ratio<         1000000000000000, 1> peta;
Ntypedef ratio<      1000000000000000000, 1> exa;
Ntypedef ratio<   1000000000000000000000, 1> zetta;  // not supported
Ntypedef ratio<1000000000000000000000000, 1> yotta;  // not supported
N
N  // 20.11.5, ratio comparison
N  template <class R1, class R2> constexpr bool ratio_equal_v
N    = ratio_equal<R1, R2>::value;                                       // C++17
N  template <class R1, class R2> constexpr bool ratio_not_equal_v
N    = ratio_not_equal<R1, R2>::value;                                   // C++17
N  template <class R1, class R2> constexpr bool ratio_less_v
N    = ratio_less<R1, R2>::value;                                        // C++17
N  template <class R1, class R2> constexpr bool ratio_less_equal_v
N    = ratio_less_equal<R1, R2>::value;                                  // C++17
N  template <class R1, class R2> constexpr bool ratio_greater_v
N    = ratio_greater<R1, R2>::value;                                     // C++17
N  template <class R1, class R2> constexpr bool ratio_greater_equal_v
N    = ratio_greater_equal<R1, R2>::value;                               // C++17
N}
N*/
N
N#include <__config>
N#include <cstdint>
N#include <climits>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/climits" 1
N// -*- C++ -*-
N//===--------------------------- climits ----------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is dual licensed under the MIT and the University of Illinois Open
N// Source Licenses. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP_CLIMITS
N#define _LIBCPP_CLIMITS
N
N/*
N    climits synopsis
N
NMacros:
N
N    CHAR_BIT
N    SCHAR_MIN
N    SCHAR_MAX
N    UCHAR_MAX
N    CHAR_MIN
N    CHAR_MAX
N    MB_LEN_MAX
N    SHRT_MIN
N    SHRT_MAX
N    USHRT_MAX
N    INT_MIN
N    INT_MAX
N    UINT_MAX
N    LONG_MIN
N    LONG_MAX
N    ULONG_MAX
N    LLONG_MIN   // C99
N    LLONG_MAX   // C99
N    ULLONG_MAX  // C99
N
N*/
N
N#include <__config>
N#include <limits.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/limits.h" 1
N/* -*- C++ -*- */
N/*===--------------------------- complex.h --------------------------------===*/
N/*                                                                            */
N/*                     The LLVM Compiler Infrastructure                       */
N/*                                                                            */
N/* This file is dual licensed under the MIT and the University of Illinois Open
N** Source Licenses. See LICENSE.TXT for details.
N*/
N/*===----------------------------------------------------------------------===*/
N
N#ifndef _LIBCPP_LIMITS_H
N#define _LIBCPP_LIMITS_H
N
N/*
N    limits.h synopsis
N
NMacros:
N
N    CHAR_BIT
N    SCHAR_MIN
N    SCHAR_MAX
N    UCHAR_MAX
N    CHAR_MIN
N    CHAR_MAX
N    MB_LEN_MAX
N    SHRT_MIN
N    SHRT_MAX
N    USHRT_MAX
N    INT_MIN
N    INT_MAX
N    UINT_MAX
N    LONG_MIN
N    LONG_MAX
N    ULONG_MAX
N    LLONG_MIN   // C99
N    LLONG_MAX   // C99
N    ULLONG_MAX  // C99
N
N*/
N
N#include <__config>
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N#ifndef __GNUC__
N#include_next <limits.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/limits.h" 1
N/*****************************************************************************/
N/* limits.h                                                                  */
N/*                                                                           */
N/* Copyright (c) 1993 Texas Instruments Incorporated                         */
N/* http://www.ti.com/                                                        */
N/*                                                                           */
N/*  Redistribution and  use in source  and binary forms, with  or without    */
N/*  modification,  are permitted provided  that the  following conditions    */
N/*  are met:                                                                 */
N/*                                                                           */
N/*     Redistributions  of source  code must  retain the  above copyright    */
N/*     notice, this list of conditions and the following disclaimer.         */
N/*                                                                           */
N/*     Redistributions in binary form  must reproduce the above copyright    */
N/*     notice, this  list of conditions  and the following  disclaimer in    */
N/*     the  documentation  and/or   other  materials  provided  with  the    */
N/*     distribution.                                                         */
N/*                                                                           */
N/*     Neither the  name of Texas Instruments Incorporated  nor the names    */
N/*     of its  contributors may  be used to  endorse or  promote products    */
N/*     derived  from   this  software  without   specific  prior  written    */
N/*     permission.                                                           */
N/*                                                                           */
N/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS    */
N/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT    */
N/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    */
N/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT    */
N/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    */
N/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT    */
N/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    */
N/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    */
N/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT    */
N/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    */
N/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     */
N/*                                                                           */
N/*****************************************************************************/
N
N#ifndef _LIMITS_H_
N#define _LIMITS_H_
N
N#pragma diag_push
N#pragma CHECK_MISRA("-20.1") /* standard headers must define standard names */
N
N#if defined(__TMS320C28XX_CLA__)
X#if 0L
S#define CHAR_BIT                16       /* NUMBER OF BITS IN TYPE CHAR      */
S#define SCHAR_MIN    (-SCHAR_MAX-1)      /* MAX VALUE FOR SIGNED CHAR        */
S#define SCHAR_MAX            32767       /* MIN VALUE FOR SIGNED CHAR        */
S#define UCHAR_MAX            65535       /* MAX VALUE FOR UNSIGNED CHAR      */
S#elif defined(__TMS320C2000__)
X#elif 0L
S#define CHAR_BIT                16       /* NUMBER OF BITS IN TYPE CHAR      */
S#define SCHAR_MIN    (-SCHAR_MAX-1)      /* MAX VALUE FOR SIGNED CHAR        */
S#define SCHAR_MAX            32767       /* MIN VALUE FOR SIGNED CHAR        */
S#define UCHAR_MAX            65535u      /* MAX VALUE FOR UNSIGNED CHAR      */
N#else
N#define CHAR_BIT                 8       /* NUMBER OF BITS IN TYPE CHAR      */
N#define SCHAR_MIN    (-SCHAR_MAX-1)      /* MIN VALUE FOR SIGNED CHAR        */
N#define SCHAR_MAX              127       /* MAX VALUE FOR SIGNED CHAR        */
N#define UCHAR_MAX              255       /* MAX VALUE FOR UNSIGNED CHAR      */
N#endif
N
N#if (!defined(__TMS320C2000__) && \
N    !(defined(__TMS320C6X__) && !defined(__C6X_MIGRATION__))) && \
N    (defined(__unsigned_chars__) || defined(__CHAR_UNSIGNED__))
X#if (!0L &&     !(0L && !0L)) &&     (1L || 0L)
N#define CHAR_MIN                 0       /* MIN VALUE FOR CHAR               */
N#define CHAR_MAX        (UCHAR_MAX)      /* MAX VALUE FOR CHAR               */
N#else
S#define CHAR_MIN        (SCHAR_MIN)      /* MIN VALUE FOR PLAIN CHAR         */
S#define CHAR_MAX        (SCHAR_MAX)      /* MAX VALUE FOR PLAIN CHAR         */
N#endif /* __CHAR_UNSIGNED__ */
N
N#if defined(_AEABI_PORTABILITY_LEVEL) && _AEABI_PORTABILITY_LEVEL != 0
X#if 0L && _AEABI_PORTABILITY_LEVEL != 0
S  #if defined(__cplusplus)
S  extern "C" {
S  #endif
S      extern const int __aeabi_MB_LEN_MAX;
S  #if defined(__cplusplus)
S  }
S  #endif
S  #define MB_LEN_MAX (__aeabi_MB_LEN_MAX)
N#elif defined(__ARM_ARCH)
X#elif 1L
N#define MB_LEN_MAX               8       /* MAX # BYTES IN MULTI-BYTE        */
N#else
S#define MB_LEN_MAX               1       /* MAX # BYTES IN MULTI-BYTE        */
N#endif
N
N#define SHRT_MIN      (-SHRT_MAX-1)      /* MIN VALUE FOR SHORT              */
N#define SHRT_MAX             32767       /* MAX VALUE FOR SHORT              */
N#if defined(__MSP430__) || \
N    defined(__TMS320C2000__) && !defined(__TMS320C28XX_CLA__)
X#if 0L ||     0L && !0L
S#define USHRT_MAX            65535u      /* MAX VALUE FOR UNSIGNED SHORT     */
S
S#define INT_MIN          (SHRT_MIN)      /* MIN VALUE FOR INT                */
S#define INT_MAX          (SHRT_MAX)      /* MAX VALUE FOR INT                */
S#define UINT_MAX        (USHRT_MAX)      /* MAX VALUE FOR UNSIGNED INT       */
N#else
N#define USHRT_MAX            65535       /* MAX VALUE FOR UNSIGNED SHORT     */
N
N#define INT_MIN         (-INT_MAX-1)     /* MIN VALUE FOR INT                */
N#define INT_MAX         2147483647       /* MAX VALUE FOR INT                */
N#define UINT_MAX        4294967295U      /* MAX VALUE FOR UNSIGNED INT       */
N#endif
N
N#if defined(__TMS320C6X__) && !defined(__C6X_MIGRATION__) && !defined(__TI_32BIT_LONG__)
X#if 0L && !0L && !0L
S#define LONG_MIN        (-LONG_MAX-1)    /* MIN VALUE FOR LONG               */
S#define LONG_MAX         549755813887    /* MAX VALUE FOR LONG               */
S#define ULONG_MAX      1099511627775U    /* MAX VALUE FOR UNSIGNED LONG      */
S#elif defined(__C7000__)
X#elif 0L
S#define LONG_MIN         (-LONG_MAX-1)   /* MIN VALUE FOR LONG               */
S#define LONG_MAX    9223372036854775807  /* MAX VALUE FOR LONG               */
S#define ULONG_MAX 18446744073709551615U  /* MAX VALUE FOR UNSIGNED LONG      */
N#else
N#define LONG_MIN        (-LONG_MAX-1)    /* MIN VALUE FOR LONG               */
N#define LONG_MAX         2147483647      /* MAX VALUE FOR LONG               */
N#define ULONG_MAX       4294967295U      /* MAX VALUE FOR UNSIGNED LONG      */
N#endif
N
N#if defined(__TMS320C6X__) && !defined(__C6X_MIGRATION__)
X#if 0L && !0L
S#define INT40_T_MIN    (-INT40_T_MAX-1)  /* MIN VALUE FOR __INT40_T          */
S#define INT40_T_MAX     549755813887I40  /* MAX VALUE FOR __INT40_T          */
S#define UINT40_T_MAX  1099511627775UI40  /* MAX VALUE FOR UNSIGNED __INT40_T */
N#endif
N
N#define LLONG_MIN         (-LLONG_MAX-1) /* MIN VALUE FOR LONG LONG          */
N#define LLONG_MAX    9223372036854775807 /* MAX VALUE FOR LONG LONG          */
N#define ULLONG_MAX 18446744073709551615U /* MAX VALUE FOR UNSIGNED LONG LONG */
N
N#pragma diag_pop
N
N#if defined(_AEABI_PORTABILITY_LEVEL) && _AEABI_PORTABILITY_LEVEL != 0 && \
N   !defined(_AEABI_PORTABLE)
X#if 0L && _AEABI_PORTABILITY_LEVEL != 0 &&    !0L
S#define _AEABI_PORTABLE
N#endif
N
N#endif /* #ifndef _LIMITS_H_ */
N
L 49 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/limits.h" 2
N#else
S/*
S*  GCC header limits.h recursively includes itself through another header called
S*  syslimits.h for some reason. This setup breaks down if we directly
S*  #include_next GCC's limits.h (reasons not entirely clear to me). Therefore,
S*  we manually re-create the necessary include sequence below:
S*/
S
S/* Get the system limits.h defines (force recurse into the next level) */
S#define _GCC_LIMITS_H_
S#define _GCC_NEXT_LIMITS_H
S#include_next <limits.h>
S
S/* Get the ISO C defines */
S#undef _GCC_LIMITS_H_
S#include_next <limits.h>
N#endif /* __GNUC__ */
N
N#endif  /* _LIBCPP_LIMITS_H */
L 43 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/climits" 2
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N#endif  // _LIBCPP_CLIMITS
L 84 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/ratio" 2
N#include <type_traits>
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N_LIBCPP_PUSH_MACROS
X_Pragma("push_macro(\"min\")") _Pragma("push_macro(\"max\")")
N#include <__undef_macros>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/__undef_macros" 1
N// -*- C++ -*-
N//===------------------------ __undef_macros ------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is distributed under the University of Illinois Open Source
N// License. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N
N#ifdef min
S#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
S#if defined(_LIBCPP_WARNING)
S_LIBCPP_WARNING("macro min is incompatible with C++.  Try #define NOMINMAX "
S                "before any Windows header. #undefing min")
S#else
S#warning: macro min is incompatible with C++.  #undefing min
S#endif
S#endif
S#undef min
N#endif
N
N#ifdef max
S#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
S#if defined(_LIBCPP_WARNING)
S_LIBCPP_WARNING("macro max is incompatible with C++.  Try #define NOMINMAX "
S                "before any Windows header. #undefing max")
S#else
S#warning: macro max is incompatible with C++.  #undefing max
S#endif
S#endif
S#undef max
N#endif
L 92 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/ratio" 2
N
N
N_LIBCPP_BEGIN_NAMESPACE_STD
Xnamespace std { inline namespace __2 {
N
N// __static_gcd
N
Ntemplate <intmax_t _Xp, intmax_t _Yp>
Nstruct __static_gcd
N{
N    static const intmax_t value = __static_gcd<_Yp, _Xp % _Yp>::value;
N};
N
Ntemplate <intmax_t _Xp>
Nstruct __static_gcd<_Xp, 0>
N{
N    static const intmax_t value = _Xp;
N};
N
Ntemplate <>
Nstruct __static_gcd<0, 0>
N{
N    static const intmax_t value = 1;
N};
N
N// __static_lcm
N
Ntemplate <intmax_t _Xp, intmax_t _Yp>
Nstruct __static_lcm
N{
N    static const intmax_t value = _Xp / __static_gcd<_Xp, _Yp>::value * _Yp;
N};
N
Ntemplate <intmax_t _Xp>
Nstruct __static_abs
N{
N    static const intmax_t value = _Xp < 0 ? -_Xp : _Xp;
N};
N
Ntemplate <intmax_t _Xp>
Nstruct __static_sign
N{
N    static const intmax_t value = _Xp == 0 ? 0 : (_Xp < 0 ? -1 : 1);
N};
N
Ntemplate <intmax_t _Xp, intmax_t _Yp, intmax_t = __static_sign<_Yp>::value>
Nclass __ll_add;
N
Ntemplate <intmax_t _Xp, intmax_t _Yp>
Nclass __ll_add<_Xp, _Yp, 1>
N{
N    static const intmax_t min = (1LL << (sizeof(intmax_t) * CHAR_BIT - 1)) + 1;
X    static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
N    static const intmax_t max = -min;
N
N    static_assert(_Xp <= max - _Yp, "overflow in __ll_add");
Npublic:
N    static const intmax_t value = _Xp + _Yp;
N};
N
Ntemplate <intmax_t _Xp, intmax_t _Yp>
Nclass __ll_add<_Xp, _Yp, 0>
N{
Npublic:
N    static const intmax_t value = _Xp;
N};
N
Ntemplate <intmax_t _Xp, intmax_t _Yp>
Nclass __ll_add<_Xp, _Yp, -1>
N{
N    static const intmax_t min = (1LL << (sizeof(intmax_t) * CHAR_BIT - 1)) + 1;
X    static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
N    static const intmax_t max = -min;
N
N    static_assert(min - _Yp <= _Xp, "overflow in __ll_add");
Npublic:
N    static const intmax_t value = _Xp + _Yp;
N};
N
Ntemplate <intmax_t _Xp, intmax_t _Yp, intmax_t = __static_sign<_Yp>::value>
Nclass __ll_sub;
N
Ntemplate <intmax_t _Xp, intmax_t _Yp>
Nclass __ll_sub<_Xp, _Yp, 1>
N{
N    static const intmax_t min = (1LL << (sizeof(intmax_t) * CHAR_BIT - 1)) + 1;
X    static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
N    static const intmax_t max = -min;
N
N    static_assert(min + _Yp <= _Xp, "overflow in __ll_sub");
Npublic:
N    static const intmax_t value = _Xp - _Yp;
N};
N
Ntemplate <intmax_t _Xp, intmax_t _Yp>
Nclass __ll_sub<_Xp, _Yp, 0>
N{
Npublic:
N    static const intmax_t value = _Xp;
N};
N
Ntemplate <intmax_t _Xp, intmax_t _Yp>
Nclass __ll_sub<_Xp, _Yp, -1>
N{
N    static const intmax_t min = (1LL << (sizeof(intmax_t) * CHAR_BIT - 1)) + 1;
X    static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
N    static const intmax_t max = -min;
N
N    static_assert(_Xp <= max + _Yp, "overflow in __ll_sub");
Npublic:
N    static const intmax_t value = _Xp - _Yp;
N};
N
Ntemplate <intmax_t _Xp, intmax_t _Yp>
Nclass __ll_mul
N{
N    static const intmax_t nan = (1LL << (sizeof(intmax_t) * CHAR_BIT - 1));
X    static const intmax_t nan = (1LL << (sizeof(intmax_t) * 8 - 1));
N    static const intmax_t min = nan + 1;
N    static const intmax_t max = -min;
N    static const intmax_t __a_x = __static_abs<_Xp>::value;
N    static const intmax_t __a_y = __static_abs<_Yp>::value;
N
N    static_assert(_Xp != nan && _Yp != nan && __a_x <= max / __a_y, "overflow in __ll_mul");
Npublic:
N    static const intmax_t value = _Xp * _Yp;
N};
N
Ntemplate <intmax_t _Yp>
Nclass __ll_mul<0, _Yp>
N{
Npublic:
N    static const intmax_t value = 0;
N};
N
Ntemplate <intmax_t _Xp>
Nclass __ll_mul<_Xp, 0>
N{
Npublic:
N    static const intmax_t value = 0;
N};
N
Ntemplate <>
Nclass __ll_mul<0, 0>
N{
Npublic:
N    static const intmax_t value = 0;
N};
N
N// Not actually used but left here in case needed in future maintenance
Ntemplate <intmax_t _Xp, intmax_t _Yp>
Nclass __ll_div
N{
N    static const intmax_t nan = (1LL << (sizeof(intmax_t) * CHAR_BIT - 1));
X    static const intmax_t nan = (1LL << (sizeof(intmax_t) * 8 - 1));
N    static const intmax_t min = nan + 1;
N    static const intmax_t max = -min;
N
N    static_assert(_Xp != nan && _Yp != nan && _Yp != 0, "overflow in __ll_div");
Npublic:
N    static const intmax_t value = _Xp / _Yp;
N};
N
Ntemplate <intmax_t _Num, intmax_t _Den = 1>
Nclass _LIBCPP_TEMPLATE_VIS ratio
Xclass  ratio
N{
N    static_assert(__static_abs<_Num>::value >= 0, "ratio numerator is out of range");
N    static_assert(_Den != 0, "ratio divide by 0");
N    static_assert(__static_abs<_Den>::value >  0, "ratio denominator is out of range");
N    static _LIBCPP_CONSTEXPR const intmax_t __na = __static_abs<_Num>::value;
X    static constexpr const intmax_t __na = __static_abs<_Num>::value;
N    static _LIBCPP_CONSTEXPR const intmax_t __da = __static_abs<_Den>::value;
X    static constexpr const intmax_t __da = __static_abs<_Den>::value;
N    static _LIBCPP_CONSTEXPR const intmax_t __s = __static_sign<_Num>::value * __static_sign<_Den>::value;
X    static constexpr const intmax_t __s = __static_sign<_Num>::value * __static_sign<_Den>::value;
N    static _LIBCPP_CONSTEXPR const intmax_t __gcd = __static_gcd<__na, __da>::value;
X    static constexpr const intmax_t __gcd = __static_gcd<__na, __da>::value;
Npublic:
N    static _LIBCPP_CONSTEXPR const intmax_t num = __s * __na / __gcd;
X    static constexpr const intmax_t num = __s * __na / __gcd;
N    static _LIBCPP_CONSTEXPR const intmax_t den = __da / __gcd;
X    static constexpr const intmax_t den = __da / __gcd;
N
N    typedef ratio<num, den> type;
N};
N
Ntemplate <intmax_t _Num, intmax_t _Den>
N_LIBCPP_CONSTEXPR const intmax_t ratio<_Num, _Den>::num;
Xconstexpr const intmax_t ratio<_Num, _Den>::num;
N
Ntemplate <intmax_t _Num, intmax_t _Den>
N_LIBCPP_CONSTEXPR const intmax_t ratio<_Num, _Den>::den;
Xconstexpr const intmax_t ratio<_Num, _Den>::den;
N
Ntemplate <class _Tp>                    struct __is_ratio                     : false_type {};
Ntemplate <intmax_t _Num, intmax_t _Den> struct __is_ratio<ratio<_Num, _Den> > : true_type  {};
N
Ntypedef ratio<1LL, 1000000000000000000LL> atto;
Ntypedef ratio<1LL,    1000000000000000LL> femto;
Ntypedef ratio<1LL,       1000000000000LL> pico;
Ntypedef ratio<1LL,          1000000000LL> nano;
Ntypedef ratio<1LL,             1000000LL> micro;
Ntypedef ratio<1LL,                1000LL> milli;
Ntypedef ratio<1LL,                 100LL> centi;
Ntypedef ratio<1LL,                  10LL> deci;
Ntypedef ratio<                 10LL, 1LL> deca;
Ntypedef ratio<                100LL, 1LL> hecto;
Ntypedef ratio<               1000LL, 1LL> kilo;
Ntypedef ratio<            1000000LL, 1LL> mega;
Ntypedef ratio<         1000000000LL, 1LL> giga;
Ntypedef ratio<      1000000000000LL, 1LL> tera;
Ntypedef ratio<   1000000000000000LL, 1LL> peta;
Ntypedef ratio<1000000000000000000LL, 1LL> exa;
N
Ntemplate <class _R1, class _R2>
Nstruct __ratio_multiply
N{
Nprivate:
N    static const intmax_t __gcd_n1_d2 = __static_gcd<_R1::num, _R2::den>::value;
N    static const intmax_t __gcd_d1_n2 = __static_gcd<_R1::den, _R2::num>::value;
Npublic:
N    typedef typename ratio
N        <
N            __ll_mul<_R1::num / __gcd_n1_d2, _R2::num / __gcd_d1_n2>::value,
N            __ll_mul<_R2::den / __gcd_n1_d2, _R1::den / __gcd_d1_n2>::value
N        >::type type;
N};
N
N#ifndef _LIBCPP_CXX03_LANG
N
Ntemplate <class _R1, class _R2> using ratio_multiply
N                                    = typename __ratio_multiply<_R1, _R2>::type;
N
N#else  // _LIBCPP_CXX03_LANG
S
Stemplate <class _R1, class _R2>
Sstruct _LIBCPP_TEMPLATE_VIS ratio_multiply
S    : public __ratio_multiply<_R1, _R2>::type {};
S
N#endif  // _LIBCPP_CXX03_LANG
N
Ntemplate <class _R1, class _R2>
Nstruct __ratio_divide
N{
Nprivate:
N    static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
N    static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
Npublic:
N    typedef typename ratio
N        <
N            __ll_mul<_R1::num / __gcd_n1_n2, _R2::den / __gcd_d1_d2>::value,
N            __ll_mul<_R2::num / __gcd_n1_n2, _R1::den / __gcd_d1_d2>::value
N        >::type type;
N};
N
N#ifndef _LIBCPP_CXX03_LANG
N
Ntemplate <class _R1, class _R2> using ratio_divide
N                                      = typename __ratio_divide<_R1, _R2>::type;
N
N#else  // _LIBCPP_CXX03_LANG
S
Stemplate <class _R1, class _R2>
Sstruct _LIBCPP_TEMPLATE_VIS ratio_divide
S    : public __ratio_divide<_R1, _R2>::type {};
S
N#endif  // _LIBCPP_CXX03_LANG
N
Ntemplate <class _R1, class _R2>
Nstruct __ratio_add
N{
Nprivate:
N    static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
N    static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
Npublic:
N    typedef typename ratio_multiply
N        <
N            ratio<__gcd_n1_n2, _R1::den / __gcd_d1_d2>,
N            ratio
N            <
N                __ll_add
N                <
N                    __ll_mul<_R1::num / __gcd_n1_n2, _R2::den / __gcd_d1_d2>::value,
N                    __ll_mul<_R2::num / __gcd_n1_n2, _R1::den / __gcd_d1_d2>::value
N                >::value,
N                _R2::den
N            >
N        >::type type;
N};
N
N#ifndef _LIBCPP_CXX03_LANG
N
Ntemplate <class _R1, class _R2> using ratio_add
N                                         = typename __ratio_add<_R1, _R2>::type;
N
N#else  // _LIBCPP_CXX03_LANG
S
Stemplate <class _R1, class _R2>
Sstruct _LIBCPP_TEMPLATE_VIS ratio_add
S    : public __ratio_add<_R1, _R2>::type {};
S
N#endif  // _LIBCPP_CXX03_LANG
N
Ntemplate <class _R1, class _R2>
Nstruct __ratio_subtract
N{
Nprivate:
N    static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
N    static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
Npublic:
N    typedef typename ratio_multiply
N        <
N            ratio<__gcd_n1_n2, _R1::den / __gcd_d1_d2>,
N            ratio
N            <
N                __ll_sub
N                <
N                    __ll_mul<_R1::num / __gcd_n1_n2, _R2::den / __gcd_d1_d2>::value,
N                    __ll_mul<_R2::num / __gcd_n1_n2, _R1::den / __gcd_d1_d2>::value
N                >::value,
N                _R2::den
N            >
N        >::type type;
N};
N
N#ifndef _LIBCPP_CXX03_LANG
N
Ntemplate <class _R1, class _R2> using ratio_subtract
N                                    = typename __ratio_subtract<_R1, _R2>::type;
N
N#else  // _LIBCPP_CXX03_LANG
S
Stemplate <class _R1, class _R2>
Sstruct _LIBCPP_TEMPLATE_VIS ratio_subtract
S    : public __ratio_subtract<_R1, _R2>::type {};
S
N#endif  // _LIBCPP_CXX03_LANG
N
N// ratio_equal
N
Ntemplate <class _R1, class _R2>
Nstruct _LIBCPP_TEMPLATE_VIS ratio_equal
Xstruct  ratio_equal
N    : public _LIBCPP_BOOL_CONSTANT((_R1::num == _R2::num && _R1::den == _R2::den)) {};
X    : public integral_constant<bool,((_R1::num == _R2::num && _R1::den == _R2::den))> {};
N
Ntemplate <class _R1, class _R2>
Nstruct _LIBCPP_TEMPLATE_VIS ratio_not_equal
Xstruct  ratio_not_equal
N    : public _LIBCPP_BOOL_CONSTANT((!ratio_equal<_R1, _R2>::value)) {};
X    : public integral_constant<bool,((!ratio_equal<_R1, _R2> ::value))> {};
N
N// ratio_less
N
Ntemplate <class _R1, class _R2, bool _Odd = false,
N          intmax_t _Q1 = _R1::num / _R1::den, intmax_t _M1 = _R1::num % _R1::den,
N          intmax_t _Q2 = _R2::num / _R2::den, intmax_t _M2 = _R2::num % _R2::den>
Nstruct __ratio_less1
N{
N    static const bool value = _Odd ? _Q2 < _Q1 : _Q1 < _Q2;
N};
N
Ntemplate <class _R1, class _R2, bool _Odd, intmax_t _Qp>
Nstruct __ratio_less1<_R1, _R2, _Odd, _Qp, 0, _Qp, 0>
N{
N    static const bool value = false;
N};
N
Ntemplate <class _R1, class _R2, bool _Odd, intmax_t _Qp, intmax_t _M2>
Nstruct __ratio_less1<_R1, _R2, _Odd, _Qp, 0, _Qp, _M2>
N{
N    static const bool value = !_Odd;
N};
N
Ntemplate <class _R1, class _R2, bool _Odd, intmax_t _Qp, intmax_t _M1>
Nstruct __ratio_less1<_R1, _R2, _Odd, _Qp, _M1, _Qp, 0>
N{
N    static const bool value = _Odd;
N};
N
Ntemplate <class _R1, class _R2, bool _Odd, intmax_t _Qp, intmax_t _M1,
N                                                        intmax_t _M2>
Nstruct __ratio_less1<_R1, _R2, _Odd, _Qp, _M1, _Qp, _M2>
N{
N    static const bool value = __ratio_less1<ratio<_R1::den, _M1>,
N                                            ratio<_R2::den, _M2>, !_Odd>::value;
N};
N
Ntemplate <class _R1, class _R2, intmax_t _S1 = __static_sign<_R1::num>::value,
N                                intmax_t _S2 = __static_sign<_R2::num>::value>
Nstruct __ratio_less
N{
N    static const bool value = _S1 < _S2;
N};
N
Ntemplate <class _R1, class _R2>
Nstruct __ratio_less<_R1, _R2, 1LL, 1LL>
N{
N    static const bool value = __ratio_less1<_R1, _R2>::value;
N};
N
Ntemplate <class _R1, class _R2>
Nstruct __ratio_less<_R1, _R2, -1LL, -1LL>
N{
N    static const bool value = __ratio_less1<ratio<-_R2::num, _R2::den>, ratio<-_R1::num, _R1::den> >::value;
N};
N
Ntemplate <class _R1, class _R2>
Nstruct _LIBCPP_TEMPLATE_VIS ratio_less
Xstruct  ratio_less
N    : public _LIBCPP_BOOL_CONSTANT((__ratio_less<_R1, _R2>::value)) {};
X    : public integral_constant<bool,((__ratio_less<_R1, _R2> ::value))> {};
N
Ntemplate <class _R1, class _R2>
Nstruct _LIBCPP_TEMPLATE_VIS ratio_less_equal
Xstruct  ratio_less_equal
N    : public _LIBCPP_BOOL_CONSTANT((!ratio_less<_R2, _R1>::value)) {};
X    : public integral_constant<bool,((!ratio_less<_R2, _R1> ::value))> {};
N
Ntemplate <class _R1, class _R2>
Nstruct _LIBCPP_TEMPLATE_VIS ratio_greater
Xstruct  ratio_greater
N    : public _LIBCPP_BOOL_CONSTANT((ratio_less<_R2, _R1>::value)) {};
X    : public integral_constant<bool,((ratio_less<_R2, _R1> ::value))> {};
N
Ntemplate <class _R1, class _R2>
Nstruct _LIBCPP_TEMPLATE_VIS ratio_greater_equal
Xstruct  ratio_greater_equal
N    : public _LIBCPP_BOOL_CONSTANT((!ratio_less<_R1, _R2>::value)) {};
X    : public integral_constant<bool,((!ratio_less<_R1, _R2> ::value))> {};
N
Ntemplate <class _R1, class _R2>
Nstruct __ratio_gcd
N{
N    typedef ratio<__static_gcd<_R1::num, _R2::num>::value,
N                  __static_lcm<_R1::den, _R2::den>::value> type;
N};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _R1, class _R2> _LIBCPP_CONSTEXPR bool ratio_equal_v
S    = ratio_equal<_R1, _R2>::value;
S
Stemplate <class _R1, class _R2> _LIBCPP_CONSTEXPR bool ratio_not_equal_v
S    = ratio_not_equal<_R1, _R2>::value;
S
Stemplate <class _R1, class _R2> _LIBCPP_CONSTEXPR bool ratio_less_v
S    = ratio_less<_R1, _R2>::value;
S
Stemplate <class _R1, class _R2> _LIBCPP_CONSTEXPR bool ratio_less_equal_v
S    = ratio_less_equal<_R1, _R2>::value;
S
Stemplate <class _R1, class _R2> _LIBCPP_CONSTEXPR bool ratio_greater_v
S    = ratio_greater<_R1, _R2>::value;
S
Stemplate <class _R1, class _R2> _LIBCPP_CONSTEXPR bool ratio_greater_equal_v
S    = ratio_greater_equal<_R1, _R2>::value;
N#endif
N
N_LIBCPP_END_NAMESPACE_STD
X} }
N
N_LIBCPP_POP_MACROS
X_Pragma("pop_macro(\"min\")") _Pragma("pop_macro(\"max\")")
N
N#endif  // _LIBCPP_RATIO
L 306 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/chrono" 2
N#include <limits>
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N_LIBCPP_PUSH_MACROS
X_Pragma("push_macro(\"min\")") _Pragma("push_macro(\"max\")")
N#include <__undef_macros>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/__undef_macros" 1
N// -*- C++ -*-
N//===------------------------ __undef_macros ------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is distributed under the University of Illinois Open Source
N// License. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N
N#ifdef min
S#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
S#if defined(_LIBCPP_WARNING)
S_LIBCPP_WARNING("macro min is incompatible with C++.  Try #define NOMINMAX "
S                "before any Windows header. #undefing min")
S#else
S#warning: macro min is incompatible with C++.  #undefing min
S#endif
S#endif
S#undef min
N#endif
N
N#ifdef max
S#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
S#if defined(_LIBCPP_WARNING)
S_LIBCPP_WARNING("macro max is incompatible with C++.  Try #define NOMINMAX "
S                "before any Windows header. #undefing max")
S#else
S#warning: macro max is incompatible with C++.  #undefing max
S#endif
S#endif
S#undef max
N#endif
L 314 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/chrono" 2
N
N
N_LIBCPP_BEGIN_NAMESPACE_STD
Xnamespace std { inline namespace __2 {
N
Nnamespace chrono
N{
N
Ntemplate <class _Rep, class _Period = ratio<1> > class _LIBCPP_TEMPLATE_VIS duration;
Xtemplate <class _Rep, class _Period = ratio<1> > class  duration;
N
Ntemplate <class _Tp>
Nstruct __is_duration : false_type {};
N
Ntemplate <class _Rep, class _Period>
Nstruct __is_duration<duration<_Rep, _Period> > : true_type  {};
N
Ntemplate <class _Rep, class _Period>
Nstruct __is_duration<const duration<_Rep, _Period> > : true_type  {};
N
Ntemplate <class _Rep, class _Period>
Nstruct __is_duration<volatile duration<_Rep, _Period> > : true_type  {};
N
Ntemplate <class _Rep, class _Period>
Nstruct __is_duration<const volatile duration<_Rep, _Period> > : true_type  {};
N
N} // chrono
N
Ntemplate <class _Rep1, class _Period1, class _Rep2, class _Period2>
Nstruct _LIBCPP_TEMPLATE_VIS common_type<chrono::duration<_Rep1, _Period1>,
Xstruct  common_type<chrono::duration<_Rep1, _Period1>,
N                                         chrono::duration<_Rep2, _Period2> >
N{
N    typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
N                             typename __ratio_gcd<_Period1, _Period2>::type> type;
N};
N
Nnamespace chrono {
N
N// duration_cast
N
Ntemplate <class _FromDuration, class _ToDuration,
N          class _Period = typename ratio_divide<typename _FromDuration::period, typename _ToDuration::period>::type,
N          bool = _Period::num == 1,
N          bool = _Period::den == 1>
Nstruct __duration_cast;
N
Ntemplate <class _FromDuration, class _ToDuration, class _Period>
Nstruct __duration_cast<_FromDuration, _ToDuration, _Period, true, true>
N{
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
X    __attribute__ ((__always_inline__)) constexpr
N    _ToDuration operator()(const _FromDuration& __fd) const
N    {
N        return _ToDuration(static_cast<typename _ToDuration::rep>(__fd.count()));
N    }
N};
N
Ntemplate <class _FromDuration, class _ToDuration, class _Period>
Nstruct __duration_cast<_FromDuration, _ToDuration, _Period, true, false>
N{
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
X    __attribute__ ((__always_inline__)) constexpr
N    _ToDuration operator()(const _FromDuration& __fd) const
N    {
N        typedef typename common_type<typename _ToDuration::rep, typename _FromDuration::rep, intmax_t>::type _Ct;
N        return _ToDuration(static_cast<typename _ToDuration::rep>(
N                           static_cast<_Ct>(__fd.count()) / static_cast<_Ct>(_Period::den)));
N    }
N};
N
Ntemplate <class _FromDuration, class _ToDuration, class _Period>
Nstruct __duration_cast<_FromDuration, _ToDuration, _Period, false, true>
N{
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
X    __attribute__ ((__always_inline__)) constexpr
N    _ToDuration operator()(const _FromDuration& __fd) const
N    {
N        typedef typename common_type<typename _ToDuration::rep, typename _FromDuration::rep, intmax_t>::type _Ct;
N        return _ToDuration(static_cast<typename _ToDuration::rep>(
N                           static_cast<_Ct>(__fd.count()) * static_cast<_Ct>(_Period::num)));
N    }
N};
N
Ntemplate <class _FromDuration, class _ToDuration, class _Period>
Nstruct __duration_cast<_FromDuration, _ToDuration, _Period, false, false>
N{
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
X    __attribute__ ((__always_inline__)) constexpr
N    _ToDuration operator()(const _FromDuration& __fd) const
N    {
N        typedef typename common_type<typename _ToDuration::rep, typename _FromDuration::rep, intmax_t>::type _Ct;
N        return _ToDuration(static_cast<typename _ToDuration::rep>(
N                           static_cast<_Ct>(__fd.count()) * static_cast<_Ct>(_Period::num)
N                                                          / static_cast<_Ct>(_Period::den)));
N    }
N};
N
Ntemplate <class _ToDuration, class _Rep, class _Period>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_LIBCPP_CONSTEXPR
Xconstexpr
Ntypename enable_if
N<
N    __is_duration<_ToDuration>::value,
N    _ToDuration
N>::type
Nduration_cast(const duration<_Rep, _Period>& __fd)
N{
N    return __duration_cast<duration<_Rep, _Period>, _ToDuration>()(__fd);
N}
N
Ntemplate <class _Rep>
Nstruct _LIBCPP_TEMPLATE_VIS treat_as_floating_point : is_floating_point<_Rep> {};
Xstruct  treat_as_floating_point : is_floating_point<_Rep> {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Rep> _LIBCPP_CONSTEXPR bool treat_as_floating_point_v
S    = treat_as_floating_point<_Rep>::value;
N#endif
N
Ntemplate <class _Rep>
Nstruct _LIBCPP_TEMPLATE_VIS duration_values
Xstruct  duration_values
N{
Npublic:
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR _Rep zero() {return _Rep(0);}
X    __attribute__ ((__always_inline__)) static constexpr _Rep zero() {return _Rep(0);}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR _Rep max()  {return numeric_limits<_Rep>::max();}
X    __attribute__ ((__always_inline__)) static constexpr _Rep max()  {return numeric_limits<_Rep>::max();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR _Rep min()  {return numeric_limits<_Rep>::lowest();}
X    __attribute__ ((__always_inline__)) static constexpr _Rep min()  {return numeric_limits<_Rep>::lowest();}
N};
N
N#if _LIBCPP_STD_VER > 14
X#if 14 > 14
Stemplate <class _ToDuration, class _Rep, class _Period>
Sinline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
Stypename enable_if
S<
S    __is_duration<_ToDuration>::value,
S    _ToDuration
S>::type
Sfloor(const duration<_Rep, _Period>& __d)
S{
S    _ToDuration __t = duration_cast<_ToDuration>(__d);
S    if (__t > __d)
S        __t = __t - _ToDuration{1};
S    return __t;
S}
S
Stemplate <class _ToDuration, class _Rep, class _Period>
Sinline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
Stypename enable_if
S<
S    __is_duration<_ToDuration>::value,
S    _ToDuration
S>::type
Sceil(const duration<_Rep, _Period>& __d)
S{
S    _ToDuration __t = duration_cast<_ToDuration>(__d);
S    if (__t < __d)
S        __t = __t + _ToDuration{1};
S    return __t;
S}
S
Stemplate <class _ToDuration, class _Rep, class _Period>
Sinline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
Stypename enable_if
S<
S    __is_duration<_ToDuration>::value,
S    _ToDuration
S>::type
Sround(const duration<_Rep, _Period>& __d)
S{
S    _ToDuration __lower = floor<_ToDuration>(__d);
S    _ToDuration __upper = __lower + _ToDuration{1};
S    auto __lowerDiff = __d - __lower;
S    auto __upperDiff = __upper - __d;
S    if (__lowerDiff < __upperDiff)
S        return __lower;
S    if (__lowerDiff > __upperDiff)
S        return __upper;
S    return __lower.count() & 1 ? __upper : __lower;
S}
N#endif
N
N// duration
N
Ntemplate <class _Rep, class _Period>
Nclass _LIBCPP_TEMPLATE_VIS duration
Xclass  duration
N{
N    static_assert(!__is_duration<_Rep>::value, "A duration representation can not be a duration");
N    static_assert(__is_ratio<_Period>::value, "Second template parameter of duration must be a std::ratio");
N    static_assert(_Period::num > 0, "duration period must be positive");
N
N    template <class _R1, class _R2>
N    struct __no_overflow
N    {
N    private:
N        static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
N        static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
N        static const intmax_t __n1 = _R1::num / __gcd_n1_n2;
N        static const intmax_t __d1 = _R1::den / __gcd_d1_d2;
N        static const intmax_t __n2 = _R2::num / __gcd_n1_n2;
N        static const intmax_t __d2 = _R2::den / __gcd_d1_d2;
N        static const intmax_t max = -((intmax_t(1) << (sizeof(intmax_t) * CHAR_BIT - 1)) + 1);
X        static const intmax_t max = -((intmax_t(1) << (sizeof(intmax_t) * 8 - 1)) + 1);
N
N        template <intmax_t _Xp, intmax_t _Yp, bool __overflow>
N        struct __mul    // __overflow == false
N        {
N            static const intmax_t value = _Xp * _Yp;
N        };
N
N        template <intmax_t _Xp, intmax_t _Yp>
N        struct __mul<_Xp, _Yp, true>
N        {
N            static const intmax_t value = 1;
N        };
N
N    public:
N        static const bool value = (__n1 <= max / __d2) && (__n2 <= max / __d1);
N        typedef ratio<__mul<__n1, __d2, !value>::value,
N                      __mul<__n2, __d1, !value>::value> type;
N    };
N    
Npublic:
N    typedef _Rep rep;
N    typedef typename _Period::type period;
Nprivate:
N    rep __rep_;
Npublic:
N
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
X    __attribute__ ((__always_inline__)) constexpr
N#ifndef _LIBCPP_CXX03_LANG
N        duration() = default;
N#else
S        duration() {}
N#endif
N
N    template <class _Rep2>
N        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
X        __attribute__ ((__always_inline__)) constexpr
N        explicit duration(const _Rep2& __r,
N            typename enable_if
N            <
N               is_convertible<_Rep2, rep>::value &&
N               (treat_as_floating_point<rep>::value ||
N               !treat_as_floating_point<_Rep2>::value)
N            >::type* = 0)
N                : __rep_(__r) {}
N
N    // conversions
N    template <class _Rep2, class _Period2>
N        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
X        __attribute__ ((__always_inline__)) constexpr
N        duration(const duration<_Rep2, _Period2>& __d,
N            typename enable_if
N            <
N                __no_overflow<_Period2, period>::value && (
N                treat_as_floating_point<rep>::value ||
N                (__no_overflow<_Period2, period>::type::den == 1 &&
N                 !treat_as_floating_point<_Rep2>::value))
N            >::type* = 0)
N                : __rep_(_VSTD::chrono::duration_cast<duration>(__d).count()) {}
X                : __rep_(std::__2::chrono::duration_cast<duration>(__d).count()) {}
N
N    // observer
N
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR rep count() const {return __rep_;}
X    __attribute__ ((__always_inline__)) constexpr rep count() const {return __rep_;}
N
N    // arithmetic
N
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR typename common_type<duration>::type operator+() const {return typename common_type<duration>::type(*this);}
X    __attribute__ ((__always_inline__)) constexpr typename common_type<duration>::type operator+() const {return typename common_type<duration>::type(*this);}
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR typename common_type<duration>::type operator-() const {return typename common_type<duration>::type(-__rep_);}
X    __attribute__ ((__always_inline__)) constexpr typename common_type<duration>::type operator-() const {return typename common_type<duration>::type(-__rep_);}
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 duration& operator++()      {++__rep_; return *this;}
X    __attribute__ ((__always_inline__))  duration& operator++()      {++__rep_; return *this;}
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 duration  operator++(int)   {return duration(__rep_++);}
X    __attribute__ ((__always_inline__))  duration  operator++(int)   {return duration(__rep_++);}
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 duration& operator--()      {--__rep_; return *this;}
X    __attribute__ ((__always_inline__))  duration& operator--()      {--__rep_; return *this;}
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 duration  operator--(int)   {return duration(__rep_--);}
X    __attribute__ ((__always_inline__))  duration  operator--(int)   {return duration(__rep_--);}
N
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 duration& operator+=(const duration& __d) {__rep_ += __d.count(); return *this;}
X    __attribute__ ((__always_inline__))  duration& operator+=(const duration& __d) {__rep_ += __d.count(); return *this;}
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 duration& operator-=(const duration& __d) {__rep_ -= __d.count(); return *this;}
X    __attribute__ ((__always_inline__))  duration& operator-=(const duration& __d) {__rep_ -= __d.count(); return *this;}
N
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 duration& operator*=(const rep& rhs) {__rep_ *= rhs; return *this;}
X    __attribute__ ((__always_inline__))  duration& operator*=(const rep& rhs) {__rep_ *= rhs; return *this;}
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 duration& operator/=(const rep& rhs) {__rep_ /= rhs; return *this;}
X    __attribute__ ((__always_inline__))  duration& operator/=(const rep& rhs) {__rep_ /= rhs; return *this;}
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 duration& operator%=(const rep& rhs) {__rep_ %= rhs; return *this;}
X    __attribute__ ((__always_inline__))  duration& operator%=(const rep& rhs) {__rep_ %= rhs; return *this;}
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 duration& operator%=(const duration& rhs) {__rep_ %= rhs.count(); return *this;}
X    __attribute__ ((__always_inline__))  duration& operator%=(const duration& rhs) {__rep_ %= rhs.count(); return *this;}
N
N    // special values
N
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR duration zero() {return duration(duration_values<rep>::zero());}
X    __attribute__ ((__always_inline__)) static constexpr duration zero() {return duration(duration_values<rep>::zero());}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR duration min()  {return duration(duration_values<rep>::min());}
X    __attribute__ ((__always_inline__)) static constexpr duration min()  {return duration(duration_values<rep>::min());}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR duration max()  {return duration(duration_values<rep>::max());}
X    __attribute__ ((__always_inline__)) static constexpr duration max()  {return duration(duration_values<rep>::max());}
N};
N
Ntypedef duration<long long,         nano> nanoseconds;
Ntypedef duration<long long,        micro> microseconds;
Ntypedef duration<long long,        milli> milliseconds;
Ntypedef duration<long long              > seconds;
Ntypedef duration<     long, ratio<  60> > minutes;
Ntypedef duration<     long, ratio<3600> > hours;
N
N// Duration ==
N
Ntemplate <class _LhsDuration, class _RhsDuration>
Nstruct __duration_eq
N{
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
X    __attribute__ ((__always_inline__)) constexpr
N    bool operator()(const _LhsDuration& __lhs, const _RhsDuration& __rhs) const
N        {
N            typedef typename common_type<_LhsDuration, _RhsDuration>::type _Ct;
N            return _Ct(__lhs).count() == _Ct(__rhs).count();
N        }
N};
N
Ntemplate <class _LhsDuration>
Nstruct __duration_eq<_LhsDuration, _LhsDuration>
N{
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
X    __attribute__ ((__always_inline__)) constexpr
N    bool operator()(const _LhsDuration& __lhs, const _LhsDuration& __rhs) const
N        {return __lhs.count() == __rhs.count();}
N};
N
Ntemplate <class _Rep1, class _Period1, class _Rep2, class _Period2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_LIBCPP_CONSTEXPR
Xconstexpr
Nbool
Noperator==(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
N{
N    return __duration_eq<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >()(__lhs, __rhs);
N}
N
N// Duration !=
N
Ntemplate <class _Rep1, class _Period1, class _Rep2, class _Period2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_LIBCPP_CONSTEXPR
Xconstexpr
Nbool
Noperator!=(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
N{
N    return !(__lhs == __rhs);
N}
N
N// Duration <
N
Ntemplate <class _LhsDuration, class _RhsDuration>
Nstruct __duration_lt
N{
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
X    __attribute__ ((__always_inline__)) constexpr
N    bool operator()(const _LhsDuration& __lhs, const _RhsDuration& __rhs) const
N        {
N            typedef typename common_type<_LhsDuration, _RhsDuration>::type _Ct;
N            return _Ct(__lhs).count() < _Ct(__rhs).count();
N        }
N};
N
Ntemplate <class _LhsDuration>
Nstruct __duration_lt<_LhsDuration, _LhsDuration>
N{
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
X    __attribute__ ((__always_inline__)) constexpr
N    bool operator()(const _LhsDuration& __lhs, const _LhsDuration& __rhs) const
N        {return __lhs.count() < __rhs.count();}
N};
N
Ntemplate <class _Rep1, class _Period1, class _Rep2, class _Period2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_LIBCPP_CONSTEXPR
Xconstexpr
Nbool
Noperator< (const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
N{
N    return __duration_lt<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >()(__lhs, __rhs);
N}
N
N// Duration >
N
Ntemplate <class _Rep1, class _Period1, class _Rep2, class _Period2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_LIBCPP_CONSTEXPR
Xconstexpr
Nbool
Noperator> (const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
N{
N    return __rhs < __lhs;
N}
N
N// Duration <=
N
Ntemplate <class _Rep1, class _Period1, class _Rep2, class _Period2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_LIBCPP_CONSTEXPR
Xconstexpr
Nbool
Noperator<=(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
N{
N    return !(__rhs < __lhs);
N}
N
N// Duration >=
N
Ntemplate <class _Rep1, class _Period1, class _Rep2, class _Period2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_LIBCPP_CONSTEXPR
Xconstexpr
Nbool
Noperator>=(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
N{
N    return !(__lhs < __rhs);
N}
N
N// Duration +
N
Ntemplate <class _Rep1, class _Period1, class _Rep2, class _Period2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_LIBCPP_CONSTEXPR
Xconstexpr
Ntypename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type
Noperator+(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
N{
N    typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Cd;
N    return _Cd(_Cd(__lhs).count() + _Cd(__rhs).count());
N}
N
N// Duration -
N
Ntemplate <class _Rep1, class _Period1, class _Rep2, class _Period2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_LIBCPP_CONSTEXPR
Xconstexpr
Ntypename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type
Noperator-(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
N{
N    typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Cd;
N    return _Cd(_Cd(__lhs).count() - _Cd(__rhs).count());
N}
N
N// Duration *
N
Ntemplate <class _Rep1, class _Period, class _Rep2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_LIBCPP_CONSTEXPR
Xconstexpr
Ntypename enable_if
N<
N    is_convertible<_Rep2, typename common_type<_Rep1, _Rep2>::type>::value,
N    duration<typename common_type<_Rep1, _Rep2>::type, _Period>
N>::type
Noperator*(const duration<_Rep1, _Period>& __d, const _Rep2& __s)
N{
N    typedef typename common_type<_Rep1, _Rep2>::type _Cr;
N    typedef duration<_Cr, _Period> _Cd;
N    return _Cd(_Cd(__d).count() * static_cast<_Cr>(__s));
N}
N
Ntemplate <class _Rep1, class _Period, class _Rep2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_LIBCPP_CONSTEXPR
Xconstexpr
Ntypename enable_if
N<
N    is_convertible<_Rep1, typename common_type<_Rep1, _Rep2>::type>::value,
N    duration<typename common_type<_Rep1, _Rep2>::type, _Period>
N>::type
Noperator*(const _Rep1& __s, const duration<_Rep2, _Period>& __d)
N{
N    return __d * __s;
N}
N
N// Duration /
N
Ntemplate <class _Duration, class _Rep, bool = __is_duration<_Rep>::value>
Nstruct __duration_divide_result
N{
N};
N
Ntemplate <class _Duration, class _Rep2,
N    bool = is_convertible<_Rep2,
N                          typename common_type<typename _Duration::rep, _Rep2>::type>::value>
Nstruct __duration_divide_imp
N{
N};
N
Ntemplate <class _Rep1, class _Period, class _Rep2>
Nstruct __duration_divide_imp<duration<_Rep1, _Period>, _Rep2, true>
N{
N    typedef duration<typename common_type<_Rep1, _Rep2>::type, _Period> type;
N};
N
Ntemplate <class _Rep1, class _Period, class _Rep2>
Nstruct __duration_divide_result<duration<_Rep1, _Period>, _Rep2, false>
N    : __duration_divide_imp<duration<_Rep1, _Period>, _Rep2>
N{
N};
N
Ntemplate <class _Rep1, class _Period, class _Rep2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_LIBCPP_CONSTEXPR
Xconstexpr
Ntypename __duration_divide_result<duration<_Rep1, _Period>, _Rep2>::type
Noperator/(const duration<_Rep1, _Period>& __d, const _Rep2& __s)
N{
N    typedef typename common_type<_Rep1, _Rep2>::type _Cr;
N    typedef duration<_Cr, _Period> _Cd;
N    return _Cd(_Cd(__d).count() / static_cast<_Cr>(__s));
N}
N
Ntemplate <class _Rep1, class _Period1, class _Rep2, class _Period2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_LIBCPP_CONSTEXPR
Xconstexpr
Ntypename common_type<_Rep1, _Rep2>::type
Noperator/(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
N{
N    typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Ct;
N    return _Ct(__lhs).count() / _Ct(__rhs).count();
N}
N
N// Duration %
N
Ntemplate <class _Rep1, class _Period, class _Rep2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_LIBCPP_CONSTEXPR
Xconstexpr
Ntypename __duration_divide_result<duration<_Rep1, _Period>, _Rep2>::type
Noperator%(const duration<_Rep1, _Period>& __d, const _Rep2& __s)
N{
N    typedef typename common_type<_Rep1, _Rep2>::type _Cr;
N    typedef duration<_Cr, _Period> _Cd;
N    return _Cd(_Cd(__d).count() % static_cast<_Cr>(__s));
N}
N
Ntemplate <class _Rep1, class _Period1, class _Rep2, class _Period2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_LIBCPP_CONSTEXPR
Xconstexpr
Ntypename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type
Noperator%(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
N{
N    typedef typename common_type<_Rep1, _Rep2>::type _Cr;
N    typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Cd;
N    return _Cd(static_cast<_Cr>(_Cd(__lhs).count()) % static_cast<_Cr>(_Cd(__rhs).count()));
N}
N
N//////////////////////////////////////////////////////////
N///////////////////// time_point /////////////////////////
N//////////////////////////////////////////////////////////
N
Ntemplate <class _Clock, class _Duration = typename _Clock::duration>
Nclass _LIBCPP_TEMPLATE_VIS time_point
Xclass  time_point
N{
N    static_assert(__is_duration<_Duration>::value,
N                  "Second template parameter of time_point must be a std::chrono::duration");
Npublic:
N    typedef _Clock                    clock;
N    typedef _Duration                 duration;
N    typedef typename duration::rep    rep;
N    typedef typename duration::period period;
Nprivate:
N    duration __d_;
N
Npublic:
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 time_point() : __d_(duration::zero()) {}
X    __attribute__ ((__always_inline__)) constexpr time_point() : __d_(duration::zero()) {}
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 explicit time_point(const duration& __d) : __d_(__d) {}
X    __attribute__ ((__always_inline__)) constexpr explicit time_point(const duration& __d) : __d_(__d) {}
N
N    // conversions
N    template <class _Duration2>
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
X    __attribute__ ((__always_inline__)) constexpr
N    time_point(const time_point<clock, _Duration2>& t,
N        typename enable_if
N        <
N            is_convertible<_Duration2, duration>::value
N        >::type* = 0)
N            : __d_(t.time_since_epoch()) {}
N
N    // observer
N
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 duration time_since_epoch() const {return __d_;}
X    __attribute__ ((__always_inline__)) constexpr duration time_since_epoch() const {return __d_;}
N
N    // arithmetic
N
N    _LIBCPP_INLINE_VISIBILITY time_point& operator+=(const duration& __d) {__d_ += __d; return *this;}
X    __attribute__ ((__always_inline__)) time_point& operator+=(const duration& __d) {__d_ += __d; return *this;}
N    _LIBCPP_INLINE_VISIBILITY time_point& operator-=(const duration& __d) {__d_ -= __d; return *this;}
X    __attribute__ ((__always_inline__)) time_point& operator-=(const duration& __d) {__d_ -= __d; return *this;}
N
N    // special values
N
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR time_point min() {return time_point(duration::min());}
X    __attribute__ ((__always_inline__)) static constexpr time_point min() {return time_point(duration::min());}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR time_point max() {return time_point(duration::max());}
X    __attribute__ ((__always_inline__)) static constexpr time_point max() {return time_point(duration::max());}
N};
N
N} // chrono
N
Ntemplate <class _Clock, class _Duration1, class _Duration2>
Nstruct _LIBCPP_TEMPLATE_VIS common_type<chrono::time_point<_Clock, _Duration1>,
Xstruct  common_type<chrono::time_point<_Clock, _Duration1>,
N                                         chrono::time_point<_Clock, _Duration2> >
N{
N    typedef chrono::time_point<_Clock, typename common_type<_Duration1, _Duration2>::type> type;
N};
N
Nnamespace chrono {
N
Ntemplate <class _ToDuration, class _Clock, class _Duration>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
Xinline __attribute__ ((__always_inline__)) constexpr
Ntime_point<_Clock, _ToDuration>
Ntime_point_cast(const time_point<_Clock, _Duration>& __t)
N{
N    return time_point<_Clock, _ToDuration>(_VSTD::chrono::duration_cast<_ToDuration>(__t.time_since_epoch()));
X    return time_point<_Clock, _ToDuration>(std::__2::chrono::duration_cast<_ToDuration>(__t.time_since_epoch()));
N}
N
N#if _LIBCPP_STD_VER > 14
X#if 14 > 14
Stemplate <class _ToDuration, class _Clock, class _Duration>
Sinline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
Stypename enable_if
S<
S    __is_duration<_ToDuration>::value,
S    time_point<_Clock, _ToDuration>
S>::type
Sfloor(const time_point<_Clock, _Duration>& __t)
S{
S    return time_point<_Clock, _ToDuration>{floor<_ToDuration>(__t.time_since_epoch())};
S}
S
Stemplate <class _ToDuration, class _Clock, class _Duration>
Sinline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
Stypename enable_if
S<
S    __is_duration<_ToDuration>::value,
S    time_point<_Clock, _ToDuration>
S>::type
Sceil(const time_point<_Clock, _Duration>& __t)
S{
S    return time_point<_Clock, _ToDuration>{ceil<_ToDuration>(__t.time_since_epoch())};
S}
S
Stemplate <class _ToDuration, class _Clock, class _Duration>
Sinline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
Stypename enable_if
S<
S    __is_duration<_ToDuration>::value,
S    time_point<_Clock, _ToDuration>
S>::type
Sround(const time_point<_Clock, _Duration>& __t)
S{
S    return time_point<_Clock, _ToDuration>{round<_ToDuration>(__t.time_since_epoch())};
S}
S
Stemplate <class _Rep, class _Period>
Sinline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
Stypename enable_if
S<
S    numeric_limits<_Rep>::is_signed,
S    duration<_Rep, _Period>
S>::type
Sabs(duration<_Rep, _Period> __d)
S{
S    return __d >= __d.zero() ? __d : -__d;
S}
N#endif
N
N// time_point ==
N
Ntemplate <class _Clock, class _Duration1, class _Duration2>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
Xinline __attribute__ ((__always_inline__)) constexpr
Nbool
Noperator==(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
N{
N    return __lhs.time_since_epoch() == __rhs.time_since_epoch();
N}
N
N// time_point !=
N
Ntemplate <class _Clock, class _Duration1, class _Duration2>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
Xinline __attribute__ ((__always_inline__)) constexpr
Nbool
Noperator!=(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
N{
N    return !(__lhs == __rhs);
N}
N
N// time_point <
N
Ntemplate <class _Clock, class _Duration1, class _Duration2>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
Xinline __attribute__ ((__always_inline__)) constexpr
Nbool
Noperator<(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
N{
N    return __lhs.time_since_epoch() < __rhs.time_since_epoch();
N}
N
N// time_point >
N
Ntemplate <class _Clock, class _Duration1, class _Duration2>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
Xinline __attribute__ ((__always_inline__)) constexpr
Nbool
Noperator>(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
N{
N    return __rhs < __lhs;
N}
N
N// time_point <=
N
Ntemplate <class _Clock, class _Duration1, class _Duration2>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
Xinline __attribute__ ((__always_inline__)) constexpr
Nbool
Noperator<=(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
N{
N    return !(__rhs < __lhs);
N}
N
N// time_point >=
N
Ntemplate <class _Clock, class _Duration1, class _Duration2>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
Xinline __attribute__ ((__always_inline__)) constexpr
Nbool
Noperator>=(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
N{
N    return !(__lhs < __rhs);
N}
N
N// time_point operator+(time_point x, duration y);
N
Ntemplate <class _Clock, class _Duration1, class _Rep2, class _Period2>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
Xinline __attribute__ ((__always_inline__)) constexpr
Ntime_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type>
Noperator+(const time_point<_Clock, _Duration1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
N{
N    typedef time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type> _Tr;
N    return _Tr (__lhs.time_since_epoch() + __rhs);
N}
N
N// time_point operator+(duration x, time_point y);
N
Ntemplate <class _Rep1, class _Period1, class _Clock, class _Duration2>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
Xinline __attribute__ ((__always_inline__)) constexpr
Ntime_point<_Clock, typename common_type<duration<_Rep1, _Period1>, _Duration2>::type>
Noperator+(const duration<_Rep1, _Period1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
N{
N    return __rhs + __lhs;
N}
N
N// time_point operator-(time_point x, duration y);
N
Ntemplate <class _Clock, class _Duration1, class _Rep2, class _Period2>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
Xinline __attribute__ ((__always_inline__)) constexpr
Ntime_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type>
Noperator-(const time_point<_Clock, _Duration1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
N{
N    typedef time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type> _Ret;
N    return _Ret(__lhs.time_since_epoch() -__rhs);
N}
N
N// duration operator-(time_point x, time_point y);
N
Ntemplate <class _Clock, class _Duration1, class _Duration2>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
Xinline __attribute__ ((__always_inline__)) constexpr
Ntypename common_type<_Duration1, _Duration2>::type
Noperator-(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
N{
N    return __lhs.time_since_epoch() - __rhs.time_since_epoch();
N}
N
N//////////////////////////////////////////////////////////
N/////////////////////// clocks ///////////////////////////
N//////////////////////////////////////////////////////////
N
Nclass _LIBCPP_TYPE_VIS system_clock
Xclass  system_clock
N{
Npublic:
N    typedef microseconds                     duration;
N    typedef duration::rep                    rep;
N    typedef duration::period                 period;
N    typedef chrono::time_point<system_clock> time_point;
N    static _LIBCPP_CONSTEXPR_AFTER_CXX11 const bool is_steady = false;
X    static constexpr const bool is_steady = false;
N
N    static time_point now() _NOEXCEPT;
X    static time_point now() noexcept;
N    static time_t     to_time_t  (const time_point& __t) _NOEXCEPT;
X    static time_t     to_time_t  (const time_point& __t) noexcept;
N    static time_point from_time_t(time_t __t) _NOEXCEPT;
X    static time_point from_time_t(time_t __t) noexcept;
N};
N
N#ifndef _LIBCPP_HAS_NO_MONOTONIC_CLOCK
Nclass _LIBCPP_TYPE_VIS steady_clock
Xclass  steady_clock
N{
Npublic:
N    typedef nanoseconds                                   duration;
N    typedef duration::rep                                 rep;
N    typedef duration::period                              period;
N    typedef chrono::time_point<steady_clock, duration>    time_point;
N    static _LIBCPP_CONSTEXPR_AFTER_CXX11 const bool is_steady = true;
X    static constexpr const bool is_steady = true;
N
N    static time_point now() _NOEXCEPT;
X    static time_point now() noexcept;
N};
N
Ntypedef steady_clock high_resolution_clock;
N#else
Stypedef system_clock high_resolution_clock;
N#endif
N
N} // chrono
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
N// Suffixes for duration literals [time.duration.literals]
Ninline namespace literals
N{ 
N  inline namespace chrono_literals
N  {
N
N    constexpr chrono::hours operator""h(unsigned long long __h)
N    {
N        return chrono::hours(static_cast<chrono::hours::rep>(__h));
N    }
N
N    constexpr chrono::duration<long double, ratio<3600,1>> operator""h(long double __h)
N    {
N        return chrono::duration<long double, ratio<3600,1>>(__h);
N    }
N
N
N    constexpr chrono::minutes operator""min(unsigned long long __m)
N    {
N        return chrono::minutes(static_cast<chrono::minutes::rep>(__m));
N    }
N
N    constexpr chrono::duration<long double, ratio<60,1>> operator""min(long double __m)
N    {
N        return chrono::duration<long double, ratio<60,1>> (__m);
N    }
N
N
N    constexpr chrono::seconds operator""s(unsigned long long __s)
N    {
N        return chrono::seconds(static_cast<chrono::seconds::rep>(__s));
N    }
N
N    constexpr chrono::duration<long double> operator""s(long double __s)
N    {
N        return chrono::duration<long double> (__s);
N    }
N
N
N    constexpr chrono::milliseconds operator""ms(unsigned long long __ms)
N    {
N        return chrono::milliseconds(static_cast<chrono::milliseconds::rep>(__ms));
N    }
N
N    constexpr chrono::duration<long double, milli> operator""ms(long double __ms)
N    {
N        return chrono::duration<long double, milli>(__ms);
N    }
N
N
N    constexpr chrono::microseconds operator""us(unsigned long long __us)
N    {
N        return chrono::microseconds(static_cast<chrono::microseconds::rep>(__us));
N    }
N
N    constexpr chrono::duration<long double, micro> operator""us(long double __us)
N    {
N        return chrono::duration<long double, micro> (__us);
N    }
N    
N
N    constexpr chrono::nanoseconds operator""ns(unsigned long long __ns)
N    {
N        return chrono::nanoseconds(static_cast<chrono::nanoseconds::rep>(__ns));
N    }
N
N    constexpr chrono::duration<long double, nano> operator""ns(long double __ns)
N    {
N        return chrono::duration<long double, nano> (__ns);
N    }
N
N}}
N
Nnamespace chrono { // hoist the literals into namespace std::chrono
N   using namespace literals::chrono_literals;
N}
N
N#endif
N
N_LIBCPP_END_NAMESPACE_STD
X} }
N
N_LIBCPP_POP_MACROS
X_Pragma("pop_macro(\"min\")") _Pragma("pop_macro(\"max\")")
N
N#endif  // _LIBCPP_CHRONO
L 16 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/__mutex_base" 2
N#include <system_error>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/system_error" 1
N// -*- C++ -*-
N//===---------------------------- system_error ----------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is dual licensed under the MIT and the University of Illinois Open
N// Source Licenses. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP_SYSTEM_ERROR
N#define _LIBCPP_SYSTEM_ERROR
N
N/*
N    system_error synopsis
N
Nnamespace std
N{
N
Nclass error_category
N{
Npublic:
N    virtual ~error_category() noexcept;
N
N    constexpr error_category();
N    error_category(const error_category&) = delete;
N    error_category& operator=(const error_category&) = delete;
N
N    virtual const char* name() const noexcept = 0;
N    virtual error_condition default_error_condition(int ev) const noexcept;
N    virtual bool equivalent(int code, const error_condition& condition) const noexcept;
N    virtual bool equivalent(const error_code& code, int condition) const noexcept;
N    virtual string message(int ev) const = 0;
N
N    bool operator==(const error_category& rhs) const noexcept;
N    bool operator!=(const error_category& rhs) const noexcept;
N    bool operator<(const error_category& rhs) const noexcept;
N};
N
Nconst error_category& generic_category() noexcept;
Nconst error_category& system_category() noexcept;
N
Ntemplate <class T> struct is_error_code_enum
N    : public false_type {};
N
Ntemplate <class T> struct is_error_condition_enum
N    : public false_type {};
N
Ntemplate <class _Tp>
Nconstexpr size_t is_error_condition_enum_v = is_error_condition_enum<_Tp>::value; // C++17
N
Ntemplate <class _Tp>
Nconstexpr size_t is_error_code_enum_v = is_error_code_enum<_Tp>::value; // C++17
N
Nclass error_code
N{
Npublic:
N    // constructors:
N    error_code() noexcept;
N    error_code(int val, const error_category& cat) noexcept;
N    template <class ErrorCodeEnum>
N        error_code(ErrorCodeEnum e) noexcept;
N
N    // modifiers:
N    void assign(int val, const error_category& cat) noexcept;
N    template <class ErrorCodeEnum>
N        error_code& operator=(ErrorCodeEnum e) noexcept;
N    void clear() noexcept;
N
N    // observers:
N    int value() const noexcept;
N    const error_category& category() const noexcept;
N    error_condition default_error_condition() const noexcept;
N    string message() const;
N    explicit operator bool() const noexcept;
N};
N
N// non-member functions:
Nbool operator<(const error_code& lhs, const error_code& rhs) noexcept;
Ntemplate <class charT, class traits>
N    basic_ostream<charT,traits>&
N    operator<<(basic_ostream<charT,traits>& os, const error_code& ec);
N
Nclass error_condition
N{
Npublic:
N    // constructors:
N    error_condition() noexcept;
N    error_condition(int val, const error_category& cat) noexcept;
N    template <class ErrorConditionEnum>
N        error_condition(ErrorConditionEnum e) noexcept;
N
N    // modifiers:
N    void assign(int val, const error_category& cat) noexcept;
N    template <class ErrorConditionEnum>
N        error_condition& operator=(ErrorConditionEnum e) noexcept;
N    void clear() noexcept;
N
N    // observers:
N    int value() const noexcept;
N    const error_category& category() const noexcept;
N    string message() const noexcept;
N    explicit operator bool() const noexcept;
N};
N
Nbool operator<(const error_condition& lhs, const error_condition& rhs) noexcept;
N
Nclass system_error
N    : public runtime_error
N{
Npublic:
N    system_error(error_code ec, const string& what_arg);
N    system_error(error_code ec, const char* what_arg);
N    system_error(error_code ec);
N    system_error(int ev, const error_category& ecat, const string& what_arg);
N    system_error(int ev, const error_category& ecat, const char* what_arg);
N    system_error(int ev, const error_category& ecat);
N
N    const error_code& code() const noexcept;
N    const char* what() const noexcept;
N};
N
Nenum class errc
N{
N    address_family_not_supported,       // EAFNOSUPPORT
N    address_in_use,                     // EADDRINUSE
N    address_not_available,              // EADDRNOTAVAIL
N    already_connected,                  // EISCONN
N    argument_list_too_long,             // E2BIG
N    argument_out_of_domain,             // EDOM
N    bad_address,                        // EFAULT
N    bad_file_descriptor,                // EBADF
N    bad_message,                        // EBADMSG
N    broken_pipe,                        // EPIPE
N    connection_aborted,                 // ECONNABORTED
N    connection_already_in_progress,     // EALREADY
N    connection_refused,                 // ECONNREFUSED
N    connection_reset,                   // ECONNRESET
N    cross_device_link,                  // EXDEV
N    destination_address_required,       // EDESTADDRREQ
N    device_or_resource_busy,            // EBUSY
N    directory_not_empty,                // ENOTEMPTY
N    executable_format_error,            // ENOEXEC
N    file_exists,                        // EEXIST
N    file_too_large,                     // EFBIG
N    filename_too_long,                  // ENAMETOOLONG
N    function_not_supported,             // ENOSYS
N    host_unreachable,                   // EHOSTUNREACH
N    identifier_removed,                 // EIDRM
N    illegal_byte_sequence,              // EILSEQ
N    inappropriate_io_control_operation, // ENOTTY
N    interrupted,                        // EINTR
N    invalid_argument,                   // EINVAL
N    invalid_seek,                       // ESPIPE
N    io_error,                           // EIO
N    is_a_directory,                     // EISDIR
N    message_size,                       // EMSGSIZE
N    network_down,                       // ENETDOWN
N    network_reset,                      // ENETRESET
N    network_unreachable,                // ENETUNREACH
N    no_buffer_space,                    // ENOBUFS
N    no_child_process,                   // ECHILD
N    no_link,                            // ENOLINK
N    no_lock_available,                  // ENOLCK
N    no_message_available,               // ENODATA
N    no_message,                         // ENOMSG
N    no_protocol_option,                 // ENOPROTOOPT
N    no_space_on_device,                 // ENOSPC
N    no_stream_resources,                // ENOSR
N    no_such_device_or_address,          // ENXIO
N    no_such_device,                     // ENODEV
N    no_such_file_or_directory,          // ENOENT
N    no_such_process,                    // ESRCH
N    not_a_directory,                    // ENOTDIR
N    not_a_socket,                       // ENOTSOCK
N    not_a_stream,                       // ENOSTR
N    not_connected,                      // ENOTCONN
N    not_enough_memory,                  // ENOMEM
N    not_supported,                      // ENOTSUP
N    operation_canceled,                 // ECANCELED
N    operation_in_progress,              // EINPROGRESS
N    operation_not_permitted,            // EPERM
N    operation_not_supported,            // EOPNOTSUPP
N    operation_would_block,              // EWOULDBLOCK
N    owner_dead,                         // EOWNERDEAD
N    permission_denied,                  // EACCES
N    protocol_error,                     // EPROTO
N    protocol_not_supported,             // EPROTONOSUPPORT
N    read_only_file_system,              // EROFS
N    resource_deadlock_would_occur,      // EDEADLK
N    resource_unavailable_try_again,     // EAGAIN
N    result_out_of_range,                // ERANGE
N    state_not_recoverable,              // ENOTRECOVERABLE
N    stream_timeout,                     // ETIME
N    text_file_busy,                     // ETXTBSY
N    timed_out,                          // ETIMEDOUT
N    too_many_files_open_in_system,      // ENFILE
N    too_many_files_open,                // EMFILE
N    too_many_links,                     // EMLINK
N    too_many_symbolic_link_levels,      // ELOOP
N    value_too_large,                    // EOVERFLOW
N    wrong_protocol_type                 // EPROTOTYPE
N};
N
Ntemplate <> struct is_error_condition_enum<errc>
N    : true_type { }
N
Nerror_code make_error_code(errc e) noexcept;
Nerror_condition make_error_condition(errc e) noexcept;
N
N// Comparison operators:
Nbool operator==(const error_code& lhs, const error_code& rhs) noexcept;
Nbool operator==(const error_code& lhs, const error_condition& rhs) noexcept;
Nbool operator==(const error_condition& lhs, const error_code& rhs) noexcept;
Nbool operator==(const error_condition& lhs, const error_condition& rhs) noexcept;
Nbool operator!=(const error_code& lhs, const error_code& rhs) noexcept;
Nbool operator!=(const error_code& lhs, const error_condition& rhs) noexcept;
Nbool operator!=(const error_condition& lhs, const error_code& rhs) noexcept;
Nbool operator!=(const error_condition& lhs, const error_condition& rhs) noexcept;
N
Ntemplate <> struct hash<std::error_code>;
Ntemplate <> struct hash<std::error_condition>;
N
N}  // std
N
N*/
N
N#include <__config>
N#include <cerrno>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/cerrno" 1
N// -*- C++ -*-
N//===-------------------------- cerrno ------------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is dual licensed under the MIT and the University of Illinois Open
N// Source Licenses. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP_CERRNO
N#define _LIBCPP_CERRNO
N
N/*
N    cerrno synopsis
N
NMacros:
N
N    EDOM
N    EILSEQ  // C99
N    ERANGE
N    errno
N
N*/
N
N#include <__config>
N#include <errno.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/errno.h" 1
N/* -*- C++ -*- */
N/*===--------------------------- complex.h --------------------------------===*/
N/*                                                                            */
N/*                     The LLVM Compiler Infrastructure                       */
N/*                                                                            */
N/* This file is dual licensed under the MIT and the University of Illinois Open
N** Source Licenses. See LICENSE.TXT for details.
N*/
N/*===----------------------------------------------------------------------===*/
N
N#ifndef _LIBCPP_ERRNO_H
N#define _LIBCPP_ERRNO_H
N
N/*
N    errno.h synopsis
N
NMacros:
N
N    EDOM
N    EILSEQ  // C99
N    ERANGE
N    errno
N
N*/
N
N#include <__config>
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N#include_next <errno.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/errno.h" 1
N/*****************************************************************************/
N/*  ERRNO.H                                                                  */
N/*                                                                           */
N/* Copyright (c) 1995 Texas Instruments Incorporated                         */
N/* http://www.ti.com/                                                        */
N/*                                                                           */
N/*  Redistribution and  use in source  and binary forms, with  or without    */
N/*  modification,  are permitted provided  that the  following conditions    */
N/*  are met:                                                                 */
N/*                                                                           */
N/*     Redistributions  of source  code must  retain the  above copyright    */
N/*     notice, this list of conditions and the following disclaimer.         */
N/*                                                                           */
N/*     Redistributions in binary form  must reproduce the above copyright    */
N/*     notice, this  list of conditions  and the following  disclaimer in    */
N/*     the  documentation  and/or   other  materials  provided  with  the    */
N/*     distribution.                                                         */
N/*                                                                           */
N/*     Neither the  name of Texas Instruments Incorporated  nor the names    */
N/*     of its  contributors may  be used to  endorse or  promote products    */
N/*     derived  from   this  software  without   specific  prior  written    */
N/*     permission.                                                           */
N/*                                                                           */
N/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS    */
N/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT    */
N/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    */
N/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT    */
N/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    */
N/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT    */
N/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    */
N/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    */
N/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT    */
N/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    */
N/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     */
N/*                                                                           */
N/*****************************************************************************/
N
N#ifndef _ERRNO
N#define _ERRNO
N
N#if defined(__TMS320C2000__)
X#if 0L
S#if defined(__TMS320C28XX_CLA__)
S#error "Header file <errno.h> not supported by CLA compiler"
S#endif
N#endif
N
N#pragma diag_push
N#pragma CHECK_MISRA("-6.3") /* standard types required for standard headers */
N#pragma CHECK_MISRA("-19.1") /* #includes required for implementation */
N#pragma CHECK_MISRA("-20.1") /* standard headers must define standard names */
N#pragma CHECK_MISRA("-20.2") /* standard headers must define standard names */
N
N#ifdef __cplusplus
Nextern "C"
N{
N#endif /* __cplusplus */
N
N#include <_ti_config.h>
N#include <_tls.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/_tls.h" 1
N/*****************************************************************************/
N/*  _tls.h                                                                   */
N/*                                                                           */
N/* Copyright (c) 2012 Texas Instruments Incorporated                         */
N/* http://www.ti.com/                                                        */
N/*                                                                           */
N/*  Redistribution and  use in source  and binary forms, with  or without    */
N/*  modification,  are permitted provided  that the  following conditions    */
N/*  are met:                                                                 */
N/*                                                                           */
N/*     Redistributions  of source  code must  retain the  above copyright    */
N/*     notice, this list of conditions and the following disclaimer.         */
N/*                                                                           */
N/*     Redistributions in binary form  must reproduce the above copyright    */
N/*     notice, this  list of conditions  and the following  disclaimer in    */
N/*     the  documentation  and/or   other  materials  provided  with  the    */
N/*     distribution.                                                         */
N/*                                                                           */
N/*     Neither the  name of Texas Instruments Incorporated  nor the names    */
N/*     of its  contributors may  be used to  endorse or  promote products    */
N/*     derived  from   this  software  without   specific  prior  written    */
N/*     permission.                                                           */
N/*                                                                           */
N/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS    */
N/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT    */
N/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    */
N/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT    */
N/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    */
N/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT    */
N/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    */
N/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    */
N/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT    */
N/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    */
N/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     */
N/*                                                                           */
N/*****************************************************************************/
N#ifndef __TLS_H
N#define __TLS_H
N
N#include <_ti_config.h>
N
N#pragma diag_push
N#pragma CHECK_MISRA("-19.4") /* macros required for implementation */
N#pragma CHECK_MISRA("-19.7") /* macros required for implementation */
N#pragma CHECK_MISRA("-19.10") /* need types as macro arguments */
N
N/*****************************************************************************/
N/* __TI_TLS__ - parser-generated symbol indicates compiler support for       */
N/*              __thread qualifier and support for thread-local              */
N/*              storage/addressing.                                          */
N/*                                                                           */
N/* __TI_USE_TLS - compile-time symbol to turn on usage of TLS in thread-safe */
N/*                versions of the RTS                                        */
N/*****************************************************************************/
N#if defined(__TI_TLS__) && defined(__TI_USE_TLS)
X#if 0L && 0L
S#define __TI_TLS_QUAL __thread 
N#else
N#define __TI_TLS_QUAL
N#endif
N
N
N#define __TI_TLS_DATA_DECL(type, name) \
N	extern __TI_TLS_QUAL _DATA_ACCESS type name
X#define __TI_TLS_DATA_DECL(type, name) 	extern __TI_TLS_QUAL _DATA_ACCESS type name
N
N#define __TI_TLS_DATA_DEF(scope, type, name, init) \
N	scope __TI_TLS_QUAL _DATA_ACCESS type name = init
X#define __TI_TLS_DATA_DEF(scope, type, name, init) 	scope __TI_TLS_QUAL _DATA_ACCESS type name = init
N
N#define __TI_TLS_DATA_PTR(name) \
N	(&(name))
X#define __TI_TLS_DATA_PTR(name) 	(&(name))
N
N#define __TI_TLS_ARR_DEF(scope, type, name, elts) \
N        scope __TI_TLS_QUAL _DATA_ACCESS type name[elts]
X#define __TI_TLS_ARR_DEF(scope, type, name, elts)         scope __TI_TLS_QUAL _DATA_ACCESS type name[elts]
N
N#define __TI_TLS_ARR(name) \
N        (&(name[0]))
X#define __TI_TLS_ARR(name)         (&(name[0]))
N
N#pragma diag_pop
N
N#endif /* __TLS_H */
L 60 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/errno.h" 2
N
N#if ((defined(__TMS320C2000__) && !defined(__TI_EABI__)) || defined(__PRU__) || \
N     defined(__ARP32__))
X#if ((0L && !1L) || 0L ||      0L)
S
S    #define EDOM           0x0001
S    #define ERANGE         0x0002
S    #define ENOENT         0x0003
S    #define EFPOS          0x0005
S    #define EILSEQ         0x0006
S
S    #define E2BIG          0x0007  
S    #define EACCES         0x000D
S    /* EADDRINUSE */
S    /* EADDRNOTAVAIL */
S    /* EAFNOSUPPORT */
S    #define EAGAIN         0x000B
S    /* EALREADY */
S    #define EBADF          0x0009     
S    #define EBADMSG        0x004D
S    #define EBUSY          0x0010
S    #define ECANCELED      0x002F  
S    #define ECHILD         0x000A  
S    /* ECONNABORTED */
S    /* ECONNREFUSED */
S    #define EDEADLK        0x002D     
S    /* EDESTADDRREQ */
S    /* EDOM defined above */
S    /* EDQUOT */
S    #define EEXIST         0x0011
S    #define EFAULT         0x000E   
S    #define EFBIG          0x001B
S    /* EHOSTUNREACH */
S    /* EIDRM */
S    /* EILSEQ defined above */
S    #define EINPROGRESS    0x0096
S    #define EINTR          0x0004  
S    #define EINVAL         0x0016  
S    #define EIO            0x0098
S    /* EISCONN */
S    #define EISDIR         0x0015
S    /* ELOOP */
S    #define EMFILE         0x0018     
S    #define EMLINK         0x001F
S    #define EMSGSIZE       0x0061  
S    /* EMULTIHOP */
S    #define ENAMETOOLONG   0x004E     
S    /* ENETDOWN */
S    /* ENETREST */
S    /* ENETUNREACH */
S    #define ENFILE         0x0017
S    /* ENOBUFS */
S    /* ENODATA */
S    #define ENODEV         0x0013
S    #define ENOEXEC        0x0008  
S    #define ENOLCK         0x002E
S    /* ENOLINK */
S    #define ENOMEM         0x000C
S    /* ENOMSG */
S    /* ENOPROTOOPT */
S    #define ENOSPC         0x001C   
S    /* ENOSR */
S    /* ENOSTR */
S    #define ENOSYS         0x0059
S    /* ENOTCONN */
S    #define ENOTDIR        0x0014     
S    #define ENOTEMPTY      0x005D
S    /* ENOTSOCK */
S    #define ENOTSUP        0x0030
S    #define ENOTTY         0x0019
S    #define ENXIO          0x0058
S    /* EOPNOTSUPP */
S    /* EOVERFLOW */
S    #define EPERM          0x0021
S    #define EPIPE          0x0020
S    /* EPROTO */
S    /* EPROTONOSUPPORT */
S    /* EPROTOTYPE */
S    /* ERANGE defined above */
S    #define EROFS          0x001E
S    #define ESPIPE         0x001D
S    #define ESRCH          0x0099
S    /* ESTALE */
S    /* ETIME */
S    #define ETIMEDOUT      0x0091
S    /* ETXTBSY */
S    /* EWOULDBLOCK */
S    #define EXDEV          0x0012
S
S    /* TI specific value used in ftell() and fgetpos() */
S    #define EFPOS          0x0005
S
N#else
N
N   /* Values defined by the C standard */
N#if defined(_AEABI_PORTABILITY_LEVEL) && _AEABI_PORTABILITY_LEVEL != 0
X#if 0L && _AEABI_PORTABILITY_LEVEL != 0
S    extern const int __aeabi_EDOM;
S    extern const int __aeabi_ERANGE;
S    extern const int __aeabi_EILSEQ;
S    #define EDOM   (__aeabi_EDOM)
S    #define ERANGE (__aeabi_ERANGE)
S    #define EILSEQ (__aeabi_EILSEQ)
N#else
N    #define EDOM           0x0021
N    #define ERANGE         0x0022
N    #define EILSEQ         0x0058
N#endif
N   /* Values defined by POSIX. Unsupported macros are commented out */
N
N    #define E2BIG          0x0007
N    #define EACCES         0x000D
N    /* EADDRINUSE */
N    /* EADDRNOTAVAIL */
N    /* EAFNOSUPPORT */
N    #define EAGAIN         0x000B
N    /* EALREADY */
N    #define EBADF          0x0009
N    #define EBADMSG        0x004D
N    #define EBUSY          0x0010
N    #define ECANCELED      0x002F
N    #define ECHILD         0x000A
N    /* ECONNABORTED */
N    /* ECONNREFUSED */
N    #define EDEADLK        0x002D
N    /* EDESTADDRREQ */
N    /* EDOM defined above */
N    /* EDQUOT */
N    #define EEXIST         0x0011
N    #define EFAULT         0x000E
N    #define EFBIG          0x001B
N    /* EHOSTUNREACH */
N    /* EIDRM */
N    /* EILSEQ defined above */
N    #define EINPROGRESS    0x0096
N    #define EINTR          0x0004
N    #define EINVAL         0x0016
N    #define EIO            0x0005
N    /* EISCONN */
N    #define EISDIR         0x0015
N    /* ELOOP */
N    #define EMFILE         0x0018
N    #define EMLINK         0x001F
N    #define EMSGSIZE       0x0061
N    /* EMULTIHOP */
N    #define ENAMETOOLONG   0x004E
N    /* ENETDOWN */
N    /* ENETREST */
N    /* ENETUNREACH */
N    #define ENFILE         0x0017
N    /* ENOBUFS */
N    /* ENODATA */
N    #define ENODEV         0x0013
N    #define ENOENT         0x0002
N    #define ENOEXEC        0x0008  
N    #define ENOLCK         0x002E
N    /* ENOLINK */
N    #define ENOMEM         0x000C
N    /* ENOMSG */
N    /* ENOPROTOOPT */
N    #define ENOSPC         0x001C   
N    /* ENOSR */
N    /* ENOSTR */
N    #define ENOSYS         0x0059
N    /* ENOTCONN */
N    #define ENOTDIR        0x0014     
N    #define ENOTEMPTY      0x005D
N    /* ENOTSOCK */
N    #define ENOTSUP        0x0030
N    #define ENOTTY         0x0019
N    #define ENXIO          0x0006
N    /* EOPNOTSUPP */
N    /* EOVERFLOW */
N    #define EPERM          0x0001
N    #define EPIPE          0x0020
N    /* EPROTO */
N    /* EPROTONOSUPPORT */
N    /* EPROTOTYPE */
N    /* ERANGE defined above */
N    #define EROFS          0x001E
N    #define ESPIPE         0x001D
N    #define ESRCH          0x0003
N    /* ESTALE */
N    /* ETIME */
N    #define ETIMEDOUT      0x0091
N    /* ETXTBSY */
N    /* EWOULDBLOCK */
N    #define EXDEV          0x0012
N
N    /* TI specific value used in ftell() and fgetpos() */
N    #define EFPOS          0x0098
N#endif
N
N#if defined(__ARM_ARCH) && (defined(__TI_EABI__) || defined(__clang__))
X#if 1L && (1L || 0L)
N    /*------------------------------------------------------------------------*/
N    /* Under EABI, use function to access errno since it likely has TLS in    */
N    /* a thread-safe version of the RTS library.                              */
N    /*------------------------------------------------------------------------*/
N    extern volatile int *__aeabi_errno_addr(void);
N    #define errno (* __aeabi_errno_addr())
N#elif !defined(__C6X_MIGRATION__) && defined(__TMS320C6X__) && defined(__TI_EABI__)
S    /*------------------------------------------------------------------------*/
S    /* Under EABI, use function to access errno since it likely has TLS in    */
S    /* a thread-safe version of the RTS library.                              */
S    /*------------------------------------------------------------------------*/
S    extern int *__c6xabi_errno_addr(void);
S    __TI_TLS_DATA_DECL(int, __errno);
S
S    #define errno (* __c6xabi_errno_addr())
S#else
S    extern _DATA_ACCESS int errno;
S    #pragma diag_push
S    /* errno is not allowed under MISRA, anyway */
S    #pragma CHECK_MISRA("-5.6") /* duplicated name in another scope (errno) */
S    #pragma CHECK_MISRA("-19.4") /* macro expands to parenthesized */
S    #define errno errno
S    #pragma diag_pop
N#endif
N
N#ifdef __cplusplus
N} /* extern "C" */
N#endif /* __cplusplus */
N
N#if defined(_AEABI_PORTABILITY_LEVEL) && _AEABI_PORTABILITY_LEVEL != 0 && \
N   !defined(_AEABI_PORTABLE)
X#if 0L && _AEABI_PORTABILITY_LEVEL != 0 &&    !0L
S#define _AEABI_PORTABLE
N#endif
N
N#pragma diag_pop
N
N#endif  /* _ERRNO */
L 33 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/errno.h" 2
N
N#ifdef __cplusplus
N
N#if !defined(EOWNERDEAD) || !defined(ENOTRECOVERABLE)
X#if !0L || !0L
N
N#ifdef ELAST
N
Nstatic const int __elast1 = ELAST+1;
Xstatic const int __elast1 = 4095+1;
Nstatic const int __elast2 = ELAST+2;
Xstatic const int __elast2 = 4095+2;
N
N#else
S
Sstatic const int __elast1 = 104;
Sstatic const int __elast2 = 105;
S
N#endif
N
N#ifdef ENOTRECOVERABLE
S
S#define EOWNERDEAD __elast1
S
S#ifdef ELAST
S#undef ELAST
S#define ELAST EOWNERDEAD
S#endif
S
S#elif defined(EOWNERDEAD)
X#elif 0L
S
S#define ENOTRECOVERABLE __elast1
S#ifdef ELAST
S#undef ELAST
S#define ELAST ENOTRECOVERABLE
S#endif
S
N#else  /* defined(EOWNERDEAD) */
N
N#define EOWNERDEAD __elast1
N#define ENOTRECOVERABLE __elast2
N#ifdef ELAST
N#undef ELAST
N#define ELAST ENOTRECOVERABLE
N#endif
N
N#endif  /* defined(EOWNERDEAD) */
N
N#endif  /* !defined(EOWNERDEAD) || !defined(ENOTRECOVERABLE) */
N
N/*  supply errno values likely to be missing, particularly on Windows */
N
N#ifndef EAFNOSUPPORT
N#define EAFNOSUPPORT 9901
N#endif
N
N#ifndef EADDRINUSE
N#define EADDRINUSE 9902
N#endif
N
N#ifndef EADDRNOTAVAIL
N#define EADDRNOTAVAIL 9903
N#endif
N
N#ifndef EISCONN
N#define EISCONN 9904
N#endif
N
N#ifndef EBADMSG
S#define EBADMSG 9905
N#endif
N
N#ifndef ECONNABORTED
N#define ECONNABORTED 9906
N#endif
N
N#ifndef EALREADY
N#define EALREADY 9907
N#endif
N
N#ifndef ECONNREFUSED
N#define ECONNREFUSED 9908
N#endif
N
N#ifndef ECONNRESET
N#define ECONNRESET 9909
N#endif
N
N#ifndef EDESTADDRREQ
N#define EDESTADDRREQ 9910
N#endif
N
N#ifndef EHOSTUNREACH
N#define EHOSTUNREACH 9911
N#endif
N
N#ifndef EIDRM
N#define EIDRM 9912
N#endif
N
N#ifndef EMSGSIZE
S#define EMSGSIZE 9913
N#endif
N
N#ifndef ENETDOWN
N#define ENETDOWN 9914
N#endif
N
N#ifndef ENETRESET
N#define ENETRESET 9915
N#endif
N
N#ifndef ENETUNREACH
N#define ENETUNREACH 9916
N#endif
N
N#ifndef ENOBUFS
N#define ENOBUFS 9917
N#endif
N
N#ifndef ENOLINK
N#define ENOLINK 9918
N#endif
N
N#ifndef ENODATA
N#define ENODATA 9919
N#endif
N
N#ifndef ENOMSG
N#define ENOMSG 9920
N#endif
N
N#ifndef ENOPROTOOPT
N#define ENOPROTOOPT 9921
N#endif
N
N#ifndef ENOSR
N#define ENOSR 9922
N#endif
N
N#ifndef ENOTSOCK
N#define ENOTSOCK 9923
N#endif
N
N#ifndef ENOSTR
N#define ENOSTR 9924
N#endif
N
N#ifndef ENOTCONN
N#define ENOTCONN 9925
N#endif
N
N#ifndef ENOTSUP
S#define ENOTSUP 9926
N#endif
N
N#ifndef ECANCELED
S#define ECANCELED 9927
N#endif
N
N#ifndef EINPROGRESS
S#define EINPROGRESS 9928
N#endif
N
N#ifndef EOPNOTSUPP
N#define EOPNOTSUPP 9929
N#endif
N
N#ifndef EWOULDBLOCK
N#define EWOULDBLOCK 9930
N#endif
N
N#ifndef EOWNERDEAD
S#define EOWNERDEAD  9931
N#endif
N
N#ifndef EPROTO
N#define EPROTO 9932
N#endif
N
N#ifndef EPROTONOSUPPORT
N#define EPROTONOSUPPORT 9933
N#endif
N
N#ifndef ENOTRECOVERABLE
S#define ENOTRECOVERABLE 9934
N#endif
N
N#ifndef ETIME
N#define ETIME 9935
N#endif
N
N#ifndef ETXTBSY
N#define ETXTBSY 9936
N#endif
N
N#ifndef ETIMEDOUT
S#define ETIMEDOUT 9938
N#endif
N
N#ifndef ELOOP
N#define ELOOP 9939
N#endif
N
N#ifndef EOVERFLOW
N#define EOVERFLOW 9940
N#endif
N
N#ifndef EPROTOTYPE
N#define EPROTOTYPE 9941
N#endif
N
N#ifndef ENOSYS
S#define ENOSYS 9942
N#endif
N
N#ifndef EINVAL
S#define EINVAL 9943
N#endif
N
N#ifndef ERANGE
S#define ERANGE 9944
N#endif
N
N#ifndef EILSEQ
S#define EILSEQ 9945
N#endif
N
N/*  Windows Mobile doesn't appear to define these: */
N
N#ifndef E2BIG
S#define E2BIG 9946
N#endif
N
N#ifndef EDOM
S#define EDOM 9947
N#endif
N
N#ifndef EFAULT
S#define EFAULT 9948
N#endif
N
N#ifndef EBADF
S#define EBADF 9949
N#endif
N
N#ifndef EPIPE
S#define EPIPE 9950
N#endif
N
N#ifndef EXDEV
S#define EXDEV 9951
N#endif
N
N#ifndef EBUSY
S#define EBUSY 9952
N#endif
N
N#ifndef ENOTEMPTY
S#define ENOTEMPTY 9953
N#endif
N
N#ifndef ENOEXEC
S#define ENOEXEC 9954
N#endif
N
N#ifndef EEXIST
S#define EEXIST 9955
N#endif
N
N#ifndef EFBIG
S#define EFBIG 9956
N#endif
N
N#ifndef ENAMETOOLONG
S#define ENAMETOOLONG 9957
N#endif
N
N#ifndef ENOTTY
S#define ENOTTY 9958
N#endif
N
N#ifndef EINTR
S#define EINTR 9959
N#endif
N
N#ifndef ESPIPE
S#define ESPIPE 9960
N#endif
N
N#ifndef EIO
S#define EIO 9961
N#endif
N
N#ifndef EISDIR
S#define EISDIR 9962
N#endif
N
N#ifndef ECHILD
S#define ECHILD 9963
N#endif
N
N#ifndef ENOLCK
S#define ENOLCK 9964
N#endif
N
N#ifndef ENOSPC
S#define ENOSPC 9965
N#endif
N
N#ifndef ENXIO
S#define ENXIO 9966
N#endif
N
N#ifndef ENODEV
S#define ENODEV 9967
N#endif
N
N#ifndef ENOENT
S#define ENOENT 9968
N#endif
N
N#ifndef ESRCH
S#define ESRCH 9969
N#endif
N
N#ifndef ENOTDIR
S#define ENOTDIR 9970
N#endif
N
N#ifndef ENOMEM
S#define ENOMEM 9971
N#endif
N
N#ifndef EPERM
S#define EPERM 9972
N#endif
N
N#ifndef EACCES
S#define EACCES 9973
N#endif
N
N#ifndef EROFS
S#define EROFS 9974
N#endif
N
N#ifndef EDEADLK
S#define EDEADLK 9975
N#endif
N
N#ifndef EAGAIN
S#define EAGAIN 9976
N#endif
N
N#ifndef ENFILE
S#define ENFILE 9977
N#endif
N
N#ifndef EMFILE
S#define EMFILE 9978
N#endif
N
N#ifndef EMLINK
S#define EMLINK 9979
N#endif
N
N#endif /* __cplusplus */
N
N#endif  /* _LIBCPP_ERRNO_H */
L 28 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/cerrno" 2
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N#endif  // _LIBCPP_CERRNO
L 230 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/system_error" 2
N#include <type_traits>
N#include <stdexcept>
N#include <__functional_base>
N#include <string>
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N_LIBCPP_BEGIN_NAMESPACE_STD
Xnamespace std { inline namespace __2 {
N
N// is_error_code_enum
N
Ntemplate <class _Tp>
Nstruct _LIBCPP_TEMPLATE_VIS is_error_code_enum
Xstruct  is_error_code_enum
N    : public false_type {};
N
N#if _LIBCPP_STD_VER > 14
X#if 14 > 14
Stemplate <class _Tp>
Sconstexpr size_t is_error_code_enum_v = is_error_code_enum<_Tp>::value;
N#endif
N
N// is_error_condition_enum
N
Ntemplate <class _Tp>
Nstruct _LIBCPP_TEMPLATE_VIS is_error_condition_enum
Xstruct  is_error_condition_enum
N    : public false_type {};
N
N#if _LIBCPP_STD_VER > 14
X#if 14 > 14
Stemplate <class _Tp>
Sconstexpr size_t is_error_condition_enum_v = is_error_condition_enum<_Tp>::value;
N#endif
N
N// Some error codes are not present on all platforms, so we provide equivalents
N// for them:
N
N//enum class errc
N_LIBCPP_DECLARE_STRONG_ENUM(errc)
Xenum class  errc
N{
N    address_family_not_supported        = EAFNOSUPPORT,
X    address_family_not_supported        = 9901,
N    address_in_use                      = EADDRINUSE,
X    address_in_use                      = 9902,
N    address_not_available               = EADDRNOTAVAIL,
X    address_not_available               = 9903,
N    already_connected                   = EISCONN,
X    already_connected                   = 9904,
N    argument_list_too_long              = E2BIG,
X    argument_list_too_long              = 0x0007,
N    argument_out_of_domain              = EDOM,
X    argument_out_of_domain              = 0x0021,
N    bad_address                         = EFAULT,
X    bad_address                         = 0x000E,
N    bad_file_descriptor                 = EBADF,
X    bad_file_descriptor                 = 0x0009,
N    bad_message                         = EBADMSG,
X    bad_message                         = 0x004D,
N    broken_pipe                         = EPIPE,
X    broken_pipe                         = 0x0020,
N    connection_aborted                  = ECONNABORTED,
X    connection_aborted                  = 9906,
N    connection_already_in_progress      = EALREADY,
X    connection_already_in_progress      = 9907,
N    connection_refused                  = ECONNREFUSED,
X    connection_refused                  = 9908,
N    connection_reset                    = ECONNRESET,
X    connection_reset                    = 9909,
N    cross_device_link                   = EXDEV,
X    cross_device_link                   = 0x0012,
N    destination_address_required        = EDESTADDRREQ,
X    destination_address_required        = 9910,
N    device_or_resource_busy             = EBUSY,
X    device_or_resource_busy             = 0x0010,
N    directory_not_empty                 = ENOTEMPTY,
X    directory_not_empty                 = 0x005D,
N    executable_format_error             = ENOEXEC,
X    executable_format_error             = 0x0008,
N    file_exists                         = EEXIST,
X    file_exists                         = 0x0011,
N    file_too_large                      = EFBIG,
X    file_too_large                      = 0x001B,
N    filename_too_long                   = ENAMETOOLONG,
X    filename_too_long                   = 0x004E,
N    function_not_supported              = ENOSYS,
X    function_not_supported              = 0x0059,
N    host_unreachable                    = EHOSTUNREACH,
X    host_unreachable                    = 9911,
N    identifier_removed                  = EIDRM,
X    identifier_removed                  = 9912,
N    illegal_byte_sequence               = EILSEQ,
X    illegal_byte_sequence               = 0x0058,
N    inappropriate_io_control_operation  = ENOTTY,
X    inappropriate_io_control_operation  = 0x0019,
N    interrupted                         = EINTR,
X    interrupted                         = 0x0004,
N    invalid_argument                    = EINVAL,
X    invalid_argument                    = 0x0016,
N    invalid_seek                        = ESPIPE,
X    invalid_seek                        = 0x001D,
N    io_error                            = EIO,
X    io_error                            = 0x0005,
N    is_a_directory                      = EISDIR,
X    is_a_directory                      = 0x0015,
N    message_size                        = EMSGSIZE,
X    message_size                        = 0x0061,
N    network_down                        = ENETDOWN,
X    network_down                        = 9914,
N    network_reset                       = ENETRESET,
X    network_reset                       = 9915,
N    network_unreachable                 = ENETUNREACH,
X    network_unreachable                 = 9916,
N    no_buffer_space                     = ENOBUFS,
X    no_buffer_space                     = 9917,
N    no_child_process                    = ECHILD,
X    no_child_process                    = 0x000A,
N    no_link                             = ENOLINK,
X    no_link                             = 9918,
N    no_lock_available                   = ENOLCK,
X    no_lock_available                   = 0x002E,
N#ifdef ENODATA
N    no_message_available                = ENODATA,
X    no_message_available                = 9919,
N#else
S    no_message_available                = ENOMSG,
N#endif
N    no_message                          = ENOMSG,
X    no_message                          = 9920,
N    no_protocol_option                  = ENOPROTOOPT,
X    no_protocol_option                  = 9921,
N    no_space_on_device                  = ENOSPC,
X    no_space_on_device                  = 0x001C,
N#ifdef ENOSR
N    no_stream_resources                 = ENOSR,
X    no_stream_resources                 = 9922,
N#else
S    no_stream_resources                 = ENOMEM,
N#endif
N    no_such_device_or_address           = ENXIO,
X    no_such_device_or_address           = 0x0006,
N    no_such_device                      = ENODEV,
X    no_such_device                      = 0x0013,
N    no_such_file_or_directory           = ENOENT,
X    no_such_file_or_directory           = 0x0002,
N    no_such_process                     = ESRCH,
X    no_such_process                     = 0x0003,
N    not_a_directory                     = ENOTDIR,
X    not_a_directory                     = 0x0014,
N    not_a_socket                        = ENOTSOCK,
X    not_a_socket                        = 9923,
N#ifdef ENOSTR
N    not_a_stream                        = ENOSTR,
X    not_a_stream                        = 9924,
N#else
S    not_a_stream                        = EINVAL,
N#endif
N    not_connected                       = ENOTCONN,
X    not_connected                       = 9925,
N    not_enough_memory                   = ENOMEM,
X    not_enough_memory                   = 0x000C,
N    not_supported                       = ENOTSUP,
X    not_supported                       = 0x0030,
N    operation_canceled                  = ECANCELED,
X    operation_canceled                  = 0x002F,
N    operation_in_progress               = EINPROGRESS,
X    operation_in_progress               = 0x0096,
N    operation_not_permitted             = EPERM,
X    operation_not_permitted             = 0x0001,
N    operation_not_supported             = EOPNOTSUPP,
X    operation_not_supported             = 9929,
N    operation_would_block               = EWOULDBLOCK,
X    operation_would_block               = 9930,
N    owner_dead                          = EOWNERDEAD,
X    owner_dead                          = __elast1,
N    permission_denied                   = EACCES,
X    permission_denied                   = 0x000D,
N    protocol_error                      = EPROTO,
X    protocol_error                      = 9932,
N    protocol_not_supported              = EPROTONOSUPPORT,
X    protocol_not_supported              = 9933,
N    read_only_file_system               = EROFS,
X    read_only_file_system               = 0x001E,
N    resource_deadlock_would_occur       = EDEADLK,
X    resource_deadlock_would_occur       = 0x002D,
N    resource_unavailable_try_again      = EAGAIN,
X    resource_unavailable_try_again      = 0x000B,
N    result_out_of_range                 = ERANGE,
X    result_out_of_range                 = 0x0022,
N    state_not_recoverable               = ENOTRECOVERABLE,
X    state_not_recoverable               = __elast2,
N#ifdef ETIME
N    stream_timeout                      = ETIME,
X    stream_timeout                      = 9935,
N#else
S    stream_timeout                      = ETIMEDOUT,
N#endif
N    text_file_busy                      = ETXTBSY,
X    text_file_busy                      = 9936,
N    timed_out                           = ETIMEDOUT,
X    timed_out                           = 0x0091,
N    too_many_files_open_in_system       = ENFILE,
X    too_many_files_open_in_system       = 0x0017,
N    too_many_files_open                 = EMFILE,
X    too_many_files_open                 = 0x0018,
N    too_many_links                      = EMLINK,
X    too_many_links                      = 0x001F,
N    too_many_symbolic_link_levels       = ELOOP,
X    too_many_symbolic_link_levels       = 9939,
N    value_too_large                     = EOVERFLOW,
X    value_too_large                     = 9940,
N    wrong_protocol_type                 = EPROTOTYPE
X    wrong_protocol_type                 = 9941
N};
N_LIBCPP_DECLARE_STRONG_ENUM_EPILOG(errc)
X
N
Ntemplate <>
Nstruct _LIBCPP_TEMPLATE_VIS is_error_condition_enum<errc>
Xstruct  is_error_condition_enum<errc>
N    : true_type { };
N
N#ifdef _LIBCPP_HAS_NO_STRONG_ENUMS
Stemplate <>
Sstruct _LIBCPP_TEMPLATE_VIS is_error_condition_enum<errc::__lx>
S    : true_type { };
N#endif
N
Nclass _LIBCPP_TYPE_VIS error_condition;
Xclass  error_condition;
Nclass _LIBCPP_TYPE_VIS error_code;
Xclass  error_code;
N
N// class error_category
N
Nclass _LIBCPP_HIDDEN __do_message;
Xclass  __do_message;
N
Nclass _LIBCPP_TYPE_VIS error_category
Xclass  error_category
N{
Npublic:
N    virtual ~error_category() _NOEXCEPT;
X    virtual ~error_category() noexcept;
N
N#if defined(_LIBCPP_BUILDING_SYSTEM_ERROR) && \
N    defined(_LIBCPP_DEPRECATED_ABI_LEGACY_LIBRARY_DEFINITIONS_FOR_INLINE_FUNCTIONS)
X#if 0L &&     0L
S    error_category() _NOEXCEPT;
N#else
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    _LIBCPP_CONSTEXPR_AFTER_CXX11 error_category() _NOEXCEPT _LIBCPP_DEFAULT
X    constexpr error_category() noexcept = default;
N#endif
Nprivate:
N    error_category(const error_category&);// = delete;
N    error_category& operator=(const error_category&);// = delete;
N
Npublic:
N    virtual const char* name() const _NOEXCEPT = 0;
X    virtual const char* name() const noexcept = 0;
N    virtual error_condition default_error_condition(int __ev) const _NOEXCEPT;
X    virtual error_condition default_error_condition(int __ev) const noexcept;
N    virtual bool equivalent(int __code, const error_condition& __condition) const _NOEXCEPT;
X    virtual bool equivalent(int __code, const error_condition& __condition) const noexcept;
N    virtual bool equivalent(const error_code& __code, int __condition) const _NOEXCEPT;
X    virtual bool equivalent(const error_code& __code, int __condition) const noexcept;
N    virtual string message(int __ev) const = 0;
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    bool operator==(const error_category& __rhs) const _NOEXCEPT {return this == &__rhs;}
X    bool operator==(const error_category& __rhs) const noexcept {return this == &__rhs;}
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    bool operator!=(const error_category& __rhs) const _NOEXCEPT {return !(*this == __rhs);}
X    bool operator!=(const error_category& __rhs) const noexcept {return !(*this == __rhs);}
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    bool operator< (const error_category& __rhs) const _NOEXCEPT {return this < &__rhs;}
X    bool operator< (const error_category& __rhs) const noexcept {return this < &__rhs;}
N
N    friend class _LIBCPP_HIDDEN __do_message;
X    friend class  __do_message;
N};
N
Nclass _LIBCPP_HIDDEN __do_message
Xclass  __do_message
N    : public error_category
N{
Npublic:
N    virtual string message(int ev) const;
N};
N
N_LIBCPP_FUNC_VIS const error_category& generic_category() _NOEXCEPT;
X const error_category& generic_category() noexcept;
N_LIBCPP_FUNC_VIS const error_category& system_category() _NOEXCEPT;
X const error_category& system_category() noexcept;
N
Nclass _LIBCPP_TYPE_VIS error_condition
Xclass  error_condition
N{
N    int __val_;
N    const error_category* __cat_;
Npublic:
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    error_condition() _NOEXCEPT : __val_(0), __cat_(&generic_category()) {}
X    error_condition() noexcept : __val_(0), __cat_(&generic_category()) {}
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    error_condition(int __val, const error_category& __cat) _NOEXCEPT
X    error_condition(int __val, const error_category& __cat) noexcept
N        : __val_(__val), __cat_(&__cat) {}
N
N    template <class _Ep>
N        _LIBCPP_ALWAYS_INLINE
X        __attribute__ ((__always_inline__))
N        error_condition(_Ep __e,
N              typename enable_if<is_error_condition_enum<_Ep>::value>::type* = 0
N                                                                     ) _NOEXCEPT
X                                                                     ) noexcept
N            {*this = make_error_condition(__e);}
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    void assign(int __val, const error_category& __cat) _NOEXCEPT
X    void assign(int __val, const error_category& __cat) noexcept
N    {
N        __val_ = __val;
N        __cat_ = &__cat;
N    }
N
N    template <class _Ep>
N        _LIBCPP_ALWAYS_INLINE
X        __attribute__ ((__always_inline__))
N        typename enable_if
N        <
N            is_error_condition_enum<_Ep>::value,
N            error_condition&
N        >::type
N        operator=(_Ep __e) _NOEXCEPT
X        operator=(_Ep __e) noexcept
N            {*this = make_error_condition(__e); return *this;}
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    void clear() _NOEXCEPT
X    void clear() noexcept
N    {
N        __val_ = 0;
N        __cat_ = &generic_category();
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    int value() const _NOEXCEPT {return __val_;}
X    int value() const noexcept {return __val_;}
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    const error_category& category() const _NOEXCEPT {return *__cat_;}
X    const error_category& category() const noexcept {return *__cat_;}
N    string message() const;
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N        _LIBCPP_EXPLICIT
X        explicit
N        operator bool() const _NOEXCEPT {return __val_ != 0;}
X        operator bool() const noexcept {return __val_ != 0;}
N};
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nerror_condition
Nmake_error_condition(errc __e) _NOEXCEPT
Xmake_error_condition(errc __e) noexcept
N{
N    return error_condition(static_cast<int>(__e), generic_category());
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator<(const error_condition& __x, const error_condition& __y) _NOEXCEPT
Xoperator<(const error_condition& __x, const error_condition& __y) noexcept
N{
N    return __x.category() < __y.category()
N        || (__x.category() == __y.category() && __x.value() < __y.value());
N}
N
N// error_code
N
Nclass _LIBCPP_TYPE_VIS error_code
Xclass  error_code
N{
N    int __val_;
N    const error_category* __cat_;
Npublic:
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    error_code() _NOEXCEPT : __val_(0), __cat_(&system_category()) {}
X    error_code() noexcept : __val_(0), __cat_(&system_category()) {}
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    error_code(int __val, const error_category& __cat) _NOEXCEPT
X    error_code(int __val, const error_category& __cat) noexcept
N        : __val_(__val), __cat_(&__cat) {}
N
N    template <class _Ep>
N        _LIBCPP_ALWAYS_INLINE
X        __attribute__ ((__always_inline__))
N        error_code(_Ep __e,
N                   typename enable_if<is_error_code_enum<_Ep>::value>::type* = 0
N                                                                     ) _NOEXCEPT
X                                                                     ) noexcept
N            {*this = make_error_code(__e);}
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    void assign(int __val, const error_category& __cat) _NOEXCEPT
X    void assign(int __val, const error_category& __cat) noexcept
N    {
N        __val_ = __val;
N        __cat_ = &__cat;
N    }
N
N    template <class _Ep>
N        _LIBCPP_ALWAYS_INLINE
X        __attribute__ ((__always_inline__))
N        typename enable_if
N        <
N            is_error_code_enum<_Ep>::value,
N            error_code&
N        >::type
N        operator=(_Ep __e) _NOEXCEPT
X        operator=(_Ep __e) noexcept
N            {*this = make_error_code(__e); return *this;}
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    void clear() _NOEXCEPT
X    void clear() noexcept
N    {
N        __val_ = 0;
N        __cat_ = &system_category();
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    int value() const _NOEXCEPT {return __val_;}
X    int value() const noexcept {return __val_;}
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    const error_category& category() const _NOEXCEPT {return *__cat_;}
X    const error_category& category() const noexcept {return *__cat_;}
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    error_condition default_error_condition() const _NOEXCEPT
X    error_condition default_error_condition() const noexcept
N        {return __cat_->default_error_condition(__val_);}
N
N    string message() const;
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N        _LIBCPP_EXPLICIT
X        explicit
N        operator bool() const _NOEXCEPT {return __val_ != 0;}
X        operator bool() const noexcept {return __val_ != 0;}
N};
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nerror_code
Nmake_error_code(errc __e) _NOEXCEPT
Xmake_error_code(errc __e) noexcept
N{
N    return error_code(static_cast<int>(__e), generic_category());
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator<(const error_code& __x, const error_code& __y) _NOEXCEPT
Xoperator<(const error_code& __x, const error_code& __y) noexcept
N{
N    return __x.category() < __y.category()
N        || (__x.category() == __y.category() && __x.value() < __y.value());
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator==(const error_code& __x, const error_code& __y) _NOEXCEPT
Xoperator==(const error_code& __x, const error_code& __y) noexcept
N{
N    return __x.category() == __y.category() && __x.value() == __y.value();
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator==(const error_code& __x, const error_condition& __y) _NOEXCEPT
Xoperator==(const error_code& __x, const error_condition& __y) noexcept
N{
N    return __x.category().equivalent(__x.value(), __y)
N        || __y.category().equivalent(__x, __y.value());
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator==(const error_condition& __x, const error_code& __y) _NOEXCEPT
Xoperator==(const error_condition& __x, const error_code& __y) noexcept
N{
N    return __y == __x;
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator==(const error_condition& __x, const error_condition& __y) _NOEXCEPT
Xoperator==(const error_condition& __x, const error_condition& __y) noexcept
N{
N    return __x.category() == __y.category() && __x.value() == __y.value();
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator!=(const error_code& __x, const error_code& __y) _NOEXCEPT
Xoperator!=(const error_code& __x, const error_code& __y) noexcept
N{return !(__x == __y);}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator!=(const error_code& __x, const error_condition& __y) _NOEXCEPT
Xoperator!=(const error_code& __x, const error_condition& __y) noexcept
N{return !(__x == __y);}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator!=(const error_condition& __x, const error_code& __y) _NOEXCEPT
Xoperator!=(const error_condition& __x, const error_code& __y) noexcept
N{return !(__x == __y);}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator!=(const error_condition& __x, const error_condition& __y) _NOEXCEPT
Xoperator!=(const error_condition& __x, const error_condition& __y) noexcept
N{return !(__x == __y);}
N
Ntemplate <>
Nstruct _LIBCPP_TEMPLATE_VIS hash<error_code>
Xstruct  hash<error_code>
N    : public unary_function<error_code, size_t>
N{
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    size_t operator()(const error_code& __ec) const _NOEXCEPT
X    size_t operator()(const error_code& __ec) const noexcept
N    {
N        return static_cast<size_t>(__ec.value());
N    }
N};
N
Ntemplate <>
Nstruct _LIBCPP_TEMPLATE_VIS hash<error_condition>
Xstruct  hash<error_condition>
N    : public unary_function<error_condition, size_t>
N{
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    size_t operator()(const error_condition& __ec) const _NOEXCEPT
X    size_t operator()(const error_condition& __ec) const noexcept
N    {
N        return static_cast<size_t>(__ec.value());
N    }
N};
N
N// system_error
N
Nclass _LIBCPP_TYPE_VIS system_error
Xclass  system_error
N    : public runtime_error
N{
N    error_code __ec_;
Npublic:
N    system_error(error_code __ec, const string& __what_arg);
N    system_error(error_code __ec, const char* __what_arg);
N    system_error(error_code __ec);
N    system_error(int __ev, const error_category& __ecat, const string& __what_arg);
N    system_error(int __ev, const error_category& __ecat, const char* __what_arg);
N    system_error(int __ev, const error_category& __ecat);
N    ~system_error() _NOEXCEPT;
X    ~system_error() noexcept;
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    const error_code& code() const _NOEXCEPT {return __ec_;}
X    const error_code& code() const noexcept {return __ec_;}
N
Nprivate:
N    static string __init(const error_code&, string);
N};
N
N_LIBCPP_NORETURN _LIBCPP_FUNC_VIS
X[[noreturn]] 
Nvoid __throw_system_error(int ev, const char* what_arg);
N
N_LIBCPP_END_NAMESPACE_STD
X} }
N
N#endif  // _LIBCPP_SYSTEM_ERROR
L 17 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/__mutex_base" 2
N#include <__threading_support>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/__threading_support" 1
N// -*- C++ -*-
N//===----------------------------------------------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is dual licensed under the MIT and the University of Illinois Open
N// Source Licenses. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP_THREADING_SUPPORT
N#define _LIBCPP_THREADING_SUPPORT
N
N#include <__config>
N#include <chrono>
N#include <errno.h>
N
N#ifndef _LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER
N#pragma GCC system_header
N#endif
N
N#if defined(_LIBCPP_HAS_THREAD_API_EXTERNAL)
X#if 0L
S# include <__external_threading>
S#elif !defined(_LIBCPP_HAS_NO_THREADS)
X#elif !1L
S
S#if defined(_LIBCPP_HAS_THREAD_API_PTHREAD)
S# include <pthread.h>
S# include <sched.h>
S#elif defined(_LIBCPP_HAS_THREAD_API_WIN32)
S#include <windows.h>
S#include <process.h>
S#include <fibersapi.h>
S#endif
S
S_LIBCPP_PUSH_MACROS
S#include <__undef_macros>
S
S
S#if defined(_LIBCPP_HAS_THREAD_LIBRARY_EXTERNAL) || \
S    defined(_LIBCPP_BUILDING_THREAD_LIBRARY_EXTERNAL)
X#if defined(_LIBCPP_HAS_THREAD_LIBRARY_EXTERNAL) ||     defined(_LIBCPP_BUILDING_THREAD_LIBRARY_EXTERNAL)
S#define _LIBCPP_THREAD_ABI_VISIBILITY _LIBCPP_FUNC_VIS
S#else
S#define _LIBCPP_THREAD_ABI_VISIBILITY inline _LIBCPP_INLINE_VISIBILITY
S#endif
S
S#if defined(__FreeBSD__) && defined(__clang__) && __has_attribute(no_thread_safety_analysis)
S#define _LIBCPP_NO_THREAD_SAFETY_ANALYSIS __attribute__((no_thread_safety_analysis))
S#else
S#define _LIBCPP_NO_THREAD_SAFETY_ANALYSIS
S#endif
S
S_LIBCPP_BEGIN_NAMESPACE_STD
S
S#if defined(_LIBCPP_HAS_THREAD_API_PTHREAD)
S// Mutex
Stypedef pthread_mutex_t __libcpp_mutex_t;
S#define _LIBCPP_MUTEX_INITIALIZER PTHREAD_MUTEX_INITIALIZER
S
Stypedef pthread_mutex_t __libcpp_recursive_mutex_t;
S
S// Condition Variable
Stypedef pthread_cond_t __libcpp_condvar_t;
S#define _LIBCPP_CONDVAR_INITIALIZER PTHREAD_COND_INITIALIZER
S
S// Execute once
Stypedef pthread_once_t __libcpp_exec_once_flag;
S#define _LIBCPP_EXEC_ONCE_INITIALIZER PTHREAD_ONCE_INIT
S
S// Thread id
Stypedef pthread_t __libcpp_thread_id;
S
S// Thread
S#define _LIBCPP_NULL_THREAD 0U
S
Stypedef pthread_t __libcpp_thread_t;
S
S// Thrad Local Storage
Stypedef pthread_key_t __libcpp_tls_key;
S
S#define _LIBCPP_TLS_DESTRUCTOR_CC
S#else
S// Mutex
Stypedef SRWLOCK __libcpp_mutex_t;
S#define _LIBCPP_MUTEX_INITIALIZER SRWLOCK_INIT
S
Stypedef CRITICAL_SECTION __libcpp_recursive_mutex_t;
S
S// Condition Variable
Stypedef CONDITION_VARIABLE __libcpp_condvar_t;
S#define _LIBCPP_CONDVAR_INITIALIZER CONDITION_VARIABLE_INIT
S
S// Execute Once
Stypedef INIT_ONCE __libcpp_exec_once_flag;
S#define _LIBCPP_EXEC_ONCE_INITIALIZER INIT_ONCE_STATIC_INIT
S
S// Thread ID
Stypedef DWORD __libcpp_thread_id;
S
S// Thread
S#define _LIBCPP_NULL_THREAD 0U
S
Stypedef HANDLE __libcpp_thread_t;
S
S// Thread Local Storage
Stypedef DWORD __libcpp_tls_key;
S
S#define _LIBCPP_TLS_DESTRUCTOR_CC WINAPI
S#endif
S
S// Mutex
S_LIBCPP_THREAD_ABI_VISIBILITY
Sint __libcpp_recursive_mutex_init(__libcpp_recursive_mutex_t *__m);
S
S_LIBCPP_THREAD_ABI_VISIBILITY _LIBCPP_NO_THREAD_SAFETY_ANALYSIS
Sint __libcpp_recursive_mutex_lock(__libcpp_recursive_mutex_t *__m);
S
S_LIBCPP_THREAD_ABI_VISIBILITY _LIBCPP_NO_THREAD_SAFETY_ANALYSIS
Sbool __libcpp_recursive_mutex_trylock(__libcpp_recursive_mutex_t *__m);
S
S_LIBCPP_THREAD_ABI_VISIBILITY _LIBCPP_NO_THREAD_SAFETY_ANALYSIS
Sint __libcpp_recursive_mutex_unlock(__libcpp_recursive_mutex_t *__m);
S
S_LIBCPP_THREAD_ABI_VISIBILITY
Sint __libcpp_recursive_mutex_destroy(__libcpp_recursive_mutex_t *__m);
S
S_LIBCPP_THREAD_ABI_VISIBILITY _LIBCPP_NO_THREAD_SAFETY_ANALYSIS
Sint __libcpp_mutex_lock(__libcpp_mutex_t *__m);
S
S_LIBCPP_THREAD_ABI_VISIBILITY _LIBCPP_NO_THREAD_SAFETY_ANALYSIS
Sbool __libcpp_mutex_trylock(__libcpp_mutex_t *__m);
S
S_LIBCPP_THREAD_ABI_VISIBILITY _LIBCPP_NO_THREAD_SAFETY_ANALYSIS
Sint __libcpp_mutex_unlock(__libcpp_mutex_t *__m);
S
S_LIBCPP_THREAD_ABI_VISIBILITY
Sint __libcpp_mutex_destroy(__libcpp_mutex_t *__m);
S
S// Condition variable
S_LIBCPP_THREAD_ABI_VISIBILITY
Sint __libcpp_condvar_signal(__libcpp_condvar_t* __cv);
S
S_LIBCPP_THREAD_ABI_VISIBILITY
Sint __libcpp_condvar_broadcast(__libcpp_condvar_t* __cv);
S
S_LIBCPP_THREAD_ABI_VISIBILITY _LIBCPP_NO_THREAD_SAFETY_ANALYSIS
Sint __libcpp_condvar_wait(__libcpp_condvar_t* __cv, __libcpp_mutex_t* __m);
S
S_LIBCPP_THREAD_ABI_VISIBILITY _LIBCPP_NO_THREAD_SAFETY_ANALYSIS
Sint __libcpp_condvar_timedwait(__libcpp_condvar_t *__cv, __libcpp_mutex_t *__m,
S                               timespec *__ts);
S
S_LIBCPP_THREAD_ABI_VISIBILITY
Sint __libcpp_condvar_destroy(__libcpp_condvar_t* __cv);
S
S// Execute once
S_LIBCPP_THREAD_ABI_VISIBILITY
Sint __libcpp_execute_once(__libcpp_exec_once_flag *flag,
S                          void (*init_routine)(void));
S
S// Thread id
S_LIBCPP_THREAD_ABI_VISIBILITY
Sbool __libcpp_thread_id_equal(__libcpp_thread_id t1, __libcpp_thread_id t2);
S
S_LIBCPP_THREAD_ABI_VISIBILITY
Sbool __libcpp_thread_id_less(__libcpp_thread_id t1, __libcpp_thread_id t2);
S
S// Thread
S_LIBCPP_THREAD_ABI_VISIBILITY
Sbool __libcpp_thread_isnull(const __libcpp_thread_t *__t);
S
S_LIBCPP_THREAD_ABI_VISIBILITY
Sint __libcpp_thread_create(__libcpp_thread_t *__t, void *(*__func)(void *),
S                           void *__arg);
S
S_LIBCPP_THREAD_ABI_VISIBILITY
S__libcpp_thread_id __libcpp_thread_get_current_id();
S
S_LIBCPP_THREAD_ABI_VISIBILITY
S__libcpp_thread_id __libcpp_thread_get_id(const __libcpp_thread_t *__t);
S
S_LIBCPP_THREAD_ABI_VISIBILITY
Sint __libcpp_thread_join(__libcpp_thread_t *__t);
S
S_LIBCPP_THREAD_ABI_VISIBILITY
Sint __libcpp_thread_detach(__libcpp_thread_t *__t);
S
S_LIBCPP_THREAD_ABI_VISIBILITY
Svoid __libcpp_thread_yield();
S
S_LIBCPP_THREAD_ABI_VISIBILITY
Svoid __libcpp_thread_sleep_for(const chrono::nanoseconds& __ns);
S
S// Thread local storage
S_LIBCPP_THREAD_ABI_VISIBILITY
Sint __libcpp_tls_create(__libcpp_tls_key* __key,
S                        void(_LIBCPP_TLS_DESTRUCTOR_CC* __at_exit)(void*));
S
S_LIBCPP_THREAD_ABI_VISIBILITY
Svoid *__libcpp_tls_get(__libcpp_tls_key __key);
S
S_LIBCPP_THREAD_ABI_VISIBILITY
Sint __libcpp_tls_set(__libcpp_tls_key __key, void *__p);
S
S#if !defined(_LIBCPP_HAS_THREAD_LIBRARY_EXTERNAL) || \
S    defined(_LIBCPP_BUILDING_THREAD_LIBRARY_EXTERNAL)
X#if !defined(_LIBCPP_HAS_THREAD_LIBRARY_EXTERNAL) ||     defined(_LIBCPP_BUILDING_THREAD_LIBRARY_EXTERNAL)
S
S#if defined(_LIBCPP_HAS_THREAD_API_PTHREAD)
S
Sint __libcpp_recursive_mutex_init(__libcpp_recursive_mutex_t *__m)
S{
S  pthread_mutexattr_t attr;
S  int __ec = pthread_mutexattr_init(&attr);
S  if (__ec)
S    return __ec;
S  __ec = pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
S  if (__ec) {
S    pthread_mutexattr_destroy(&attr);
S    return __ec;
S  }
S  __ec = pthread_mutex_init(__m, &attr);
S  if (__ec) {
S    pthread_mutexattr_destroy(&attr);
S    return __ec;
S  }
S  __ec = pthread_mutexattr_destroy(&attr);
S  if (__ec) {
S    pthread_mutex_destroy(__m);
S    return __ec;
S  }
S  return 0;
S}
S
Sint __libcpp_recursive_mutex_lock(__libcpp_recursive_mutex_t *__m)
S{
S  return pthread_mutex_lock(__m);
S}
S
Sbool __libcpp_recursive_mutex_trylock(__libcpp_recursive_mutex_t *__m)
S{
S  return pthread_mutex_trylock(__m) == 0;
S}
S
Sint __libcpp_recursive_mutex_unlock(__libcpp_mutex_t *__m)
S{
S  return pthread_mutex_unlock(__m);
S}
S
Sint __libcpp_recursive_mutex_destroy(__libcpp_recursive_mutex_t *__m)
S{
S  return pthread_mutex_destroy(__m);
S}
S
Sint __libcpp_mutex_lock(__libcpp_mutex_t *__m)
S{
S  return pthread_mutex_lock(__m);
S}
S
Sbool __libcpp_mutex_trylock(__libcpp_mutex_t *__m)
S{
S  return pthread_mutex_trylock(__m) == 0;
S}
S
Sint __libcpp_mutex_unlock(__libcpp_mutex_t *__m)
S{
S  return pthread_mutex_unlock(__m);
S}
S
Sint __libcpp_mutex_destroy(__libcpp_mutex_t *__m)
S{
S  return pthread_mutex_destroy(__m);
S}
S
S// Condition Variable
Sint __libcpp_condvar_signal(__libcpp_condvar_t *__cv)
S{
S  return pthread_cond_signal(__cv);
S}
S
Sint __libcpp_condvar_broadcast(__libcpp_condvar_t *__cv)
S{
S  return pthread_cond_broadcast(__cv);
S}
S
Sint __libcpp_condvar_wait(__libcpp_condvar_t *__cv, __libcpp_mutex_t *__m)
S{
S  return pthread_cond_wait(__cv, __m);
S}
S
Sint __libcpp_condvar_timedwait(__libcpp_condvar_t *__cv, __libcpp_mutex_t *__m,
S                               timespec *__ts)
S{
S  return pthread_cond_timedwait(__cv, __m, __ts);
S}
S
Sint __libcpp_condvar_destroy(__libcpp_condvar_t *__cv)
S{
S  return pthread_cond_destroy(__cv);
S}
S
S// Execute once
Sint __libcpp_execute_once(__libcpp_exec_once_flag *flag,
S                          void (*init_routine)(void)) {
S  return pthread_once(flag, init_routine);
S}
S
S// Thread id
S// Returns non-zero if the thread ids are equal, otherwise 0
Sbool __libcpp_thread_id_equal(__libcpp_thread_id t1, __libcpp_thread_id t2)
S{
S  return pthread_equal(t1, t2) != 0;
S}
S
S// Returns non-zero if t1 < t2, otherwise 0
Sbool __libcpp_thread_id_less(__libcpp_thread_id t1, __libcpp_thread_id t2)
S{
S  return t1 < t2;
S}
S
S// Thread
Sbool __libcpp_thread_isnull(const __libcpp_thread_t *__t) {
S  return *__t == 0;
S}
S
Sint __libcpp_thread_create(__libcpp_thread_t *__t, void *(*__func)(void *),
S                           void *__arg)
S{
S  return pthread_create(__t, 0, __func, __arg);
S}
S
S__libcpp_thread_id __libcpp_thread_get_current_id()
S{
S  return pthread_self();
S}
S
S__libcpp_thread_id __libcpp_thread_get_id(const __libcpp_thread_t *__t)
S{
S  return *__t;
S}
S
Sint __libcpp_thread_join(__libcpp_thread_t *__t)
S{
S  return pthread_join(*__t, 0);
S}
S
Sint __libcpp_thread_detach(__libcpp_thread_t *__t)
S{
S  return pthread_detach(*__t);
S}
S
Svoid __libcpp_thread_yield()
S{
S  sched_yield();
S}
S
Svoid __libcpp_thread_sleep_for(const chrono::nanoseconds& __ns)
S{
S   using namespace chrono;
S   seconds __s = duration_cast<seconds>(__ns);
S   timespec __ts;
S   typedef decltype(__ts.tv_sec) ts_sec;
S   _LIBCPP_CONSTEXPR ts_sec __ts_sec_max = numeric_limits<ts_sec>::max();
S
S   if (__s.count() < __ts_sec_max)
S   {
S     __ts.tv_sec = static_cast<ts_sec>(__s.count());
S     __ts.tv_nsec = static_cast<decltype(__ts.tv_nsec)>((__ns - __s).count());
S   }
S   else
S   {
S     __ts.tv_sec = __ts_sec_max;
S     __ts.tv_nsec = 999999999; // (10^9 - 1)
S   }
S
S   while (nanosleep(&__ts, &__ts) == -1 && errno == EINTR);
S}
S
S// Thread local storage
Sint __libcpp_tls_create(__libcpp_tls_key *__key, void (*__at_exit)(void *))
S{
S  return pthread_key_create(__key, __at_exit);
S}
S
Svoid *__libcpp_tls_get(__libcpp_tls_key __key)
S{
S  return pthread_getspecific(__key);
S}
S
Sint __libcpp_tls_set(__libcpp_tls_key __key, void *__p)
S{
S    return pthread_setspecific(__key, __p);
S}
S
S#elif defined(_LIBCPP_HAS_THREAD_API_WIN32)
S
S// Mutex
Sint __libcpp_recursive_mutex_init(__libcpp_recursive_mutex_t *__m)
S{
S  InitializeCriticalSection(__m);
S  return 0;
S}
S
Sint __libcpp_recursive_mutex_lock(__libcpp_recursive_mutex_t *__m)
S{
S  EnterCriticalSection(__m);
S  return 0;
S}
S
Sbool __libcpp_recursive_mutex_trylock(__libcpp_recursive_mutex_t *__m)
S{
S  return TryEnterCriticalSection(__m) != 0;
S}
S
Sint __libcpp_recursive_mutex_unlock(__libcpp_recursive_mutex_t *__m)
S{
S  LeaveCriticalSection(__m);
S  return 0;
S}
S
Sint __libcpp_recursive_mutex_destroy(__libcpp_recursive_mutex_t *__m)
S{
S  DeleteCriticalSection(__m);
S  return 0;
S}
S
Sint __libcpp_mutex_lock(__libcpp_mutex_t *__m)
S{
S  AcquireSRWLockExclusive(__m);
S  return 0;
S}
S
Sbool __libcpp_mutex_trylock(__libcpp_mutex_t *__m)
S{
S  return TryAcquireSRWLockExclusive(__m) != 0;
S}
S
Sint __libcpp_mutex_unlock(__libcpp_mutex_t *__m)
S{
S  ReleaseSRWLockExclusive(__m);
S  return 0;
S}
S
Sint __libcpp_mutex_destroy(__libcpp_mutex_t *__m)
S{
S  static_cast<void>(__m);
S  return 0;
S}
S
S// Condition Variable
Sint __libcpp_condvar_signal(__libcpp_condvar_t *__cv)
S{
S  WakeConditionVariable(__cv);
S  return 0;
S}
S
Sint __libcpp_condvar_broadcast(__libcpp_condvar_t *__cv)
S{
S  WakeAllConditionVariable(__cv);
S  return 0;
S}
S
Sint __libcpp_condvar_wait(__libcpp_condvar_t *__cv, __libcpp_mutex_t *__m)
S{
S  SleepConditionVariableSRW(__cv, __m, INFINITE, 0);
S  return 0;
S}
S
Sint __libcpp_condvar_timedwait(__libcpp_condvar_t *__cv, __libcpp_mutex_t *__m,
S                               timespec *__ts)
S{
S  using namespace _VSTD::chrono;
S
S  auto duration = seconds(__ts->tv_sec) + nanoseconds(__ts->tv_nsec);
S  auto abstime =
S      system_clock::time_point(duration_cast<system_clock::duration>(duration));
S  auto timeout_ms = duration_cast<milliseconds>(abstime - system_clock::now());
S
S  if (!SleepConditionVariableSRW(__cv, __m,
S                                 timeout_ms.count() > 0 ? timeout_ms.count()
S                                                        : 0,
S                                 0))
S    {
S      auto __ec = GetLastError();
S      return __ec == ERROR_TIMEOUT ? ETIMEDOUT : __ec;
S    }
S  return 0;
S}
S
Sint __libcpp_condvar_destroy(__libcpp_condvar_t *__cv)
S{
S  static_cast<void>(__cv);
S  return 0;
S}
S
S// Execute Once
Sstatic inline _LIBCPP_ALWAYS_INLINE BOOL CALLBACK
S__libcpp_init_once_execute_once_thunk(PINIT_ONCE __init_once, PVOID __parameter,
S                                      PVOID *__context)
S{
S  static_cast<void>(__init_once);
S  static_cast<void>(__context);
S
S  void (*init_routine)(void) = reinterpret_cast<void (*)(void)>(__parameter);
S  init_routine();
S  return TRUE;
S}
S
Sint __libcpp_execute_once(__libcpp_exec_once_flag *__flag,
S                          void (*__init_routine)(void))
S{
S  if (!InitOnceExecuteOnce(__flag, __libcpp_init_once_execute_once_thunk,
S                           reinterpret_cast<void *>(__init_routine), NULL))
S    return GetLastError();
S  return 0;
S}
S
S// Thread ID
Sbool __libcpp_thread_id_equal(__libcpp_thread_id __lhs,
S                              __libcpp_thread_id __rhs)
S{
S  return __lhs == __rhs;
S}
S
Sbool __libcpp_thread_id_less(__libcpp_thread_id __lhs, __libcpp_thread_id __rhs)
S{
S  return __lhs < __rhs;
S}
S
S// Thread
Sstruct __libcpp_beginthreadex_thunk_data
S{
S  void *(*__func)(void *);
S  void *__arg;
S};
S
Sstatic inline _LIBCPP_ALWAYS_INLINE unsigned WINAPI
S__libcpp_beginthreadex_thunk(void *__raw_data)
S{
S  auto *__data =
S      static_cast<__libcpp_beginthreadex_thunk_data *>(__raw_data);
S  auto *__func = __data->__func;
S  void *__arg = __data->__arg;
S  delete __data;
S  return static_cast<unsigned>(reinterpret_cast<uintptr_t>(__func(__arg)));
S}
S
Sbool __libcpp_thread_isnull(const __libcpp_thread_t *__t) {
S  return *__t == 0;
S}
S
Sint __libcpp_thread_create(__libcpp_thread_t *__t, void *(*__func)(void *),
S                           void *__arg)
S{
S  auto *__data = new __libcpp_beginthreadex_thunk_data;
S  __data->__func = __func;
S  __data->__arg = __arg;
S
S  *__t = reinterpret_cast<HANDLE>(_beginthreadex(nullptr, 0,
S                                                 __libcpp_beginthreadex_thunk,
S                                                 __data, 0, nullptr));
S
S  if (*__t)
S    return 0;
S  return GetLastError();
S}
S
S__libcpp_thread_id __libcpp_thread_get_current_id()
S{
S  return GetCurrentThreadId();
S}
S
S__libcpp_thread_id __libcpp_thread_get_id(const __libcpp_thread_t *__t)
S{
S  return GetThreadId(*__t);
S}
S
Sint __libcpp_thread_join(__libcpp_thread_t *__t)
S{
S  if (WaitForSingleObjectEx(*__t, INFINITE, FALSE) == WAIT_FAILED)
S    return GetLastError();
S  if (!CloseHandle(*__t))
S    return GetLastError();
S  return 0;
S}
S
Sint __libcpp_thread_detach(__libcpp_thread_t *__t)
S{
S  if (!CloseHandle(*__t))
S    return GetLastError();
S  return 0;
S}
S
Svoid __libcpp_thread_yield()
S{
S  SwitchToThread();
S}
S
Svoid __libcpp_thread_sleep_for(const chrono::nanoseconds& __ns)
S{
S  using namespace chrono;
S  // round-up to the nearest milisecond
S  milliseconds __ms =
S      duration_cast<milliseconds>(__ns + chrono::nanoseconds(999999));
S  // FIXME(compnerd) this should be an alertable sleep (WFSO or SleepEx)
S  Sleep(__ms.count());
S}
S
S// Thread Local Storage
Sint __libcpp_tls_create(__libcpp_tls_key* __key,
S                        void(_LIBCPP_TLS_DESTRUCTOR_CC* __at_exit)(void*))
S{
S  *__key = FlsAlloc(__at_exit);
S  if (*__key == FLS_OUT_OF_INDEXES)
S    return GetLastError();
S  return 0;
S}
S
Svoid *__libcpp_tls_get(__libcpp_tls_key __key)
S{
S  return FlsGetValue(__key);
S}
S
Sint __libcpp_tls_set(__libcpp_tls_key __key, void *__p)
S{
S  if (!FlsSetValue(__key, __p))
S    return GetLastError();
S  return 0;
S}
S
S#endif // _LIBCPP_HAS_THREAD_API_PTHREAD
S
S#endif // !_LIBCPP_HAS_THREAD_LIBRARY_EXTERNAL || _LIBCPP_BUILDING_THREAD_LIBRARY_EXTERNAL
S
S_LIBCPP_END_NAMESPACE_STD
S
S_LIBCPP_POP_MACROS
S
N#endif // !_LIBCPP_HAS_NO_THREADS
N
N#endif // _LIBCPP_THREADING_SUPPORT
L 18 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/__mutex_base" 2
N
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N_LIBCPP_PUSH_MACROS
X_Pragma("push_macro(\"min\")") _Pragma("push_macro(\"max\")")
N#include <__undef_macros>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/__undef_macros" 1
N// -*- C++ -*-
N//===------------------------ __undef_macros ------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is distributed under the University of Illinois Open Source
N// License. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N
N#ifdef min
S#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
S#if defined(_LIBCPP_WARNING)
S_LIBCPP_WARNING("macro min is incompatible with C++.  Try #define NOMINMAX "
S                "before any Windows header. #undefing min")
S#else
S#warning: macro min is incompatible with C++.  #undefing min
S#endif
S#endif
S#undef min
N#endif
N
N#ifdef max
S#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
S#if defined(_LIBCPP_WARNING)
S_LIBCPP_WARNING("macro max is incompatible with C++.  Try #define NOMINMAX "
S                "before any Windows header. #undefing max")
S#else
S#warning: macro max is incompatible with C++.  #undefing max
S#endif
S#endif
S#undef max
N#endif
L 26 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/__mutex_base" 2
N
N
N_LIBCPP_BEGIN_NAMESPACE_STD
Xnamespace std { inline namespace __2 {
N
N#ifndef _LIBCPP_HAS_NO_THREADS
S
S#ifndef _LIBCPP_THREAD_SAFETY_ANNOTATION
S#  ifdef _LIBCPP_HAS_THREAD_SAFETY_ANNOTATIONS
S#    define _LIBCPP_THREAD_SAFETY_ANNOTATION(x) __attribute__((x))
S#  else
S#    define _LIBCPP_THREAD_SAFETY_ANNOTATION(x)
S#  endif
S#endif  // _LIBCPP_THREAD_SAFETY_ANNOTATION
S
Sclass _LIBCPP_TYPE_VIS _LIBCPP_THREAD_SAFETY_ANNOTATION(capability("mutex")) mutex
S{
S#ifndef _LIBCPP_CXX03_LANG
S    __libcpp_mutex_t __m_ = _LIBCPP_MUTEX_INITIALIZER;
S#else
S    __libcpp_mutex_t __m_;
S#endif
S
Spublic:
S    _LIBCPP_INLINE_VISIBILITY
S#ifndef _LIBCPP_CXX03_LANG
S    constexpr mutex() = default;
S#else
S    mutex() _NOEXCEPT {__m_ = (__libcpp_mutex_t)_LIBCPP_MUTEX_INITIALIZER;}
S#endif
S    ~mutex();
S
Sprivate:
S    mutex(const mutex&);// = delete;
S    mutex& operator=(const mutex&);// = delete;
S
Spublic:
S    void lock() _LIBCPP_THREAD_SAFETY_ANNOTATION(acquire_capability());
S    bool try_lock() _NOEXCEPT _LIBCPP_THREAD_SAFETY_ANNOTATION(try_acquire_capability(true));
S    void unlock() _NOEXCEPT _LIBCPP_THREAD_SAFETY_ANNOTATION(release_capability());
S
S    typedef __libcpp_mutex_t* native_handle_type;
S    _LIBCPP_INLINE_VISIBILITY native_handle_type native_handle() {return &__m_;}
S};
S
Sstatic_assert(is_nothrow_default_constructible<mutex>::value,
S              "the default constructor for std::mutex must be nothrow");
S
Sstruct _LIBCPP_TYPE_VIS defer_lock_t {};
Sstruct _LIBCPP_TYPE_VIS try_to_lock_t {};
Sstruct _LIBCPP_TYPE_VIS adopt_lock_t {};
S
S#if defined(_LIBCPP_CXX03_LANG) || defined(_LIBCPP_BUILDING_MUTEX)
S
Sextern const defer_lock_t  defer_lock;
Sextern const try_to_lock_t try_to_lock;
Sextern const adopt_lock_t  adopt_lock;
S
S#else
S
Sconstexpr defer_lock_t  defer_lock  = defer_lock_t();
Sconstexpr try_to_lock_t try_to_lock = try_to_lock_t();
Sconstexpr adopt_lock_t  adopt_lock  = adopt_lock_t();
S
S#endif
S
Stemplate <class _Mutex>
Sclass _LIBCPP_TEMPLATE_VIS _LIBCPP_THREAD_SAFETY_ANNOTATION(scoped_lockable)
Slock_guard
S{
Spublic:
S    typedef _Mutex mutex_type;
S
Sprivate:
S    mutex_type& __m_;
Spublic:
S
S    _LIBCPP_INLINE_VISIBILITY
S    explicit lock_guard(mutex_type& __m) _LIBCPP_THREAD_SAFETY_ANNOTATION(acquire_capability(__m))
S        : __m_(__m) {__m_.lock();}
S    _LIBCPP_INLINE_VISIBILITY
S    lock_guard(mutex_type& __m, adopt_lock_t) _LIBCPP_THREAD_SAFETY_ANNOTATION(requires_capability(__m))
S        : __m_(__m) {}
S    _LIBCPP_INLINE_VISIBILITY
S    ~lock_guard() _LIBCPP_THREAD_SAFETY_ANNOTATION(release_capability()) {__m_.unlock();}
S
Sprivate:
S    lock_guard(lock_guard const&) _LIBCPP_EQUAL_DELETE;
S    lock_guard& operator=(lock_guard const&) _LIBCPP_EQUAL_DELETE;
S};
S
Stemplate <class _Mutex>
Sclass _LIBCPP_TEMPLATE_VIS unique_lock
S{
Spublic:
S    typedef _Mutex mutex_type;
S
Sprivate:
S    mutex_type* __m_;
S    bool __owns_;
S
Spublic:
S    _LIBCPP_INLINE_VISIBILITY
S    unique_lock() _NOEXCEPT : __m_(nullptr), __owns_(false) {}
S    _LIBCPP_INLINE_VISIBILITY
S    explicit unique_lock(mutex_type& __m)
S        : __m_(_VSTD::addressof(__m)), __owns_(true) {__m_->lock();}
S    _LIBCPP_INLINE_VISIBILITY
S    unique_lock(mutex_type& __m, defer_lock_t) _NOEXCEPT
S        : __m_(_VSTD::addressof(__m)), __owns_(false) {}
S    _LIBCPP_INLINE_VISIBILITY
S    unique_lock(mutex_type& __m, try_to_lock_t)
S        : __m_(_VSTD::addressof(__m)), __owns_(__m.try_lock()) {}
S    _LIBCPP_INLINE_VISIBILITY
S    unique_lock(mutex_type& __m, adopt_lock_t)
S        : __m_(_VSTD::addressof(__m)), __owns_(true) {}
S    template <class _Clock, class _Duration>
S    _LIBCPP_INLINE_VISIBILITY
S        unique_lock(mutex_type& __m, const chrono::time_point<_Clock, _Duration>& __t)
S            : __m_(_VSTD::addressof(__m)), __owns_(__m.try_lock_until(__t)) {}
S    template <class _Rep, class _Period>
S    _LIBCPP_INLINE_VISIBILITY
S        unique_lock(mutex_type& __m, const chrono::duration<_Rep, _Period>& __d)
S            : __m_(_VSTD::addressof(__m)), __owns_(__m.try_lock_for(__d)) {}
S    _LIBCPP_INLINE_VISIBILITY
S    ~unique_lock()
S    {
S        if (__owns_)
S            __m_->unlock();
S    }
S
Sprivate:
S    unique_lock(unique_lock const&); // = delete;
S    unique_lock& operator=(unique_lock const&); // = delete;
S
Spublic:
S#ifndef _LIBCPP_CXX03_LANG
S    _LIBCPP_INLINE_VISIBILITY
S    unique_lock(unique_lock&& __u) _NOEXCEPT
S        : __m_(__u.__m_), __owns_(__u.__owns_)
S        {__u.__m_ = nullptr; __u.__owns_ = false;}
S    _LIBCPP_INLINE_VISIBILITY
S    unique_lock& operator=(unique_lock&& __u) _NOEXCEPT
S        {
S            if (__owns_)
S                __m_->unlock();
S            __m_ = __u.__m_;
S            __owns_ = __u.__owns_;
S            __u.__m_ = nullptr;
S            __u.__owns_ = false;
S            return *this;
S        }
S
S#endif  // _LIBCPP_CXX03_LANG
S
S    void lock();
S    bool try_lock();
S
S    template <class _Rep, class _Period>
S        bool try_lock_for(const chrono::duration<_Rep, _Period>& __d);
S    template <class _Clock, class _Duration>
S        bool try_lock_until(const chrono::time_point<_Clock, _Duration>& __t);
S
S    void unlock();
S
S    _LIBCPP_INLINE_VISIBILITY
S    void swap(unique_lock& __u) _NOEXCEPT
S    {
S        _VSTD::swap(__m_, __u.__m_);
S        _VSTD::swap(__owns_, __u.__owns_);
S    }
S    _LIBCPP_INLINE_VISIBILITY
S    mutex_type* release() _NOEXCEPT
S    {
S        mutex_type* __m = __m_;
S        __m_ = nullptr;
S        __owns_ = false;
S        return __m;
S    }
S
S    _LIBCPP_INLINE_VISIBILITY
S    bool owns_lock() const _NOEXCEPT {return __owns_;}
S    _LIBCPP_INLINE_VISIBILITY
S    _LIBCPP_EXPLICIT
S        operator bool () const _NOEXCEPT {return __owns_;}
S    _LIBCPP_INLINE_VISIBILITY
S    mutex_type* mutex() const _NOEXCEPT {return __m_;}
S};
S
Stemplate <class _Mutex>
Svoid
Sunique_lock<_Mutex>::lock()
S{
S    if (__m_ == nullptr)
S        __throw_system_error(EPERM, "unique_lock::lock: references null mutex");
S    if (__owns_)
S        __throw_system_error(EDEADLK, "unique_lock::lock: already locked");
S    __m_->lock();
S    __owns_ = true;
S}
S
Stemplate <class _Mutex>
Sbool
Sunique_lock<_Mutex>::try_lock()
S{
S    if (__m_ == nullptr)
S        __throw_system_error(EPERM, "unique_lock::try_lock: references null mutex");
S    if (__owns_)
S        __throw_system_error(EDEADLK, "unique_lock::try_lock: already locked");
S    __owns_ = __m_->try_lock();
S    return __owns_;
S}
S
Stemplate <class _Mutex>
Stemplate <class _Rep, class _Period>
Sbool
Sunique_lock<_Mutex>::try_lock_for(const chrono::duration<_Rep, _Period>& __d)
S{
S    if (__m_ == nullptr)
S        __throw_system_error(EPERM, "unique_lock::try_lock_for: references null mutex");
S    if (__owns_)
S        __throw_system_error(EDEADLK, "unique_lock::try_lock_for: already locked");
S    __owns_ = __m_->try_lock_for(__d);
S    return __owns_;
S}
S
Stemplate <class _Mutex>
Stemplate <class _Clock, class _Duration>
Sbool
Sunique_lock<_Mutex>::try_lock_until(const chrono::time_point<_Clock, _Duration>& __t)
S{
S    if (__m_ == nullptr)
S        __throw_system_error(EPERM, "unique_lock::try_lock_until: references null mutex");
S    if (__owns_)
S        __throw_system_error(EDEADLK, "unique_lock::try_lock_until: already locked");
S    __owns_ = __m_->try_lock_until(__t);
S    return __owns_;
S}
S
Stemplate <class _Mutex>
Svoid
Sunique_lock<_Mutex>::unlock()
S{
S    if (!__owns_)
S        __throw_system_error(EPERM, "unique_lock::unlock: not locked");
S    __m_->unlock();
S    __owns_ = false;
S}
S
Stemplate <class _Mutex>
Sinline _LIBCPP_INLINE_VISIBILITY
Svoid
Sswap(unique_lock<_Mutex>& __x, unique_lock<_Mutex>& __y) _NOEXCEPT
S    {__x.swap(__y);}
S
S//enum class cv_status
S_LIBCPP_DECLARE_STRONG_ENUM(cv_status)
S{
S    no_timeout,
S    timeout
S};
S_LIBCPP_DECLARE_STRONG_ENUM_EPILOG(cv_status)
S
Sclass _LIBCPP_TYPE_VIS condition_variable
S{
S#ifndef _LIBCPP_CXX03_LANG
S    __libcpp_condvar_t __cv_ = _LIBCPP_CONDVAR_INITIALIZER;
S#else
S    __libcpp_condvar_t __cv_;
S#endif
S
Spublic:
S    _LIBCPP_INLINE_VISIBILITY
S#ifndef _LIBCPP_CXX03_LANG
S    constexpr condition_variable() _NOEXCEPT = default;
S#else
S    condition_variable() _NOEXCEPT {__cv_ = (__libcpp_condvar_t)_LIBCPP_CONDVAR_INITIALIZER;}
S#endif
S    ~condition_variable();
S
Sprivate:
S    condition_variable(const condition_variable&); // = delete;
S    condition_variable& operator=(const condition_variable&); // = delete;
S
Spublic:
S    void notify_one() _NOEXCEPT;
S    void notify_all() _NOEXCEPT;
S
S    void wait(unique_lock<mutex>& __lk) _NOEXCEPT;
S    template <class _Predicate>
S        _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
S        void wait(unique_lock<mutex>& __lk, _Predicate __pred);
S
S    template <class _Clock, class _Duration>
S        _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
S        cv_status
S        wait_until(unique_lock<mutex>& __lk,
S                   const chrono::time_point<_Clock, _Duration>& __t);
S
S    template <class _Clock, class _Duration, class _Predicate>
S        _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
S        bool
S        wait_until(unique_lock<mutex>& __lk,
S                   const chrono::time_point<_Clock, _Duration>& __t,
S                   _Predicate __pred);
S
S    template <class _Rep, class _Period>
S        _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
S        cv_status
S        wait_for(unique_lock<mutex>& __lk,
S                 const chrono::duration<_Rep, _Period>& __d);
S
S    template <class _Rep, class _Period, class _Predicate>
S        bool
S        _LIBCPP_INLINE_VISIBILITY
S        wait_for(unique_lock<mutex>& __lk,
S                 const chrono::duration<_Rep, _Period>& __d,
S                 _Predicate __pred);
S
S    typedef __libcpp_condvar_t* native_handle_type;
S    _LIBCPP_INLINE_VISIBILITY native_handle_type native_handle() {return &__cv_;}
S
Sprivate:
S    void __do_timed_wait(unique_lock<mutex>& __lk,
S       chrono::time_point<chrono::system_clock, chrono::nanoseconds>) _NOEXCEPT;
S};
N#endif // !_LIBCPP_HAS_NO_THREADS
N
Ntemplate <class _To, class _Rep, class _Period>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename enable_if
N<
N    chrono::__is_duration<_To>::value,
N    _To
N>::type
N__ceil(chrono::duration<_Rep, _Period> __d)
N{
N    using namespace chrono;
N    _To __r = duration_cast<_To>(__d);
N    if (__r < __d)
N        ++__r;
N    return __r;
N}
N
N#ifndef _LIBCPP_HAS_NO_THREADS
Stemplate <class _Predicate>
Svoid
Scondition_variable::wait(unique_lock<mutex>& __lk, _Predicate __pred)
S{
S    while (!__pred())
S        wait(__lk);
S}
S
Stemplate <class _Clock, class _Duration>
Scv_status
Scondition_variable::wait_until(unique_lock<mutex>& __lk,
S                               const chrono::time_point<_Clock, _Duration>& __t)
S{
S    using namespace chrono;
S    wait_for(__lk, __t - _Clock::now());
S    return _Clock::now() < __t ? cv_status::no_timeout : cv_status::timeout;
S}
S
Stemplate <class _Clock, class _Duration, class _Predicate>
Sbool
Scondition_variable::wait_until(unique_lock<mutex>& __lk,
S                   const chrono::time_point<_Clock, _Duration>& __t,
S                   _Predicate __pred)
S{
S    while (!__pred())
S    {
S        if (wait_until(__lk, __t) == cv_status::timeout)
S            return __pred();
S    }
S    return true;
S}
S
Stemplate <class _Rep, class _Period>
Scv_status
Scondition_variable::wait_for(unique_lock<mutex>& __lk,
S                             const chrono::duration<_Rep, _Period>& __d)
S{
S    using namespace chrono;
S    if (__d <= __d.zero())
S        return cv_status::timeout;
S    typedef time_point<system_clock, duration<long double, nano> > __sys_tpf;
S    typedef time_point<system_clock, nanoseconds> __sys_tpi;
S    __sys_tpf _Max = __sys_tpi::max();
S    steady_clock::time_point __c_now = steady_clock::now();
S    system_clock::time_point __s_now = system_clock::now();
S    if (_Max - __d > __s_now)
S        __do_timed_wait(__lk, __s_now + __ceil<nanoseconds>(__d));
S    else
S        __do_timed_wait(__lk, __sys_tpi::max());
S    return steady_clock::now() - __c_now < __d ? cv_status::no_timeout :
S                                                 cv_status::timeout;
S}
S
Stemplate <class _Rep, class _Period, class _Predicate>
Sinline
Sbool
Scondition_variable::wait_for(unique_lock<mutex>& __lk,
S                             const chrono::duration<_Rep, _Period>& __d,
S                             _Predicate __pred)
S{
S    return wait_until(__lk, chrono::steady_clock::now() + __d,
S                      _VSTD::move(__pred));
S}
S
N#endif // !_LIBCPP_HAS_NO_THREADS
N
N_LIBCPP_END_NAMESPACE_STD
X} }
N
N_LIBCPP_POP_MACROS
X_Pragma("pop_macro(\"min\")") _Pragma("pop_macro(\"max\")")
N
N#endif  // _LIBCPP___MUTEX_BASE
L 192 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/mutex" 2
N#include <functional>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/functional" 1
N// -*- C++ -*-
N//===------------------------ functional ----------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is dual licensed under the MIT and the University of Illinois Open
N// Source Licenses. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP_FUNCTIONAL
N#define _LIBCPP_FUNCTIONAL
N
N/*
N    functional synopsis
N
Nnamespace std
N{
N
Ntemplate <class Arg, class Result>
Nstruct unary_function
N{
N    typedef Arg    argument_type;
N    typedef Result result_type;
N};
N
Ntemplate <class Arg1, class Arg2, class Result>
Nstruct binary_function
N{
N    typedef Arg1   first_argument_type;
N    typedef Arg2   second_argument_type;
N    typedef Result result_type;
N};
N
Ntemplate <class T>
Nclass reference_wrapper
N    : public unary_function<T1, R> // if wrapping a unary functor
N    : public binary_function<T1, T2, R> // if wraping a binary functor
N{
Npublic:
N    // types
N    typedef T type;
N    typedef see below result_type; // Not always defined
N
N    // construct/copy/destroy
N    reference_wrapper(T&) noexcept;
N    reference_wrapper(T&&) = delete; // do not bind to temps
N    reference_wrapper(const reference_wrapper<T>& x) noexcept;
N
N    // assignment
N    reference_wrapper& operator=(const reference_wrapper<T>& x) noexcept;
N
N    // access
N    operator T& () const noexcept;
N    T& get() const noexcept;
N
N    // invoke
N    template <class... ArgTypes>
N      typename result_of<T&(ArgTypes&&...)>::type
N          operator() (ArgTypes&&...) const;
N};
N
Ntemplate <class T> reference_wrapper<T> ref(T& t) noexcept;
Ntemplate <class T> void ref(const T&& t) = delete;
Ntemplate <class T> reference_wrapper<T> ref(reference_wrapper<T>t) noexcept;
N
Ntemplate <class T> reference_wrapper<const T> cref(const T& t) noexcept;
Ntemplate <class T> void cref(const T&& t) = delete;
Ntemplate <class T> reference_wrapper<const T> cref(reference_wrapper<T> t) noexcept;
N
Ntemplate <class T> // <class T=void> in C++14
Nstruct plus : binary_function<T, T, T>
N{
N    T operator()(const T& x, const T& y) const;
N};
N
Ntemplate <class T> // <class T=void> in C++14
Nstruct minus : binary_function<T, T, T>
N{
N    T operator()(const T& x, const T& y) const;
N};
N
Ntemplate <class T> // <class T=void> in C++14
Nstruct multiplies : binary_function<T, T, T>
N{
N    T operator()(const T& x, const T& y) const;
N};
N
Ntemplate <class T> // <class T=void> in C++14
Nstruct divides : binary_function<T, T, T>
N{
N    T operator()(const T& x, const T& y) const;
N};
N
Ntemplate <class T> // <class T=void> in C++14
Nstruct modulus : binary_function<T, T, T>
N{
N    T operator()(const T& x, const T& y) const;
N};
N
Ntemplate <class T> // <class T=void> in C++14
Nstruct negate : unary_function<T, T>
N{
N    T operator()(const T& x) const;
N};
N
Ntemplate <class T> // <class T=void> in C++14
Nstruct equal_to : binary_function<T, T, bool>
N{
N    bool operator()(const T& x, const T& y) const;
N};
N
Ntemplate <class T> // <class T=void> in C++14
Nstruct not_equal_to : binary_function<T, T, bool>
N{
N    bool operator()(const T& x, const T& y) const;
N};
N
Ntemplate <class T> // <class T=void> in C++14
Nstruct greater : binary_function<T, T, bool>
N{
N    bool operator()(const T& x, const T& y) const;
N};
N
Ntemplate <class T> // <class T=void> in C++14
Nstruct less : binary_function<T, T, bool>
N{
N    bool operator()(const T& x, const T& y) const;
N};
N
Ntemplate <class T> // <class T=void> in C++14
Nstruct greater_equal : binary_function<T, T, bool>
N{
N    bool operator()(const T& x, const T& y) const;
N};
N
Ntemplate <class T> // <class T=void> in C++14
Nstruct less_equal : binary_function<T, T, bool>
N{
N    bool operator()(const T& x, const T& y) const;
N};
N
Ntemplate <class T> // <class T=void> in C++14
Nstruct logical_and : binary_function<T, T, bool>
N{
N    bool operator()(const T& x, const T& y) const;
N};
N
Ntemplate <class T> // <class T=void> in C++14
Nstruct logical_or : binary_function<T, T, bool>
N{
N    bool operator()(const T& x, const T& y) const;
N};
N
Ntemplate <class T> // <class T=void> in C++14
Nstruct logical_not : unary_function<T, bool>
N{
N    bool operator()(const T& x) const;
N};
N
Ntemplate <class T> // <class T=void> in C++14
Nstruct bit_and : unary_function<T, bool>
N{
N    bool operator()(const T& x, const T& y) const;
N};
N
Ntemplate <class T> // <class T=void> in C++14
Nstruct bit_or : unary_function<T, bool>
N{
N    bool operator()(const T& x, const T& y) const;
N};
N
Ntemplate <class T> // <class T=void> in C++14
Nstruct bit_xor : unary_function<T, bool>
N{
N    bool operator()(const T& x, const T& y) const;
N};
N
Ntemplate <class T=void> // C++14
Nstruct bit_xor : unary_function<T, bool>
N{
N    bool operator()(const T& x) const;
N};
N
Ntemplate <class Predicate>
Nclass unary_negate
N    : public unary_function<typename Predicate::argument_type, bool>
N{
Npublic:
N    explicit unary_negate(const Predicate& pred);
N    bool operator()(const typename Predicate::argument_type& x) const;
N};
N
Ntemplate <class Predicate> unary_negate<Predicate> not1(const Predicate& pred);
N
Ntemplate <class Predicate>
Nclass binary_negate
N    : public binary_function<typename Predicate::first_argument_type,
N                             typename Predicate::second_argument_type,
N                             bool>
N{
Npublic:
N    explicit binary_negate(const Predicate& pred);
N    bool operator()(const typename Predicate::first_argument_type& x,
N                    const typename Predicate::second_argument_type& y) const;
N};
N
Ntemplate <class Predicate> binary_negate<Predicate> not2(const Predicate& pred);
N
Ntemplate <class F> unspecified not_fn(F&& f); // C++17
N
Ntemplate<class T> struct is_bind_expression;
Ntemplate<class T> struct is_placeholder;
N
N    // See C++14 20.9.9, Function object binders
Ntemplate <class T> constexpr bool is_bind_expression_v
N  = is_bind_expression<T>::value; // C++17
Ntemplate <class T> constexpr int is_placeholder_v
N  = is_placeholder<T>::value; // C++17
N
N
Ntemplate<class Fn, class... BoundArgs>
N  unspecified bind(Fn&&, BoundArgs&&...);
Ntemplate<class R, class Fn, class... BoundArgs>
N  unspecified bind(Fn&&, BoundArgs&&...);
N
Nnamespace placeholders {
N  // M is the implementation-defined number of placeholders
N  extern unspecified _1;
N  extern unspecified _2;
N  .
N  .
N  .
N  extern unspecified _Mp;
N}
N
Ntemplate <class Operation>
Nclass binder1st     // deprecated in C++11, removed in C++17
N    : public unary_function<typename Operation::second_argument_type,
N                            typename Operation::result_type>
N{
Nprotected:
N    Operation                               op;
N    typename Operation::first_argument_type value;
Npublic:
N    binder1st(const Operation& x, const typename Operation::first_argument_type y);
N    typename Operation::result_type operator()(      typename Operation::second_argument_type& x) const;
N    typename Operation::result_type operator()(const typename Operation::second_argument_type& x) const;
N};
N
Ntemplate <class Operation, class T>
Nbinder1st<Operation> bind1st(const Operation& op, const T& x);  // deprecated in C++11, removed in C++17
N
Ntemplate <class Operation>
Nclass binder2nd     // deprecated in C++11, removed in C++17
N    : public unary_function<typename Operation::first_argument_type,
N                            typename Operation::result_type>
N{
Nprotected:
N    Operation                                op;
N    typename Operation::second_argument_type value;
Npublic:
N    binder2nd(const Operation& x, const typename Operation::second_argument_type y);
N    typename Operation::result_type operator()(      typename Operation::first_argument_type& x) const;
N    typename Operation::result_type operator()(const typename Operation::first_argument_type& x) const;
N};
N
Ntemplate <class Operation, class T>
Nbinder2nd<Operation> bind2nd(const Operation& op, const T& x);  // deprecated in C++11, removed in C++17
N
Ntemplate <class Arg, class Result>      // deprecated in C++11, removed in C++17
Nclass pointer_to_unary_function : public unary_function<Arg, Result>
N{
Npublic:
N    explicit pointer_to_unary_function(Result (*f)(Arg));
N    Result operator()(Arg x) const;
N};
N
Ntemplate <class Arg, class Result>
Npointer_to_unary_function<Arg,Result> ptr_fun(Result (*f)(Arg));      // deprecated in C++11, removed in C++17
N
Ntemplate <class Arg1, class Arg2, class Result>      // deprecated in C++11, removed in C++17
Nclass pointer_to_binary_function : public binary_function<Arg1, Arg2, Result>
N{
Npublic:
N    explicit pointer_to_binary_function(Result (*f)(Arg1, Arg2));
N    Result operator()(Arg1 x, Arg2 y) const;
N};
N
Ntemplate <class Arg1, class Arg2, class Result>
Npointer_to_binary_function<Arg1,Arg2,Result> ptr_fun(Result (*f)(Arg1,Arg2));      // deprecated in C++11, removed in C++17
N
Ntemplate<class S, class T>      // deprecated in C++11, removed in C++17
Nclass mem_fun_t : public unary_function<T*, S>
N{
Npublic:
N    explicit mem_fun_t(S (T::*p)());
N    S operator()(T* p) const;
N};
N
Ntemplate<class S, class T, class A>
Nclass mem_fun1_t : public binary_function<T*, A, S>      // deprecated in C++11, removed in C++17
N{
Npublic:
N    explicit mem_fun1_t(S (T::*p)(A));
N    S operator()(T* p, A x) const;
N};
N
Ntemplate<class S, class T>          mem_fun_t<S,T>    mem_fun(S (T::*f)());      // deprecated in C++11, removed in C++17
Ntemplate<class S, class T, class A> mem_fun1_t<S,T,A> mem_fun(S (T::*f)(A));     // deprecated in C++11, removed in C++17
N
Ntemplate<class S, class T>
Nclass mem_fun_ref_t : public unary_function<T, S>      // deprecated in C++11, removed in C++17
N{
Npublic:
N    explicit mem_fun_ref_t(S (T::*p)());
N    S operator()(T& p) const;
N};
N
Ntemplate<class S, class T, class A>
Nclass mem_fun1_ref_t : public binary_function<T, A, S>      // deprecated in C++11, removed in C++17
N{
Npublic:
N    explicit mem_fun1_ref_t(S (T::*p)(A));
N    S operator()(T& p, A x) const;
N};
N
Ntemplate<class S, class T>          mem_fun_ref_t<S,T>    mem_fun_ref(S (T::*f)());      // deprecated in C++11, removed in C++17
Ntemplate<class S, class T, class A> mem_fun1_ref_t<S,T,A> mem_fun_ref(S (T::*f)(A));     // deprecated in C++11, removed in C++17
N
Ntemplate <class S, class T>
Nclass const_mem_fun_t : public unary_function<const T*, S>      // deprecated in C++11, removed in C++17
N{
Npublic:
N    explicit const_mem_fun_t(S (T::*p)() const);
N    S operator()(const T* p) const;
N};
N
Ntemplate <class S, class T, class A>
Nclass const_mem_fun1_t : public binary_function<const T*, A, S>      // deprecated in C++11, removed in C++17
N{
Npublic:
N    explicit const_mem_fun1_t(S (T::*p)(A) const);
N    S operator()(const T* p, A x) const;
N};
N
Ntemplate <class S, class T>          const_mem_fun_t<S,T>    mem_fun(S (T::*f)() const);      // deprecated in C++11, removed in C++17
Ntemplate <class S, class T, class A> const_mem_fun1_t<S,T,A> mem_fun(S (T::*f)(A) const);     // deprecated in C++11, removed in C++17
N
Ntemplate <class S, class T>
Nclass const_mem_fun_ref_t : public unary_function<T, S>      // deprecated in C++11, removed in C++17
N{
Npublic:
N    explicit const_mem_fun_ref_t(S (T::*p)() const);
N    S operator()(const T& p) const;
N};
N
Ntemplate <class S, class T, class A>
Nclass const_mem_fun1_ref_t : public binary_function<T, A, S>      // deprecated in C++11, removed in C++17
N{
Npublic:
N    explicit const_mem_fun1_ref_t(S (T::*p)(A) const);
N    S operator()(const T& p, A x) const;
N};
N
Ntemplate <class S, class T>          const_mem_fun_ref_t<S,T>    mem_fun_ref(S (T::*f)() const);   // deprecated in C++11, removed in C++17
Ntemplate <class S, class T, class A> const_mem_fun1_ref_t<S,T,A> mem_fun_ref(S (T::*f)(A) const);  // deprecated in C++11, removed in C++17
N
Ntemplate<class R, class T> unspecified mem_fn(R T::*);
N
Nclass bad_function_call
N    : public exception
N{
N};
N
Ntemplate<class> class function; // undefined
N
Ntemplate<class R, class... ArgTypes>
Nclass function<R(ArgTypes...)>
N  : public unary_function<T1, R>      // iff sizeof...(ArgTypes) == 1 and
N                                      // ArgTypes contains T1
N  : public binary_function<T1, T2, R> // iff sizeof...(ArgTypes) == 2 and
N                                      // ArgTypes contains T1 and T2
N{
Npublic:
N    typedef R result_type;
N
N    // construct/copy/destroy:
N    function() noexcept;
N    function(nullptr_t) noexcept;
N    function(const function&);
N    function(function&&) noexcept;
N    template<class F>
N      function(F);
N    template<Allocator Alloc>
N      function(allocator_arg_t, const Alloc&) noexcept;            // removed in C++17
N    template<Allocator Alloc>
N      function(allocator_arg_t, const Alloc&, nullptr_t) noexcept; // removed in C++17
N    template<Allocator Alloc>
N      function(allocator_arg_t, const Alloc&, const function&);    // removed in C++17
N    template<Allocator Alloc>
N      function(allocator_arg_t, const Alloc&, function&&);         // removed in C++17
N    template<class F, Allocator Alloc>
N      function(allocator_arg_t, const Alloc&, F);                  // removed in C++17
N
N    function& operator=(const function&);
N    function& operator=(function&&) noexcept;
N    function& operator=(nullptr_t) noexcept;
N    template<class F>
N      function& operator=(F&&);
N    template<class F>
N      function& operator=(reference_wrapper<F>) noexcept;
N
N    ~function();
N
N    // function modifiers:
N    void swap(function&) noexcept;
N    template<class F, class Alloc>
N      void assign(F&&, const Alloc&);                 // Removed in C++17
N
N    // function capacity:
N    explicit operator bool() const noexcept;
N
N    // function invocation:
N    R operator()(ArgTypes...) const;
N
N    // function target access:
N    const std::type_info& target_type() const noexcept;
N    template <typename T>       T* target() noexcept;
N    template <typename T> const T* target() const noexcept;
N};
N
N// Null pointer comparisons:
Ntemplate <class R, class ... ArgTypes>
N  bool operator==(const function<R(ArgTypes...)>&, nullptr_t) noexcept;
N
Ntemplate <class R, class ... ArgTypes>
N  bool operator==(nullptr_t, const function<R(ArgTypes...)>&) noexcept;
N
Ntemplate <class R, class ... ArgTypes>
N  bool operator!=(const function<R(ArgTypes...)>&, nullptr_t) noexcept;
N
Ntemplate <class  R, class ... ArgTypes>
N  bool operator!=(nullptr_t, const function<R(ArgTypes...)>&) noexcept;
N
N// specialized algorithms:
Ntemplate <class  R, class ... ArgTypes>
N  void swap(function<R(ArgTypes...)>&, function<R(ArgTypes...)>&) noexcept;
N
Ntemplate <class T> struct hash;
N
Ntemplate <> struct hash<bool>;
Ntemplate <> struct hash<char>;
Ntemplate <> struct hash<signed char>;
Ntemplate <> struct hash<unsigned char>;
Ntemplate <> struct hash<char16_t>;
Ntemplate <> struct hash<char32_t>;
Ntemplate <> struct hash<wchar_t>;
Ntemplate <> struct hash<short>;
Ntemplate <> struct hash<unsigned short>;
Ntemplate <> struct hash<int>;
Ntemplate <> struct hash<unsigned int>;
Ntemplate <> struct hash<long>;
Ntemplate <> struct hash<long long>;
Ntemplate <> struct hash<unsigned long>;
Ntemplate <> struct hash<unsigned long long>;
N
Ntemplate <> struct hash<float>;
Ntemplate <> struct hash<double>;
Ntemplate <> struct hash<long double>;
N
Ntemplate<class T> struct hash<T*>;
Ntemplate <> struct hash<nullptr_t>;  // C++17
N
N}  // std
N
NPOLICY:  For non-variadic implementations, the number of arguments is limited
N         to 3.  It is hoped that the need for non-variadic implementations
N         will be minimal.
N
N*/
N
N#include <__config>
N#include <type_traits>
N#include <typeinfo>
N#include <exception>
N#include <memory>
N#include <tuple>
N#include <utility>
N
N#include <__functional_base>
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N_LIBCPP_BEGIN_NAMESPACE_STD
Xnamespace std { inline namespace __2 {
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _Tp = void>
N#else
Stemplate <class _Tp>
N#endif
Nstruct _LIBCPP_TEMPLATE_VIS plus : binary_function<_Tp, _Tp, _Tp>
Xstruct  plus : binary_function<_Tp, _Tp, _Tp>
N{
N    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X    constexpr __attribute__ ((__always_inline__))
N    _Tp operator()(const _Tp& __x, const _Tp& __y) const
N        {return __x + __y;}
N};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <>
Nstruct _LIBCPP_TEMPLATE_VIS plus<void>
Xstruct  plus<void>
N{
N    template <class _T1, class _T2>
N    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X    constexpr __attribute__ ((__always_inline__))
N    auto operator()(_T1&& __t, _T2&& __u) const
N    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) + _VSTD::forward<_T2>(__u)))
X    noexcept(noexcept(std::__2::forward<_T1>(__t) + std::__2::forward<_T2>(__u)))
N    -> decltype        (_VSTD::forward<_T1>(__t) + _VSTD::forward<_T2>(__u))
X    -> decltype        (std::__2::forward<_T1>(__t) + std::__2::forward<_T2>(__u))
N        { return        _VSTD::forward<_T1>(__t) + _VSTD::forward<_T2>(__u); }
X        { return        std::__2::forward<_T1>(__t) + std::__2::forward<_T2>(__u); }
N    typedef void is_transparent;
N};
N#endif
N
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _Tp = void>
N#else
Stemplate <class _Tp>
N#endif
Nstruct _LIBCPP_TEMPLATE_VIS minus : binary_function<_Tp, _Tp, _Tp>
Xstruct  minus : binary_function<_Tp, _Tp, _Tp>
N{
N    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X    constexpr __attribute__ ((__always_inline__))
N    _Tp operator()(const _Tp& __x, const _Tp& __y) const
N        {return __x - __y;}
N};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <>
Nstruct _LIBCPP_TEMPLATE_VIS minus<void>
Xstruct  minus<void>
N{
N    template <class _T1, class _T2>
N    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X    constexpr __attribute__ ((__always_inline__))
N    auto operator()(_T1&& __t, _T2&& __u) const
N    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) - _VSTD::forward<_T2>(__u)))
X    noexcept(noexcept(std::__2::forward<_T1>(__t) - std::__2::forward<_T2>(__u)))
N    -> decltype        (_VSTD::forward<_T1>(__t) - _VSTD::forward<_T2>(__u))
X    -> decltype        (std::__2::forward<_T1>(__t) - std::__2::forward<_T2>(__u))
N        { return        _VSTD::forward<_T1>(__t) - _VSTD::forward<_T2>(__u); }
X        { return        std::__2::forward<_T1>(__t) - std::__2::forward<_T2>(__u); }
N    typedef void is_transparent;
N};
N#endif
N
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _Tp = void>
N#else
Stemplate <class _Tp>
N#endif
Nstruct _LIBCPP_TEMPLATE_VIS multiplies : binary_function<_Tp, _Tp, _Tp>
Xstruct  multiplies : binary_function<_Tp, _Tp, _Tp>
N{
N    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X    constexpr __attribute__ ((__always_inline__))
N    _Tp operator()(const _Tp& __x, const _Tp& __y) const
N        {return __x * __y;}
N};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <>
Nstruct _LIBCPP_TEMPLATE_VIS multiplies<void>
Xstruct  multiplies<void>
N{
N    template <class _T1, class _T2>
N    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X    constexpr __attribute__ ((__always_inline__))
N    auto operator()(_T1&& __t, _T2&& __u) const
N    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) * _VSTD::forward<_T2>(__u)))
X    noexcept(noexcept(std::__2::forward<_T1>(__t) * std::__2::forward<_T2>(__u)))
N    -> decltype        (_VSTD::forward<_T1>(__t) * _VSTD::forward<_T2>(__u))
X    -> decltype        (std::__2::forward<_T1>(__t) * std::__2::forward<_T2>(__u))
N        { return        _VSTD::forward<_T1>(__t) * _VSTD::forward<_T2>(__u); }
X        { return        std::__2::forward<_T1>(__t) * std::__2::forward<_T2>(__u); }
N    typedef void is_transparent;
N};
N#endif
N
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _Tp = void>
N#else
Stemplate <class _Tp>
N#endif
Nstruct _LIBCPP_TEMPLATE_VIS divides : binary_function<_Tp, _Tp, _Tp>
Xstruct  divides : binary_function<_Tp, _Tp, _Tp>
N{
N    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X    constexpr __attribute__ ((__always_inline__))
N    _Tp operator()(const _Tp& __x, const _Tp& __y) const
N        {return __x / __y;}
N};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <>
Nstruct _LIBCPP_TEMPLATE_VIS divides<void>
Xstruct  divides<void>
N{
N    template <class _T1, class _T2>
N    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X    constexpr __attribute__ ((__always_inline__))
N    auto operator()(_T1&& __t, _T2&& __u) const
N    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) / _VSTD::forward<_T2>(__u)))
X    noexcept(noexcept(std::__2::forward<_T1>(__t) / std::__2::forward<_T2>(__u)))
N    -> decltype        (_VSTD::forward<_T1>(__t) / _VSTD::forward<_T2>(__u))
X    -> decltype        (std::__2::forward<_T1>(__t) / std::__2::forward<_T2>(__u))
N        { return        _VSTD::forward<_T1>(__t) / _VSTD::forward<_T2>(__u); }
X        { return        std::__2::forward<_T1>(__t) / std::__2::forward<_T2>(__u); }
N    typedef void is_transparent;
N};
N#endif
N
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _Tp = void>
N#else
Stemplate <class _Tp>
N#endif
Nstruct _LIBCPP_TEMPLATE_VIS modulus : binary_function<_Tp, _Tp, _Tp>
Xstruct  modulus : binary_function<_Tp, _Tp, _Tp>
N{
N    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X    constexpr __attribute__ ((__always_inline__))
N    _Tp operator()(const _Tp& __x, const _Tp& __y) const
N        {return __x % __y;}
N};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <>
Nstruct _LIBCPP_TEMPLATE_VIS modulus<void>
Xstruct  modulus<void>
N{
N    template <class _T1, class _T2>
N    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X    constexpr __attribute__ ((__always_inline__))
N    auto operator()(_T1&& __t, _T2&& __u) const
N    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) % _VSTD::forward<_T2>(__u)))
X    noexcept(noexcept(std::__2::forward<_T1>(__t) % std::__2::forward<_T2>(__u)))
N    -> decltype        (_VSTD::forward<_T1>(__t) % _VSTD::forward<_T2>(__u))
X    -> decltype        (std::__2::forward<_T1>(__t) % std::__2::forward<_T2>(__u))
N        { return        _VSTD::forward<_T1>(__t) % _VSTD::forward<_T2>(__u); }
X        { return        std::__2::forward<_T1>(__t) % std::__2::forward<_T2>(__u); }
N    typedef void is_transparent;
N};
N#endif
N
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _Tp = void>
N#else
Stemplate <class _Tp>
N#endif
Nstruct _LIBCPP_TEMPLATE_VIS negate : unary_function<_Tp, _Tp>
Xstruct  negate : unary_function<_Tp, _Tp>
N{
N    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X    constexpr __attribute__ ((__always_inline__))
N    _Tp operator()(const _Tp& __x) const
N        {return -__x;}
N};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <>
Nstruct _LIBCPP_TEMPLATE_VIS negate<void>
Xstruct  negate<void>
N{
N    template <class _Tp>
N    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X    constexpr __attribute__ ((__always_inline__))
N    auto operator()(_Tp&& __x) const
N    _NOEXCEPT_(noexcept(- _VSTD::forward<_Tp>(__x)))
X    noexcept(noexcept(- std::__2::forward<_Tp>(__x)))
N    -> decltype        (- _VSTD::forward<_Tp>(__x))
X    -> decltype        (- std::__2::forward<_Tp>(__x))
N        { return        - _VSTD::forward<_Tp>(__x); }
X        { return        - std::__2::forward<_Tp>(__x); }
N    typedef void is_transparent;
N};
N#endif
N
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _Tp = void>
N#else
Stemplate <class _Tp>
N#endif
Nstruct _LIBCPP_TEMPLATE_VIS equal_to : binary_function<_Tp, _Tp, bool>
Xstruct  equal_to : binary_function<_Tp, _Tp, bool>
N{
N    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X    constexpr __attribute__ ((__always_inline__))
N    bool operator()(const _Tp& __x, const _Tp& __y) const
N        {return __x == __y;}
N};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <>
Nstruct _LIBCPP_TEMPLATE_VIS equal_to<void>
Xstruct  equal_to<void>
N{
N    template <class _T1, class _T2>
N    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X    constexpr __attribute__ ((__always_inline__))
N    auto operator()(_T1&& __t, _T2&& __u) const
N    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) == _VSTD::forward<_T2>(__u)))
X    noexcept(noexcept(std::__2::forward<_T1>(__t) == std::__2::forward<_T2>(__u)))
N    -> decltype        (_VSTD::forward<_T1>(__t) == _VSTD::forward<_T2>(__u))
X    -> decltype        (std::__2::forward<_T1>(__t) == std::__2::forward<_T2>(__u))
N        { return        _VSTD::forward<_T1>(__t) == _VSTD::forward<_T2>(__u); }
X        { return        std::__2::forward<_T1>(__t) == std::__2::forward<_T2>(__u); }
N    typedef void is_transparent;
N};
N#endif
N
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _Tp = void>
N#else
Stemplate <class _Tp>
N#endif
Nstruct _LIBCPP_TEMPLATE_VIS not_equal_to : binary_function<_Tp, _Tp, bool>
Xstruct  not_equal_to : binary_function<_Tp, _Tp, bool>
N{
N    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X    constexpr __attribute__ ((__always_inline__))
N    bool operator()(const _Tp& __x, const _Tp& __y) const
N        {return __x != __y;}
N};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <>
Nstruct _LIBCPP_TEMPLATE_VIS not_equal_to<void>
Xstruct  not_equal_to<void>
N{
N    template <class _T1, class _T2>
N    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X    constexpr __attribute__ ((__always_inline__))
N    auto operator()(_T1&& __t, _T2&& __u) const
N    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) != _VSTD::forward<_T2>(__u)))
X    noexcept(noexcept(std::__2::forward<_T1>(__t) != std::__2::forward<_T2>(__u)))
N    -> decltype        (_VSTD::forward<_T1>(__t) != _VSTD::forward<_T2>(__u))
X    -> decltype        (std::__2::forward<_T1>(__t) != std::__2::forward<_T2>(__u))
N        { return        _VSTD::forward<_T1>(__t) != _VSTD::forward<_T2>(__u); }
X        { return        std::__2::forward<_T1>(__t) != std::__2::forward<_T2>(__u); }
N    typedef void is_transparent;
N};
N#endif
N
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _Tp = void>
N#else
Stemplate <class _Tp>
N#endif
Nstruct _LIBCPP_TEMPLATE_VIS greater : binary_function<_Tp, _Tp, bool>
Xstruct  greater : binary_function<_Tp, _Tp, bool>
N{
N    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X    constexpr __attribute__ ((__always_inline__))
N    bool operator()(const _Tp& __x, const _Tp& __y) const
N        {return __x > __y;}
N};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <>
Nstruct _LIBCPP_TEMPLATE_VIS greater<void>
Xstruct  greater<void>
N{
N    template <class _T1, class _T2>
N    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X    constexpr __attribute__ ((__always_inline__))
N    auto operator()(_T1&& __t, _T2&& __u) const
N    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) > _VSTD::forward<_T2>(__u)))
X    noexcept(noexcept(std::__2::forward<_T1>(__t) > std::__2::forward<_T2>(__u)))
N    -> decltype        (_VSTD::forward<_T1>(__t) > _VSTD::forward<_T2>(__u))
X    -> decltype        (std::__2::forward<_T1>(__t) > std::__2::forward<_T2>(__u))
N        { return        _VSTD::forward<_T1>(__t) > _VSTD::forward<_T2>(__u); }
X        { return        std::__2::forward<_T1>(__t) > std::__2::forward<_T2>(__u); }
N    typedef void is_transparent;
N};
N#endif
N
N
N// less in <__functional_base>
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _Tp = void>
N#else
Stemplate <class _Tp>
N#endif
Nstruct _LIBCPP_TEMPLATE_VIS greater_equal : binary_function<_Tp, _Tp, bool>
Xstruct  greater_equal : binary_function<_Tp, _Tp, bool>
N{
N    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X    constexpr __attribute__ ((__always_inline__))
N    bool operator()(const _Tp& __x, const _Tp& __y) const
N        {return __x >= __y;}
N};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <>
Nstruct _LIBCPP_TEMPLATE_VIS greater_equal<void>
Xstruct  greater_equal<void>
N{
N    template <class _T1, class _T2>
N    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X    constexpr __attribute__ ((__always_inline__))
N    auto operator()(_T1&& __t, _T2&& __u) const
N    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) >= _VSTD::forward<_T2>(__u)))
X    noexcept(noexcept(std::__2::forward<_T1>(__t) >= std::__2::forward<_T2>(__u)))
N    -> decltype        (_VSTD::forward<_T1>(__t) >= _VSTD::forward<_T2>(__u))
X    -> decltype        (std::__2::forward<_T1>(__t) >= std::__2::forward<_T2>(__u))
N        { return        _VSTD::forward<_T1>(__t) >= _VSTD::forward<_T2>(__u); }
X        { return        std::__2::forward<_T1>(__t) >= std::__2::forward<_T2>(__u); }
N    typedef void is_transparent;
N};
N#endif
N
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _Tp = void>
N#else
Stemplate <class _Tp>
N#endif
Nstruct _LIBCPP_TEMPLATE_VIS less_equal : binary_function<_Tp, _Tp, bool>
Xstruct  less_equal : binary_function<_Tp, _Tp, bool>
N{
N    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X    constexpr __attribute__ ((__always_inline__))
N    bool operator()(const _Tp& __x, const _Tp& __y) const
N        {return __x <= __y;}
N};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <>
Nstruct _LIBCPP_TEMPLATE_VIS less_equal<void>
Xstruct  less_equal<void>
N{
N    template <class _T1, class _T2>
N    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X    constexpr __attribute__ ((__always_inline__))
N    auto operator()(_T1&& __t, _T2&& __u) const
N    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) <= _VSTD::forward<_T2>(__u)))
X    noexcept(noexcept(std::__2::forward<_T1>(__t) <= std::__2::forward<_T2>(__u)))
N    -> decltype        (_VSTD::forward<_T1>(__t) <= _VSTD::forward<_T2>(__u))
X    -> decltype        (std::__2::forward<_T1>(__t) <= std::__2::forward<_T2>(__u))
N        { return        _VSTD::forward<_T1>(__t) <= _VSTD::forward<_T2>(__u); }
X        { return        std::__2::forward<_T1>(__t) <= std::__2::forward<_T2>(__u); }
N    typedef void is_transparent;
N};
N#endif
N
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _Tp = void>
N#else
Stemplate <class _Tp>
N#endif
Nstruct _LIBCPP_TEMPLATE_VIS logical_and : binary_function<_Tp, _Tp, bool>
Xstruct  logical_and : binary_function<_Tp, _Tp, bool>
N{
N    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X    constexpr __attribute__ ((__always_inline__))
N    bool operator()(const _Tp& __x, const _Tp& __y) const
N        {return __x && __y;}
N};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <>
Nstruct _LIBCPP_TEMPLATE_VIS logical_and<void>
Xstruct  logical_and<void>
N{
N    template <class _T1, class _T2>
N    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X    constexpr __attribute__ ((__always_inline__))
N    auto operator()(_T1&& __t, _T2&& __u) const
N    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) && _VSTD::forward<_T2>(__u)))
X    noexcept(noexcept(std::__2::forward<_T1>(__t) && std::__2::forward<_T2>(__u)))
N    -> decltype        (_VSTD::forward<_T1>(__t) && _VSTD::forward<_T2>(__u))
X    -> decltype        (std::__2::forward<_T1>(__t) && std::__2::forward<_T2>(__u))
N        { return        _VSTD::forward<_T1>(__t) && _VSTD::forward<_T2>(__u); }
X        { return        std::__2::forward<_T1>(__t) && std::__2::forward<_T2>(__u); }
N    typedef void is_transparent;
N};
N#endif
N
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _Tp = void>
N#else
Stemplate <class _Tp>
N#endif
Nstruct _LIBCPP_TEMPLATE_VIS logical_or : binary_function<_Tp, _Tp, bool>
Xstruct  logical_or : binary_function<_Tp, _Tp, bool>
N{
N    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X    constexpr __attribute__ ((__always_inline__))
N    bool operator()(const _Tp& __x, const _Tp& __y) const
N        {return __x || __y;}
N};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <>
Nstruct _LIBCPP_TEMPLATE_VIS logical_or<void>
Xstruct  logical_or<void>
N{
N    template <class _T1, class _T2>
N    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X    constexpr __attribute__ ((__always_inline__))
N    auto operator()(_T1&& __t, _T2&& __u) const
N    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) || _VSTD::forward<_T2>(__u)))
X    noexcept(noexcept(std::__2::forward<_T1>(__t) || std::__2::forward<_T2>(__u)))
N    -> decltype        (_VSTD::forward<_T1>(__t) || _VSTD::forward<_T2>(__u))
X    -> decltype        (std::__2::forward<_T1>(__t) || std::__2::forward<_T2>(__u))
N        { return        _VSTD::forward<_T1>(__t) || _VSTD::forward<_T2>(__u); }
X        { return        std::__2::forward<_T1>(__t) || std::__2::forward<_T2>(__u); }
N    typedef void is_transparent;
N};
N#endif
N
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _Tp = void>
N#else
Stemplate <class _Tp>
N#endif
Nstruct _LIBCPP_TEMPLATE_VIS logical_not : unary_function<_Tp, bool>
Xstruct  logical_not : unary_function<_Tp, bool>
N{
N    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X    constexpr __attribute__ ((__always_inline__))
N    bool operator()(const _Tp& __x) const
N        {return !__x;}
N};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <>
Nstruct _LIBCPP_TEMPLATE_VIS logical_not<void>
Xstruct  logical_not<void>
N{
N    template <class _Tp>
N    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X    constexpr __attribute__ ((__always_inline__))
N    auto operator()(_Tp&& __x) const
N    _NOEXCEPT_(noexcept(!_VSTD::forward<_Tp>(__x)))
X    noexcept(noexcept(!std::__2::forward<_Tp>(__x)))
N    -> decltype        (!_VSTD::forward<_Tp>(__x))
X    -> decltype        (!std::__2::forward<_Tp>(__x))
N        { return        !_VSTD::forward<_Tp>(__x); }
X        { return        !std::__2::forward<_Tp>(__x); }
N    typedef void is_transparent;
N};
N#endif
N
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _Tp = void>
N#else
Stemplate <class _Tp>
N#endif
Nstruct _LIBCPP_TEMPLATE_VIS bit_and : binary_function<_Tp, _Tp, _Tp>
Xstruct  bit_and : binary_function<_Tp, _Tp, _Tp>
N{
N    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X    constexpr __attribute__ ((__always_inline__))
N    _Tp operator()(const _Tp& __x, const _Tp& __y) const
N        {return __x & __y;}
N};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <>
Nstruct _LIBCPP_TEMPLATE_VIS bit_and<void>
Xstruct  bit_and<void>
N{
N    template <class _T1, class _T2>
N    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X    constexpr __attribute__ ((__always_inline__))
N    auto operator()(_T1&& __t, _T2&& __u) const
N    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) & _VSTD::forward<_T2>(__u)))
X    noexcept(noexcept(std::__2::forward<_T1>(__t) & std::__2::forward<_T2>(__u)))
N    -> decltype        (_VSTD::forward<_T1>(__t) & _VSTD::forward<_T2>(__u))
X    -> decltype        (std::__2::forward<_T1>(__t) & std::__2::forward<_T2>(__u))
N        { return        _VSTD::forward<_T1>(__t) & _VSTD::forward<_T2>(__u); }
X        { return        std::__2::forward<_T1>(__t) & std::__2::forward<_T2>(__u); }
N    typedef void is_transparent;
N};
N#endif
N
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _Tp = void>
N#else
Stemplate <class _Tp>
N#endif
Nstruct _LIBCPP_TEMPLATE_VIS bit_or : binary_function<_Tp, _Tp, _Tp>
Xstruct  bit_or : binary_function<_Tp, _Tp, _Tp>
N{
N    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X    constexpr __attribute__ ((__always_inline__))
N    _Tp operator()(const _Tp& __x, const _Tp& __y) const
N        {return __x | __y;}
N};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <>
Nstruct _LIBCPP_TEMPLATE_VIS bit_or<void>
Xstruct  bit_or<void>
N{
N    template <class _T1, class _T2>
N    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X    constexpr __attribute__ ((__always_inline__))
N    auto operator()(_T1&& __t, _T2&& __u) const
N    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) | _VSTD::forward<_T2>(__u)))
X    noexcept(noexcept(std::__2::forward<_T1>(__t) | std::__2::forward<_T2>(__u)))
N    -> decltype        (_VSTD::forward<_T1>(__t) | _VSTD::forward<_T2>(__u))
X    -> decltype        (std::__2::forward<_T1>(__t) | std::__2::forward<_T2>(__u))
N        { return        _VSTD::forward<_T1>(__t) | _VSTD::forward<_T2>(__u); }
X        { return        std::__2::forward<_T1>(__t) | std::__2::forward<_T2>(__u); }
N    typedef void is_transparent;
N};
N#endif
N
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _Tp = void>
N#else
Stemplate <class _Tp>
N#endif
Nstruct _LIBCPP_TEMPLATE_VIS bit_xor : binary_function<_Tp, _Tp, _Tp>
Xstruct  bit_xor : binary_function<_Tp, _Tp, _Tp>
N{
N    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X    constexpr __attribute__ ((__always_inline__))
N    _Tp operator()(const _Tp& __x, const _Tp& __y) const
N        {return __x ^ __y;}
N};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <>
Nstruct _LIBCPP_TEMPLATE_VIS bit_xor<void>
Xstruct  bit_xor<void>
N{
N    template <class _T1, class _T2>
N    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X    constexpr __attribute__ ((__always_inline__))
N    auto operator()(_T1&& __t, _T2&& __u) const
N    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) ^ _VSTD::forward<_T2>(__u)))
X    noexcept(noexcept(std::__2::forward<_T1>(__t) ^ std::__2::forward<_T2>(__u)))
N    -> decltype        (_VSTD::forward<_T1>(__t) ^ _VSTD::forward<_T2>(__u))
X    -> decltype        (std::__2::forward<_T1>(__t) ^ std::__2::forward<_T2>(__u))
N        { return        _VSTD::forward<_T1>(__t) ^ _VSTD::forward<_T2>(__u); }
X        { return        std::__2::forward<_T1>(__t) ^ std::__2::forward<_T2>(__u); }
N    typedef void is_transparent;
N};
N#endif
N
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _Tp = void>
Nstruct _LIBCPP_TEMPLATE_VIS bit_not : unary_function<_Tp, _Tp>
Xstruct  bit_not : unary_function<_Tp, _Tp>
N{
N    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X    constexpr __attribute__ ((__always_inline__))
N    _Tp operator()(const _Tp& __x) const
N        {return ~__x;}
N};
N
Ntemplate <>
Nstruct _LIBCPP_TEMPLATE_VIS bit_not<void>
Xstruct  bit_not<void>
N{
N    template <class _Tp>
N    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X    constexpr __attribute__ ((__always_inline__))
N    auto operator()(_Tp&& __x) const
N    _NOEXCEPT_(noexcept(~_VSTD::forward<_Tp>(__x)))
X    noexcept(noexcept(~std::__2::forward<_Tp>(__x)))
N    -> decltype        (~_VSTD::forward<_Tp>(__x))
X    -> decltype        (~std::__2::forward<_Tp>(__x))
N        { return        ~_VSTD::forward<_Tp>(__x); }
X        { return        ~std::__2::forward<_Tp>(__x); }
N    typedef void is_transparent;
N};
N#endif
N
Ntemplate <class _Predicate>
Nclass _LIBCPP_TEMPLATE_VIS unary_negate
Xclass  unary_negate
N    : public unary_function<typename _Predicate::argument_type, bool>
N{
N    _Predicate __pred_;
Npublic:
N    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X    constexpr __attribute__ ((__always_inline__))
N    explicit unary_negate(const _Predicate& __pred)
N        : __pred_(__pred) {}
N    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X    constexpr __attribute__ ((__always_inline__))
N    bool operator()(const typename _Predicate::argument_type& __x) const
N        {return !__pred_(__x);}
N};
N
Ntemplate <class _Predicate>
Ninline _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
Xinline constexpr __attribute__ ((__always_inline__))
Nunary_negate<_Predicate>
Nnot1(const _Predicate& __pred) {return unary_negate<_Predicate>(__pred);}
N
Ntemplate <class _Predicate>
Nclass _LIBCPP_TEMPLATE_VIS binary_negate
Xclass  binary_negate
N    : public binary_function<typename _Predicate::first_argument_type,
N                             typename _Predicate::second_argument_type,
N                             bool>
N{
N    _Predicate __pred_;
Npublic:
N    _LIBCPP_INLINE_VISIBILITY explicit _LIBCPP_CONSTEXPR_AFTER_CXX11 
X    __attribute__ ((__always_inline__)) explicit constexpr 
N    binary_negate(const _Predicate& __pred) : __pred_(__pred) {}
N
N    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
X    constexpr __attribute__ ((__always_inline__))
N    bool operator()(const typename _Predicate::first_argument_type& __x,
N                    const typename _Predicate::second_argument_type& __y) const
N        {return !__pred_(__x, __y);}
N};
N
Ntemplate <class _Predicate>
Ninline _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
Xinline constexpr __attribute__ ((__always_inline__))
Nbinary_negate<_Predicate>
Nnot2(const _Predicate& __pred) {return binary_negate<_Predicate>(__pred);}
N
N#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_BINDERS)
X#if 14 <= 14 || 0L
Ntemplate <class __Operation>
Nclass _LIBCPP_TEMPLATE_VIS binder1st
Xclass  binder1st
N    : public unary_function<typename __Operation::second_argument_type,
N                            typename __Operation::result_type>
N{
Nprotected:
N    __Operation                               op;
N    typename __Operation::first_argument_type value;
Npublic:
N    _LIBCPP_INLINE_VISIBILITY binder1st(const __Operation& __x,
X    __attribute__ ((__always_inline__)) binder1st(const __Operation& __x,
N                               const typename __Operation::first_argument_type __y)
N        : op(__x), value(__y) {}
N    _LIBCPP_INLINE_VISIBILITY typename __Operation::result_type operator()
X    __attribute__ ((__always_inline__)) typename __Operation::result_type operator()
N        (typename __Operation::second_argument_type& __x) const
N            {return op(value, __x);}
N    _LIBCPP_INLINE_VISIBILITY typename __Operation::result_type operator()
X    __attribute__ ((__always_inline__)) typename __Operation::result_type operator()
N        (const typename __Operation::second_argument_type& __x) const
N            {return op(value, __x);}
N};
N
Ntemplate <class __Operation, class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbinder1st<__Operation>
Nbind1st(const __Operation& __op, const _Tp& __x)
N    {return binder1st<__Operation>(__op, __x);}
N
Ntemplate <class __Operation>
Nclass _LIBCPP_TEMPLATE_VIS binder2nd
Xclass  binder2nd
N    : public unary_function<typename __Operation::first_argument_type,
N                            typename __Operation::result_type>
N{
Nprotected:
N    __Operation                                op;
N    typename __Operation::second_argument_type value;
Npublic:
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    binder2nd(const __Operation& __x, const typename __Operation::second_argument_type __y)
N        : op(__x), value(__y) {}
N    _LIBCPP_INLINE_VISIBILITY typename __Operation::result_type operator()
X    __attribute__ ((__always_inline__)) typename __Operation::result_type operator()
N        (      typename __Operation::first_argument_type& __x) const
N            {return op(__x, value);}
N    _LIBCPP_INLINE_VISIBILITY typename __Operation::result_type operator()
X    __attribute__ ((__always_inline__)) typename __Operation::result_type operator()
N        (const typename __Operation::first_argument_type& __x) const
N            {return op(__x, value);}
N};
N
Ntemplate <class __Operation, class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbinder2nd<__Operation>
Nbind2nd(const __Operation& __op, const _Tp& __x)
N    {return binder2nd<__Operation>(__op, __x);}
N
Ntemplate <class _Arg, class _Result>
Nclass _LIBCPP_TEMPLATE_VIS pointer_to_unary_function
Xclass  pointer_to_unary_function
N    : public unary_function<_Arg, _Result>
N{
N    _Result (*__f_)(_Arg);
Npublic:
N    _LIBCPP_INLINE_VISIBILITY explicit pointer_to_unary_function(_Result (*__f)(_Arg))
X    __attribute__ ((__always_inline__)) explicit pointer_to_unary_function(_Result (*__f)(_Arg))
N        : __f_(__f) {}
N    _LIBCPP_INLINE_VISIBILITY _Result operator()(_Arg __x) const
X    __attribute__ ((__always_inline__)) _Result operator()(_Arg __x) const
N        {return __f_(__x);}
N};
N
Ntemplate <class _Arg, class _Result>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Npointer_to_unary_function<_Arg,_Result>
Nptr_fun(_Result (*__f)(_Arg))
N    {return pointer_to_unary_function<_Arg,_Result>(__f);}
N
Ntemplate <class _Arg1, class _Arg2, class _Result>
Nclass _LIBCPP_TEMPLATE_VIS pointer_to_binary_function
Xclass  pointer_to_binary_function
N    : public binary_function<_Arg1, _Arg2, _Result>
N{
N    _Result (*__f_)(_Arg1, _Arg2);
Npublic:
N    _LIBCPP_INLINE_VISIBILITY explicit pointer_to_binary_function(_Result (*__f)(_Arg1, _Arg2))
X    __attribute__ ((__always_inline__)) explicit pointer_to_binary_function(_Result (*__f)(_Arg1, _Arg2))
N        : __f_(__f) {}
N    _LIBCPP_INLINE_VISIBILITY _Result operator()(_Arg1 __x, _Arg2 __y) const
X    __attribute__ ((__always_inline__)) _Result operator()(_Arg1 __x, _Arg2 __y) const
N        {return __f_(__x, __y);}
N};
N
Ntemplate <class _Arg1, class _Arg2, class _Result>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Npointer_to_binary_function<_Arg1,_Arg2,_Result>
Nptr_fun(_Result (*__f)(_Arg1,_Arg2))
N    {return pointer_to_binary_function<_Arg1,_Arg2,_Result>(__f);}
N
Ntemplate<class _Sp, class _Tp>
Nclass _LIBCPP_TEMPLATE_VIS mem_fun_t : public unary_function<_Tp*, _Sp>
Xclass  mem_fun_t : public unary_function<_Tp*, _Sp>
N{
N    _Sp (_Tp::*__p_)();
Npublic:
N    _LIBCPP_INLINE_VISIBILITY explicit mem_fun_t(_Sp (_Tp::*__p)())
X    __attribute__ ((__always_inline__)) explicit mem_fun_t(_Sp (_Tp::*__p)())
N        : __p_(__p) {}
N    _LIBCPP_INLINE_VISIBILITY _Sp operator()(_Tp* __p) const
X    __attribute__ ((__always_inline__)) _Sp operator()(_Tp* __p) const
N        {return (__p->*__p_)();}
N};
N
Ntemplate<class _Sp, class _Tp, class _Ap>
Nclass _LIBCPP_TEMPLATE_VIS mem_fun1_t : public binary_function<_Tp*, _Ap, _Sp>
Xclass  mem_fun1_t : public binary_function<_Tp*, _Ap, _Sp>
N{
N    _Sp (_Tp::*__p_)(_Ap);
Npublic:
N    _LIBCPP_INLINE_VISIBILITY explicit mem_fun1_t(_Sp (_Tp::*__p)(_Ap))
X    __attribute__ ((__always_inline__)) explicit mem_fun1_t(_Sp (_Tp::*__p)(_Ap))
N        : __p_(__p) {}
N    _LIBCPP_INLINE_VISIBILITY _Sp operator()(_Tp* __p, _Ap __x) const
X    __attribute__ ((__always_inline__)) _Sp operator()(_Tp* __p, _Ap __x) const
N        {return (__p->*__p_)(__x);}
N};
N
Ntemplate<class _Sp, class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nmem_fun_t<_Sp,_Tp>
Nmem_fun(_Sp (_Tp::*__f)())
N    {return mem_fun_t<_Sp,_Tp>(__f);}
N
Ntemplate<class _Sp, class _Tp, class _Ap>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nmem_fun1_t<_Sp,_Tp,_Ap>
Nmem_fun(_Sp (_Tp::*__f)(_Ap))
N    {return mem_fun1_t<_Sp,_Tp,_Ap>(__f);}
N
Ntemplate<class _Sp, class _Tp>
Nclass _LIBCPP_TEMPLATE_VIS mem_fun_ref_t : public unary_function<_Tp, _Sp>
Xclass  mem_fun_ref_t : public unary_function<_Tp, _Sp>
N{
N    _Sp (_Tp::*__p_)();
Npublic:
N    _LIBCPP_INLINE_VISIBILITY explicit mem_fun_ref_t(_Sp (_Tp::*__p)())
X    __attribute__ ((__always_inline__)) explicit mem_fun_ref_t(_Sp (_Tp::*__p)())
N        : __p_(__p) {}
N    _LIBCPP_INLINE_VISIBILITY _Sp operator()(_Tp& __p) const
X    __attribute__ ((__always_inline__)) _Sp operator()(_Tp& __p) const
N        {return (__p.*__p_)();}
N};
N
Ntemplate<class _Sp, class _Tp, class _Ap>
Nclass _LIBCPP_TEMPLATE_VIS mem_fun1_ref_t : public binary_function<_Tp, _Ap, _Sp>
Xclass  mem_fun1_ref_t : public binary_function<_Tp, _Ap, _Sp>
N{
N    _Sp (_Tp::*__p_)(_Ap);
Npublic:
N    _LIBCPP_INLINE_VISIBILITY explicit mem_fun1_ref_t(_Sp (_Tp::*__p)(_Ap))
X    __attribute__ ((__always_inline__)) explicit mem_fun1_ref_t(_Sp (_Tp::*__p)(_Ap))
N        : __p_(__p) {}
N    _LIBCPP_INLINE_VISIBILITY _Sp operator()(_Tp& __p, _Ap __x) const
X    __attribute__ ((__always_inline__)) _Sp operator()(_Tp& __p, _Ap __x) const
N        {return (__p.*__p_)(__x);}
N};
N
Ntemplate<class _Sp, class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nmem_fun_ref_t<_Sp,_Tp>
Nmem_fun_ref(_Sp (_Tp::*__f)())
N    {return mem_fun_ref_t<_Sp,_Tp>(__f);}
N
Ntemplate<class _Sp, class _Tp, class _Ap>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nmem_fun1_ref_t<_Sp,_Tp,_Ap>
Nmem_fun_ref(_Sp (_Tp::*__f)(_Ap))
N    {return mem_fun1_ref_t<_Sp,_Tp,_Ap>(__f);}
N
Ntemplate <class _Sp, class _Tp>
Nclass _LIBCPP_TEMPLATE_VIS const_mem_fun_t : public unary_function<const _Tp*, _Sp>
Xclass  const_mem_fun_t : public unary_function<const _Tp*, _Sp>
N{
N    _Sp (_Tp::*__p_)() const;
Npublic:
N    _LIBCPP_INLINE_VISIBILITY explicit const_mem_fun_t(_Sp (_Tp::*__p)() const)
X    __attribute__ ((__always_inline__)) explicit const_mem_fun_t(_Sp (_Tp::*__p)() const)
N        : __p_(__p) {}
N    _LIBCPP_INLINE_VISIBILITY _Sp operator()(const _Tp* __p) const
X    __attribute__ ((__always_inline__)) _Sp operator()(const _Tp* __p) const
N        {return (__p->*__p_)();}
N};
N
Ntemplate <class _Sp, class _Tp, class _Ap>
Nclass _LIBCPP_TEMPLATE_VIS const_mem_fun1_t : public binary_function<const _Tp*, _Ap, _Sp>
Xclass  const_mem_fun1_t : public binary_function<const _Tp*, _Ap, _Sp>
N{
N    _Sp (_Tp::*__p_)(_Ap) const;
Npublic:
N    _LIBCPP_INLINE_VISIBILITY explicit const_mem_fun1_t(_Sp (_Tp::*__p)(_Ap) const)
X    __attribute__ ((__always_inline__)) explicit const_mem_fun1_t(_Sp (_Tp::*__p)(_Ap) const)
N        : __p_(__p) {}
N    _LIBCPP_INLINE_VISIBILITY _Sp operator()(const _Tp* __p, _Ap __x) const
X    __attribute__ ((__always_inline__)) _Sp operator()(const _Tp* __p, _Ap __x) const
N        {return (__p->*__p_)(__x);}
N};
N
Ntemplate <class _Sp, class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nconst_mem_fun_t<_Sp,_Tp>
Nmem_fun(_Sp (_Tp::*__f)() const)
N    {return const_mem_fun_t<_Sp,_Tp>(__f);}
N
Ntemplate <class _Sp, class _Tp, class _Ap>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nconst_mem_fun1_t<_Sp,_Tp,_Ap>
Nmem_fun(_Sp (_Tp::*__f)(_Ap) const)
N    {return const_mem_fun1_t<_Sp,_Tp,_Ap>(__f);}
N
Ntemplate <class _Sp, class _Tp>
Nclass _LIBCPP_TEMPLATE_VIS const_mem_fun_ref_t : public unary_function<_Tp, _Sp>
Xclass  const_mem_fun_ref_t : public unary_function<_Tp, _Sp>
N{
N    _Sp (_Tp::*__p_)() const;
Npublic:
N    _LIBCPP_INLINE_VISIBILITY explicit const_mem_fun_ref_t(_Sp (_Tp::*__p)() const)
X    __attribute__ ((__always_inline__)) explicit const_mem_fun_ref_t(_Sp (_Tp::*__p)() const)
N        : __p_(__p) {}
N    _LIBCPP_INLINE_VISIBILITY _Sp operator()(const _Tp& __p) const
X    __attribute__ ((__always_inline__)) _Sp operator()(const _Tp& __p) const
N        {return (__p.*__p_)();}
N};
N
Ntemplate <class _Sp, class _Tp, class _Ap>
Nclass _LIBCPP_TEMPLATE_VIS const_mem_fun1_ref_t
Xclass  const_mem_fun1_ref_t
N    : public binary_function<_Tp, _Ap, _Sp>
N{
N    _Sp (_Tp::*__p_)(_Ap) const;
Npublic:
N    _LIBCPP_INLINE_VISIBILITY explicit const_mem_fun1_ref_t(_Sp (_Tp::*__p)(_Ap) const)
X    __attribute__ ((__always_inline__)) explicit const_mem_fun1_ref_t(_Sp (_Tp::*__p)(_Ap) const)
N        : __p_(__p) {}
N    _LIBCPP_INLINE_VISIBILITY _Sp operator()(const _Tp& __p, _Ap __x) const
X    __attribute__ ((__always_inline__)) _Sp operator()(const _Tp& __p, _Ap __x) const
N        {return (__p.*__p_)(__x);}
N};
N
Ntemplate <class _Sp, class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nconst_mem_fun_ref_t<_Sp,_Tp>
Nmem_fun_ref(_Sp (_Tp::*__f)() const)
N    {return const_mem_fun_ref_t<_Sp,_Tp>(__f);}
N
Ntemplate <class _Sp, class _Tp, class _Ap>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nconst_mem_fun1_ref_t<_Sp,_Tp,_Ap>
Nmem_fun_ref(_Sp (_Tp::*__f)(_Ap) const)
N    {return const_mem_fun1_ref_t<_Sp,_Tp,_Ap>(__f);}
N#endif
N
N////////////////////////////////////////////////////////////////////////////////
N//                                MEMFUN
N//==============================================================================
N
Ntemplate <class _Tp>
Nclass __mem_fn
N    : public __weak_result_type<_Tp>
N{
Npublic:
N    // types
N    typedef _Tp type;
Nprivate:
N    type __f_;
N
Npublic:
N    _LIBCPP_INLINE_VISIBILITY __mem_fn(type __f) _NOEXCEPT : __f_(__f) {}
X    __attribute__ ((__always_inline__)) __mem_fn(type __f) noexcept : __f_(__f) {}
N
N#ifndef _LIBCPP_CXX03_LANG
N    // invoke
N    template <class... _ArgTypes>
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    typename __invoke_return<type, _ArgTypes...>::type
N    operator() (_ArgTypes&&... __args) const {
N        return __invoke(__f_, _VSTD::forward<_ArgTypes>(__args)...);
X        return __invoke(__f_, std::__2::forward<_ArgTypes>(__args)...);
N    }
N#else
S
S    template <class _A0>
S    _LIBCPP_INLINE_VISIBILITY
S    typename __invoke_return0<type, _A0>::type
S    operator() (_A0& __a0) const {
S        return __invoke(__f_, __a0);
S    }
S
S    template <class _A0>
S    _LIBCPP_INLINE_VISIBILITY
S    typename __invoke_return0<type, _A0 const>::type
S    operator() (_A0 const& __a0) const {
S        return __invoke(__f_, __a0);
S    }
S
S    template <class _A0, class _A1>
S    _LIBCPP_INLINE_VISIBILITY
S    typename __invoke_return1<type, _A0, _A1>::type
S    operator() (_A0& __a0, _A1& __a1) const {
S        return __invoke(__f_, __a0, __a1);
S    }
S
S    template <class _A0, class _A1>
S    _LIBCPP_INLINE_VISIBILITY
S    typename __invoke_return1<type, _A0 const, _A1>::type
S    operator() (_A0 const& __a0, _A1& __a1) const {
S        return __invoke(__f_, __a0, __a1);
S    }
S
S    template <class _A0, class _A1>
S    _LIBCPP_INLINE_VISIBILITY
S    typename __invoke_return1<type, _A0, _A1 const>::type
S    operator() (_A0& __a0, _A1 const& __a1) const {
S        return __invoke(__f_, __a0, __a1);
S    }
S
S    template <class _A0, class _A1>
S    _LIBCPP_INLINE_VISIBILITY
S    typename __invoke_return1<type, _A0 const, _A1 const>::type
S    operator() (_A0 const& __a0, _A1 const& __a1) const {
S        return __invoke(__f_, __a0, __a1);
S    }
S
S    template <class _A0, class _A1, class _A2>
S    _LIBCPP_INLINE_VISIBILITY
S    typename __invoke_return2<type, _A0, _A1, _A2>::type
S    operator() (_A0& __a0, _A1& __a1, _A2& __a2) const {
S        return __invoke(__f_, __a0, __a1, __a2);
S    }
S
S    template <class _A0, class _A1, class _A2>
S    _LIBCPP_INLINE_VISIBILITY
S    typename __invoke_return2<type, _A0 const, _A1, _A2>::type
S    operator() (_A0 const& __a0, _A1& __a1, _A2& __a2) const {
S        return __invoke(__f_, __a0, __a1, __a2);
S    }
S
S    template <class _A0, class _A1, class _A2>
S    _LIBCPP_INLINE_VISIBILITY
S    typename __invoke_return2<type, _A0, _A1 const, _A2>::type
S    operator() (_A0& __a0, _A1 const& __a1, _A2& __a2) const {
S        return __invoke(__f_, __a0, __a1, __a2);
S    }
S
S    template <class _A0, class _A1, class _A2>
S    _LIBCPP_INLINE_VISIBILITY
S    typename __invoke_return2<type, _A0, _A1, _A2 const>::type
S    operator() (_A0& __a0, _A1& __a1, _A2 const& __a2) const {
S        return __invoke(__f_, __a0, __a1, __a2);
S    }
S
S    template <class _A0, class _A1, class _A2>
S    _LIBCPP_INLINE_VISIBILITY
S    typename __invoke_return2<type, _A0 const, _A1 const, _A2>::type
S    operator() (_A0 const& __a0, _A1 const& __a1, _A2& __a2) const {
S        return __invoke(__f_, __a0, __a1, __a2);
S    }
S
S    template <class _A0, class _A1, class _A2>
S    _LIBCPP_INLINE_VISIBILITY
S    typename __invoke_return2<type, _A0 const, _A1, _A2 const>::type
S    operator() (_A0 const& __a0, _A1& __a1, _A2 const& __a2) const {
S        return __invoke(__f_, __a0, __a1, __a2);
S    }
S
S    template <class _A0, class _A1, class _A2>
S    _LIBCPP_INLINE_VISIBILITY
S    typename __invoke_return2<type, _A0, _A1 const, _A2 const>::type
S    operator() (_A0& __a0, _A1 const& __a1, _A2 const& __a2) const {
S        return __invoke(__f_, __a0, __a1, __a2);
S    }
S
S    template <class _A0, class _A1, class _A2>
S    _LIBCPP_INLINE_VISIBILITY
S    typename __invoke_return2<type, _A0 const, _A1 const, _A2 const>::type
S    operator() (_A0 const& __a0, _A1 const& __a1, _A2 const& __a2) const {
S        return __invoke(__f_, __a0, __a1, __a2);
S    }
N#endif
N};
N
Ntemplate<class _Rp, class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N__mem_fn<_Rp _Tp::*>
Nmem_fn(_Rp _Tp::* __pm) _NOEXCEPT
Xmem_fn(_Rp _Tp::* __pm) noexcept
N{
N    return __mem_fn<_Rp _Tp::*>(__pm);
N}
N
N////////////////////////////////////////////////////////////////////////////////
N//                                FUNCTION
N//==============================================================================
N
N// bad_function_call
N
Nclass _LIBCPP_EXCEPTION_ABI bad_function_call
Xclass  bad_function_call
N    : public exception
N{
N#ifdef _LIBCPP_ABI_BAD_FUNCTION_CALL_KEY_FUNCTION
Npublic:
N    virtual ~bad_function_call() _NOEXCEPT;
X    virtual ~bad_function_call() noexcept;
N
N    virtual const char* what() const _NOEXCEPT;
X    virtual const char* what() const noexcept;
N#endif
N};
N
N_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE
X[[noreturn]] inline __attribute__ ((__always_inline__))
Nvoid __throw_bad_function_call()
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    throw bad_function_call();
N#else
N	_VSTD::abort();
X	std::__2::abort();
N#endif
N}
N
Ntemplate<class _Fp> class _LIBCPP_TEMPLATE_VIS function; // undefined
Xtemplate<class _Fp> class  function; 
N
Nnamespace __function
N{
N
Ntemplate<class _Rp>
Nstruct __maybe_derive_from_unary_function
N{
N};
N
Ntemplate<class _Rp, class _A1>
Nstruct __maybe_derive_from_unary_function<_Rp(_A1)>
N    : public unary_function<_A1, _Rp>
N{
N};
N
Ntemplate<class _Rp>
Nstruct __maybe_derive_from_binary_function
N{
N};
N
Ntemplate<class _Rp, class _A1, class _A2>
Nstruct __maybe_derive_from_binary_function<_Rp(_A1, _A2)>
N    : public binary_function<_A1, _A2, _Rp>
N{
N};
N
Ntemplate <class _Fp>
N_LIBCPP_INLINE_VISIBILITY
X__attribute__ ((__always_inline__))
Nbool __not_null(_Fp const&) { return true; }
N
Ntemplate <class _Fp>
N_LIBCPP_INLINE_VISIBILITY
X__attribute__ ((__always_inline__))
Nbool __not_null(_Fp* __ptr) { return __ptr; }
N
Ntemplate <class _Ret, class _Class>
N_LIBCPP_INLINE_VISIBILITY
X__attribute__ ((__always_inline__))
Nbool __not_null(_Ret _Class::*__ptr) { return __ptr; }
N
Ntemplate <class _Fp>
N_LIBCPP_INLINE_VISIBILITY
X__attribute__ ((__always_inline__))
Nbool __not_null(function<_Fp> const& __f) { return !!__f; }
N
N} // namespace __function
N
N#ifndef _LIBCPP_CXX03_LANG
N
Nnamespace __function {
N
Ntemplate<class _Fp> class __base;
N
Ntemplate<class _Rp, class ..._ArgTypes>
Nclass __base<_Rp(_ArgTypes...)>
N{
N    __base(const __base&);
N    __base& operator=(const __base&);
Npublic:
N    _LIBCPP_INLINE_VISIBILITY __base() {}
X    __attribute__ ((__always_inline__)) __base() {}
N    _LIBCPP_INLINE_VISIBILITY virtual ~__base() {}
X    __attribute__ ((__always_inline__)) virtual ~__base() {}
N    virtual __base* __clone() const = 0;
N    virtual void __clone(__base*) const = 0;
N    virtual void destroy() _NOEXCEPT = 0;
X    virtual void destroy() noexcept = 0;
N    virtual void destroy_deallocate() _NOEXCEPT = 0;
X    virtual void destroy_deallocate() noexcept = 0;
N    virtual _Rp operator()(_ArgTypes&& ...) = 0;
N#ifndef _LIBCPP_NO_RTTI
N    virtual const void* target(const type_info&) const _NOEXCEPT = 0;
X    virtual const void* target(const type_info&) const noexcept = 0;
N    virtual const std::type_info& target_type() const _NOEXCEPT = 0;
X    virtual const std::type_info& target_type() const noexcept = 0;
N#endif  // _LIBCPP_NO_RTTI
N};
N
Ntemplate<class _FD, class _Alloc, class _FB> class __func;
N
Ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
Nclass __func<_Fp, _Alloc, _Rp(_ArgTypes...)>
N    : public  __base<_Rp(_ArgTypes...)>
N{
N    __compressed_pair<_Fp, _Alloc> __f_;
Npublic:
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    explicit __func(_Fp&& __f)
N        : __f_(piecewise_construct, _VSTD::forward_as_tuple(_VSTD::move(__f)),
X        : __f_(piecewise_construct, std::__2::forward_as_tuple(std::__2::move(__f)),
N                                    _VSTD::forward_as_tuple()) {}
X                                    std::__2::forward_as_tuple()) {}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    explicit __func(const _Fp& __f, const _Alloc& __a)
N        : __f_(piecewise_construct, _VSTD::forward_as_tuple(__f),
X        : __f_(piecewise_construct, std::__2::forward_as_tuple(__f),
N                                    _VSTD::forward_as_tuple(__a)) {}
X                                    std::__2::forward_as_tuple(__a)) {}
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    explicit __func(const _Fp& __f, _Alloc&& __a)
N        : __f_(piecewise_construct, _VSTD::forward_as_tuple(__f),
X        : __f_(piecewise_construct, std::__2::forward_as_tuple(__f),
N                                    _VSTD::forward_as_tuple(_VSTD::move(__a))) {}
X                                    std::__2::forward_as_tuple(std::__2::move(__a))) {}
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    explicit __func(_Fp&& __f, _Alloc&& __a)
N        : __f_(piecewise_construct, _VSTD::forward_as_tuple(_VSTD::move(__f)),
X        : __f_(piecewise_construct, std::__2::forward_as_tuple(std::__2::move(__f)),
N                                    _VSTD::forward_as_tuple(_VSTD::move(__a))) {}
X                                    std::__2::forward_as_tuple(std::__2::move(__a))) {}
N    virtual __base<_Rp(_ArgTypes...)>* __clone() const;
N    virtual void __clone(__base<_Rp(_ArgTypes...)>*) const;
N    virtual void destroy() _NOEXCEPT;
X    virtual void destroy() noexcept;
N    virtual void destroy_deallocate() _NOEXCEPT;
X    virtual void destroy_deallocate() noexcept;
N    virtual _Rp operator()(_ArgTypes&& ... __arg);
N#ifndef _LIBCPP_NO_RTTI
N    virtual const void* target(const type_info&) const _NOEXCEPT;
X    virtual const void* target(const type_info&) const noexcept;
N    virtual const std::type_info& target_type() const _NOEXCEPT;
X    virtual const std::type_info& target_type() const noexcept;
N#endif  // _LIBCPP_NO_RTTI
N};
N
Ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
N__base<_Rp(_ArgTypes...)>*
N__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::__clone() const
N{
N    typedef allocator_traits<_Alloc> __alloc_traits;
N    typedef typename __rebind_alloc_helper<__alloc_traits, __func>::type _Ap;
N    _Ap __a(__f_.second());
N    typedef __allocator_destructor<_Ap> _Dp;
N    unique_ptr<__func, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
N    ::new (__hold.get()) __func(__f_.first(), _Alloc(__a));
N    return __hold.release();
N}
N
Ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
Nvoid
N__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::__clone(__base<_Rp(_ArgTypes...)>* __p) const
N{
N    ::new (__p) __func(__f_.first(), __f_.second());
N}
N
Ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
Nvoid
N__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::destroy() _NOEXCEPT
X__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::destroy() noexcept
N{
N    __f_.~__compressed_pair<_Fp, _Alloc>();
N}
N
Ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
Nvoid
N__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::destroy_deallocate() _NOEXCEPT
X__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::destroy_deallocate() noexcept
N{
N    typedef allocator_traits<_Alloc> __alloc_traits;
N    typedef typename __rebind_alloc_helper<__alloc_traits, __func>::type _Ap;
N    _Ap __a(__f_.second());
N    __f_.~__compressed_pair<_Fp, _Alloc>();
N    __a.deallocate(this, 1);
N}
N
Ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
N_Rp
N__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::operator()(_ArgTypes&& ... __arg)
N{
N    typedef __invoke_void_return_wrapper<_Rp> _Invoker;
N    return _Invoker::__call(__f_.first(), _VSTD::forward<_ArgTypes>(__arg)...);
X    return _Invoker::__call(__f_.first(), std::__2::forward<_ArgTypes>(__arg)...);
N}
N
N#ifndef _LIBCPP_NO_RTTI
N
Ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
Nconst void*
N__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::target(const type_info& __ti) const _NOEXCEPT
X__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::target(const type_info& __ti) const noexcept
N{
N    if (__ti == typeid(_Fp))
N        return &__f_.first();
N    return (const void*)0;
N}
N
Ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
Nconst std::type_info&
N__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::target_type() const _NOEXCEPT
X__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::target_type() const noexcept
N{
N    return typeid(_Fp);
N}
N
N#endif  // _LIBCPP_NO_RTTI
N
N}  // __function
N
Ntemplate<class _Rp, class ..._ArgTypes>
Nclass _LIBCPP_TEMPLATE_VIS function<_Rp(_ArgTypes...)>
Xclass  function<_Rp(_ArgTypes...)>
N    : public __function::__maybe_derive_from_unary_function<_Rp(_ArgTypes...)>,
N      public __function::__maybe_derive_from_binary_function<_Rp(_ArgTypes...)>
N{
N    typedef __function::__base<_Rp(_ArgTypes...)> __base;
N    typename aligned_storage<3*sizeof(void*)>::type __buf_;
N    __base* __f_;
N
N    _LIBCPP_NO_CFI static __base *__as_base(void *p) {
X     static __base *__as_base(void *p) {
N      return reinterpret_cast<__base*>(p);
N    }
N
N    template <class _Fp, bool = __lazy_and<
N        integral_constant<bool, !is_same<__uncvref_t<_Fp>, function>::value>,
N        __invokable<_Fp&, _ArgTypes...>
N    >::value>
N    struct __callable;
N    template <class _Fp>
N        struct __callable<_Fp, true>
N        {
N            static const bool value = is_same<void, _Rp>::value ||
N                is_convertible<typename __invoke_of<_Fp&, _ArgTypes...>::type,
N                               _Rp>::value;
N        };
N    template <class _Fp>
N        struct __callable<_Fp, false>
N        {
N            static const bool value = false;
N        };
N
N  template <class _Fp>
N  using _EnableIfCallable = typename enable_if<__callable<_Fp>::value>::type;
Npublic:
N    typedef _Rp result_type;
N
N    // construct/copy/destroy:
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    function() _NOEXCEPT : __f_(0) {}
X    function() noexcept : __f_(0) {}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    function(nullptr_t) _NOEXCEPT : __f_(0) {}
X    function(nullptr_t) noexcept : __f_(0) {}
N    function(const function&);
N    function(function&&) _NOEXCEPT;
X    function(function&&) noexcept;
N    template<class _Fp, class = _EnableIfCallable<_Fp>>
N    function(_Fp);
N
N#if _LIBCPP_STD_VER <= 14
X#if 14 <= 14
N    template<class _Alloc>
N      _LIBCPP_INLINE_VISIBILITY
X      __attribute__ ((__always_inline__))
N      function(allocator_arg_t, const _Alloc&) _NOEXCEPT : __f_(0) {}
X      function(allocator_arg_t, const _Alloc&) noexcept : __f_(0) {}
N    template<class _Alloc>
N      _LIBCPP_INLINE_VISIBILITY
X      __attribute__ ((__always_inline__))
N      function(allocator_arg_t, const _Alloc&, nullptr_t) _NOEXCEPT : __f_(0) {}
X      function(allocator_arg_t, const _Alloc&, nullptr_t) noexcept : __f_(0) {}
N    template<class _Alloc>
N      function(allocator_arg_t, const _Alloc&, const function&);
N    template<class _Alloc>
N      function(allocator_arg_t, const _Alloc&, function&&);
N    template<class _Fp, class _Alloc, class = _EnableIfCallable<_Fp>>
N      function(allocator_arg_t, const _Alloc& __a, _Fp __f);
N#endif
N
N    function& operator=(const function&);
N    function& operator=(function&&) _NOEXCEPT;
X    function& operator=(function&&) noexcept;
N    function& operator=(nullptr_t) _NOEXCEPT;
X    function& operator=(nullptr_t) noexcept;
N    template<class _Fp, class = _EnableIfCallable<_Fp>>
N    function& operator=(_Fp&&);
N
N    ~function();
N
N    // function modifiers:
N    void swap(function&) _NOEXCEPT;
X    void swap(function&) noexcept;
N
N#if _LIBCPP_STD_VER <= 14
X#if 14 <= 14
N    template<class _Fp, class _Alloc>
N      _LIBCPP_INLINE_VISIBILITY
X      __attribute__ ((__always_inline__))
N      void assign(_Fp&& __f, const _Alloc& __a)
N        {function(allocator_arg, __a, _VSTD::forward<_Fp>(__f)).swap(*this);}
X        {function(allocator_arg, __a, std::__2::forward<_Fp>(__f)).swap(*this);}
N#endif
N
N    // function capacity:
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N        _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT {return __f_;}
X        explicit operator bool() const noexcept {return __f_;}
N
N    // deleted overloads close possible hole in the type system
N    template<class _R2, class... _ArgTypes2>
N      bool operator==(const function<_R2(_ArgTypes2...)>&) const = delete;
N    template<class _R2, class... _ArgTypes2>
N      bool operator!=(const function<_R2(_ArgTypes2...)>&) const = delete;
Npublic:
N    // function invocation:
N    _Rp operator()(_ArgTypes...) const;
N
N#ifndef _LIBCPP_NO_RTTI
N    // function target access:
N    const std::type_info& target_type() const _NOEXCEPT;
X    const std::type_info& target_type() const noexcept;
N    template <typename _Tp> _Tp* target() _NOEXCEPT;
X    template <typename _Tp> _Tp* target() noexcept;
N    template <typename _Tp> const _Tp* target() const _NOEXCEPT;
X    template <typename _Tp> const _Tp* target() const noexcept;
N#endif  // _LIBCPP_NO_RTTI
N};
N
Ntemplate<class _Rp, class ..._ArgTypes>
Nfunction<_Rp(_ArgTypes...)>::function(const function& __f)
N{
N    if (__f.__f_ == 0)
N        __f_ = 0;
N    else if ((void *)__f.__f_ == &__f.__buf_)
N    {
N        __f_ = __as_base(&__buf_);
N        __f.__f_->__clone(__f_);
N    }
N    else
N        __f_ = __f.__f_->__clone();
N}
N
N#if _LIBCPP_STD_VER <= 14
X#if 14 <= 14
Ntemplate<class _Rp, class ..._ArgTypes>
Ntemplate <class _Alloc>
Nfunction<_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc&,
N                                     const function& __f)
N{
N    if (__f.__f_ == 0)
N        __f_ = 0;
N    else if ((void *)__f.__f_ == &__f.__buf_)
N    {
N        __f_ = __as_base(&__buf_);
N        __f.__f_->__clone(__f_);
N    }
N    else
N        __f_ = __f.__f_->__clone();
N}
N#endif
N
Ntemplate<class _Rp, class ..._ArgTypes>
Nfunction<_Rp(_ArgTypes...)>::function(function&& __f) _NOEXCEPT
Xfunction<_Rp(_ArgTypes...)>::function(function&& __f) noexcept
N{
N    if (__f.__f_ == 0)
N        __f_ = 0;
N    else if ((void *)__f.__f_ == &__f.__buf_)
N    {
N        __f_ = __as_base(&__buf_);
N        __f.__f_->__clone(__f_);
N    }
N    else
N    {
N        __f_ = __f.__f_;
N        __f.__f_ = 0;
N    }
N}
N
N#if _LIBCPP_STD_VER <= 14
X#if 14 <= 14
Ntemplate<class _Rp, class ..._ArgTypes>
Ntemplate <class _Alloc>
Nfunction<_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc&,
N                                     function&& __f)
N{
N    if (__f.__f_ == 0)
N        __f_ = 0;
N    else if ((void *)__f.__f_ == &__f.__buf_)
N    {
N        __f_ = __as_base(&__buf_);
N        __f.__f_->__clone(__f_);
N    }
N    else
N    {
N        __f_ = __f.__f_;
N        __f.__f_ = 0;
N    }
N}
N#endif
N
Ntemplate<class _Rp, class ..._ArgTypes>
Ntemplate <class _Fp, class>
Nfunction<_Rp(_ArgTypes...)>::function(_Fp __f)
N    : __f_(0)
N{
N    if (__function::__not_null(__f))
N    {
N        typedef __function::__func<_Fp, allocator<_Fp>, _Rp(_ArgTypes...)> _FF;
N        if (sizeof(_FF) <= sizeof(__buf_) && is_nothrow_copy_constructible<_Fp>::value)
N        {
N            __f_ = ::new((void*)&__buf_) _FF(_VSTD::move(__f));
X            __f_ = ::new((void*)&__buf_) _FF(std::__2::move(__f));
N        }
N        else
N        {
N            typedef allocator<_FF> _Ap;
N            _Ap __a;
N            typedef __allocator_destructor<_Ap> _Dp;
N            unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
N            ::new (__hold.get()) _FF(_VSTD::move(__f), allocator<_Fp>(__a));
X            ::new (__hold.get()) _FF(std::__2::move(__f), allocator<_Fp>(__a));
N            __f_ = __hold.release();
N        }
N    }
N}
N
N#if _LIBCPP_STD_VER <= 14
X#if 14 <= 14
Ntemplate<class _Rp, class ..._ArgTypes>
Ntemplate <class _Fp, class _Alloc, class>
Nfunction<_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc& __a0, _Fp __f)
N    : __f_(0)
N{
N    typedef allocator_traits<_Alloc> __alloc_traits;
N    if (__function::__not_null(__f))
N    {
N        typedef __function::__func<_Fp, _Alloc, _Rp(_ArgTypes...)> _FF;
N        typedef typename __rebind_alloc_helper<__alloc_traits, _FF>::type _Ap;
N        _Ap __a(__a0);
N        if (sizeof(_FF) <= sizeof(__buf_) && 
N            is_nothrow_copy_constructible<_Fp>::value && is_nothrow_copy_constructible<_Ap>::value)
N        {
N            __f_ = ::new((void*)&__buf_) _FF(_VSTD::move(__f), _Alloc(__a));
X            __f_ = ::new((void*)&__buf_) _FF(std::__2::move(__f), _Alloc(__a));
N        }
N        else
N        {
N            typedef __allocator_destructor<_Ap> _Dp;
N            unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
N            ::new (__hold.get()) _FF(_VSTD::move(__f), _Alloc(__a));
X            ::new (__hold.get()) _FF(std::__2::move(__f), _Alloc(__a));
N            __f_ = __hold.release();
N        }
N    }
N}
N#endif
N
Ntemplate<class _Rp, class ..._ArgTypes>
Nfunction<_Rp(_ArgTypes...)>&
Nfunction<_Rp(_ArgTypes...)>::operator=(const function& __f)
N{
N    function(__f).swap(*this);
N    return *this;
N}
N
Ntemplate<class _Rp, class ..._ArgTypes>
Nfunction<_Rp(_ArgTypes...)>&
Nfunction<_Rp(_ArgTypes...)>::operator=(function&& __f) _NOEXCEPT
Xfunction<_Rp(_ArgTypes...)>::operator=(function&& __f) noexcept
N{
N    if ((void *)__f_ == &__buf_)
N        __f_->destroy();
N    else if (__f_)
N        __f_->destroy_deallocate();
N    __f_ = 0;
N    if (__f.__f_ == 0)
N        __f_ = 0;
N    else if ((void *)__f.__f_ == &__f.__buf_)
N    {
N        __f_ = __as_base(&__buf_);
N        __f.__f_->__clone(__f_);
N    }
N    else
N    {
N        __f_ = __f.__f_;
N        __f.__f_ = 0;
N    }
N    return *this;
N}
N
Ntemplate<class _Rp, class ..._ArgTypes>
Nfunction<_Rp(_ArgTypes...)>&
Nfunction<_Rp(_ArgTypes...)>::operator=(nullptr_t) _NOEXCEPT
Xfunction<_Rp(_ArgTypes...)>::operator=(nullptr_t) noexcept
N{
N    if ((void *)__f_ == &__buf_)
N        __f_->destroy();
N    else if (__f_)
N        __f_->destroy_deallocate();
N    __f_ = 0;
N    return *this;
N}
N
Ntemplate<class _Rp, class ..._ArgTypes>
Ntemplate <class _Fp, class>
Nfunction<_Rp(_ArgTypes...)>&
Nfunction<_Rp(_ArgTypes...)>::operator=(_Fp&& __f)
N{
N    function(_VSTD::forward<_Fp>(__f)).swap(*this);
X    function(std::__2::forward<_Fp>(__f)).swap(*this);
N    return *this;
N}
N
Ntemplate<class _Rp, class ..._ArgTypes>
Nfunction<_Rp(_ArgTypes...)>::~function()
N{
N    if ((void *)__f_ == &__buf_)
N        __f_->destroy();
N    else if (__f_)
N        __f_->destroy_deallocate();
N}
N
Ntemplate<class _Rp, class ..._ArgTypes>
Nvoid
Nfunction<_Rp(_ArgTypes...)>::swap(function& __f) _NOEXCEPT
Xfunction<_Rp(_ArgTypes...)>::swap(function& __f) noexcept
N{
N    if (_VSTD::addressof(__f) == this)
X    if (std::__2::addressof(__f) == this)
N      return;
N    if ((void *)__f_ == &__buf_ && (void *)__f.__f_ == &__f.__buf_)
N    {
N        typename aligned_storage<sizeof(__buf_)>::type __tempbuf;
N        __base* __t = __as_base(&__tempbuf);
N        __f_->__clone(__t);
N        __f_->destroy();
N        __f_ = 0;
N        __f.__f_->__clone(__as_base(&__buf_));
N        __f.__f_->destroy();
N        __f.__f_ = 0;
N        __f_ = __as_base(&__buf_);
N        __t->__clone(__as_base(&__f.__buf_));
N        __t->destroy();
N        __f.__f_ = __as_base(&__f.__buf_);
N    }
N    else if ((void *)__f_ == &__buf_)
N    {
N        __f_->__clone(__as_base(&__f.__buf_));
N        __f_->destroy();
N        __f_ = __f.__f_;
N        __f.__f_ = __as_base(&__f.__buf_);
N    }
N    else if ((void *)__f.__f_ == &__f.__buf_)
N    {
N        __f.__f_->__clone(__as_base(&__buf_));
N        __f.__f_->destroy();
N        __f.__f_ = __f_;
N        __f_ = __as_base(&__buf_);
N    }
N    else
N        _VSTD::swap(__f_, __f.__f_);
X        std::__2::swap(__f_, __f.__f_);
N}
N
Ntemplate<class _Rp, class ..._ArgTypes>
N_Rp
Nfunction<_Rp(_ArgTypes...)>::operator()(_ArgTypes... __arg) const
N{
N    if (__f_ == 0)
N        __throw_bad_function_call();
N    return (*__f_)(_VSTD::forward<_ArgTypes>(__arg)...);
X    return (*__f_)(std::__2::forward<_ArgTypes>(__arg)...);
N}
N
N#ifndef _LIBCPP_NO_RTTI
N
Ntemplate<class _Rp, class ..._ArgTypes>
Nconst std::type_info&
Nfunction<_Rp(_ArgTypes...)>::target_type() const _NOEXCEPT
Xfunction<_Rp(_ArgTypes...)>::target_type() const noexcept
N{
N    if (__f_ == 0)
N        return typeid(void);
N    return __f_->target_type();
N}
N
Ntemplate<class _Rp, class ..._ArgTypes>
Ntemplate <typename _Tp>
N_Tp*
Nfunction<_Rp(_ArgTypes...)>::target() _NOEXCEPT
Xfunction<_Rp(_ArgTypes...)>::target() noexcept
N{
N    if (__f_ == 0)
N        return nullptr;
N    return (_Tp*) const_cast<void *>(__f_->target(typeid(_Tp)));
N}
N
Ntemplate<class _Rp, class ..._ArgTypes>
Ntemplate <typename _Tp>
Nconst _Tp*
Nfunction<_Rp(_ArgTypes...)>::target() const _NOEXCEPT
Xfunction<_Rp(_ArgTypes...)>::target() const noexcept
N{
N    if (__f_ == 0)
N        return nullptr;
N    return (const _Tp*)__f_->target(typeid(_Tp));
N}
N
N#endif  // _LIBCPP_NO_RTTI
N
Ntemplate <class _Rp, class... _ArgTypes>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator==(const function<_Rp(_ArgTypes...)>& __f, nullptr_t) _NOEXCEPT {return !__f;}
Xoperator==(const function<_Rp(_ArgTypes...)>& __f, nullptr_t) noexcept {return !__f;}
N
Ntemplate <class _Rp, class... _ArgTypes>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator==(nullptr_t, const function<_Rp(_ArgTypes...)>& __f) _NOEXCEPT {return !__f;}
Xoperator==(nullptr_t, const function<_Rp(_ArgTypes...)>& __f) noexcept {return !__f;}
N
Ntemplate <class _Rp, class... _ArgTypes>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator!=(const function<_Rp(_ArgTypes...)>& __f, nullptr_t) _NOEXCEPT {return (bool)__f;}
Xoperator!=(const function<_Rp(_ArgTypes...)>& __f, nullptr_t) noexcept {return (bool)__f;}
N
Ntemplate <class _Rp, class... _ArgTypes>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Noperator!=(nullptr_t, const function<_Rp(_ArgTypes...)>& __f) _NOEXCEPT {return (bool)__f;}
Xoperator!=(nullptr_t, const function<_Rp(_ArgTypes...)>& __f) noexcept {return (bool)__f;}
N
Ntemplate <class _Rp, class... _ArgTypes>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Nswap(function<_Rp(_ArgTypes...)>& __x, function<_Rp(_ArgTypes...)>& __y) _NOEXCEPT
Xswap(function<_Rp(_ArgTypes...)>& __x, function<_Rp(_ArgTypes...)>& __y) noexcept
N{return __x.swap(__y);}
N
N#else // _LIBCPP_CXX03_LANG
S
S#include <__functional_03>
S
N#endif
N
N////////////////////////////////////////////////////////////////////////////////
N//                                  BIND
N//==============================================================================
N
Ntemplate<class _Tp> struct __is_bind_expression : public false_type {};
Ntemplate<class _Tp> struct _LIBCPP_TEMPLATE_VIS is_bind_expression
Xtemplate<class _Tp> struct  is_bind_expression
N    : public __is_bind_expression<typename remove_cv<_Tp>::type> {};
N
N#if _LIBCPP_STD_VER > 14
X#if 14 > 14
Stemplate <class _Tp>
Sconstexpr size_t is_bind_expression_v = is_bind_expression<_Tp>::value;
N#endif
N
Ntemplate<class _Tp> struct __is_placeholder : public integral_constant<int, 0> {};
Ntemplate<class _Tp> struct _LIBCPP_TEMPLATE_VIS is_placeholder
Xtemplate<class _Tp> struct  is_placeholder
N    : public __is_placeholder<typename remove_cv<_Tp>::type> {};
N
N#if _LIBCPP_STD_VER > 14
X#if 14 > 14
Stemplate <class _Tp>
Sconstexpr size_t is_placeholder_v = is_placeholder<_Tp>::value;
N#endif
N
Nnamespace placeholders
N{
N
Ntemplate <int _Np> struct __ph {};
N
N#if defined(_LIBCPP_CXX03_LANG) || defined(_LIBCPP_BUILDING_BIND)
X#if 0L || 0L
S_LIBCPP_FUNC_VIS extern const __ph<1>   _1;
S_LIBCPP_FUNC_VIS extern const __ph<2>   _2;
S_LIBCPP_FUNC_VIS extern const __ph<3>   _3;
S_LIBCPP_FUNC_VIS extern const __ph<4>   _4;
S_LIBCPP_FUNC_VIS extern const __ph<5>   _5;
S_LIBCPP_FUNC_VIS extern const __ph<6>   _6;
S_LIBCPP_FUNC_VIS extern const __ph<7>   _7;
S_LIBCPP_FUNC_VIS extern const __ph<8>   _8;
S_LIBCPP_FUNC_VIS extern const __ph<9>   _9;
S_LIBCPP_FUNC_VIS extern const __ph<10> _10;
N#else
Nconstexpr __ph<1>   _1{};
Nconstexpr __ph<2>   _2{};
Nconstexpr __ph<3>   _3{};
Nconstexpr __ph<4>   _4{};
Nconstexpr __ph<5>   _5{};
Nconstexpr __ph<6>   _6{};
Nconstexpr __ph<7>   _7{};
Nconstexpr __ph<8>   _8{};
Nconstexpr __ph<9>   _9{};
Nconstexpr __ph<10> _10{};
N#endif // defined(_LIBCPP_CXX03_LANG) || defined(_LIBCPP_BUILDING_BIND)
N
N}  // placeholders
N
Ntemplate<int _Np>
Nstruct __is_placeholder<placeholders::__ph<_Np> >
N    : public integral_constant<int, _Np> {};
N
N
N#ifndef _LIBCPP_CXX03_LANG
N
Ntemplate <class _Tp, class _Uj>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_Tp&
N__mu(reference_wrapper<_Tp> __t, _Uj&)
N{
N    return __t.get();
N}
N
Ntemplate <class _Ti, class ..._Uj, size_t ..._Indx>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename __invoke_of<_Ti&, _Uj...>::type
N__mu_expand(_Ti& __ti, tuple<_Uj...>& __uj, __tuple_indices<_Indx...>)
N{
N    return __ti(_VSTD::forward<_Uj>(_VSTD::get<_Indx>(__uj))...);
X    return __ti(std::__2::forward<_Uj>(std::__2::get<_Indx>(__uj))...);
N}
N
Ntemplate <class _Ti, class ..._Uj>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename __lazy_enable_if
N<
N    is_bind_expression<_Ti>::value,
N    __invoke_of<_Ti&, _Uj...>
N>::type
N__mu(_Ti& __ti, tuple<_Uj...>& __uj)
N{
N    typedef typename __make_tuple_indices<sizeof...(_Uj)>::type __indices;
N    return  __mu_expand(__ti, __uj, __indices());
N}
N
Ntemplate <bool IsPh, class _Ti, class _Uj>
Nstruct __mu_return2 {};
N
Ntemplate <class _Ti, class _Uj>
Nstruct __mu_return2<true, _Ti, _Uj>
N{
N    typedef typename tuple_element<is_placeholder<_Ti>::value - 1, _Uj>::type type;
N};
N
Ntemplate <class _Ti, class _Uj>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename enable_if
N<
N    0 < is_placeholder<_Ti>::value,
N    typename __mu_return2<0 < is_placeholder<_Ti>::value, _Ti, _Uj>::type
N>::type
N__mu(_Ti&, _Uj& __uj)
N{
N    const size_t _Indx = is_placeholder<_Ti>::value - 1;
N    return _VSTD::forward<typename tuple_element<_Indx, _Uj>::type>(_VSTD::get<_Indx>(__uj));
X    return std::__2::forward<typename tuple_element<_Indx, _Uj>::type>(std::__2::get<_Indx>(__uj));
N}
N
Ntemplate <class _Ti, class _Uj>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename enable_if
N<
N    !is_bind_expression<_Ti>::value &&
N    is_placeholder<_Ti>::value == 0 &&
N    !__is_reference_wrapper<_Ti>::value,
N    _Ti&
N>::type
N__mu(_Ti& __ti, _Uj&)
N{
N    return __ti;
N}
N
Ntemplate <class _Ti, bool IsReferenceWrapper, bool IsBindEx, bool IsPh,
N          class _TupleUj>
Nstruct ____mu_return;
N
Ntemplate <bool _Invokable, class _Ti, class ..._Uj>
Nstruct ____mu_return_invokable  // false
N{
N    typedef __nat type;
N};
N
Ntemplate <class _Ti, class ..._Uj>
Nstruct ____mu_return_invokable<true, _Ti, _Uj...>
N{
N    typedef typename __invoke_of<_Ti&, _Uj...>::type type;
N};
N
Ntemplate <class _Ti, class ..._Uj>
Nstruct ____mu_return<_Ti, false, true, false, tuple<_Uj...> >
N    : public ____mu_return_invokable<__invokable<_Ti&, _Uj...>::value, _Ti, _Uj...>
N{
N};
N
Ntemplate <class _Ti, class _TupleUj>
Nstruct ____mu_return<_Ti, false, false, true, _TupleUj>
N{
N    typedef typename tuple_element<is_placeholder<_Ti>::value - 1,
N                                   _TupleUj>::type&& type;
N};
N
Ntemplate <class _Ti, class _TupleUj>
Nstruct ____mu_return<_Ti, true, false, false, _TupleUj>
N{
N    typedef typename _Ti::type& type;
N};
N
Ntemplate <class _Ti, class _TupleUj>
Nstruct ____mu_return<_Ti, false, false, false, _TupleUj>
N{
N    typedef _Ti& type;
N};
N
Ntemplate <class _Ti, class _TupleUj>
Nstruct __mu_return
N    : public ____mu_return<_Ti,
N                           __is_reference_wrapper<_Ti>::value,
N                           is_bind_expression<_Ti>::value,
N                           0 < is_placeholder<_Ti>::value &&
N                           is_placeholder<_Ti>::value <= tuple_size<_TupleUj>::value,
N                           _TupleUj>
N{
N};
N
Ntemplate <class _Fp, class _BoundArgs, class _TupleUj>
Nstruct __is_valid_bind_return
N{
N    static const bool value = false;
N};
N
Ntemplate <class _Fp, class ..._BoundArgs, class _TupleUj>
Nstruct __is_valid_bind_return<_Fp, tuple<_BoundArgs...>, _TupleUj>
N{
N    static const bool value = __invokable<_Fp,
N                    typename __mu_return<_BoundArgs, _TupleUj>::type...>::value;
N};
N
Ntemplate <class _Fp, class ..._BoundArgs, class _TupleUj>
Nstruct __is_valid_bind_return<_Fp, const tuple<_BoundArgs...>, _TupleUj>
N{
N    static const bool value = __invokable<_Fp,
N                    typename __mu_return<const _BoundArgs, _TupleUj>::type...>::value;
N};
N
Ntemplate <class _Fp, class _BoundArgs, class _TupleUj,
N          bool = __is_valid_bind_return<_Fp, _BoundArgs, _TupleUj>::value>
Nstruct __bind_return;
N
Ntemplate <class _Fp, class ..._BoundArgs, class _TupleUj>
Nstruct __bind_return<_Fp, tuple<_BoundArgs...>, _TupleUj, true>
N{
N    typedef typename __invoke_of
N    <
N        _Fp&,
N        typename __mu_return
N        <
N            _BoundArgs,
N            _TupleUj
N        >::type...
N    >::type type;
N};
N
Ntemplate <class _Fp, class ..._BoundArgs, class _TupleUj>
Nstruct __bind_return<_Fp, const tuple<_BoundArgs...>, _TupleUj, true>
N{
N    typedef typename __invoke_of
N    <
N        _Fp&,
N        typename __mu_return
N        <
N            const _BoundArgs,
N            _TupleUj
N        >::type...
N    >::type type;
N};
N
Ntemplate <class _Fp, class _BoundArgs, size_t ..._Indx, class _Args>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename __bind_return<_Fp, _BoundArgs, _Args>::type
N__apply_functor(_Fp& __f, _BoundArgs& __bound_args, __tuple_indices<_Indx...>,
N                _Args&& __args)
N{
N    return _VSTD::__invoke(__f, _VSTD::__mu(_VSTD::get<_Indx>(__bound_args), __args)...);
X    return std::__2::__invoke(__f, std::__2::__mu(std::__2::get<_Indx>(__bound_args), __args)...);
N}
N
Ntemplate<class _Fp, class ..._BoundArgs>
Nclass __bind
N    : public __weak_result_type<typename decay<_Fp>::type>
N{
Nprotected:
N    typedef typename decay<_Fp>::type _Fd;
N    typedef tuple<typename decay<_BoundArgs>::type...> _Td;
Nprivate:
N    _Fd __f_;
N    _Td __bound_args_;
N
N    typedef typename __make_tuple_indices<sizeof...(_BoundArgs)>::type __indices;
Npublic:
N    template <class _Gp, class ..._BA,
N              class = typename enable_if
N                               <
N                                  is_constructible<_Fd, _Gp>::value &&
N                                  !is_same<typename remove_reference<_Gp>::type,
N                                           __bind>::value
N                               >::type>
N      _LIBCPP_INLINE_VISIBILITY
X      __attribute__ ((__always_inline__))
N      explicit __bind(_Gp&& __f, _BA&& ...__bound_args)
N        : __f_(_VSTD::forward<_Gp>(__f)),
X        : __f_(std::__2::forward<_Gp>(__f)),
N          __bound_args_(_VSTD::forward<_BA>(__bound_args)...) {}
X          __bound_args_(std::__2::forward<_BA>(__bound_args)...) {}
N
N    template <class ..._Args>
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        typename __bind_return<_Fd, _Td, tuple<_Args&&...> >::type
N        operator()(_Args&& ...__args)
N        {
N            return _VSTD::__apply_functor(__f_, __bound_args_, __indices(),
X            return std::__2::__apply_functor(__f_, __bound_args_, __indices(),
N                                  tuple<_Args&&...>(_VSTD::forward<_Args>(__args)...));
X                                  tuple<_Args&&...>(std::__2::forward<_Args>(__args)...));
N        }
N
N    template <class ..._Args>
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        typename __bind_return<const _Fd, const _Td, tuple<_Args&&...> >::type
N        operator()(_Args&& ...__args) const
N        {
N            return _VSTD::__apply_functor(__f_, __bound_args_, __indices(),
X            return std::__2::__apply_functor(__f_, __bound_args_, __indices(),
N                                   tuple<_Args&&...>(_VSTD::forward<_Args>(__args)...));
X                                   tuple<_Args&&...>(std::__2::forward<_Args>(__args)...));
N        }
N};
N
Ntemplate<class _Fp, class ..._BoundArgs>
Nstruct __is_bind_expression<__bind<_Fp, _BoundArgs...> > : public true_type {};
N
Ntemplate<class _Rp, class _Fp, class ..._BoundArgs>
Nclass __bind_r
N    : public __bind<_Fp, _BoundArgs...>
N{
N    typedef __bind<_Fp, _BoundArgs...> base;
N    typedef typename base::_Fd _Fd;
N    typedef typename base::_Td _Td;
Npublic:
N    typedef _Rp result_type;
N
N
N    template <class _Gp, class ..._BA,
N              class = typename enable_if
N                               <
N                                  is_constructible<_Fd, _Gp>::value &&
N                                  !is_same<typename remove_reference<_Gp>::type,
N                                           __bind_r>::value
N                               >::type>
N      _LIBCPP_INLINE_VISIBILITY
X      __attribute__ ((__always_inline__))
N      explicit __bind_r(_Gp&& __f, _BA&& ...__bound_args)
N        : base(_VSTD::forward<_Gp>(__f),
X        : base(std::__2::forward<_Gp>(__f),
N               _VSTD::forward<_BA>(__bound_args)...) {}
X               std::__2::forward<_BA>(__bound_args)...) {}
N
N    template <class ..._Args>
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        typename enable_if
N        <
N            is_convertible<typename __bind_return<_Fd, _Td, tuple<_Args&&...> >::type,
N                           result_type>::value || is_void<_Rp>::value,
N            result_type
N        >::type
N        operator()(_Args&& ...__args)
N        {
N            typedef __invoke_void_return_wrapper<_Rp> _Invoker;
N            return _Invoker::__call(static_cast<base&>(*this), _VSTD::forward<_Args>(__args)...);
X            return _Invoker::__call(static_cast<base&>(*this), std::__2::forward<_Args>(__args)...);
N        }
N
N    template <class ..._Args>
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        typename enable_if
N        <
N            is_convertible<typename __bind_return<const _Fd, const _Td, tuple<_Args&&...> >::type,
N                           result_type>::value || is_void<_Rp>::value,
N            result_type
N        >::type
N        operator()(_Args&& ...__args) const
N        {
N            typedef __invoke_void_return_wrapper<_Rp> _Invoker;
N            return _Invoker::__call(static_cast<base const&>(*this), _VSTD::forward<_Args>(__args)...);
X            return _Invoker::__call(static_cast<base const&>(*this), std::__2::forward<_Args>(__args)...);
N        }
N};
N
Ntemplate<class _Rp, class _Fp, class ..._BoundArgs>
Nstruct __is_bind_expression<__bind_r<_Rp, _Fp, _BoundArgs...> > : public true_type {};
N
Ntemplate<class _Fp, class ..._BoundArgs>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N__bind<_Fp, _BoundArgs...>
Nbind(_Fp&& __f, _BoundArgs&&... __bound_args)
N{
N    typedef __bind<_Fp, _BoundArgs...> type;
N    return type(_VSTD::forward<_Fp>(__f), _VSTD::forward<_BoundArgs>(__bound_args)...);
X    return type(std::__2::forward<_Fp>(__f), std::__2::forward<_BoundArgs>(__bound_args)...);
N}
N
Ntemplate<class _Rp, class _Fp, class ..._BoundArgs>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N__bind_r<_Rp, _Fp, _BoundArgs...>
Nbind(_Fp&& __f, _BoundArgs&&... __bound_args)
N{
N    typedef __bind_r<_Rp, _Fp, _BoundArgs...> type;
N    return type(_VSTD::forward<_Fp>(__f), _VSTD::forward<_BoundArgs>(__bound_args)...);
X    return type(std::__2::forward<_Fp>(__f), std::__2::forward<_BoundArgs>(__bound_args)...);
N}
N
N#endif  // _LIBCPP_CXX03_LANG
N
N#if _LIBCPP_STD_VER > 14
X#if 14 > 14
S
S#define __cpp_lib_invoke 201411
S
Stemplate <class _Fn, class ..._Args>
Sresult_of_t<_Fn&&(_Args&&...)>
Sinvoke(_Fn&& __f, _Args&&... __args)
S    noexcept(noexcept(_VSTD::__invoke(_VSTD::forward<_Fn>(__f), _VSTD::forward<_Args>(__args)...)))
S{
S    return _VSTD::__invoke(_VSTD::forward<_Fn>(__f), _VSTD::forward<_Args>(__args)...);
S}
S
Stemplate <class _DecayFunc>
Sclass _LIBCPP_TEMPLATE_VIS __not_fn_imp {
S  _DecayFunc __fd;
S
Spublic:
S    __not_fn_imp() = delete;
S
S    template <class ..._Args>
S    _LIBCPP_INLINE_VISIBILITY
S    auto operator()(_Args&& ...__args) &
S            noexcept(noexcept(!_VSTD::invoke(__fd, _VSTD::forward<_Args>(__args)...)))
S        -> decltype(          !_VSTD::invoke(__fd, _VSTD::forward<_Args>(__args)...))
S        { return              !_VSTD::invoke(__fd, _VSTD::forward<_Args>(__args)...); }
S
S    template <class ..._Args>
S    _LIBCPP_INLINE_VISIBILITY
S    auto operator()(_Args&& ...__args) &&
S            noexcept(noexcept(!_VSTD::invoke(_VSTD::move(__fd), _VSTD::forward<_Args>(__args)...)))
S        -> decltype(          !_VSTD::invoke(_VSTD::move(__fd), _VSTD::forward<_Args>(__args)...))
S        { return              !_VSTD::invoke(_VSTD::move(__fd), _VSTD::forward<_Args>(__args)...); }
S
S    template <class ..._Args>
S    _LIBCPP_INLINE_VISIBILITY
S    auto operator()(_Args&& ...__args) const&
S            noexcept(noexcept(!_VSTD::invoke(__fd, _VSTD::forward<_Args>(__args)...)))
S        -> decltype(          !_VSTD::invoke(__fd, _VSTD::forward<_Args>(__args)...))
S        { return              !_VSTD::invoke(__fd, _VSTD::forward<_Args>(__args)...); }
S
S
S    template <class ..._Args>
S    _LIBCPP_INLINE_VISIBILITY
S    auto operator()(_Args&& ...__args) const&&
S            noexcept(noexcept(!_VSTD::invoke(_VSTD::move(__fd), _VSTD::forward<_Args>(__args)...)))
S        -> decltype(          !_VSTD::invoke(_VSTD::move(__fd), _VSTD::forward<_Args>(__args)...))
S        { return              !_VSTD::invoke(_VSTD::move(__fd), _VSTD::forward<_Args>(__args)...); }
S
Sprivate:
S    template <class _RawFunc,
S              class = enable_if_t<!is_same<decay_t<_RawFunc>, __not_fn_imp>::value>>
S    _LIBCPP_INLINE_VISIBILITY
S    explicit __not_fn_imp(_RawFunc&& __rf)
S        : __fd(_VSTD::forward<_RawFunc>(__rf)) {}
S
S    template <class _RawFunc>
S    friend inline _LIBCPP_INLINE_VISIBILITY
S    __not_fn_imp<decay_t<_RawFunc>> not_fn(_RawFunc&&);
S};
S
Stemplate <class _RawFunc>
Sinline _LIBCPP_INLINE_VISIBILITY
S__not_fn_imp<decay_t<_RawFunc>> not_fn(_RawFunc&& __fn) {
S    return __not_fn_imp<decay_t<_RawFunc>>(_VSTD::forward<_RawFunc>(__fn));
S}
S
N#endif
N
N// struct hash<T*> in <memory>
N
N_LIBCPP_END_NAMESPACE_STD
X} }
N
N#endif  // _LIBCPP_FUNCTIONAL
L 193 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/mutex" 2
N#include <memory>
N#ifndef _LIBCPP_CXX03_LANG
N#include <tuple>
N#endif
N#include <__threading_support>
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N_LIBCPP_PUSH_MACROS
X_Pragma("push_macro(\"min\")") _Pragma("push_macro(\"max\")")
N#include <__undef_macros>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/__undef_macros" 1
N// -*- C++ -*-
N//===------------------------ __undef_macros ------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is distributed under the University of Illinois Open Source
N// License. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N
N#ifdef min
S#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
S#if defined(_LIBCPP_WARNING)
S_LIBCPP_WARNING("macro min is incompatible with C++.  Try #define NOMINMAX "
S                "before any Windows header. #undefing min")
S#else
S#warning: macro min is incompatible with C++.  #undefing min
S#endif
S#endif
S#undef min
N#endif
N
N#ifdef max
S#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
S#if defined(_LIBCPP_WARNING)
S_LIBCPP_WARNING("macro max is incompatible with C++.  Try #define NOMINMAX "
S                "before any Windows header. #undefing max")
S#else
S#warning: macro max is incompatible with C++.  #undefing max
S#endif
S#endif
S#undef max
N#endif
L 205 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/mutex" 2
N
N
N_LIBCPP_BEGIN_NAMESPACE_STD
Xnamespace std { inline namespace __2 {
N
N#ifndef _LIBCPP_HAS_NO_THREADS
S
Sclass _LIBCPP_TYPE_VIS recursive_mutex
S{
S    __libcpp_recursive_mutex_t __m_;
S
Spublic:
S     recursive_mutex();
S     ~recursive_mutex();
S
Sprivate:
S    recursive_mutex(const recursive_mutex&); // = delete;
S    recursive_mutex& operator=(const recursive_mutex&); // = delete;
S
Spublic:
S    void lock();
S    bool try_lock() _NOEXCEPT;
S    void unlock()  _NOEXCEPT;
S
S    typedef __libcpp_recursive_mutex_t* native_handle_type;
S
S    _LIBCPP_INLINE_VISIBILITY
S    native_handle_type native_handle() {return &__m_;}
S};
S
Sclass _LIBCPP_TYPE_VIS timed_mutex
S{
S    mutex              __m_;
S    condition_variable __cv_;
S    bool               __locked_;
Spublic:
S     timed_mutex();
S     ~timed_mutex();
S
Sprivate:
S    timed_mutex(const timed_mutex&); // = delete;
S    timed_mutex& operator=(const timed_mutex&); // = delete;
S
Spublic:
S    void lock();
S    bool try_lock() _NOEXCEPT;
S    template <class _Rep, class _Period>
S        _LIBCPP_INLINE_VISIBILITY
S        bool try_lock_for(const chrono::duration<_Rep, _Period>& __d)
S            {return try_lock_until(chrono::steady_clock::now() + __d);}
S    template <class _Clock, class _Duration>
S        _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
S        bool try_lock_until(const chrono::time_point<_Clock, _Duration>& __t);
S    void unlock() _NOEXCEPT;
S};
S
Stemplate <class _Clock, class _Duration>
Sbool
Stimed_mutex::try_lock_until(const chrono::time_point<_Clock, _Duration>& __t)
S{
S    using namespace chrono;
S    unique_lock<mutex> __lk(__m_);
S    bool no_timeout = _Clock::now() < __t;
S    while (no_timeout && __locked_)
S        no_timeout = __cv_.wait_until(__lk, __t) == cv_status::no_timeout;
S    if (!__locked_)
S    {
S        __locked_ = true;
S        return true;
S    }
S    return false;
S}
S
Sclass _LIBCPP_TYPE_VIS recursive_timed_mutex
S{
S    mutex              __m_;
S    condition_variable __cv_;
S    size_t             __count_;
S    __libcpp_thread_id __id_;
Spublic:
S     recursive_timed_mutex();
S     ~recursive_timed_mutex();
S
Sprivate:
S    recursive_timed_mutex(const recursive_timed_mutex&); // = delete;
S    recursive_timed_mutex& operator=(const recursive_timed_mutex&); // = delete;
S
Spublic:
S    void lock();
S    bool try_lock() _NOEXCEPT;
S    template <class _Rep, class _Period>
S        _LIBCPP_INLINE_VISIBILITY
S        bool try_lock_for(const chrono::duration<_Rep, _Period>& __d)
S            {return try_lock_until(chrono::steady_clock::now() + __d);}
S    template <class _Clock, class _Duration>
S        _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
S        bool try_lock_until(const chrono::time_point<_Clock, _Duration>& __t);
S    void unlock() _NOEXCEPT;
S};
S
Stemplate <class _Clock, class _Duration>
Sbool
Srecursive_timed_mutex::try_lock_until(const chrono::time_point<_Clock, _Duration>& __t)
S{
S    using namespace chrono;
S    __libcpp_thread_id __id = __libcpp_thread_get_current_id();
S    unique_lock<mutex> lk(__m_);
S    if (__libcpp_thread_id_equal(__id, __id_))
S    {
S        if (__count_ == numeric_limits<size_t>::max())
S            return false;
S        ++__count_;
S        return true;
S    }
S    bool no_timeout = _Clock::now() < __t;
S    while (no_timeout && __count_ != 0)
S        no_timeout = __cv_.wait_until(lk, __t) == cv_status::no_timeout;
S    if (__count_ == 0)
S    {
S        __count_ = 1;
S        __id_ = __id;
S        return true;
S    }
S    return false;
S}
S
Stemplate <class _L0, class _L1>
Sint
Stry_lock(_L0& __l0, _L1& __l1)
S{
S    unique_lock<_L0> __u0(__l0, try_to_lock);
S    if (__u0.owns_lock())
S    {
S        if (__l1.try_lock())
S        {
S            __u0.release();
S            return -1;
S        }
S        else
S            return 1;
S    }
S    return 0;
S}
S
S#ifndef _LIBCPP_CXX03_LANG
S
Stemplate <class _L0, class _L1, class _L2, class... _L3>
Sint
Stry_lock(_L0& __l0, _L1& __l1, _L2& __l2, _L3&... __l3)
S{
S    int __r = 0;
S    unique_lock<_L0> __u0(__l0, try_to_lock);
S    if (__u0.owns_lock())
S    {
S        __r = try_lock(__l1, __l2, __l3...);
S        if (__r == -1)
S            __u0.release();
S        else
S            ++__r;
S    }
S    return __r;
S}
S
S#endif  // _LIBCPP_CXX03_LANG
S
Stemplate <class _L0, class _L1>
Svoid
Slock(_L0& __l0, _L1& __l1)
S{
S    while (true)
S    {
S        {
S            unique_lock<_L0> __u0(__l0);
S            if (__l1.try_lock())
S            {
S                __u0.release();
S                break;
S            }
S        }
S        __libcpp_thread_yield();
S        {
S            unique_lock<_L1> __u1(__l1);
S            if (__l0.try_lock())
S            {
S                __u1.release();
S                break;
S            }
S        }
S        __libcpp_thread_yield();
S    }
S}
S
S#ifndef _LIBCPP_CXX03_LANG
S
Stemplate <class _L0, class _L1, class _L2, class ..._L3>
Svoid
S__lock_first(int __i, _L0& __l0, _L1& __l1, _L2& __l2, _L3& ...__l3)
S{
S    while (true)
S    {
S        switch (__i)
S        {
S        case 0:
S            {
S                unique_lock<_L0> __u0(__l0);
S                __i = try_lock(__l1, __l2, __l3...);
S                if (__i == -1)
S                {
S                    __u0.release();
S                    return;
S                }
S            }
S            ++__i;
S            __libcpp_thread_yield();
S            break;
S        case 1:
S            {
S                unique_lock<_L1> __u1(__l1);
S                __i = try_lock(__l2, __l3..., __l0);
S                if (__i == -1)
S                {
S                    __u1.release();
S                    return;
S                }
S            }
S            if (__i == sizeof...(_L3) + 1)
S                __i = 0;
S            else
S                __i += 2;
S            __libcpp_thread_yield();
S            break;
S        default:
S            __lock_first(__i - 2, __l2, __l3..., __l0, __l1);
S            return;
S        }
S    }
S}
S
Stemplate <class _L0, class _L1, class _L2, class ..._L3>
Sinline _LIBCPP_INLINE_VISIBILITY
Svoid
Slock(_L0& __l0, _L1& __l1, _L2& __l2, _L3& ...__l3)
S{
S    __lock_first(0, __l0, __l1, __l2, __l3...);
S}
S
Stemplate <class _L0>
Sinline _LIBCPP_INLINE_VISIBILITY
Svoid __unlock(_L0& __l0) {
S    __l0.unlock();
S}
S
Stemplate <class _L0, class _L1>
Sinline _LIBCPP_INLINE_VISIBILITY
Svoid __unlock(_L0& __l0, _L1& __l1) {
S    __l0.unlock();
S    __l1.unlock();
S}
S
Stemplate <class _L0, class _L1, class _L2, class ..._L3>
Sinline _LIBCPP_INLINE_VISIBILITY
Svoid __unlock(_L0& __l0, _L1& __l1, _L2& __l2, _L3&... __l3) {
S    __l0.unlock();
S    __l1.unlock();
S    _VSTD::__unlock(__l2, __l3...);
S}
S
S#endif  // _LIBCPP_CXX03_LANG
S
S#if _LIBCPP_STD_VER > 14
Stemplate <class ..._Mutexes>
Sclass _LIBCPP_TEMPLATE_VIS scoped_lock;
S
Stemplate <>
Sclass _LIBCPP_TEMPLATE_VIS scoped_lock<> {
Spublic:
S    explicit scoped_lock() {}
S    ~scoped_lock() = default;
S
S    _LIBCPP_INLINE_VISIBILITY
S    explicit scoped_lock(adopt_lock_t) {}
S
S    scoped_lock(scoped_lock const&) = delete;
S    scoped_lock& operator=(scoped_lock const&) = delete;
S};
S
Stemplate <class _Mutex>
Sclass _LIBCPP_TEMPLATE_VIS scoped_lock<_Mutex> {
Spublic:
S    typedef _Mutex  mutex_type;
Sprivate:
S    mutex_type& __m_;
Spublic:
S    explicit scoped_lock(mutex_type & __m) _LIBCPP_THREAD_SAFETY_ANNOTATION(acquire_capability(__m))
S        : __m_(__m) {__m_.lock();}
S
S    ~scoped_lock() _LIBCPP_THREAD_SAFETY_ANNOTATION(release_capability()) {__m_.unlock();}
S
S    _LIBCPP_INLINE_VISIBILITY
S    explicit scoped_lock(adopt_lock_t, mutex_type& __m) _LIBCPP_THREAD_SAFETY_ANNOTATION(requires_capability(__m))
S        : __m_(__m) {}
S
S    scoped_lock(scoped_lock const&) = delete;
S    scoped_lock& operator=(scoped_lock const&) = delete;
S};
S
Stemplate <class ..._MArgs>
Sclass _LIBCPP_TEMPLATE_VIS scoped_lock
S{
S    static_assert(sizeof...(_MArgs) > 1, "At least 2 lock types required");
S    typedef tuple<_MArgs&...> _MutexTuple;
S
Spublic:
S    _LIBCPP_INLINE_VISIBILITY
S    explicit scoped_lock(_MArgs&... __margs)
S      : __t_(__margs...)
S    {
S        _VSTD::lock(__margs...);
S    }
S
S    _LIBCPP_INLINE_VISIBILITY
S    scoped_lock(adopt_lock_t, _MArgs&... __margs)
S        : __t_(__margs...)
S    {
S    }
S
S    _LIBCPP_INLINE_VISIBILITY
S    ~scoped_lock() {
S        typedef typename __make_tuple_indices<sizeof...(_MArgs)>::type _Indices;
S        __unlock_unpack(_Indices{}, __t_);
S    }
S
S    scoped_lock(scoped_lock const&) = delete;
S    scoped_lock& operator=(scoped_lock const&) = delete;
S
Sprivate:
S    template <size_t ..._Indx>
S    _LIBCPP_INLINE_VISIBILITY
S    static void __unlock_unpack(__tuple_indices<_Indx...>, _MutexTuple& __mt) {
S        _VSTD::__unlock(_VSTD::get<_Indx>(__mt)...);
S    }
S
S    _MutexTuple __t_;
S};
S
S#endif // _LIBCPP_STD_VER > 14
N#endif // !_LIBCPP_HAS_NO_THREADS
N
Nstruct _LIBCPP_TEMPLATE_VIS once_flag;
Xstruct  once_flag;
N
N#ifndef _LIBCPP_CXX03_LANG
N
Ntemplate<class _Callable, class... _Args>
N_LIBCPP_INLINE_VISIBILITY
X__attribute__ ((__always_inline__))
Nvoid call_once(once_flag&, _Callable&&, _Args&&...);
N
N#else  // _LIBCPP_CXX03_LANG
S
Stemplate<class _Callable>
S_LIBCPP_INLINE_VISIBILITY
Svoid call_once(once_flag&, _Callable&);
S
Stemplate<class _Callable>
S_LIBCPP_INLINE_VISIBILITY
Svoid call_once(once_flag&, const _Callable&);
S
N#endif  // _LIBCPP_CXX03_LANG
N
Nstruct _LIBCPP_TEMPLATE_VIS once_flag
Xstruct  once_flag
N{
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _LIBCPP_CONSTEXPR
X    constexpr
N        once_flag() _NOEXCEPT : __state_(0) {}
X        once_flag() noexcept : __state_(0) {}
N
Nprivate:
N    once_flag(const once_flag&); // = delete;
N    once_flag& operator=(const once_flag&); // = delete;
N
N    unsigned long __state_;
N
N#ifndef _LIBCPP_CXX03_LANG
N    template<class _Callable, class... _Args>
N    friend
N    void call_once(once_flag&, _Callable&&, _Args&&...);
N#else  // _LIBCPP_CXX03_LANG
S    template<class _Callable>
S    friend
S    void call_once(once_flag&, _Callable&);
S
S    template<class _Callable>
S    friend
S    void call_once(once_flag&, const _Callable&);
N#endif  // _LIBCPP_CXX03_LANG
N};
N
N#ifndef _LIBCPP_CXX03_LANG
N
Ntemplate <class _Fp>
Nclass __call_once_param
N{
N    _Fp& __f_;
Npublic:
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    explicit __call_once_param(_Fp& __f) : __f_(__f) {}
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    void operator()()
N    {
N        typedef typename __make_tuple_indices<tuple_size<_Fp>::value, 1>::type _Index;
N        __execute(_Index());
N    }
N
Nprivate:
N    template <size_t ..._Indices>
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    void __execute(__tuple_indices<_Indices...>)
N    {
N        __invoke(_VSTD::get<0>(_VSTD::move(__f_)), _VSTD::get<_Indices>(_VSTD::move(__f_))...);
X        __invoke(std::__2::get<0>(std::__2::move(__f_)), std::__2::get<_Indices>(std::__2::move(__f_))...);
N    }
N};
N
N#else
S
Stemplate <class _Fp>
Sclass __call_once_param
S{
S    _Fp& __f_;
Spublic:
S    _LIBCPP_INLINE_VISIBILITY
S    explicit __call_once_param(_Fp& __f) : __f_(__f) {}
S
S    _LIBCPP_INLINE_VISIBILITY
S    void operator()()
S    {
S        __f_();
S    }
S};
S
N#endif
N
Ntemplate <class _Fp>
Nvoid
N__call_once_proxy(void* __vp)
N{
N    __call_once_param<_Fp>* __p = static_cast<__call_once_param<_Fp>*>(__vp);
N    (*__p)();
N}
N
N_LIBCPP_FUNC_VIS void __call_once(volatile unsigned long&, void*, void(*)(void*));
X void __call_once(volatile unsigned long&, void*, void(*)(void*));
N
N#ifndef _LIBCPP_CXX03_LANG
N
Ntemplate<class _Callable, class... _Args>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Ncall_once(once_flag& __flag, _Callable&& __func, _Args&&... __args)
N{
N    if (__libcpp_acquire_load(&__flag.__state_) != ~0ul)
N    {
N        typedef tuple<_Callable&&, _Args&&...> _Gp;
N        _Gp __f(_VSTD::forward<_Callable>(__func), _VSTD::forward<_Args>(__args)...);
X        _Gp __f(std::__2::forward<_Callable>(__func), std::__2::forward<_Args>(__args)...);
N        __call_once_param<_Gp> __p(__f);
N        __call_once(__flag.__state_, &__p, &__call_once_proxy<_Gp>);
N    }
N}
N
N#else  // _LIBCPP_CXX03_LANG
S
Stemplate<class _Callable>
Sinline _LIBCPP_INLINE_VISIBILITY
Svoid
Scall_once(once_flag& __flag, _Callable& __func)
S{
S    if (__libcpp_acquire_load(&__flag.__state_) != ~0ul)
S    {
S        __call_once_param<_Callable> __p(__func);
S        __call_once(__flag.__state_, &__p, &__call_once_proxy<_Callable>);
S    }
S}
S
Stemplate<class _Callable>
Sinline _LIBCPP_INLINE_VISIBILITY
Svoid
Scall_once(once_flag& __flag, const _Callable& __func)
S{
S    if (__libcpp_acquire_load(&__flag.__state_) != ~0ul)
S    {
S        __call_once_param<const _Callable> __p(__func);
S        __call_once(__flag.__state_, &__p, &__call_once_proxy<const _Callable>);
S    }
S}
S
N#endif  // _LIBCPP_CXX03_LANG
N
N_LIBCPP_END_NAMESPACE_STD
X} }
N
N_LIBCPP_POP_MACROS
X_Pragma("pop_macro(\"min\")") _Pragma("pop_macro(\"max\")")
N
N#endif  // _LIBCPP_MUTEX
L 19 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/__locale" 2
N#include <cstdint>
N#include <cctype>
N#include <locale.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/locale.h" 1
N/* -*- C++ -*- */
N/*===--------------------------- complex.h --------------------------------===*/
N/*                                                                            */
N/*                     The LLVM Compiler Infrastructure                       */
N/*                                                                            */
N/* This file is dual licensed under the MIT and the University of Illinois Open
N** Source Licenses. See LICENSE.TXT for details.
N*/
N/*===----------------------------------------------------------------------===*/
N
N#ifndef _LIBCPP_LOCALE_H
N#define _LIBCPP_LOCALE_H
N
N/*
N    locale.h synopsis
N
NMacros:
N
N    LC_ALL
N    LC_COLLATE
N    LC_CTYPE
N    LC_MONETARY
N    LC_NUMERIC
N    LC_TIME
N
NTypes:
N
N    lconv
N
NFunctions:
N
N   setlocale
N   localeconv
N
N*/
N
N#include <__config>
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N#include_next <locale.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/locale.h" 1
N/*****************************************************************************/
N/* locale.h                                                                  */
N/*                                                                           */
N/* Copyright (c) 1993 Texas Instruments Incorporated                         */
N/* http://www.ti.com/                                                        */
N/*                                                                           */
N/*  Redistribution and  use in source  and binary forms, with  or without    */
N/*  modification,  are permitted provided  that the  following conditions    */
N/*  are met:                                                                 */
N/*                                                                           */
N/*     Redistributions  of source  code must  retain the  above copyright    */
N/*     notice, this list of conditions and the following disclaimer.         */
N/*                                                                           */
N/*     Redistributions in binary form  must reproduce the above copyright    */
N/*     notice, this  list of conditions  and the following  disclaimer in    */
N/*     the  documentation  and/or   other  materials  provided  with  the    */
N/*     distribution.                                                         */
N/*                                                                           */
N/*     Neither the  name of Texas Instruments Incorporated  nor the names    */
N/*     of its  contributors may  be used to  endorse or  promote products    */
N/*     derived  from   this  software  without   specific  prior  written    */
N/*     permission.                                                           */
N/*                                                                           */
N/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS    */
N/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT    */
N/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    */
N/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT    */
N/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    */
N/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT    */
N/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    */
N/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    */
N/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT    */
N/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    */
N/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     */
N/*                                                                           */
N/*****************************************************************************/
N#ifndef _LOCALE_H_
N#define _LOCALE_H_
N
N#if defined(__TMS320C2000__)
X#if 0L
S#if defined(__TMS320C28XX_CLA__)
S#error "Header file <locale.h> not supported by CLA compiler"
S#endif
N#endif
N
N#pragma diag_push
N#pragma CHECK_MISRA("-6.3") /* standard types required for standard headers */
N#pragma CHECK_MISRA("-20.1") /* standard headers must define standard names */
N#pragma CHECK_MISRA("-20.2") /* standard headers must define standard names */
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
N#ifndef NULL
S #define NULL	0
N#endif
N
N		/* LOCALE CATEGORY INDEXES */
N#if defined(_AEABI_PORTABILITY_LEVEL) && _AEABI_PORTABILITY_LEVEL != 0
X#if 0L && _AEABI_PORTABILITY_LEVEL != 0
Sextern const int __aeabi_LC_COLLATE;
Sextern const int __aeabi_LC_CTYPE;
Sextern const int __aeabi_LC_MONETARY;
Sextern const int __aeabi_LC_NUMERIC;
Sextern const int __aeabi_LC_TIME;
Sextern const int __aeabi_LC_ALL;
S
S#define LC_COLLATE (  __aeabi_LC_COLLATE )
S#define LC_CTYPE (  __aeabi_LC_CTYPE )
S#define LC_MONETARY ( __aeabi_LC_MONETARY )
S#define LC_NUMERIC ( __aeabi_LC_NUMERIC )
S#define LC_TIME ( __aeabi_LC_TIME )
S#define LC_ALL ( __aeabi_LC_ALL )
S
N#else /* _AEABI_PORTABILITY_LEVEL */
N
N#define LC_ALL                  0
N#define LC_COLLATE		1
N#define LC_CTYPE		2
N#define LC_MONETARY	        3
N#define LC_NUMERIC		4
N#define LC_TIME		        5
N#define LC_MESSAGES	        6
N
N#endif/* _AEABI_PORTABILITY_LEVEL */
N
N		/* TYPE DEFINITIONS */
N#if defined(_AEABI_PORTABILITY_LEVEL) && _AEABI_PORTABILITY_LEVEL
X#if 0L && _AEABI_PORTABILITY_LEVEL
Sstruct __aeabi_lconv {
S    char *decimal_point;
S    char *thousands_sep;
S    char *grouping;
S    char *int_curr_symbol;
S    char *currency_symbol;
S    char *mon_decimal_point;
S    char *mon_thousands_sep;
S    char *mon_grouping;
S    char *positive_sign;
S    char *negative_sign;
S    char int_frac_digits;
S    char frac_digits;
S    char p_cs_precedes;
S    char p_sep_by_space;
S    char n_cs_precedes;
S    char n_sep_by_space;
S    char p_sign_posn;
S    char n_sign_posn;
S    char int_p_cs_precedes;
S    char int_n_cs_precedes;
S    char int_p_sep_by_space;
S    char int_n_sep_by_space;
S    char int_p_sign_posn;
S    char int_n_sign_posn;
S};
S
N#else /* _AEABI_PORTABILITY_LEVEL */
Nstruct lconv
N{
N    /* LC_NUMERIC */
N    char *decimal_point;
N    char *grouping;
N    char *thousands_sep;
N    /* LC_MONETARY */
N    char *mon_decimal_point;
N    char *mon_grouping;
N    char *mon_thousands_sep;
N
N    char *negative_sign;
N    char *positive_sign;
N
N    char *currency_symbol;
N
N    char frac_digits;
N    char n_cs_precedes;
N    char n_sep_by_space;
N    char n_sign_posn;
N    char p_cs_precedes;
N    char p_sep_by_space;
N    char p_sign_posn;
N
N    char *int_curr_symbol;
N    char int_frac_digits;
N    char int_p_cs_precedes;
N    char int_n_cs_precedes;
N    char int_p_sep_by_space;
N    char int_n_sep_by_space;
N    char int_p_sign_posn;
N    char int_n_sign_posn;
N};
N#endif /* _AEABI_PORTABILITY_LEVEL */
N
N		/* DECLARATIONS */
N#if defined(_AEABI_PORTABILITY_LEVEL) && _AEABI_PORTABILITY_LEVEL
X#if 0L && _AEABI_PORTABILITY_LEVEL
Sextern struct __aeabi_lconv *__aeabi_localeconv(void);
Sextern void _get_aeabi_lconv(struct __aeabi_lconv *result);
N#else /* _AEABI_PORTABILITY_LEVEL */
Nstruct lconv *localeconv(void);
N#endif/* _AEABI_PORTABILITY_LEVEL */
N
Nchar *setlocale(int category, const char *locale);
N
N#ifdef __cplusplus
N} /* extern "C" */
N#endif /* __cplusplus */
N
N#pragma diag_pop
N
N#if defined(_AEABI_PORTABILITY_LEVEL) && _AEABI_PORTABILITY_LEVEL != 0 && \
N   !defined(_AEABI_PORTABLE)
X#if 0L && _AEABI_PORTABILITY_LEVEL != 0 &&    !0L
S#define _AEABI_PORTABLE
N#endif
N
N/*----------------------------------------------------------------------------*/
N/* If sys/cdefs.h is available, go ahead and include it. xlocale.h assumes    */
N/* this file will have already included sys/cdefs.h.                          */
N/*----------------------------------------------------------------------------*/
N#if __has_include(<sys/cdefs>)
X#if 0
S#include <sys/cdefs.h>
N#endif
N
N/*----------------------------------------------------------------------------*/
N/* Include xlocale/_locale.h> if POSIX is enabled. This will expose the       */
N/* xlocale locale interface.                                                  */
N/*----------------------------------------------------------------------------*/
N#if defined(_POSIX_VISIBLE) && _POSIX_VISIBLE >= 200809
X#if 0L && _POSIX_VISIBLE >= 200809
S__BEGIN_DECLS
S#include <xlocale/_locale.h>
S__END_DECLS
N#endif
N
N#endif /* _LOCALE_H_ */
N
L 44 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/locale.h" 2
N
N#endif  /* _LIBCPP_LOCALE_H */
L 22 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/__locale" 2
N#if defined(_LIBCPP_MSVCRT_LIKE)
X#if 0L
S# include <support/win32/locale_win32.h>
S#elif defined(_AIX)
X#elif 0L
S# include <support/ibm/xlocale.h>
S#elif defined(__ANDROID__)
X#elif 0L
S// Android gained the locale aware functions in L (API level 21)
S# include <android/api-level.h>
S# if __ANDROID_API__ <= 20
S#  include <support/android/locale_bionic.h>
S# endif
S#elif defined(__sun__)
X#elif 0L
S# include <xlocale.h>
S# include <support/solaris/xlocale.h>
S#elif defined(_NEWLIB_VERSION)
X#elif 0L
S# include <support/newlib/xlocale.h>
N#elif (defined(__APPLE__)      || defined(__FreeBSD__) \
N    || defined(__EMSCRIPTEN__) || defined(__IBMCPP__)  \
N    || defined(__TI_COMPILER_VERSION__))
X#elif (0L      || 0L     || 0L || 0L      || 1L)
N# include <xlocale.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/xlocale.h" 1
N/*-
N * SPDX-License-Identifier: BSD-2-Clause-FreeBSD
N *
N * Copyright (c) 2011, 2012 The FreeBSD Foundation
N * All rights reserved.
N *
N * This software was developed by David Chisnall under sponsorship from
N * the FreeBSD Foundation.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N * 1. Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
N * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
N * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
N * SUCH DAMAGE.
N *
N * $FreeBSD$
N */
N
N#ifndef _XLOCALE_H_
N#define _XLOCALE_H_
N
N#include <locale.h>
N__BEGIN_DECLS
Xextern "C" {
N#include <xlocale/_locale.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/xlocale/_locale.h" 1
N/*-
N * SPDX-License-Identifier: BSD-2-Clause-FreeBSD
N *
N * Copyright (c) 2011, 2012 The FreeBSD Foundation
N * All rights reserved.
N *
N * This software was developed by David Chisnall under sponsorship from
N * the FreeBSD Foundation.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N * 1. Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
N * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
N * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
N * SUCH DAMAGE.
N *
N * $FreeBSD$
N */
N
N#ifndef _XLOCALE_LOCALE_H
N#define _XLOCALE_LOCALE_H
N
N/* Bit shifting order of LC_*_MASK should match XLC_* and LC_* order. */
N#define LC_COLLATE_MASK  (1<<0)
N#define LC_CTYPE_MASK    (1<<1)
N#define LC_MONETARY_MASK (1<<2)
N#define LC_NUMERIC_MASK  (1<<3)
N#define LC_TIME_MASK     (1<<4)
N#define LC_MESSAGES_MASK (1<<5)
N#define LC_ALL_MASK      (LC_COLLATE_MASK | LC_CTYPE_MASK | LC_MESSAGES_MASK | \
N			  LC_MONETARY_MASK | LC_NUMERIC_MASK | LC_TIME_MASK)
X#define LC_ALL_MASK      (LC_COLLATE_MASK | LC_CTYPE_MASK | LC_MESSAGES_MASK | 			  LC_MONETARY_MASK | LC_NUMERIC_MASK | LC_TIME_MASK)
N#define LC_GLOBAL_LOCALE ((locale_t)-1)
N
N#ifndef _LOCALE_T_DEFINED
S#define _LOCALE_T_DEFINED
Stypedef struct	_xlocale *locale_t;
N#endif
N
Nlocale_t	 duplocale(locale_t base);
Nvoid		 freelocale(locale_t loc);
Nlocale_t	 newlocale(int mask, const char *locale, locale_t base);
Nconst char	*querylocale(int mask, locale_t loc);
Nlocale_t	 uselocale(locale_t loc);
N
N#endif /* _XLOCALE_LOCALE_H */
L 40 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/xlocale.h" 2
N
N#ifdef _STRING_H_
N#include <xlocale/_string.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/xlocale/_string.h" 1
N/*-
N * SPDX-License-Identifier: BSD-2-Clause-FreeBSD
N *
N * Copyright (c) 2011, 2012 The FreeBSD Foundation
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N * 1. Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
N * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
N * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
N * SUCH DAMAGE.
N *
N * $FreeBSD$
N */
N
N#ifndef _LOCALE_T_DEFINED
S#define _LOCALE_T_DEFINED
Stypedef struct	_xlocale *locale_t;
N#endif
N
N/*
N * This file is included from both string.h and xlocale.h.  We need to expose
N * the declarations unconditionally if we are included from xlocale.h, but only
N * if we are in POSIX2008 mode if included from string.h.
N */
N
N#ifndef _XLOCALE_STRING1_H
N#define _XLOCALE_STRING1_H
N
N/*
N * POSIX2008 functions
N */
Nint	 strcoll_l(const char *, const char *, locale_t);
Nsize_t	 strxfrm_l(char *, const char *, size_t, locale_t);
N#endif /* _XLOCALE_STRING1_H */
N
N/*
N * xlocale extensions
N */
N#ifdef _XLOCALE_H_
N#ifndef _XLOCALE_STRING2_H
N#define _XLOCALE_STRING2_H
Nchar	*strcasestr_l(const char *, const char *, locale_t);
N
N#endif /* _XLOCALE_STRING2_H */
N#endif /* _XLOCALE_H_ */
L 43 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/xlocale.h" 2
N#endif
N
N#ifdef _INTTYPES_H_
S#include <xlocale/_inttypes.h>
N#endif
N
N#ifdef _MONETARY_H_
S#include <xlocale/_monetary.h>
N#endif
N
N#ifdef _STDLIB_H_
N#include <xlocale/_stdlib.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/xlocale/_stdlib.h" 1
N/*-
N * SPDX-License-Identifier: BSD-2-Clause-FreeBSD
N *
N * Copyright (c) 2011, 2012 The FreeBSD Foundation
N * All rights reserved.
N *
N * This software was developed by David Chisnall under sponsorship from
N * the FreeBSD Foundation.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N * 1. Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
N * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
N * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
N * SUCH DAMAGE.
N *
N * $FreeBSD$
N */
N
N/*
N * Extended locale versions of the locale-aware functions from stdlib.h.
N *
N * Include <stdlib.h> before <xlocale.h> to expose these.
N */
Ndouble			 atof_l(const char *, locale_t);
Nint			 atoi_l(const char *, locale_t);
Nlong			 atol_l(const char *, locale_t);
Nlong long		 atoll_l(const char *, locale_t);
Nint			 mblen_l(const char *, size_t, locale_t);
Nsize_t			 mbstowcs_l(wchar_t * __restrict,
N			    const char * __restrict, size_t, locale_t);
Nint			 mbtowc_l(wchar_t * __restrict,
N			    const char * __restrict, size_t, locale_t);
Ndouble			 strtod_l(const char *, char **, locale_t);
Nfloat			 strtof_l(const char *, char **, locale_t);
Nlong			 strtol_l(const char *, char **, int, locale_t);
Nlong double		 strtold_l(const char *, char **, locale_t);
Nlong long		 strtoll_l(const char *, char **, int, locale_t);
Nunsigned long		 strtoul_l(const char *, char **, int, locale_t);
Nunsigned long long	 strtoull_l(const char *, char **, int, locale_t);
Nsize_t			 wcstombs_l(char * __restrict,
N			    const wchar_t * __restrict, size_t, locale_t);
Nint			 wctomb_l(char *, wchar_t, locale_t);
N
Nint			 ___mb_cur_max_l(locale_t);
N#define MB_CUR_MAX_L(x) ((size_t)___mb_cur_max_l(x))
N
L 55 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/xlocale.h" 2
N#endif
N
N#ifdef _TIME_H_
N#include <xlocale/_time.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/xlocale/_time.h" 1
N/*-
N * SPDX-License-Identifier: BSD-2-Clause-FreeBSD
N *
N * Copyright (c) 2011, 2012 The FreeBSD Foundation
N * All rights reserved.
N *
N * This software was developed by David Chisnall under sponsorship from
N * the FreeBSD Foundation.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N * 1. Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
N * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
N * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
N * SUCH DAMAGE.
N *
N * $FreeBSD$
N */
N
N#ifndef _LOCALE_T_DEFINED
S#define _LOCALE_T_DEFINED
Stypedef struct	_xlocale *locale_t;
N#endif
N
N/*
N * This file is included from both locale.h and xlocale.h.  We need to expose
N * the declarations unconditionally if we are included from xlocale.h, but only
N * if we are in POSIX2008 mode if included from locale.h.
N */
N#ifndef _XLOCALE_LOCALE1_H
S#define _XLOCALE_LOCALE1_H
S
Ssize_t	 strftime_l(char * __restrict, size_t, const char * __restrict,
S	    const struct tm * __restrict, locale_t) __strftimelike(3, 0);
S
N#endif /* _XLOCALE_LOCALE1_H */
N
N#ifdef _XLOCALE_H_
N#ifndef _XLOCALE_LOCALE2_H
N#define _XLOCALE_LOCALE2_H
N
Nchar	*strptime_l(const char * __restrict, const char * __restrict,
N           struct tm * __restrict, locale_t);
N
N#endif /* _XLOCALE_LOCALE2_H */
N#endif /* _XLOCALE_H_ */
L 59 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/xlocale.h" 2
N#endif
N
N#ifdef _LANGINFO_H_
S#include <xlocale/_langinfo.h>
N#endif
N
N#ifdef _CTYPE_H_
N#include <xlocale/_ctype.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/xlocale/_ctype.h" 1
N/*****************************************************************************/
N/*  _CTYPE.H                                                                 */
N/*                                                                           */
N/* Copyright (c) 2017 Texas Instruments Incorporated                         */
N/* http://www.ti.com/                                                        */
N/*                                                                           */
N/*  Redistribution and  use in source  and binary forms, with  or without    */
N/*  modification,  are permitted provided  that the  following conditions    */
N/*  are met:                                                                 */
N/*                                                                           */
N/*     Redistributions  of source  code must  retain the  above copyright    */
N/*     notice, this list of conditions and the following disclaimer.         */
N/*                                                                           */
N/*     Redistributions in binary form  must reproduce the above copyright    */
N/*     notice, this  list of conditions  and the following  disclaimer in    */
N/*     the  documentation  and/or   other  materials  provided  with  the    */
N/*     distribution.                                                         */
N/*                                                                           */
N/*     Neither the  name of Texas Instruments Incorporated  nor the names    */
N/*     of its  contributors may  be used to  endorse or  promote products    */
N/*     derived  from   this  software  without   specific  prior  written    */
N/*     permission.                                                           */
N/*                                                                           */
N/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS    */
N/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT    */
N/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    */
N/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT    */
N/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    */
N/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT    */
N/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    */
N/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    */
N/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT    */
N/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    */
N/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     */
N/*                                                                           */
N/*****************************************************************************/
N
N/*-
N * SPDX-License-Identifier: BSD-2-Clause-FreeBSD
N *
N * Copyright (c) 2011 The FreeBSD Foundation
N * All rights reserved.
N *
N * This software was developed by David Chisnall under sponsorship from
N * the FreeBSD Foundation.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N * 1. Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
N * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
N * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
N * SUCH DAMAGE.
N *
N * $FreeBSD$
N */
N
N
N#if	(defined(_XLOCALE_WCTYPES) && !defined(_XLOCALE_WCTYPE_H)) || \
N	(!defined(_XLOCALE_WCTYPES) && !defined(_XLOCALE_CTYPE_H))
X#if	(0L && !1L) || 	(!0L && !0L)
N
N#ifdef _XLOCALE_WCTYPES
S#define _XLOCALE_WCTYPE_H
N#else
N#define _XLOCALE_CTYPE_H
N#endif
N
N#ifndef _LOCALE_T_DEFINED
S#define _LOCALE_T_DEFINED
Stypedef struct	_xlocale *locale_t;
N#endif
N
N#ifndef _XLOCALE_INLINE
S#define _XLOCALE_INLINE static __inline
N#endif /* _XLOCALE_INLINE */
N
N#ifdef _XLOCALE_WCTYPES
S
S#define XLOCALE_ISCTYPE(fname, cat) \
S		_XLOCALE_INLINE int isw##fname##_l(int, locale_t);\
S		_XLOCALE_INLINE int isw##fname##_l(int __c, locale_t __l)\
S                { return isw##fname(__c); }
X#define XLOCALE_ISCTYPE(fname, cat) 		_XLOCALE_INLINE int isw##fname##_l(int, locale_t);		_XLOCALE_INLINE int isw##fname##_l(int __c, locale_t __l)                { return isw##fname(__c); }
N#else
N#define XLOCALE_ISCTYPE(__fname, __cat)                             \
N		_XLOCALE_INLINE int is##__fname##_l(int, locale_t); \
N		_XLOCALE_INLINE int is##__fname##_l(int __c, locale_t __l)\
N		{ return is##__fname(__c); }
X#define XLOCALE_ISCTYPE(__fname, __cat)                             		_XLOCALE_INLINE int is##__fname##_l(int, locale_t); 		_XLOCALE_INLINE int is##__fname##_l(int __c, locale_t __l)		{ return is##__fname(__c); }
N#endif
N
NXLOCALE_ISCTYPE(alnum, _CTYPE_A|_CTYPE_D|_CTYPE_N)
Xstatic inline int isalnum_l(int, locale_t); static inline int isalnum_l(int __c, locale_t __l) { return isalnum(__c); }
NXLOCALE_ISCTYPE(alpha, _CTYPE_A)
Xstatic inline int isalpha_l(int, locale_t); static inline int isalpha_l(int __c, locale_t __l) { return isalpha(__c); }
NXLOCALE_ISCTYPE(blank, _CTYPE_B)
Xstatic inline int isblank_l(int, locale_t); static inline int isblank_l(int __c, locale_t __l) { return isblank(__c); }
NXLOCALE_ISCTYPE(cntrl, _CTYPE_C)
Xstatic inline int iscntrl_l(int, locale_t); static inline int iscntrl_l(int __c, locale_t __l) { return iscntrl(__c); }
NXLOCALE_ISCTYPE(digit, _CTYPE_D)
Xstatic inline int isdigit_l(int, locale_t); static inline int isdigit_l(int __c, locale_t __l) { return isdigit(__c); }
NXLOCALE_ISCTYPE(graph, _CTYPE_G)
Xstatic inline int isgraph_l(int, locale_t); static inline int isgraph_l(int __c, locale_t __l) { return isgraph(__c); }
NXLOCALE_ISCTYPE(lower, _CTYPE_L)
Xstatic inline int islower_l(int, locale_t); static inline int islower_l(int __c, locale_t __l) { return islower(__c); }
NXLOCALE_ISCTYPE(print, _CTYPE_R)
Xstatic inline int isprint_l(int, locale_t); static inline int isprint_l(int __c, locale_t __l) { return isprint(__c); }
NXLOCALE_ISCTYPE(punct, _CTYPE_P)
Xstatic inline int ispunct_l(int, locale_t); static inline int ispunct_l(int __c, locale_t __l) { return ispunct(__c); }
NXLOCALE_ISCTYPE(space, _CTYPE_S)
Xstatic inline int isspace_l(int, locale_t); static inline int isspace_l(int __c, locale_t __l) { return isspace(__c); }
NXLOCALE_ISCTYPE(upper, _CTYPE_U)
Xstatic inline int isupper_l(int, locale_t); static inline int isupper_l(int __c, locale_t __l) { return isupper(__c); }
NXLOCALE_ISCTYPE(xdigit, _CTYPE_X)
Xstatic inline int isxdigit_l(int, locale_t); static inline int isxdigit_l(int __c, locale_t __l) { return isxdigit(__c); }
N#undef XLOCALE_ISCTYPE
N
N#ifdef _XLOCALE_WCTYPES
S_XLOCALE_INLINE int towlower_l(int, locale_t);
S_XLOCALE_INLINE int towupper_l(int, locale_t);
S
S_XLOCALE_INLINE int towlower_l(int __c, locale_t __l)
S{
S   return towlower(__c);
S}
S_XLOCALE_INLINE int towupper_l(int __c, locale_t __l)
S{
S   return towupper(__c);
S}
S
S_XLOCALE_INLINE int
Siswctype_l(wint_t __wc, wctype_t __charclass, locale_t __l)
S{
S   return iswctype(__wc, __charclass);
S}
S
S_XLOCALE_INLINE wctype_t
Swctype_l(const char *property, locale_t __l)
S{
S   return wctype(property);
S}
S
S_XLOCALE_INLINE wint_t
Stowctrans_l(wint_t __wc, wctrans_t desc, locale_t __l)
S{
S   return towctrans(__wc, desc);
S}
S
S_XLOCALE_INLINE wctrans_t
Swctrans_l(const char *__charclass, locale_t __l)
S{
S   return wctrans(__charclass);
S}
S
S#undef _XLOCALE_WCTYPES
N#else
N_XLOCALE_INLINE int tolower_l(int, locale_t);
Xstatic inline int tolower_l(int, locale_t);
N_XLOCALE_INLINE int toupper_l(int, locale_t);
Xstatic inline int toupper_l(int, locale_t);
N
N_XLOCALE_INLINE int tolower_l(int __c, locale_t __l)
Xstatic inline int tolower_l(int __c, locale_t __l)
N{
N   return tolower(__c);
N}
N_XLOCALE_INLINE int toupper_l(int __c, locale_t __l)
Xstatic inline int toupper_l(int __c, locale_t __l)
N{
N   return toupper(__c);
N}
N#endif
N#endif /* (defined(_XLOCALE_WCTYPES) && !defined(_XLOCALE_WCTYPE_H)) || \
N	(!defined(_XLOCALE_WCTYPES) && !defined(_XLOCALE_CTYPE_H)) */
X#endif  
L 67 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/xlocale.h" 2
N#endif
N
N#ifdef _WCTYPE_H_
N#define _XLOCALE_WCTYPES 1
N#include <xlocale/_ctype.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/xlocale/_ctype.h" 1
N/*****************************************************************************/
N/*  _CTYPE.H                                                                 */
N/*                                                                           */
N/* Copyright (c) 2017 Texas Instruments Incorporated                         */
N/* http://www.ti.com/                                                        */
N/*                                                                           */
N/*  Redistribution and  use in source  and binary forms, with  or without    */
N/*  modification,  are permitted provided  that the  following conditions    */
N/*  are met:                                                                 */
N/*                                                                           */
N/*     Redistributions  of source  code must  retain the  above copyright    */
N/*     notice, this list of conditions and the following disclaimer.         */
N/*                                                                           */
N/*     Redistributions in binary form  must reproduce the above copyright    */
N/*     notice, this  list of conditions  and the following  disclaimer in    */
N/*     the  documentation  and/or   other  materials  provided  with  the    */
N/*     distribution.                                                         */
N/*                                                                           */
N/*     Neither the  name of Texas Instruments Incorporated  nor the names    */
N/*     of its  contributors may  be used to  endorse or  promote products    */
N/*     derived  from   this  software  without   specific  prior  written    */
N/*     permission.                                                           */
N/*                                                                           */
N/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS    */
N/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT    */
N/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    */
N/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT    */
N/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    */
N/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT    */
N/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    */
N/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    */
N/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT    */
N/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    */
N/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     */
N/*                                                                           */
N/*****************************************************************************/
N
N/*-
N * SPDX-License-Identifier: BSD-2-Clause-FreeBSD
N *
N * Copyright (c) 2011 The FreeBSD Foundation
N * All rights reserved.
N *
N * This software was developed by David Chisnall under sponsorship from
N * the FreeBSD Foundation.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N * 1. Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
N * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
N * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
N * SUCH DAMAGE.
N *
N * $FreeBSD$
N */
N
N
N#if	(defined(_XLOCALE_WCTYPES) && !defined(_XLOCALE_WCTYPE_H)) || \
N	(!defined(_XLOCALE_WCTYPES) && !defined(_XLOCALE_CTYPE_H))
X#if	(1L && !1L) || 	(!1L && !1L)
S
S#ifdef _XLOCALE_WCTYPES
S#define _XLOCALE_WCTYPE_H
S#else
S#define _XLOCALE_CTYPE_H
S#endif
S
S#ifndef _LOCALE_T_DEFINED
S#define _LOCALE_T_DEFINED
Stypedef struct	_xlocale *locale_t;
S#endif
S
S#ifndef _XLOCALE_INLINE
S#define _XLOCALE_INLINE static __inline
S#endif /* _XLOCALE_INLINE */
S
S#ifdef _XLOCALE_WCTYPES
S
S#define XLOCALE_ISCTYPE(fname, cat) \
S		_XLOCALE_INLINE int isw##fname##_l(int, locale_t);\
S		_XLOCALE_INLINE int isw##fname##_l(int __c, locale_t __l)\
S                { return isw##fname(__c); }
X#define XLOCALE_ISCTYPE(fname, cat) 		_XLOCALE_INLINE int isw##fname##_l(int, locale_t);		_XLOCALE_INLINE int isw##fname##_l(int __c, locale_t __l)                { return isw##fname(__c); }
S#else
S#define XLOCALE_ISCTYPE(__fname, __cat)                             \
S		_XLOCALE_INLINE int is##__fname##_l(int, locale_t); \
S		_XLOCALE_INLINE int is##__fname##_l(int __c, locale_t __l)\
S		{ return is##__fname(__c); }
X#define XLOCALE_ISCTYPE(__fname, __cat)                             		_XLOCALE_INLINE int is##__fname##_l(int, locale_t); 		_XLOCALE_INLINE int is##__fname##_l(int __c, locale_t __l)		{ return is##__fname(__c); }
S#endif
S
SXLOCALE_ISCTYPE(alnum, _CTYPE_A|_CTYPE_D|_CTYPE_N)
SXLOCALE_ISCTYPE(alpha, _CTYPE_A)
SXLOCALE_ISCTYPE(blank, _CTYPE_B)
SXLOCALE_ISCTYPE(cntrl, _CTYPE_C)
SXLOCALE_ISCTYPE(digit, _CTYPE_D)
SXLOCALE_ISCTYPE(graph, _CTYPE_G)
SXLOCALE_ISCTYPE(lower, _CTYPE_L)
SXLOCALE_ISCTYPE(print, _CTYPE_R)
SXLOCALE_ISCTYPE(punct, _CTYPE_P)
SXLOCALE_ISCTYPE(space, _CTYPE_S)
SXLOCALE_ISCTYPE(upper, _CTYPE_U)
SXLOCALE_ISCTYPE(xdigit, _CTYPE_X)
S#undef XLOCALE_ISCTYPE
S
S#ifdef _XLOCALE_WCTYPES
S_XLOCALE_INLINE int towlower_l(int, locale_t);
S_XLOCALE_INLINE int towupper_l(int, locale_t);
S
S_XLOCALE_INLINE int towlower_l(int __c, locale_t __l)
S{
S   return towlower(__c);
S}
S_XLOCALE_INLINE int towupper_l(int __c, locale_t __l)
S{
S   return towupper(__c);
S}
S
S_XLOCALE_INLINE int
Siswctype_l(wint_t __wc, wctype_t __charclass, locale_t __l)
S{
S   return iswctype(__wc, __charclass);
S}
S
S_XLOCALE_INLINE wctype_t
Swctype_l(const char *property, locale_t __l)
S{
S   return wctype(property);
S}
S
S_XLOCALE_INLINE wint_t
Stowctrans_l(wint_t __wc, wctrans_t desc, locale_t __l)
S{
S   return towctrans(__wc, desc);
S}
S
S_XLOCALE_INLINE wctrans_t
Swctrans_l(const char *__charclass, locale_t __l)
S{
S   return wctrans(__charclass);
S}
S
S#undef _XLOCALE_WCTYPES
S#else
S_XLOCALE_INLINE int tolower_l(int, locale_t);
S_XLOCALE_INLINE int toupper_l(int, locale_t);
S
S_XLOCALE_INLINE int tolower_l(int __c, locale_t __l)
S{
S   return tolower(__c);
S}
S_XLOCALE_INLINE int toupper_l(int __c, locale_t __l)
S{
S   return toupper(__c);
S}
S#endif
N#endif /* (defined(_XLOCALE_WCTYPES) && !defined(_XLOCALE_WCTYPE_H)) || \
N	(!defined(_XLOCALE_WCTYPES) && !defined(_XLOCALE_CTYPE_H)) */
X#endif  
L 72 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/xlocale.h" 2
N#endif
N
N#ifdef _STDIO_H_
N#include <xlocale/_stdio.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/xlocale/_stdio.h" 1
N/*-
N * SPDX-License-Identifier: BSD-2-Clause-FreeBSD
N *
N * Copyright (c) 2011, 2012 The FreeBSD Foundation
N * All rights reserved.
N *
N * This software was developed by David Chisnall under sponsorship from
N * the FreeBSD Foundation.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N * 1. Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
N * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
N * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
N * SUCH DAMAGE.
N *
N * $FreeBSD$
N */
N
Nint	 asprintf_l(char **, locale_t, const char *, ...) __printflike(3, 4);
Xint	 asprintf_l(char **, locale_t, const char *, ...) ;
Nint	 dprintf_l(int, locale_t, const char * __restrict, ...)
N	    __printflike(3, 4);
X	    ;
Nint	 fprintf_l(FILE * __restrict, locale_t, const char * __restrict, ...)
N	    __printflike(3, 4);
X	    ;
Nint	 fscanf_l(FILE * __restrict, locale_t, const char * __restrict, ...)
N	    __scanflike(3, 4);
X	    ;
Nint	 printf_l(locale_t, const char * __restrict, ...) __printflike(2, 3);
Xint	 printf_l(locale_t, const char * __restrict, ...) ;
Nint	 scanf_l(locale_t, const char * __restrict, ...) __scanflike(2, 3);
Xint	 scanf_l(locale_t, const char * __restrict, ...) ;
Nint	 snprintf_l(char * __restrict, size_t, locale_t,
N	    const char * __restrict, ...) __printflike(4, 5);
X	    const char * __restrict, ...) ;
Nint	 sprintf_l(char * __restrict, locale_t, const char * __restrict, ...)
N	    __printflike(3, 4);
X	    ;
Nint	 sscanf_l(const char * __restrict, locale_t, const char * __restrict,
N	    ...) __scanflike(3, 4);
X	    ...) ;
Nint	 vfprintf_l(FILE * __restrict, locale_t, const char * __restrict,
N	    __va_list) __printflike(3, 0);
X	    __va_list) ;
Nint	 vprintf_l(locale_t, const char * __restrict, __va_list)
N	    __printflike(2, 0);
X	    ;
Nint	 vsprintf_l(char * __restrict, locale_t, const char * __restrict,
N	    __va_list) __printflike(3, 0);
X	    __va_list) ;
Nint	 vfscanf_l(FILE * __restrict, locale_t, const char * __restrict,
N	    __va_list) __scanflike(3, 0);
X	    __va_list) ;
Nint	 vscanf_l(locale_t, const char * __restrict, __va_list)
N	    __scanflike(2, 0);
X	    ;
Nint	 vsnprintf_l(char * __restrict, size_t, locale_t,
N	    const char * __restrict, __va_list) __printflike(4, 0);
X	    const char * __restrict, __va_list) ;
Nint	 vsscanf_l(const char * __restrict, locale_t, const char * __restrict,
N	    __va_list) __scanflike(3, 0);
X	    __va_list) ;
Nint	 vdprintf_l(int, locale_t, const char * __restrict, __va_list)
N	    __printflike(3, 0);
X	    ;
Nint	 vasprintf_l(char **, locale_t, const char *, __va_list)
N	    __printflike(3, 0);
X	    ;
L 76 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/xlocale.h" 2
N#endif
N
N#ifdef _WCHAR_H_
N#include <xlocale/_wchar.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/xlocale/_wchar.h" 1
N/*-
N * SPDX-License-Identifier: BSD-2-Clause-FreeBSD
N *
N * Copyright (c) 2011, 2012 The FreeBSD Foundation
N * All rights reserved.
N *
N * This software was developed by David Chisnall under sponsorship from
N * the FreeBSD Foundation.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N * 1. Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
N * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
N * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
N * SUCH DAMAGE.
N *
N * $FreeBSD$
N */
N
N#ifndef _LOCALE_T_DEFINED
S#define _LOCALE_T_DEFINED
Stypedef struct	_xlocale *locale_t;
N#endif
N
N#ifndef _XLOCALE_WCHAR1_H
S#define _XLOCALE_WCHAR1_H
Sint			 wcscasecmp_l(const wchar_t *, const wchar_t *,
S			   locale_t);
Sint			 wcsncasecmp_l(const wchar_t *, const wchar_t *, size_t,
S			   locale_t);
Sint			 wcscoll_l(const wchar_t *, const wchar_t *, locale_t);
Ssize_t			 wcsxfrm_l(wchar_t * __restrict,
S			   const wchar_t * __restrict, size_t, locale_t);
S
N#endif /* _XLOCALE_WCHAR1_H */
N
N/*
N * Only declare the non-POSIX functions if we're included from xlocale.h.
N */
N
N#ifdef _XLOCALE_H_
N#ifndef _XLOCALE_WCHAR2_H
N#define _XLOCALE_WCHAR2_H
N
Nwint_t			 btowc_l(int, locale_t);
Nwint_t			 fgetwc_l(FILE *, locale_t);
Nwchar_t			*fgetws_l(wchar_t * __restrict, int, FILE * __restrict,
N			    locale_t);
Nwint_t			 fputwc_l(wchar_t, FILE *, locale_t);
Nint			 fputws_l(const wchar_t * __restrict, FILE * __restrict,
N			   locale_t);
Nint			 fwprintf_l(FILE * __restrict, locale_t,
N			    const wchar_t * __restrict, ...);
Nint			 fwscanf_l(FILE * __restrict, locale_t,
N			    const wchar_t * __restrict, ...);
Nwint_t			 getwc_l(FILE *, locale_t);
Nwint_t			 getwchar_l(locale_t);
Nsize_t			 mbrlen_l(const char * __restrict, size_t,
N			   mbstate_t * __restrict, locale_t);
Nsize_t			 mbrtowc_l(wchar_t * __restrict,
N			    const char * __restrict, size_t,
N			    mbstate_t * __restrict, locale_t);
Nint			 mbsinit_l(const mbstate_t *, locale_t);
Nsize_t			 mbsrtowcs_l(wchar_t * __restrict,
N			    const char ** __restrict, size_t,
N			    mbstate_t * __restrict, locale_t);
Nwint_t			 putwc_l(wchar_t, FILE *, locale_t);
Nwint_t			 putwchar_l(wchar_t, locale_t);
Nint			 swprintf_l(wchar_t * __restrict, size_t n, locale_t,
N			    const wchar_t * __restrict, ...);
Nint			 swscanf_l(const wchar_t * __restrict, locale_t,
N			   const wchar_t * __restrict, ...);
Nwint_t			 ungetwc_l(wint_t, FILE *, locale_t);
Nint			 vfwprintf_l(FILE * __restrict, locale_t,
N			    const wchar_t * __restrict, __va_list);
Nint			 vswprintf_l(wchar_t * __restrict, size_t n, locale_t,
N			    const wchar_t * __restrict, __va_list);
Nint			 vwprintf_l(locale_t, const wchar_t * __restrict,
N			    __va_list);
Nsize_t			 wcrtomb_l(char * __restrict, wchar_t,
N			    mbstate_t * __restrict, locale_t);
Nsize_t			 wcsftime_l(wchar_t * __restrict, size_t,
N			    const wchar_t * __restrict,
N			    const struct tm * __restrict, locale_t);
Nsize_t			 wcsrtombs_l(char * __restrict,
N			    const wchar_t ** __restrict, size_t,
N			    mbstate_t * __restrict, locale_t);
Ndouble			 wcstod_l(const wchar_t * __restrict,
N			    wchar_t ** __restrict, locale_t);
Nlong			 wcstol_l(const wchar_t * __restrict,
N			    wchar_t ** __restrict, int, locale_t);
Nunsigned long		 wcstoul_l(const wchar_t * __restrict,
N			    wchar_t ** __restrict, int, locale_t);
Nint			 wcswidth_l(const wchar_t *, size_t, locale_t);
Nint			 wctob_l(wint_t, locale_t);
Nint			 wcwidth_l(wchar_t, locale_t);
Nint			 wprintf_l(locale_t, const wchar_t * __restrict, ...);
Nint			 wscanf_l(locale_t, const wchar_t * __restrict, ...);
Nint			 vfwscanf_l(FILE * __restrict, locale_t,
N			    const wchar_t * __restrict, __va_list);
Nint			 vswscanf_l(const wchar_t * __restrict, locale_t,
N			    const wchar_t *__restrict, __va_list);
Nint			 vwscanf_l(locale_t, const wchar_t * __restrict,
N			    __va_list);
Nfloat			 wcstof_l(const wchar_t * __restrict,
N			    wchar_t ** __restrict, locale_t);
Nlong double		 wcstold_l(const wchar_t * __restrict,
N			    wchar_t ** __restrict, locale_t);
Nlong long		 wcstoll_l(const wchar_t * __restrict,
N			    wchar_t ** __restrict, int, locale_t);
Nunsigned long long	 wcstoull_l(const wchar_t * __restrict,
N			    wchar_t ** __restrict, int, locale_t);
Nsize_t			 mbsnrtowcs_l(wchar_t * __restrict,
N			    const char ** __restrict, size_t, size_t,
N			    mbstate_t * __restrict, locale_t);
Nsize_t			 wcsnrtombs_l(char * __restrict,
N			    const wchar_t ** __restrict, size_t, size_t,
N			    mbstate_t * __restrict, locale_t);
N
N#endif /* _XLOCALE_WCHAR_H */
N#endif /* _XLOCALE_H_ */
L 80 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/xlocale.h" 2
N#endif
N
N
N
Nstruct lconv	*localeconv_l(locale_t);
N__END_DECLS
X}
N
N#endif
L 41 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/__locale" 2
N#elif defined(__Fuchsia__)
S# include <support/fuchsia/xlocale.h>
S#elif defined(_LIBCPP_HAS_MUSL_LIBC)
S# include <support/musl/xlocale.h>
N#endif
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N_LIBCPP_BEGIN_NAMESPACE_STD
Xnamespace std { inline namespace __2 {
N
N#if !defined(_LIBCPP_LOCALE__L_EXTENSIONS) || defined(_LIBCPP_MSVCRT)
X#if !1L || 0L
Sstruct __libcpp_locale_guard {
S  _LIBCPP_INLINE_VISIBILITY
S  __libcpp_locale_guard(locale_t& __loc) : __old_loc_(uselocale(__loc)) {}
S
S  _LIBCPP_INLINE_VISIBILITY
S  ~__libcpp_locale_guard() {
S    if (__old_loc_)
S      uselocale(__old_loc_);
S  }
S
S  locale_t __old_loc_;
Sprivate:
S  __libcpp_locale_guard(__libcpp_locale_guard const&);
S  __libcpp_locale_guard& operator=(__libcpp_locale_guard const&);
S};
N#endif
N
N
Nclass _LIBCPP_TYPE_VIS locale;
Xclass  locale;
N
Ntemplate <class _Facet>
N_LIBCPP_INLINE_VISIBILITY
X__attribute__ ((__always_inline__))
Nbool
Nhas_facet(const locale&) _NOEXCEPT;
Xhas_facet(const locale&) noexcept;
N
Ntemplate <class _Facet>
N_LIBCPP_INLINE_VISIBILITY
X__attribute__ ((__always_inline__))
Nconst _Facet&
Nuse_facet(const locale&);
N
Nclass _LIBCPP_TYPE_VIS locale
Xclass  locale
N{
Npublic:
N    // types:
N    class _LIBCPP_TYPE_VIS facet;
X    class  facet;
N    class _LIBCPP_TYPE_VIS id;
X    class  id;
N
N    typedef int category;
N    _LIBCPP_AVAILABILITY_LOCALE_CATEGORY
X    
N    static const category // values assigned here are for exposition only
N        none     = 0,
N        collate  = LC_COLLATE_MASK,
X        collate  = (1<<0),
N        ctype    = LC_CTYPE_MASK,
X        ctype    = (1<<1),
N        monetary = LC_MONETARY_MASK,
X        monetary = (1<<2),
N        numeric  = LC_NUMERIC_MASK,
X        numeric  = (1<<3),
N        time     = LC_TIME_MASK,
X        time     = (1<<4),
N        messages = LC_MESSAGES_MASK,
X        messages = (1<<5),
N        all = collate | ctype | monetary | numeric | time | messages;
N
N    // construct/copy/destroy:
N    locale()  _NOEXCEPT;
X    locale()  noexcept;
N    locale(const locale&)  _NOEXCEPT;
X    locale(const locale&)  noexcept;
N    explicit locale(const char*);
N    explicit locale(const string&);
N    locale(const locale&, const char*, category);
N    locale(const locale&, const string&, category);
N    template <class _Facet>
N        _LIBCPP_INLINE_VISIBILITY locale(const locale&, _Facet*);
X        __attribute__ ((__always_inline__)) locale(const locale&, _Facet*);
N    locale(const locale&, const locale&, category);
N
N    ~locale();
N
N    const locale& operator=(const locale&)  _NOEXCEPT;
X    const locale& operator=(const locale&)  noexcept;
N
N    template <class _Facet>
N      _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
X      
N      locale combine(const locale&) const;
N
N    // locale operations:
N    string name() const;
N    bool operator==(const locale&) const;
N    bool operator!=(const locale& __y) const {return !(*this == __y);}
N    template <class _CharT, class _Traits, class _Allocator>
N      _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
X      
N      bool operator()(const basic_string<_CharT, _Traits, _Allocator>&,
N                      const basic_string<_CharT, _Traits, _Allocator>&) const;
N
N    // global locale objects:
N    static locale global(const locale&);
N    static const locale& classic();
N
Nprivate:
N    class __imp;
N    __imp* __locale_;
N
N    void __install_ctor(const locale&, facet*, long);
N    static locale& __global();
N    bool has_facet(id&) const;
N    const facet* use_facet(id&) const;
N
N    template <class _Facet> friend bool has_facet(const locale&)  _NOEXCEPT;
X    template <class _Facet> friend bool has_facet(const locale&)  noexcept;
N    template <class _Facet> friend const _Facet& use_facet(const locale&);
N};
N
Nclass _LIBCPP_TYPE_VIS locale::facet
Xclass  locale::facet
N    : public __shared_count
N{
Nprotected:
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    explicit facet(size_t __refs = 0)
N        : __shared_count(static_cast<long>(__refs)-1) {}
N
N    virtual ~facet();
N
N//    facet(const facet&) = delete;     // effectively done in __shared_count
N//    void operator=(const facet&) = delete;
Nprivate:
N    virtual void __on_zero_shared() _NOEXCEPT;
X    virtual void __on_zero_shared() noexcept;
N};
N
Nclass _LIBCPP_TYPE_VIS locale::id
Xclass  locale::id
N{
N    once_flag      __flag_;
N    int32_t        __id_;
N
N    static int32_t __next_id;
Npublic:
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR id() :__id_(0) {}
X    __attribute__ ((__always_inline__)) constexpr id() :__id_(0) {}
Nprivate:
N    void __init();
N    void operator=(const id&); // = delete;
N    id(const id&); // = delete;
Npublic:  // only needed for tests
N    long __get();
N
N    friend class locale;
N    friend class locale::__imp;
N};
N
Ntemplate <class _Facet>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nlocale::locale(const locale& __other, _Facet* __f)
N{
N    __install_ctor(__other, __f, __f ? __f->id.__get() : 0);
N}
N
Ntemplate <class _Facet>
Nlocale
Nlocale::combine(const locale& __other) const
N{
N    if (!_VSTD::has_facet<_Facet>(__other))
X    if (!std::__2::has_facet<_Facet>(__other))
N        __throw_runtime_error("locale::combine: locale missing facet");
N
N    return locale(*this, &const_cast<_Facet&>(_VSTD::use_facet<_Facet>(__other)));
X    return locale(*this, &const_cast<_Facet&>(std::__2::use_facet<_Facet>(__other)));
N}
N
Ntemplate <class _Facet>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Nhas_facet(const locale& __l)  _NOEXCEPT
Xhas_facet(const locale& __l)  noexcept
N{
N    return __l.has_facet(_Facet::id);
N}
N
Ntemplate <class _Facet>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nconst _Facet&
Nuse_facet(const locale& __l)
N{
N    return static_cast<const _Facet&>(*__l.use_facet(_Facet::id));
N}
N
N// template <class _CharT> class collate;
N
Ntemplate <class _CharT>
Nclass _LIBCPP_TEMPLATE_VIS collate
Xclass  collate
N    : public locale::facet
N{
Npublic:
N    typedef _CharT char_type;
N    typedef basic_string<char_type> string_type;
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    explicit collate(size_t __refs = 0)
N        : locale::facet(__refs) {}
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    int compare(const char_type* __lo1, const char_type* __hi1,
N                const char_type* __lo2, const char_type* __hi2) const
N    {
N        return do_compare(__lo1, __hi1, __lo2, __hi2);
N    }
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    string_type transform(const char_type* __lo, const char_type* __hi) const
N    {
N        return do_transform(__lo, __hi);
N    }
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    long hash(const char_type* __lo, const char_type* __hi) const
N    {
N        return do_hash(__lo, __hi);
N    }
N
N    static _DATA_ACCESS locale::id id;
X    static  locale::id id;
N
Nprotected:
N    ~collate();
N    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,
N                           const char_type* __lo2, const char_type* __hi2) const;
N    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const
N        {return string_type(__lo, __hi);}
N    virtual long do_hash(const char_type* __lo, const char_type* __hi) const;
N};
N
Ntemplate <class _CharT> locale::id collate<_CharT>::id;
N
Ntemplate <class _CharT>
Ncollate<_CharT>::~collate()
N{
N}
N
Ntemplate <class _CharT>
Nint
Ncollate<_CharT>::do_compare(const char_type* __lo1, const char_type* __hi1,
N                            const char_type* __lo2, const char_type* __hi2) const
N{
N    for (; __lo2 != __hi2; ++__lo1, ++__lo2)
N    {
N        if (__lo1 == __hi1 || *__lo1 < *__lo2)
N            return -1;
N        if (*__lo2 < *__lo1)
N            return 1;
N    }
N    return __lo1 != __hi1;
N}
N
Ntemplate <class _CharT>
Nlong
Ncollate<_CharT>::do_hash(const char_type* __lo, const char_type* __hi) const
N{
N    size_t __h = 0;
N    const size_t __sr = __CHAR_BIT__ * sizeof(size_t) - 8;
X    const size_t __sr = 8 * sizeof(size_t) - 8;
N    const size_t __mask = size_t(0xF) << (__sr + 4);
N    for(const char_type* __p = __lo; __p != __hi; ++__p)
N    {
N        __h = (__h << 4) + static_cast<size_t>(*__p);
N        size_t __g = __h & __mask;
N        __h ^= __g | (__g >> __sr);
N    }
N    return static_cast<long>(__h);
N}
N
N_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS collate<char>)
Xextern template class collate<char>;
N_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS collate<wchar_t>)
Xextern template class collate<wchar_t>;
N
N// template <class CharT> class collate_byname;
N
Ntemplate <class _CharT> class _LIBCPP_TEMPLATE_VIS collate_byname;
Xtemplate <class _CharT> class  collate_byname;
N
Ntemplate <>
Nclass _LIBCPP_TYPE_VIS collate_byname<char>
Xclass  collate_byname<char>
N    : public collate<char>
N{
N    locale_t __l;
Npublic:
N    typedef char char_type;
N    typedef basic_string<char_type> string_type;
N
N    explicit collate_byname(const char* __n, size_t __refs = 0);
N    explicit collate_byname(const string& __n, size_t __refs = 0);
N
Nprotected:
N    ~collate_byname();
N    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,
N                           const char_type* __lo2, const char_type* __hi2) const;
N    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const;
N};
N
Ntemplate <>
Nclass _LIBCPP_TYPE_VIS collate_byname<wchar_t>
Xclass  collate_byname<wchar_t>
N    : public collate<wchar_t>
N{
N    locale_t __l;
Npublic:
N    typedef wchar_t char_type;
N    typedef basic_string<char_type> string_type;
N
N    explicit collate_byname(const char* __n, size_t __refs = 0);
N    explicit collate_byname(const string& __n, size_t __refs = 0);
N
Nprotected:
N    ~collate_byname();
N
N    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,
N                           const char_type* __lo2, const char_type* __hi2) const;
N    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const;
N};
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbool
Nlocale::operator()(const basic_string<_CharT, _Traits, _Allocator>& __x,
N                   const basic_string<_CharT, _Traits, _Allocator>& __y) const
N{
N    return _VSTD::use_facet<_VSTD::collate<_CharT> >(*this).compare(
X    return std::__2::use_facet<std::__2::collate<_CharT> >(*this).compare(
N                                       __x.data(), __x.data() + __x.size(),
N                                       __y.data(), __y.data() + __y.size()) < 0;
N}
N
N// template <class charT> class ctype
N
Nclass _LIBCPP_TYPE_VIS ctype_base
Xclass  ctype_base
N{
Npublic:
N#if defined(__GLIBC__)
X#if 0L
S    typedef unsigned short mask;
S    static const mask space  = _ISspace;
S    static const mask print  = _ISprint;
S    static const mask cntrl  = _IScntrl;
S    static const mask upper  = _ISupper;
S    static const mask lower  = _ISlower;
S    static const mask alpha  = _ISalpha;
S    static const mask digit  = _ISdigit;
S    static const mask punct  = _ISpunct;
S    static const mask xdigit = _ISxdigit;
S    static const mask blank  = _ISblank;
S#elif defined(_LIBCPP_MSVCRT_LIKE)
X#elif 0L
S    typedef unsigned short mask;
S    static const mask space  = _SPACE;
S    static const mask print  = _BLANK|_PUNCT|_ALPHA|_DIGIT;
S    static const mask cntrl  = _CONTROL;
S    static const mask upper  = _UPPER;
S    static const mask lower  = _LOWER;
S    static const mask alpha  = _ALPHA;
S    static const mask digit  = _DIGIT;
S    static const mask punct  = _PUNCT;
S    static const mask xdigit = _HEX;
S    static const mask blank  = _BLANK;
S# define _LIBCPP_CTYPE_MASK_IS_COMPOSITE_PRINT
S#elif defined(__APPLE__) || defined(__FreeBSD__) || defined(__EMSCRIPTEN__) || defined(__NetBSD__)
X#elif 0L || 0L || 0L || 0L
S# ifdef __APPLE__
S    typedef __uint32_t mask;
S# elif defined(__FreeBSD__)
S    typedef unsigned long mask;
S# elif defined(__EMSCRIPTEN__) || defined(__NetBSD__)
S    typedef unsigned short mask;
S# endif
S    static const mask space  = _CTYPE_S;
S    static const mask print  = _CTYPE_R;
S    static const mask cntrl  = _CTYPE_C;
S    static const mask upper  = _CTYPE_U;
S    static const mask lower  = _CTYPE_L;
S    static const mask alpha  = _CTYPE_A;
S    static const mask digit  = _CTYPE_D;
S    static const mask punct  = _CTYPE_P;
S    static const mask xdigit = _CTYPE_X;
S
S# if defined(__NetBSD__)
S    static const mask blank  = _CTYPE_BL;
S# else
S    static const mask blank  = _CTYPE_B;
S# endif
S#elif defined(__sun__) || defined(_AIX)
X#elif 0L || 0L
S    typedef unsigned int mask;
S    static const mask space  = _ISSPACE;
S    static const mask print  = _ISPRINT;
S    static const mask cntrl  = _ISCNTRL;
S    static const mask upper  = _ISUPPER;
S    static const mask lower  = _ISLOWER;
S    static const mask alpha  = _ISALPHA;
S    static const mask digit  = _ISDIGIT;
S    static const mask punct  = _ISPUNCT;
S    static const mask xdigit = _ISXDIGIT;
S    static const mask blank  = _ISBLANK;
S#elif defined(_NEWLIB_VERSION)
X#elif 0L
S    // Same type as Newlib's _ctype_ array in newlib/libc/include/ctype.h.
S    typedef char mask;
S    static const mask space  = _S;
S    static const mask print  = _P | _U | _L | _N | _B;
S    static const mask cntrl  = _C;
S    static const mask upper  = _U;
S    static const mask lower  = _L;
S    static const mask alpha  = _U | _L;
S    static const mask digit  = _N;
S    static const mask punct  = _P;
S    static const mask xdigit = _X | _N;
S    static const mask blank  = _B;
S# define _LIBCPP_CTYPE_MASK_IS_COMPOSITE_PRINT
S# define _LIBCPP_CTYPE_MASK_IS_COMPOSITE_ALPHA
S# define _LIBCPP_CTYPE_MASK_IS_COMPOSITE_XDIGIT
N#elif defined(__TI_COMPILER_VERSION__)
X#elif 1L
N    typedef unsigned char mask;
N    static const mask space  = _S_;
X    static const mask space  = ((unsigned char)0x08);
N    static const mask print  = (_B_ | _U_ | _L_ | _N_ | _P_);
X    static const mask print  = (((unsigned char)0x80) | ((unsigned char)0x01) | ((unsigned char)0x02) | ((unsigned char)0x04) | ((unsigned char)0x10));
N    static const mask cntrl  = _C_;
X    static const mask cntrl  = ((unsigned char)0x20);
N    static const mask upper  = _U_;
X    static const mask upper  = ((unsigned char)0x01);
N    static const mask lower  = _L_;
X    static const mask lower  = ((unsigned char)0x02);
N    static const mask alpha  = _U_ | _L_;
X    static const mask alpha  = ((unsigned char)0x01) | ((unsigned char)0x02);
N    static const mask digit  = _N_;
X    static const mask digit  = ((unsigned char)0x04);
N    static const mask punct  = _P_;
X    static const mask punct  = ((unsigned char)0x10);
N    static const mask xdigit = _H_;
X    static const mask xdigit = ((unsigned char)0x40);
N    static const mask blank  = _B_;
X    static const mask blank  = ((unsigned char)0x80);
N# define _LIBCPP_CTYPE_MASK_IS_COMPOSITE_PRINT
N# define _LIBCPP_CTYPE_MASK_IS_COMPOSITE_ALPHA
N#else
S    typedef unsigned long mask;
S    static const mask space  = 1<<0;
S    static const mask print  = 1<<1;
S    static const mask cntrl  = 1<<2;
S    static const mask upper  = 1<<3;
S    static const mask lower  = 1<<4;
S    static const mask alpha  = 1<<5;
S    static const mask digit  = 1<<6;
S    static const mask punct  = 1<<7;
S    static const mask xdigit = 1<<8;
S    static const mask blank  = 1<<9;
N#endif
N    static const mask alnum  = alpha | digit;
N    static const mask graph  = alnum | punct;
N
N    _LIBCPP_ALWAYS_INLINE ctype_base() {}
X    __attribute__ ((__always_inline__)) ctype_base() {}
N};
N
Ntemplate <class _CharT> class _LIBCPP_TEMPLATE_VIS ctype;
Xtemplate <class _CharT> class  ctype;
N
Ntemplate <>
Nclass _LIBCPP_TYPE_VIS ctype<wchar_t>
Xclass  ctype<wchar_t>
N    : public locale::facet,
N      public ctype_base
N{
Npublic:
N    typedef wchar_t char_type;
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    explicit ctype(size_t __refs = 0)
N        : locale::facet(__refs) {}
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    bool is(mask __m, char_type __c) const
N    {
N        return do_is(__m, __c);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    const char_type* is(const char_type* __low, const char_type* __high, mask* __vec) const
N    {
N        return do_is(__low, __high, __vec);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    const char_type* scan_is(mask __m, const char_type* __low, const char_type* __high) const
N    {
N        return do_scan_is(__m, __low, __high);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    const char_type* scan_not(mask __m, const char_type* __low, const char_type* __high) const
N    {
N        return do_scan_not(__m, __low, __high);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    char_type toupper(char_type __c) const
N    {
N        return do_toupper(__c);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    const char_type* toupper(char_type* __low, const char_type* __high) const
N    {
N        return do_toupper(__low, __high);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    char_type tolower(char_type __c) const
N    {
N        return do_tolower(__c);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    const char_type* tolower(char_type* __low, const char_type* __high) const
N    {
N        return do_tolower(__low, __high);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    char_type widen(char __c) const
N    {
N        return do_widen(__c);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    const char* widen(const char* __low, const char* __high, char_type* __to) const
N    {
N        return do_widen(__low, __high, __to);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    char narrow(char_type __c, char __dfault) const
N    {
N        return do_narrow(__c, __dfault);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    const char_type* narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const
N    {
N        return do_narrow(__low, __high, __dfault, __to);
N    }
N
N    static _DATA_ACCESS locale::id id;
X    static  locale::id id;
N
Nprotected:
N    ~ctype();
N    virtual bool do_is(mask __m, char_type __c) const;
N    virtual const char_type* do_is(const char_type* __low, const char_type* __high, mask* __vec) const;
N    virtual const char_type* do_scan_is(mask __m, const char_type* __low, const char_type* __high) const;
N    virtual const char_type* do_scan_not(mask __m, const char_type* __low, const char_type* __high) const;
N    virtual char_type do_toupper(char_type) const;
N    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;
N    virtual char_type do_tolower(char_type) const;
N    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;
N    virtual char_type do_widen(char) const;
N    virtual const char* do_widen(const char* __low, const char* __high, char_type* __dest) const;
N    virtual char do_narrow(char_type, char __dfault) const;
N    virtual const char_type* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __dest) const;
N};
N
Ntemplate <>
Nclass _LIBCPP_TYPE_VIS ctype<char>
Xclass  ctype<char>
N    : public locale::facet, public ctype_base
N{
N    const mask* __tab_;
N    bool        __del_;
Npublic:
N    typedef char char_type;
N
N    explicit ctype(const mask* __tab = 0, bool __del = false, size_t __refs = 0);
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    bool is(mask __m, char_type __c) const
N    {
N        return isascii(__c) ? (__tab_[static_cast<int>(__c)] & __m) !=0 : false;
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    const char_type* is(const char_type* __low, const char_type* __high, mask* __vec) const
N    {
N        for (; __low != __high; ++__low, ++__vec)
N            *__vec = isascii(*__low) ? __tab_[static_cast<int>(*__low)] : 0;
N        return __low;
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    const char_type* scan_is (mask __m, const char_type* __low, const char_type* __high) const
N    {
N        for (; __low != __high; ++__low)
N            if (isascii(*__low) && (__tab_[static_cast<int>(*__low)] & __m))
N                break;
N        return __low;
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    const char_type* scan_not(mask __m, const char_type* __low, const char_type* __high) const
N    {
N        for (; __low != __high; ++__low)
N            if (!(isascii(*__low) && (__tab_[static_cast<int>(*__low)] & __m)))
N                break;
N        return __low;
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    char_type toupper(char_type __c) const
N    {
N        return do_toupper(__c);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    const char_type* toupper(char_type* __low, const char_type* __high) const
N    {
N        return do_toupper(__low, __high);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    char_type tolower(char_type __c) const
N    {
N        return do_tolower(__c);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    const char_type* tolower(char_type* __low, const char_type* __high) const
N    {
N        return do_tolower(__low, __high);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    char_type widen(char __c) const
N    {
N        return do_widen(__c);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    const char* widen(const char* __low, const char* __high, char_type* __to) const
N    {
N        return do_widen(__low, __high, __to);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    char narrow(char_type __c, char __dfault) const
N    {
N        return do_narrow(__c, __dfault);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    const char* narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const
N    {
N        return do_narrow(__low, __high, __dfault, __to);
N    }
N
N    static _DATA_ACCESS locale::id id;
X    static  locale::id id;
N
N#ifdef _CACHED_RUNES
S    static const size_t table_size = _CACHED_RUNES;
N#else
N    static const size_t table_size = 256;  // FIXME: Don't hardcode this.
N#endif
N    _LIBCPP_ALWAYS_INLINE const mask* table() const  _NOEXCEPT {return __tab_;}
X    __attribute__ ((__always_inline__)) const mask* table() const  noexcept {return __tab_;}
N    static const mask* classic_table()  _NOEXCEPT;
X    static const mask* classic_table()  noexcept;
N#if defined(__GLIBC__) || defined(__EMSCRIPTEN__)
X#if 0L || 0L
S    static const int* __classic_upper_table() _NOEXCEPT;
S    static const int* __classic_lower_table() _NOEXCEPT;
N#endif
N#if defined(__NetBSD__)
X#if 0L
S    static const short* __classic_upper_table() _NOEXCEPT;
S    static const short* __classic_lower_table() _NOEXCEPT;
N#endif
N
Nprotected:
N    ~ctype();
N    virtual char_type do_toupper(char_type __c) const;
N    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;
N    virtual char_type do_tolower(char_type __c) const;
N    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;
N    virtual char_type do_widen(char __c) const;
N    virtual const char* do_widen(const char* __low, const char* __high, char_type* __to) const;
N    virtual char do_narrow(char_type __c, char __dfault) const;
N    virtual const char* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const;
N};
N
N// template <class CharT> class ctype_byname;
N
Ntemplate <class _CharT> class _LIBCPP_TEMPLATE_VIS ctype_byname;
Xtemplate <class _CharT> class  ctype_byname;
N
Ntemplate <>
Nclass _LIBCPP_TYPE_VIS ctype_byname<char>
Xclass  ctype_byname<char>
N    : public ctype<char>
N{
N    locale_t __l;
N
Npublic:
N    explicit ctype_byname(const char*, size_t = 0);
N    explicit ctype_byname(const string&, size_t = 0);
N
Nprotected:
N    ~ctype_byname();
N    virtual char_type do_toupper(char_type) const;
N    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;
N    virtual char_type do_tolower(char_type) const;
N    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;
N};
N
Ntemplate <>
Nclass _LIBCPP_TYPE_VIS ctype_byname<wchar_t>
Xclass  ctype_byname<wchar_t>
N    : public ctype<wchar_t>
N{
N    locale_t __l;
N
Npublic:
N    explicit ctype_byname(const char*, size_t = 0);
N    explicit ctype_byname(const string&, size_t = 0);
N
Nprotected:
N    ~ctype_byname();
N    virtual bool do_is(mask __m, char_type __c) const;
N    virtual const char_type* do_is(const char_type* __low, const char_type* __high, mask* __vec) const;
N    virtual const char_type* do_scan_is(mask __m, const char_type* __low, const char_type* __high) const;
N    virtual const char_type* do_scan_not(mask __m, const char_type* __low, const char_type* __high) const;
N    virtual char_type do_toupper(char_type) const;
N    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;
N    virtual char_type do_tolower(char_type) const;
N    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;
N    virtual char_type do_widen(char) const;
N    virtual const char* do_widen(const char* __low, const char* __high, char_type* __dest) const;
N    virtual char do_narrow(char_type, char __dfault) const;
N    virtual const char_type* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __dest) const;
N};
N
Ntemplate <class _CharT>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Nisspace(_CharT __c, const locale& __loc)
N{
N    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c);
N}
N
Ntemplate <class _CharT>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Nisprint(_CharT __c, const locale& __loc)
N{
N    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c);
N}
N
Ntemplate <class _CharT>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Niscntrl(_CharT __c, const locale& __loc)
N{
N    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c);
N}
N
Ntemplate <class _CharT>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Nisupper(_CharT __c, const locale& __loc)
N{
N    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c);
N}
N
Ntemplate <class _CharT>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Nislower(_CharT __c, const locale& __loc)
N{
N    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c);
N}
N
Ntemplate <class _CharT>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Nisalpha(_CharT __c, const locale& __loc)
N{
N    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c);
N}
N
Ntemplate <class _CharT>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Nisdigit(_CharT __c, const locale& __loc)
N{
N    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c);
N}
N
Ntemplate <class _CharT>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Nispunct(_CharT __c, const locale& __loc)
N{
N    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c);
N}
N
Ntemplate <class _CharT>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Nisxdigit(_CharT __c, const locale& __loc)
N{
N    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c);
N}
N
Ntemplate <class _CharT>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Nisalnum(_CharT __c, const locale& __loc)
N{
N    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c);
N}
N
Ntemplate <class _CharT>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Nisgraph(_CharT __c, const locale& __loc)
N{
N    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c);
N}
N
Ntemplate <class _CharT>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_CharT
Ntoupper(_CharT __c, const locale& __loc)
N{
N    return use_facet<ctype<_CharT> >(__loc).toupper(__c);
N}
N
Ntemplate <class _CharT>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_CharT
Ntolower(_CharT __c, const locale& __loc)
N{
N    return use_facet<ctype<_CharT> >(__loc).tolower(__c);
N}
N
N// codecvt_base
N
Nclass _LIBCPP_TYPE_VIS codecvt_base
Xclass  codecvt_base
N{
Npublic:
N    _LIBCPP_ALWAYS_INLINE codecvt_base() {}
X    __attribute__ ((__always_inline__)) codecvt_base() {}
N    enum __attribute__((packed)) result {ok, partial, error, noconv};
N};
N
N// template <class internT, class externT, class stateT> class codecvt;
N
Ntemplate <class _InternT, class _ExternT, class _StateT> class _LIBCPP_TEMPLATE_VIS codecvt;
Xtemplate <class _InternT, class _ExternT, class _StateT> class  codecvt;
N
N// template <> class codecvt<char, char, mbstate_t>
N
Ntemplate <>
Nclass _LIBCPP_TYPE_VIS codecvt<char, char, mbstate_t>
Xclass  codecvt<char, char, mbstate_t>
N    : public locale::facet,
N      public codecvt_base
N{
Npublic:
N    typedef char      intern_type;
N    typedef char      extern_type;
N    typedef mbstate_t state_type;
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    explicit codecvt(size_t __refs = 0)
N        : locale::facet(__refs) {}
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    result out(state_type& __st,
N               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
N               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
N    {
N        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    result unshift(state_type& __st,
N                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
N    {
N        return do_unshift(__st, __to, __to_end, __to_nxt);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    result in(state_type& __st,
N              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
N              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const
N    {
N        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    int encoding() const  _NOEXCEPT
X    int encoding() const  noexcept
N    {
N        return do_encoding();
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    bool always_noconv() const  _NOEXCEPT
X    bool always_noconv() const  noexcept
N    {
N        return do_always_noconv();
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const
N    {
N        return do_length(__st, __frm, __end, __mx);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    int max_length() const  _NOEXCEPT
X    int max_length() const  noexcept
N    {
N        return do_max_length();
N    }
N
N    static _DATA_ACCESS locale::id id;
X    static  locale::id id;
N
Nprotected:
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    explicit codecvt(const char*, size_t __refs = 0)
N        : locale::facet(__refs) {}
N
N    ~codecvt();
N
N    virtual result do_out(state_type& __st,
N                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
N                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
N    virtual result do_in(state_type& __st,
N                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
N                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;
N    virtual result do_unshift(state_type& __st,
N                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
N    virtual int do_encoding() const  _NOEXCEPT;
X    virtual int do_encoding() const  noexcept;
N    virtual bool do_always_noconv() const  _NOEXCEPT;
X    virtual bool do_always_noconv() const  noexcept;
N    virtual int do_length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const;
N    virtual int do_max_length() const  _NOEXCEPT;
X    virtual int do_max_length() const  noexcept;
N};
N
N// template <> class codecvt<wchar_t, char, mbstate_t>
N
Ntemplate <>
Nclass _LIBCPP_TYPE_VIS codecvt<wchar_t, char, mbstate_t>
Xclass  codecvt<wchar_t, char, mbstate_t>
N    : public locale::facet,
N      public codecvt_base
N{
N    locale_t __l;
Npublic:
N    typedef wchar_t   intern_type;
N    typedef char      extern_type;
N    typedef mbstate_t state_type;
N
N    explicit codecvt(size_t __refs = 0);
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    result out(state_type& __st,
N               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
N               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
N    {
N        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    result unshift(state_type& __st,
N                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
N    {
N        return do_unshift(__st, __to, __to_end, __to_nxt);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    result in(state_type& __st,
N              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
N              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const
N    {
N        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    int encoding() const  _NOEXCEPT
X    int encoding() const  noexcept
N    {
N        return do_encoding();
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    bool always_noconv() const  _NOEXCEPT
X    bool always_noconv() const  noexcept
N    {
N        return do_always_noconv();
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const
N    {
N        return do_length(__st, __frm, __end, __mx);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    int max_length() const  _NOEXCEPT
X    int max_length() const  noexcept
N    {
N        return do_max_length();
N    }
N
N    static _DATA_ACCESS locale::id id;
X    static  locale::id id;
N
Nprotected:
N    explicit codecvt(const char*, size_t __refs = 0);
N
N    ~codecvt();
N
N    virtual result do_out(state_type& __st,
N                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
N                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
N    virtual result do_in(state_type& __st,
N                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
N                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;
N    virtual result do_unshift(state_type& __st,
N                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
N    virtual int do_encoding() const  _NOEXCEPT;
X    virtual int do_encoding() const  noexcept;
N    virtual bool do_always_noconv() const  _NOEXCEPT;
X    virtual bool do_always_noconv() const  noexcept;
N    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;
N    virtual int do_max_length() const  _NOEXCEPT;
X    virtual int do_max_length() const  noexcept;
N};
N
N// template <> class codecvt<char16_t, char, mbstate_t>
N
Ntemplate <>
Nclass _LIBCPP_TYPE_VIS codecvt<char16_t, char, mbstate_t>
Xclass  codecvt<char16_t, char, mbstate_t>
N    : public locale::facet,
N      public codecvt_base
N{
Npublic:
N    typedef char16_t  intern_type;
N    typedef char      extern_type;
N    typedef mbstate_t state_type;
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    explicit codecvt(size_t __refs = 0)
N        : locale::facet(__refs) {}
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    result out(state_type& __st,
N               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
N               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
N    {
N        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    result unshift(state_type& __st,
N                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
N    {
N        return do_unshift(__st, __to, __to_end, __to_nxt);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    result in(state_type& __st,
N              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
N              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const
N    {
N        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    int encoding() const  _NOEXCEPT
X    int encoding() const  noexcept
N    {
N        return do_encoding();
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    bool always_noconv() const  _NOEXCEPT
X    bool always_noconv() const  noexcept
N    {
N        return do_always_noconv();
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const
N    {
N        return do_length(__st, __frm, __end, __mx);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    int max_length() const  _NOEXCEPT
X    int max_length() const  noexcept
N    {
N        return do_max_length();
N    }
N
N    static _DATA_ACCESS locale::id id;
X    static  locale::id id;
N
Nprotected:
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    explicit codecvt(const char*, size_t __refs = 0)
N        : locale::facet(__refs) {}
N
N    ~codecvt();
N
N    virtual result do_out(state_type& __st,
N                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
N                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
N    virtual result do_in(state_type& __st,
N                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
N                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;
N    virtual result do_unshift(state_type& __st,
N                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
N    virtual int do_encoding() const  _NOEXCEPT;
X    virtual int do_encoding() const  noexcept;
N    virtual bool do_always_noconv() const  _NOEXCEPT;
X    virtual bool do_always_noconv() const  noexcept;
N    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;
N    virtual int do_max_length() const  _NOEXCEPT;
X    virtual int do_max_length() const  noexcept;
N};
N
N// template <> class codecvt<char32_t, char, mbstate_t>
N
Ntemplate <>
Nclass _LIBCPP_TYPE_VIS codecvt<char32_t, char, mbstate_t>
Xclass  codecvt<char32_t, char, mbstate_t>
N    : public locale::facet,
N      public codecvt_base
N{
Npublic:
N    typedef char32_t  intern_type;
N    typedef char      extern_type;
N    typedef mbstate_t state_type;
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    explicit codecvt(size_t __refs = 0)
N        : locale::facet(__refs) {}
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    result out(state_type& __st,
N               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
N               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
N    {
N        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    result unshift(state_type& __st,
N                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
N    {
N        return do_unshift(__st, __to, __to_end, __to_nxt);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    result in(state_type& __st,
N              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
N              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const
N    {
N        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    int encoding() const  _NOEXCEPT
X    int encoding() const  noexcept
N    {
N        return do_encoding();
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    bool always_noconv() const  _NOEXCEPT
X    bool always_noconv() const  noexcept
N    {
N        return do_always_noconv();
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const
N    {
N        return do_length(__st, __frm, __end, __mx);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    int max_length() const  _NOEXCEPT
X    int max_length() const  noexcept
N    {
N        return do_max_length();
N    }
N
N    static _DATA_ACCESS locale::id id;
X    static  locale::id id;
N
Nprotected:
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    explicit codecvt(const char*, size_t __refs = 0)
N        : locale::facet(__refs) {}
N
N    ~codecvt();
N
N    virtual result do_out(state_type& __st,
N                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
N                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
N    virtual result do_in(state_type& __st,
N                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
N                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;
N    virtual result do_unshift(state_type& __st,
N                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
N    virtual int do_encoding() const  _NOEXCEPT;
X    virtual int do_encoding() const  noexcept;
N    virtual bool do_always_noconv() const  _NOEXCEPT;
X    virtual bool do_always_noconv() const  noexcept;
N    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;
N    virtual int do_max_length() const  _NOEXCEPT;
X    virtual int do_max_length() const  noexcept;
N};
N
N// template <class _InternT, class _ExternT, class _StateT> class codecvt_byname
N
Ntemplate <class _InternT, class _ExternT, class _StateT>
Nclass _LIBCPP_TEMPLATE_VIS codecvt_byname
Xclass  codecvt_byname
N    : public codecvt<_InternT, _ExternT, _StateT>
N{
Npublic:
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    explicit codecvt_byname(const char* __nm, size_t __refs = 0)
N        : codecvt<_InternT, _ExternT, _StateT>(__nm, __refs) {}
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    explicit codecvt_byname(const string& __nm, size_t __refs = 0)
N        : codecvt<_InternT, _ExternT, _StateT>(__nm.c_str(), __refs) {}
Nprotected:
N    ~codecvt_byname();
N};
N
Ntemplate <class _InternT, class _ExternT, class _StateT>
Ncodecvt_byname<_InternT, _ExternT, _StateT>::~codecvt_byname()
N{
N}
N
N_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS codecvt_byname<char, char, mbstate_t>)
Xextern template class codecvt_byname<char, char, mbstate_t>;
N_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS codecvt_byname<wchar_t, char, mbstate_t>)
Xextern template class codecvt_byname<wchar_t, char, mbstate_t>;
N_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS codecvt_byname<char16_t, char, mbstate_t>)
Xextern template class codecvt_byname<char16_t, char, mbstate_t>;
N_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS codecvt_byname<char32_t, char, mbstate_t>)
Xextern template class codecvt_byname<char32_t, char, mbstate_t>;
N
N_LIBCPP_NORETURN _LIBCPP_FUNC_VIS void __throw_runtime_error(const char*);
X[[noreturn]]  void __throw_runtime_error(const char*);
N
Ntemplate <size_t _Np>
Nstruct __narrow_to_utf8
N{
N    template <class _OutputIterator, class _CharT>
N    _OutputIterator
N    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const;
N};
N
Ntemplate <>
Nstruct __narrow_to_utf8<8>
N{
N    template <class _OutputIterator, class _CharT>
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    _OutputIterator
N    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const
N    {
N        for (; __wb < __we; ++__wb, ++__s)
N            *__s = *__wb;
N        return __s;
N    }
N};
N
Ntemplate <>
Nstruct __narrow_to_utf8<16>
N    : public codecvt<char16_t, char, mbstate_t>
N{
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    __narrow_to_utf8() : codecvt<char16_t, char, mbstate_t>(1) {}
N
N    ~__narrow_to_utf8();
N
N    template <class _OutputIterator, class _CharT>
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    _OutputIterator
N    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const
N    {
N        result __r = ok;
N        mbstate_t __mb;
N        while (__wb < __we && __r != error)
N        {
N            const int __sz = 32;
N            char __buf[__sz];
N            char* __bn;
N            const char16_t* __wn = (const char16_t*)__wb;
N            __r = do_out(__mb, (const char16_t*)__wb, (const char16_t*)__we, __wn,
N                         __buf, __buf+__sz, __bn);
N            if (__r == codecvt_base::error || __wn == (const char16_t*)__wb)
N                __throw_runtime_error("locale not supported");
N            for (const char* __p = __buf; __p < __bn; ++__p, ++__s)
N                *__s = *__p;
N            __wb = (const _CharT*)__wn;
N        }
N        return __s;
N    }
N};
N
Ntemplate <>
Nstruct __narrow_to_utf8<32>
N    : public codecvt<char32_t, char, mbstate_t>
N{
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    __narrow_to_utf8() : codecvt<char32_t, char, mbstate_t>(1) {}
N
N    ~__narrow_to_utf8();
N
N    template <class _OutputIterator, class _CharT>
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    _OutputIterator
N    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const
N    {
N        result __r = ok;
N        mbstate_t __mb;
N        while (__wb < __we && __r != error)
N        {
N            const int __sz = 32;
N            char __buf[__sz];
N            char* __bn;
N            const char32_t* __wn = (const char32_t*)__wb;
N            __r = do_out(__mb, (const char32_t*)__wb, (const char32_t*)__we, __wn,
N                         __buf, __buf+__sz, __bn);
N            if (__r == codecvt_base::error || __wn == (const char32_t*)__wb)
N                __throw_runtime_error("locale not supported");
N            for (const char* __p = __buf; __p < __bn; ++__p, ++__s)
N                *__s = *__p;
N            __wb = (const _CharT*)__wn;
N        }
N        return __s;
N    }
N};
N
Ntemplate <size_t _Np>
Nstruct __widen_from_utf8
N{
N    template <class _OutputIterator>
N    _OutputIterator
N    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const;
N};
N
Ntemplate <>
Nstruct __widen_from_utf8<8>
N{
N    template <class _OutputIterator>
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    _OutputIterator
N    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const
N    {
N        for (; __nb < __ne; ++__nb, ++__s)
N            *__s = *__nb;
N        return __s;
N    }
N};
N
Ntemplate <>
Nstruct __widen_from_utf8<16>
N    : public codecvt<char16_t, char, mbstate_t>
N{
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    __widen_from_utf8() : codecvt<char16_t, char, mbstate_t>(1) {}
N
N    ~__widen_from_utf8();
N
N    template <class _OutputIterator>
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    _OutputIterator
N    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const
N    {
N        result __r = ok;
N        mbstate_t __mb;
N        while (__nb < __ne && __r != error)
N        {
N            const int __sz = 32;
N            char16_t __buf[__sz];
N            char16_t* __bn;
N            const char* __nn = __nb;
N            __r = do_in(__mb, __nb, __ne - __nb > __sz ? __nb+__sz : __ne, __nn,
N                        __buf, __buf+__sz, __bn);
N            if (__r == codecvt_base::error || __nn == __nb)
N                __throw_runtime_error("locale not supported");
N            for (const char16_t* __p = __buf; __p < __bn; ++__p, ++__s)
N                *__s = (wchar_t)*__p;
N            __nb = __nn;
N        }
N        return __s;
N    }
N};
N
Ntemplate <>
Nstruct __widen_from_utf8<32>
N    : public codecvt<char32_t, char, mbstate_t>
N{
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    __widen_from_utf8() : codecvt<char32_t, char, mbstate_t>(1) {}
N
N    ~__widen_from_utf8();
N
N    template <class _OutputIterator>
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    _OutputIterator
N    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const
N    {
N        result __r = ok;
N        mbstate_t __mb;
N        while (__nb < __ne && __r != error)
N        {
N            const int __sz = 32;
N            char32_t __buf[__sz];
N            char32_t* __bn;
N            const char* __nn = __nb;
N            __r = do_in(__mb, __nb, __ne - __nb > __sz ? __nb+__sz : __ne, __nn,
N                        __buf, __buf+__sz, __bn);
N            if (__r == codecvt_base::error || __nn == __nb)
N                __throw_runtime_error("locale not supported");
N            for (const char32_t* __p = __buf; __p < __bn; ++__p, ++__s)
N                *__s = (wchar_t)*__p;
N            __nb = __nn;
N        }
N        return __s;
N    }
N};
N
N// template <class charT> class numpunct
N
Ntemplate <class _CharT> class _LIBCPP_TEMPLATE_VIS numpunct;
Xtemplate <class _CharT> class  numpunct;
N
Ntemplate <>
Nclass _LIBCPP_TYPE_VIS numpunct<char>
Xclass  numpunct<char>
N    : public locale::facet
N{
Npublic:
N    typedef char char_type;
N    typedef basic_string<char_type> string_type;
N
N    explicit numpunct(size_t __refs = 0);
N
N    _LIBCPP_ALWAYS_INLINE char_type decimal_point() const {return do_decimal_point();}
X    __attribute__ ((__always_inline__)) char_type decimal_point() const {return do_decimal_point();}
N    _LIBCPP_ALWAYS_INLINE char_type thousands_sep() const {return do_thousands_sep();}
X    __attribute__ ((__always_inline__)) char_type thousands_sep() const {return do_thousands_sep();}
N    _LIBCPP_ALWAYS_INLINE string grouping() const         {return do_grouping();}
X    __attribute__ ((__always_inline__)) string grouping() const         {return do_grouping();}
N    _LIBCPP_ALWAYS_INLINE string_type truename() const    {return do_truename();}
X    __attribute__ ((__always_inline__)) string_type truename() const    {return do_truename();}
N    _LIBCPP_ALWAYS_INLINE string_type falsename() const   {return do_falsename();}
X    __attribute__ ((__always_inline__)) string_type falsename() const   {return do_falsename();}
N
N    static _DATA_ACCESS locale::id id;
X    static  locale::id id;
N
Nprotected:
N    ~numpunct();
N    virtual char_type do_decimal_point() const;
N    virtual char_type do_thousands_sep() const;
N    virtual string do_grouping() const;
N    virtual string_type do_truename() const;
N    virtual string_type do_falsename() const;
N
N    char_type __decimal_point_;
N    char_type __thousands_sep_;
N    string __grouping_;
N};
N
Ntemplate <>
Nclass _LIBCPP_TYPE_VIS numpunct<wchar_t>
Xclass  numpunct<wchar_t>
N    : public locale::facet
N{
Npublic:
N    typedef wchar_t char_type;
N    typedef basic_string<char_type> string_type;
N
N    explicit numpunct(size_t __refs = 0);
N
N    _LIBCPP_ALWAYS_INLINE char_type decimal_point() const {return do_decimal_point();}
X    __attribute__ ((__always_inline__)) char_type decimal_point() const {return do_decimal_point();}
N    _LIBCPP_ALWAYS_INLINE char_type thousands_sep() const {return do_thousands_sep();}
X    __attribute__ ((__always_inline__)) char_type thousands_sep() const {return do_thousands_sep();}
N    _LIBCPP_ALWAYS_INLINE string grouping() const         {return do_grouping();}
X    __attribute__ ((__always_inline__)) string grouping() const         {return do_grouping();}
N    _LIBCPP_ALWAYS_INLINE string_type truename() const    {return do_truename();}
X    __attribute__ ((__always_inline__)) string_type truename() const    {return do_truename();}
N    _LIBCPP_ALWAYS_INLINE string_type falsename() const   {return do_falsename();}
X    __attribute__ ((__always_inline__)) string_type falsename() const   {return do_falsename();}
N
N    static _DATA_ACCESS locale::id id;
X    static  locale::id id;
N
Nprotected:
N    ~numpunct();
N    virtual char_type do_decimal_point() const;
N    virtual char_type do_thousands_sep() const;
N    virtual string do_grouping() const;
N    virtual string_type do_truename() const;
N    virtual string_type do_falsename() const;
N
N    char_type __decimal_point_;
N    char_type __thousands_sep_;
N    string __grouping_;
N};
N
N// template <class charT> class numpunct_byname
N
Ntemplate <class _CharT> class _LIBCPP_TEMPLATE_VIS numpunct_byname;
Xtemplate <class _CharT> class  numpunct_byname;
N
Ntemplate <>
Nclass _LIBCPP_TYPE_VIS numpunct_byname<char>
Xclass  numpunct_byname<char>
N: public numpunct<char>
N{
Npublic:
N    typedef char char_type;
N    typedef basic_string<char_type> string_type;
N
N    explicit numpunct_byname(const char* __nm, size_t __refs = 0);
N    explicit numpunct_byname(const string& __nm, size_t __refs = 0);
N
Nprotected:
N    ~numpunct_byname();
N
Nprivate:
N    void __init(const char*);
N};
N
Ntemplate <>
Nclass _LIBCPP_TYPE_VIS numpunct_byname<wchar_t>
Xclass  numpunct_byname<wchar_t>
N: public numpunct<wchar_t>
N{
Npublic:
N    typedef wchar_t char_type;
N    typedef basic_string<char_type> string_type;
N
N    explicit numpunct_byname(const char* __nm, size_t __refs = 0);
N    explicit numpunct_byname(const string& __nm, size_t __refs = 0);
N
Nprotected:
N    ~numpunct_byname();
N
Nprivate:
N    void __init(const char*);
N};
N
N_LIBCPP_END_NAMESPACE_STD
X} }
N
N#endif  // _LIBCPP___LOCALE
L 217 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/ios" 2
N#include <system_error>
N
N#if !defined(_LIBCPP_HAS_NO_ATOMIC_HEADER)
X#if !0L
N#include <atomic>     // for __xindex_
N#endif
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N_LIBCPP_BEGIN_NAMESPACE_STD
Xnamespace std { inline namespace __2 {
N
Ntypedef ptrdiff_t streamsize;
N
Nclass _LIBCPP_TYPE_VIS ios_base
Xclass  ios_base
N{
Npublic:
N    class _LIBCPP_EXCEPTION_ABI failure;
X    class  failure;
N
N    typedef unsigned int fmtflags;
N    static _DATA_ACCESS const fmtflags boolalpha   = 0x0001;
X    static  const fmtflags boolalpha   = 0x0001;
N    static _DATA_ACCESS const fmtflags dec         = 0x0002;
X    static  const fmtflags dec         = 0x0002;
N    static _DATA_ACCESS const fmtflags fixed       = 0x0004;
X    static  const fmtflags fixed       = 0x0004;
N    static _DATA_ACCESS const fmtflags hex         = 0x0008;
X    static  const fmtflags hex         = 0x0008;
N    static _DATA_ACCESS const fmtflags internal    = 0x0010;
X    static  const fmtflags internal    = 0x0010;
N    static _DATA_ACCESS const fmtflags left        = 0x0020;
X    static  const fmtflags left        = 0x0020;
N    static _DATA_ACCESS const fmtflags oct         = 0x0040;
X    static  const fmtflags oct         = 0x0040;
N    static _DATA_ACCESS const fmtflags right       = 0x0080;
X    static  const fmtflags right       = 0x0080;
N    static _DATA_ACCESS const fmtflags scientific  = 0x0100;
X    static  const fmtflags scientific  = 0x0100;
N    static _DATA_ACCESS const fmtflags showbase    = 0x0200;
X    static  const fmtflags showbase    = 0x0200;
N    static _DATA_ACCESS const fmtflags showpoint   = 0x0400;
X    static  const fmtflags showpoint   = 0x0400;
N    static _DATA_ACCESS const fmtflags showpos     = 0x0800;
X    static  const fmtflags showpos     = 0x0800;
N    static _DATA_ACCESS const fmtflags skipws      = 0x1000;
X    static  const fmtflags skipws      = 0x1000;
N    static _DATA_ACCESS const fmtflags unitbuf     = 0x2000;
X    static  const fmtflags unitbuf     = 0x2000;
N    static _DATA_ACCESS const fmtflags uppercase   = 0x4000;
X    static  const fmtflags uppercase   = 0x4000;
N    static _DATA_ACCESS const fmtflags adjustfield = left | right | internal;
X    static  const fmtflags adjustfield = left | right | internal;
N    static _DATA_ACCESS const fmtflags basefield   = dec | oct | hex;
X    static  const fmtflags basefield   = dec | oct | hex;
N    static _DATA_ACCESS const fmtflags floatfield  = scientific | fixed;
X    static  const fmtflags floatfield  = scientific | fixed;
N
N    typedef unsigned int iostate;
N    static _DATA_ACCESS const iostate badbit  = 0x1;
X    static  const iostate badbit  = 0x1;
N    static _DATA_ACCESS const iostate eofbit  = 0x2;
X    static  const iostate eofbit  = 0x2;
N    static _DATA_ACCESS const iostate failbit = 0x4;
X    static  const iostate failbit = 0x4;
N    static _DATA_ACCESS const iostate goodbit = 0x0;
X    static  const iostate goodbit = 0x0;
N
N    typedef unsigned int openmode;
N    static _DATA_ACCESS const openmode app    = 0x01;
X    static  const openmode app    = 0x01;
N    static _DATA_ACCESS const openmode ate    = 0x02;
X    static  const openmode ate    = 0x02;
N    static _DATA_ACCESS const openmode binary = 0x04;
X    static  const openmode binary = 0x04;
N    static _DATA_ACCESS const openmode in     = 0x08;
X    static  const openmode in     = 0x08;
N    static _DATA_ACCESS const openmode out    = 0x10;
X    static  const openmode out    = 0x10;
N    static _DATA_ACCESS const openmode trunc  = 0x20;
X    static  const openmode trunc  = 0x20;
N
N    enum __attribute__((packed)) seekdir {beg, cur, end};
N
N#if _LIBCPP_STD_VER <= 14
X#if 14 <= 14
N    typedef iostate      io_state;
N    typedef openmode     open_mode;
N    typedef seekdir      seek_dir;
N
N    typedef _VSTD::streamoff streamoff;
X    typedef std::__2::streamoff streamoff;
N    typedef _VSTD::streampos streampos;
X    typedef std::__2::streampos streampos;
N#endif
N
N    class _LIBCPP_TYPE_VIS Init;
X    class  Init;
N
N    // 27.5.2.2 fmtflags state:
N    _LIBCPP_INLINE_VISIBILITY fmtflags flags() const;
X    __attribute__ ((__always_inline__)) fmtflags flags() const;
N    _LIBCPP_INLINE_VISIBILITY fmtflags flags(fmtflags __fmtfl);
X    __attribute__ ((__always_inline__)) fmtflags flags(fmtflags __fmtfl);
N    _LIBCPP_INLINE_VISIBILITY fmtflags setf(fmtflags __fmtfl);
X    __attribute__ ((__always_inline__)) fmtflags setf(fmtflags __fmtfl);
N    _LIBCPP_INLINE_VISIBILITY fmtflags setf(fmtflags __fmtfl, fmtflags __mask);
X    __attribute__ ((__always_inline__)) fmtflags setf(fmtflags __fmtfl, fmtflags __mask);
N    _LIBCPP_INLINE_VISIBILITY void unsetf(fmtflags __mask);
X    __attribute__ ((__always_inline__)) void unsetf(fmtflags __mask);
N
N    _LIBCPP_INLINE_VISIBILITY streamsize precision() const;
X    __attribute__ ((__always_inline__)) streamsize precision() const;
N    _LIBCPP_INLINE_VISIBILITY streamsize precision(streamsize __prec);
X    __attribute__ ((__always_inline__)) streamsize precision(streamsize __prec);
N    _LIBCPP_INLINE_VISIBILITY streamsize width() const;
X    __attribute__ ((__always_inline__)) streamsize width() const;
N    _LIBCPP_INLINE_VISIBILITY streamsize width(streamsize __wide);
X    __attribute__ ((__always_inline__)) streamsize width(streamsize __wide);
N
N    // 27.5.2.3 locales:
N    locale imbue(const locale& __loc);
N    locale getloc() const;
N
N    // 27.5.2.5 storage:
N    static int xalloc();
N    long& iword(int __index);
N    void*& pword(int __index);
N
N    // destructor
N    virtual ~ios_base();
N
N    // 27.5.2.6 callbacks;
N    enum __attribute__((packed)) event { erase_event, imbue_event, copyfmt_event };
N    typedef void (*event_callback)(event, ios_base&, int __index);
N    void register_callback(event_callback __fn, int __index);
N
Nprivate:
N    ios_base(const ios_base&); // = delete;
N    ios_base& operator=(const ios_base&); // = delete;
N
Npublic:
N    static bool sync_with_stdio(bool __sync = true);
N
N    _LIBCPP_INLINE_VISIBILITY iostate rdstate() const;
X    __attribute__ ((__always_inline__)) iostate rdstate() const;
N    void clear(iostate __state = goodbit);
N    _LIBCPP_INLINE_VISIBILITY void setstate(iostate __state);
X    __attribute__ ((__always_inline__)) void setstate(iostate __state);
N
N    _LIBCPP_INLINE_VISIBILITY bool good() const;
X    __attribute__ ((__always_inline__)) bool good() const;
N    _LIBCPP_INLINE_VISIBILITY bool eof() const;
X    __attribute__ ((__always_inline__)) bool eof() const;
N    _LIBCPP_INLINE_VISIBILITY bool fail() const;
X    __attribute__ ((__always_inline__)) bool fail() const;
N    _LIBCPP_INLINE_VISIBILITY bool bad() const;
X    __attribute__ ((__always_inline__)) bool bad() const;
N
N    _LIBCPP_INLINE_VISIBILITY iostate exceptions() const;
X    __attribute__ ((__always_inline__)) iostate exceptions() const;
N    _LIBCPP_INLINE_VISIBILITY void exceptions(iostate __iostate);
X    __attribute__ ((__always_inline__)) void exceptions(iostate __iostate);
N
N    void __set_badbit_and_consider_rethrow();
N    void __set_failbit_and_consider_rethrow();
N
Nprotected:
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    ios_base() {// purposefully does no initialization
N               }
N
N    void init(void* __sb);
N    _LIBCPP_ALWAYS_INLINE void* rdbuf() const {return __rdbuf_;}
X    __attribute__ ((__always_inline__)) void* rdbuf() const {return __rdbuf_;}
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    void rdbuf(void* __sb)
N    {
N        __rdbuf_ = __sb;
N        clear();
N    }
N
N    void __call_callbacks(event);
N    void copyfmt(const ios_base&);
N    void move(ios_base&);
N    void swap(ios_base&) _NOEXCEPT;
X    void swap(ios_base&) noexcept;
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    void set_rdbuf(void* __sb)
N    {
N        __rdbuf_ = __sb;
N    }
N
Nprivate:
N    // All data members must be scalars
N    fmtflags        __fmtflags_;
N    streamsize      __precision_;
N    streamsize      __width_;
N    iostate         __rdstate_;
N    iostate         __exceptions_;
N    void*           __rdbuf_;
N    void*           __loc_;
N    event_callback* __fn_;
N    int*            __index_;
N    size_t          __event_size_;
N    size_t          __event_cap_;
N// TODO(EricWF): Enable this for both Clang and GCC. Currently it is only
N// enabled with clang.
N#if defined(_LIBCPP_HAS_C_ATOMIC_IMP) && !defined(_LIBCPP_HAS_NO_THREADS)
X#if 0L && !1L
S    static _DATA_ACCESS atomic<int> __xindex_;
N#else
N    static _DATA_ACCESS int      __xindex_;
X    static  int      __xindex_;
N#endif
N    long*           __iarray_;
N    size_t          __iarray_size_;
N    size_t          __iarray_cap_;
N    void**          __parray_;
N    size_t          __parray_size_;
N    size_t          __parray_cap_;
N};
N
N//enum class io_errc
N_LIBCPP_DECLARE_STRONG_ENUM(io_errc)
Xenum class  io_errc
N{
N    stream = 1
N};
N_LIBCPP_DECLARE_STRONG_ENUM_EPILOG(io_errc)
X
N
Ntemplate <>
Nstruct _LIBCPP_TEMPLATE_VIS is_error_code_enum<io_errc> : public true_type { };
Xstruct  is_error_code_enum<io_errc> : public true_type { };
N
N#ifdef _LIBCPP_HAS_NO_STRONG_ENUMS
Stemplate <>
Sstruct _LIBCPP_TEMPLATE_VIS is_error_code_enum<io_errc::__lx> : public true_type { };
N#endif
N
N_LIBCPP_FUNC_VIS
X
Nconst error_category& iostream_category() _NOEXCEPT;
Xconst error_category& iostream_category() noexcept;
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nerror_code
Nmake_error_code(io_errc __e) _NOEXCEPT
Xmake_error_code(io_errc __e) noexcept
N{
N    return error_code(static_cast<int>(__e), iostream_category());
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nerror_condition
Nmake_error_condition(io_errc __e) _NOEXCEPT
Xmake_error_condition(io_errc __e) noexcept
N{
N    return error_condition(static_cast<int>(__e), iostream_category());
N}
N
Nclass _LIBCPP_EXCEPTION_ABI ios_base::failure
Xclass  ios_base::failure
N    : public system_error
N{
Npublic:
N    explicit failure(const string& __msg, const error_code& __ec = io_errc::stream);
N    explicit failure(const char* __msg, const error_code& __ec = io_errc::stream);
N    virtual ~failure() throw();
N};
N
Nclass _LIBCPP_TYPE_VIS ios_base::Init
Xclass  ios_base::Init
N{
Npublic:
N    Init();
N    ~Init();
N};
N
N// fmtflags
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nios_base::fmtflags
Nios_base::flags() const
N{
N    return __fmtflags_;
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nios_base::fmtflags
Nios_base::flags(fmtflags __fmtfl)
N{
N    fmtflags __r = __fmtflags_;
N    __fmtflags_ = __fmtfl;
N    return __r;
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nios_base::fmtflags
Nios_base::setf(fmtflags __fmtfl)
N{
N    fmtflags __r = __fmtflags_;
N    __fmtflags_ |= __fmtfl;
N    return __r;
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Nios_base::unsetf(fmtflags __mask)
N{
N    __fmtflags_ &= ~__mask;
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nios_base::fmtflags
Nios_base::setf(fmtflags __fmtfl, fmtflags __mask)
N{
N    fmtflags __r = __fmtflags_;
N    unsetf(__mask);
N    __fmtflags_ |= __fmtfl & __mask;
N    return __r;
N}
N
N// precision
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nstreamsize
Nios_base::precision() const
N{
N    return __precision_;
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nstreamsize
Nios_base::precision(streamsize __prec)
N{
N    streamsize __r = __precision_;
N    __precision_ = __prec;
N    return __r;
N}
N
N// width
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nstreamsize
Nios_base::width() const
N{
N    return __width_;
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nstreamsize
Nios_base::width(streamsize __wide)
N{
N    streamsize __r = __width_;
N    __width_ = __wide;
N    return __r;
N}
N
N// iostate
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nios_base::iostate
Nios_base::rdstate() const
N{
N    return __rdstate_;
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Nios_base::setstate(iostate __state)
N{
N    clear(__rdstate_ | __state);
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Nios_base::good() const
N{
N    return __rdstate_ == 0;
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Nios_base::eof() const
N{
N    return (__rdstate_ & eofbit) != 0;
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Nios_base::fail() const
N{
N    return (__rdstate_ & (failbit | badbit)) != 0;
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Nios_base::bad() const
N{
N    return (__rdstate_ & badbit) != 0;
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nios_base::iostate
Nios_base::exceptions() const
N{
N    return __exceptions_;
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Nios_base::exceptions(iostate __iostate)
N{
N    __exceptions_ = __iostate;
N    clear(__rdstate_);
N}
N
N#if defined(_LIBCPP_CXX03_LANG)
X#if 0L
Sstruct _LIBCPP_TYPE_VIS __cxx03_bool {
S  typedef void (__cxx03_bool::*__bool_type)();
S  void __true_value() {}
S};
N#endif
N
Ntemplate <class _CharT, class _Traits>
Nclass _LIBCPP_TEMPLATE_VIS basic_ios
Xclass  basic_ios
N    : public ios_base
N{
Npublic:
N    // types:
N    typedef _CharT char_type;
N    typedef _Traits traits_type;
N
N    typedef typename traits_type::int_type int_type;
N    typedef typename traits_type::pos_type pos_type;
N    typedef typename traits_type::off_type off_type;
N
N  // __true_value will generate undefined references when linking unless
N  // we give it internal linkage.
N
N#if defined(_LIBCPP_CXX03_LANG)
X#if 0L
S    _LIBCPP_ALWAYS_INLINE
S    operator __cxx03_bool::__bool_type() const {
S        return !fail() ? &__cxx03_bool::__true_value : nullptr;
S    }
N#else
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    _LIBCPP_EXPLICIT operator bool() const {return !fail();}
X    explicit operator bool() const {return !fail();}
N#endif
N
N    _LIBCPP_ALWAYS_INLINE bool operator!() const    {return  fail();}
X    __attribute__ ((__always_inline__)) bool operator!() const    {return  fail();}
N    _LIBCPP_ALWAYS_INLINE iostate rdstate() const   {return ios_base::rdstate();}
X    __attribute__ ((__always_inline__)) iostate rdstate() const   {return ios_base::rdstate();}
N    _LIBCPP_ALWAYS_INLINE void clear(iostate __state = goodbit) {ios_base::clear(__state);}
X    __attribute__ ((__always_inline__)) void clear(iostate __state = goodbit) {ios_base::clear(__state);}
N    _LIBCPP_ALWAYS_INLINE void setstate(iostate __state) {ios_base::setstate(__state);}
X    __attribute__ ((__always_inline__)) void setstate(iostate __state) {ios_base::setstate(__state);}
N    _LIBCPP_ALWAYS_INLINE bool good() const {return ios_base::good();}
X    __attribute__ ((__always_inline__)) bool good() const {return ios_base::good();}
N    _LIBCPP_ALWAYS_INLINE bool eof() const  {return ios_base::eof();}
X    __attribute__ ((__always_inline__)) bool eof() const  {return ios_base::eof();}
N    _LIBCPP_ALWAYS_INLINE bool fail() const {return ios_base::fail();}
X    __attribute__ ((__always_inline__)) bool fail() const {return ios_base::fail();}
N    _LIBCPP_ALWAYS_INLINE bool bad() const  {return ios_base::bad();}
X    __attribute__ ((__always_inline__)) bool bad() const  {return ios_base::bad();}
N
N    _LIBCPP_ALWAYS_INLINE iostate exceptions() const {return ios_base::exceptions();}
X    __attribute__ ((__always_inline__)) iostate exceptions() const {return ios_base::exceptions();}
N    _LIBCPP_ALWAYS_INLINE void exceptions(iostate __iostate) {ios_base::exceptions(__iostate);}
X    __attribute__ ((__always_inline__)) void exceptions(iostate __iostate) {ios_base::exceptions(__iostate);}
N
N    // 27.5.4.1 Constructor/destructor:
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    explicit basic_ios(basic_streambuf<char_type,traits_type>* __sb);
N    virtual ~basic_ios();
N
N    // 27.5.4.2 Members:
N    _LIBCPP_INLINE_VISIBILITY 
X    __attribute__ ((__always_inline__)) 
N    basic_ostream<char_type, traits_type>* tie() const;
N    _LIBCPP_INLINE_VISIBILITY 
X    __attribute__ ((__always_inline__)) 
N    basic_ostream<char_type, traits_type>* tie(basic_ostream<char_type, traits_type>* __tiestr);
N
N    _LIBCPP_INLINE_VISIBILITY 
X    __attribute__ ((__always_inline__)) 
N    basic_streambuf<char_type, traits_type>* rdbuf() const;
N    _LIBCPP_INLINE_VISIBILITY 
X    __attribute__ ((__always_inline__)) 
N    basic_streambuf<char_type, traits_type>* rdbuf(basic_streambuf<char_type, traits_type>* __sb);
N
N    basic_ios& copyfmt(const basic_ios& __rhs);
N
N    _LIBCPP_INLINE_VISIBILITY 
X    __attribute__ ((__always_inline__)) 
N    char_type fill() const;
N    _LIBCPP_INLINE_VISIBILITY 
X    __attribute__ ((__always_inline__)) 
N    char_type fill(char_type __ch);
N
N    _LIBCPP_INLINE_VISIBILITY 
X    __attribute__ ((__always_inline__)) 
N    locale imbue(const locale& __loc);
N
N    _LIBCPP_INLINE_VISIBILITY 
X    __attribute__ ((__always_inline__)) 
N    char narrow(char_type __c, char __dfault) const;
N    _LIBCPP_INLINE_VISIBILITY 
X    __attribute__ ((__always_inline__)) 
N    char_type widen(char __c) const;
N
Nprotected:
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    basic_ios() {// purposefully does no initialization
N                }
N    _LIBCPP_INLINE_VISIBILITY 
X    __attribute__ ((__always_inline__)) 
N    void init(basic_streambuf<char_type, traits_type>* __sb);
N
N    _LIBCPP_INLINE_VISIBILITY 
X    __attribute__ ((__always_inline__)) 
N    void move(basic_ios& __rhs);
N#ifndef _LIBCPP_CXX03_LANG
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    void move(basic_ios&& __rhs) {move(__rhs);}
N#endif
N    _LIBCPP_INLINE_VISIBILITY 
X    __attribute__ ((__always_inline__)) 
N    void swap(basic_ios& __rhs) _NOEXCEPT;
X    void swap(basic_ios& __rhs) noexcept;
N    _LIBCPP_INLINE_VISIBILITY 
X    __attribute__ ((__always_inline__)) 
N    void set_rdbuf(basic_streambuf<char_type, traits_type>* __sb);
Nprivate:
N    basic_ostream<char_type, traits_type>* __tie_;
N     mutable int_type __fill_;
N};
N
Ntemplate <class _CharT, class _Traits>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbasic_ios<_CharT, _Traits>::basic_ios(basic_streambuf<char_type,traits_type>* __sb)
N{
N    init(__sb);
N}
N
Ntemplate <class _CharT, class _Traits>
Nbasic_ios<_CharT, _Traits>::~basic_ios()
N{
N}
N
Ntemplate <class _CharT, class _Traits>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Nbasic_ios<_CharT, _Traits>::init(basic_streambuf<char_type, traits_type>* __sb)
N{
N    ios_base::init(__sb);
N    __tie_ = 0;
N    __fill_ = traits_type::eof();
N}
N
Ntemplate <class _CharT, class _Traits>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbasic_ostream<_CharT, _Traits>*
Nbasic_ios<_CharT, _Traits>::tie() const
N{
N    return __tie_;
N}
N
Ntemplate <class _CharT, class _Traits>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbasic_ostream<_CharT, _Traits>*
Nbasic_ios<_CharT, _Traits>::tie(basic_ostream<char_type, traits_type>* __tiestr)
N{
N    basic_ostream<char_type, traits_type>* __r = __tie_;
N    __tie_ = __tiestr;
N    return __r;
N}
N
Ntemplate <class _CharT, class _Traits>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbasic_streambuf<_CharT, _Traits>*
Nbasic_ios<_CharT, _Traits>::rdbuf() const
N{
N    return static_cast<basic_streambuf<char_type, traits_type>*>(ios_base::rdbuf());
N}
N
Ntemplate <class _CharT, class _Traits>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbasic_streambuf<_CharT, _Traits>*
Nbasic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<char_type, traits_type>* __sb)
N{
N    basic_streambuf<char_type, traits_type>* __r = rdbuf();
N    ios_base::rdbuf(__sb);
N    return __r;
N}
N
Ntemplate <class _CharT, class _Traits>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nlocale
Nbasic_ios<_CharT, _Traits>::imbue(const locale& __loc)
N{
N    locale __r = getloc();
N    ios_base::imbue(__loc);
N    if (rdbuf())
N        rdbuf()->pubimbue(__loc);
N    return __r;
N}
N
Ntemplate <class _CharT, class _Traits>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nchar
Nbasic_ios<_CharT, _Traits>::narrow(char_type __c, char __dfault) const
N{
N    return use_facet<ctype<char_type> >(getloc()).narrow(__c, __dfault);
N}
N
Ntemplate <class _CharT, class _Traits>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_CharT
Nbasic_ios<_CharT, _Traits>::widen(char __c) const
N{
N    return use_facet<ctype<char_type> >(getloc()).widen(__c);
N}
N
Ntemplate <class _CharT, class _Traits>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_CharT
Nbasic_ios<_CharT, _Traits>::fill() const
N{
N    if (traits_type::eq_int_type(traits_type::eof(), __fill_))
N        __fill_ = widen(' ');
N    return __fill_;
N}
N
Ntemplate <class _CharT, class _Traits>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_CharT
Nbasic_ios<_CharT, _Traits>::fill(char_type __ch)
N{
N    char_type __r = __fill_;
N    __fill_ = __ch;
N    return __r;
N}
N
Ntemplate <class _CharT, class _Traits>
Nbasic_ios<_CharT, _Traits>&
Nbasic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)
N{
N    if (this != &__rhs)
N    {
N        __call_callbacks(erase_event);
N        ios_base::copyfmt(__rhs);
N        __tie_ = __rhs.__tie_;
N        __fill_ = __rhs.__fill_;
N        __call_callbacks(copyfmt_event);
N        exceptions(__rhs.exceptions());
N    }
N    return *this;
N}
N
Ntemplate <class _CharT, class _Traits>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Nbasic_ios<_CharT, _Traits>::move(basic_ios& __rhs)
N{
N    ios_base::move(__rhs);
N    __tie_ = __rhs.__tie_;
N    __rhs.__tie_ = 0;
N    __fill_ = __rhs.__fill_;
N}
N
Ntemplate <class _CharT, class _Traits>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Nbasic_ios<_CharT, _Traits>::swap(basic_ios& __rhs) _NOEXCEPT
Xbasic_ios<_CharT, _Traits>::swap(basic_ios& __rhs) noexcept
N{
N    ios_base::swap(__rhs);
N    _VSTD::swap(__tie_, __rhs.__tie_);
X    std::__2::swap(__tie_, __rhs.__tie_);
N    _VSTD::swap(__fill_, __rhs.__fill_);
X    std::__2::swap(__fill_, __rhs.__fill_);
N}
N
Ntemplate <class _CharT, class _Traits>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Nbasic_ios<_CharT, _Traits>::set_rdbuf(basic_streambuf<char_type, traits_type>* __sb)
N{
N    ios_base::set_rdbuf(__sb);
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nios_base&
Nboolalpha(ios_base& __str)
N{
N    __str.setf(ios_base::boolalpha);
N    return __str;
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nios_base&
Nnoboolalpha(ios_base& __str)
N{
N    __str.unsetf(ios_base::boolalpha);
N    return __str;
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nios_base&
Nshowbase(ios_base& __str)
N{
N    __str.setf(ios_base::showbase);
N    return __str;
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nios_base&
Nnoshowbase(ios_base& __str)
N{
N    __str.unsetf(ios_base::showbase);
N    return __str;
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nios_base&
Nshowpoint(ios_base& __str)
N{
N    __str.setf(ios_base::showpoint);
N    return __str;
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nios_base&
Nnoshowpoint(ios_base& __str)
N{
N    __str.unsetf(ios_base::showpoint);
N    return __str;
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nios_base&
Nshowpos(ios_base& __str)
N{
N    __str.setf(ios_base::showpos);
N    return __str;
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nios_base&
Nnoshowpos(ios_base& __str)
N{
N    __str.unsetf(ios_base::showpos);
N    return __str;
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nios_base&
Nskipws(ios_base& __str)
N{
N    __str.setf(ios_base::skipws);
N    return __str;
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nios_base&
Nnoskipws(ios_base& __str)
N{
N    __str.unsetf(ios_base::skipws);
N    return __str;
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nios_base&
Nuppercase(ios_base& __str)
N{
N    __str.setf(ios_base::uppercase);
N    return __str;
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nios_base&
Nnouppercase(ios_base& __str)
N{
N    __str.unsetf(ios_base::uppercase);
N    return __str;
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nios_base&
Nunitbuf(ios_base& __str)
N{
N    __str.setf(ios_base::unitbuf);
N    return __str;
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nios_base&
Nnounitbuf(ios_base& __str)
N{
N    __str.unsetf(ios_base::unitbuf);
N    return __str;
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nios_base&
Ninternal(ios_base& __str)
N{
N    __str.setf(ios_base::internal, ios_base::adjustfield);
N    return __str;
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nios_base&
Nleft(ios_base& __str)
N{
N    __str.setf(ios_base::left, ios_base::adjustfield);
N    return __str;
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nios_base&
Nright(ios_base& __str)
N{
N    __str.setf(ios_base::right, ios_base::adjustfield);
N    return __str;
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nios_base&
Ndec(ios_base& __str)
N{
N    __str.setf(ios_base::dec, ios_base::basefield);
N    return __str;
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nios_base&
Nhex(ios_base& __str)
N{
N    __str.setf(ios_base::hex, ios_base::basefield);
N    return __str;
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nios_base&
Noct(ios_base& __str)
N{
N    __str.setf(ios_base::oct, ios_base::basefield);
N    return __str;
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nios_base&
Nfixed(ios_base& __str)
N{
N    __str.setf(ios_base::fixed, ios_base::floatfield);
N    return __str;
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nios_base&
Nscientific(ios_base& __str)
N{
N    __str.setf(ios_base::scientific, ios_base::floatfield);
N    return __str;
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nios_base&
Nhexfloat(ios_base& __str)
N{
N    __str.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield);
N    return __str;
N}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nios_base&
Ndefaultfloat(ios_base& __str)
N{
N    __str.unsetf(ios_base::floatfield);
N    return __str;
N}
N
Ntemplate <class _CharT, class _Traits>
Nclass __save_flags
N{
N    typedef basic_ios<_CharT, _Traits> __stream_type;
N    typedef typename __stream_type::fmtflags fmtflags;
N
N    __stream_type& __stream_;
N    fmtflags       __fmtflags_;
N    _CharT         __fill_;
N
N    __save_flags(const __save_flags&);
N    __save_flags& operator=(const __save_flags&);
Npublic:
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    explicit __save_flags(__stream_type& __stream)
N        : __stream_(__stream),
N          __fmtflags_(__stream.flags()),
N          __fill_(__stream.fill())
N        {}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    ~__save_flags()
N    {
N        __stream_.flags(__fmtflags_);
N        __stream_.fill(__fill_);
N    }
N};
N
N_LIBCPP_END_NAMESPACE_STD
X} }
N
N#endif  // _LIBCPP_IOS
L 139 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/ostream" 2
N#include <streambuf>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/streambuf" 1
N// -*- C++ -*-
N//===------------------------- streambuf ----------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is dual licensed under the MIT and the University of Illinois Open
N// Source Licenses. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP_STEAMBUF
N#define _LIBCPP_STEAMBUF
N
N/*
N    streambuf synopsis
N
Nnamespace std
N{
N
Ntemplate <class charT, class traits = char_traits<charT> >
Nclass basic_streambuf
N{
Npublic:
N    // types:
N    typedef charT char_type;
N    typedef traits traits_type;
N    typedef typename traits_type::int_type int_type;
N    typedef typename traits_type::pos_type pos_type;
N    typedef typename traits_type::off_type off_type;
N
N    virtual ~basic_streambuf();
N
N    // 27.6.2.2.1 locales:
N    locale pubimbue(const locale& loc);
N    locale getloc() const;
N
N    // 27.6.2.2.2 buffer and positioning:
N    basic_streambuf* pubsetbuf(char_type* s, streamsize n);
N    pos_type pubseekoff(off_type off, ios_base::seekdir way,
N                        ios_base::openmode which = ios_base::in | ios_base::out);
N    pos_type pubseekpos(pos_type sp,
N                        ios_base::openmode which = ios_base::in | ios_base::out);
N    int pubsync();
N
N    // Get and put areas:
N    // 27.6.2.2.3 Get area:
N    streamsize in_avail();
N    int_type snextc();
N    int_type sbumpc();
N    int_type sgetc();
N    streamsize sgetn(char_type* s, streamsize n);
N
N    // 27.6.2.2.4 Putback:
N    int_type sputbackc(char_type c);
N    int_type sungetc();
N
N    // 27.6.2.2.5 Put area:
N    int_type sputc(char_type c);
N    streamsize sputn(const char_type* s, streamsize n);
N
Nprotected:
N    basic_streambuf();
N    basic_streambuf(const basic_streambuf& rhs);
N    basic_streambuf& operator=(const basic_streambuf& rhs);
N    void swap(basic_streambuf& rhs);
N
N    // 27.6.2.3.2 Get area:
N    char_type* eback() const;
N    char_type* gptr() const;
N    char_type* egptr() const;
N    void gbump(int n);
N    void setg(char_type* gbeg, char_type* gnext, char_type* gend);
N
N    // 27.6.2.3.3 Put area:
N    char_type* pbase() const;
N    char_type* pptr() const;
N    char_type* epptr() const;
N    void pbump(int n);
N    void setp(char_type* pbeg, char_type* pend);
N
N    // 27.6.2.4 virtual functions:
N    // 27.6.2.4.1 Locales:
N    virtual void imbue(const locale& loc);
N
N    // 27.6.2.4.2 Buffer management and positioning:
N    virtual basic_streambuf* setbuf(char_type* s, streamsize n);
N    virtual pos_type seekoff(off_type off, ios_base::seekdir way,
N                             ios_base::openmode which = ios_base::in | ios_base::out);
N    virtual pos_type seekpos(pos_type sp,
N                             ios_base::openmode which = ios_base::in | ios_base::out);
N    virtual int sync();
N
N    // 27.6.2.4.3 Get area:
N    virtual streamsize showmanyc();
N    virtual streamsize xsgetn(char_type* s, streamsize n);
N    virtual int_type underflow();
N    virtual int_type uflow();
N
N    // 27.6.2.4.4 Putback:
N    virtual int_type pbackfail(int_type c = traits_type::eof());
N
N    // 27.6.2.4.5 Put area:
N    virtual streamsize xsputn(const char_type* s, streamsize n);
N    virtual int_type overflow (int_type c = traits_type::eof());
N};
N
N}  // std
N
N*/
N
N#include <__config>
N#include <iosfwd>
N#include <ios>
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N_LIBCPP_PUSH_MACROS
X_Pragma("push_macro(\"min\")") _Pragma("push_macro(\"max\")")
N#include <__undef_macros>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/__undef_macros" 1
N// -*- C++ -*-
N//===------------------------ __undef_macros ------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is distributed under the University of Illinois Open Source
N// License. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N
N#ifdef min
S#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
S#if defined(_LIBCPP_WARNING)
S_LIBCPP_WARNING("macro min is incompatible with C++.  Try #define NOMINMAX "
S                "before any Windows header. #undefing min")
S#else
S#warning: macro min is incompatible with C++.  #undefing min
S#endif
S#endif
S#undef min
N#endif
N
N#ifdef max
S#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
S#if defined(_LIBCPP_WARNING)
S_LIBCPP_WARNING("macro max is incompatible with C++.  Try #define NOMINMAX "
S                "before any Windows header. #undefing max")
S#else
S#warning: macro max is incompatible with C++.  #undefing max
S#endif
S#endif
S#undef max
N#endif
L 121 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/streambuf" 2
N
N_LIBCPP_BEGIN_NAMESPACE_STD
Xnamespace std { inline namespace __2 {
N
Ntemplate <class _CharT, class _Traits>
Nclass _LIBCPP_TEMPLATE_VIS basic_streambuf
Xclass  basic_streambuf
N{
Npublic:
N    // types:
N    typedef _CharT                         char_type;
N    typedef _Traits                        traits_type;
N    typedef typename traits_type::int_type int_type;
N    typedef typename traits_type::pos_type pos_type;
N    typedef typename traits_type::off_type off_type;
N
N    virtual ~basic_streambuf();
N
N    // 27.6.2.2.1 locales:
N    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY
X    inline __attribute__((__always_inline__))
N    locale pubimbue(const locale& __loc) {
N        imbue(__loc);
N        locale __r = __loc_;
N        __loc_ = __loc;
N        return __r;
N    }
N
N    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY
X    inline __attribute__((__always_inline__))
N    locale getloc() const { return __loc_; }
N
N    // 27.6.2.2.2 buffer and positioning:
N    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY
X    inline __attribute__((__always_inline__))
N    basic_streambuf* pubsetbuf(char_type* __s, streamsize __n)
N    { return setbuf(__s, __n); }
N
N    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY
X    inline __attribute__((__always_inline__))
N    pos_type pubseekoff(off_type __off, ios_base::seekdir __way,
N                        ios_base::openmode __which = ios_base::in | ios_base::out)
N    { return seekoff(__off, __way, __which); }
N
N    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY
X    inline __attribute__((__always_inline__))
N    pos_type pubseekpos(pos_type __sp,
N                        ios_base::openmode __which = ios_base::in | ios_base::out)
N    { return seekpos(__sp, __which); }
N
N    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY
X    inline __attribute__((__always_inline__))
N    int pubsync() { return sync(); }
N
N    // Get and put areas:
N    // 27.6.2.2.3 Get area:
N    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY
X    inline __attribute__((__always_inline__))
N    streamsize in_avail() {
N        if (__ninp_ < __einp_)
N            return static_cast<streamsize>(__einp_ - __ninp_);
N        return showmanyc();
N    }
N
N    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY
X    inline __attribute__((__always_inline__))
N    int_type snextc() {
N        if (sbumpc() == traits_type::eof())
N            return traits_type::eof();
N        return sgetc();
N    }
N
N    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY
X    inline __attribute__((__always_inline__))
N    int_type sbumpc() {
N        if (__ninp_ == __einp_)
N            return uflow();
N        return traits_type::to_int_type(*__ninp_++);
N    }
N
N    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY
X    inline __attribute__((__always_inline__))
N    int_type sgetc() {
N        if (__ninp_ == __einp_)
N            return underflow();
N        return traits_type::to_int_type(*__ninp_);
N    }
N
N    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY
X    inline __attribute__((__always_inline__))
N    streamsize sgetn(char_type* __s, streamsize __n)
N    { return xsgetn(__s, __n); }
N
N    // 27.6.2.2.4 Putback:
N    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY
X    inline __attribute__((__always_inline__))
N    int_type sputbackc(char_type __c) {
N        if (__binp_ == __ninp_ || !traits_type::eq(__c, __ninp_[-1]))
N            return pbackfail(traits_type::to_int_type(__c));
N        return traits_type::to_int_type(*--__ninp_);
N    }
N
N    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY
X    inline __attribute__((__always_inline__))
N    int_type sungetc() {
N        if (__binp_ == __ninp_)
N          return pbackfail();
N        return traits_type::to_int_type(*--__ninp_);
N    }
N
N    // 27.6.2.2.5 Put area:
N    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY
X    inline __attribute__((__always_inline__))
N    int_type sputc(char_type __c) {
N        if (__nout_ == __eout_)
N            return overflow(traits_type::to_int_type(__c));
N        *__nout_++ = __c;
N        return traits_type::to_int_type(__c);
N    }
N
N    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY
X    inline __attribute__((__always_inline__))
N    streamsize sputn(const char_type* __s, streamsize __n)
N    { return xsputn(__s, __n); }
N
Nprotected:
N    basic_streambuf();
N    basic_streambuf(const basic_streambuf& __rhs);
N    basic_streambuf& operator=(const basic_streambuf& __rhs);
N    void swap(basic_streambuf& __rhs);
N
N    // 27.6.2.3.2 Get area:
N    _LIBCPP_ALWAYS_INLINE char_type* eback() const {return __binp_;}
X    __attribute__ ((__always_inline__)) char_type* eback() const {return __binp_;}
N    _LIBCPP_ALWAYS_INLINE char_type* gptr()  const {return __ninp_;}
X    __attribute__ ((__always_inline__)) char_type* gptr()  const {return __ninp_;}
N    _LIBCPP_ALWAYS_INLINE char_type* egptr() const {return __einp_;}
X    __attribute__ ((__always_inline__)) char_type* egptr() const {return __einp_;}
N
N    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY
X    inline __attribute__((__always_inline__))
N    void gbump(int __n) { __ninp_ += __n; }
N
N    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY
X    inline __attribute__((__always_inline__))
N    void setg(char_type* __gbeg, char_type* __gnext, char_type* __gend) {
N        __binp_ = __gbeg;
N        __ninp_ = __gnext;
N        __einp_ = __gend;
N    }
N
N    // 27.6.2.3.3 Put area:
N    _LIBCPP_ALWAYS_INLINE char_type* pbase() const {return __bout_;}
X    __attribute__ ((__always_inline__)) char_type* pbase() const {return __bout_;}
N    _LIBCPP_ALWAYS_INLINE char_type* pptr()  const {return __nout_;}
X    __attribute__ ((__always_inline__)) char_type* pptr()  const {return __nout_;}
N    _LIBCPP_ALWAYS_INLINE char_type* epptr() const {return __eout_;}
X    __attribute__ ((__always_inline__)) char_type* epptr() const {return __eout_;}
N
N    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY
X    inline __attribute__((__always_inline__))
N    void pbump(int __n) { __nout_ += __n; }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    void __pbump(streamsize __n) { __nout_ += __n; }
N
N    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY
X    inline __attribute__((__always_inline__))
N    void setp(char_type* __pbeg, char_type* __pend) {
N        __bout_ = __nout_ = __pbeg;
N        __eout_ = __pend;
N    }
N
N    // 27.6.2.4 virtual functions:
N    // 27.6.2.4.1 Locales:
N    virtual void imbue(const locale& __loc);
N
N    // 27.6.2.4.2 Buffer management and positioning:
N    virtual basic_streambuf* setbuf(char_type* __s, streamsize __n);
N    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,
N                             ios_base::openmode __which = ios_base::in | ios_base::out);
N    virtual pos_type seekpos(pos_type __sp,
N                             ios_base::openmode __which = ios_base::in | ios_base::out);
N    virtual int sync();
N
N    // 27.6.2.4.3 Get area:
N    virtual streamsize showmanyc();
N    virtual streamsize xsgetn(char_type* __s, streamsize __n);
N    virtual int_type underflow();
N    virtual int_type uflow();
N
N    // 27.6.2.4.4 Putback:
N    virtual int_type pbackfail(int_type __c = traits_type::eof());
N
N    // 27.6.2.4.5 Put area:
N    virtual streamsize xsputn(const char_type* __s, streamsize __n);
N    virtual int_type overflow(int_type __c = traits_type::eof());
N
Nprivate:
N    locale __loc_;
N    char_type* __binp_;
N    char_type* __ninp_;
N    char_type* __einp_;
N    char_type* __bout_;
N    char_type* __nout_;
N    char_type* __eout_;
N};
N
Ntemplate <class _CharT, class _Traits>
Nbasic_streambuf<_CharT, _Traits>::~basic_streambuf()
N{
N}
N
Ntemplate <class _CharT, class _Traits>
Nbasic_streambuf<_CharT, _Traits>::basic_streambuf()
N    : __binp_(0),
N      __ninp_(0),
N      __einp_(0),
N      __bout_(0),
N      __nout_(0),
N      __eout_(0)
N{
N}
N
Ntemplate <class _CharT, class _Traits>
Nbasic_streambuf<_CharT, _Traits>::basic_streambuf(const basic_streambuf& __sb)
N    : __loc_(__sb.__loc_),
N      __binp_(__sb.__binp_),
N      __ninp_(__sb.__ninp_),
N      __einp_(__sb.__einp_),
N      __bout_(__sb.__bout_),
N      __nout_(__sb.__nout_),
N      __eout_(__sb.__eout_)
N{
N}
N
Ntemplate <class _CharT, class _Traits>
Nbasic_streambuf<_CharT, _Traits>&
Nbasic_streambuf<_CharT, _Traits>::operator=(const basic_streambuf& __sb)
N{
N    __loc_ = __sb.__loc_;
N    __binp_ = __sb.__binp_;
N    __ninp_ = __sb.__ninp_;
N    __einp_ = __sb.__einp_;
N    __bout_ = __sb.__bout_;
N    __nout_ = __sb.__nout_;
N    __eout_ = __sb.__eout_;
N    return *this;
N}
N
Ntemplate <class _CharT, class _Traits>
Nvoid
Nbasic_streambuf<_CharT, _Traits>::swap(basic_streambuf& __sb)
N{
N    _VSTD::swap(__loc_, __sb.__loc_);
X    std::__2::swap(__loc_, __sb.__loc_);
N    _VSTD::swap(__binp_, __sb.__binp_);
X    std::__2::swap(__binp_, __sb.__binp_);
N    _VSTD::swap(__ninp_, __sb.__ninp_);
X    std::__2::swap(__ninp_, __sb.__ninp_);
N    _VSTD::swap(__einp_, __sb.__einp_);
X    std::__2::swap(__einp_, __sb.__einp_);
N    _VSTD::swap(__bout_, __sb.__bout_);
X    std::__2::swap(__bout_, __sb.__bout_);
N    _VSTD::swap(__nout_, __sb.__nout_);
X    std::__2::swap(__nout_, __sb.__nout_);
N    _VSTD::swap(__eout_, __sb.__eout_);
X    std::__2::swap(__eout_, __sb.__eout_);
N}
N
Ntemplate <class _CharT, class _Traits>
Nvoid
Nbasic_streambuf<_CharT, _Traits>::imbue(const locale&)
N{
N}
N
Ntemplate <class _CharT, class _Traits>
Nbasic_streambuf<_CharT, _Traits>*
Nbasic_streambuf<_CharT, _Traits>::setbuf(char_type*, streamsize)
N{
N    return this;
N}
N
Ntemplate <class _CharT, class _Traits>
Ntypename basic_streambuf<_CharT, _Traits>::pos_type
Nbasic_streambuf<_CharT, _Traits>::seekoff(off_type, ios_base::seekdir,
N                                          ios_base::openmode)
N{
N    return pos_type(off_type(-1));
N}
N
Ntemplate <class _CharT, class _Traits>
Ntypename basic_streambuf<_CharT, _Traits>::pos_type
Nbasic_streambuf<_CharT, _Traits>::seekpos(pos_type, ios_base::openmode)
N{
N    return pos_type(off_type(-1));
N}
N
Ntemplate <class _CharT, class _Traits>
Nint
Nbasic_streambuf<_CharT, _Traits>::sync()
N{
N    return 0;
N}
N
Ntemplate <class _CharT, class _Traits>
Nstreamsize
Nbasic_streambuf<_CharT, _Traits>::showmanyc()
N{
N    return 0;
N}
N
Ntemplate <class _CharT, class _Traits>
Nstreamsize
Nbasic_streambuf<_CharT, _Traits>::xsgetn(char_type* __s, streamsize __n)
N{
N    const int_type __eof = traits_type::eof();
N    int_type __c;
N    streamsize __i = 0;
N    while(__i < __n)
N    {
N        if (__ninp_ < __einp_)
N        {
N            const streamsize __len = _VSTD::min(static_cast<streamsize>(INT_MAX),
X            const streamsize __len = std::__2::min(static_cast<streamsize>(2147483647),
N                                _VSTD::min(__einp_ - __ninp_, __n - __i));
X                                std::__2::min(__einp_ - __ninp_, __n - __i));
N            traits_type::copy(__s, __ninp_, __len);
N            __s +=  __len;
N            __i +=  __len;
N            this->gbump(__len);
N        }
N        else if ((__c = uflow()) != __eof)
N        {
N            *__s = traits_type::to_char_type(__c);
N            ++__s;
N            ++__i;
N        }
N        else
N            break;
N    }
N    return __i;
N}
N
Ntemplate <class _CharT, class _Traits>
Ntypename basic_streambuf<_CharT, _Traits>::int_type
Nbasic_streambuf<_CharT, _Traits>::underflow()
N{
N    return traits_type::eof();
N}
N
Ntemplate <class _CharT, class _Traits>
Ntypename basic_streambuf<_CharT, _Traits>::int_type
Nbasic_streambuf<_CharT, _Traits>::uflow()
N{
N    if (underflow() == traits_type::eof())
N        return traits_type::eof();
N    return traits_type::to_int_type(*__ninp_++);
N}
N
Ntemplate <class _CharT, class _Traits>
Ntypename basic_streambuf<_CharT, _Traits>::int_type
Nbasic_streambuf<_CharT, _Traits>::pbackfail(int_type)
N{
N    return traits_type::eof();
N}
N
Ntemplate <class _CharT, class _Traits>
Nstreamsize
Nbasic_streambuf<_CharT, _Traits>::xsputn(const char_type* __s, streamsize __n)
N{
N    streamsize __i = 0;
N    int_type __eof = traits_type::eof();
N    while( __i < __n)
N    {
N        if (__nout_ >= __eout_)
N        {
N            if (overflow(traits_type::to_int_type(*__s)) == __eof)
N                break;
N            ++__s;
N            ++__i;
N        }
N        else
N        {
N            streamsize __chunk_size = _VSTD::min(__eout_ - __nout_, __n - __i);
X            streamsize __chunk_size = std::__2::min(__eout_ - __nout_, __n - __i);
N            traits_type::copy(__nout_, __s, __chunk_size);
N            __nout_ += __chunk_size;
N            __s     += __chunk_size;
N            __i     += __chunk_size;
N        }
N    }
N    return __i;
N}
N
Ntemplate <class _CharT, class _Traits>
Ntypename basic_streambuf<_CharT, _Traits>::int_type
Nbasic_streambuf<_CharT, _Traits>::overflow(int_type)
N{
N    return traits_type::eof();
N}
N
N#ifndef _LIBCPP_AVAILABILITY_NO_STREAMS_EXTERN_TEMPLATE
N_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_streambuf<char>)
Xextern template class basic_streambuf<char>;
N_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_streambuf<wchar_t>)
Xextern template class basic_streambuf<wchar_t>;
N
N_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_ios<char>)
Xextern template class basic_ios<char>;
N_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_ios<wchar_t>)
Xextern template class basic_ios<wchar_t>;
N#endif
N
N_LIBCPP_END_NAMESPACE_STD
X} }
N
N_LIBCPP_POP_MACROS
X_Pragma("pop_macro(\"min\")") _Pragma("pop_macro(\"max\")")
N
N#endif  // _LIBCPP_STEAMBUF
L 140 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/ostream" 2
N#include <locale>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/locale" 1
N// -*- C++ -*-
N//===-------------------------- locale ------------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is dual licensed under the MIT and the University of Illinois Open
N// Source Licenses. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP_LOCALE
N#define _LIBCPP_LOCALE
N
N/*
N    locale synopsis
N
Nnamespace std
N{
N
Nclass locale
N{
Npublic:
N    // types:
N    class facet;
N    class id;
N
N    typedef int category;
N    static const category // values assigned here are for exposition only
N        none     = 0x000,
N        collate  = 0x010,
N        ctype    = 0x020,
N        monetary = 0x040,
N        numeric  = 0x080,
N        time     = 0x100,
N        messages = 0x200,
N        all = collate | ctype | monetary | numeric | time | messages;
N
N    // construct/copy/destroy:
N    locale() noexcept;
N    locale(const locale& other) noexcept;
N    explicit locale(const char* std_name);
N    explicit locale(const string& std_name);
N    locale(const locale& other, const char* std_name, category);
N    locale(const locale& other, const string& std_name, category);
N    template <class Facet> locale(const locale& other, Facet* f);
N    locale(const locale& other, const locale& one, category);
N
N    ~locale(); // not virtual
N
N    const locale& operator=(const locale& other) noexcept;
N
N    template <class Facet> locale combine(const locale& other) const;
N
N    // locale operations:
N    basic_string<char> name() const;
N    bool operator==(const locale& other) const;
N    bool operator!=(const locale& other) const;
N    template <class charT, class Traits, class Allocator>
N      bool operator()(const basic_string<charT,Traits,Allocator>& s1,
N                      const basic_string<charT,Traits,Allocator>& s2) const;
N
N    // global locale objects:
N    static locale global(const locale&);
N    static const locale& classic();
N};
N
Ntemplate <class Facet> const Facet& use_facet(const locale&);
Ntemplate <class Facet> bool has_facet(const locale&) noexcept;
N
N// 22.3.3, convenience interfaces:
Ntemplate <class charT> bool isspace (charT c, const locale& loc);
Ntemplate <class charT> bool isprint (charT c, const locale& loc);
Ntemplate <class charT> bool iscntrl (charT c, const locale& loc);
Ntemplate <class charT> bool isupper (charT c, const locale& loc);
Ntemplate <class charT> bool islower (charT c, const locale& loc);
Ntemplate <class charT> bool isalpha (charT c, const locale& loc);
Ntemplate <class charT> bool isdigit (charT c, const locale& loc);
Ntemplate <class charT> bool ispunct (charT c, const locale& loc);
Ntemplate <class charT> bool isxdigit(charT c, const locale& loc);
Ntemplate <class charT> bool isalnum (charT c, const locale& loc);
Ntemplate <class charT> bool isgraph (charT c, const locale& loc);
Ntemplate <class charT> charT toupper(charT c, const locale& loc);
Ntemplate <class charT> charT tolower(charT c, const locale& loc);
N
Ntemplate<class Codecvt, class Elem = wchar_t,
N         class Wide_alloc = allocator<Elem>,
N         class Byte_alloc = allocator<char>>
Nclass wstring_convert
N{
Npublic:
N    typedef basic_string<char, char_traits<char>, Byte_alloc> byte_string;
N    typedef basic_string<Elem, char_traits<Elem>, Wide_alloc> wide_string;
N    typedef typename Codecvt::state_type                      state_type;
N    typedef typename wide_string::traits_type::int_type       int_type;
N
N    explicit wstring_convert(Codecvt* pcvt = new Codecvt);          // explicit in C++14
N    wstring_convert(Codecvt* pcvt, state_type state);
N    explicit wstring_convert(const byte_string& byte_err,           // explicit in C++14
N                    const wide_string& wide_err = wide_string());
N    wstring_convert(const wstring_convert&) = delete;               // C++14
N    wstring_convert & operator=(const wstring_convert &) = delete;  // C++14
N    ~wstring_convert();
N
N    wide_string from_bytes(char byte);
N    wide_string from_bytes(const char* ptr);
N    wide_string from_bytes(const byte_string& str);
N    wide_string from_bytes(const char* first, const char* last);
N
N    byte_string to_bytes(Elem wchar);
N    byte_string to_bytes(const Elem* wptr);
N    byte_string to_bytes(const wide_string& wstr);
N    byte_string to_bytes(const Elem* first, const Elem* last);
N
N    size_t converted() const; // noexcept in C++14
N    state_type state() const;
N};
N
Ntemplate <class Codecvt, class Elem = wchar_t, class Tr = char_traits<Elem>>
Nclass wbuffer_convert
N    : public basic_streambuf<Elem, Tr>
N{
Npublic:
N    typedef typename Tr::state_type state_type;
N
N    explicit wbuffer_convert(streambuf* bytebuf = 0, Codecvt* pcvt = new Codecvt,
N                    state_type state = state_type());       // explicit in C++14
N    wbuffer_convert(const wbuffer_convert&) = delete;               // C++14
N    wbuffer_convert & operator=(const wbuffer_convert &) = delete;  // C++14
N    ~wbuffer_convert();                                             // C++14
N    
N    streambuf* rdbuf() const;
N    streambuf* rdbuf(streambuf* bytebuf);
N
N    state_type state() const;
N};
N
N// 22.4.1 and 22.4.1.3, ctype:
Nclass ctype_base;
Ntemplate <class charT> class ctype;
Ntemplate <> class ctype<char>; // specialization
Ntemplate <class charT> class ctype_byname;
Ntemplate <> class ctype_byname<char>; // specialization
N
Nclass codecvt_base;
Ntemplate <class internT, class externT, class stateT> class codecvt;
Ntemplate <class internT, class externT, class stateT> class codecvt_byname;
N
N// 22.4.2 and 22.4.3, numeric:
Ntemplate <class charT, class InputIterator> class num_get;
Ntemplate <class charT, class OutputIterator> class num_put;
Ntemplate <class charT> class numpunct;
Ntemplate <class charT> class numpunct_byname;
N
N// 22.4.4, col lation:
Ntemplate <class charT> class collate;
Ntemplate <class charT> class collate_byname;
N
N// 22.4.5, date and time:
Nclass time_base;
Ntemplate <class charT, class InputIterator> class time_get;
Ntemplate <class charT, class InputIterator> class time_get_byname;
Ntemplate <class charT, class OutputIterator> class time_put;
Ntemplate <class charT, class OutputIterator> class time_put_byname;
N
N// 22.4.6, money:
Nclass money_base;
Ntemplate <class charT, class InputIterator> class money_get;
Ntemplate <class charT, class OutputIterator> class money_put;
Ntemplate <class charT, bool Intl> class moneypunct;
Ntemplate <class charT, bool Intl> class moneypunct_byname;
N
N// 22.4.7, message retrieval:
Nclass messages_base;
Ntemplate <class charT> class messages;
Ntemplate <class charT> class messages_byname;
N
N}  // std
N
N*/
N
N#include <__config>
N#include <__locale>
N#include <__debug>
N#include <algorithm>
N#include <memory>
N#include <ios>
N#include <streambuf>
N#include <iterator>
N#include <limits>
N#ifndef __APPLE__
N#include <cstdarg>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/cstdarg" 1
N// -*- C++ -*-
N//===--------------------------- cstdarg ----------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is dual licensed under the MIT and the University of Illinois Open
N// Source Licenses. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP_CSTDARG
N#define _LIBCPP_CSTDARG
N
N/*
N    cstdarg synopsis
N
NMacros:
N
N    type va_arg(va_list ap, type);
N    void va_copy(va_list dest, va_list src);  // C99
N    void va_end(va_list ap);
N    void va_start(va_list ap, parmN);
N
Nnamespace std
N{
N
NTypes:
N
N    va_list
N
N}  // std
N
N*/
N
N#include <__config>
N#include <stdarg.h>
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N_LIBCPP_BEGIN_NAMESPACE_STD
Xnamespace std { inline namespace __2 {
N
Nusing ::va_list;
N
N_LIBCPP_END_NAMESPACE_STD
X} }
N
N#endif  // _LIBCPP_CSTDARG
L 192 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/locale" 2
N#endif
N#include <cstdlib>
N#include <ctime>
N#include <cstdio>
N#ifdef _LIBCPP_HAS_CATOPEN
S#include <nl_types.h>
N#endif
N
N#ifdef __APPLE__
S#include <Availability.h>
N#endif
N
N#ifdef _LIBCPP_LOCALE__L_EXTENSIONS
N#include <__bsd_locale_defaults.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/__bsd_locale_defaults.h" 1
N// -*- C++ -*-
N//===---------------------- __bsd_locale_defaults.h -----------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is dual licensed under the MIT and the University of Illinois Open
N// Source Licenses. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N// The BSDs have lots of *_l functions.  We don't want to define those symbols
N// on other platforms though, for fear of conflicts with user code.  So here,
N// we will define the mapping from an internal macro to the real BSD symbol.
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP_BSD_LOCALE_DEFAULTS_H
N#define _LIBCPP_BSD_LOCALE_DEFAULTS_H
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N#define __libcpp_mb_cur_max_l(loc)                          MB_CUR_MAX_L(loc)
N#define __libcpp_btowc_l(ch, loc)                           btowc_l(ch, loc)
N#define __libcpp_wctob_l(wch, loc)                          wctob_l(wch, loc)
N#define __libcpp_wcsnrtombs_l(dst, src, nwc, len, ps, loc)  wcsnrtombs_l(dst, src, nwc, len, ps, loc)
N#define __libcpp_wcrtomb_l(src, wc, ps, loc)                wcrtomb_l(src, wc, ps, loc)
N#define __libcpp_mbsnrtowcs_l(dst, src, nms, len, ps, loc)  mbsnrtowcs_l(dst, src, nms, len, ps, loc)
N#define __libcpp_mbrtowc_l(pwc, s, n, ps, l)                mbrtowc_l(pwc, s, n, ps, l)
N#define __libcpp_mbtowc_l(pwc, pmb, max, l)                 mbtowc_l(pwc, pmb, max, l)
N#define __libcpp_mbrlen_l(s, n, ps, l)                      mbrlen_l(s, n, ps, l)
N#define __libcpp_localeconv_l(l)                            localeconv_l(l)
N#define __libcpp_mbsrtowcs_l(dest, src, len, ps, l)         mbsrtowcs_l(dest, src, len, ps, l)
N#define __libcpp_snprintf_l(...)                            snprintf_l(__VA_ARGS__)
N#define __libcpp_asprintf_l(...)                            asprintf_l(__VA_ARGS__)
N#define __libcpp_sscanf_l(...)                              sscanf_l(__VA_ARGS__)
N
N#endif // _LIBCPP_BSD_LOCALE_DEFAULTS_H
L 206 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/locale" 2
N#else
S#include <__bsd_locale_fallbacks.h>
N#endif
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N_LIBCPP_PUSH_MACROS
X_Pragma("push_macro(\"min\")") _Pragma("push_macro(\"max\")")
N#include <__undef_macros>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/__undef_macros" 1
N// -*- C++ -*-
N//===------------------------ __undef_macros ------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is distributed under the University of Illinois Open Source
N// License. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N
N#ifdef min
S#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
S#if defined(_LIBCPP_WARNING)
S_LIBCPP_WARNING("macro min is incompatible with C++.  Try #define NOMINMAX "
S                "before any Windows header. #undefing min")
S#else
S#warning: macro min is incompatible with C++.  #undefing min
S#endif
S#endif
S#undef min
N#endif
N
N#ifdef max
S#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
S#if defined(_LIBCPP_WARNING)
S_LIBCPP_WARNING("macro max is incompatible with C++.  Try #define NOMINMAX "
S                "before any Windows header. #undefing max")
S#else
S#warning: macro max is incompatible with C++.  #undefing max
S#endif
S#endif
S#undef max
N#endif
L 216 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/locale" 2
N
N
N_LIBCPP_BEGIN_NAMESPACE_STD
Xnamespace std { inline namespace __2 {
N
N#if defined(__APPLE__) || defined(__FreeBSD__)
X#if 0L || 0L
S#  define _LIBCPP_GET_C_LOCALE 0
S#elif defined(__CloudABI__) || defined(__NetBSD__)
X#elif 0L || 0L
S#  define _LIBCPP_GET_C_LOCALE LC_C_LOCALE
N#else
N#  define _LIBCPP_GET_C_LOCALE __cloc()
N   // Get the C locale object
N   _LIBCPP_FUNC_VIS locale_t __cloc();
X    locale_t __cloc();
N#define __cloc_defined
N#endif
N
N// __scan_keyword
N// Scans [__b, __e) until a match is found in the basic_strings range
N//  [__kb, __ke) or until it can be shown that there is no match in [__kb, __ke).
N//  __b will be incremented (visibly), consuming CharT until a match is found
N//  or proved to not exist.  A keyword may be "", in which will match anything.
N//  If one keyword is a prefix of another, and the next CharT in the input
N//  might match another keyword, the algorithm will attempt to find the longest
N//  matching keyword.  If the longer matching keyword ends up not matching, then
N//  no keyword match is found.  If no keyword match is found, __ke is returned
N//  and failbit is set in __err.
N//  Else an iterator pointing to the matching keyword is found.  If more than
N//  one keyword matches, an iterator to the first matching keyword is returned.
N//  If on exit __b == __e, eofbit is set in __err.  If __case_sensitive is false,
N//  __ct is used to force to lower case before comparing characters.
N//  Examples:
N//  Keywords:  "a", "abb"
N//  If the input is "a", the first keyword matches and eofbit is set.
N//  If the input is "abc", no match is found and "ab" are consumed.
Ntemplate <class _InputIterator, class _ForwardIterator, class _Ctype>
N_LIBCPP_HIDDEN
X
N_ForwardIterator
N__scan_keyword(_InputIterator& __b, _InputIterator __e,
N               _ForwardIterator __kb, _ForwardIterator __ke,
N               const _Ctype& __ct, ios_base::iostate& __err,
N               bool __case_sensitive = true)
N{
N    typedef typename iterator_traits<_InputIterator>::value_type _CharT;
N    size_t __nkw = static_cast<size_t>(_VSTD::distance(__kb, __ke));
X    size_t __nkw = static_cast<size_t>(std::__2::distance(__kb, __ke));
N    const unsigned char __doesnt_match = '\0';
N    const unsigned char __might_match = '\1';
N    const unsigned char __does_match = '\2';
N    unsigned char __statbuf[100];
N    unsigned char* __status = __statbuf;
N    unique_ptr<unsigned char, void(*)(void*)> __stat_hold(0, _LIBCPP_FREE);
X    unique_ptr<unsigned char, void(*)(void*)> __stat_hold(0, [] (void *p) { free(p); });
N    if (__nkw > sizeof(__statbuf))
N    {
N        __status = (unsigned char*)malloc(__nkw);
N        if (__status == 0)
N            __throw_bad_alloc();
N        __stat_hold.reset(__status);
N    }
N    size_t __n_might_match = __nkw;  // At this point, any keyword might match
N    size_t __n_does_match = 0;       // but none of them definitely do
N    // Initialize all statuses to __might_match, except for "" keywords are __does_match
N    unsigned char* __st = __status;
N    for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, (void) ++__st)
N    {
N        if (!__ky->empty())
N            *__st = __might_match;
N        else
N        {
N            *__st = __does_match;
N            --__n_might_match;
N            ++__n_does_match;
N        }
N    }
N    // While there might be a match, test keywords against the next CharT
N    for (size_t __indx = 0; __b != __e && __n_might_match > 0; ++__indx)
N    {
N        // Peek at the next CharT but don't consume it
N        _CharT __c = *__b;
N        if (!__case_sensitive)
N            __c = __ct.toupper(__c);
N        bool __consume = false;
N        // For each keyword which might match, see if the __indx character is __c
N        // If a match if found, consume __c
N        // If a match is found, and that is the last character in the keyword,
N        //    then that keyword matches.
N        // If the keyword doesn't match this character, then change the keyword
N        //    to doesn't match
N        __st = __status;
N        for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, (void) ++__st)
N        {
N            if (*__st == __might_match)
N            {
N                _CharT __kc = (*__ky)[__indx];
N                if (!__case_sensitive)
N                    __kc = __ct.toupper(__kc);
N                if (__c == __kc)
N                {
N                    __consume = true;
N                    if (__ky->size() == __indx+1)
N                    {
N                        *__st = __does_match;
N                        --__n_might_match;
N                        ++__n_does_match;
N                    }
N                }
N                else
N                {
N                    *__st = __doesnt_match;
N                    --__n_might_match;
N                }
N            }
N        }
N        // consume if we matched a character
N        if (__consume)
N        {
N            ++__b;
N            // If we consumed a character and there might be a matched keyword that
N            //   was marked matched on a previous iteration, then such keywords
N            //   which are now marked as not matching.
N            if (__n_might_match + __n_does_match > 1)
N            {
N                __st = __status;
N                for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, (void) ++__st)
N                {
N                    if (*__st == __does_match && __ky->size() != __indx+1)
N                    {
N                        *__st = __doesnt_match;
N                        --__n_does_match;
N                    }
N                }
N            }
N        }
N    }
N    // We've exited the loop because we hit eof and/or we have no more "might matches".
N    if (__b == __e)
N        __err |= ios_base::eofbit;
N    // Return the first matching result
N    for (__st = __status; __kb != __ke; ++__kb, (void) ++__st)
N        if (*__st == __does_match)
N            break;
N    if (__kb == __ke)
N        __err |= ios_base::failbit;
N    return __kb;
N}
N
Nstruct _LIBCPP_TYPE_VIS __num_get_base
Xstruct  __num_get_base
N{
N    static const int __num_get_buf_sz = 40;
N
N    static int __get_base(ios_base&);
N    static _DATA_ACCESS const char __src[33];
X    static  const char __src[33];
N};
N
N_LIBCPP_FUNC_VIS
X
Nvoid __check_grouping(const string& __grouping, unsigned* __g, unsigned* __g_end,
N                      ios_base::iostate& __err);
N
Ntemplate <class _CharT>
Nstruct __num_get
N    : protected __num_get_base
N{
N    static string __stage2_float_prep(ios_base& __iob, _CharT* __atoms, _CharT& __decimal_point,
N                                      _CharT& __thousands_sep);
N
N    static int __stage2_float_loop(_CharT __ct, bool& __in_units, char& __exp,
N                                   char* __a, char*& __a_end,
N                                   _CharT __decimal_point, _CharT __thousands_sep,
N                                   const string& __grouping, unsigned* __g,
N                                   unsigned*& __g_end, unsigned& __dc, _CharT* __atoms);
N#ifndef _LIBCPP_ABI_OPTIMIZED_LOCALE_NUM_GET
S    static string __stage2_int_prep(ios_base& __iob, _CharT* __atoms, _CharT& __thousands_sep);
S    static int __stage2_int_loop(_CharT __ct, int __base, char* __a, char*& __a_end,
S                  unsigned& __dc, _CharT __thousands_sep, const string& __grouping,
S                  unsigned* __g, unsigned*& __g_end, _CharT* __atoms);
S
N#else
N    static string __stage2_int_prep(ios_base& __iob, _CharT& __thousands_sep)
N    {
N        locale __loc = __iob.getloc();
N        const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);
N        __thousands_sep = __np.thousands_sep();
N        return __np.grouping();
N    }
N
N    const _CharT* __do_widen(ios_base& __iob, _CharT* __atoms) const
N    {
N      return __do_widen_p(__iob, __atoms);
N    }
N
N
N    static int __stage2_int_loop(_CharT __ct, int __base, char* __a, char*& __a_end,
N                  unsigned& __dc, _CharT __thousands_sep, const string& __grouping,
N                  unsigned* __g, unsigned*& __g_end, const _CharT* __atoms);
Nprivate:
N    template<typename T>
N    const T* __do_widen_p(ios_base& __iob, T* __atoms) const
N    {
N      locale __loc = __iob.getloc();
N      use_facet<ctype<T> >(__loc).widen(__src, __src + 26, __atoms);
N      return __atoms;
N    }
N
N    const char* __do_widen_p(ios_base& __iob, char* __atoms) const
N    {
N      (void)__iob;
N      (void)__atoms;
N      return __src;
N    }
N#endif
N};
N
N#ifndef _LIBCPP_ABI_OPTIMIZED_LOCALE_NUM_GET
Stemplate <class _CharT>
Sstring
S__num_get<_CharT>::__stage2_int_prep(ios_base& __iob, _CharT* __atoms, _CharT& __thousands_sep)
S{
S    locale __loc = __iob.getloc();
S    use_facet<ctype<_CharT> >(__loc).widen(__src, __src + 26, __atoms);
S    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);
S    __thousands_sep = __np.thousands_sep();
S    return __np.grouping();
S}
N#endif
N
Ntemplate <class _CharT>
Nstring
N__num_get<_CharT>::__stage2_float_prep(ios_base& __iob, _CharT* __atoms, _CharT& __decimal_point,
N                    _CharT& __thousands_sep)
N{
N    locale __loc = __iob.getloc();
N    use_facet<ctype<_CharT> >(__loc).widen(__src, __src + 32, __atoms);
N    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);
N    __decimal_point = __np.decimal_point();
N    __thousands_sep = __np.thousands_sep();
N    return __np.grouping();
N}
N
Ntemplate <class _CharT>
Nint
N#ifndef _LIBCPP_ABI_OPTIMIZED_LOCALE_NUM_GET
S__num_get<_CharT>::__stage2_int_loop(_CharT __ct, int __base, char* __a, char*& __a_end,
S                  unsigned& __dc, _CharT __thousands_sep, const string& __grouping,
S                  unsigned* __g, unsigned*& __g_end, _CharT* __atoms)
N#else
N__num_get<_CharT>::__stage2_int_loop(_CharT __ct, int __base, char* __a, char*& __a_end,
N                  unsigned& __dc, _CharT __thousands_sep, const string& __grouping,
N                  unsigned* __g, unsigned*& __g_end, const _CharT* __atoms)
N
N#endif
N{
N    if (__a_end == __a && (__ct == __atoms[24] || __ct == __atoms[25]))
N    {
N        *__a_end++ = __ct == __atoms[24] ? '+' : '-';
N        __dc = 0;
N        return 0;
N    }
N    if (__grouping.size() != 0 && __ct == __thousands_sep)
N    {
N        if (__g_end-__g < __num_get_buf_sz)
N        {
N            *__g_end++ = __dc;
N            __dc = 0;
N        }
N        return 0;
N    }
N    ptrdiff_t __f = find(__atoms, __atoms + 26, __ct) - __atoms;
N    if (__f >= 24)
N        return -1;
N    switch (__base)
N    {
N    case 8:
N    case 10:
N        if (__f >= __base)
N            return -1;
N        break;
N    case 16:
N        if (__f < 22)
N            break;
N        if (__a_end != __a && __a_end - __a <= 2 && __a_end[-1] == '0')
N        {
N            __dc = 0;
N            *__a_end++ = __src[__f];
N            return 0;
N        }
N        return -1;
N    }
N    *__a_end++ = __src[__f];
N    ++__dc;
N    return 0;
N}
N
Ntemplate <class _CharT>
Nint
N__num_get<_CharT>::__stage2_float_loop(_CharT __ct, bool& __in_units, char& __exp, char* __a, char*& __a_end,
N                    _CharT __decimal_point, _CharT __thousands_sep, const string& __grouping,
N                    unsigned* __g, unsigned*& __g_end, unsigned& __dc, _CharT* __atoms)
N{
N    if (__ct == __decimal_point)
N    {
N        if (!__in_units)
N            return -1;
N        __in_units = false;
N        *__a_end++ = '.';
N        if (__grouping.size() != 0 && __g_end-__g < __num_get_buf_sz)
N            *__g_end++ = __dc;
N        return 0;
N    }
N    if (__ct == __thousands_sep && __grouping.size() != 0)
N    {
N        if (!__in_units)
N            return -1;
N        if (__g_end-__g < __num_get_buf_sz)
N        {
N            *__g_end++ = __dc;
N            __dc = 0;
N        }
N        return 0;
N    }
N    ptrdiff_t __f = find(__atoms, __atoms + 32, __ct) - __atoms;
N    if (__f >= 32)
N        return -1;
N    char __x = __src[__f];
N    if (__x == '-' || __x == '+')
N    {
N        if (__a_end == __a || (__a_end[-1] & 0x5F) == (__exp & 0x7F))
N        {
N            *__a_end++ = __x;
N            return 0;
N        }
N        return -1;
N    }
N    if (__x == 'x' || __x == 'X')
N        __exp = 'P';
N    else if ((__x & 0x5F) == __exp)
N    {
N        __exp |= 0x80;
N        if (__in_units)
N        {
N            __in_units = false;
N            if (__grouping.size() != 0 && __g_end-__g < __num_get_buf_sz)
N                *__g_end++ = __dc;
N        }
N    }
N    *__a_end++ = __x;
N    if (__f >= 22)
N        return 0;
N    ++__dc;
N    return 0;
N}
N
N_LIBCPP_EXTERN_TEMPLATE2(struct _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __num_get<char>)
Xextern template struct __num_get<char>;
N_LIBCPP_EXTERN_TEMPLATE2(struct _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __num_get<wchar_t>)
Xextern template struct __num_get<wchar_t>;
N
Ntemplate <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >
Nclass _LIBCPP_TEMPLATE_VIS num_get
Xclass  num_get
N    : public locale::facet,
N      private __num_get<_CharT>
N{
Npublic:
N    typedef _CharT char_type;
N    typedef _InputIterator iter_type;
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    explicit num_get(size_t __refs = 0)
N        : locale::facet(__refs) {}
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
N                  ios_base::iostate& __err, bool& __v) const
N    {
N        return do_get(__b, __e, __iob, __err, __v);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
N                  ios_base::iostate& __err, long& __v) const
N    {
N        return do_get(__b, __e, __iob, __err, __v);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
N                  ios_base::iostate& __err, long long& __v) const
N    {
N        return do_get(__b, __e, __iob, __err, __v);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
N                  ios_base::iostate& __err, unsigned short& __v) const
N    {
N        return do_get(__b, __e, __iob, __err, __v);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
N                  ios_base::iostate& __err, unsigned int& __v) const
N    {
N        return do_get(__b, __e, __iob, __err, __v);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
N                  ios_base::iostate& __err, unsigned long& __v) const
N    {
N        return do_get(__b, __e, __iob, __err, __v);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
N                  ios_base::iostate& __err, unsigned long long& __v) const
N    {
N        return do_get(__b, __e, __iob, __err, __v);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
N                  ios_base::iostate& __err, float& __v) const
N    {
N        return do_get(__b, __e, __iob, __err, __v);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
N                  ios_base::iostate& __err, double& __v) const
N    {
N        return do_get(__b, __e, __iob, __err, __v);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
N                  ios_base::iostate& __err, long double& __v) const
N    {
N        return do_get(__b, __e, __iob, __err, __v);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
N                  ios_base::iostate& __err, void*& __v) const
N    {
N        return do_get(__b, __e, __iob, __err, __v);
N    }
N
N    static _DATA_ACCESS locale::id id;
X    static  locale::id id;
N
Nprotected:
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    ~num_get() {}
N
N    template <class _Fp>
N    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
X    
N    iter_type __do_get_floating_point
N                            (iter_type __b, iter_type __e, ios_base& __iob,
N                             ios_base::iostate& __err, _Fp& __v) const;
N
N    template <class _Signed>
N    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
X    
N    iter_type __do_get_signed
N                            (iter_type __b, iter_type __e, ios_base& __iob,
N                             ios_base::iostate& __err, _Signed& __v) const;
N
N    template <class _Unsigned>
N    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
X    
N    iter_type __do_get_unsigned
N                            (iter_type __b, iter_type __e, ios_base& __iob,
N                             ios_base::iostate& __err, _Unsigned& __v) const;
N
N
N    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
N                             ios_base::iostate& __err, bool& __v) const;
N
N    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
N                             ios_base::iostate& __err, long& __v) const
N    { return this->__do_get_signed ( __b, __e, __iob, __err, __v ); }
N
N    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
N                             ios_base::iostate& __err, long long& __v) const
N    { return this->__do_get_signed ( __b, __e, __iob, __err, __v ); }
N
N    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
N                             ios_base::iostate& __err, unsigned short& __v) const
N    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }
N
N    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
N                             ios_base::iostate& __err, unsigned int& __v) const
N    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }
N
N    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
N                             ios_base::iostate& __err, unsigned long& __v) const
N    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }
N
N    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
N                             ios_base::iostate& __err, unsigned long long& __v) const
N    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }
N
N    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
N                             ios_base::iostate& __err, float& __v) const
N    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }
N
N    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
N                             ios_base::iostate& __err, double& __v) const
N    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }
N
N    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
N                             ios_base::iostate& __err, long double& __v) const
N    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }
N
N    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
N                             ios_base::iostate& __err, void*& __v) const;
N};
N
Ntemplate <class _CharT, class _InputIterator>
Nlocale::id
Nnum_get<_CharT, _InputIterator>::id;
N
Ntemplate <class _Tp>
N_Tp
N__num_get_signed_integral(const char* __a, const char* __a_end,
N                          ios_base::iostate& __err, int __base)
N{
N    if (__a != __a_end)
N    {
N        typename remove_reference<decltype(errno)>::type __save_errno = errno;
X        typename remove_reference<decltype((* __aeabi_errno_addr()))>::type __save_errno = (* __aeabi_errno_addr());
N        errno = 0;
X        (* __aeabi_errno_addr()) = 0;
N        char *__p2;
N        long long __ll = strtoll_l(__a, &__p2, __base, _LIBCPP_GET_C_LOCALE);
X        long long __ll = strtoll_l(__a, &__p2, __base, __cloc());
N        typename remove_reference<decltype(errno)>::type __current_errno = errno;
X        typename remove_reference<decltype((* __aeabi_errno_addr()))>::type __current_errno = (* __aeabi_errno_addr());
N        if (__current_errno == 0)
N            errno = __save_errno;
X            (* __aeabi_errno_addr()) = __save_errno;
N        if (__p2 != __a_end)
N        {
N            __err = ios_base::failbit;
N            return 0;
N        }
N        else if (__current_errno == ERANGE         ||
X        else if (__current_errno == 0x0022         ||
N                 __ll < numeric_limits<_Tp>::min() ||
N                 numeric_limits<_Tp>::max() < __ll)
N        {
N            __err = ios_base::failbit;
N            if (__ll > 0)
N                return numeric_limits<_Tp>::max();
N            else
N                return numeric_limits<_Tp>::min();
N        }
N        return static_cast<_Tp>(__ll);
N    }
N    __err = ios_base::failbit;
N    return 0;
N}
N
Ntemplate <class _Tp>
N_Tp
N__num_get_unsigned_integral(const char* __a, const char* __a_end,
N                            ios_base::iostate& __err, int __base)
N{
N    if (__a != __a_end)
N    {
N        if (*__a == '-')
N        {
N            __err = ios_base::failbit;
N            return 0;
N        }
N        typename remove_reference<decltype(errno)>::type __save_errno = errno;
X        typename remove_reference<decltype((* __aeabi_errno_addr()))>::type __save_errno = (* __aeabi_errno_addr());
N        errno = 0;
X        (* __aeabi_errno_addr()) = 0;
N        char *__p2;
N        unsigned long long __ll = strtoull_l(__a, &__p2, __base, _LIBCPP_GET_C_LOCALE);
X        unsigned long long __ll = strtoull_l(__a, &__p2, __base, __cloc());
N        typename remove_reference<decltype(errno)>::type __current_errno = errno;
X        typename remove_reference<decltype((* __aeabi_errno_addr()))>::type __current_errno = (* __aeabi_errno_addr());
N        if (__current_errno == 0)
N            errno = __save_errno;
X            (* __aeabi_errno_addr()) = __save_errno;
N        if (__p2 != __a_end)
N        {
N            __err = ios_base::failbit;
N            return 0;
N        }
N        else if (__current_errno == ERANGE ||
X        else if (__current_errno == 0x0022 ||
N                 numeric_limits<_Tp>::max() < __ll)
N        {
N            __err = ios_base::failbit;
N            return numeric_limits<_Tp>::max();
N        }
N        return static_cast<_Tp>(__ll);
N    }
N    __err = ios_base::failbit;
N    return 0;
N}
N
Ntemplate <class _Tp>
N_LIBCPP_INLINE_VISIBILITY
X__attribute__ ((__always_inline__))
N_Tp __do_strtod(const char* __a, char** __p2);
N
Ntemplate <>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nfloat __do_strtod<float>(const char* __a, char** __p2) {
N    return strtof_l(__a, __p2, _LIBCPP_GET_C_LOCALE);
X    return strtof_l(__a, __p2, __cloc());
N}
N
Ntemplate <>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ndouble __do_strtod<double>(const char* __a, char** __p2) {
N    return strtod_l(__a, __p2, _LIBCPP_GET_C_LOCALE);
X    return strtod_l(__a, __p2, __cloc());
N}
N
Ntemplate <>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nlong double __do_strtod<long double>(const char* __a, char** __p2) {
N    return strtold_l(__a, __p2, _LIBCPP_GET_C_LOCALE);
X    return strtold_l(__a, __p2, __cloc());
N}
N
Ntemplate <class _Tp>
N_LIBCPP_HIDDEN
X
N_Tp
N__num_get_float(const char* __a, const char* __a_end, ios_base::iostate& __err)
N{
N    if (__a != __a_end)
N    {
N        typename remove_reference<decltype(errno)>::type __save_errno = errno;
X        typename remove_reference<decltype((* __aeabi_errno_addr()))>::type __save_errno = (* __aeabi_errno_addr());
N        errno = 0;
X        (* __aeabi_errno_addr()) = 0;
N        char *__p2;
N        _Tp __ld = __do_strtod<_Tp>(__a, &__p2);
N        typename remove_reference<decltype(errno)>::type __current_errno = errno;
X        typename remove_reference<decltype((* __aeabi_errno_addr()))>::type __current_errno = (* __aeabi_errno_addr());
N        if (__current_errno == 0)
N            errno = __save_errno;
X            (* __aeabi_errno_addr()) = __save_errno;
N        if (__p2 != __a_end)
N        {
N            __err = ios_base::failbit;
N            return 0;
N        }
N        else if (__current_errno == ERANGE)
X        else if (__current_errno == 0x0022)
N            __err = ios_base::failbit;
N        return __ld;
N    }
N    __err = ios_base::failbit;
N    return 0;
N}
N
Ntemplate <class _CharT, class _InputIterator>
N_InputIterator
Nnum_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
N                                        ios_base& __iob,
N                                        ios_base::iostate& __err,
N                                        bool& __v) const
N{
N    if ((__iob.flags() & ios_base::boolalpha) == 0)
N    {
N        long __lv = -1;
N        __b = do_get(__b, __e, __iob, __err, __lv);
N        switch (__lv)
N        {
N        case 0:
N            __v = false;
N            break;
N        case 1:
N            __v = true;
N            break;
N        default:
N            __v = true;
N            __err = ios_base::failbit;
N            break;
N        }
N        return __b;
N    }
N    const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__iob.getloc());
N    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__iob.getloc());
N    typedef typename numpunct<_CharT>::string_type string_type;
N    const string_type __names[2] = {__np.truename(), __np.falsename()};
N    const string_type* __i = __scan_keyword(__b, __e, __names, __names+2,
N                                            __ct, __err);
N    __v = __i == __names;
N    return __b;
N}
N
N// signed
N
Ntemplate <class _CharT, class _InputIterator>
Ntemplate <class _Signed>
N_InputIterator
Nnum_get<_CharT, _InputIterator>::__do_get_signed(iter_type __b, iter_type __e,
N                                        ios_base& __iob,
N                                        ios_base::iostate& __err,
N                                        _Signed& __v) const
N{
N    // Stage 1
N    int __base = this->__get_base(__iob);
N    // Stage 2
N    char_type __thousands_sep;
N    const int __atoms_size = 26;
N#ifdef _LIBCPP_ABI_OPTIMIZED_LOCALE_NUM_GET
N    char_type __atoms1[__atoms_size];
N    const char_type *__atoms = this->__do_widen(__iob, __atoms1);
N    string __grouping = this->__stage2_int_prep(__iob, __thousands_sep);
N#else
S    char_type __atoms[__atoms_size];
S    string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);
N#endif
N    string __buf;
N    __buf.resize(__buf.capacity());
N    char* __a = &__buf[0];
N    char* __a_end = __a;
N    unsigned __g[__num_get_base::__num_get_buf_sz];
N    unsigned* __g_end = __g;
N    unsigned __dc = 0;
N    for (; __b != __e; ++__b)
N    {
N        if (__a_end == __a + __buf.size())
N        {
N            size_t __tmp = __buf.size();
N            __buf.resize(2*__buf.size());
N            __buf.resize(__buf.capacity());
N            __a = &__buf[0];
N            __a_end = __a + __tmp;
N        }
N        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,
N                                    __thousands_sep, __grouping, __g, __g_end,
N                                    __atoms))
N            break;
N    }
N    if (__grouping.size() != 0 && __g_end-__g < __num_get_base::__num_get_buf_sz)
N        *__g_end++ = __dc;
N    // Stage 3
N    __v = __num_get_signed_integral<_Signed>(__a, __a_end, __err, __base);
N    // Digit grouping checked
N    __check_grouping(__grouping, __g, __g_end, __err);
N    // EOF checked
N    if (__b == __e)
N        __err |= ios_base::eofbit;
N    return __b;
N}
N
N// unsigned
N
Ntemplate <class _CharT, class _InputIterator>
Ntemplate <class _Unsigned>
N_InputIterator
Nnum_get<_CharT, _InputIterator>::__do_get_unsigned(iter_type __b, iter_type __e,
N                                        ios_base& __iob,
N                                        ios_base::iostate& __err,
N                                        _Unsigned& __v) const
N{
N    // Stage 1
N    int __base = this->__get_base(__iob);
N    // Stage 2
N    char_type __thousands_sep;
N    const int __atoms_size = 26;
N#ifdef _LIBCPP_ABI_OPTIMIZED_LOCALE_NUM_GET
N    char_type __atoms1[__atoms_size];
N    const char_type *__atoms = this->__do_widen(__iob, __atoms1);
N    string __grouping = this->__stage2_int_prep(__iob, __thousands_sep);
N#else
S    char_type __atoms[__atoms_size];
S    string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);
N#endif
N    string __buf;
N    __buf.resize(__buf.capacity());
N    char* __a = &__buf[0];
N    char* __a_end = __a;
N    unsigned __g[__num_get_base::__num_get_buf_sz];
N    unsigned* __g_end = __g;
N    unsigned __dc = 0;
N    for (; __b != __e; ++__b)
N    {
N        if (__a_end == __a + __buf.size())
N        {
N            size_t __tmp = __buf.size();
N            __buf.resize(2*__buf.size());
N            __buf.resize(__buf.capacity());
N            __a = &__buf[0];
N            __a_end = __a + __tmp;
N        }
N        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,
N                                    __thousands_sep, __grouping, __g, __g_end,
N                                    __atoms))
N            break;
N    }
N    if (__grouping.size() != 0 && __g_end-__g < __num_get_base::__num_get_buf_sz)
N        *__g_end++ = __dc;
N    // Stage 3
N    __v = __num_get_unsigned_integral<_Unsigned>(__a, __a_end, __err, __base);
N    // Digit grouping checked
N    __check_grouping(__grouping, __g, __g_end, __err);
N    // EOF checked
N    if (__b == __e)
N        __err |= ios_base::eofbit;
N    return __b;
N}
N
N// floating point
N
Ntemplate <class _CharT, class _InputIterator>
Ntemplate <class _Fp>
N_InputIterator
Nnum_get<_CharT, _InputIterator>::__do_get_floating_point(iter_type __b, iter_type __e,
N                                        ios_base& __iob,
N                                        ios_base::iostate& __err,
N                                        _Fp& __v) const
N{
N    // Stage 1, nothing to do
N    // Stage 2
N    char_type __atoms[32];
N    char_type __decimal_point;
N    char_type __thousands_sep;
N    string __grouping = this->__stage2_float_prep(__iob, __atoms,
N                                                  __decimal_point,
N                                                  __thousands_sep);
N    string __buf;
N    __buf.resize(__buf.capacity());
N    char* __a = &__buf[0];
N    char* __a_end = __a;
N    unsigned __g[__num_get_base::__num_get_buf_sz];
N    unsigned* __g_end = __g;
N    unsigned __dc = 0;
N    bool __in_units = true;
N    char __exp = 'E';
N    for (; __b != __e; ++__b)
N    {
N        if (__a_end == __a + __buf.size())
N        {
N            size_t __tmp = __buf.size();
N            __buf.resize(2*__buf.size());
N            __buf.resize(__buf.capacity());
N            __a = &__buf[0];
N            __a_end = __a + __tmp;
N        }
N        if (this->__stage2_float_loop(*__b, __in_units, __exp, __a, __a_end,
N                                      __decimal_point, __thousands_sep,
N                                      __grouping, __g, __g_end,
N                                      __dc, __atoms))
N            break;
N    }
N    if (__grouping.size() != 0 && __in_units && __g_end-__g < __num_get_base::__num_get_buf_sz)
N        *__g_end++ = __dc;
N    // Stage 3
N    __v = __num_get_float<_Fp>(__a, __a_end, __err);
N    // Digit grouping checked
N    __check_grouping(__grouping, __g, __g_end, __err);
N    // EOF checked
N    if (__b == __e)
N        __err |= ios_base::eofbit;
N    return __b;
N}
N
Ntemplate <class _CharT, class _InputIterator>
N_InputIterator
Nnum_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
N                                        ios_base& __iob,
N                                        ios_base::iostate& __err,
N                                        void*& __v) const
N{
N    // Stage 1
N    int __base = 16;
N    // Stage 2
N    char_type __atoms[26];
N    char_type __thousands_sep = 0;
N    string __grouping;
N    use_facet<ctype<_CharT> >(__iob.getloc()).widen(__num_get_base::__src,
N                                                    __num_get_base::__src + 26, __atoms);
N    string __buf;
N    __buf.resize(__buf.capacity());
N    char* __a = &__buf[0];
N    char* __a_end = __a;
N    unsigned __g[__num_get_base::__num_get_buf_sz];
N    unsigned* __g_end = __g;
N    unsigned __dc = 0;
N    for (; __b != __e; ++__b)
N    {
N        if (__a_end == __a + __buf.size())
N        {
N            size_t __tmp = __buf.size();
N            __buf.resize(2*__buf.size());
N            __buf.resize(__buf.capacity());
N            __a = &__buf[0];
N            __a_end = __a + __tmp;
N        }
N        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,
N                                    __thousands_sep, __grouping,
N                                    __g, __g_end, __atoms))
N            break;
N    }
N    // Stage 3
N    __buf.resize(__a_end - __a);
N    if (__libcpp_sscanf_l(__buf.c_str(), _LIBCPP_GET_C_LOCALE, "%p", &__v) != 1)
X    if (sscanf_l(__buf . c_str(), __cloc(), "%p", &__v) != 1)
N        __err = ios_base::failbit;
N    // EOF checked
N    if (__b == __e)
N        __err |= ios_base::eofbit;
N    return __b;
N}
N
N_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS num_get<char>)
Xextern template class num_get<char>;
N_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS num_get<wchar_t>)
Xextern template class num_get<wchar_t>;
N
Nstruct _LIBCPP_TYPE_VIS __num_put_base
Xstruct  __num_put_base
N{
Nprotected:
N    static void __format_int(char* __fmt, const char* __len, bool __signd,
N                             ios_base::fmtflags __flags);
N    static bool __format_float(char* __fmt, const char* __len,
N                               ios_base::fmtflags __flags);
N    static char* __identify_padding(char* __nb, char* __ne,
N                                    const ios_base& __iob);
N};
N
Ntemplate <class _CharT>
Nstruct __num_put
N    : protected __num_put_base
N{
N    static void __widen_and_group_int(char* __nb, char* __np, char* __ne,
N                                      _CharT* __ob, _CharT*& __op, _CharT*& __oe,
N                                      const locale& __loc);
N    static void __widen_and_group_float(char* __nb, char* __np, char* __ne,
N                                        _CharT* __ob, _CharT*& __op, _CharT*& __oe,
N                                        const locale& __loc);
N};
N
Ntemplate <class _CharT>
Nvoid
N__num_put<_CharT>::__widen_and_group_int(char* __nb, char* __np, char* __ne,
N                                         _CharT* __ob, _CharT*& __op, _CharT*& __oe,
N                                         const locale& __loc)
N{
N    const ctype<_CharT>&    __ct = use_facet<ctype<_CharT> >   (__loc);
N    const numpunct<_CharT>& __npt = use_facet<numpunct<_CharT> >(__loc);
N    string __grouping = __npt.grouping();
N    if (__grouping.empty())
N    {
N        __ct.widen(__nb, __ne, __ob);
N        __oe = __ob + (__ne - __nb);
N    }
N    else
N    {
N        __oe = __ob;
N        char* __nf = __nb;
N        if (*__nf == '-' || *__nf == '+')
N            *__oe++ = __ct.widen(*__nf++);
N        if (__ne - __nf >= 2 && __nf[0] == '0' && (__nf[1] == 'x' ||
N                                                   __nf[1] == 'X'))
N        {
N            *__oe++ = __ct.widen(*__nf++);
N            *__oe++ = __ct.widen(*__nf++);
N        }
N        reverse(__nf, __ne);
N        _CharT __thousands_sep = __npt.thousands_sep();
N        unsigned __dc = 0;
N        unsigned __dg = 0;
N        for (char* __p = __nf; __p < __ne; ++__p)
N        {
N            if (static_cast<unsigned>(__grouping[__dg]) > 0 &&
N                __dc == static_cast<unsigned>(__grouping[__dg]))
N            {
N                *__oe++ = __thousands_sep;
N                __dc = 0;
N                if (__dg < __grouping.size()-1)
N                    ++__dg;
N            }
N            *__oe++ = __ct.widen(*__p);
N            ++__dc;
N        }
N        reverse(__ob + (__nf - __nb), __oe);
N    }
N    if (__np == __ne)
N        __op = __oe;
N    else
N        __op = __ob + (__np - __nb);
N}
N
Ntemplate <class _CharT>
Nvoid
N__num_put<_CharT>::__widen_and_group_float(char* __nb, char* __np, char* __ne,
N                                           _CharT* __ob, _CharT*& __op, _CharT*& __oe,
N                                           const locale& __loc)
N{
N    const ctype<_CharT>&    __ct = use_facet<ctype<_CharT> >   (__loc);
N    const numpunct<_CharT>& __npt = use_facet<numpunct<_CharT> >(__loc);
N    string __grouping = __npt.grouping();
N    __oe = __ob;
N    char* __nf = __nb;
N    if (*__nf == '-' || *__nf == '+')
N        *__oe++ = __ct.widen(*__nf++);
N    char* __ns;
N    if (__ne - __nf >= 2 && __nf[0] == '0' && (__nf[1] == 'x' ||
N                                               __nf[1] == 'X'))
N    {
N        *__oe++ = __ct.widen(*__nf++);
N        *__oe++ = __ct.widen(*__nf++);
N        for (__ns = __nf; __ns < __ne; ++__ns)
N            if (!isxdigit_l(*__ns, _LIBCPP_GET_C_LOCALE))
X            if (!isxdigit_l(*__ns, __cloc()))
N                break;
N    }
N    else
N    {
N        for (__ns = __nf; __ns < __ne; ++__ns)
N            if (!isdigit_l(*__ns, _LIBCPP_GET_C_LOCALE))
X            if (!isdigit_l(*__ns, __cloc()))
N                break;
N    }
N    if (__grouping.empty())
N    {
N        __ct.widen(__nf, __ns, __oe);
N        __oe += __ns - __nf;
N    }
N    else
N    {
N        reverse(__nf, __ns);
N        _CharT __thousands_sep = __npt.thousands_sep();
N        unsigned __dc = 0;
N        unsigned __dg = 0;
N        for (char* __p = __nf; __p < __ns; ++__p)
N        {
N            if (__grouping[__dg] > 0 && __dc == static_cast<unsigned>(__grouping[__dg]))
N            {
N                *__oe++ = __thousands_sep;
N                __dc = 0;
N                if (__dg < __grouping.size()-1)
N                    ++__dg;
N            }
N            *__oe++ = __ct.widen(*__p);
N            ++__dc;
N        }
N        reverse(__ob + (__nf - __nb), __oe);
N    }
N    for (__nf = __ns; __nf < __ne; ++__nf)
N    {
N        if (*__nf == '.')
N        {
N            *__oe++ = __npt.decimal_point();
N            ++__nf;
N            break;
N        }
N        else
N            *__oe++ = __ct.widen(*__nf);
N    }
N    __ct.widen(__nf, __ne, __oe);
N    __oe += __ne - __nf;
N    if (__np == __ne)
N        __op = __oe;
N    else
N        __op = __ob + (__np - __nb);
N}
N
N_LIBCPP_EXTERN_TEMPLATE2(struct _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __num_put<char>)
Xextern template struct __num_put<char>;
N_LIBCPP_EXTERN_TEMPLATE2(struct _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __num_put<wchar_t>)
Xextern template struct __num_put<wchar_t>;
N
Ntemplate <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >
Nclass _LIBCPP_TEMPLATE_VIS num_put
Xclass  num_put
N    : public locale::facet,
N      private __num_put<_CharT>
N{
Npublic:
N    typedef _CharT char_type;
N    typedef _OutputIterator iter_type;
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    explicit num_put(size_t __refs = 0)
N        : locale::facet(__refs) {}
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
N                  bool __v) const
N    {
N        return do_put(__s, __iob, __fl, __v);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
N                  long __v) const
N    {
N        return do_put(__s, __iob, __fl, __v);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
N                  long long __v) const
N    {
N        return do_put(__s, __iob, __fl, __v);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
N                  unsigned long __v) const
N    {
N        return do_put(__s, __iob, __fl, __v);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
N                  unsigned long long __v) const
N    {
N        return do_put(__s, __iob, __fl, __v);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
N                  double __v) const
N    {
N        return do_put(__s, __iob, __fl, __v);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
N                  long double __v) const
N    {
N        return do_put(__s, __iob, __fl, __v);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
N                  const void* __v) const
N    {
N        return do_put(__s, __iob, __fl, __v);
N    }
N
N    static _DATA_ACCESS locale::id id;
X    static  locale::id id;
N
Nprotected:
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    ~num_put() {}
N
N    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
N                             bool __v) const;
N    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
N                             long __v) const;
N    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
N                             long long __v) const;
N    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
N                             unsigned long) const;
N    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
N                             unsigned long long) const;
N    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
N                             double __v) const;
N    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
N                             long double __v) const;
N    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
N                             const void* __v) const;
N};
N
Ntemplate <class _CharT, class _OutputIterator>
Nlocale::id
Nnum_put<_CharT, _OutputIterator>::id;
N
Ntemplate <class _CharT, class _OutputIterator>
N_LIBCPP_HIDDEN
X
N_OutputIterator
N__pad_and_output(_OutputIterator __s,
N                 const _CharT* __ob, const _CharT* __op, const _CharT* __oe,
N                 ios_base& __iob, _CharT __fl)
N{
N    streamsize __sz = __oe - __ob;
N    streamsize __ns = __iob.width();
N    if (__ns > __sz)
N        __ns -= __sz;
N    else
N        __ns = 0;
N    for (;__ob < __op; ++__ob, ++__s)
N        *__s = *__ob;
N    for (; __ns; --__ns, ++__s)
N        *__s = __fl;
N    for (; __ob < __oe; ++__ob, ++__s)
N        *__s = *__ob;
N    __iob.width(0);
N    return __s;
N}
N
N#if !defined(__APPLE__) || \
N    (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && __MAC_OS_X_VERSION_MIN_REQUIRED > __MAC_10_8) || \
N    (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && __IPHONE_OS_VERSION_MIN_REQUIRED > __IPHONE_6_0)
X#if !0L ||     (0L && __MAC_OS_X_VERSION_MIN_REQUIRED > __MAC_10_8) ||     (0L && __IPHONE_OS_VERSION_MIN_REQUIRED > __IPHONE_6_0)
N
Ntemplate <class _CharT, class _Traits>
N_LIBCPP_HIDDEN
X
Nostreambuf_iterator<_CharT, _Traits>
N__pad_and_output(ostreambuf_iterator<_CharT, _Traits> __s,
N                 const _CharT* __ob, const _CharT* __op, const _CharT* __oe,
N                 ios_base& __iob, _CharT __fl)
N{
N    if (__s.__sbuf_ == nullptr)
N        return __s;
N    streamsize __sz = __oe - __ob;
N    streamsize __ns = __iob.width();
N    if (__ns > __sz)
N        __ns -= __sz;
N    else
N        __ns = 0;
N    streamsize __np = __op - __ob;
N    if (__np > 0)
N    {
N        if (__s.__sbuf_->sputn(__ob, __np) != __np)
N        {
N            __s.__sbuf_ = nullptr;
N            return __s;
N        }
N    }
N    if (__ns > 0)
N    {
N        basic_string<_CharT, _Traits> __sp(__ns, __fl);
N        if (__s.__sbuf_->sputn(__sp.data(), __ns) != __ns)
N        {
N            __s.__sbuf_ = nullptr;
N            return __s;
N        }
N    }
N    __np = __oe - __op;
N    if (__np > 0)
N    {
N        if (__s.__sbuf_->sputn(__op, __np) != __np)
N        {
N            __s.__sbuf_ = nullptr;
N            return __s;
N        }
N    }
N    __iob.width(0);
N    return __s;
N}
N
N#endif
N
Ntemplate <class _CharT, class _OutputIterator>
N_OutputIterator
Nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
N                                         char_type __fl, bool __v) const
N{
N    if ((__iob.flags() & ios_base::boolalpha) == 0)
N        return do_put(__s, __iob, __fl, (unsigned long)__v);
N    const numpunct<char_type>& __np = use_facet<numpunct<char_type> >(__iob.getloc());
N    typedef typename numpunct<char_type>::string_type string_type;
N#if _LIBCPP_DEBUG_LEVEL >= 2
S    string_type __tmp(__v ? __np.truename() : __np.falsename());
S    string_type __nm = _VSTD::move(__tmp);
N#else
N    string_type __nm = __v ? __np.truename() : __np.falsename();
N#endif
N    for (typename string_type::iterator __i = __nm.begin(); __i != __nm.end(); ++__i, ++__s)
N        *__s = *__i;
N    return __s;
N}
N
Ntemplate <class _CharT, class _OutputIterator>
N_OutputIterator
Nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
N                                         char_type __fl, long __v) const
N{
N    // Stage 1 - Get number in narrow char
N    char __fmt[6] = {'%', 0};
N    const char* __len = "l";
N    this->__format_int(__fmt+1, __len, true, __iob.flags());
N    const unsigned __nbuf = (numeric_limits<long>::digits / 3)
N                          + ((numeric_limits<long>::digits % 3) != 0)
N                          + ((__iob.flags() & ios_base::showbase) != 0)
N                          + 2;
N    char __nar[__nbuf];
N    int __nc = __libcpp_snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);
X    int __nc = snprintf_l(__nar, sizeof(__nar), __cloc(), __fmt, __v);
N    char* __ne = __nar + __nc;
N    char* __np = this->__identify_padding(__nar, __ne, __iob);
N    // Stage 2 - Widen __nar while adding thousands separators
N    char_type __o[2*(__nbuf-1) - 1];
N    char_type* __op;  // pad here
N    char_type* __oe;  // end of output
N    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());
N    // [__o, __oe) contains thousands_sep'd wide number
N    // Stage 3 & 4
N    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
N}
N
Ntemplate <class _CharT, class _OutputIterator>
N_OutputIterator
Nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
N                                         char_type __fl, long long __v) const
N{
N    // Stage 1 - Get number in narrow char
N    char __fmt[8] = {'%', 0};
N    const char* __len = "ll";
N    this->__format_int(__fmt+1, __len, true, __iob.flags());
N    const unsigned __nbuf = (numeric_limits<long long>::digits / 3)
N                          + ((numeric_limits<long long>::digits % 3) != 0)
N                          + ((__iob.flags() & ios_base::showbase) != 0)
N                          + 2;
N    char __nar[__nbuf];
N    int __nc = __libcpp_snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);
X    int __nc = snprintf_l(__nar, sizeof(__nar), __cloc(), __fmt, __v);
N    char* __ne = __nar + __nc;
N    char* __np = this->__identify_padding(__nar, __ne, __iob);
N    // Stage 2 - Widen __nar while adding thousands separators
N    char_type __o[2*(__nbuf-1) - 1];
N    char_type* __op;  // pad here
N    char_type* __oe;  // end of output
N    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());
N    // [__o, __oe) contains thousands_sep'd wide number
N    // Stage 3 & 4
N    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
N}
N
Ntemplate <class _CharT, class _OutputIterator>
N_OutputIterator
Nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
N                                         char_type __fl, unsigned long __v) const
N{
N    // Stage 1 - Get number in narrow char
N    char __fmt[6] = {'%', 0};
N    const char* __len = "l";
N    this->__format_int(__fmt+1, __len, false, __iob.flags());
N    const unsigned __nbuf = (numeric_limits<unsigned long>::digits / 3)
N                          + ((numeric_limits<unsigned long>::digits % 3) != 0)
N                          + ((__iob.flags() & ios_base::showbase) != 0)
N                          + 1;
N    char __nar[__nbuf];
N    int __nc = __libcpp_snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);
X    int __nc = snprintf_l(__nar, sizeof(__nar), __cloc(), __fmt, __v);
N    char* __ne = __nar + __nc;
N    char* __np = this->__identify_padding(__nar, __ne, __iob);
N    // Stage 2 - Widen __nar while adding thousands separators
N    char_type __o[2*(__nbuf-1) - 1];
N    char_type* __op;  // pad here
N    char_type* __oe;  // end of output
N    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());
N    // [__o, __oe) contains thousands_sep'd wide number
N    // Stage 3 & 4
N    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
N}
N
Ntemplate <class _CharT, class _OutputIterator>
N_OutputIterator
Nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
N                                         char_type __fl, unsigned long long __v) const
N{
N    // Stage 1 - Get number in narrow char
N    char __fmt[8] = {'%', 0};
N    const char* __len = "ll";
N    this->__format_int(__fmt+1, __len, false, __iob.flags());
N    const unsigned __nbuf = (numeric_limits<unsigned long long>::digits / 3)
N                          + ((numeric_limits<unsigned long long>::digits % 3) != 0)
N                          + ((__iob.flags() & ios_base::showbase) != 0)
N                          + 1;
N    char __nar[__nbuf];
N    int __nc = __libcpp_snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);
X    int __nc = snprintf_l(__nar, sizeof(__nar), __cloc(), __fmt, __v);
N    char* __ne = __nar + __nc;
N    char* __np = this->__identify_padding(__nar, __ne, __iob);
N    // Stage 2 - Widen __nar while adding thousands separators
N    char_type __o[2*(__nbuf-1) - 1];
N    char_type* __op;  // pad here
N    char_type* __oe;  // end of output
N    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());
N    // [__o, __oe) contains thousands_sep'd wide number
N    // Stage 3 & 4
N    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
N}
N
Ntemplate <class _CharT, class _OutputIterator>
N_OutputIterator
Nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
N                                         char_type __fl, double __v) const
N{
N    // Stage 1 - Get number in narrow char
N    char __fmt[8] = {'%', 0};
N    const char* __len = "";
N    bool __specify_precision = this->__format_float(__fmt+1, __len, __iob.flags());
N    const unsigned __nbuf = 30;
N    char __nar[__nbuf];
N    char* __nb = __nar;
N    int __nc;
N    if (__specify_precision)
N        __nc = __libcpp_snprintf_l(__nb, __nbuf, _LIBCPP_GET_C_LOCALE, __fmt,
N                                   (int)__iob.precision(), __v);
X        __nc = snprintf_l(__nb, __nbuf, __cloc(), __fmt, (int)__iob . precision(), __v);
N    else
N        __nc = __libcpp_snprintf_l(__nb, __nbuf, _LIBCPP_GET_C_LOCALE, __fmt, __v);
X        __nc = snprintf_l(__nb, __nbuf, __cloc(), __fmt, __v);
N    unique_ptr<char, void(*)(void*)> __nbh(0, _LIBCPP_FREE);
X    unique_ptr<char, void(*)(void*)> __nbh(0, [] (void *p) { free(p); });
N    if (__nc > static_cast<int>(__nbuf-1))
N    {
N        if (__specify_precision)
N            __nc = __libcpp_asprintf_l(&__nb, _LIBCPP_GET_C_LOCALE, __fmt, (int)__iob.precision(), __v);
X            __nc = asprintf_l(&__nb, __cloc(), __fmt, (int)__iob . precision(), __v);
N        else
N            __nc = __libcpp_asprintf_l(&__nb, _LIBCPP_GET_C_LOCALE, __fmt, __v);
X            __nc = asprintf_l(&__nb, __cloc(), __fmt, __v);
N        if (__nb == 0)
N            __throw_bad_alloc();
N        __nbh.reset(__nb);
N    }
N    char* __ne = __nb + __nc;
N    char* __np = this->__identify_padding(__nb, __ne, __iob);
N    // Stage 2 - Widen __nar while adding thousands separators
N    char_type __o[2*(__nbuf-1) - 1];
N    char_type* __ob = __o;
N    unique_ptr<char_type, void(*)(void*)> __obh(0, _LIBCPP_FREE);
X    unique_ptr<char_type, void(*)(void*)> __obh(0, [] (void *p) { free(p); });
N    if (__nb != __nar)
N    {
N        __ob = (char_type*)malloc(2*static_cast<size_t>(__nc)*sizeof(char_type));
N        if (__ob == 0)
N            __throw_bad_alloc();
N        __obh.reset(__ob);
N    }
N    char_type* __op;  // pad here
N    char_type* __oe;  // end of output
N    this->__widen_and_group_float(__nb, __np, __ne, __ob, __op, __oe, __iob.getloc());
N    // [__o, __oe) contains thousands_sep'd wide number
N    // Stage 3 & 4
N    __s = __pad_and_output(__s, __ob, __op, __oe, __iob, __fl);
N    return __s;
N}
N
Ntemplate <class _CharT, class _OutputIterator>
N_OutputIterator
Nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
N                                         char_type __fl, long double __v) const
N{
N    // Stage 1 - Get number in narrow char
N    char __fmt[8] = {'%', 0};
N    const char* __len = "L";
N    bool __specify_precision = this->__format_float(__fmt+1, __len, __iob.flags());
N    const unsigned __nbuf = 30;
N    char __nar[__nbuf];
N    char* __nb = __nar;
N    int __nc;
N    if (__specify_precision)
N        __nc = __libcpp_snprintf_l(__nb, __nbuf, _LIBCPP_GET_C_LOCALE, __fmt,
N                                   (int)__iob.precision(), __v);
X        __nc = snprintf_l(__nb, __nbuf, __cloc(), __fmt, (int)__iob . precision(), __v);
N    else
N        __nc = __libcpp_snprintf_l(__nb, __nbuf, _LIBCPP_GET_C_LOCALE, __fmt, __v);
X        __nc = snprintf_l(__nb, __nbuf, __cloc(), __fmt, __v);
N    unique_ptr<char, void(*)(void*)> __nbh(0, _LIBCPP_FREE);
X    unique_ptr<char, void(*)(void*)> __nbh(0, [] (void *p) { free(p); });
N    if (__nc > static_cast<int>(__nbuf-1))
N    {
N        if (__specify_precision)
N            __nc = __libcpp_asprintf_l(&__nb, _LIBCPP_GET_C_LOCALE, __fmt, (int)__iob.precision(), __v);
X            __nc = asprintf_l(&__nb, __cloc(), __fmt, (int)__iob . precision(), __v);
N        else
N            __nc = __libcpp_asprintf_l(&__nb, _LIBCPP_GET_C_LOCALE, __fmt, __v);
X            __nc = asprintf_l(&__nb, __cloc(), __fmt, __v);
N        if (__nb == 0)
N            __throw_bad_alloc();
N        __nbh.reset(__nb);
N    }
N    char* __ne = __nb + __nc;
N    char* __np = this->__identify_padding(__nb, __ne, __iob);
N    // Stage 2 - Widen __nar while adding thousands separators
N    char_type __o[2*(__nbuf-1) - 1];
N    char_type* __ob = __o;
N    unique_ptr<char_type, void(*)(void*)> __obh(0, _LIBCPP_FREE);
X    unique_ptr<char_type, void(*)(void*)> __obh(0, [] (void *p) { free(p); });
N    if (__nb != __nar)
N    {
N        __ob = (char_type*)malloc(2*static_cast<size_t>(__nc)*sizeof(char_type));
N        if (__ob == 0)
N            __throw_bad_alloc();
N        __obh.reset(__ob);
N    }
N    char_type* __op;  // pad here
N    char_type* __oe;  // end of output
N    this->__widen_and_group_float(__nb, __np, __ne, __ob, __op, __oe, __iob.getloc());
N    // [__o, __oe) contains thousands_sep'd wide number
N    // Stage 3 & 4
N    __s = __pad_and_output(__s, __ob, __op, __oe, __iob, __fl);
N    return __s;
N}
N
Ntemplate <class _CharT, class _OutputIterator>
N_OutputIterator
Nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
N                                         char_type __fl, const void* __v) const
N{
N    // Stage 1 - Get pointer in narrow char
N    char __fmt[6] = "%p";
N    const unsigned __nbuf = 20;
N    char __nar[__nbuf];
N    int __nc = __libcpp_snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);
X    int __nc = snprintf_l(__nar, sizeof(__nar), __cloc(), __fmt, __v);
N    char* __ne = __nar + __nc;
N    char* __np = this->__identify_padding(__nar, __ne, __iob);
N    // Stage 2 - Widen __nar
N    char_type __o[2*(__nbuf-1) - 1];
N    char_type* __op;  // pad here
N    char_type* __oe;  // end of output
N    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
N    __ct.widen(__nar, __ne, __o);
N    __oe = __o + (__ne - __nar);
N    if (__np == __ne)
N        __op = __oe;
N    else
N        __op = __o + (__np - __nar);
N    // [__o, __oe) contains wide number
N    // Stage 3 & 4
N    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
N}
N
N_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS num_put<char>)
Xextern template class num_put<char>;
N_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS num_put<wchar_t>)
Xextern template class num_put<wchar_t>;
N
Ntemplate <class _CharT, class _InputIterator>
N_LIBCPP_HIDDEN
X
Nint
N__get_up_to_n_digits(_InputIterator& __b, _InputIterator __e,
N                     ios_base::iostate& __err, const ctype<_CharT>& __ct, int __n)
N{
N    // Precondition:  __n >= 1
N    if (__b == __e)
N    {
N        __err |= ios_base::eofbit | ios_base::failbit;
N        return 0;
N    }
N    // get first digit
N    _CharT __c = *__b;
N    if (!__ct.is(ctype_base::digit, __c))
N    {
N        __err |= ios_base::failbit;
N        return 0;
N    }
N    int __r = __ct.narrow(__c, 0) - '0';
N    for (++__b, (void) --__n; __b != __e && __n > 0; ++__b, (void) --__n)
N    {
N        // get next digit
N        __c = *__b;
N        if (!__ct.is(ctype_base::digit, __c))
N            return __r;
N        __r = __r * 10 + __ct.narrow(__c, 0) - '0';
N    }
N    if (__b == __e)
N        __err |= ios_base::eofbit;
N    return __r;
N}
N
Nclass _LIBCPP_TYPE_VIS time_base
Xclass  time_base
N{
Npublic:
N    enum __attribute__((packed)) dateorder {no_order, dmy, mdy, ymd, ydm};
N};
N
Ntemplate <class _CharT>
Nclass _LIBCPP_TEMPLATE_VIS __time_get_c_storage
Xclass  __time_get_c_storage
N{
Nprotected:
N    typedef basic_string<_CharT> string_type;
N
N    virtual const string_type* __weeks() const;
N    virtual const string_type* __months() const;
N    virtual const string_type* __am_pm() const;
N    virtual const string_type& __c() const;
N    virtual const string_type& __r() const;
N    virtual const string_type& __x() const;
N    virtual const string_type& __X() const;
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    ~__time_get_c_storage() {}
N};
N
Ntemplate <> _LIBCPP_FUNC_VIS const string* __time_get_c_storage<char>::__weeks() const;
Xtemplate <>  const string* __time_get_c_storage<char>::__weeks() const;
Ntemplate <> _LIBCPP_FUNC_VIS const string* __time_get_c_storage<char>::__months() const;
Xtemplate <>  const string* __time_get_c_storage<char>::__months() const;
Ntemplate <> _LIBCPP_FUNC_VIS const string* __time_get_c_storage<char>::__am_pm() const;
Xtemplate <>  const string* __time_get_c_storage<char>::__am_pm() const;
Ntemplate <> _LIBCPP_FUNC_VIS const string& __time_get_c_storage<char>::__c() const;
Xtemplate <>  const string& __time_get_c_storage<char>::__c() const;
Ntemplate <> _LIBCPP_FUNC_VIS const string& __time_get_c_storage<char>::__r() const;
Xtemplate <>  const string& __time_get_c_storage<char>::__r() const;
Ntemplate <> _LIBCPP_FUNC_VIS const string& __time_get_c_storage<char>::__x() const;
Xtemplate <>  const string& __time_get_c_storage<char>::__x() const;
Ntemplate <> _LIBCPP_FUNC_VIS const string& __time_get_c_storage<char>::__X() const;
Xtemplate <>  const string& __time_get_c_storage<char>::__X() const;
N
Ntemplate <> _LIBCPP_FUNC_VIS const wstring* __time_get_c_storage<wchar_t>::__weeks() const;
Xtemplate <>  const wstring* __time_get_c_storage<wchar_t>::__weeks() const;
Ntemplate <> _LIBCPP_FUNC_VIS const wstring* __time_get_c_storage<wchar_t>::__months() const;
Xtemplate <>  const wstring* __time_get_c_storage<wchar_t>::__months() const;
Ntemplate <> _LIBCPP_FUNC_VIS const wstring* __time_get_c_storage<wchar_t>::__am_pm() const;
Xtemplate <>  const wstring* __time_get_c_storage<wchar_t>::__am_pm() const;
Ntemplate <> _LIBCPP_FUNC_VIS const wstring& __time_get_c_storage<wchar_t>::__c() const;
Xtemplate <>  const wstring& __time_get_c_storage<wchar_t>::__c() const;
Ntemplate <> _LIBCPP_FUNC_VIS const wstring& __time_get_c_storage<wchar_t>::__r() const;
Xtemplate <>  const wstring& __time_get_c_storage<wchar_t>::__r() const;
Ntemplate <> _LIBCPP_FUNC_VIS const wstring& __time_get_c_storage<wchar_t>::__x() const;
Xtemplate <>  const wstring& __time_get_c_storage<wchar_t>::__x() const;
Ntemplate <> _LIBCPP_FUNC_VIS const wstring& __time_get_c_storage<wchar_t>::__X() const;
Xtemplate <>  const wstring& __time_get_c_storage<wchar_t>::__X() const;
N
Ntemplate <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >
Nclass _LIBCPP_TEMPLATE_VIS time_get
Xclass  time_get
N    : public locale::facet,
N      public time_base,
N      private __time_get_c_storage<_CharT>
N{
Npublic:
N    typedef _CharT                  char_type;
N    typedef _InputIterator          iter_type;
N    typedef time_base::dateorder    dateorder;
N    typedef basic_string<char_type> string_type;
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    explicit time_get(size_t __refs = 0)
N        : locale::facet(__refs) {}
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    dateorder date_order() const
N    {
N        return this->do_date_order();
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    iter_type get_time(iter_type __b, iter_type __e, ios_base& __iob,
N                       ios_base::iostate& __err, tm* __tm) const
N    {
N        return do_get_time(__b, __e, __iob, __err, __tm);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    iter_type get_date(iter_type __b, iter_type __e, ios_base& __iob,
N                       ios_base::iostate& __err, tm* __tm) const
N    {
N        return do_get_date(__b, __e, __iob, __err, __tm);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    iter_type get_weekday(iter_type __b, iter_type __e, ios_base& __iob,
N                          ios_base::iostate& __err, tm* __tm) const
N    {
N        return do_get_weekday(__b, __e, __iob, __err, __tm);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    iter_type get_monthname(iter_type __b, iter_type __e, ios_base& __iob,
N                            ios_base::iostate& __err, tm* __tm) const
N    {
N        return do_get_monthname(__b, __e, __iob, __err, __tm);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    iter_type get_year(iter_type __b, iter_type __e, ios_base& __iob,
N                       ios_base::iostate& __err, tm* __tm) const
N    {
N        return do_get_year(__b, __e, __iob, __err, __tm);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
N                  ios_base::iostate& __err, tm *__tm,
N                  char __fmt, char __mod = 0) const
N    {
N        return do_get(__b, __e, __iob, __err, __tm, __fmt, __mod);
N    }
N
N    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
N                  ios_base::iostate& __err, tm* __tm,
N                  const char_type* __fmtb, const char_type* __fmte) const;
N
N    static _DATA_ACCESS locale::id id;
X    static  locale::id id;
N
Nprotected:
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    ~time_get() {}
N
N    virtual dateorder do_date_order() const;
N    virtual iter_type do_get_time(iter_type __b, iter_type __e, ios_base& __iob,
N                                  ios_base::iostate& __err, tm* __tm) const;
N    virtual iter_type do_get_date(iter_type __b, iter_type __e, ios_base& __iob,
N                                  ios_base::iostate& __err, tm* __tm) const;
N    virtual iter_type do_get_weekday(iter_type __b, iter_type __e, ios_base& __iob,
N                                     ios_base::iostate& __err, tm* __tm) const;
N    virtual iter_type do_get_monthname(iter_type __b, iter_type __e, ios_base& __iob,
N                                       ios_base::iostate& __err, tm* __tm) const;
N    virtual iter_type do_get_year(iter_type __b, iter_type __e, ios_base& __iob,
N                                  ios_base::iostate& __err, tm* __tm) const;
N    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
N                             ios_base::iostate& __err, tm* __tm,
N                             char __fmt, char __mod) const;
Nprivate:
N    void __get_white_space(iter_type& __b, iter_type __e,
N                           ios_base::iostate& __err, const ctype<char_type>& __ct) const;
N    void __get_percent(iter_type& __b, iter_type __e, ios_base::iostate& __err,
N                       const ctype<char_type>& __ct) const;
N
N    void __get_weekdayname(int& __m,
N                           iter_type& __b, iter_type __e,
N                           ios_base::iostate& __err,
N                           const ctype<char_type>& __ct) const;
N    void __get_monthname(int& __m,
N                         iter_type& __b, iter_type __e,
N                         ios_base::iostate& __err,
N                         const ctype<char_type>& __ct) const;
N    void __get_day(int& __d,
N                   iter_type& __b, iter_type __e,
N                   ios_base::iostate& __err,
N                   const ctype<char_type>& __ct) const;
N    void __get_month(int& __m,
N                     iter_type& __b, iter_type __e,
N                     ios_base::iostate& __err,
N                     const ctype<char_type>& __ct) const;
N    void __get_year(int& __y,
N                   iter_type& __b, iter_type __e,
N                   ios_base::iostate& __err,
N                   const ctype<char_type>& __ct) const;
N    void __get_year4(int& __y,
N                    iter_type& __b, iter_type __e,
N                    ios_base::iostate& __err,
N                    const ctype<char_type>& __ct) const;
N    void __get_hour(int& __d,
N                    iter_type& __b, iter_type __e,
N                    ios_base::iostate& __err,
N                    const ctype<char_type>& __ct) const;
N    void __get_12_hour(int& __h,
N                       iter_type& __b, iter_type __e,
N                       ios_base::iostate& __err,
N                       const ctype<char_type>& __ct) const;
N    void __get_am_pm(int& __h,
N                     iter_type& __b, iter_type __e,
N                     ios_base::iostate& __err,
N                     const ctype<char_type>& __ct) const;
N    void __get_minute(int& __m,
N                      iter_type& __b, iter_type __e,
N                      ios_base::iostate& __err,
N                      const ctype<char_type>& __ct) const;
N    void __get_second(int& __s,
N                      iter_type& __b, iter_type __e,
N                      ios_base::iostate& __err,
N                      const ctype<char_type>& __ct) const;
N    void __get_weekday(int& __w,
N                       iter_type& __b, iter_type __e,
N                       ios_base::iostate& __err,
N                       const ctype<char_type>& __ct) const;
N    void __get_day_year_num(int& __w,
N                            iter_type& __b, iter_type __e,
N                            ios_base::iostate& __err,
N                            const ctype<char_type>& __ct) const;
N};
N
Ntemplate <class _CharT, class _InputIterator>
Nlocale::id
Ntime_get<_CharT, _InputIterator>::id;
N
N// time_get primitives
N
Ntemplate <class _CharT, class _InputIterator>
Nvoid
Ntime_get<_CharT, _InputIterator>::__get_weekdayname(int& __w,
N                                                    iter_type& __b, iter_type __e,
N                                                    ios_base::iostate& __err,
N                                                    const ctype<char_type>& __ct) const
N{
N    // Note:  ignoring case comes from the POSIX strptime spec
N    const string_type* __wk = this->__weeks();
N    ptrdiff_t __i = __scan_keyword(__b, __e, __wk, __wk+14, __ct, __err, false) - __wk;
N    if (__i < 14)
N        __w = __i % 7;
N}
N
Ntemplate <class _CharT, class _InputIterator>
Nvoid
Ntime_get<_CharT, _InputIterator>::__get_monthname(int& __m,
N                                                  iter_type& __b, iter_type __e,
N                                                  ios_base::iostate& __err,
N                                                  const ctype<char_type>& __ct) const
N{
N    // Note:  ignoring case comes from the POSIX strptime spec
N    const string_type* __month = this->__months();
N    ptrdiff_t __i = __scan_keyword(__b, __e, __month, __month+24, __ct, __err, false) - __month;
N    if (__i < 24)
N        __m = __i % 12;
N}
N
Ntemplate <class _CharT, class _InputIterator>
Nvoid
Ntime_get<_CharT, _InputIterator>::__get_day(int& __d,
N                                            iter_type& __b, iter_type __e,
N                                            ios_base::iostate& __err,
N                                            const ctype<char_type>& __ct) const
N{
N    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
N    if (!(__err & ios_base::failbit) && 1 <= __t && __t <= 31)
N        __d = __t;
N    else
N        __err |= ios_base::failbit;
N}
N
Ntemplate <class _CharT, class _InputIterator>
Nvoid
Ntime_get<_CharT, _InputIterator>::__get_month(int& __m,
N                                              iter_type& __b, iter_type __e,
N                                              ios_base::iostate& __err,
N                                              const ctype<char_type>& __ct) const
N{
N    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2) - 1;
N    if (!(__err & ios_base::failbit) && __t <= 11)
N        __m = __t;
N    else
N        __err |= ios_base::failbit;
N}
N
Ntemplate <class _CharT, class _InputIterator>
Nvoid
Ntime_get<_CharT, _InputIterator>::__get_year(int& __y,
N                                             iter_type& __b, iter_type __e,
N                                             ios_base::iostate& __err,
N                                             const ctype<char_type>& __ct) const
N{
N    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 4);
N    if (!(__err & ios_base::failbit))
N    {
N        if (__t < 69)
N            __t += 2000;
N        else if (69 <= __t && __t <= 99)
N            __t += 1900;
N        __y = __t - 1900;
N    }
N}
N
Ntemplate <class _CharT, class _InputIterator>
Nvoid
Ntime_get<_CharT, _InputIterator>::__get_year4(int& __y,
N                                              iter_type& __b, iter_type __e,
N                                              ios_base::iostate& __err,
N                                              const ctype<char_type>& __ct) const
N{
N    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 4);
N    if (!(__err & ios_base::failbit))
N        __y = __t - 1900;
N}
N
Ntemplate <class _CharT, class _InputIterator>
Nvoid
Ntime_get<_CharT, _InputIterator>::__get_hour(int& __h,
N                                             iter_type& __b, iter_type __e,
N                                             ios_base::iostate& __err,
N                                             const ctype<char_type>& __ct) const
N{
N    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
N    if (!(__err & ios_base::failbit) && __t <= 23)
N        __h = __t;
N    else
N        __err |= ios_base::failbit;
N}
N
Ntemplate <class _CharT, class _InputIterator>
Nvoid
Ntime_get<_CharT, _InputIterator>::__get_12_hour(int& __h,
N                                                iter_type& __b, iter_type __e,
N                                                ios_base::iostate& __err,
N                                                const ctype<char_type>& __ct) const
N{
N    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
N    if (!(__err & ios_base::failbit) && 1 <= __t && __t <= 12)
N        __h = __t;
N    else
N        __err |= ios_base::failbit;
N}
N
Ntemplate <class _CharT, class _InputIterator>
Nvoid
Ntime_get<_CharT, _InputIterator>::__get_minute(int& __m,
N                                               iter_type& __b, iter_type __e,
N                                               ios_base::iostate& __err,
N                                               const ctype<char_type>& __ct) const
N{
N    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
N    if (!(__err & ios_base::failbit) && __t <= 59)
N        __m = __t;
N    else
N        __err |= ios_base::failbit;
N}
N
Ntemplate <class _CharT, class _InputIterator>
Nvoid
Ntime_get<_CharT, _InputIterator>::__get_second(int& __s,
N                                               iter_type& __b, iter_type __e,
N                                               ios_base::iostate& __err,
N                                               const ctype<char_type>& __ct) const
N{
N    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
N    if (!(__err & ios_base::failbit) && __t <= 60)
N        __s = __t;
N    else
N        __err |= ios_base::failbit;
N}
N
Ntemplate <class _CharT, class _InputIterator>
Nvoid
Ntime_get<_CharT, _InputIterator>::__get_weekday(int& __w,
N                                                iter_type& __b, iter_type __e,
N                                                ios_base::iostate& __err,
N                                                const ctype<char_type>& __ct) const
N{
N    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 1);
N    if (!(__err & ios_base::failbit) && __t <= 6)
N        __w = __t;
N    else
N        __err |= ios_base::failbit;
N}
N
Ntemplate <class _CharT, class _InputIterator>
Nvoid
Ntime_get<_CharT, _InputIterator>::__get_day_year_num(int& __d,
N                                                     iter_type& __b, iter_type __e,
N                                                     ios_base::iostate& __err,
N                                                     const ctype<char_type>& __ct) const
N{
N    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 3);
N    if (!(__err & ios_base::failbit) && __t <= 365)
N        __d = __t;
N    else
N        __err |= ios_base::failbit;
N}
N
Ntemplate <class _CharT, class _InputIterator>
Nvoid
Ntime_get<_CharT, _InputIterator>::__get_white_space(iter_type& __b, iter_type __e,
N                                                    ios_base::iostate& __err,
N                                                    const ctype<char_type>& __ct) const
N{
N    for (; __b != __e && __ct.is(ctype_base::space, *__b); ++__b)
N        ;
N    if (__b == __e)
N        __err |= ios_base::eofbit;
N}
N
Ntemplate <class _CharT, class _InputIterator>
Nvoid
Ntime_get<_CharT, _InputIterator>::__get_am_pm(int& __h,
N                                              iter_type& __b, iter_type __e,
N                                              ios_base::iostate& __err,
N                                              const ctype<char_type>& __ct) const
N{
N    const string_type* __ap = this->__am_pm();
N    if (__ap[0].size() + __ap[1].size() == 0)
N    {
N        __err |= ios_base::failbit;
N        return;
N    }
N    ptrdiff_t __i = __scan_keyword(__b, __e, __ap, __ap+2, __ct, __err, false) - __ap;
N    if (__i == 0 && __h == 12)
N        __h = 0;
N    else if (__i == 1 && __h < 12)
N        __h += 12;
N}
N
Ntemplate <class _CharT, class _InputIterator>
Nvoid
Ntime_get<_CharT, _InputIterator>::__get_percent(iter_type& __b, iter_type __e,
N                                                ios_base::iostate& __err,
N                                                const ctype<char_type>& __ct) const
N{
N    if (__b == __e)
N    {
N        __err |= ios_base::eofbit | ios_base::failbit;
N        return;
N    }
N    if (__ct.narrow(*__b, 0) != '%')
N        __err |= ios_base::failbit;
N    else if(++__b == __e)
N        __err |= ios_base::eofbit;
N}
N
N// time_get end primitives
N
Ntemplate <class _CharT, class _InputIterator>
N_InputIterator
Ntime_get<_CharT, _InputIterator>::get(iter_type __b, iter_type __e,
N                                      ios_base& __iob,
N                                      ios_base::iostate& __err, tm* __tm,
N                                      const char_type* __fmtb, const char_type* __fmte) const
N{
N    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
N    __err = ios_base::goodbit;
N    while (__fmtb != __fmte && __err == ios_base::goodbit)
N    {
N        if (__b == __e)
N        {
N            __err = ios_base::failbit;
N            break;
N        }
N        if (__ct.narrow(*__fmtb, 0) == '%')
N        {
N            if (++__fmtb == __fmte)
N            {
N                __err = ios_base::failbit;
N                break;
N            }
N            char __cmd = __ct.narrow(*__fmtb, 0);
N            char __opt = '\0';
N            if (__cmd == 'E' || __cmd == '0')
N            {
N                if (++__fmtb == __fmte)
N                {
N                    __err = ios_base::failbit;
N                    break;
N                }
N                __opt = __cmd;
N                __cmd = __ct.narrow(*__fmtb, 0);
N            }
N            __b = do_get(__b, __e, __iob, __err, __tm, __cmd, __opt);
N            ++__fmtb;
N        }
N        else if (__ct.is(ctype_base::space, *__fmtb))
N        {
N            for (++__fmtb; __fmtb != __fmte && __ct.is(ctype_base::space, *__fmtb); ++__fmtb)
N                ;
N            for (        ;    __b != __e    && __ct.is(ctype_base::space, *__b);    ++__b)
N                ;
N        }
N        else if (__ct.toupper(*__b) == __ct.toupper(*__fmtb))
N        {
N            ++__b;
N            ++__fmtb;
N        }
N        else
N            __err = ios_base::failbit;
N    }
N    if (__b == __e)
N        __err |= ios_base::eofbit;
N    return __b;
N}
N
Ntemplate <class _CharT, class _InputIterator>
Ntypename time_get<_CharT, _InputIterator>::dateorder
Ntime_get<_CharT, _InputIterator>::do_date_order() const
N{
N    return mdy;
N}
N
Ntemplate <class _CharT, class _InputIterator>
N_InputIterator
Ntime_get<_CharT, _InputIterator>::do_get_time(iter_type __b, iter_type __e,
N                                              ios_base& __iob,
N                                              ios_base::iostate& __err,
N                                              tm* __tm) const
N{
N    const char_type __fmt[] = {'%', 'H', ':', '%', 'M', ':', '%', 'S'};
N    return get(__b, __e, __iob, __err, __tm, __fmt, __fmt + sizeof(__fmt)/sizeof(__fmt[0]));
N}
N
Ntemplate <class _CharT, class _InputIterator>
N_InputIterator
Ntime_get<_CharT, _InputIterator>::do_get_date(iter_type __b, iter_type __e,
N                                              ios_base& __iob,
N                                              ios_base::iostate& __err,
N                                              tm* __tm) const
N{
N    const string_type& __fmt = this->__x();
N    return get(__b, __e, __iob, __err, __tm, __fmt.data(), __fmt.data() + __fmt.size());
N}
N
Ntemplate <class _CharT, class _InputIterator>
N_InputIterator
Ntime_get<_CharT, _InputIterator>::do_get_weekday(iter_type __b, iter_type __e,
N                                                 ios_base& __iob,
N                                                 ios_base::iostate& __err,
N                                                 tm* __tm) const
N{
N    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
N    __get_weekdayname(__tm->tm_wday, __b, __e, __err, __ct);
N    return __b;
N}
N
Ntemplate <class _CharT, class _InputIterator>
N_InputIterator
Ntime_get<_CharT, _InputIterator>::do_get_monthname(iter_type __b, iter_type __e,
N                                                   ios_base& __iob,
N                                                   ios_base::iostate& __err,
N                                                   tm* __tm) const
N{
N    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
N    __get_monthname(__tm->tm_mon, __b, __e, __err, __ct);
N    return __b;
N}
N
Ntemplate <class _CharT, class _InputIterator>
N_InputIterator
Ntime_get<_CharT, _InputIterator>::do_get_year(iter_type __b, iter_type __e,
N                                              ios_base& __iob,
N                                              ios_base::iostate& __err,
N                                              tm* __tm) const
N{
N    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
N    __get_year(__tm->tm_year, __b, __e, __err, __ct);
N    return __b;
N}
N
Ntemplate <class _CharT, class _InputIterator>
N_InputIterator
Ntime_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
N                                         ios_base& __iob,
N                                         ios_base::iostate& __err, tm* __tm,
N                                         char __fmt, char) const
N{
N    __err = ios_base::goodbit;
N    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
N    switch (__fmt)
N    {
N    case 'a':
N    case 'A':
N        __get_weekdayname(__tm->tm_wday, __b, __e, __err, __ct);
N        break;
N    case 'b':
N    case 'B':
N    case 'h':
N        __get_monthname(__tm->tm_mon, __b, __e, __err, __ct);
N        break;
N    case 'c':
N        {
N        const string_type& __fm = this->__c();
N        __b = get(__b, __e, __iob, __err, __tm, __fm.data(), __fm.data() + __fm.size());
N        }
N        break;
N    case 'd':
N    case 'e':
N        __get_day(__tm->tm_mday, __b, __e, __err, __ct);
N        break;
N    case 'D':
N        {
N        const char_type __fm[] = {'%', 'm', '/', '%', 'd', '/', '%', 'y'};
N        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));
N        }
N        break;
N    case 'F':
N        {
N        const char_type __fm[] = {'%', 'Y', '-', '%', 'm', '-', '%', 'd'};
N        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));
N        }
N        break;
N    case 'H':
N        __get_hour(__tm->tm_hour, __b, __e, __err, __ct);
N        break;
N    case 'I':
N        __get_12_hour(__tm->tm_hour, __b, __e, __err, __ct);
N        break;
N    case 'j':
N        __get_day_year_num(__tm->tm_yday, __b, __e, __err, __ct);
N        break;
N    case 'm':
N        __get_month(__tm->tm_mon, __b, __e, __err, __ct);
N        break;
N    case 'M':
N        __get_minute(__tm->tm_min, __b, __e, __err, __ct);
N        break;
N    case 'n':
N    case 't':
N        __get_white_space(__b, __e, __err, __ct);
N        break;
N    case 'p':
N        __get_am_pm(__tm->tm_hour, __b, __e, __err, __ct);
N        break;
N    case 'r':
N        {
N        const char_type __fm[] = {'%', 'I', ':', '%', 'M', ':', '%', 'S', ' ', '%', 'p'};
N        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));
N        }
N        break;
N    case 'R':
N        {
N        const char_type __fm[] = {'%', 'H', ':', '%', 'M'};
N        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));
N        }
N        break;
N    case 'S':
N        __get_second(__tm->tm_sec, __b, __e, __err, __ct);
N        break;
N    case 'T':
N        {
N        const char_type __fm[] = {'%', 'H', ':', '%', 'M', ':', '%', 'S'};
N        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));
N        }
N        break;
N    case 'w':
N        __get_weekday(__tm->tm_wday, __b, __e, __err, __ct);
N        break;
N    case 'x':
N        return do_get_date(__b, __e, __iob, __err, __tm);
N    case 'X':
N        {
N        const string_type& __fm = this->__X();
N        __b = get(__b, __e, __iob, __err, __tm, __fm.data(), __fm.data() + __fm.size());
N        }
N        break;
N    case 'y':
N        __get_year(__tm->tm_year, __b, __e, __err, __ct);
N        break;
N    case 'Y':
N        __get_year4(__tm->tm_year, __b, __e, __err, __ct);
N        break;
N    case '%':
N        __get_percent(__b, __e, __err, __ct);
N        break;
N    default:
N        __err |= ios_base::failbit;
N    }
N    return __b;
N}
N
N_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_get<char>)
Xextern template class time_get<char>;
N_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_get<wchar_t>)
Xextern template class time_get<wchar_t>;
N
Nclass _LIBCPP_TYPE_VIS __time_get
Xclass  __time_get
N{
Nprotected:
N    locale_t __loc_;
N
N    __time_get(const char* __nm);
N    __time_get(const string& __nm);
N    ~__time_get();
N};
N
Ntemplate <class _CharT>
Nclass _LIBCPP_TEMPLATE_VIS __time_get_storage
Xclass  __time_get_storage
N    : public __time_get
N{
Nprotected:
N    typedef basic_string<_CharT> string_type;
N
N    string_type __weeks_[14];
N    string_type __months_[24];
N    string_type __am_pm_[2];
N    string_type __c_;
N    string_type __r_;
N    string_type __x_;
N    string_type __X_;
N
N    explicit __time_get_storage(const char* __nm);
N    explicit __time_get_storage(const string& __nm);
N
N    _LIBCPP_ALWAYS_INLINE ~__time_get_storage() {}
X    __attribute__ ((__always_inline__)) ~__time_get_storage() {}
N
N    time_base::dateorder __do_date_order() const;
N
Nprivate:
N    void init(const ctype<_CharT>&);
N    string_type __analyze(char __fmt, const ctype<_CharT>&);
N};
N
Ntemplate <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >
Nclass _LIBCPP_TEMPLATE_VIS time_get_byname
Xclass  time_get_byname
N    : public time_get<_CharT, _InputIterator>,
N      private __time_get_storage<_CharT>
N{
Npublic:
N    typedef time_base::dateorder    dateorder;
N    typedef _InputIterator          iter_type;
N    typedef _CharT                  char_type;
N    typedef basic_string<char_type> string_type;
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    explicit time_get_byname(const char* __nm, size_t __refs = 0)
N        : time_get<_CharT, _InputIterator>(__refs),
N          __time_get_storage<_CharT>(__nm) {}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    explicit time_get_byname(const string& __nm, size_t __refs = 0)
N        : time_get<_CharT, _InputIterator>(__refs),
N          __time_get_storage<_CharT>(__nm) {}
N
Nprotected:
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    ~time_get_byname() {}
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    virtual dateorder do_date_order() const {return this->__do_date_order();}
Nprivate:
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    virtual const string_type* __weeks() const  {return this->__weeks_;}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    virtual const string_type* __months() const {return this->__months_;}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    virtual const string_type* __am_pm() const  {return this->__am_pm_;}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    virtual const string_type& __c() const      {return this->__c_;}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    virtual const string_type& __r() const      {return this->__r_;}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    virtual const string_type& __x() const      {return this->__x_;}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    virtual const string_type& __X() const      {return this->__X_;}
N};
N
N_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_get_byname<char>)
Xextern template class time_get_byname<char>;
N_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_get_byname<wchar_t>)
Xextern template class time_get_byname<wchar_t>;
N
Nclass _LIBCPP_TYPE_VIS __time_put
Xclass  __time_put
N{
N    locale_t __loc_;
Nprotected:
N    _LIBCPP_ALWAYS_INLINE __time_put() : __loc_(_LIBCPP_GET_C_LOCALE) {}
X    __attribute__ ((__always_inline__)) __time_put() : __loc_(__cloc()) {}
N    __time_put(const char* __nm);
N    __time_put(const string& __nm);
N    ~__time_put();
N    void __do_put(char* __nb, char*& __ne, const tm* __tm,
N                  char __fmt, char __mod) const;
N    void __do_put(wchar_t* __wb, wchar_t*& __we, const tm* __tm,
N                  char __fmt, char __mod) const;
N};
N
Ntemplate <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >
Nclass _LIBCPP_TEMPLATE_VIS time_put
Xclass  time_put
N    : public locale::facet,
N      private __time_put
N{
Npublic:
N    typedef _CharT char_type;
N    typedef _OutputIterator iter_type;
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    explicit time_put(size_t __refs = 0)
N        : locale::facet(__refs) {}
N
N    iter_type put(iter_type __s, ios_base& __iob, char_type __fl, const tm* __tm,
N                  const char_type* __pb, const char_type* __pe) const;
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
N                  const tm* __tm, char __fmt, char __mod = 0) const
N    {
N        return do_put(__s, __iob, __fl, __tm, __fmt, __mod);
N    }
N
N    static _DATA_ACCESS locale::id id;
X    static  locale::id id;
N
Nprotected:
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    ~time_put() {}
N    virtual iter_type do_put(iter_type __s, ios_base&, char_type, const tm* __tm,
N                             char __fmt, char __mod) const;
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    explicit time_put(const char* __nm, size_t __refs)
N        : locale::facet(__refs),
N          __time_put(__nm) {}
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    explicit time_put(const string& __nm, size_t __refs)
N        : locale::facet(__refs),
N          __time_put(__nm) {}
N};
N
Ntemplate <class _CharT, class _OutputIterator>
Nlocale::id
Ntime_put<_CharT, _OutputIterator>::id;
N
Ntemplate <class _CharT, class _OutputIterator>
N_OutputIterator
Ntime_put<_CharT, _OutputIterator>::put(iter_type __s, ios_base& __iob,
N                                       char_type __fl, const tm* __tm,
N                                       const char_type* __pb,
N                                       const char_type* __pe) const
N{
N    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
N    for (; __pb != __pe; ++__pb)
N    {
N        if (__ct.narrow(*__pb, 0) == '%')
N        {
N            if (++__pb == __pe)
N            {
N                *__s++ = __pb[-1];
N                break;
N            }
N            char __mod = 0;
N            char __fmt = __ct.narrow(*__pb, 0);
N            if (__fmt == 'E' || __fmt == 'O')
N            {
N                if (++__pb == __pe)
N                {
N                    *__s++ = __pb[-2];
N                    *__s++ = __pb[-1];
N                    break;
N                }
N                __mod = __fmt;
N                __fmt = __ct.narrow(*__pb, 0);
N            }
N            __s = do_put(__s, __iob, __fl, __tm, __fmt, __mod);
N        }
N        else
N            *__s++ = *__pb;
N    }
N    return __s;
N}
N
Ntemplate <class _CharT, class _OutputIterator>
N_OutputIterator
Ntime_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base&,
N                                          char_type, const tm* __tm,
N                                          char __fmt, char __mod) const
N{
N    char_type __nar[100];
N    char_type* __nb = __nar;
N    char_type* __ne = __nb + 100;
N    __do_put(__nb, __ne, __tm, __fmt, __mod);
N    return _VSTD::copy(__nb, __ne, __s);
X    return std::__2::copy(__nb, __ne, __s);
N}
N
N_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_put<char>)
Xextern template class time_put<char>;
N_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_put<wchar_t>)
Xextern template class time_put<wchar_t>;
N
Ntemplate <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >
Nclass _LIBCPP_TEMPLATE_VIS time_put_byname
Xclass  time_put_byname
N    : public time_put<_CharT, _OutputIterator>
N{
Npublic:
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    explicit time_put_byname(const char* __nm, size_t __refs = 0)
N        : time_put<_CharT, _OutputIterator>(__nm, __refs) {}
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    explicit time_put_byname(const string& __nm, size_t __refs = 0)
N        : time_put<_CharT, _OutputIterator>(__nm, __refs) {}
N
Nprotected:
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    ~time_put_byname() {}
N};
N
N_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_put_byname<char>)
Xextern template class time_put_byname<char>;
N_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_put_byname<wchar_t>)
Xextern template class time_put_byname<wchar_t>;
N
N// money_base
N
Nclass _LIBCPP_TYPE_VIS money_base
Xclass  money_base
N{
Npublic:
N    enum __attribute__((packed)) part {none, space, symbol, sign, value};
N    struct pattern {char field[4];};
N
N    _LIBCPP_ALWAYS_INLINE money_base() {}
X    __attribute__ ((__always_inline__)) money_base() {}
N};
N
N// moneypunct
N
Ntemplate <class _CharT, bool _International = false>
Nclass _LIBCPP_TEMPLATE_VIS moneypunct
Xclass  moneypunct
N    : public locale::facet,
N      public money_base
N{
Npublic:
N    typedef _CharT                  char_type;
N    typedef basic_string<char_type> string_type;
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    explicit moneypunct(size_t __refs = 0)
N        : locale::facet(__refs) {}
N
N    _LIBCPP_ALWAYS_INLINE char_type   decimal_point() const {return do_decimal_point();}
X    __attribute__ ((__always_inline__)) char_type   decimal_point() const {return do_decimal_point();}
N    _LIBCPP_ALWAYS_INLINE char_type   thousands_sep() const {return do_thousands_sep();}
X    __attribute__ ((__always_inline__)) char_type   thousands_sep() const {return do_thousands_sep();}
N    _LIBCPP_ALWAYS_INLINE string      grouping()      const {return do_grouping();}
X    __attribute__ ((__always_inline__)) string      grouping()      const {return do_grouping();}
N    _LIBCPP_ALWAYS_INLINE string_type curr_symbol()   const {return do_curr_symbol();}
X    __attribute__ ((__always_inline__)) string_type curr_symbol()   const {return do_curr_symbol();}
N    _LIBCPP_ALWAYS_INLINE string_type positive_sign() const {return do_positive_sign();}
X    __attribute__ ((__always_inline__)) string_type positive_sign() const {return do_positive_sign();}
N    _LIBCPP_ALWAYS_INLINE string_type negative_sign() const {return do_negative_sign();}
X    __attribute__ ((__always_inline__)) string_type negative_sign() const {return do_negative_sign();}
N    _LIBCPP_ALWAYS_INLINE int         frac_digits()   const {return do_frac_digits();}
X    __attribute__ ((__always_inline__)) int         frac_digits()   const {return do_frac_digits();}
N    _LIBCPP_ALWAYS_INLINE pattern     pos_format()    const {return do_pos_format();}
X    __attribute__ ((__always_inline__)) pattern     pos_format()    const {return do_pos_format();}
N    _LIBCPP_ALWAYS_INLINE pattern     neg_format()    const {return do_neg_format();}
X    __attribute__ ((__always_inline__)) pattern     neg_format()    const {return do_neg_format();}
N
N    static _DATA_ACCESS locale::id id;
X    static  locale::id id;
N    _DATA_ACCESS static const bool intl = _International;
X     static const bool intl = _International;
N
Nprotected:
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    ~moneypunct() {}
N
N    virtual char_type   do_decimal_point() const {return numeric_limits<char_type>::max();}
N    virtual char_type   do_thousands_sep() const {return numeric_limits<char_type>::max();}
N    virtual string      do_grouping()      const {return string();}
N    virtual string_type do_curr_symbol()   const {return string_type();}
N    virtual string_type do_positive_sign() const {return string_type();}
N    virtual string_type do_negative_sign() const {return string_type(1, '-');}
N    virtual int         do_frac_digits()   const {return 0;}
N    virtual pattern     do_pos_format()    const
N        {pattern __p = {{symbol, sign, none, value}}; return __p;}
N    virtual pattern     do_neg_format()    const
N        {pattern __p = {{symbol, sign, none, value}}; return __p;}
N};
N
Ntemplate <class _CharT, bool _International>
Nlocale::id
Nmoneypunct<_CharT, _International>::id;
N
Ntemplate <class _CharT, bool _International>
Nconst bool
Nmoneypunct<_CharT, _International>::intl;
N
N_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct<char, false>)
Xextern template class moneypunct<char, false>;
N_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct<char, true>)
Xextern template class moneypunct<char, true>;
N_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct<wchar_t, false>)
Xextern template class moneypunct<wchar_t, false>;
N_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct<wchar_t, true>)
Xextern template class moneypunct<wchar_t, true>;
N
N// moneypunct_byname
N
Ntemplate <class _CharT, bool _International = false>
Nclass _LIBCPP_TEMPLATE_VIS moneypunct_byname
Xclass  moneypunct_byname
N    : public moneypunct<_CharT, _International>
N{
Npublic:
N    typedef money_base::pattern  pattern;
N    typedef _CharT                  char_type;
N    typedef basic_string<char_type> string_type;
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    explicit moneypunct_byname(const char* __nm, size_t __refs = 0)
N        : moneypunct<_CharT, _International>(__refs) {init(__nm);}
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    explicit moneypunct_byname(const string& __nm, size_t __refs = 0)
N        : moneypunct<_CharT, _International>(__refs) {init(__nm.c_str());}
N
Nprotected:
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    ~moneypunct_byname() {}
N
N    virtual char_type   do_decimal_point() const {return __decimal_point_;}
N    virtual char_type   do_thousands_sep() const {return __thousands_sep_;}
N    virtual string      do_grouping()      const {return __grouping_;}
N    virtual string_type do_curr_symbol()   const {return __curr_symbol_;}
N    virtual string_type do_positive_sign() const {return __positive_sign_;}
N    virtual string_type do_negative_sign() const {return __negative_sign_;}
N    virtual int         do_frac_digits()   const {return __frac_digits_;}
N    virtual pattern     do_pos_format()    const {return __pos_format_;}
N    virtual pattern     do_neg_format()    const {return __neg_format_;}
N
Nprivate:
N    char_type   __decimal_point_;
N    char_type   __thousands_sep_;
N    string      __grouping_;
N    string_type __curr_symbol_;
N    string_type __positive_sign_;
N    string_type __negative_sign_;
N    int         __frac_digits_;
N    pattern     __pos_format_;
N    pattern     __neg_format_;
N
N    void init(const char*);
N};
N
Ntemplate<> _LIBCPP_FUNC_VIS void moneypunct_byname<char, false>::init(const char*);
Xtemplate<>  void moneypunct_byname<char, false>::init(const char*);
Ntemplate<> _LIBCPP_FUNC_VIS void moneypunct_byname<char, true>::init(const char*);
Xtemplate<>  void moneypunct_byname<char, true>::init(const char*);
Ntemplate<> _LIBCPP_FUNC_VIS void moneypunct_byname<wchar_t, false>::init(const char*);
Xtemplate<>  void moneypunct_byname<wchar_t, false>::init(const char*);
Ntemplate<> _LIBCPP_FUNC_VIS void moneypunct_byname<wchar_t, true>::init(const char*);
Xtemplate<>  void moneypunct_byname<wchar_t, true>::init(const char*);
N
N_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct_byname<char, false>)
Xextern template class moneypunct_byname<char, false>;
N_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct_byname<char, true>)
Xextern template class moneypunct_byname<char, true>;
N_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct_byname<wchar_t, false>)
Xextern template class moneypunct_byname<wchar_t, false>;
N_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct_byname<wchar_t, true>)
Xextern template class moneypunct_byname<wchar_t, true>;
N
N// money_get
N
Ntemplate <class _CharT>
Nclass __money_get
N{
Nprotected:
N    typedef _CharT                  char_type;
N    typedef basic_string<char_type> string_type;
N
N    _LIBCPP_ALWAYS_INLINE __money_get() {}
X    __attribute__ ((__always_inline__)) __money_get() {}
N
N    static void __gather_info(bool __intl, const locale& __loc,
N                              money_base::pattern& __pat, char_type& __dp,
N                              char_type& __ts, string& __grp,
N                              string_type& __sym, string_type& __psn,
N                              string_type& __nsn, int& __fd);
N};
N
Ntemplate <class _CharT>
Nvoid
N__money_get<_CharT>::__gather_info(bool __intl, const locale& __loc,
N                                   money_base::pattern& __pat, char_type& __dp,
N                                   char_type& __ts, string& __grp,
N                                   string_type& __sym, string_type& __psn,
N                                   string_type& __nsn, int& __fd)
N{
N    if (__intl)
N    {
N        const moneypunct<char_type, true>& __mp =
N            use_facet<moneypunct<char_type, true> >(__loc);
N        __pat = __mp.neg_format();
N        __nsn = __mp.negative_sign();
N        __psn = __mp.positive_sign();
N        __dp = __mp.decimal_point();
N        __ts = __mp.thousands_sep();
N        __grp = __mp.grouping();
N        __sym = __mp.curr_symbol();
N        __fd = __mp.frac_digits();
N    }
N    else
N    {
N        const moneypunct<char_type, false>& __mp =
N            use_facet<moneypunct<char_type, false> >(__loc);
N        __pat = __mp.neg_format();
N        __nsn = __mp.negative_sign();
N        __psn = __mp.positive_sign();
N        __dp = __mp.decimal_point();
N        __ts = __mp.thousands_sep();
N        __grp = __mp.grouping();
N        __sym = __mp.curr_symbol();
N        __fd = __mp.frac_digits();
N    }
N}
N
N_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __money_get<char>)
Xextern template class __money_get<char>;
N_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __money_get<wchar_t>)
Xextern template class __money_get<wchar_t>;
N
Ntemplate <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >
Nclass _LIBCPP_TEMPLATE_VIS money_get
Xclass  money_get
N    : public locale::facet,
N      private __money_get<_CharT>
N{
Npublic:
N    typedef _CharT                  char_type;
N    typedef _InputIterator          iter_type;
N    typedef basic_string<char_type> string_type;
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    explicit money_get(size_t __refs = 0)
N        : locale::facet(__refs) {}
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    iter_type get(iter_type __b, iter_type __e, bool __intl, ios_base& __iob,
N                  ios_base::iostate& __err, long double& __v) const
N    {
N        return do_get(__b, __e, __intl, __iob, __err, __v);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    iter_type get(iter_type __b, iter_type __e, bool __intl, ios_base& __iob,
N                  ios_base::iostate& __err, string_type& __v) const
N    {
N        return do_get(__b, __e, __intl, __iob, __err, __v);
N    }
N
N    static _DATA_ACCESS locale::id id;
X    static  locale::id id;
N
Nprotected:
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    ~money_get() {}
N
N    virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl,
N                             ios_base& __iob, ios_base::iostate& __err,
N                             long double& __v) const;
N    virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl,
N                             ios_base& __iob, ios_base::iostate& __err,
N                             string_type& __v) const;
N
Nprivate:
N    static bool __do_get(iter_type& __b, iter_type __e,
N                         bool __intl, const locale& __loc,
N                         ios_base::fmtflags __flags, ios_base::iostate& __err,
N                         bool& __neg, const ctype<char_type>& __ct,
N                         unique_ptr<char_type, void(*)(void*)>& __wb,
N                         char_type*& __wn, char_type* __we);
N};
N
Ntemplate <class _CharT, class _InputIterator>
Nlocale::id
Nmoney_get<_CharT, _InputIterator>::id;
N
N_LIBCPP_FUNC_VIS void __do_nothing(void*);
X void __do_nothing(void*);
N
Ntemplate <class _Tp>
N_LIBCPP_HIDDEN
X
Nvoid
N__double_or_nothing(unique_ptr<_Tp, void(*)(void*)>& __b, _Tp*& __n, _Tp*& __e)
N{
N    bool __owns = __b.get_deleter() != __do_nothing;
N    size_t __cur_cap = static_cast<size_t>(__e-__b.get()) * sizeof(_Tp);
N    size_t __new_cap = __cur_cap < numeric_limits<size_t>::max() / 2 ?
N                       2 * __cur_cap : numeric_limits<size_t>::max();
N    if (__new_cap == 0)
N        __new_cap = sizeof(_Tp);
N    size_t __n_off = static_cast<size_t>(__n - __b.get());
N    _Tp* __t = (_Tp*)realloc(__owns ? __b.get() : 0, __new_cap);
N    if (__t == 0)
N        __throw_bad_alloc();
N    if (__owns)
N        __b.release();
N    __b = unique_ptr<_Tp, void(*)(void*)>(__t, _LIBCPP_FREE);
X    __b = unique_ptr<_Tp, void(*)(void*)>(__t, [] (void *p) { free(p); });
N    __new_cap /= sizeof(_Tp);
N    __n = __b.get() + __n_off;
N    __e = __b.get() + __new_cap;
N}
N
N// true == success
Ntemplate <class _CharT, class _InputIterator>
Nbool
Nmoney_get<_CharT, _InputIterator>::__do_get(iter_type& __b, iter_type __e,
N                                            bool __intl, const locale& __loc,
N                                            ios_base::fmtflags __flags,
N                                            ios_base::iostate& __err,
N                                            bool& __neg,
N                                            const ctype<char_type>& __ct,
N                                            unique_ptr<char_type, void(*)(void*)>& __wb,
N                                            char_type*& __wn, char_type* __we)
N{
N    const unsigned __bz = 100;
N    unsigned __gbuf[__bz];
N    unique_ptr<unsigned, void(*)(void*)> __gb(__gbuf, __do_nothing);
N    unsigned* __gn = __gb.get();
N    unsigned* __ge = __gn + __bz;
N    money_base::pattern __pat;
N    char_type __dp;
N    char_type __ts;
N    string __grp;
N    string_type __sym;
N    string_type __psn;
N    string_type __nsn;
N    // Capture the spaces read into money_base::{space,none} so they
N    // can be compared to initial spaces in __sym.
N    string_type __spaces;
N    int __fd;
N    __money_get<_CharT>::__gather_info(__intl, __loc, __pat, __dp, __ts, __grp,
N                                       __sym, __psn, __nsn, __fd);
N    const string_type* __trailing_sign = 0;
N    __wn = __wb.get();
N    for (unsigned __p = 0; __p < 4 && __b != __e; ++__p)
N    {
N        switch (__pat.field[__p])
N        {
N        case money_base::space:
N            if (__p != 3)
N            {
N                if (__ct.is(ctype_base::space, *__b))
N                    __spaces.push_back(*__b++);
N                else
N                {
N                    __err |= ios_base::failbit;
N                    return false;
N                }
N            }
N            _LIBCPP_FALLTHROUGH();
X            ((void)0);
N        case money_base::none:
N            if (__p != 3)
N            {
N                while (__b != __e && __ct.is(ctype_base::space, *__b))
N                    __spaces.push_back(*__b++);
N            }
N            break;
N        case money_base::sign:
N            if (__psn.size() + __nsn.size() > 0)
N            {
N                if (__psn.size() == 0 || __nsn.size() == 0)
N                {   // sign is optional
N                    if (__psn.size() > 0)
N                    {   // __nsn.size() == 0
N                        if (*__b == __psn[0])
N                        {
N                            ++__b;
N                            if (__psn.size() > 1)
N                                __trailing_sign = &__psn;
N                        }
N                        else
N                            __neg = true;
N                    }
N                    else if (*__b == __nsn[0])  // __nsn.size() > 0 &&  __psn.size() == 0
N                    {
N                        ++__b;
N                        __neg = true;
N                        if (__nsn.size() > 1)
N                            __trailing_sign = &__nsn;
N                    }
N                }
N                else  // sign is required
N                {
N                    if (*__b == __psn[0])
N                    {
N                        ++__b;
N                        if (__psn.size() > 1)
N                            __trailing_sign = &__psn;
N                    }
N                    else if (*__b == __nsn[0])
N                    {
N                        ++__b;
N                        __neg = true;
N                        if (__nsn.size() > 1)
N                            __trailing_sign = &__nsn;
N                    }
N                    else
N                    {
N                        __err |= ios_base::failbit;
N                        return false;
N                    }
N                }
N            }
N            break;
N        case money_base::symbol:
N            {
N            bool __more_needed = __trailing_sign ||
N                                 (__p < 2)       ||
N                                 (__p == 2 && __pat.field[3] != static_cast<char>(money_base::none));
N            bool __sb = (__flags & ios_base::showbase) != 0;
N            if (__sb || __more_needed)
N            {
N                typename string_type::const_iterator __sym_space_end = __sym.begin();
N                if (__p > 0 && (__pat.field[__p - 1] == money_base::none ||
N                                __pat.field[__p - 1] == money_base::space)) {
N                    // Match spaces we've already read against spaces at
N                    // the beginning of __sym.
N                    while (__sym_space_end != __sym.end() &&
N                           __ct.is(ctype_base::space, *__sym_space_end))
N                        ++__sym_space_end;
N                    const size_t __num_spaces = __sym_space_end - __sym.begin();
N                    if (__num_spaces > __spaces.size() ||
N                        !equal(__spaces.end() - __num_spaces, __spaces.end(),
N                               __sym.begin())) {
N                        // No match. Put __sym_space_end back at the
N                        // beginning of __sym, which will prevent a
N                        // match in the next loop.
N                        __sym_space_end = __sym.begin();
N                    }
N                }
N                typename string_type::const_iterator __sym_curr_char = __sym_space_end;
N                while (__sym_curr_char != __sym.end() && __b != __e &&
N                       *__b == *__sym_curr_char) {
N                    ++__b;
N                    ++__sym_curr_char;
N                }
N                if (__sb && __sym_curr_char != __sym.end())
N                {
N                    __err |= ios_base::failbit;
N                    return false;
N                }
N            }
N            }
N            break;
N        case money_base::value:
N            {
N            unsigned __ng = 0;
N            for (; __b != __e; ++__b)
N            {
N                char_type __c = *__b;
N                if (__ct.is(ctype_base::digit, __c))
N                {
N                    if (__wn == __we)
N                        __double_or_nothing(__wb, __wn, __we);
N                    *__wn++ = __c;
N                    ++__ng;
N                }
N                else if (__grp.size() > 0 && __ng > 0 && __c == __ts)
N                {
N                    if (__gn == __ge)
N                        __double_or_nothing(__gb, __gn, __ge);
N                    *__gn++ = __ng;
N                    __ng = 0;
N                }
N                else
N                    break;
N            }
N            if (__gb.get() != __gn && __ng > 0)
N            {
N                if (__gn == __ge)
N                    __double_or_nothing(__gb, __gn, __ge);
N                *__gn++ = __ng;
N            }
N            if (__fd > 0)
N            {
N                if (__b == __e || *__b != __dp)
N                {
N                    __err |= ios_base::failbit;
N                    return false;
N                }
N                for (++__b; __fd > 0; --__fd, ++__b)
N                {
N                    if (__b == __e || !__ct.is(ctype_base::digit, *__b))
N                    {
N                        __err |= ios_base::failbit;
N                        return false;
N                    }
N                    if (__wn == __we)
N                        __double_or_nothing(__wb, __wn, __we);
N                    *__wn++ = *__b;
N                }
N            }
N            if (__wn == __wb.get())
N            {
N                __err |= ios_base::failbit;
N                return false;
N            }
N            }
N            break;
N        }
N    }
N    if (__trailing_sign)
N    {
N        for (unsigned __i = 1; __i < __trailing_sign->size(); ++__i, ++__b)
N        {
N            if (__b == __e || *__b != (*__trailing_sign)[__i])
N            {
N                __err |= ios_base::failbit;
N                return false;
N            }
N        }
N    }
N    if (__gb.get() != __gn)
N    {
N        ios_base::iostate __et = ios_base::goodbit;
N        __check_grouping(__grp, __gb.get(), __gn, __et);
N        if (__et)
N        {
N            __err |= ios_base::failbit;
N            return false;
N        }
N    }
N    return true;
N}
N
Ntemplate <class _CharT, class _InputIterator>
N_InputIterator
Nmoney_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
N                                          bool __intl, ios_base& __iob,
N                                          ios_base::iostate& __err,
N                                          long double& __v) const
N{
N    const int __bz = 100;
N    char_type __wbuf[__bz];
N    unique_ptr<char_type, void(*)(void*)> __wb(__wbuf, __do_nothing);
N    char_type* __wn;
N    char_type* __we = __wbuf + __bz;
N    locale __loc = __iob.getloc();
N    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);
N    bool __neg = false;
N    if (__do_get(__b, __e, __intl, __loc, __iob.flags(), __err, __neg, __ct,
N                 __wb, __wn, __we))
N    {
N        const char __src[] = "0123456789";
N        char_type __atoms[sizeof(__src)-1];
N        __ct.widen(__src, __src + (sizeof(__src)-1), __atoms);
N        char __nbuf[__bz];
N        char* __nc = __nbuf;
N        unique_ptr<char, void(*)(void*)> __h(0, _LIBCPP_FREE);
X        unique_ptr<char, void(*)(void*)> __h(0, [] (void *p) { free(p); });
N        if (__wn - __wb.get() > __bz-2)
N        {
N            __h.reset((char*)malloc(static_cast<size_t>(__wn - __wb.get() + 2)));
N            if (__h.get() == 0)
N                __throw_bad_alloc();
N            __nc = __h.get();
N        }
N        if (__neg)
N            *__nc++ = '-';
N        for (const char_type* __w = __wb.get(); __w < __wn; ++__w, ++__nc)
N            *__nc = __src[find(__atoms, _VSTD::end(__atoms), *__w) - __atoms];
X            *__nc = __src[find(__atoms, std::__2::end(__atoms), *__w) - __atoms];
N        *__nc = char();
N        if (sscanf(__nbuf, "%Lf", &__v) != 1)
N            __throw_runtime_error("money_get error");
N    }
N    if (__b == __e)
N        __err |= ios_base::eofbit;
N    return __b;
N}
N
Ntemplate <class _CharT, class _InputIterator>
N_InputIterator
Nmoney_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
N                                          bool __intl, ios_base& __iob,
N                                          ios_base::iostate& __err,
N                                          string_type& __v) const
N{
N    const int __bz = 100;
N    char_type __wbuf[__bz];
N    unique_ptr<char_type, void(*)(void*)> __wb(__wbuf, __do_nothing);
N    char_type* __wn;
N    char_type* __we = __wbuf + __bz;
N    locale __loc = __iob.getloc();
N    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);
N    bool __neg = false;
N    if (__do_get(__b, __e, __intl, __loc, __iob.flags(), __err, __neg, __ct,
N                 __wb, __wn, __we))
N    {
N        __v.clear();
N        if (__neg)
N            __v.push_back(__ct.widen('-'));
N        char_type __z = __ct.widen('0');
N        char_type* __w;
N        for (__w = __wb.get(); __w < __wn-1; ++__w)
N            if (*__w != __z)
N                break;
N        __v.append(__w, __wn);
N    }
N    if (__b == __e)
N        __err |= ios_base::eofbit;
N    return __b;
N}
N
N_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS money_get<char>)
Xextern template class money_get<char>;
N_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS money_get<wchar_t>)
Xextern template class money_get<wchar_t>;
N
N// money_put
N
Ntemplate <class _CharT>
Nclass __money_put
N{
Nprotected:
N    typedef _CharT                  char_type;
N    typedef basic_string<char_type> string_type;
N
N    _LIBCPP_ALWAYS_INLINE __money_put() {}
X    __attribute__ ((__always_inline__)) __money_put() {}
N
N    static void __gather_info(bool __intl, bool __neg, const locale& __loc,
N                              money_base::pattern& __pat, char_type& __dp,
N                              char_type& __ts, string& __grp,
N                              string_type& __sym, string_type& __sn,
N                              int& __fd);
N    static void __format(char_type* __mb, char_type*& __mi, char_type*& __me,
N                         ios_base::fmtflags __flags,
N                         const char_type* __db, const char_type* __de,
N                         const ctype<char_type>& __ct, bool __neg,
N                         const money_base::pattern& __pat, char_type __dp,
N                         char_type __ts, const string& __grp,
N                         const string_type& __sym, const string_type& __sn,
N                         int __fd);
N};
N
Ntemplate <class _CharT>
Nvoid
N__money_put<_CharT>::__gather_info(bool __intl, bool __neg, const locale& __loc,
N                                   money_base::pattern& __pat, char_type& __dp,
N                                   char_type& __ts, string& __grp,
N                                   string_type& __sym, string_type& __sn,
N                                   int& __fd)
N{
N    if (__intl)
N    {
N        const moneypunct<char_type, true>& __mp =
N            use_facet<moneypunct<char_type, true> >(__loc);
N        if (__neg)
N        {
N            __pat = __mp.neg_format();
N            __sn = __mp.negative_sign();
N        }
N        else
N        {
N            __pat = __mp.pos_format();
N            __sn = __mp.positive_sign();
N        }
N        __dp = __mp.decimal_point();
N        __ts = __mp.thousands_sep();
N        __grp = __mp.grouping();
N        __sym = __mp.curr_symbol();
N        __fd = __mp.frac_digits();
N    }
N    else
N    {
N        const moneypunct<char_type, false>& __mp =
N            use_facet<moneypunct<char_type, false> >(__loc);
N        if (__neg)
N        {
N            __pat = __mp.neg_format();
N            __sn = __mp.negative_sign();
N        }
N        else
N        {
N            __pat = __mp.pos_format();
N            __sn = __mp.positive_sign();
N        }
N        __dp = __mp.decimal_point();
N        __ts = __mp.thousands_sep();
N        __grp = __mp.grouping();
N        __sym = __mp.curr_symbol();
N        __fd = __mp.frac_digits();
N    }
N}
N
Ntemplate <class _CharT>
Nvoid
N__money_put<_CharT>::__format(char_type* __mb, char_type*& __mi, char_type*& __me,
N                              ios_base::fmtflags __flags,
N                              const char_type* __db, const char_type* __de,
N                              const ctype<char_type>& __ct, bool __neg,
N                              const money_base::pattern& __pat, char_type __dp,
N                              char_type __ts, const string& __grp,
N                              const string_type& __sym, const string_type& __sn,
N                              int __fd)
N{
N    __me = __mb;
N    for (unsigned __p = 0; __p < 4; ++__p)
N    {
N        switch (__pat.field[__p])
N        {
N        case money_base::none:
N            __mi = __me;
N            break;
N        case money_base::space:
N            __mi = __me;
N            *__me++ = __ct.widen(' ');
N            break;
N        case money_base::sign:
N            if (!__sn.empty())
N                *__me++ = __sn[0];
N            break;
N        case money_base::symbol:
N            if (!__sym.empty() && (__flags & ios_base::showbase))
N                __me = _VSTD::copy(__sym.begin(), __sym.end(), __me);
X                __me = std::__2::copy(__sym.begin(), __sym.end(), __me);
N            break;
N        case money_base::value:
N            {
N            // remember start of value so we can reverse it
N            char_type* __t = __me;
N            // find beginning of digits
N            if (__neg)
N                ++__db;
N            // find end of digits
N            const char_type* __d;
N            for (__d = __db; __d < __de; ++__d)
N                if (!__ct.is(ctype_base::digit, *__d))
N                    break;
N            // print fractional part
N            if (__fd > 0)
N            {
N                int __f;
N                for (__f = __fd; __d > __db && __f > 0; --__f)
N                    *__me++ = *--__d;
N                char_type __z = __f > 0 ? __ct.widen('0') : char_type();
N                for (; __f > 0; --__f)
N                    *__me++ = __z;
N                *__me++ = __dp;
N            }
N            // print units part
N            if (__d == __db)
N            {
N                *__me++ = __ct.widen('0');
N            }
N            else
N            {
N                unsigned __ng = 0;
N                unsigned __ig = 0;
N                unsigned __gl = __grp.empty() ? numeric_limits<unsigned>::max()
N                                              : static_cast<unsigned>(__grp[__ig]);
N                while (__d != __db)
N                {
N                    if (__ng == __gl)
N                    {
N                        *__me++ = __ts;
N                        __ng = 0;
N                        if (++__ig < __grp.size())
N                            __gl = __grp[__ig] == numeric_limits<char>::max() ?
N                                        numeric_limits<unsigned>::max() :
N                                        static_cast<unsigned>(__grp[__ig]);
N                    }
N                    *__me++ = *--__d;
N                    ++__ng;
N                }
N            }
N            // reverse it
N            reverse(__t, __me);
N            }
N            break;
N        }
N    }
N    // print rest of sign, if any
N    if (__sn.size() > 1)
N        __me = _VSTD::copy(__sn.begin()+1, __sn.end(), __me);
X        __me = std::__2::copy(__sn.begin()+1, __sn.end(), __me);
N    // set alignment
N    if ((__flags & ios_base::adjustfield) == ios_base::left)
N        __mi = __me;
N    else if ((__flags & ios_base::adjustfield) != ios_base::internal)
N        __mi = __mb;
N}
N
N_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __money_put<char>)
Xextern template class __money_put<char>;
N_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __money_put<wchar_t>)
Xextern template class __money_put<wchar_t>;
N
Ntemplate <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >
Nclass _LIBCPP_TEMPLATE_VIS money_put
Xclass  money_put
N    : public locale::facet,
N      private __money_put<_CharT>
N{
Npublic:
N    typedef _CharT                  char_type;
N    typedef _OutputIterator         iter_type;
N    typedef basic_string<char_type> string_type;
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    explicit money_put(size_t __refs = 0)
N        : locale::facet(__refs) {}
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    iter_type put(iter_type __s, bool __intl, ios_base& __iob, char_type __fl,
N                  long double __units) const
N    {
N        return do_put(__s, __intl, __iob, __fl, __units);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    iter_type put(iter_type __s, bool __intl, ios_base& __iob, char_type __fl,
N                  const string_type& __digits) const
N    {
N        return do_put(__s, __intl, __iob, __fl, __digits);
N    }
N
N    static _DATA_ACCESS locale::id id;
X    static  locale::id id;
N
Nprotected:
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    ~money_put() {}
N
N    virtual iter_type do_put(iter_type __s, bool __intl, ios_base& __iob,
N                             char_type __fl, long double __units) const;
N    virtual iter_type do_put(iter_type __s, bool __intl, ios_base& __iob,
N                             char_type __fl, const string_type& __digits) const;
N};
N
Ntemplate <class _CharT, class _OutputIterator>
Nlocale::id
Nmoney_put<_CharT, _OutputIterator>::id;
N
Ntemplate <class _CharT, class _OutputIterator>
N_OutputIterator
Nmoney_put<_CharT, _OutputIterator>::do_put(iter_type __s, bool __intl,
N                                           ios_base& __iob, char_type __fl,
N                                           long double __units) const
N{
N    // convert to char
N    const size_t __bs = 100;
N    char __buf[__bs];
N    char* __bb = __buf;
N    char_type __digits[__bs];
N    char_type* __db = __digits;
N    size_t __n = static_cast<size_t>(snprintf(__bb, __bs, "%.0Lf", __units));
N    unique_ptr<char, void(*)(void*)> __hn(0, _LIBCPP_FREE);
X    unique_ptr<char, void(*)(void*)> __hn(0, [] (void *p) { free(p); });
N    unique_ptr<char_type, void(*)(void*)> __hd(0, _LIBCPP_FREE);
X    unique_ptr<char_type, void(*)(void*)> __hd(0, [] (void *p) { free(p); });
N    // secure memory for digit storage
N    if (__n > __bs-1)
N    {
N        __n = static_cast<size_t>(__libcpp_asprintf_l(&__bb, _LIBCPP_GET_C_LOCALE, "%.0Lf", __units));
X        __n = static_cast<size_t>(asprintf_l(&__bb, __cloc(), "%.0Lf", __units));
N        if (__bb == 0)
N            __throw_bad_alloc();
N        __hn.reset(__bb);
N        __hd.reset((char_type*)malloc(__n * sizeof(char_type)));
N        if (__hd == nullptr)
N            __throw_bad_alloc();
N        __db = __hd.get();
N    }
N    // gather info
N    locale __loc = __iob.getloc();
N    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);
N    __ct.widen(__bb, __bb + __n, __db);
N    bool __neg = __n > 0 && __bb[0] == '-';
N    money_base::pattern __pat;
N    char_type __dp;
N    char_type __ts;
N    string __grp;
N    string_type __sym;
N    string_type __sn;
N    int __fd;
N    this->__gather_info(__intl, __neg, __loc, __pat, __dp, __ts, __grp, __sym, __sn, __fd);
N    // secure memory for formatting
N    char_type __mbuf[__bs];
N    char_type* __mb = __mbuf;
N    unique_ptr<char_type, void(*)(void*)> __hw(0, _LIBCPP_FREE);
X    unique_ptr<char_type, void(*)(void*)> __hw(0, [] (void *p) { free(p); });
N    size_t __exn = static_cast<int>(__n) > __fd ?
N                   (__n - static_cast<size_t>(__fd)) * 2 + __sn.size() +
N                    __sym.size() + static_cast<size_t>(__fd) + 1
N                 : __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 2;
N    if (__exn > __bs)
N    {
N        __hw.reset((char_type*)malloc(__exn * sizeof(char_type)));
N        __mb = __hw.get();
N        if (__mb == 0)
N            __throw_bad_alloc();
N    }
N    // format
N    char_type* __mi;
N    char_type* __me;
N    this->__format(__mb, __mi, __me, __iob.flags(),
N                   __db, __db + __n, __ct,
N                   __neg, __pat, __dp, __ts, __grp, __sym, __sn, __fd);
N    return __pad_and_output(__s, __mb, __mi, __me, __iob, __fl);
N}
N
Ntemplate <class _CharT, class _OutputIterator>
N_OutputIterator
Nmoney_put<_CharT, _OutputIterator>::do_put(iter_type __s, bool __intl,
N                                           ios_base& __iob, char_type __fl,
N                                           const string_type& __digits) const
N{
N    // gather info
N    locale __loc = __iob.getloc();
N    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);
N    bool __neg = __digits.size() > 0 && __digits[0] == __ct.widen('-');
N    money_base::pattern __pat;
N    char_type __dp;
N    char_type __ts;
N    string __grp;
N    string_type __sym;
N    string_type __sn;
N    int __fd;
N    this->__gather_info(__intl, __neg, __loc, __pat, __dp, __ts, __grp, __sym, __sn, __fd);
N    // secure memory for formatting
N    char_type __mbuf[100];
N    char_type* __mb = __mbuf;
N    unique_ptr<char_type, void(*)(void*)> __h(0, _LIBCPP_FREE);
X    unique_ptr<char_type, void(*)(void*)> __h(0, [] (void *p) { free(p); });
N    size_t __exn = static_cast<int>(__digits.size()) > __fd ?
N                   (__digits.size() - static_cast<size_t>(__fd)) * 2 +
N                    __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 1
N                 : __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 2;
N    if (__exn > 100)
N    {
N        __h.reset((char_type*)malloc(__exn * sizeof(char_type)));
N        __mb = __h.get();
N        if (__mb == 0)
N            __throw_bad_alloc();
N    }
N    // format
N    char_type* __mi;
N    char_type* __me;
N    this->__format(__mb, __mi, __me, __iob.flags(),
N                   __digits.data(), __digits.data() + __digits.size(), __ct,
N                   __neg, __pat, __dp, __ts, __grp, __sym, __sn, __fd);
N    return __pad_and_output(__s, __mb, __mi, __me, __iob, __fl);
N}
N
N_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS money_put<char>)
Xextern template class money_put<char>;
N_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS money_put<wchar_t>)
Xextern template class money_put<wchar_t>;
N
N// messages
N
Nclass _LIBCPP_TYPE_VIS messages_base
Xclass  messages_base
N{
Npublic:
N    typedef ptrdiff_t catalog;
N
N    _LIBCPP_ALWAYS_INLINE messages_base() {}
X    __attribute__ ((__always_inline__)) messages_base() {}
N};
N
Ntemplate <class _CharT>
Nclass _LIBCPP_TEMPLATE_VIS messages
Xclass  messages
N    : public locale::facet,
N      public messages_base
N{
Npublic:
N    typedef _CharT               char_type;
N    typedef basic_string<_CharT> string_type;
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    explicit messages(size_t __refs = 0)
N        : locale::facet(__refs) {}
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    catalog open(const basic_string<char>& __nm, const locale& __loc) const
N    {
N        return do_open(__nm, __loc);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    string_type get(catalog __c, int __set, int __msgid,
N                    const string_type& __dflt) const
N    {
N        return do_get(__c, __set, __msgid, __dflt);
N    }
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    void close(catalog __c) const
N    {
N        do_close(__c);
N    }
N
N    static _DATA_ACCESS locale::id id;
X    static  locale::id id;
N
Nprotected:
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    ~messages() {}
N
N    virtual catalog do_open(const basic_string<char>&, const locale&) const;
N    virtual string_type do_get(catalog, int __set, int __msgid,
N                               const string_type& __dflt) const;
N    virtual void do_close(catalog) const;
N};
N
Ntemplate <class _CharT>
Nlocale::id
Nmessages<_CharT>::id;
N
Ntemplate <class _CharT>
Ntypename messages<_CharT>::catalog
Nmessages<_CharT>::do_open(const basic_string<char>& __nm, const locale&) const
N{
N#ifdef _LIBCPP_HAS_CATOPEN
S    catalog __cat = (catalog)catopen(__nm.c_str(), NL_CAT_LOCALE);
S    if (__cat != -1)
S        __cat = static_cast<catalog>((static_cast<size_t>(__cat) >> 1));
S    return __cat;
N#else // !_LIBCPP_HAS_CATOPEN
N    return -1;
N#endif // _LIBCPP_HAS_CATOPEN
N}
N
Ntemplate <class _CharT>
Ntypename messages<_CharT>::string_type
Nmessages<_CharT>::do_get(catalog __c, int __set, int __msgid,
N                         const string_type& __dflt) const
N{
N#ifdef _LIBCPP_HAS_CATOPEN
S    string __ndflt;
S    __narrow_to_utf8<sizeof(char_type)*__CHAR_BIT__>()(back_inserter(__ndflt),
S                                                       __dflt.c_str(),
S                                                       __dflt.c_str() + __dflt.size());
S    if (__c != -1)
S        __c <<= 1;
S    nl_catd __cat = (nl_catd)__c;
S    char* __n = catgets(__cat, __set, __msgid, __ndflt.c_str());
S    string_type __w;
S    __widen_from_utf8<sizeof(char_type)*__CHAR_BIT__>()(back_inserter(__w),
S                                                        __n, __n + strlen(__n));
S    return __w;
N#else // !_LIBCPP_HAS_CATOPEN
N    return __dflt;
N#endif // _LIBCPP_HAS_CATOPEN
N}
N
Ntemplate <class _CharT>
Nvoid
Nmessages<_CharT>::do_close(catalog __c) const
N{
N#ifdef _LIBCPP_HAS_CATOPEN
S    if (__c != -1)
S        __c <<= 1;
S    nl_catd __cat = (nl_catd)__c;
S    catclose(__cat);
N#endif // _LIBCPP_HAS_CATOPEN
N}
N
N_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS messages<char>)
Xextern template class messages<char>;
N_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS messages<wchar_t>)
Xextern template class messages<wchar_t>;
N
Ntemplate <class _CharT>
Nclass _LIBCPP_TEMPLATE_VIS messages_byname
Xclass  messages_byname
N    : public messages<_CharT>
N{
Npublic:
N    typedef messages_base::catalog catalog;
N    typedef basic_string<_CharT> string_type;
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    explicit messages_byname(const char*, size_t __refs = 0)
N        : messages<_CharT>(__refs) {}
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    explicit messages_byname(const string&, size_t __refs = 0)
N        : messages<_CharT>(__refs) {}
N
Nprotected:
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    ~messages_byname() {}
N};
N
N_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS messages_byname<char>)
Xextern template class messages_byname<char>;
N_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS messages_byname<wchar_t>)
Xextern template class messages_byname<wchar_t>;
N
Ntemplate<class _Codecvt, class _Elem = wchar_t,
N         class _Wide_alloc = allocator<_Elem>,
N         class _Byte_alloc = allocator<char> >
Nclass _LIBCPP_TEMPLATE_VIS wstring_convert
Xclass  wstring_convert
N{
Npublic:
N    typedef basic_string<char, char_traits<char>, _Byte_alloc>   byte_string;
N    typedef basic_string<_Elem, char_traits<_Elem>, _Wide_alloc> wide_string;
N    typedef typename _Codecvt::state_type                        state_type;
N    typedef typename wide_string::traits_type::int_type          int_type;
N
Nprivate:
N    byte_string __byte_err_string_;
N    wide_string __wide_err_string_;
N    _Codecvt* __cvtptr_;
N    state_type __cvtstate_;
N    size_t __cvtcount_;
N
N    wstring_convert(const wstring_convert& __wc);
N    wstring_convert& operator=(const wstring_convert& __wc);
Npublic:
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    _LIBCPP_EXPLICIT_AFTER_CXX11 wstring_convert(_Codecvt* __pcvt = new _Codecvt);
X    explicit wstring_convert(_Codecvt* __pcvt = new _Codecvt);
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    wstring_convert(_Codecvt* __pcvt, state_type __state);
N    _LIBCPP_EXPLICIT_AFTER_CXX11 wstring_convert(const byte_string& __byte_err,
X    explicit wstring_convert(const byte_string& __byte_err,
N                    const wide_string& __wide_err = wide_string());
N#ifndef _LIBCPP_CXX03_LANG
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    wstring_convert(wstring_convert&& __wc);
N#endif
N    ~wstring_convert();
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    wide_string from_bytes(char __byte)
N        {return from_bytes(&__byte, &__byte+1);}
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    wide_string from_bytes(const char* __ptr)
N        {return from_bytes(__ptr, __ptr + char_traits<char>::length(__ptr));}
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    wide_string from_bytes(const byte_string& __str)
N        {return from_bytes(__str.data(), __str.data() + __str.size());}
N    wide_string from_bytes(const char* __first, const char* __last);
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    byte_string to_bytes(_Elem __wchar)
N        {return to_bytes(&__wchar, &__wchar+1);}
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    byte_string to_bytes(const _Elem* __wptr)
N        {return to_bytes(__wptr, __wptr + char_traits<_Elem>::length(__wptr));}
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    byte_string to_bytes(const wide_string& __wstr)
N        {return to_bytes(__wstr.data(), __wstr.data() + __wstr.size());}
N    byte_string to_bytes(const _Elem* __first, const _Elem* __last);
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    size_t converted() const _NOEXCEPT {return __cvtcount_;}
X    size_t converted() const noexcept {return __cvtcount_;}
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    state_type state() const {return __cvtstate_;}
N};
N
Ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
Ninline
Nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
N    wstring_convert(_Codecvt* __pcvt)
N        : __cvtptr_(__pcvt), __cvtstate_(), __cvtcount_(0)
N{
N}
N
Ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
Ninline
Nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
N    wstring_convert(_Codecvt* __pcvt, state_type __state)
N        : __cvtptr_(__pcvt), __cvtstate_(__state), __cvtcount_(0)
N{
N}
N
Ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
Nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
N    wstring_convert(const byte_string& __byte_err, const wide_string& __wide_err)
N        : __byte_err_string_(__byte_err), __wide_err_string_(__wide_err),
N          __cvtstate_(), __cvtcount_(0)
N{
N    __cvtptr_ = new _Codecvt;
N}
N
N#ifndef _LIBCPP_CXX03_LANG
N
Ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
Ninline
Nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
N    wstring_convert(wstring_convert&& __wc)
N        : __byte_err_string_(_VSTD::move(__wc.__byte_err_string_)),
X        : __byte_err_string_(std::__2::move(__wc.__byte_err_string_)),
N          __wide_err_string_(_VSTD::move(__wc.__wide_err_string_)),
X          __wide_err_string_(std::__2::move(__wc.__wide_err_string_)),
N          __cvtptr_(__wc.__cvtptr_),
N          __cvtstate_(__wc.__cvtstate_), __cvtcount_(__wc.__cvtcount_)
N{
N    __wc.__cvtptr_ = nullptr;
N}
N
N#endif  // _LIBCPP_CXX03_LANG
N
Ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
Nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::~wstring_convert()
N{
N    delete __cvtptr_;
N}
N
Ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
Ntypename wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::wide_string
Nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
N    from_bytes(const char* __frm, const char* __frm_end)
N{
N    __cvtcount_ = 0;
N    if (__cvtptr_ != nullptr)
N    {
N        wide_string __ws(2*(__frm_end - __frm), _Elem());
N        if (__frm != __frm_end)
N            __ws.resize(__ws.capacity());
N        codecvt_base::result __r = codecvt_base::ok;
N        state_type __st = __cvtstate_;
N        if (__frm != __frm_end)
N        {
N            _Elem* __to = &__ws[0];
N            _Elem* __to_end = __to + __ws.size();
N            const char* __frm_nxt;
N            do
N            {
N                _Elem* __to_nxt;
N                __r = __cvtptr_->in(__st, __frm, __frm_end, __frm_nxt,
N                                          __to, __to_end, __to_nxt);
N                __cvtcount_ += __frm_nxt - __frm;
N                if (__frm_nxt == __frm)
N                {
N                    __r = codecvt_base::error;
N                }
N                else if (__r == codecvt_base::noconv)
N                {
N                    __ws.resize(__to - &__ws[0]);
N                    // This only gets executed if _Elem is char
N                    __ws.append((const _Elem*)__frm, (const _Elem*)__frm_end);
N                    __frm = __frm_nxt;
N                    __r = codecvt_base::ok;
N                }
N                else if (__r == codecvt_base::ok)
N                {
N                    __ws.resize(__to_nxt - &__ws[0]);
N                    __frm = __frm_nxt;
N                }
N                else if (__r == codecvt_base::partial)
N                {
N                    ptrdiff_t __s = __to_nxt - &__ws[0];
N                    __ws.resize(2 * __s);
N                    __to = &__ws[0] + __s;
N                    __to_end = &__ws[0] + __ws.size();
N                    __frm = __frm_nxt;
N                }
N            } while (__r == codecvt_base::partial && __frm_nxt < __frm_end);
N        }
N        if (__r == codecvt_base::ok)
N            return __ws;
N    }
N
N    if (__wide_err_string_.empty())
N        __throw_range_error("wstring_convert: from_bytes error");
N
N    return __wide_err_string_;
N}
N
Ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
Ntypename wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::byte_string
Nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
N    to_bytes(const _Elem* __frm, const _Elem* __frm_end)
N{
N    __cvtcount_ = 0;
N    if (__cvtptr_ != nullptr)
N    {
N        byte_string __bs(2*(__frm_end - __frm), char());
N        if (__frm != __frm_end)
N            __bs.resize(__bs.capacity());
N        codecvt_base::result __r = codecvt_base::ok;
N        state_type __st = __cvtstate_;
N        if (__frm != __frm_end)
N        {
N            char* __to = &__bs[0];
N            char* __to_end = __to + __bs.size();
N            const _Elem* __frm_nxt;
N            do
N            {
N                char* __to_nxt;
N                __r = __cvtptr_->out(__st, __frm, __frm_end, __frm_nxt,
N                                           __to, __to_end, __to_nxt);
N                __cvtcount_ += __frm_nxt - __frm;
N                if (__frm_nxt == __frm)
N                {
N                    __r = codecvt_base::error;
N                }
N                else if (__r == codecvt_base::noconv)
N                {
N                    __bs.resize(__to - &__bs[0]);
N                    // This only gets executed if _Elem is char
N                    __bs.append((const char*)__frm, (const char*)__frm_end);
N                    __frm = __frm_nxt;
N                    __r = codecvt_base::ok;
N                }
N                else if (__r == codecvt_base::ok)
N                {
N                    __bs.resize(__to_nxt - &__bs[0]);
N                    __frm = __frm_nxt;
N                }
N                else if (__r == codecvt_base::partial)
N                {
N                    ptrdiff_t __s = __to_nxt - &__bs[0];
N                    __bs.resize(2 * __s);
N                    __to = &__bs[0] + __s;
N                    __to_end = &__bs[0] + __bs.size();
N                    __frm = __frm_nxt;
N                }
N            } while (__r == codecvt_base::partial && __frm_nxt < __frm_end);
N        }
N        if (__r == codecvt_base::ok)
N        {
N            size_t __s = __bs.size();
N            __bs.resize(__bs.capacity());
N            char* __to = &__bs[0] + __s;
N            char* __to_end = __to + __bs.size();
N            do
N            {
N                char* __to_nxt;
N                __r = __cvtptr_->unshift(__st, __to, __to_end, __to_nxt);
N                if (__r == codecvt_base::noconv)
N                {
N                    __bs.resize(__to - &__bs[0]);
N                    __r = codecvt_base::ok;
N                }
N                else if (__r == codecvt_base::ok)
N                {
N                    __bs.resize(__to_nxt - &__bs[0]);
N                }
N                else if (__r == codecvt_base::partial)
N                {
N                    ptrdiff_t __sp = __to_nxt - &__bs[0];
N                    __bs.resize(2 * __sp);
N                    __to = &__bs[0] + __sp;
N                    __to_end = &__bs[0] + __bs.size();
N                }
N            } while (__r == codecvt_base::partial);
N            if (__r == codecvt_base::ok)
N                return __bs;
N        }
N    }
N
N    if (__byte_err_string_.empty())
N        __throw_range_error("wstring_convert: to_bytes error");
N
N    return __byte_err_string_;
N}
N
Ntemplate <class _Codecvt, class _Elem = wchar_t, class _Tr = char_traits<_Elem> >
Nclass _LIBCPP_TEMPLATE_VIS wbuffer_convert
Xclass  wbuffer_convert
N    : public basic_streambuf<_Elem, _Tr>
N{
Npublic:
N    // types:
N    typedef _Elem                          char_type;
N    typedef _Tr                            traits_type;
N    typedef typename traits_type::int_type int_type;
N    typedef typename traits_type::pos_type pos_type;
N    typedef typename traits_type::off_type off_type;
N    typedef typename _Codecvt::state_type  state_type;
N
Nprivate:
N    char*       __extbuf_;
N    const char* __extbufnext_;
N    const char* __extbufend_;
N    char __extbuf_min_[8];
N    size_t __ebs_;
N    char_type* __intbuf_;
N    size_t __ibs_;
N    streambuf* __bufptr_;
N    _Codecvt* __cv_;
N    state_type __st_;
N    ios_base::openmode __cm_;
N    bool __owns_eb_;
N    bool __owns_ib_;
N    bool __always_noconv_;
N
N    wbuffer_convert(const wbuffer_convert&);
N    wbuffer_convert& operator=(const wbuffer_convert&);
Npublic:
N    _LIBCPP_EXPLICIT_AFTER_CXX11 wbuffer_convert(streambuf* __bytebuf = 0, 
X    explicit wbuffer_convert(streambuf* __bytebuf = 0, 
N            _Codecvt* __pcvt = new _Codecvt, state_type __state = state_type());
N    ~wbuffer_convert();
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    streambuf* rdbuf() const {return __bufptr_;}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    streambuf* rdbuf(streambuf* __bytebuf)
N    {
N        streambuf* __r = __bufptr_;
N        __bufptr_ = __bytebuf;
N        return __r;
N    }
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    state_type state() const {return __st_;}
N
Nprotected:
N    virtual int_type underflow();
N    virtual int_type pbackfail(int_type __c = traits_type::eof());
N    virtual int_type overflow (int_type __c = traits_type::eof());
N    virtual basic_streambuf<char_type, traits_type>* setbuf(char_type* __s,
N                                                            streamsize __n);
N    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,
N                             ios_base::openmode __wch = ios_base::in | ios_base::out);
N    virtual pos_type seekpos(pos_type __sp,
N                             ios_base::openmode __wch = ios_base::in | ios_base::out);
N    virtual int sync();
N
Nprivate:
N    bool __read_mode();
N    void __write_mode();
N    wbuffer_convert* __close();
N};
N
Ntemplate <class _Codecvt, class _Elem, class _Tr>
Nwbuffer_convert<_Codecvt, _Elem, _Tr>::
N    wbuffer_convert(streambuf* __bytebuf, _Codecvt* __pcvt, state_type __state)
N    : __extbuf_(0),
N      __extbufnext_(0),
N      __extbufend_(0),
N      __ebs_(0),
N      __intbuf_(0),
N      __ibs_(0),
N      __bufptr_(__bytebuf),
N      __cv_(__pcvt),
N      __st_(__state),
N      __cm_(0),
N      __owns_eb_(false),
N      __owns_ib_(false),
N      __always_noconv_(__cv_ ? __cv_->always_noconv() : false)
N{
N    setbuf(0, 4096);
N}
N
Ntemplate <class _Codecvt, class _Elem, class _Tr>
Nwbuffer_convert<_Codecvt, _Elem, _Tr>::~wbuffer_convert()
N{
N    __close();
N    delete __cv_;
N    if (__owns_eb_)
N        delete [] __extbuf_;
N    if (__owns_ib_)
N        delete [] __intbuf_;
N}
N
Ntemplate <class _Codecvt, class _Elem, class _Tr>
Ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type
Nwbuffer_convert<_Codecvt, _Elem, _Tr>::underflow()
N{
N    if (__cv_ == 0 || __bufptr_ == 0)
N        return traits_type::eof();
N    bool __initial = __read_mode();
N    char_type __1buf;
N    if (this->gptr() == 0)
N        this->setg(&__1buf, &__1buf+1, &__1buf+1);
N    const size_t __unget_sz = __initial ? 0 : min<size_t>((this->egptr() - this->eback()) / 2, 4);
N    int_type __c = traits_type::eof();
N    if (this->gptr() == this->egptr())
N    {
N        memmove(this->eback(), this->egptr() - __unget_sz, __unget_sz * sizeof(char_type));
N        if (__always_noconv_)
N        {
N            streamsize __nmemb = static_cast<streamsize>(this->egptr() - this->eback() - __unget_sz);
N            __nmemb = __bufptr_->sgetn((char*)this->eback() + __unget_sz, __nmemb);
N            if (__nmemb != 0)
N            {
N                this->setg(this->eback(),
N                           this->eback() + __unget_sz,
N                           this->eback() + __unget_sz + __nmemb);
N                __c = *this->gptr();
N            }
N        }
N        else
N        {
N             _LIBCPP_ASSERT(!(__extbufnext_ == NULL && (__extbufend_ != __extbufnext_)), "underflow moving from NULL" );
X             ((void)0);
N             if (__extbufend_ != __extbufnext_)
N                memmove(__extbuf_, __extbufnext_, __extbufend_ - __extbufnext_);
N            __extbufnext_ = __extbuf_ + (__extbufend_ - __extbufnext_);
N            __extbufend_ = __extbuf_ + (__extbuf_ == __extbuf_min_ ? sizeof(__extbuf_min_) : __ebs_);
N            streamsize __nmemb = _VSTD::min(static_cast<streamsize>(this->egptr() - this->eback() - __unget_sz),
X            streamsize __nmemb = std::__2::min(static_cast<streamsize>(this->egptr() - this->eback() - __unget_sz),
N                                 static_cast<streamsize>(__extbufend_ - __extbufnext_));
N            codecvt_base::result __r;
N            // FIXME: Do we ever need to restore the state here?
N            //state_type __svs = __st_;
N            streamsize __nr = __bufptr_->sgetn(const_cast<char*>(__extbufnext_), __nmemb);
N            if (__nr != 0)
N            {
N                __extbufend_ = __extbufnext_ + __nr;
N                char_type*  __inext;
N                __r = __cv_->in(__st_, __extbuf_, __extbufend_, __extbufnext_,
N                                       this->eback() + __unget_sz,
N                                       this->egptr(), __inext);
N                if (__r == codecvt_base::noconv)
N                {
N                    this->setg((char_type*)__extbuf_, (char_type*)__extbuf_, 
N                               (char_type*) const_cast<char *>(__extbufend_));
N                    __c = *this->gptr();
N                }
N                else if (__inext != this->eback() + __unget_sz)
N                {
N                    this->setg(this->eback(), this->eback() + __unget_sz, __inext);
N                    __c = *this->gptr();
N                }
N            }
N        }
N    }
N    else
N        __c = *this->gptr();
N    if (this->eback() == &__1buf)
N        this->setg(0, 0, 0);
N    return __c;
N}
N
Ntemplate <class _Codecvt, class _Elem, class _Tr>
Ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type
Nwbuffer_convert<_Codecvt, _Elem, _Tr>::pbackfail(int_type __c)
N{
N    if (__cv_ != 0 && __bufptr_ != 0 && this->eback() < this->gptr())
N    {
N        if (traits_type::eq_int_type(__c, traits_type::eof()))
N        {
N            this->gbump(-1);
N            return traits_type::not_eof(__c);
N        }
N        if (traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1]))
N        {
N            this->gbump(-1);
N            *this->gptr() = traits_type::to_char_type(__c);
N            return __c;
N        }
N    }
N    return traits_type::eof();
N}
N
Ntemplate <class _Codecvt, class _Elem, class _Tr>
Ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type
Nwbuffer_convert<_Codecvt, _Elem, _Tr>::overflow(int_type __c)
N{
N    if (__cv_ == 0 || __bufptr_ == 0)
N        return traits_type::eof();
N    __write_mode();
N    char_type __1buf;
N    char_type* __pb_save = this->pbase();
N    char_type* __epb_save = this->epptr();
N    if (!traits_type::eq_int_type(__c, traits_type::eof()))
N    {
N        if (this->pptr() == 0)
N            this->setp(&__1buf, &__1buf+1);
N        *this->pptr() = traits_type::to_char_type(__c);
N        this->pbump(1);
N    }
N    if (this->pptr() != this->pbase())
N    {
N        if (__always_noconv_)
N        {
N            streamsize __nmemb = static_cast<streamsize>(this->pptr() - this->pbase());
N            if (__bufptr_->sputn((const char*)this->pbase(), __nmemb) != __nmemb)
N                return traits_type::eof();
N        }
N        else
N        {
N            char* __extbe = __extbuf_;
N            codecvt_base::result __r;
N            do
N            {
N                const char_type* __e;
N                __r = __cv_->out(__st_, this->pbase(), this->pptr(), __e,
N                                        __extbuf_, __extbuf_ + __ebs_, __extbe);
N                if (__e == this->pbase())
N                    return traits_type::eof();
N                if (__r == codecvt_base::noconv)
N                {
N                    streamsize __nmemb = static_cast<size_t>(this->pptr() - this->pbase());
N                    if (__bufptr_->sputn((const char*)this->pbase(), __nmemb) != __nmemb)
N                        return traits_type::eof();
N                }
N                else if (__r == codecvt_base::ok || __r == codecvt_base::partial)
N                {
N                    streamsize __nmemb = static_cast<size_t>(__extbe - __extbuf_);
N                    if (__bufptr_->sputn(__extbuf_, __nmemb) != __nmemb)
N                        return traits_type::eof();
N                    if (__r == codecvt_base::partial)
N                    {
N                        this->setp(const_cast<char_type *>(__e), this->pptr());
N                        this->__pbump(this->epptr() - this->pbase());
N                    }
N                }
N                else
N                    return traits_type::eof();
N            } while (__r == codecvt_base::partial);
N        }
N        this->setp(__pb_save, __epb_save);
N    }
N    return traits_type::not_eof(__c);
N}
N
Ntemplate <class _Codecvt, class _Elem, class _Tr>
Nbasic_streambuf<_Elem, _Tr>*
Nwbuffer_convert<_Codecvt, _Elem, _Tr>::setbuf(char_type* __s, streamsize __n)
N{
N    this->setg(0, 0, 0);
N    this->setp(0, 0);
N    if (__owns_eb_)
N        delete [] __extbuf_;
N    if (__owns_ib_)
N        delete [] __intbuf_;
N    __ebs_ = __n;
N    if (__ebs_ > sizeof(__extbuf_min_))
N    {
N        if (__always_noconv_ && __s)
N        {
N            __extbuf_ = (char*)__s;
N            __owns_eb_ = false;
N        }
N        else
N        {
N            __extbuf_ = new char[__ebs_];
N            __owns_eb_ = true;
N        }
N    }
N    else
N    {
N        __extbuf_ = __extbuf_min_;
N        __ebs_ = sizeof(__extbuf_min_);
N        __owns_eb_ = false;
N    }
N    if (!__always_noconv_)
N    {
N        __ibs_ = max<streamsize>(__n, sizeof(__extbuf_min_));
N        if (__s && __ibs_ >= sizeof(__extbuf_min_))
N        {
N            __intbuf_ = __s;
N            __owns_ib_ = false;
N        }
N        else
N        {
N            __intbuf_ = new char_type[__ibs_];
N            __owns_ib_ = true;
N        }
N    }
N    else
N    {
N        __ibs_ = 0;
N        __intbuf_ = 0;
N        __owns_ib_ = false;
N    }
N    return this;
N}
N
Ntemplate <class _Codecvt, class _Elem, class _Tr>
Ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::pos_type
Nwbuffer_convert<_Codecvt, _Elem, _Tr>::seekoff(off_type __off, ios_base::seekdir __way,
N                                        ios_base::openmode __om)
N{
N    int __width = __cv_->encoding();
N    if (__cv_ == 0 || __bufptr_ == 0 || (__width <= 0 && __off != 0) || sync())
N        return pos_type(off_type(-1));
N    // __width > 0 || __off == 0, now check __way
N    if (__way != ios_base::beg && __way != ios_base::cur && __way != ios_base::end)
N        return pos_type(off_type(-1));
N    pos_type __r = __bufptr_->pubseekoff(__width * __off, __way, __om);
N    __r.state(__st_);
N    return __r;
N}
N
Ntemplate <class _Codecvt, class _Elem, class _Tr>
Ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::pos_type
Nwbuffer_convert<_Codecvt, _Elem, _Tr>::seekpos(pos_type __sp, ios_base::openmode __wch)
N{
N    if (__cv_ == 0 || __bufptr_ == 0 || sync())
N        return pos_type(off_type(-1));
N    if (__bufptr_->pubseekpos(__sp, __wch) == pos_type(off_type(-1)))
N        return pos_type(off_type(-1));
N    return __sp;
N}
N
Ntemplate <class _Codecvt, class _Elem, class _Tr>
Nint
Nwbuffer_convert<_Codecvt, _Elem, _Tr>::sync()
N{
N    if (__cv_ == 0 || __bufptr_ == 0)
N        return 0;
N    if (__cm_ & ios_base::out)
N    {
N        if (this->pptr() != this->pbase())
N            if (overflow() == traits_type::eof())
N                return -1;
N        codecvt_base::result __r;
N        do
N        {
N            char* __extbe;
N            __r = __cv_->unshift(__st_, __extbuf_, __extbuf_ + __ebs_, __extbe);
N            streamsize __nmemb = static_cast<streamsize>(__extbe - __extbuf_);
N            if (__bufptr_->sputn(__extbuf_, __nmemb) != __nmemb)
N                return -1;
N        } while (__r == codecvt_base::partial);
N        if (__r == codecvt_base::error)
N            return -1;
N        if (__bufptr_->pubsync())
N            return -1;
N    }
N    else if (__cm_ & ios_base::in)
N    {
N        off_type __c;
N        if (__always_noconv_)
N            __c = this->egptr() - this->gptr();
N        else
N        {
N            int __width = __cv_->encoding();
N            __c = __extbufend_ - __extbufnext_;
N            if (__width > 0)
N                __c += __width * (this->egptr() - this->gptr());
N            else
N            {
N                if (this->gptr() != this->egptr())
N                {
N                    reverse(this->gptr(), this->egptr());
N                    codecvt_base::result __r;
N                    const char_type* __e = this->gptr();
N                    char* __extbe;
N                    do
N                    {
N                        __r = __cv_->out(__st_, __e, this->egptr(), __e,
N                                         __extbuf_, __extbuf_ + __ebs_, __extbe);
N                        switch (__r)
N                        {
N                        case codecvt_base::noconv:
N                            __c += this->egptr() - this->gptr();
N                            break;
N                        case codecvt_base::ok:
N                        case codecvt_base::partial:
N                            __c += __extbe - __extbuf_;
N                            break;
N                        default:
N                            return -1;
N                        }
N                    } while (__r == codecvt_base::partial);
N                }
N            }
N        }
N        if (__bufptr_->pubseekoff(-__c, ios_base::cur, __cm_) == pos_type(off_type(-1)))
N            return -1;
N        this->setg(0, 0, 0);
N        __cm_ = 0;
N    }
N    return 0;
N}
N
Ntemplate <class _Codecvt, class _Elem, class _Tr>
Nbool
Nwbuffer_convert<_Codecvt, _Elem, _Tr>::__read_mode()
N{
N    if (!(__cm_ & ios_base::in))
N    {
N        this->setp(0, 0);
N        if (__always_noconv_)
N            this->setg((char_type*)__extbuf_,
N                       (char_type*)__extbuf_ + __ebs_,
N                       (char_type*)__extbuf_ + __ebs_);
N        else
N            this->setg(__intbuf_, __intbuf_ + __ibs_, __intbuf_ + __ibs_);
N        __cm_ = ios_base::in;
N        return true;
N    }
N    return false;
N}
N
Ntemplate <class _Codecvt, class _Elem, class _Tr>
Nvoid
Nwbuffer_convert<_Codecvt, _Elem, _Tr>::__write_mode()
N{
N    if (!(__cm_ & ios_base::out))
N    {
N        this->setg(0, 0, 0);
N        if (__ebs_ > sizeof(__extbuf_min_))
N        {
N            if (__always_noconv_)
N                this->setp((char_type*)__extbuf_,
N                           (char_type*)__extbuf_ + (__ebs_ - 1));
N            else
N                this->setp(__intbuf_, __intbuf_ + (__ibs_ - 1));
N        }
N        else
N            this->setp(0, 0);
N        __cm_ = ios_base::out;
N    }
N}
N
Ntemplate <class _Codecvt, class _Elem, class _Tr>
Nwbuffer_convert<_Codecvt, _Elem, _Tr>*
Nwbuffer_convert<_Codecvt, _Elem, _Tr>::__close()
N{
N    wbuffer_convert* __rt = 0;
N    if (__cv_ != 0 && __bufptr_ != 0)
N    {
N        __rt = this;
N        if ((__cm_ & ios_base::out) && sync())
N            __rt = 0;
N    }
N    return __rt;
N}
N
N_LIBCPP_END_NAMESPACE_STD
X} }
N
N_LIBCPP_POP_MACROS
X_Pragma("pop_macro(\"min\")") _Pragma("pop_macro(\"max\")")
N
N#endif  // _LIBCPP_LOCALE
L 141 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/ostream" 2
N#include <iterator>
N#include <bitset>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/bitset" 1
N// -*- C++ -*-
N//===---------------------------- bitset ----------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is dual licensed under the MIT and the University of Illinois Open
N// Source Licenses. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP_BITSET
N#define _LIBCPP_BITSET
N
N/*
N    bitset synopsis
N
Nnamespace std
N{
N
Nnamespace std {
N
Ntemplate <size_t N>
Nclass bitset
N{
Npublic:
N    // bit reference:
N    class reference
N    {
N        friend class bitset;
N        reference() noexcept;
N    public:
N        ~reference() noexcept;
N        reference& operator=(bool x) noexcept;           // for b[i] = x;
N        reference& operator=(const reference&) noexcept; // for b[i] = b[j];
N        bool operator~() const noexcept;                 // flips the bit
N        operator bool() const noexcept;                  // for x = b[i];
N        reference& flip() noexcept;                      // for b[i].flip();
N    };
N
N    // 23.3.5.1 constructors:
N    constexpr bitset() noexcept;
N    constexpr bitset(unsigned long long val) noexcept;
N    template <class charT>
N        explicit bitset(const charT* str,
N                        typename basic_string<charT>::size_type n = basic_string<charT>::npos,
N                        charT zero = charT('0'), charT one = charT('1'));
N    template<class charT, class traits, class Allocator>
N        explicit bitset(const basic_string<charT,traits,Allocator>& str,
N                        typename basic_string<charT,traits,Allocator>::size_type pos = 0,
N                        typename basic_string<charT,traits,Allocator>::size_type n =
N                                 basic_string<charT,traits,Allocator>::npos,
N                        charT zero = charT('0'), charT one = charT('1'));
N
N    // 23.3.5.2 bitset operations:
N    bitset& operator&=(const bitset& rhs) noexcept;
N    bitset& operator|=(const bitset& rhs) noexcept;
N    bitset& operator^=(const bitset& rhs) noexcept;
N    bitset& operator<<=(size_t pos) noexcept;
N    bitset& operator>>=(size_t pos) noexcept;
N    bitset& set() noexcept;
N    bitset& set(size_t pos, bool val = true);
N    bitset& reset() noexcept;
N    bitset& reset(size_t pos);
N    bitset operator~() const noexcept;
N    bitset& flip() noexcept;
N    bitset& flip(size_t pos);
N
N    // element access:
N    constexpr bool operator[](size_t pos) const; // for b[i];
N    reference operator[](size_t pos);            // for b[i];
N    unsigned long to_ulong() const;
N    unsigned long long to_ullong() const;
N    template <class charT, class traits, class Allocator>
N        basic_string<charT, traits, Allocator> to_string(charT zero = charT('0'), charT one = charT('1')) const;
N    template <class charT, class traits>
N        basic_string<charT, traits, allocator<charT> > to_string(charT zero = charT('0'), charT one = charT('1')) const;
N    template <class charT>
N        basic_string<charT, char_traits<charT>, allocator<charT> > to_string(charT zero = charT('0'), charT one = charT('1')) const;
N    basic_string<char, char_traits<char>, allocator<char> > to_string(char zero = '0', char one = '1') const;
N    size_t count() const noexcept;
N    constexpr size_t size() const noexcept;
N    bool operator==(const bitset& rhs) const noexcept;
N    bool operator!=(const bitset& rhs) const noexcept;
N    bool test(size_t pos) const;
N    bool all() const noexcept;
N    bool any() const noexcept;
N    bool none() const noexcept;
N    bitset operator<<(size_t pos) const noexcept;
N    bitset operator>>(size_t pos) const noexcept;
N};
N
N// 23.3.5.3 bitset operators:
Ntemplate <size_t N>
Nbitset<N> operator&(const bitset<N>&, const bitset<N>&) noexcept;
N
Ntemplate <size_t N>
Nbitset<N> operator|(const bitset<N>&, const bitset<N>&) noexcept;
N
Ntemplate <size_t N>
Nbitset<N> operator^(const bitset<N>&, const bitset<N>&) noexcept;
N
Ntemplate <class charT, class traits, size_t N>
Nbasic_istream<charT, traits>&
Noperator>>(basic_istream<charT, traits>& is, bitset<N>& x);
N
Ntemplate <class charT, class traits, size_t N>
Nbasic_ostream<charT, traits>&
Noperator<<(basic_ostream<charT, traits>& os, const bitset<N>& x);
N
Ntemplate <size_t N> struct hash<std::bitset<N>>;
N
N}  // std
N
N*/
N
N#include <__config>
N#include <__bit_reference>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/__bit_reference" 1
N// -*- C++ -*-
N//===----------------------------------------------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is dual licensed under the MIT and the University of Illinois Open
N// Source Licenses. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP___BIT_REFERENCE
N#define _LIBCPP___BIT_REFERENCE
N
N#include <__config>
N#include <algorithm>
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N_LIBCPP_PUSH_MACROS
X_Pragma("push_macro(\"min\")") _Pragma("push_macro(\"max\")")
N#include <__undef_macros>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/__undef_macros" 1
N// -*- C++ -*-
N//===------------------------ __undef_macros ------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is distributed under the University of Illinois Open Source
N// License. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N
N#ifdef min
S#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
S#if defined(_LIBCPP_WARNING)
S_LIBCPP_WARNING("macro min is incompatible with C++.  Try #define NOMINMAX "
S                "before any Windows header. #undefing min")
S#else
S#warning: macro min is incompatible with C++.  #undefing min
S#endif
S#endif
S#undef min
N#endif
N
N#ifdef max
S#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
S#if defined(_LIBCPP_WARNING)
S_LIBCPP_WARNING("macro max is incompatible with C++.  Try #define NOMINMAX "
S                "before any Windows header. #undefing max")
S#else
S#warning: macro max is incompatible with C++.  #undefing max
S#endif
S#endif
S#undef max
N#endif
L 23 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/__bit_reference" 2
N
N
N_LIBCPP_BEGIN_NAMESPACE_STD
Xnamespace std { inline namespace __2 {
N
Ntemplate <class _Cp, bool _IsConst, typename _Cp::__storage_type = 0> class __bit_iterator;
Ntemplate <class _Cp> class __bit_const_reference;
N
Ntemplate <class _Tp>
Nstruct __has_storage_type
N{
N    static const bool value = false;
N};
N
Ntemplate <class _Cp, bool = __has_storage_type<_Cp>::value>
Nclass __bit_reference
N{
N    typedef typename _Cp::__storage_type    __storage_type;
N    typedef typename _Cp::__storage_pointer __storage_pointer;
N
N    __storage_pointer __seg_;
N    __storage_type    __mask_;
N
N    friend typename _Cp::__self;
N
N    friend class __bit_const_reference<_Cp>;
N    friend class __bit_iterator<_Cp, false>;
Npublic:
N    _LIBCPP_INLINE_VISIBILITY operator bool() const _NOEXCEPT
X    __attribute__ ((__always_inline__)) operator bool() const noexcept
N        {return static_cast<bool>(*__seg_ & __mask_);}
N    _LIBCPP_INLINE_VISIBILITY bool operator ~() const _NOEXCEPT
X    __attribute__ ((__always_inline__)) bool operator ~() const noexcept
N        {return !static_cast<bool>(*this);}
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    __bit_reference& operator=(bool __x) _NOEXCEPT
X    __bit_reference& operator=(bool __x) noexcept
N    {
N        if (__x)
N            *__seg_ |= __mask_;
N        else
N            *__seg_ &= ~__mask_;
N        return *this;
N    }
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    __bit_reference& operator=(const __bit_reference& __x) _NOEXCEPT
X    __bit_reference& operator=(const __bit_reference& __x) noexcept
N        {return operator=(static_cast<bool>(__x));}
N
N    _LIBCPP_INLINE_VISIBILITY void flip() _NOEXCEPT {*__seg_ ^= __mask_;}
X    __attribute__ ((__always_inline__)) void flip() noexcept {*__seg_ ^= __mask_;}
N    _LIBCPP_INLINE_VISIBILITY __bit_iterator<_Cp, false> operator&() const _NOEXCEPT
X    __attribute__ ((__always_inline__)) __bit_iterator<_Cp, false> operator&() const noexcept
N        {return __bit_iterator<_Cp, false>(__seg_, static_cast<unsigned>(__ctz(__mask_)));}
Nprivate:
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    __bit_reference(__storage_pointer __s, __storage_type __m) _NOEXCEPT
X    __bit_reference(__storage_pointer __s, __storage_type __m) noexcept
N        : __seg_(__s), __mask_(__m) {}
N};
N
Ntemplate <class _Cp>
Nclass __bit_reference<_Cp, false>
N{
N};
N
Ntemplate <class _Cp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Nswap(__bit_reference<_Cp> __x, __bit_reference<_Cp> __y) _NOEXCEPT
Xswap(__bit_reference<_Cp> __x, __bit_reference<_Cp> __y) noexcept
N{
N    bool __t = __x;
N    __x = __y;
N    __y = __t;
N}
N
Ntemplate <class _Cp, class _Dp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Nswap(__bit_reference<_Cp> __x, __bit_reference<_Dp> __y) _NOEXCEPT
Xswap(__bit_reference<_Cp> __x, __bit_reference<_Dp> __y) noexcept
N{
N    bool __t = __x;
N    __x = __y;
N    __y = __t;
N}
N
Ntemplate <class _Cp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Nswap(__bit_reference<_Cp> __x, bool& __y) _NOEXCEPT
Xswap(__bit_reference<_Cp> __x, bool& __y) noexcept
N{
N    bool __t = __x;
N    __x = __y;
N    __y = __t;
N}
N
Ntemplate <class _Cp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Nswap(bool& __x, __bit_reference<_Cp> __y) _NOEXCEPT
Xswap(bool& __x, __bit_reference<_Cp> __y) noexcept
N{
N    bool __t = __x;
N    __x = __y;
N    __y = __t;
N}
N
Ntemplate <class _Cp>
Nclass __bit_const_reference
N{
N    typedef typename _Cp::__storage_type          __storage_type;
N    typedef typename _Cp::__const_storage_pointer __storage_pointer;
N
N    __storage_pointer        __seg_;
N    __storage_type __mask_;
N
N    friend typename _Cp::__self;
N    friend class __bit_iterator<_Cp, true>;
Npublic:
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    __bit_const_reference(const __bit_reference<_Cp>& __x) _NOEXCEPT
X    __bit_const_reference(const __bit_reference<_Cp>& __x) noexcept
N        : __seg_(__x.__seg_), __mask_(__x.__mask_) {}
N
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR operator bool() const _NOEXCEPT
X    __attribute__ ((__always_inline__)) constexpr operator bool() const noexcept
N        {return static_cast<bool>(*__seg_ & __mask_);}
N
N    _LIBCPP_INLINE_VISIBILITY __bit_iterator<_Cp, true> operator&() const _NOEXCEPT
X    __attribute__ ((__always_inline__)) __bit_iterator<_Cp, true> operator&() const noexcept
N        {return __bit_iterator<_Cp, true>(__seg_, static_cast<unsigned>(__ctz(__mask_)));}
Nprivate:
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _LIBCPP_CONSTEXPR
X    constexpr
N    __bit_const_reference(__storage_pointer __s, __storage_type __m) _NOEXCEPT
X    __bit_const_reference(__storage_pointer __s, __storage_type __m) noexcept
N        : __seg_(__s), __mask_(__m) {}
N
N    __bit_const_reference& operator=(const __bit_const_reference& __x);
N};
N
N// find
N
Ntemplate <class _Cp, bool _IsConst>
N__bit_iterator<_Cp, _IsConst>
N__find_bool_true(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)
N{
N    typedef __bit_iterator<_Cp, _IsConst> _It;
N    typedef typename _It::__storage_type __storage_type;
N    static const int __bits_per_word = _It::__bits_per_word;
N    // do first partial word
N    if (__first.__ctz_ != 0)
N    {
N        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
N        __storage_type __dn = _VSTD::min(__clz_f, __n);
X        __storage_type __dn = std::__2::min(__clz_f, __n);
N        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
N        __storage_type __b = *__first.__seg_ & __m;
N        if (__b)
N            return _It(__first.__seg_, static_cast<unsigned>(_VSTD::__ctz(__b)));
X            return _It(__first.__seg_, static_cast<unsigned>(std::__2::__ctz(__b)));
N        if (__n == __dn)
N            return __first + __n;
N        __n -= __dn;
N        ++__first.__seg_;
N    }
N    // do middle whole words
N    for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)
N        if (*__first.__seg_)
N            return _It(__first.__seg_, static_cast<unsigned>(_VSTD::__ctz(*__first.__seg_)));
X            return _It(__first.__seg_, static_cast<unsigned>(std::__2::__ctz(*__first.__seg_)));
N    // do last partial word
N    if (__n > 0)
N    {
N        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
N        __storage_type __b = *__first.__seg_ & __m;
N        if (__b)
N            return _It(__first.__seg_, static_cast<unsigned>(_VSTD::__ctz(__b)));
X            return _It(__first.__seg_, static_cast<unsigned>(std::__2::__ctz(__b)));
N    }
N    return _It(__first.__seg_, static_cast<unsigned>(__n));
N}
N
Ntemplate <class _Cp, bool _IsConst>
N__bit_iterator<_Cp, _IsConst>
N__find_bool_false(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)
N{
N    typedef __bit_iterator<_Cp, _IsConst> _It;
N    typedef typename _It::__storage_type __storage_type;
N    const int __bits_per_word = _It::__bits_per_word;
N    // do first partial word
N    if (__first.__ctz_ != 0)
N    {
N        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
N        __storage_type __dn = _VSTD::min(__clz_f, __n);
X        __storage_type __dn = std::__2::min(__clz_f, __n);
N        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
N        __storage_type __b = ~*__first.__seg_ & __m;
N        if (__b)
N            return _It(__first.__seg_, static_cast<unsigned>(_VSTD::__ctz(__b)));
X            return _It(__first.__seg_, static_cast<unsigned>(std::__2::__ctz(__b)));
N        if (__n == __dn)
N            return __first + __n;
N        __n -= __dn;
N        ++__first.__seg_;
N    }
N    // do middle whole words
N    for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)
N    {
N        __storage_type __b = ~*__first.__seg_;
N        if (__b)
N            return _It(__first.__seg_, static_cast<unsigned>(_VSTD::__ctz(__b)));
X            return _It(__first.__seg_, static_cast<unsigned>(std::__2::__ctz(__b)));
N    }
N    // do last partial word
N    if (__n > 0)
N    {
N        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
N        __storage_type __b = ~*__first.__seg_ & __m;
N        if (__b)
N            return _It(__first.__seg_, static_cast<unsigned>(_VSTD::__ctz(__b)));
X            return _It(__first.__seg_, static_cast<unsigned>(std::__2::__ctz(__b)));
N    }
N    return _It(__first.__seg_, static_cast<unsigned>(__n));
N}
N
Ntemplate <class _Cp, bool _IsConst, class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N__bit_iterator<_Cp, _IsConst>
Nfind(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, const _Tp& __value_)
N{
N    if (static_cast<bool>(__value_))
N        return __find_bool_true(__first, static_cast<typename _Cp::size_type>(__last - __first));
N    return __find_bool_false(__first, static_cast<typename _Cp::size_type>(__last - __first));
N}
N
N// count
N
Ntemplate <class _Cp, bool _IsConst>
Ntypename __bit_iterator<_Cp, _IsConst>::difference_type
N__count_bool_true(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)
N{
N    typedef __bit_iterator<_Cp, _IsConst> _It;
N    typedef typename _It::__storage_type __storage_type;
N    typedef typename _It::difference_type difference_type;
N    const int __bits_per_word = _It::__bits_per_word;
N    difference_type __r = 0;
N    // do first partial word
N    if (__first.__ctz_ != 0)
N    {
N        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
N        __storage_type __dn = _VSTD::min(__clz_f, __n);
X        __storage_type __dn = std::__2::min(__clz_f, __n);
N        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
N        __r = _VSTD::__pop_count(*__first.__seg_ & __m);
X        __r = std::__2::__pop_count(*__first.__seg_ & __m);
N        __n -= __dn;
N        ++__first.__seg_;
N    }
N    // do middle whole words
N    for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)
N        __r += _VSTD::__pop_count(*__first.__seg_);
X        __r += std::__2::__pop_count(*__first.__seg_);
N    // do last partial word
N    if (__n > 0)
N    {
N        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
N        __r += _VSTD::__pop_count(*__first.__seg_ & __m);
X        __r += std::__2::__pop_count(*__first.__seg_ & __m);
N    }
N    return __r;
N}
N
Ntemplate <class _Cp, bool _IsConst>
Ntypename __bit_iterator<_Cp, _IsConst>::difference_type
N__count_bool_false(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)
N{
N    typedef __bit_iterator<_Cp, _IsConst> _It;
N    typedef typename _It::__storage_type __storage_type;
N    typedef typename _It::difference_type difference_type;
N    const int __bits_per_word = _It::__bits_per_word;
N    difference_type __r = 0;
N    // do first partial word
N    if (__first.__ctz_ != 0)
N    {
N        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
N        __storage_type __dn = _VSTD::min(__clz_f, __n);
X        __storage_type __dn = std::__2::min(__clz_f, __n);
N        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
N        __r = _VSTD::__pop_count(~*__first.__seg_ & __m);
X        __r = std::__2::__pop_count(~*__first.__seg_ & __m);
N        __n -= __dn;
N        ++__first.__seg_;
N    }
N    // do middle whole words
N    for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)
N        __r += _VSTD::__pop_count(~*__first.__seg_);
X        __r += std::__2::__pop_count(~*__first.__seg_);
N    // do last partial word
N    if (__n > 0)
N    {
N        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
N        __r += _VSTD::__pop_count(~*__first.__seg_ & __m);
X        __r += std::__2::__pop_count(~*__first.__seg_ & __m);
N    }
N    return __r;
N}
N
Ntemplate <class _Cp, bool _IsConst, class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename __bit_iterator<_Cp, _IsConst>::difference_type
Ncount(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, const _Tp& __value_)
N{
N    if (static_cast<bool>(__value_))
N        return __count_bool_true(__first, static_cast<typename _Cp::size_type>(__last - __first));
N    return __count_bool_false(__first, static_cast<typename _Cp::size_type>(__last - __first));
N}
N
N// fill_n
N
Ntemplate <class _Cp>
Nvoid
N__fill_n_false(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n)
N{
N    typedef __bit_iterator<_Cp, false> _It;
N    typedef typename _It::__storage_type __storage_type;
N    const int __bits_per_word = _It::__bits_per_word;
N    // do first partial word
N    if (__first.__ctz_ != 0)
N    {
N        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
N        __storage_type __dn = _VSTD::min(__clz_f, __n);
X        __storage_type __dn = std::__2::min(__clz_f, __n);
N        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
N        *__first.__seg_ &= ~__m;
N        __n -= __dn;
N        ++__first.__seg_;
N    }
N    // do middle whole words
N    __storage_type __nw = __n / __bits_per_word;
N    _VSTD::memset(_VSTD::__to_raw_pointer(__first.__seg_), 0, __nw * sizeof(__storage_type));
X    std::__2::memset(std::__2::__to_raw_pointer(__first.__seg_), 0, __nw * sizeof(__storage_type));
N    __n -= __nw * __bits_per_word;
N    // do last partial word
N    if (__n > 0)
N    {
N        __first.__seg_ += __nw;
N        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
N        *__first.__seg_ &= ~__m;
N    }
N}
N
Ntemplate <class _Cp>
Nvoid
N__fill_n_true(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n)
N{
N    typedef __bit_iterator<_Cp, false> _It;
N    typedef typename _It::__storage_type __storage_type;
N    const int __bits_per_word = _It::__bits_per_word;
N    // do first partial word
N    if (__first.__ctz_ != 0)
N    {
N        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
N        __storage_type __dn = _VSTD::min(__clz_f, __n);
X        __storage_type __dn = std::__2::min(__clz_f, __n);
N        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
N        *__first.__seg_ |= __m;
N        __n -= __dn;
N        ++__first.__seg_;
N    }
N    // do middle whole words
N    __storage_type __nw = __n / __bits_per_word;
N    _VSTD::memset(_VSTD::__to_raw_pointer(__first.__seg_), -1, __nw * sizeof(__storage_type));
X    std::__2::memset(std::__2::__to_raw_pointer(__first.__seg_), -1, __nw * sizeof(__storage_type));
N    __n -= __nw * __bits_per_word;
N    // do last partial word
N    if (__n > 0)
N    {
N        __first.__seg_ += __nw;
N        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
N        *__first.__seg_ |= __m;
N    }
N}
N
Ntemplate <class _Cp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Nfill_n(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n, bool __value_)
N{
N    if (__n > 0)
N    {
N        if (__value_)
N            __fill_n_true(__first, __n);
N        else
N            __fill_n_false(__first, __n);
N    }
N}
N
N// fill
N
Ntemplate <class _Cp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Nfill(__bit_iterator<_Cp, false> __first, __bit_iterator<_Cp, false> __last, bool __value_)
N{
N    _VSTD::fill_n(__first, static_cast<typename _Cp::size_type>(__last - __first), __value_);
X    std::__2::fill_n(__first, static_cast<typename _Cp::size_type>(__last - __first), __value_);
N}
N
N// copy
N
Ntemplate <class _Cp, bool _IsConst>
N__bit_iterator<_Cp, false>
N__copy_aligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last,
N                                                     __bit_iterator<_Cp, false> __result)
N{
N    typedef __bit_iterator<_Cp, _IsConst> _In;
N    typedef  typename _In::difference_type difference_type;
N    typedef typename _In::__storage_type __storage_type;
N    const int __bits_per_word = _In::__bits_per_word;
N    difference_type __n = __last - __first;
N    if (__n > 0)
N    {
N        // do first word
N        if (__first.__ctz_ != 0)
N        {
N            unsigned __clz = __bits_per_word - __first.__ctz_;
N            difference_type __dn = _VSTD::min(static_cast<difference_type>(__clz), __n);
X            difference_type __dn = std::__2::min(static_cast<difference_type>(__clz), __n);
N            __n -= __dn;
N            __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz - __dn));
N            __storage_type __b = *__first.__seg_ & __m;
N            *__result.__seg_ &= ~__m;
N            *__result.__seg_ |= __b;
N            __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
N            __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_)  % __bits_per_word);
N            ++__first.__seg_;
N            // __first.__ctz_ = 0;
N        }
N        // __first.__ctz_ == 0;
N        // do middle words
N        __storage_type __nw = __n / __bits_per_word;
N        _VSTD::memmove(_VSTD::__to_raw_pointer(__result.__seg_),
X        std::__2::memmove(std::__2::__to_raw_pointer(__result.__seg_),
N                       _VSTD::__to_raw_pointer(__first.__seg_),
X                       std::__2::__to_raw_pointer(__first.__seg_),
N                       __nw * sizeof(__storage_type));
N        __n -= __nw * __bits_per_word;
N        __result.__seg_ += __nw;
N        // do last word
N        if (__n > 0)
N        {
N            __first.__seg_ += __nw;
N            __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
N            __storage_type __b = *__first.__seg_ & __m;
N            *__result.__seg_ &= ~__m;
N            *__result.__seg_ |= __b;
N            __result.__ctz_ = static_cast<unsigned>(__n);
N        }
N    }
N    return __result;
N}
N
Ntemplate <class _Cp, bool _IsConst>
N__bit_iterator<_Cp, false>
N__copy_unaligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last,
N                                                       __bit_iterator<_Cp, false> __result)
N{
N    typedef __bit_iterator<_Cp, _IsConst> _In;
N    typedef  typename _In::difference_type difference_type;
N    typedef typename _In::__storage_type __storage_type;
N    static const int __bits_per_word = _In::__bits_per_word;
N    difference_type __n = __last - __first;
N    if (__n > 0)
N    {
N        // do first word
N        if (__first.__ctz_ != 0)
N        {
N            unsigned __clz_f = __bits_per_word - __first.__ctz_;
N            difference_type __dn = _VSTD::min(static_cast<difference_type>(__clz_f), __n);
X            difference_type __dn = std::__2::min(static_cast<difference_type>(__clz_f), __n);
N            __n -= __dn;
N            __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
N            __storage_type __b = *__first.__seg_ & __m;
N            unsigned __clz_r = __bits_per_word - __result.__ctz_;
N            __storage_type __ddn = _VSTD::min<__storage_type>(__dn, __clz_r);
X            __storage_type __ddn = std::__2::min<__storage_type>(__dn, __clz_r);
N            __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __ddn));
N            *__result.__seg_ &= ~__m;
N            if (__result.__ctz_ > __first.__ctz_)
N                *__result.__seg_ |= __b << (__result.__ctz_ - __first.__ctz_);
N            else
N                *__result.__seg_ |= __b >> (__first.__ctz_ - __result.__ctz_);
N            __result.__seg_ += (__ddn + __result.__ctz_) / __bits_per_word;
N            __result.__ctz_ = static_cast<unsigned>((__ddn + __result.__ctz_)  % __bits_per_word);
N            __dn -= __ddn;
N            if (__dn > 0)
N            {
N                __m = ~__storage_type(0) >> (__bits_per_word - __dn);
N                *__result.__seg_ &= ~__m;
N                *__result.__seg_ |= __b >> (__first.__ctz_ + __ddn);
N                __result.__ctz_ = static_cast<unsigned>(__dn);
N            }
N            ++__first.__seg_;
N            // __first.__ctz_ = 0;
N        }
N        // __first.__ctz_ == 0;
N        // do middle words
N        unsigned __clz_r = __bits_per_word - __result.__ctz_;
N        __storage_type __m = ~__storage_type(0) << __result.__ctz_;
N        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first.__seg_)
N        {
N            __storage_type __b = *__first.__seg_;
N            *__result.__seg_ &= ~__m;
N            *__result.__seg_ |= __b << __result.__ctz_;
N            ++__result.__seg_;
N            *__result.__seg_ &= __m;
N            *__result.__seg_ |= __b >> __clz_r;
N        }
N        // do last word
N        if (__n > 0)
N        {
N            __m = ~__storage_type(0) >> (__bits_per_word - __n);
N            __storage_type __b = *__first.__seg_ & __m;
N            __storage_type __dn = _VSTD::min(__n, static_cast<difference_type>(__clz_r));
X            __storage_type __dn = std::__2::min(__n, static_cast<difference_type>(__clz_r));
N            __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __dn));
N            *__result.__seg_ &= ~__m;
N            *__result.__seg_ |= __b << __result.__ctz_;
N            __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
N            __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_)  % __bits_per_word);
N            __n -= __dn;
N            if (__n > 0)
N            {
N                __m = ~__storage_type(0) >> (__bits_per_word - __n);
N                *__result.__seg_ &= ~__m;
N                *__result.__seg_ |= __b >> __dn;
N                __result.__ctz_ = static_cast<unsigned>(__n);
N            }
N        }
N    }
N    return __result;
N}
N
Ntemplate <class _Cp, bool _IsConst>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N__bit_iterator<_Cp, false>
Ncopy(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)
N{
N    if (__first.__ctz_ == __result.__ctz_)
N        return __copy_aligned(__first, __last, __result);
N    return __copy_unaligned(__first, __last, __result);
N}
N
N// copy_backward
N
Ntemplate <class _Cp, bool _IsConst>
N__bit_iterator<_Cp, false>
N__copy_backward_aligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last,
N                                                     __bit_iterator<_Cp, false> __result)
N{
N    typedef __bit_iterator<_Cp, _IsConst> _In;
N    typedef  typename _In::difference_type difference_type;
N    typedef typename _In::__storage_type __storage_type;
N    const int __bits_per_word = _In::__bits_per_word;
N    difference_type __n = __last - __first;
N    if (__n > 0)
N    {
N        // do first word
N        if (__last.__ctz_ != 0)
N        {
N            difference_type __dn = _VSTD::min(static_cast<difference_type>(__last.__ctz_), __n);
X            difference_type __dn = std::__2::min(static_cast<difference_type>(__last.__ctz_), __n);
N            __n -= __dn;
N            unsigned __clz = __bits_per_word - __last.__ctz_;
N            __storage_type __m = (~__storage_type(0) << (__last.__ctz_ - __dn)) & (~__storage_type(0) >> __clz);
N            __storage_type __b = *__last.__seg_ & __m;
N            *__result.__seg_ &= ~__m;
N            *__result.__seg_ |= __b;
N            __result.__ctz_ = static_cast<unsigned>(((-__dn & (__bits_per_word - 1)) +
N                                                       __result.__ctz_)  % __bits_per_word);
N            // __last.__ctz_ = 0
N         }
N        // __last.__ctz_ == 0 || __n == 0
N        // __result.__ctz_ == 0 || __n == 0
N        // do middle words
N        __storage_type __nw = __n / __bits_per_word;
N        __result.__seg_ -= __nw;
N        __last.__seg_ -= __nw;
N        _VSTD::memmove(_VSTD::__to_raw_pointer(__result.__seg_),
X        std::__2::memmove(std::__2::__to_raw_pointer(__result.__seg_),
N                       _VSTD::__to_raw_pointer(__last.__seg_),
X                       std::__2::__to_raw_pointer(__last.__seg_),
N                       __nw * sizeof(__storage_type));
N        __n -= __nw * __bits_per_word;
N        // do last word
N        if (__n > 0)
N        {
N            __storage_type __m = ~__storage_type(0) << (__bits_per_word - __n);
N            __storage_type __b = *--__last.__seg_ & __m;
N            *--__result.__seg_ &= ~__m;
N            *__result.__seg_ |= __b;
N            __result.__ctz_ = static_cast<unsigned>(-__n & (__bits_per_word - 1));
N        }
N    }
N    return __result;
N}
N
Ntemplate <class _Cp, bool _IsConst>
N__bit_iterator<_Cp, false>
N__copy_backward_unaligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last,
N                                                       __bit_iterator<_Cp, false> __result)
N{
N    typedef __bit_iterator<_Cp, _IsConst> _In;
N    typedef  typename _In::difference_type difference_type;
N    typedef typename _In::__storage_type __storage_type;
N    const int __bits_per_word = _In::__bits_per_word;
N    difference_type __n = __last - __first;
N    if (__n > 0)
N    {
N        // do first word
N        if (__last.__ctz_ != 0)
N        {
N            difference_type __dn = _VSTD::min(static_cast<difference_type>(__last.__ctz_), __n);
X            difference_type __dn = std::__2::min(static_cast<difference_type>(__last.__ctz_), __n);
N            __n -= __dn;
N            unsigned __clz_l = __bits_per_word - __last.__ctz_;
N            __storage_type __m = (~__storage_type(0) << (__last.__ctz_ - __dn)) & (~__storage_type(0) >> __clz_l);
N            __storage_type __b = *__last.__seg_ & __m;
N            unsigned __clz_r = __bits_per_word - __result.__ctz_;
N            __storage_type __ddn = _VSTD::min(__dn, static_cast<difference_type>(__result.__ctz_));
X            __storage_type __ddn = std::__2::min(__dn, static_cast<difference_type>(__result.__ctz_));
N            if (__ddn > 0)
N            {
N                __m = (~__storage_type(0) << (__result.__ctz_ - __ddn)) & (~__storage_type(0) >> __clz_r);
N                *__result.__seg_ &= ~__m;
N                if (__result.__ctz_ > __last.__ctz_)
N                    *__result.__seg_ |= __b << (__result.__ctz_ - __last.__ctz_);
N                else
N                    *__result.__seg_ |= __b >> (__last.__ctz_ - __result.__ctz_);
N                __result.__ctz_ = static_cast<unsigned>(((-__ddn & (__bits_per_word - 1)) +
N                                                         __result.__ctz_)  % __bits_per_word);
N                __dn -= __ddn;
N            }
N            if (__dn > 0)
N            {
N                // __result.__ctz_ == 0
N                --__result.__seg_;
N                __result.__ctz_ = static_cast<unsigned>(-__dn & (__bits_per_word - 1));
N                __m = ~__storage_type(0) << __result.__ctz_;
N                *__result.__seg_ &= ~__m;
N                __last.__ctz_ -= __dn + __ddn;
N                *__result.__seg_ |= __b << (__result.__ctz_ - __last.__ctz_);
N            }
N            // __last.__ctz_ = 0
N         }
N        // __last.__ctz_ == 0 || __n == 0
N        // __result.__ctz_ != 0 || __n == 0
N        // do middle words
N        unsigned __clz_r = __bits_per_word - __result.__ctz_;
N        __storage_type __m = ~__storage_type(0) >> __clz_r;
N        for (; __n >= __bits_per_word; __n -= __bits_per_word)
N        {
N            __storage_type __b = *--__last.__seg_;
N            *__result.__seg_ &= ~__m;
N            *__result.__seg_ |= __b >> __clz_r;
N            *--__result.__seg_ &= __m;
N            *__result.__seg_ |= __b << __result.__ctz_;
N        }
N        // do last word
N        if (__n > 0)
N        {
N            __m = ~__storage_type(0) << (__bits_per_word - __n);
N            __storage_type __b = *--__last.__seg_ & __m;
N            __clz_r = __bits_per_word - __result.__ctz_;
N            __storage_type __dn = _VSTD::min(__n, static_cast<difference_type>(__result.__ctz_));
X            __storage_type __dn = std::__2::min(__n, static_cast<difference_type>(__result.__ctz_));
N            __m = (~__storage_type(0) << (__result.__ctz_ - __dn)) & (~__storage_type(0) >> __clz_r);
N            *__result.__seg_ &= ~__m;
N            *__result.__seg_ |= __b >> (__bits_per_word - __result.__ctz_);
N            __result.__ctz_ = static_cast<unsigned>(((-__dn & (__bits_per_word - 1)) +
N                                                     __result.__ctz_)  % __bits_per_word);
N            __n -= __dn;
N            if (__n > 0)
N            {
N                // __result.__ctz_ == 0
N                --__result.__seg_;
N                __result.__ctz_ = static_cast<unsigned>(-__n & (__bits_per_word - 1));
N                __m = ~__storage_type(0) << __result.__ctz_;
N                *__result.__seg_ &= ~__m;
N                *__result.__seg_ |= __b << (__result.__ctz_ - (__bits_per_word - __n - __dn));
N            }
N        }
N    }
N    return __result;
N}
N
Ntemplate <class _Cp, bool _IsConst>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N__bit_iterator<_Cp, false>
Ncopy_backward(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)
N{
N    if (__last.__ctz_ == __result.__ctz_)
N        return __copy_backward_aligned(__first, __last, __result);
N    return __copy_backward_unaligned(__first, __last, __result);
N}
N
N// move
N
Ntemplate <class _Cp, bool _IsConst>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N__bit_iterator<_Cp, false>
Nmove(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)
N{
N    return _VSTD::copy(__first, __last, __result);
X    return std::__2::copy(__first, __last, __result);
N}
N
N// move_backward
N
Ntemplate <class _Cp, bool _IsConst>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N__bit_iterator<_Cp, false>
Nmove_backward(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)
N{
N    return _VSTD::copy_backward(__first, __last, __result);
X    return std::__2::copy_backward(__first, __last, __result);
N}
N
N// swap_ranges
N
Ntemplate <class __C1, class __C2>
N__bit_iterator<__C2, false>
N__swap_ranges_aligned(__bit_iterator<__C1, false> __first, __bit_iterator<__C1, false> __last,
N                      __bit_iterator<__C2, false> __result)
N{
N    typedef __bit_iterator<__C1, false> _I1;
N    typedef  typename _I1::difference_type difference_type;
N    typedef typename _I1::__storage_type __storage_type;
N    const int __bits_per_word = _I1::__bits_per_word;
N    difference_type __n = __last - __first;
N    if (__n > 0)
N    {
N        // do first word
N        if (__first.__ctz_ != 0)
N        {
N            unsigned __clz = __bits_per_word - __first.__ctz_;
N            difference_type __dn = _VSTD::min(static_cast<difference_type>(__clz), __n);
X            difference_type __dn = std::__2::min(static_cast<difference_type>(__clz), __n);
N            __n -= __dn;
N            __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz - __dn));
N            __storage_type __b1 = *__first.__seg_ & __m;
N            *__first.__seg_ &= ~__m;
N            __storage_type __b2 = *__result.__seg_ & __m;
N            *__result.__seg_ &= ~__m;
N            *__result.__seg_ |= __b1;
N            *__first.__seg_  |= __b2;
N            __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
N            __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_)  % __bits_per_word);
N            ++__first.__seg_;
N            // __first.__ctz_ = 0;
N        }
N        // __first.__ctz_ == 0;
N        // do middle words
N        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first.__seg_, ++__result.__seg_)
N            swap(*__first.__seg_, *__result.__seg_);
N        // do last word
N        if (__n > 0)
N        {
N            __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
N            __storage_type __b1 = *__first.__seg_ & __m;
N            *__first.__seg_ &= ~__m;
N            __storage_type __b2 = *__result.__seg_ & __m;
N            *__result.__seg_ &= ~__m;
N            *__result.__seg_ |= __b1;
N            *__first.__seg_  |= __b2;
N            __result.__ctz_ = static_cast<unsigned>(__n);
N        }
N    }
N    return __result;
N}
N
Ntemplate <class __C1, class __C2>
N__bit_iterator<__C2, false>
N__swap_ranges_unaligned(__bit_iterator<__C1, false> __first, __bit_iterator<__C1, false> __last,
N                        __bit_iterator<__C2, false> __result)
N{
N    typedef __bit_iterator<__C1, false> _I1;
N    typedef  typename _I1::difference_type difference_type;
N    typedef typename _I1::__storage_type __storage_type;
N    const int __bits_per_word = _I1::__bits_per_word;
N    difference_type __n = __last - __first;
N    if (__n > 0)
N    {
N        // do first word
N        if (__first.__ctz_ != 0)
N        {
N            unsigned __clz_f = __bits_per_word - __first.__ctz_;
N            difference_type __dn = _VSTD::min(static_cast<difference_type>(__clz_f), __n);
X            difference_type __dn = std::__2::min(static_cast<difference_type>(__clz_f), __n);
N            __n -= __dn;
N            __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
N            __storage_type __b1 = *__first.__seg_ & __m;
N            *__first.__seg_ &= ~__m;
N            unsigned __clz_r = __bits_per_word - __result.__ctz_;
N            __storage_type __ddn = _VSTD::min<__storage_type>(__dn, __clz_r);
X            __storage_type __ddn = std::__2::min<__storage_type>(__dn, __clz_r);
N            __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __ddn));
N            __storage_type __b2 = *__result.__seg_ & __m;
N            *__result.__seg_ &= ~__m;
N            if (__result.__ctz_ > __first.__ctz_)
N            {
N                unsigned __s = __result.__ctz_ - __first.__ctz_;
N                *__result.__seg_ |= __b1 << __s;
N                *__first.__seg_  |= __b2 >> __s;
N            }
N            else
N            {
N                unsigned __s = __first.__ctz_ - __result.__ctz_;
N                *__result.__seg_ |= __b1 >> __s;
N                *__first.__seg_  |= __b2 << __s;
N            }
N            __result.__seg_ += (__ddn + __result.__ctz_) / __bits_per_word;
N            __result.__ctz_ = static_cast<unsigned>((__ddn + __result.__ctz_)  % __bits_per_word);
N            __dn -= __ddn;
N            if (__dn > 0)
N            {
N                __m = ~__storage_type(0) >> (__bits_per_word - __dn);
N                __b2 = *__result.__seg_ & __m;
N                *__result.__seg_ &= ~__m;
N                unsigned __s = __first.__ctz_ + __ddn;
N                *__result.__seg_ |= __b1 >> __s;
N                *__first.__seg_  |= __b2 << __s;
N                __result.__ctz_ = static_cast<unsigned>(__dn);
N            }
N            ++__first.__seg_;
N            // __first.__ctz_ = 0;
N        }
N        // __first.__ctz_ == 0;
N        // do middle words
N        __storage_type __m = ~__storage_type(0) << __result.__ctz_;
N        unsigned __clz_r = __bits_per_word - __result.__ctz_;
N        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first.__seg_)
N        {
N            __storage_type __b1 = *__first.__seg_;
N            __storage_type __b2 = *__result.__seg_ & __m;
N            *__result.__seg_ &= ~__m;
N            *__result.__seg_ |= __b1 << __result.__ctz_;
N            *__first.__seg_  = __b2 >> __result.__ctz_;
N            ++__result.__seg_;
N            __b2 = *__result.__seg_ & ~__m;
N            *__result.__seg_ &= __m;
N            *__result.__seg_ |= __b1 >> __clz_r;
N            *__first.__seg_  |= __b2 << __clz_r;
N        }
N        // do last word
N        if (__n > 0)
N        {
N            __m = ~__storage_type(0) >> (__bits_per_word - __n);
N            __storage_type __b1 = *__first.__seg_ & __m;
N            *__first.__seg_ &= ~__m;
N            __storage_type __dn = _VSTD::min<__storage_type>(__n, __clz_r);
X            __storage_type __dn = std::__2::min<__storage_type>(__n, __clz_r);
N            __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __dn));
N            __storage_type __b2 = *__result.__seg_ & __m;
N            *__result.__seg_ &= ~__m;
N            *__result.__seg_ |= __b1 << __result.__ctz_;
N            *__first.__seg_  |= __b2 >> __result.__ctz_;
N            __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
N            __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_)  % __bits_per_word);
N            __n -= __dn;
N            if (__n > 0)
N            {
N                __m = ~__storage_type(0) >> (__bits_per_word - __n);
N                __b2 = *__result.__seg_ & __m;
N                *__result.__seg_ &= ~__m;
N                *__result.__seg_ |= __b1 >> __dn;
N                *__first.__seg_  |= __b2 << __dn;
N                __result.__ctz_ = static_cast<unsigned>(__n);
N            }
N        }
N    }
N    return __result;
N}
N
Ntemplate <class __C1, class __C2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N__bit_iterator<__C2, false>
Nswap_ranges(__bit_iterator<__C1, false> __first1, __bit_iterator<__C1, false> __last1,
N            __bit_iterator<__C2, false> __first2)
N{
N    if (__first1.__ctz_ == __first2.__ctz_)
N        return __swap_ranges_aligned(__first1, __last1, __first2);
N    return __swap_ranges_unaligned(__first1, __last1, __first2);
N}
N
N// rotate
N
Ntemplate <class _Cp>
Nstruct __bit_array
N{
N    typedef typename _Cp::difference_type difference_type;
N    typedef typename _Cp::__storage_type  __storage_type;
N    typedef typename _Cp::__storage_pointer __storage_pointer;
N    typedef typename _Cp::iterator        iterator;
N    static const unsigned __bits_per_word = _Cp::__bits_per_word;
N    static const unsigned _Np = 4;
N
N    difference_type __size_;
N    __storage_type __word_[_Np];
N
N    _LIBCPP_INLINE_VISIBILITY static difference_type capacity()
X    __attribute__ ((__always_inline__)) static difference_type capacity()
N        {return static_cast<difference_type>(_Np * __bits_per_word);}
N    _LIBCPP_INLINE_VISIBILITY explicit __bit_array(difference_type __s) : __size_(__s) {}
X    __attribute__ ((__always_inline__)) explicit __bit_array(difference_type __s) : __size_(__s) {}
N    _LIBCPP_INLINE_VISIBILITY iterator begin()
X    __attribute__ ((__always_inline__)) iterator begin()
N    {
N        return iterator(pointer_traits<__storage_pointer>::pointer_to(__word_[0]), 0);
N    }
N    _LIBCPP_INLINE_VISIBILITY iterator end()
X    __attribute__ ((__always_inline__)) iterator end()
N    {
N        return iterator(pointer_traits<__storage_pointer>::pointer_to(__word_[0]) + __size_ / __bits_per_word,
N                                                  static_cast<unsigned>(__size_ % __bits_per_word));
N    }
N};
N
Ntemplate <class _Cp>
N__bit_iterator<_Cp, false>
Nrotate(__bit_iterator<_Cp, false> __first, __bit_iterator<_Cp, false> __middle, __bit_iterator<_Cp, false> __last)
N{
N    typedef __bit_iterator<_Cp, false> _I1;
N    typedef  typename _I1::difference_type difference_type;
N    difference_type __d1 = __middle - __first;
N    difference_type __d2 = __last - __middle;
N    _I1 __r = __first + __d2;
N    while (__d1 != 0 && __d2 != 0)
N    {
N        if (__d1 <= __d2)
N        {
N            if (__d1 <= __bit_array<_Cp>::capacity())
N            {
N                __bit_array<_Cp> __b(__d1);
N                _VSTD::copy(__first, __middle, __b.begin());
X                std::__2::copy(__first, __middle, __b.begin());
N                _VSTD::copy(__b.begin(), __b.end(), _VSTD::copy(__middle, __last, __first));
X                std::__2::copy(__b.begin(), __b.end(), std::__2::copy(__middle, __last, __first));
N                break;
N            }
N            else
N            {
N                __bit_iterator<_Cp, false> __mp = _VSTD::swap_ranges(__first, __middle, __middle);
X                __bit_iterator<_Cp, false> __mp = std::__2::swap_ranges(__first, __middle, __middle);
N                __first = __middle;
N                __middle = __mp;
N                __d2 -= __d1;
N            }
N        }
N        else
N        {
N            if (__d2 <= __bit_array<_Cp>::capacity())
N            {
N                __bit_array<_Cp> __b(__d2);
N                _VSTD::copy(__middle, __last, __b.begin());
X                std::__2::copy(__middle, __last, __b.begin());
N                _VSTD::copy_backward(__b.begin(), __b.end(), _VSTD::copy_backward(__first, __middle, __last));
X                std::__2::copy_backward(__b.begin(), __b.end(), std::__2::copy_backward(__first, __middle, __last));
N                break;
N            }
N            else
N            {
N                __bit_iterator<_Cp, false> __mp = __first + __d2;
N                _VSTD::swap_ranges(__first, __mp, __middle);
X                std::__2::swap_ranges(__first, __mp, __middle);
N                __first = __mp;
N                __d1 -= __d2;
N            }
N        }
N    }
N    return __r;
N}
N
N// equal
N
Ntemplate <class _Cp, bool _IC1, bool _IC2>
Nbool
N__equal_unaligned(__bit_iterator<_Cp, _IC1> __first1, __bit_iterator<_Cp, _IC1> __last1,
N                  __bit_iterator<_Cp, _IC2> __first2)
N{
N    typedef __bit_iterator<_Cp, _IC1> _It;
N    typedef  typename _It::difference_type difference_type;
N    typedef typename _It::__storage_type __storage_type;
N    static const int __bits_per_word = _It::__bits_per_word;
N    difference_type __n = __last1 - __first1;
N    if (__n > 0)
N    {
N        // do first word
N        if (__first1.__ctz_ != 0)
N        {
N            unsigned __clz_f = __bits_per_word - __first1.__ctz_;
N            difference_type __dn = _VSTD::min(static_cast<difference_type>(__clz_f), __n);
X            difference_type __dn = std::__2::min(static_cast<difference_type>(__clz_f), __n);
N            __n -= __dn;
N            __storage_type __m = (~__storage_type(0) << __first1.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
N            __storage_type __b = *__first1.__seg_ & __m;
N            unsigned __clz_r = __bits_per_word - __first2.__ctz_;
N            __storage_type __ddn = _VSTD::min<__storage_type>(__dn, __clz_r);
X            __storage_type __ddn = std::__2::min<__storage_type>(__dn, __clz_r);
N            __m = (~__storage_type(0) << __first2.__ctz_) & (~__storage_type(0) >> (__clz_r - __ddn));
N            if (__first2.__ctz_ > __first1.__ctz_)
N            {
N                if ((*__first2.__seg_ & __m) != (__b << (__first2.__ctz_ - __first1.__ctz_)))
N                    return false;
N            }
N            else
N            {
N                if ((*__first2.__seg_ & __m) != (__b >> (__first1.__ctz_ - __first2.__ctz_)))
N                    return false;
N            }
N            __first2.__seg_ += (__ddn + __first2.__ctz_) / __bits_per_word;
N            __first2.__ctz_ = static_cast<unsigned>((__ddn + __first2.__ctz_)  % __bits_per_word);
N            __dn -= __ddn;
N            if (__dn > 0)
N            {
N                __m = ~__storage_type(0) >> (__bits_per_word - __dn);
N                if ((*__first2.__seg_ & __m) != (__b >> (__first1.__ctz_ + __ddn)))
N                    return false;
N                __first2.__ctz_ = static_cast<unsigned>(__dn);
N            }
N            ++__first1.__seg_;
N            // __first1.__ctz_ = 0;
N        }
N        // __first1.__ctz_ == 0;
N        // do middle words
N        unsigned __clz_r = __bits_per_word - __first2.__ctz_;
N        __storage_type __m = ~__storage_type(0) << __first2.__ctz_;
N        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first1.__seg_)
N        {
N            __storage_type __b = *__first1.__seg_;
N            if ((*__first2.__seg_ & __m) != (__b << __first2.__ctz_))
N                return false;
N            ++__first2.__seg_;
N            if ((*__first2.__seg_ & ~__m) != (__b >> __clz_r))
N                return false;
N        }
N        // do last word
N        if (__n > 0)
N        {
N            __m = ~__storage_type(0) >> (__bits_per_word - __n);
N            __storage_type __b = *__first1.__seg_ & __m;
N            __storage_type __dn = _VSTD::min(__n, static_cast<difference_type>(__clz_r));
X            __storage_type __dn = std::__2::min(__n, static_cast<difference_type>(__clz_r));
N            __m = (~__storage_type(0) << __first2.__ctz_) & (~__storage_type(0) >> (__clz_r - __dn));
N            if ((*__first2.__seg_ & __m) != (__b << __first2.__ctz_))
N                return false;
N            __first2.__seg_ += (__dn + __first2.__ctz_) / __bits_per_word;
N            __first2.__ctz_ = static_cast<unsigned>((__dn + __first2.__ctz_)  % __bits_per_word);
N            __n -= __dn;
N            if (__n > 0)
N            {
N                __m = ~__storage_type(0) >> (__bits_per_word - __n);
N                if ((*__first2.__seg_ & __m) != (__b >> __dn))
N                    return false;
N            }
N        }
N    }
N    return true;
N}
N
Ntemplate <class _Cp, bool _IC1, bool _IC2>
Nbool
N__equal_aligned(__bit_iterator<_Cp, _IC1> __first1, __bit_iterator<_Cp, _IC1> __last1,
N                __bit_iterator<_Cp, _IC2> __first2)
N{
N    typedef __bit_iterator<_Cp, _IC1> _It;
N    typedef  typename _It::difference_type difference_type;
N    typedef typename _It::__storage_type __storage_type;
N    static const int __bits_per_word = _It::__bits_per_word;
N    difference_type __n = __last1 - __first1;
N    if (__n > 0)
N    {
N        // do first word
N        if (__first1.__ctz_ != 0)
N        {
N            unsigned __clz = __bits_per_word - __first1.__ctz_;
N            difference_type __dn = _VSTD::min(static_cast<difference_type>(__clz), __n);
X            difference_type __dn = std::__2::min(static_cast<difference_type>(__clz), __n);
N            __n -= __dn;
N            __storage_type __m = (~__storage_type(0) << __first1.__ctz_) & (~__storage_type(0) >> (__clz - __dn));
N            if ((*__first2.__seg_ & __m) != (*__first1.__seg_ & __m))
N                return false;
N            ++__first2.__seg_;
N            ++__first1.__seg_;
N            // __first1.__ctz_ = 0;
N            // __first2.__ctz_ = 0;
N        }
N        // __first1.__ctz_ == 0;
N        // __first2.__ctz_ == 0;
N        // do middle words
N        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first1.__seg_, ++__first2.__seg_)
N            if (*__first2.__seg_ != *__first1.__seg_)
N                return false;
N        // do last word
N        if (__n > 0)
N        {
N            __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
N            if ((*__first2.__seg_ & __m) != (*__first1.__seg_ & __m))
N                return false;
N        }
N    }
N    return true;
N}
N
Ntemplate <class _Cp, bool _IC1, bool _IC2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbool
Nequal(__bit_iterator<_Cp, _IC1> __first1, __bit_iterator<_Cp, _IC1> __last1, __bit_iterator<_Cp, _IC2> __first2)
N{
N    if (__first1.__ctz_ == __first2.__ctz_)
N        return __equal_aligned(__first1, __last1, __first2);
N    return __equal_unaligned(__first1, __last1, __first2);
N}
N
Ntemplate <class _Cp, bool _IsConst,
N          typename _Cp::__storage_type>
Nclass __bit_iterator
N{
Npublic:
N    typedef typename _Cp::difference_type                                                          difference_type;
N    typedef bool                                                                                  value_type;
N    typedef __bit_iterator                                                                        pointer;
N    typedef typename conditional<_IsConst, __bit_const_reference<_Cp>, __bit_reference<_Cp> >::type reference;
N    typedef random_access_iterator_tag                                                            iterator_category;
N
Nprivate:
N    typedef typename _Cp::__storage_type                                           __storage_type;
N    typedef typename conditional<_IsConst, typename _Cp::__const_storage_pointer,
N                                           typename _Cp::__storage_pointer>::type  __storage_pointer;
N    static const unsigned __bits_per_word = _Cp::__bits_per_word;
N
N    __storage_pointer __seg_;
N    unsigned          __ctz_;
N
Npublic:
N    _LIBCPP_INLINE_VISIBILITY __bit_iterator() _NOEXCEPT
X    __attribute__ ((__always_inline__)) __bit_iterator() noexcept
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
N    : __seg_(nullptr), __ctz_(0)
N#endif
N    {}
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    __bit_iterator(const __bit_iterator<_Cp, false>& __it) _NOEXCEPT
X    __bit_iterator(const __bit_iterator<_Cp, false>& __it) noexcept
N        : __seg_(__it.__seg_), __ctz_(__it.__ctz_) {}
N
N    _LIBCPP_INLINE_VISIBILITY reference operator*() const _NOEXCEPT
X    __attribute__ ((__always_inline__)) reference operator*() const noexcept
N        {return reference(__seg_, __storage_type(1) << __ctz_);}
N
N    _LIBCPP_INLINE_VISIBILITY __bit_iterator& operator++()
X    __attribute__ ((__always_inline__)) __bit_iterator& operator++()
N    {
N        if (__ctz_ != __bits_per_word-1)
N            ++__ctz_;
N        else
N        {
N            __ctz_ = 0;
N            ++__seg_;
N        }
N        return *this;
N    }
N
N    _LIBCPP_INLINE_VISIBILITY __bit_iterator operator++(int)
X    __attribute__ ((__always_inline__)) __bit_iterator operator++(int)
N    {
N        __bit_iterator __tmp = *this;
N        ++(*this);
N        return __tmp;
N    }
N
N    _LIBCPP_INLINE_VISIBILITY __bit_iterator& operator--()
X    __attribute__ ((__always_inline__)) __bit_iterator& operator--()
N    {
N        if (__ctz_ != 0)
N            --__ctz_;
N        else
N        {
N            __ctz_ = __bits_per_word - 1;
N            --__seg_;
N        }
N        return *this;
N    }
N
N    _LIBCPP_INLINE_VISIBILITY __bit_iterator operator--(int)
X    __attribute__ ((__always_inline__)) __bit_iterator operator--(int)
N    {
N        __bit_iterator __tmp = *this;
N        --(*this);
N        return __tmp;
N    }
N
N    _LIBCPP_INLINE_VISIBILITY __bit_iterator& operator+=(difference_type __n)
X    __attribute__ ((__always_inline__)) __bit_iterator& operator+=(difference_type __n)
N    {
N        if (__n >= 0)
N            __seg_ += (__n + __ctz_) / __bits_per_word;
N        else
N            __seg_ += static_cast<difference_type>(__n - __bits_per_word + __ctz_ + 1)
N                    / static_cast<difference_type>(__bits_per_word);
N        __n &= (__bits_per_word - 1);
N        __ctz_ = static_cast<unsigned>((__n + __ctz_)  % __bits_per_word);
N        return *this;
N    }
N
N    _LIBCPP_INLINE_VISIBILITY __bit_iterator& operator-=(difference_type __n)
X    __attribute__ ((__always_inline__)) __bit_iterator& operator-=(difference_type __n)
N    {
N        return *this += -__n;
N    }
N
N    _LIBCPP_INLINE_VISIBILITY __bit_iterator operator+(difference_type __n) const
X    __attribute__ ((__always_inline__)) __bit_iterator operator+(difference_type __n) const
N    {
N        __bit_iterator __t(*this);
N        __t += __n;
N        return __t;
N    }
N
N    _LIBCPP_INLINE_VISIBILITY __bit_iterator operator-(difference_type __n) const
X    __attribute__ ((__always_inline__)) __bit_iterator operator-(difference_type __n) const
N    {
N        __bit_iterator __t(*this);
N        __t -= __n;
N        return __t;
N    }
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    friend __bit_iterator operator+(difference_type __n, const __bit_iterator& __it) {return __it + __n;}
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    friend difference_type operator-(const __bit_iterator& __x, const __bit_iterator& __y)
N        {return (__x.__seg_ - __y.__seg_) * __bits_per_word + __x.__ctz_ - __y.__ctz_;}
N
N    _LIBCPP_INLINE_VISIBILITY reference operator[](difference_type __n) const {return *(*this + __n);}
X    __attribute__ ((__always_inline__)) reference operator[](difference_type __n) const {return *(*this + __n);}
N
N    _LIBCPP_INLINE_VISIBILITY friend bool operator==(const __bit_iterator& __x, const __bit_iterator& __y)
X    __attribute__ ((__always_inline__)) friend bool operator==(const __bit_iterator& __x, const __bit_iterator& __y)
N        {return __x.__seg_ == __y.__seg_ && __x.__ctz_ == __y.__ctz_;}
N
N    _LIBCPP_INLINE_VISIBILITY friend bool operator!=(const __bit_iterator& __x, const __bit_iterator& __y)
X    __attribute__ ((__always_inline__)) friend bool operator!=(const __bit_iterator& __x, const __bit_iterator& __y)
N        {return !(__x == __y);}
N
N    _LIBCPP_INLINE_VISIBILITY friend bool operator<(const __bit_iterator& __x, const __bit_iterator& __y)
X    __attribute__ ((__always_inline__)) friend bool operator<(const __bit_iterator& __x, const __bit_iterator& __y)
N        {return __x.__seg_ < __y.__seg_ || (__x.__seg_ == __y.__seg_ && __x.__ctz_ < __y.__ctz_);}
N
N    _LIBCPP_INLINE_VISIBILITY friend bool operator>(const __bit_iterator& __x, const __bit_iterator& __y)
X    __attribute__ ((__always_inline__)) friend bool operator>(const __bit_iterator& __x, const __bit_iterator& __y)
N        {return __y < __x;}
N
N    _LIBCPP_INLINE_VISIBILITY friend bool operator<=(const __bit_iterator& __x, const __bit_iterator& __y)
X    __attribute__ ((__always_inline__)) friend bool operator<=(const __bit_iterator& __x, const __bit_iterator& __y)
N        {return !(__y < __x);}
N
N    _LIBCPP_INLINE_VISIBILITY friend bool operator>=(const __bit_iterator& __x, const __bit_iterator& __y)
X    __attribute__ ((__always_inline__)) friend bool operator>=(const __bit_iterator& __x, const __bit_iterator& __y)
N        {return !(__x < __y);}
N
Nprivate:
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    __bit_iterator(__storage_pointer __s, unsigned __ctz) _NOEXCEPT
X    __bit_iterator(__storage_pointer __s, unsigned __ctz) noexcept
N        : __seg_(__s), __ctz_(__ctz) {}
N
N    friend typename _Cp::__self;
N
N    friend class __bit_reference<_Cp>;
N    friend class __bit_const_reference<_Cp>;
N    friend class __bit_iterator<_Cp, true>;
N    template <class _Dp> friend struct __bit_array;
N    template <class _Dp> friend void __fill_n_false(__bit_iterator<_Dp, false> __first, typename _Dp::size_type __n);
N    template <class _Dp> friend void __fill_n_true(__bit_iterator<_Dp, false> __first, typename _Dp::size_type __n);
N    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> __copy_aligned(__bit_iterator<_Dp, _IC> __first,
N                                                                                  __bit_iterator<_Dp, _IC> __last,
N                                                                                  __bit_iterator<_Dp, false> __result);
N    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> __copy_unaligned(__bit_iterator<_Dp, _IC> __first,
N                                                                                    __bit_iterator<_Dp, _IC> __last,
N                                                                                    __bit_iterator<_Dp, false> __result);
N    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> copy(__bit_iterator<_Dp, _IC> __first,
N                                                                        __bit_iterator<_Dp, _IC> __last,
N                                                                        __bit_iterator<_Dp, false> __result);
N    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> __copy_backward_aligned(__bit_iterator<_Dp, _IC> __first,
N                                                                                           __bit_iterator<_Dp, _IC> __last,
N                                                                                           __bit_iterator<_Dp, false> __result);
N    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> __copy_backward_unaligned(__bit_iterator<_Dp, _IC> __first,
N                                                                                             __bit_iterator<_Dp, _IC> __last,
N                                                                                             __bit_iterator<_Dp, false> __result);
N    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> copy_backward(__bit_iterator<_Dp, _IC> __first,
N                                                                                 __bit_iterator<_Dp, _IC> __last,
N                                                                                 __bit_iterator<_Dp, false> __result);
N    template <class __C1, class __C2>friend __bit_iterator<__C2, false> __swap_ranges_aligned(__bit_iterator<__C1, false>,
N                                                                                           __bit_iterator<__C1, false>,
N                                                                                           __bit_iterator<__C2, false>);
N    template <class __C1, class __C2>friend __bit_iterator<__C2, false> __swap_ranges_unaligned(__bit_iterator<__C1, false>,
N                                                                                             __bit_iterator<__C1, false>,
N                                                                                             __bit_iterator<__C2, false>);
N    template <class __C1, class __C2>friend __bit_iterator<__C2, false> swap_ranges(__bit_iterator<__C1, false>,
N                                                                                 __bit_iterator<__C1, false>,
N                                                                                 __bit_iterator<__C2, false>);
N    template <class _Dp> friend __bit_iterator<_Dp, false> rotate(__bit_iterator<_Dp, false>,
N                                                                __bit_iterator<_Dp, false>,
N                                                                __bit_iterator<_Dp, false>);
N    template <class _Dp, bool _IC1, bool _IC2> friend bool __equal_aligned(__bit_iterator<_Dp, _IC1>,
N                                                    __bit_iterator<_Dp, _IC1>,
N                                                    __bit_iterator<_Dp, _IC2>);
N    template <class _Dp, bool _IC1, bool _IC2> friend bool __equal_unaligned(__bit_iterator<_Dp, _IC1>,
N                                                      __bit_iterator<_Dp, _IC1>,
N                                                      __bit_iterator<_Dp, _IC2>);
N    template <class _Dp, bool _IC1, bool _IC2> friend bool equal(__bit_iterator<_Dp, _IC1>,
N                                                                __bit_iterator<_Dp, _IC1>,
N                                                                __bit_iterator<_Dp, _IC2>);
N    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, _IC> __find_bool_true(__bit_iterator<_Dp, _IC>,
N                                                                          typename _Dp::size_type);
N    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, _IC> __find_bool_false(__bit_iterator<_Dp, _IC>,
N                                                                           typename _Dp::size_type);
N    template <class _Dp, bool _IC> friend typename __bit_iterator<_Dp, _IC>::difference_type
N                   __count_bool_true(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
N    template <class _Dp, bool _IC> friend typename __bit_iterator<_Dp, _IC>::difference_type
N                   __count_bool_false(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
N};
N
N_LIBCPP_END_NAMESPACE_STD
X} }
N
N_LIBCPP_POP_MACROS
X_Pragma("pop_macro(\"min\")") _Pragma("pop_macro(\"max\")")
N
N#endif  // _LIBCPP___BIT_REFERENCE
L 118 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/bitset" 2
N#include <cstddef>
N#include <climits>
N#include <string>
N#include <stdexcept>
N#include <iosfwd>
N#include <__functional_base>
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N_LIBCPP_PUSH_MACROS
X_Pragma("push_macro(\"min\")") _Pragma("push_macro(\"max\")")
N#include <__undef_macros>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/__undef_macros" 1
N// -*- C++ -*-
N//===------------------------ __undef_macros ------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is distributed under the University of Illinois Open Source
N// License. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N
N#ifdef min
S#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
S#if defined(_LIBCPP_WARNING)
S_LIBCPP_WARNING("macro min is incompatible with C++.  Try #define NOMINMAX "
S                "before any Windows header. #undefing min")
S#else
S#warning: macro min is incompatible with C++.  #undefing min
S#endif
S#endif
S#undef min
N#endif
N
N#ifdef max
S#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
S#if defined(_LIBCPP_WARNING)
S_LIBCPP_WARNING("macro max is incompatible with C++.  Try #define NOMINMAX "
S                "before any Windows header. #undefing max")
S#else
S#warning: macro max is incompatible with C++.  #undefing max
S#endif
S#endif
S#undef max
N#endif
L 131 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/bitset" 2
N
N
N_LIBCPP_BEGIN_NAMESPACE_STD
Xnamespace std { inline namespace __2 {
N
Ntemplate <size_t _N_words, size_t _Size>
Nclass __bitset;
N
Ntemplate <size_t _N_words, size_t _Size>
Nstruct __has_storage_type<__bitset<_N_words, _Size> >
N{
N    static const bool value = true;
N};
N
Ntemplate <size_t _N_words, size_t _Size>
Nclass __bitset
N{
Npublic:
N    typedef ptrdiff_t              difference_type;
N    typedef size_t                 size_type;
N    typedef size_type              __storage_type;
Nprotected:
N    typedef __bitset __self;
N    typedef       __storage_type*  __storage_pointer;
N    typedef const __storage_type*  __const_storage_pointer;
N    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * CHAR_BIT);
X    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * 8);
N
N    friend class __bit_reference<__bitset>;
N    friend class __bit_const_reference<__bitset>;
N    friend class __bit_iterator<__bitset, false>;
N    friend class __bit_iterator<__bitset, true>;
N    friend struct __bit_array<__bitset>;
N
N    __storage_type __first_[_N_words];
N
N    typedef __bit_reference<__bitset>                  reference;
N    typedef __bit_const_reference<__bitset>            const_reference;
N    typedef __bit_iterator<__bitset, false>            iterator;
N    typedef __bit_iterator<__bitset, true>             const_iterator;
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _LIBCPP_CONSTEXPR __bitset() _NOEXCEPT;
X    constexpr __bitset() noexcept;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    explicit _LIBCPP_CONSTEXPR __bitset(unsigned long long __v) _NOEXCEPT;
X    explicit constexpr __bitset(unsigned long long __v) noexcept;
N
N    _LIBCPP_INLINE_VISIBILITY reference __make_ref(size_t __pos) _NOEXCEPT
X    __attribute__ ((__always_inline__)) reference __make_ref(size_t __pos) noexcept
N        {return reference(__first_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR const_reference __make_ref(size_t __pos) const _NOEXCEPT
X    __attribute__ ((__always_inline__)) constexpr const_reference __make_ref(size_t __pos) const noexcept
N        {return const_reference(__first_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}
N    _LIBCPP_INLINE_VISIBILITY iterator __make_iter(size_t __pos) _NOEXCEPT
X    __attribute__ ((__always_inline__)) iterator __make_iter(size_t __pos) noexcept
N        {return iterator(__first_ + __pos / __bits_per_word, __pos % __bits_per_word);}
N    _LIBCPP_INLINE_VISIBILITY const_iterator __make_iter(size_t __pos) const _NOEXCEPT
X    __attribute__ ((__always_inline__)) const_iterator __make_iter(size_t __pos) const noexcept
N        {return const_iterator(__first_ + __pos / __bits_per_word, __pos % __bits_per_word);}
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    void operator&=(const __bitset& __v) _NOEXCEPT;
X    void operator&=(const __bitset& __v) noexcept;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    void operator|=(const __bitset& __v) _NOEXCEPT;
X    void operator|=(const __bitset& __v) noexcept;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    void operator^=(const __bitset& __v) _NOEXCEPT;
X    void operator^=(const __bitset& __v) noexcept;
N
N    void flip() _NOEXCEPT;
X    void flip() noexcept;
N    _LIBCPP_INLINE_VISIBILITY unsigned long to_ulong() const
X    __attribute__ ((__always_inline__)) unsigned long to_ulong() const
N        {return to_ulong(integral_constant<bool, _Size < sizeof(unsigned long) * CHAR_BIT>());}
X        {return to_ulong(integral_constant<bool, _Size < sizeof(unsigned long) * 8>());}
N    _LIBCPP_INLINE_VISIBILITY unsigned long long to_ullong() const
X    __attribute__ ((__always_inline__)) unsigned long long to_ullong() const
N        {return to_ullong(integral_constant<bool, _Size < sizeof(unsigned long long) * CHAR_BIT>());}
X        {return to_ullong(integral_constant<bool, _Size < sizeof(unsigned long long) * 8>());}
N
N    bool all() const _NOEXCEPT;
X    bool all() const noexcept;
N    bool any() const _NOEXCEPT;
X    bool any() const noexcept;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    size_t __hash_code() const _NOEXCEPT;
X    size_t __hash_code() const noexcept;
Nprivate:
N#ifdef _LIBCPP_CXX03_LANG
S    void __init(unsigned long long __v, false_type) _NOEXCEPT;
S    _LIBCPP_INLINE_VISIBILITY
S    void __init(unsigned long long __v, true_type) _NOEXCEPT;
N#endif  // _LIBCPP_CXX03_LANG
N    unsigned long to_ulong(false_type) const;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    unsigned long to_ulong(true_type) const;
N    unsigned long long to_ullong(false_type) const;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    unsigned long long to_ullong(true_type) const;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    unsigned long long to_ullong(true_type, false_type) const;
N    unsigned long long to_ullong(true_type, true_type) const;
N};
N
Ntemplate <size_t _N_words, size_t _Size>
Ninline
N_LIBCPP_CONSTEXPR
Xconstexpr
N__bitset<_N_words, _Size>::__bitset() _NOEXCEPT
X__bitset<_N_words, _Size>::__bitset() noexcept
N#ifndef _LIBCPP_CXX03_LANG
N    : __first_{0}
N#endif
N{
N#ifdef _LIBCPP_CXX03_LANG
S    _VSTD::fill_n(__first_, _N_words, __storage_type(0));
N#endif
N}
N
N#ifdef _LIBCPP_CXX03_LANG
S
Stemplate <size_t _N_words, size_t _Size>
Svoid
S__bitset<_N_words, _Size>::__init(unsigned long long __v, false_type) _NOEXCEPT
S{
S    __storage_type __t[sizeof(unsigned long long) / sizeof(__storage_type)];
S    for (size_t __i = 0; __i < sizeof(__t)/sizeof(__t[0]); ++__i, __v >>= __bits_per_word)
S        __t[__i] = static_cast<__storage_type>(__v);
S    _VSTD::copy(__t, __t + sizeof(__t)/sizeof(__t[0]), __first_);
S    _VSTD::fill(__first_ + sizeof(__t)/sizeof(__t[0]), __first_ + sizeof(__first_)/sizeof(__first_[0]),
S               __storage_type(0));
S}
S
Stemplate <size_t _N_words, size_t _Size>
Sinline _LIBCPP_INLINE_VISIBILITY
Svoid
S__bitset<_N_words, _Size>::__init(unsigned long long __v, true_type) _NOEXCEPT
S{
S    __first_[0] = __v;
S    _VSTD::fill(__first_ + 1, __first_ + sizeof(__first_)/sizeof(__first_[0]), __storage_type(0));
S}
S
N#endif  // _LIBCPP_CXX03_LANG
N
Ntemplate <size_t _N_words, size_t _Size>
Ninline
N_LIBCPP_CONSTEXPR
Xconstexpr
N__bitset<_N_words, _Size>::__bitset(unsigned long long __v) _NOEXCEPT
X__bitset<_N_words, _Size>::__bitset(unsigned long long __v) noexcept
N#ifndef _LIBCPP_CXX03_LANG
N#if __SIZEOF_SIZE_T__ == __SIZEOF_LONG_LONG__
X#if 4 == 8
S    : __first_{__v}
N#elif __SIZEOF_SIZE_T__ == (__SIZEOF_LONG_LONG__ / 2)
X#elif 4 == (8 / 2)
N    : __first_{static_cast<__storage_type>(__v), static_cast<__storage_type>(__v >> __bits_per_word)}
N#elif __SIZEOF_SIZE_T__ == (__SIZEOF_LONG_LONG__ / 4)
S    : __first_{static_cast<__storage_type>(__v >> (0 * __bits_per_word)),
S               static_cast<__storage_type>(__v >> (1 * __bits_per_word)),
S               static_cast<__storage_type>(__v >> (2 * __bits_per_word)),
S               static_cast<__storage_type>(__v >> (3 * __bits_per_word))}
S#else
S#error This constructor has not been ported to this platform
N#endif
N#endif
N{
N#ifdef _LIBCPP_CXX03_LANG
S    __init(__v, integral_constant<bool, sizeof(unsigned long long) == sizeof(__storage_type)>());
N#endif
N}
N
Ntemplate <size_t _N_words, size_t _Size>
Ninline
Nvoid
N__bitset<_N_words, _Size>::operator&=(const __bitset& __v) _NOEXCEPT
X__bitset<_N_words, _Size>::operator&=(const __bitset& __v) noexcept
N{
N    for (size_type __i = 0; __i < _N_words; ++__i)
N        __first_[__i] &= __v.__first_[__i];
N}
N
Ntemplate <size_t _N_words, size_t _Size>
Ninline
Nvoid
N__bitset<_N_words, _Size>::operator|=(const __bitset& __v) _NOEXCEPT
X__bitset<_N_words, _Size>::operator|=(const __bitset& __v) noexcept
N{
N    for (size_type __i = 0; __i < _N_words; ++__i)
N        __first_[__i] |= __v.__first_[__i];
N}
N
Ntemplate <size_t _N_words, size_t _Size>
Ninline
Nvoid
N__bitset<_N_words, _Size>::operator^=(const __bitset& __v) _NOEXCEPT
X__bitset<_N_words, _Size>::operator^=(const __bitset& __v) noexcept
N{
N    for (size_type __i = 0; __i < _N_words; ++__i)
N        __first_[__i] ^= __v.__first_[__i];
N}
N
Ntemplate <size_t _N_words, size_t _Size>
Nvoid
N__bitset<_N_words, _Size>::flip() _NOEXCEPT
X__bitset<_N_words, _Size>::flip() noexcept
N{
N    // do middle whole words
N    size_type __n = _Size;
N    __storage_pointer __p = __first_;
N    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
N        *__p = ~*__p;
N    // do last partial word
N    if (__n > 0)
N    {
N        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
N        __storage_type __b = *__p & __m;
N        *__p &= ~__m;
N        *__p |= ~__b & __m;
N    }
N}
N
Ntemplate <size_t _N_words, size_t _Size>
Nunsigned long
N__bitset<_N_words, _Size>::to_ulong(false_type) const
N{
N    const_iterator __e = __make_iter(_Size);
N    const_iterator __i = _VSTD::find(__make_iter(sizeof(unsigned long) * CHAR_BIT), __e, true);
X    const_iterator __i = std::__2::find(__make_iter(sizeof(unsigned long) * 8), __e, true);
N    if (__i != __e)
N        __throw_overflow_error("bitset to_ulong overflow error");
N
N    return __first_[0];
N}
N
Ntemplate <size_t _N_words, size_t _Size>
Ninline
Nunsigned long
N__bitset<_N_words, _Size>::to_ulong(true_type) const
N{
N    return __first_[0];
N}
N
Ntemplate <size_t _N_words, size_t _Size>
Nunsigned long long
N__bitset<_N_words, _Size>::to_ullong(false_type) const
N{
N    const_iterator __e = __make_iter(_Size);
N    const_iterator __i = _VSTD::find(__make_iter(sizeof(unsigned long long) * CHAR_BIT), __e, true);
X    const_iterator __i = std::__2::find(__make_iter(sizeof(unsigned long long) * 8), __e, true);
N    if (__i != __e)
N        __throw_overflow_error("bitset to_ullong overflow error");
N
N    return to_ullong(true_type());
N}
N
Ntemplate <size_t _N_words, size_t _Size>
Ninline
Nunsigned long long
N__bitset<_N_words, _Size>::to_ullong(true_type) const
N{
N    return to_ullong(true_type(), integral_constant<bool, sizeof(__storage_type) < sizeof(unsigned long long)>());
N}
N
Ntemplate <size_t _N_words, size_t _Size>
Ninline
Nunsigned long long
N__bitset<_N_words, _Size>::to_ullong(true_type, false_type) const
N{
N    return __first_[0];
N}
N
Ntemplate <size_t _N_words, size_t _Size>
Nunsigned long long
N__bitset<_N_words, _Size>::to_ullong(true_type, true_type) const
N{
N    unsigned long long __r = __first_[0];
N    for (std::size_t __i = 1; __i < sizeof(unsigned long long) / sizeof(__storage_type); ++__i)
N        __r |= static_cast<unsigned long long>(__first_[__i]) << (sizeof(__storage_type) * CHAR_BIT);
X        __r |= static_cast<unsigned long long>(__first_[__i]) << (sizeof(__storage_type) * 8);
N    return __r;
N}
N
Ntemplate <size_t _N_words, size_t _Size>
Nbool
N__bitset<_N_words, _Size>::all() const _NOEXCEPT
X__bitset<_N_words, _Size>::all() const noexcept
N{
N    // do middle whole words
N    size_type __n = _Size;
N    __const_storage_pointer __p = __first_;
N    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
N        if (~*__p)
N            return false;
N    // do last partial word
N    if (__n > 0)
N    {
N        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
N        if (~*__p & __m)
N            return false;
N    }
N    return true;
N}
N
Ntemplate <size_t _N_words, size_t _Size>
Nbool
N__bitset<_N_words, _Size>::any() const _NOEXCEPT
X__bitset<_N_words, _Size>::any() const noexcept
N{
N    // do middle whole words
N    size_type __n = _Size;
N    __const_storage_pointer __p = __first_;
N    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
N        if (*__p)
N            return true;
N    // do last partial word
N    if (__n > 0)
N    {
N        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
N        if (*__p & __m)
N            return true;
N    }
N    return false;
N}
N
Ntemplate <size_t _N_words, size_t _Size>
Ninline
Nsize_t
N__bitset<_N_words, _Size>::__hash_code() const _NOEXCEPT
X__bitset<_N_words, _Size>::__hash_code() const noexcept
N{
N    size_t __h = 0;
N    for (size_type __i = 0; __i < _N_words; ++__i)
N        __h ^= __first_[__i];
N    return __h;
N}
N
Ntemplate <size_t _Size>
Nclass __bitset<1, _Size>
N{
Npublic:
N    typedef ptrdiff_t              difference_type;
N    typedef size_t                 size_type;
N    typedef size_type              __storage_type;
Nprotected:
N    typedef __bitset __self;
N    typedef       __storage_type*  __storage_pointer;
N    typedef const __storage_type*  __const_storage_pointer;
N    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * CHAR_BIT);
X    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * 8);
N
N    friend class __bit_reference<__bitset>;
N    friend class __bit_const_reference<__bitset>;
N    friend class __bit_iterator<__bitset, false>;
N    friend class __bit_iterator<__bitset, true>;
N    friend struct __bit_array<__bitset>;
N
N    __storage_type __first_;
N
N    typedef __bit_reference<__bitset>                  reference;
N    typedef __bit_const_reference<__bitset>            const_reference;
N    typedef __bit_iterator<__bitset, false>            iterator;
N    typedef __bit_iterator<__bitset, true>             const_iterator;
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _LIBCPP_CONSTEXPR __bitset() _NOEXCEPT;
X    constexpr __bitset() noexcept;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    explicit _LIBCPP_CONSTEXPR __bitset(unsigned long long __v) _NOEXCEPT;
X    explicit constexpr __bitset(unsigned long long __v) noexcept;
N
N    _LIBCPP_INLINE_VISIBILITY reference __make_ref(size_t __pos) _NOEXCEPT
X    __attribute__ ((__always_inline__)) reference __make_ref(size_t __pos) noexcept
N        {return reference(&__first_, __storage_type(1) << __pos);}
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR const_reference __make_ref(size_t __pos) const _NOEXCEPT
X    __attribute__ ((__always_inline__)) constexpr const_reference __make_ref(size_t __pos) const noexcept
N        {return const_reference(&__first_, __storage_type(1) << __pos);}
N    _LIBCPP_INLINE_VISIBILITY iterator __make_iter(size_t __pos) _NOEXCEPT
X    __attribute__ ((__always_inline__)) iterator __make_iter(size_t __pos) noexcept
N        {return iterator(&__first_ + __pos / __bits_per_word, __pos % __bits_per_word);}
N    _LIBCPP_INLINE_VISIBILITY const_iterator __make_iter(size_t __pos) const _NOEXCEPT
X    __attribute__ ((__always_inline__)) const_iterator __make_iter(size_t __pos) const noexcept
N        {return const_iterator(&__first_ + __pos / __bits_per_word, __pos % __bits_per_word);}
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    void operator&=(const __bitset& __v) _NOEXCEPT;
X    void operator&=(const __bitset& __v) noexcept;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    void operator|=(const __bitset& __v) _NOEXCEPT;
X    void operator|=(const __bitset& __v) noexcept;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    void operator^=(const __bitset& __v) _NOEXCEPT;
X    void operator^=(const __bitset& __v) noexcept;
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    void flip() _NOEXCEPT;
X    void flip() noexcept;
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    unsigned long to_ulong() const;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    unsigned long long to_ullong() const;
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    bool all() const _NOEXCEPT;
X    bool all() const noexcept;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    bool any() const _NOEXCEPT;
X    bool any() const noexcept;
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    size_t __hash_code() const _NOEXCEPT;
X    size_t __hash_code() const noexcept;
N};
N
Ntemplate <size_t _Size>
Ninline
N_LIBCPP_CONSTEXPR
Xconstexpr
N__bitset<1, _Size>::__bitset() _NOEXCEPT
X__bitset<1, _Size>::__bitset() noexcept
N    : __first_(0)
N{
N}
N
Ntemplate <size_t _Size>
Ninline
N_LIBCPP_CONSTEXPR
Xconstexpr
N__bitset<1, _Size>::__bitset(unsigned long long __v) _NOEXCEPT
X__bitset<1, _Size>::__bitset(unsigned long long __v) noexcept
N    : __first_(static_cast<__storage_type>(__v))
N{
N}
N
Ntemplate <size_t _Size>
Ninline
Nvoid
N__bitset<1, _Size>::operator&=(const __bitset& __v) _NOEXCEPT
X__bitset<1, _Size>::operator&=(const __bitset& __v) noexcept
N{
N    __first_ &= __v.__first_;
N}
N
Ntemplate <size_t _Size>
Ninline
Nvoid
N__bitset<1, _Size>::operator|=(const __bitset& __v) _NOEXCEPT
X__bitset<1, _Size>::operator|=(const __bitset& __v) noexcept
N{
N    __first_ |= __v.__first_;
N}
N
Ntemplate <size_t _Size>
Ninline
Nvoid
N__bitset<1, _Size>::operator^=(const __bitset& __v) _NOEXCEPT
X__bitset<1, _Size>::operator^=(const __bitset& __v) noexcept
N{
N    __first_ ^= __v.__first_;
N}
N
Ntemplate <size_t _Size>
Ninline
Nvoid
N__bitset<1, _Size>::flip() _NOEXCEPT
X__bitset<1, _Size>::flip() noexcept
N{
N    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - _Size);
N    __first_ = ~__first_;
N    __first_ &= __m;
N}
N
Ntemplate <size_t _Size>
Ninline
Nunsigned long
N__bitset<1, _Size>::to_ulong() const
N{
N    return __first_;
N}
N
Ntemplate <size_t _Size>
Ninline
Nunsigned long long
N__bitset<1, _Size>::to_ullong() const
N{
N    return __first_;
N}
N
Ntemplate <size_t _Size>
Ninline
Nbool
N__bitset<1, _Size>::all() const _NOEXCEPT
X__bitset<1, _Size>::all() const noexcept
N{
N    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - _Size);
N    return !(~__first_ & __m);
N}
N
Ntemplate <size_t _Size>
Ninline
Nbool
N__bitset<1, _Size>::any() const _NOEXCEPT
X__bitset<1, _Size>::any() const noexcept
N{
N    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - _Size);
N    return __first_ & __m;
N}
N
Ntemplate <size_t _Size>
Ninline
Nsize_t
N__bitset<1, _Size>::__hash_code() const _NOEXCEPT
X__bitset<1, _Size>::__hash_code() const noexcept
N{
N    return __first_;
N}
N
Ntemplate <>
Nclass __bitset<0, 0>
N{
Npublic:
N    typedef ptrdiff_t              difference_type;
N    typedef size_t                 size_type;
N    typedef size_type              __storage_type;
Nprotected:
N    typedef __bitset __self;
N    typedef       __storage_type*  __storage_pointer;
N    typedef const __storage_type*  __const_storage_pointer;
N    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * CHAR_BIT);
X    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * 8);
N
N    friend class __bit_reference<__bitset>;
N    friend class __bit_const_reference<__bitset>;
N    friend class __bit_iterator<__bitset, false>;
N    friend class __bit_iterator<__bitset, true>;
N    friend struct __bit_array<__bitset>;
N
N    typedef __bit_reference<__bitset>                  reference;
N    typedef __bit_const_reference<__bitset>            const_reference;
N    typedef __bit_iterator<__bitset, false>            iterator;
N    typedef __bit_iterator<__bitset, true>             const_iterator;
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    _LIBCPP_CONSTEXPR __bitset() _NOEXCEPT;
X    constexpr __bitset() noexcept;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    explicit _LIBCPP_CONSTEXPR __bitset(unsigned long long) _NOEXCEPT;
X    explicit constexpr __bitset(unsigned long long) noexcept;
N
N    _LIBCPP_INLINE_VISIBILITY reference __make_ref(size_t) _NOEXCEPT
X    __attribute__ ((__always_inline__)) reference __make_ref(size_t) noexcept
N        {return reference(0, 1);}
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR const_reference __make_ref(size_t) const _NOEXCEPT
X    __attribute__ ((__always_inline__)) constexpr const_reference __make_ref(size_t) const noexcept
N        {return const_reference(0, 1);}
N    _LIBCPP_INLINE_VISIBILITY iterator __make_iter(size_t) _NOEXCEPT
X    __attribute__ ((__always_inline__)) iterator __make_iter(size_t) noexcept
N        {return iterator(0, 0);}
N    _LIBCPP_INLINE_VISIBILITY const_iterator __make_iter(size_t) const _NOEXCEPT
X    __attribute__ ((__always_inline__)) const_iterator __make_iter(size_t) const noexcept
N        {return const_iterator(0, 0);}
N
N    _LIBCPP_INLINE_VISIBILITY void operator&=(const __bitset&) _NOEXCEPT {}
X    __attribute__ ((__always_inline__)) void operator&=(const __bitset&) noexcept {}
N    _LIBCPP_INLINE_VISIBILITY void operator|=(const __bitset&) _NOEXCEPT {}
X    __attribute__ ((__always_inline__)) void operator|=(const __bitset&) noexcept {}
N    _LIBCPP_INLINE_VISIBILITY void operator^=(const __bitset&) _NOEXCEPT {}
X    __attribute__ ((__always_inline__)) void operator^=(const __bitset&) noexcept {}
N
N    _LIBCPP_INLINE_VISIBILITY void flip() _NOEXCEPT {}
X    __attribute__ ((__always_inline__)) void flip() noexcept {}
N
N    _LIBCPP_INLINE_VISIBILITY unsigned long to_ulong() const {return 0;}
X    __attribute__ ((__always_inline__)) unsigned long to_ulong() const {return 0;}
N    _LIBCPP_INLINE_VISIBILITY unsigned long long to_ullong() const {return 0;}
X    __attribute__ ((__always_inline__)) unsigned long long to_ullong() const {return 0;}
N
N    _LIBCPP_INLINE_VISIBILITY bool all() const _NOEXCEPT {return true;}
X    __attribute__ ((__always_inline__)) bool all() const noexcept {return true;}
N    _LIBCPP_INLINE_VISIBILITY bool any() const _NOEXCEPT {return false;}
X    __attribute__ ((__always_inline__)) bool any() const noexcept {return false;}
N
N    _LIBCPP_INLINE_VISIBILITY size_t __hash_code() const _NOEXCEPT {return 0;}
X    __attribute__ ((__always_inline__)) size_t __hash_code() const noexcept {return 0;}
N};
N
Ninline
N_LIBCPP_CONSTEXPR
Xconstexpr
N__bitset<0, 0>::__bitset() _NOEXCEPT
X__bitset<0, 0>::__bitset() noexcept
N{
N}
N
Ninline
N_LIBCPP_CONSTEXPR
Xconstexpr
N__bitset<0, 0>::__bitset(unsigned long long) _NOEXCEPT
X__bitset<0, 0>::__bitset(unsigned long long) noexcept
N{
N}
N
Ntemplate <size_t _Size> class _LIBCPP_TEMPLATE_VIS bitset;
Xtemplate <size_t _Size> class  bitset;
Ntemplate <size_t _Size> struct hash<bitset<_Size> >;
N
Ntemplate <size_t _Size>
Nclass _LIBCPP_TEMPLATE_VIS bitset
Xclass  bitset
N    : private __bitset<_Size == 0 ? 0 : (_Size - 1) / (sizeof(size_t) * CHAR_BIT) + 1, _Size>
X    : private __bitset<_Size == 0 ? 0 : (_Size - 1) / (sizeof(size_t) * 8) + 1, _Size>
N{
Npublic:
N    static const unsigned __n_words = _Size == 0 ? 0 : (_Size - 1) / (sizeof(size_t) * CHAR_BIT) + 1;
X    static const unsigned __n_words = _Size == 0 ? 0 : (_Size - 1) / (sizeof(size_t) * 8) + 1;
N    typedef __bitset<__n_words, _Size> base;
N
Npublic:
N    typedef typename base::reference       reference;
N    typedef typename base::const_reference const_reference;
N
N    // 23.3.5.1 constructors:
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR bitset() _NOEXCEPT {}
X    __attribute__ ((__always_inline__)) constexpr bitset() noexcept {}
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
X    __attribute__ ((__always_inline__)) constexpr
N        bitset(unsigned long long __v) _NOEXCEPT : base(__v) {}
X        bitset(unsigned long long __v) noexcept : base(__v) {}
N    template<class _CharT>
N        explicit bitset(const _CharT* __str,
N                        typename basic_string<_CharT>::size_type __n = basic_string<_CharT>::npos,
N                        _CharT __zero = _CharT('0'), _CharT __one = _CharT('1'));
N    template<class _CharT, class _Traits, class _Allocator>
N        explicit bitset(const basic_string<_CharT,_Traits,_Allocator>& __str,
N                        typename basic_string<_CharT,_Traits,_Allocator>::size_type __pos = 0,
N                        typename basic_string<_CharT,_Traits,_Allocator>::size_type __n =
N                                (basic_string<_CharT,_Traits,_Allocator>::npos),
N                        _CharT __zero = _CharT('0'), _CharT __one = _CharT('1'));
N
N    // 23.3.5.2 bitset operations:
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    bitset& operator&=(const bitset& __rhs) _NOEXCEPT;
X    bitset& operator&=(const bitset& __rhs) noexcept;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    bitset& operator|=(const bitset& __rhs) _NOEXCEPT;
X    bitset& operator|=(const bitset& __rhs) noexcept;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    bitset& operator^=(const bitset& __rhs) _NOEXCEPT;
X    bitset& operator^=(const bitset& __rhs) noexcept;
N    bitset& operator<<=(size_t __pos) _NOEXCEPT;
X    bitset& operator<<=(size_t __pos) noexcept;
N    bitset& operator>>=(size_t __pos) _NOEXCEPT;
X    bitset& operator>>=(size_t __pos) noexcept;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    bitset& set() _NOEXCEPT;
X    bitset& set() noexcept;
N    bitset& set(size_t __pos, bool __val = true);
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    bitset& reset() _NOEXCEPT;
X    bitset& reset() noexcept;
N    bitset& reset(size_t __pos);
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    bitset  operator~() const _NOEXCEPT;
X    bitset  operator~() const noexcept;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    bitset& flip() _NOEXCEPT;
X    bitset& flip() noexcept;
N    bitset& flip(size_t __pos);
N
N    // element access:
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
X    __attribute__ ((__always_inline__)) constexpr
N                              const_reference operator[](size_t __p) const {return base::__make_ref(__p);}
N    _LIBCPP_INLINE_VISIBILITY       reference operator[](size_t __p)       {return base::__make_ref(__p);}
X    __attribute__ ((__always_inline__))       reference operator[](size_t __p)       {return base::__make_ref(__p);}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    unsigned long to_ulong() const;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    unsigned long long to_ullong() const;
N    template <class _CharT, class _Traits, class _Allocator>
N        basic_string<_CharT, _Traits, _Allocator> to_string(_CharT __zero = _CharT('0'),
N                                                            _CharT __one = _CharT('1')) const;
N    template <class _CharT, class _Traits>
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        basic_string<_CharT, _Traits, allocator<_CharT> > to_string(_CharT __zero = _CharT('0'),
N                                                                    _CharT __one = _CharT('1')) const;
N    template <class _CharT>
N        _LIBCPP_INLINE_VISIBILITY
X        __attribute__ ((__always_inline__))
N        basic_string<_CharT, char_traits<_CharT>, allocator<_CharT> > to_string(_CharT __zero = _CharT('0'),
N                                                                                _CharT __one = _CharT('1')) const;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    basic_string<char, char_traits<char>, allocator<char> > to_string(char __zero = '0',
N                                                                      char __one = '1') const;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    size_t count() const _NOEXCEPT;
X    size_t count() const noexcept;
N    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR size_t size() const _NOEXCEPT {return _Size;}
X    __attribute__ ((__always_inline__)) constexpr size_t size() const noexcept {return _Size;}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    bool operator==(const bitset& __rhs) const _NOEXCEPT;
X    bool operator==(const bitset& __rhs) const noexcept;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    bool operator!=(const bitset& __rhs) const _NOEXCEPT;
X    bool operator!=(const bitset& __rhs) const noexcept;
N    bool test(size_t __pos) const;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    bool all() const _NOEXCEPT;
X    bool all() const noexcept;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    bool any() const _NOEXCEPT;
X    bool any() const noexcept;
N    _LIBCPP_INLINE_VISIBILITY bool none() const _NOEXCEPT {return !any();}
X    __attribute__ ((__always_inline__)) bool none() const noexcept {return !any();}
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    bitset operator<<(size_t __pos) const _NOEXCEPT;
X    bitset operator<<(size_t __pos) const noexcept;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    bitset operator>>(size_t __pos) const _NOEXCEPT;
X    bitset operator>>(size_t __pos) const noexcept;
N
Nprivate:
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    size_t __hash_code() const _NOEXCEPT {return base::__hash_code();}
X    size_t __hash_code() const noexcept {return base::__hash_code();}
N
N    friend struct hash<bitset>;
N};
N
Ntemplate <size_t _Size>
Ntemplate<class _CharT>
Nbitset<_Size>::bitset(const _CharT* __str,
N                      typename basic_string<_CharT>::size_type __n,
N                      _CharT __zero, _CharT __one)
N{
N    size_t __rlen = _VSTD::min(__n, char_traits<_CharT>::length(__str));
X    size_t __rlen = std::__2::min(__n, char_traits<_CharT>::length(__str));
N    for (size_t __i = 0; __i < __rlen; ++__i)
N        if (__str[__i] != __zero && __str[__i] != __one)
N            __throw_invalid_argument("bitset string ctor has invalid argument");
N
N    size_t _Mp = _VSTD::min(__rlen, _Size);
X    size_t _Mp = std::__2::min(__rlen, _Size);
N    size_t __i = 0;
N    for (; __i < _Mp; ++__i)
N    {
N        _CharT __c = __str[_Mp - 1 - __i];
N        if (__c == __zero)
N            (*this)[__i] = false;
N        else
N            (*this)[__i] = true;
N    }
N    _VSTD::fill(base::__make_iter(__i), base::__make_iter(_Size), false);
X    std::__2::fill(base::__make_iter(__i), base::__make_iter(_Size), false);
N}
N
Ntemplate <size_t _Size>
Ntemplate<class _CharT, class _Traits, class _Allocator>
Nbitset<_Size>::bitset(const basic_string<_CharT,_Traits,_Allocator>& __str,
N       typename basic_string<_CharT,_Traits,_Allocator>::size_type __pos,
N       typename basic_string<_CharT,_Traits,_Allocator>::size_type __n,
N       _CharT __zero, _CharT __one)
N{
N    if (__pos > __str.size())
N        __throw_out_of_range("bitset string pos out of range");
N
N    size_t __rlen = _VSTD::min(__n, __str.size() - __pos);
X    size_t __rlen = std::__2::min(__n, __str.size() - __pos);
N    for (size_t __i = __pos; __i < __pos + __rlen; ++__i)
N        if (!_Traits::eq(__str[__i], __zero) && !_Traits::eq(__str[__i], __one))
N            __throw_invalid_argument("bitset string ctor has invalid argument");
N
N    size_t _Mp = _VSTD::min(__rlen, _Size);
X    size_t _Mp = std::__2::min(__rlen, _Size);
N    size_t __i = 0;
N    for (; __i < _Mp; ++__i)
N    {
N        _CharT __c = __str[__pos + _Mp - 1 - __i];
N        if (_Traits::eq(__c, __zero))
N            (*this)[__i] = false;
N        else
N            (*this)[__i] = true;
N    }
N    _VSTD::fill(base::__make_iter(__i), base::__make_iter(_Size), false);
X    std::__2::fill(base::__make_iter(__i), base::__make_iter(_Size), false);
N}
N
Ntemplate <size_t _Size>
Ninline
Nbitset<_Size>&
Nbitset<_Size>::operator&=(const bitset& __rhs) _NOEXCEPT
Xbitset<_Size>::operator&=(const bitset& __rhs) noexcept
N{
N    base::operator&=(__rhs);
N    return *this;
N}
N
Ntemplate <size_t _Size>
Ninline
Nbitset<_Size>&
Nbitset<_Size>::operator|=(const bitset& __rhs) _NOEXCEPT
Xbitset<_Size>::operator|=(const bitset& __rhs) noexcept
N{
N    base::operator|=(__rhs);
N    return *this;
N}
N
Ntemplate <size_t _Size>
Ninline
Nbitset<_Size>&
Nbitset<_Size>::operator^=(const bitset& __rhs) _NOEXCEPT
Xbitset<_Size>::operator^=(const bitset& __rhs) noexcept
N{
N    base::operator^=(__rhs);
N    return *this;
N}
N
Ntemplate <size_t _Size>
Nbitset<_Size>&
Nbitset<_Size>::operator<<=(size_t __pos) _NOEXCEPT
Xbitset<_Size>::operator<<=(size_t __pos) noexcept
N{
N    __pos = _VSTD::min(__pos, _Size);
X    __pos = std::__2::min(__pos, _Size);
N    _VSTD::copy_backward(base::__make_iter(0), base::__make_iter(_Size - __pos), base::__make_iter(_Size));
X    std::__2::copy_backward(base::__make_iter(0), base::__make_iter(_Size - __pos), base::__make_iter(_Size));
N    _VSTD::fill_n(base::__make_iter(0), __pos, false);
X    std::__2::fill_n(base::__make_iter(0), __pos, false);
N    return *this;
N}
N
Ntemplate <size_t _Size>
Nbitset<_Size>&
Nbitset<_Size>::operator>>=(size_t __pos) _NOEXCEPT
Xbitset<_Size>::operator>>=(size_t __pos) noexcept
N{
N    __pos = _VSTD::min(__pos, _Size);
X    __pos = std::__2::min(__pos, _Size);
N    _VSTD::copy(base::__make_iter(__pos), base::__make_iter(_Size), base::__make_iter(0));
X    std::__2::copy(base::__make_iter(__pos), base::__make_iter(_Size), base::__make_iter(0));
N    _VSTD::fill_n(base::__make_iter(_Size - __pos), __pos, false);
X    std::__2::fill_n(base::__make_iter(_Size - __pos), __pos, false);
N    return *this;
N}
N
Ntemplate <size_t _Size>
Ninline
Nbitset<_Size>&
Nbitset<_Size>::set() _NOEXCEPT
Xbitset<_Size>::set() noexcept
N{
N    _VSTD::fill_n(base::__make_iter(0), _Size, true);
X    std::__2::fill_n(base::__make_iter(0), _Size, true);
N    return *this;
N}
N
Ntemplate <size_t _Size>
Nbitset<_Size>&
Nbitset<_Size>::set(size_t __pos, bool __val)
N{
N    if (__pos >= _Size)
N        __throw_out_of_range("bitset set argument out of range");
N
N    (*this)[__pos] = __val;
N    return *this;
N}
N
Ntemplate <size_t _Size>
Ninline
Nbitset<_Size>&
Nbitset<_Size>::reset() _NOEXCEPT
Xbitset<_Size>::reset() noexcept
N{
N    _VSTD::fill_n(base::__make_iter(0), _Size, false);
X    std::__2::fill_n(base::__make_iter(0), _Size, false);
N    return *this;
N}
N
Ntemplate <size_t _Size>
Nbitset<_Size>&
Nbitset<_Size>::reset(size_t __pos)
N{
N    if (__pos >= _Size)
N        __throw_out_of_range("bitset reset argument out of range");
N
N    (*this)[__pos] = false;
N    return *this;
N}
N
Ntemplate <size_t _Size>
Ninline
Nbitset<_Size>
Nbitset<_Size>::operator~() const _NOEXCEPT
Xbitset<_Size>::operator~() const noexcept
N{
N    bitset __x(*this);
N    __x.flip();
N    return __x;
N}
N
Ntemplate <size_t _Size>
Ninline
Nbitset<_Size>&
Nbitset<_Size>::flip() _NOEXCEPT
Xbitset<_Size>::flip() noexcept
N{
N    base::flip();
N    return *this;
N}
N
Ntemplate <size_t _Size>
Nbitset<_Size>&
Nbitset<_Size>::flip(size_t __pos)
N{
N    if (__pos >= _Size)
N        __throw_out_of_range("bitset flip argument out of range");
N
N    reference r = base::__make_ref(__pos);
N    r = ~r;
N    return *this;
N}
N
Ntemplate <size_t _Size>
Ninline
Nunsigned long
Nbitset<_Size>::to_ulong() const
N{
N    return base::to_ulong();
N}
N
Ntemplate <size_t _Size>
Ninline
Nunsigned long long
Nbitset<_Size>::to_ullong() const
N{
N    return base::to_ullong();
N}
N
Ntemplate <size_t _Size>
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>
Nbitset<_Size>::to_string(_CharT __zero, _CharT __one) const
N{
N    basic_string<_CharT, _Traits, _Allocator> __r(_Size, __zero);
N    for (size_t __i = 0; __i < _Size; ++__i)
N    {
N        if ((*this)[__i])
N            __r[_Size - 1 - __i] = __one;
N    }
N    return __r;
N}
N
Ntemplate <size_t _Size>
Ntemplate <class _CharT, class _Traits>
Ninline
Nbasic_string<_CharT, _Traits, allocator<_CharT> >
Nbitset<_Size>::to_string(_CharT __zero, _CharT __one) const
N{
N    return to_string<_CharT, _Traits, allocator<_CharT> >(__zero, __one);
N}
N
Ntemplate <size_t _Size>
Ntemplate <class _CharT>
Ninline
Nbasic_string<_CharT, char_traits<_CharT>, allocator<_CharT> >
Nbitset<_Size>::to_string(_CharT __zero, _CharT __one) const
N{
N    return to_string<_CharT, char_traits<_CharT>, allocator<_CharT> >(__zero, __one);
N}
N
Ntemplate <size_t _Size>
Ninline
Nbasic_string<char, char_traits<char>, allocator<char> >
Nbitset<_Size>::to_string(char __zero, char __one) const
N{
N    return to_string<char, char_traits<char>, allocator<char> >(__zero, __one);
N}
N
Ntemplate <size_t _Size>
Ninline
Nsize_t
Nbitset<_Size>::count() const _NOEXCEPT
Xbitset<_Size>::count() const noexcept
N{
N    return static_cast<size_t>(_VSTD::count(base::__make_iter(0), base::__make_iter(_Size), true));
X    return static_cast<size_t>(std::__2::count(base::__make_iter(0), base::__make_iter(_Size), true));
N}
N
Ntemplate <size_t _Size>
Ninline
Nbool
Nbitset<_Size>::operator==(const bitset& __rhs) const _NOEXCEPT
Xbitset<_Size>::operator==(const bitset& __rhs) const noexcept
N{
N    return _VSTD::equal(base::__make_iter(0), base::__make_iter(_Size), __rhs.__make_iter(0));
X    return std::__2::equal(base::__make_iter(0), base::__make_iter(_Size), __rhs.__make_iter(0));
N}
N
Ntemplate <size_t _Size>
Ninline
Nbool
Nbitset<_Size>::operator!=(const bitset& __rhs) const _NOEXCEPT
Xbitset<_Size>::operator!=(const bitset& __rhs) const noexcept
N{
N    return !(*this == __rhs);
N}
N
Ntemplate <size_t _Size>
Nbool
Nbitset<_Size>::test(size_t __pos) const
N{
N    if (__pos >= _Size)
N        __throw_out_of_range("bitset test argument out of range");
N
N    return (*this)[__pos];
N}
N
Ntemplate <size_t _Size>
Ninline
Nbool
Nbitset<_Size>::all() const _NOEXCEPT
Xbitset<_Size>::all() const noexcept
N{
N    return base::all();
N}
N
Ntemplate <size_t _Size>
Ninline
Nbool
Nbitset<_Size>::any() const _NOEXCEPT
Xbitset<_Size>::any() const noexcept
N{
N    return base::any();
N}
N
Ntemplate <size_t _Size>
Ninline
Nbitset<_Size>
Nbitset<_Size>::operator<<(size_t __pos) const _NOEXCEPT
Xbitset<_Size>::operator<<(size_t __pos) const noexcept
N{
N    bitset __r = *this;
N    __r <<= __pos;
N    return __r;
N}
N
Ntemplate <size_t _Size>
Ninline
Nbitset<_Size>
Nbitset<_Size>::operator>>(size_t __pos) const _NOEXCEPT
Xbitset<_Size>::operator>>(size_t __pos) const noexcept
N{
N    bitset __r = *this;
N    __r >>= __pos;
N    return __r;
N}
N
Ntemplate <size_t _Size>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbitset<_Size>
Noperator&(const bitset<_Size>& __x, const bitset<_Size>& __y) _NOEXCEPT
Xoperator&(const bitset<_Size>& __x, const bitset<_Size>& __y) noexcept
N{
N    bitset<_Size> __r = __x;
N    __r &= __y;
N    return __r;
N}
N
Ntemplate <size_t _Size>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbitset<_Size>
Noperator|(const bitset<_Size>& __x, const bitset<_Size>& __y) _NOEXCEPT
Xoperator|(const bitset<_Size>& __x, const bitset<_Size>& __y) noexcept
N{
N    bitset<_Size> __r = __x;
N    __r |= __y;
N    return __r;
N}
N
Ntemplate <size_t _Size>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbitset<_Size>
Noperator^(const bitset<_Size>& __x, const bitset<_Size>& __y) _NOEXCEPT
Xoperator^(const bitset<_Size>& __x, const bitset<_Size>& __y) noexcept
N{
N    bitset<_Size> __r = __x;
N    __r ^= __y;
N    return __r;
N}
N
Ntemplate <size_t _Size>
Nstruct _LIBCPP_TEMPLATE_VIS hash<bitset<_Size> >
Xstruct  hash<bitset<_Size> >
N    : public unary_function<bitset<_Size>, size_t>
N{
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    size_t operator()(const bitset<_Size>& __bs) const _NOEXCEPT
X    size_t operator()(const bitset<_Size>& __bs) const noexcept
N        {return __bs.__hash_code();}
N};
N
Ntemplate <class _CharT, class _Traits, size_t _Size>
Nbasic_istream<_CharT, _Traits>&
Noperator>>(basic_istream<_CharT, _Traits>& __is, bitset<_Size>& __x);
N
Ntemplate <class _CharT, class _Traits, size_t _Size>
Nbasic_ostream<_CharT, _Traits>&
Noperator<<(basic_ostream<_CharT, _Traits>& __os, const bitset<_Size>& __x);
N
N_LIBCPP_END_NAMESPACE_STD
X} }
N
N_LIBCPP_POP_MACROS
X_Pragma("pop_macro(\"min\")") _Pragma("pop_macro(\"max\")")
N
N#endif  // _LIBCPP_BITSET
L 143 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/ostream" 2
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N_LIBCPP_BEGIN_NAMESPACE_STD
Xnamespace std { inline namespace __2 {
N
Ntemplate <class _CharT, class _Traits>
Nclass _LIBCPP_TEMPLATE_VIS basic_ostream
Xclass  basic_ostream
N    : virtual public basic_ios<_CharT, _Traits>
N{
Npublic:
N    // types (inherited from basic_ios (27.5.4)):
N    typedef _CharT                         char_type;
N    typedef _Traits                        traits_type;
N    typedef typename traits_type::int_type int_type;
N    typedef typename traits_type::pos_type pos_type;
N    typedef typename traits_type::off_type off_type;
N
N    // 27.7.2.2 Constructor/destructor:
N    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY
X    inline __attribute__((__always_inline__))
N    explicit basic_ostream(basic_streambuf<char_type, traits_type>* __sb)
N    { this->init(__sb); }
N    virtual ~basic_ostream();
Nprotected:
N#ifndef _LIBCPP_CXX03_LANG
N    inline _LIBCPP_INLINE_VISIBILITY
X    inline __attribute__ ((__always_inline__))
N    basic_ostream(basic_ostream&& __rhs);
N
N    // 27.7.2.3 Assign/swap
N    inline _LIBCPP_INLINE_VISIBILITY
X    inline __attribute__ ((__always_inline__))
N    basic_ostream& operator=(basic_ostream&& __rhs);
N#endif
N    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY
X    inline __attribute__((__always_inline__))
N    void swap(basic_ostream& __rhs)
N    { basic_ios<char_type, traits_type>::swap(__rhs); }
N
N#ifndef _LIBCPP_CXX03_LANG
N    basic_ostream           (const basic_ostream& __rhs) = delete;
N    basic_ostream& operator=(const basic_ostream& __rhs) = delete;
N#else
S    basic_ostream           (const basic_ostream& __rhs); // not defined
S    basic_ostream& operator=(const basic_ostream& __rhs); // not defined
N#endif
Npublic:
N
N    // 27.7.2.4 Prefix/suffix:
N    class _LIBCPP_TEMPLATE_VIS sentry;
X    class  sentry;
N
N    // 27.7.2.6 Formatted output:
N    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY
X    inline __attribute__((__always_inline__))
N    basic_ostream& operator<<(basic_ostream& (*__pf)(basic_ostream&))
N    { return __pf(*this); }
N
N    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY
X    inline __attribute__((__always_inline__))
N    basic_ostream& operator<<(basic_ios<char_type, traits_type>&
N                              (*__pf)(basic_ios<char_type,traits_type>&))
N    { __pf(*this); return *this; }
N
N    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY
X    inline __attribute__((__always_inline__))
N    basic_ostream& operator<<(ios_base& (*__pf)(ios_base&))
N    { __pf(*this); return *this; }
N
N    basic_ostream& operator<<(bool __n);
N    basic_ostream& operator<<(short __n);
N    basic_ostream& operator<<(unsigned short __n);
N    basic_ostream& operator<<(int __n);
N    basic_ostream& operator<<(unsigned int __n);
N    basic_ostream& operator<<(long __n);
N    basic_ostream& operator<<(unsigned long __n);
N    basic_ostream& operator<<(long long __n);
N    basic_ostream& operator<<(unsigned long long __n);
N    basic_ostream& operator<<(float __f);
N    basic_ostream& operator<<(double __f);
N    basic_ostream& operator<<(long double __f);
N    basic_ostream& operator<<(const void* __p);
N    basic_ostream& operator<<(basic_streambuf<char_type, traits_type>* __sb);
N
N    // 27.7.2.7 Unformatted output:
N    basic_ostream& put(char_type __c);
N    basic_ostream& write(const char_type* __s, streamsize __n);
N    basic_ostream& flush();
N
N    // 27.7.2.5 seeks:
N    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY
X    inline __attribute__((__always_inline__))
N    pos_type tellp();
N    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY
X    inline __attribute__((__always_inline__))
N    basic_ostream& seekp(pos_type __pos);
N    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY
X    inline __attribute__((__always_inline__))
N    basic_ostream& seekp(off_type __off, ios_base::seekdir __dir);
N
Nprotected:
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N    basic_ostream() {}  // extension, intentially does not initialize
N};
N
Ntemplate <class _CharT, class _Traits>
Nclass _LIBCPP_TEMPLATE_VIS basic_ostream<_CharT, _Traits>::sentry
Xclass  basic_ostream<_CharT, _Traits>::sentry
N{
N    bool __ok_;
N    basic_ostream<_CharT, _Traits>& __os_;
N
N    sentry(const sentry&); // = delete;
N    sentry& operator=(const sentry&); // = delete;
N
Npublic:
N    explicit sentry(basic_ostream<_CharT, _Traits>& __os);
N    ~sentry();
N
N    _LIBCPP_ALWAYS_INLINE
X    __attribute__ ((__always_inline__))
N        _LIBCPP_EXPLICIT
X        explicit
N        operator bool() const {return __ok_;}
N};
N
Ntemplate <class _CharT, class _Traits>
Nbasic_ostream<_CharT, _Traits>::sentry::sentry(basic_ostream<_CharT, _Traits>& __os)
N    : __ok_(false),
N      __os_(__os)
N{
N    if (__os.good())
N    {
N        if (__os.tie())
N            __os.tie()->flush();
N        __ok_ = true;
N    }
N}
N
Ntemplate <class _CharT, class _Traits>
Nbasic_ostream<_CharT, _Traits>::sentry::~sentry()
N{
N    if (__os_.rdbuf() && __os_.good() && (__os_.flags() & ios_base::unitbuf)
N                      && !uncaught_exception())
N    {
N#ifndef _LIBCPP_NO_EXCEPTIONS
S        try
S        {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N            if (__os_.rdbuf()->pubsync() == -1)
N                __os_.setstate(ios_base::badbit);
N#ifndef _LIBCPP_NO_EXCEPTIONS
S        }
S        catch (...)
S        {
S        }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    }
N}
N
N#ifndef _LIBCPP_CXX03_LANG
N
Ntemplate <class _CharT, class _Traits>
Nbasic_ostream<_CharT, _Traits>::basic_ostream(basic_ostream&& __rhs)
N{
N    this->move(__rhs);
N}
N
Ntemplate <class _CharT, class _Traits>
Nbasic_ostream<_CharT, _Traits>&
Nbasic_ostream<_CharT, _Traits>::operator=(basic_ostream&& __rhs)
N{
N    swap(__rhs);
N    return *this;
N}
N
N#endif  // _LIBCPP_CXX03_LANG
N
Ntemplate <class _CharT, class _Traits>
Nbasic_ostream<_CharT, _Traits>::~basic_ostream()
N{
N}
N
Ntemplate <class _CharT, class _Traits>
Nbasic_ostream<_CharT, _Traits>&
Nbasic_ostream<_CharT, _Traits>::operator<<(basic_streambuf<char_type, traits_type>* __sb)
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        sentry __s(*this);
N        if (__s)
N        {
N            if (__sb)
N            {
N#ifndef _LIBCPP_NO_EXCEPTIONS
S                try
S                {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N                    typedef istreambuf_iterator<_CharT, _Traits> _Ip;
N                    typedef ostreambuf_iterator<_CharT, _Traits> _Op;
N                    _Ip __i(__sb);
N                    _Ip __eof;
N                    _Op __o(*this);
N                    size_t __c = 0;
N                    for (; __i != __eof; ++__i, ++__o, ++__c)
N                    {
N                        *__o = *__i;
N                        if (__o.failed())
N                            break;
N                    }
N                    if (__c == 0)
N                        this->setstate(ios_base::failbit);
N#ifndef _LIBCPP_NO_EXCEPTIONS
S                }
S                catch (...)
S                {
S                    this->__set_failbit_and_consider_rethrow();
S                }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N            }
N            else
N                this->setstate(ios_base::badbit);
N        }
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        this->__set_badbit_and_consider_rethrow();
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    return *this;
N}
N
Ntemplate <class _CharT, class _Traits>
Nbasic_ostream<_CharT, _Traits>&
Nbasic_ostream<_CharT, _Traits>::operator<<(bool __n)
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        sentry __s(*this);
N        if (__s)
N        {
N            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
N            const _Fp& __f = use_facet<_Fp>(this->getloc());
N            if (__f.put(*this, *this, this->fill(), __n).failed())
N                this->setstate(ios_base::badbit | ios_base::failbit);
N        }
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        this->__set_badbit_and_consider_rethrow();
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    return *this;
N}
N
Ntemplate <class _CharT, class _Traits>
Nbasic_ostream<_CharT, _Traits>&
Nbasic_ostream<_CharT, _Traits>::operator<<(short __n)
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        sentry __s(*this);
N        if (__s)
N        {
N            ios_base::fmtflags __flags = ios_base::flags() & ios_base::basefield;
N            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
N            const _Fp& __f = use_facet<_Fp>(this->getloc());
N            if (__f.put(*this, *this, this->fill(),
N                        __flags == ios_base::oct || __flags == ios_base::hex ?
N                        static_cast<long>(static_cast<unsigned short>(__n))  :
N                        static_cast<long>(__n)).failed())
N                this->setstate(ios_base::badbit | ios_base::failbit);
N        }
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        this->__set_badbit_and_consider_rethrow();
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    return *this;
N}
N
Ntemplate <class _CharT, class _Traits>
Nbasic_ostream<_CharT, _Traits>&
Nbasic_ostream<_CharT, _Traits>::operator<<(unsigned short __n)
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        sentry __s(*this);
N        if (__s)
N        {
N            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
N            const _Fp& __f = use_facet<_Fp>(this->getloc());
N            if (__f.put(*this, *this, this->fill(), static_cast<unsigned long>(__n)).failed())
N                this->setstate(ios_base::badbit | ios_base::failbit);
N        }
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        this->__set_badbit_and_consider_rethrow();
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    return *this;
N}
N
Ntemplate <class _CharT, class _Traits>
Nbasic_ostream<_CharT, _Traits>&
Nbasic_ostream<_CharT, _Traits>::operator<<(int __n)
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        sentry __s(*this);
N        if (__s)
N        {
N            ios_base::fmtflags __flags = ios_base::flags() & ios_base::basefield;
N            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
N            const _Fp& __f = use_facet<_Fp>(this->getloc());
N            if (__f.put(*this, *this, this->fill(),
N                        __flags == ios_base::oct || __flags == ios_base::hex ?
N                        static_cast<long>(static_cast<unsigned int>(__n))  :
N                        static_cast<long>(__n)).failed())
N                this->setstate(ios_base::badbit | ios_base::failbit);
N        }
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        this->__set_badbit_and_consider_rethrow();
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    return *this;
N}
N
Ntemplate <class _CharT, class _Traits>
Nbasic_ostream<_CharT, _Traits>&
Nbasic_ostream<_CharT, _Traits>::operator<<(unsigned int __n)
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        sentry __s(*this);
N        if (__s)
N        {
N            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
N            const _Fp& __f = use_facet<_Fp>(this->getloc());
N            if (__f.put(*this, *this, this->fill(), static_cast<unsigned long>(__n)).failed())
N                this->setstate(ios_base::badbit | ios_base::failbit);
N        }
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        this->__set_badbit_and_consider_rethrow();
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    return *this;
N}
N
Ntemplate <class _CharT, class _Traits>
Nbasic_ostream<_CharT, _Traits>&
Nbasic_ostream<_CharT, _Traits>::operator<<(long __n)
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        sentry __s(*this);
N        if (__s)
N        {
N            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
N            const _Fp& __f = use_facet<_Fp>(this->getloc());
N            if (__f.put(*this, *this, this->fill(), __n).failed())
N                this->setstate(ios_base::badbit | ios_base::failbit);
N        }
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        this->__set_badbit_and_consider_rethrow();
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    return *this;
N}
N
Ntemplate <class _CharT, class _Traits>
Nbasic_ostream<_CharT, _Traits>&
Nbasic_ostream<_CharT, _Traits>::operator<<(unsigned long __n)
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        sentry __s(*this);
N        if (__s)
N        {
N            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
N            const _Fp& __f = use_facet<_Fp>(this->getloc());
N            if (__f.put(*this, *this, this->fill(), __n).failed())
N                this->setstate(ios_base::badbit | ios_base::failbit);
N        }
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        this->__set_badbit_and_consider_rethrow();
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    return *this;
N}
N
Ntemplate <class _CharT, class _Traits>
Nbasic_ostream<_CharT, _Traits>&
Nbasic_ostream<_CharT, _Traits>::operator<<(long long __n)
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        sentry __s(*this);
N        if (__s)
N        {
N            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
N            const _Fp& __f = use_facet<_Fp>(this->getloc());
N            if (__f.put(*this, *this, this->fill(), __n).failed())
N                this->setstate(ios_base::badbit | ios_base::failbit);
N        }
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        this->__set_badbit_and_consider_rethrow();
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    return *this;
N}
N
Ntemplate <class _CharT, class _Traits>
Nbasic_ostream<_CharT, _Traits>&
Nbasic_ostream<_CharT, _Traits>::operator<<(unsigned long long __n)
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        sentry __s(*this);
N        if (__s)
N        {
N            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
N            const _Fp& __f = use_facet<_Fp>(this->getloc());
N            if (__f.put(*this, *this, this->fill(), __n).failed())
N                this->setstate(ios_base::badbit | ios_base::failbit);
N        }
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        this->__set_badbit_and_consider_rethrow();
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    return *this;
N}
N
Ntemplate <class _CharT, class _Traits>
Nbasic_ostream<_CharT, _Traits>&
Nbasic_ostream<_CharT, _Traits>::operator<<(float __n)
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        sentry __s(*this);
N        if (__s)
N        {
N            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
N            const _Fp& __f = use_facet<_Fp>(this->getloc());
N            if (__f.put(*this, *this, this->fill(), static_cast<double>(__n)).failed())
N                this->setstate(ios_base::badbit | ios_base::failbit);
N        }
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        this->__set_badbit_and_consider_rethrow();
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    return *this;
N}
N
Ntemplate <class _CharT, class _Traits>
Nbasic_ostream<_CharT, _Traits>&
Nbasic_ostream<_CharT, _Traits>::operator<<(double __n)
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        sentry __s(*this);
N        if (__s)
N        {
N            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
N            const _Fp& __f = use_facet<_Fp>(this->getloc());
N            if (__f.put(*this, *this, this->fill(), __n).failed())
N                this->setstate(ios_base::badbit | ios_base::failbit);
N        }
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        this->__set_badbit_and_consider_rethrow();
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    return *this;
N}
N
Ntemplate <class _CharT, class _Traits>
Nbasic_ostream<_CharT, _Traits>&
Nbasic_ostream<_CharT, _Traits>::operator<<(long double __n)
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        sentry __s(*this);
N        if (__s)
N        {
N            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
N            const _Fp& __f = use_facet<_Fp>(this->getloc());
N            if (__f.put(*this, *this, this->fill(), __n).failed())
N                this->setstate(ios_base::badbit | ios_base::failbit);
N        }
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        this->__set_badbit_and_consider_rethrow();
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    return *this;
N}
N
Ntemplate <class _CharT, class _Traits>
Nbasic_ostream<_CharT, _Traits>&
Nbasic_ostream<_CharT, _Traits>::operator<<(const void* __n)
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        sentry __s(*this);
N        if (__s)
N        {
N            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
N            const _Fp& __f = use_facet<_Fp>(this->getloc());
N            if (__f.put(*this, *this, this->fill(), __n).failed())
N                this->setstate(ios_base::badbit | ios_base::failbit);
N        }
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        this->__set_badbit_and_consider_rethrow();
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    return *this;
N}
N
Ntemplate<class _CharT, class _Traits>
Nbasic_ostream<_CharT, _Traits>&
N__put_character_sequence(basic_ostream<_CharT, _Traits>& __os,
N                          const _CharT* __str, size_t __len)
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);
N        if (__s)
N        {
N            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;
N            if (__pad_and_output(_Ip(__os),
N                                 __str,
N                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?
N                                     __str + __len :
N                                     __str,
N                                 __str + __len,
N                                 __os,
N                                 __os.fill()).failed())
N                __os.setstate(ios_base::badbit | ios_base::failbit);
N        }
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        __os.__set_badbit_and_consider_rethrow();
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    return __os;
N}
N
N
Ntemplate<class _CharT, class _Traits>
Nbasic_ostream<_CharT, _Traits>&
Noperator<<(basic_ostream<_CharT, _Traits>& __os, _CharT __c)
N{
N    return _VSTD::__put_character_sequence(__os, &__c, 1);
X    return std::__2::__put_character_sequence(__os, &__c, 1);
N}
N
Ntemplate<class _CharT, class _Traits>
Nbasic_ostream<_CharT, _Traits>&
Noperator<<(basic_ostream<_CharT, _Traits>& __os, char __cn)
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);
N        if (__s)
N        {
N            _CharT __c = __os.widen(__cn);
N            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;
N            if (__pad_and_output(_Ip(__os),
N                                 &__c,
N                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?
N                                     &__c + 1 :
N                                     &__c,
N                                 &__c + 1,
N                                 __os,
N                                 __os.fill()).failed())
N                __os.setstate(ios_base::badbit | ios_base::failbit);
N        }
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        __os.__set_badbit_and_consider_rethrow();
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    return __os;
N}
N
Ntemplate<class _Traits>
Nbasic_ostream<char, _Traits>&
Noperator<<(basic_ostream<char, _Traits>& __os, char __c)
N{
N    return _VSTD::__put_character_sequence(__os, &__c, 1);
X    return std::__2::__put_character_sequence(__os, &__c, 1);
N}
N
Ntemplate<class _Traits>
Nbasic_ostream<char, _Traits>&
Noperator<<(basic_ostream<char, _Traits>& __os, signed char __c)
N{
N    return _VSTD::__put_character_sequence(__os, (char *) &__c, 1);
X    return std::__2::__put_character_sequence(__os, (char *) &__c, 1);
N}
N
Ntemplate<class _Traits>
Nbasic_ostream<char, _Traits>&
Noperator<<(basic_ostream<char, _Traits>& __os, unsigned char __c)
N{
N    return _VSTD::__put_character_sequence(__os, (char *) &__c, 1);
X    return std::__2::__put_character_sequence(__os, (char *) &__c, 1);
N}
N
Ntemplate<class _CharT, class _Traits>
Nbasic_ostream<_CharT, _Traits>&
Noperator<<(basic_ostream<_CharT, _Traits>& __os, const _CharT* __str)
N{
N    return _VSTD::__put_character_sequence(__os, __str, _Traits::length(__str));
X    return std::__2::__put_character_sequence(__os, __str, _Traits::length(__str));
N}
N
Ntemplate<class _CharT, class _Traits>
Nbasic_ostream<_CharT, _Traits>&
Noperator<<(basic_ostream<_CharT, _Traits>& __os, const char* __strn)
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);
N        if (__s)
N        {
N            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;
N            size_t __len = char_traits<char>::length(__strn);
N            const int __bs = 100;
N            _CharT __wbb[__bs];
N            _CharT* __wb = __wbb;
N            unique_ptr<_CharT, void(*)(void*)> __h(0, _LIBCPP_FREE);
X            unique_ptr<_CharT, void(*)(void*)> __h(0, [] (void *p) { free(p); });
N            if (__len > __bs)
N            {
N                __wb = (_CharT*)malloc(__len*sizeof(_CharT));
N                if (__wb == 0)
N                    __throw_bad_alloc();
N                __h.reset(__wb);
N            }
N            for (_CharT* __p = __wb; *__strn != '\0'; ++__strn, ++__p)
N                *__p = __os.widen(*__strn);
N            if (__pad_and_output(_Ip(__os),
N                                 __wb,
N                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?
N                                     __wb + __len :
N                                     __wb,
N                                 __wb + __len,
N                                 __os,
N                                 __os.fill()).failed())
N                __os.setstate(ios_base::badbit | ios_base::failbit);
N        }
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        __os.__set_badbit_and_consider_rethrow();
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    return __os;
N}
N
Ntemplate<class _Traits>
Nbasic_ostream<char, _Traits>&
Noperator<<(basic_ostream<char, _Traits>& __os, const char* __str)
N{
N    return _VSTD::__put_character_sequence(__os, __str, _Traits::length(__str));
X    return std::__2::__put_character_sequence(__os, __str, _Traits::length(__str));
N}
N
Ntemplate<class _Traits>
Nbasic_ostream<char, _Traits>&
Noperator<<(basic_ostream<char, _Traits>& __os, const signed char* __str)
N{
N    const char *__s = (const char *) __str;
N    return _VSTD::__put_character_sequence(__os, __s, _Traits::length(__s));
X    return std::__2::__put_character_sequence(__os, __s, _Traits::length(__s));
N}
N
Ntemplate<class _Traits>
Nbasic_ostream<char, _Traits>&
Noperator<<(basic_ostream<char, _Traits>& __os, const unsigned char* __str)
N{
N    const char *__s = (const char *) __str;
N    return _VSTD::__put_character_sequence(__os, __s, _Traits::length(__s));
X    return std::__2::__put_character_sequence(__os, __s, _Traits::length(__s));
N}
N
Ntemplate <class _CharT, class _Traits>
Nbasic_ostream<_CharT, _Traits>&
Nbasic_ostream<_CharT, _Traits>::put(char_type __c)
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        sentry __s(*this);
N        if (__s)
N        {
N            typedef ostreambuf_iterator<_CharT, _Traits> _Op;
N            _Op __o(*this);
N            *__o = __c;
N            if (__o.failed())
N                this->setstate(ios_base::badbit);
N        }
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        this->__set_badbit_and_consider_rethrow();
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    return *this;
N}
N
Ntemplate <class _CharT, class _Traits>
Nbasic_ostream<_CharT, _Traits>&
Nbasic_ostream<_CharT, _Traits>::write(const char_type* __s, streamsize __n)
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        sentry __sen(*this);
N        if (__sen && __n)
N        {
N            if (this->rdbuf()->sputn(__s, __n) != __n)
N                this->setstate(ios_base::badbit);
N        }
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        this->__set_badbit_and_consider_rethrow();
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    return *this;
N}
N
Ntemplate <class _CharT, class _Traits>
Nbasic_ostream<_CharT, _Traits>&
Nbasic_ostream<_CharT, _Traits>::flush()
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        if (this->rdbuf())
N        {
N            sentry __s(*this);
N            if (__s)
N            {
N                if (this->rdbuf()->pubsync() == -1)
N                    this->setstate(ios_base::badbit);
N            }
N        }
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        this->__set_badbit_and_consider_rethrow();
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    return *this;
N}
N
Ntemplate <class _CharT, class _Traits>
Ntypename basic_ostream<_CharT, _Traits>::pos_type
Nbasic_ostream<_CharT, _Traits>::tellp()
N{
N    if (this->fail())
N        return pos_type(-1);
N    return this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
N}
N
Ntemplate <class _CharT, class _Traits>
Nbasic_ostream<_CharT, _Traits>&
Nbasic_ostream<_CharT, _Traits>::seekp(pos_type __pos)
N{
N    sentry __s(*this);
N    if (!this->fail())
N    {
N        if (this->rdbuf()->pubseekpos(__pos, ios_base::out) == pos_type(-1))
N            this->setstate(ios_base::failbit);
N    }
N    return *this;
N}
N
Ntemplate <class _CharT, class _Traits>
Nbasic_ostream<_CharT, _Traits>&
Nbasic_ostream<_CharT, _Traits>::seekp(off_type __off, ios_base::seekdir __dir)
N{
N    sentry __s(*this);
N    if (!this->fail())
N    {
N        if (this->rdbuf()->pubseekoff(__off, __dir, ios_base::out) == pos_type(-1))
N            this->setstate(ios_base::failbit);
N    }
N    return *this;
N}
N
Ntemplate <class _CharT, class _Traits>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbasic_ostream<_CharT, _Traits>&
Nendl(basic_ostream<_CharT, _Traits>& __os)
N{
N    __os.put(__os.widen('\n'));
N    __os.flush();
N    return __os;
N}
N
Ntemplate <class _CharT, class _Traits>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbasic_ostream<_CharT, _Traits>&
Nends(basic_ostream<_CharT, _Traits>& __os)
N{
N    __os.put(_CharT());
N    return __os;
N}
N
Ntemplate <class _CharT, class _Traits>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbasic_ostream<_CharT, _Traits>&
Nflush(basic_ostream<_CharT, _Traits>& __os)
N{
N    __os.flush();
N    return __os;
N}
N
N#ifndef _LIBCPP_CXX03_LANG
N
Ntemplate <class _Stream, class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename enable_if
N<
N    !is_lvalue_reference<_Stream>::value &&
N    is_base_of<ios_base, _Stream>::value,
N    _Stream&&
N>::type
Noperator<<(_Stream&& __os, const _Tp& __x)
N{
N    __os << __x;
N    return _VSTD::move(__os);
X    return std::__2::move(__os);
N}
N
N#endif  // _LIBCPP_CXX03_LANG
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Nbasic_ostream<_CharT, _Traits>&
Noperator<<(basic_ostream<_CharT, _Traits>& __os,
N           const basic_string<_CharT, _Traits, _Allocator>& __str)
N{
N    return _VSTD::__put_character_sequence(__os, __str.data(), __str.size());
X    return std::__2::__put_character_sequence(__os, __str.data(), __str.size());
N}
N
Ntemplate<class _CharT, class _Traits>
Nbasic_ostream<_CharT, _Traits>&
Noperator<<(basic_ostream<_CharT, _Traits>& __os,
N           const basic_string_view<_CharT, _Traits> __sv)
N{
N    return _VSTD::__put_character_sequence(__os, __sv.data(), __sv.size());
X    return std::__2::__put_character_sequence(__os, __sv.data(), __sv.size());
N}
N
Ntemplate <class _CharT, class _Traits>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbasic_ostream<_CharT, _Traits>&
Noperator<<(basic_ostream<_CharT, _Traits>& __os, const error_code& __ec)
N{
N    return __os << __ec.category().name() << ':' << __ec.value();
N}
N
Ntemplate<class _CharT, class _Traits, class _Yp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbasic_ostream<_CharT, _Traits>&
Noperator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p)
N{
N    return __os << __p.get();
N}
N
Ntemplate <class _CharT, class _Traits, size_t _Size>
Nbasic_ostream<_CharT, _Traits>&
Noperator<<(basic_ostream<_CharT, _Traits>& __os, const bitset<_Size>& __x)
N{
N    return __os << __x.template to_string<_CharT, _Traits>
N                        (use_facet<ctype<_CharT> >(__os.getloc()).widen('0'),
N                         use_facet<ctype<_CharT> >(__os.getloc()).widen('1'));
N}
N
N#ifndef _LIBCPP_AVAILABILITY_NO_STREAMS_EXTERN_TEMPLATE
N_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_ostream<char>)
Xextern template class basic_ostream<char>;
N_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_ostream<wchar_t>)
Xextern template class basic_ostream<wchar_t>;
N#endif
N
N_LIBCPP_END_NAMESPACE_STD
X} }
N
N#endif  // _LIBCPP_OSTREAM
L 175 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/sstream" 2
N#include <istream>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/istream" 1
N// -*- C++ -*-
N//===--------------------------- istream ----------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is dual licensed under the MIT and the University of Illinois Open
N// Source Licenses. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP_ISTREAM
N#define _LIBCPP_ISTREAM
N
N/*
N    istream synopsis
N
Ntemplate <class charT, class traits = char_traits<charT> >
Nclass basic_istream
N    : virtual public basic_ios<charT,traits>
N{
Npublic:
N    // types (inherited from basic_ios (27.5.4)):
N    typedef charT                          char_type;
N    typedef traits                         traits_type;
N    typedef typename traits_type::int_type int_type;
N    typedef typename traits_type::pos_type pos_type;
N    typedef typename traits_type::off_type off_type;
N
N    // 27.7.1.1.1 Constructor/destructor:
N    explicit basic_istream(basic_streambuf<char_type, traits_type>* sb);
N    basic_istream(basic_istream&& rhs);
N    virtual ~basic_istream();
N
N    // 27.7.1.1.2 Assign/swap:
N    basic_istream& operator=(basic_istream&& rhs);
N    void swap(basic_istream& rhs);
N
N    // 27.7.1.1.3 Prefix/suffix:
N    class sentry;
N
N    // 27.7.1.2 Formatted input:
N    basic_istream& operator>>(basic_istream& (*pf)(basic_istream&));
N    basic_istream& operator>>(basic_ios<char_type, traits_type>&
N                              (*pf)(basic_ios<char_type, traits_type>&));
N    basic_istream& operator>>(ios_base& (*pf)(ios_base&));
N    basic_istream& operator>>(basic_streambuf<char_type, traits_type>* sb);
N    basic_istream& operator>>(bool& n);
N    basic_istream& operator>>(short& n);
N    basic_istream& operator>>(unsigned short& n);
N    basic_istream& operator>>(int& n);
N    basic_istream& operator>>(unsigned int& n);
N    basic_istream& operator>>(long& n);
N    basic_istream& operator>>(unsigned long& n);
N    basic_istream& operator>>(long long& n);
N    basic_istream& operator>>(unsigned long long& n);
N    basic_istream& operator>>(float& f);
N    basic_istream& operator>>(double& f);
N    basic_istream& operator>>(long double& f);
N    basic_istream& operator>>(void*& p);
N
N    // 27.7.1.3 Unformatted input:
N    streamsize gcount() const;
N    int_type get();
N    basic_istream& get(char_type& c);
N    basic_istream& get(char_type* s, streamsize n);
N    basic_istream& get(char_type* s, streamsize n, char_type delim);
N    basic_istream& get(basic_streambuf<char_type,traits_type>& sb);
N    basic_istream& get(basic_streambuf<char_type,traits_type>& sb, char_type delim);
N
N    basic_istream& getline(char_type* s, streamsize n);
N    basic_istream& getline(char_type* s, streamsize n, char_type delim);
N
N    basic_istream& ignore(streamsize n = 1, int_type delim = traits_type::eof());
N    int_type peek();
N    basic_istream& read (char_type* s, streamsize n);
N    streamsize readsome(char_type* s, streamsize n);
N
N    basic_istream& putback(char_type c);
N    basic_istream& unget();
N    int sync();
N
N    pos_type tellg();
N    basic_istream& seekg(pos_type);
N    basic_istream& seekg(off_type, ios_base::seekdir);
Nprotected:
N    basic_istream(const basic_istream& rhs) = delete;
N    basic_istream(basic_istream&& rhs);
N    // 27.7.2.1.2 Assign/swap:
N    basic_istream& operator=(const basic_istream& rhs) = delete;
N    basic_istream& operator=(basic_istream&& rhs);
N    void swap(basic_istream& rhs);
N};
N
N// 27.7.1.2.3 character extraction templates:
Ntemplate<class charT, class traits>
N  basic_istream<charT,traits>& operator>>(basic_istream<charT,traits>&, charT&);
N
Ntemplate<class traits>
N  basic_istream<char,traits>& operator>>(basic_istream<char,traits>&, unsigned char&);
N
Ntemplate<class traits>
N  basic_istream<char,traits>& operator>>(basic_istream<char,traits>&, signed char&);
N
Ntemplate<class charT, class traits>
N  basic_istream<charT,traits>& operator>>(basic_istream<charT,traits>&, charT*);
N
Ntemplate<class traits>
N  basic_istream<char,traits>& operator>>(basic_istream<char,traits>&, unsigned char*);
N
Ntemplate<class traits>
N  basic_istream<char,traits>& operator>>(basic_istream<char,traits>&, signed char*);
N
Ntemplate <class charT, class traits>
N  void
N  swap(basic_istream<charT, traits>& x, basic_istream<charT, traits>& y);
N
Ntypedef basic_istream<char> istream;
Ntypedef basic_istream<wchar_t> wistream;
N
Ntemplate <class charT, class traits = char_traits<charT> >
Nclass basic_iostream :
N    public basic_istream<charT,traits>,
N    public basic_ostream<charT,traits>
N{
Npublic:
N    // types:
N    typedef charT                          char_type;
N    typedef traits                         traits_type;
N    typedef typename traits_type::int_type int_type;
N    typedef typename traits_type::pos_type pos_type;
N    typedef typename traits_type::off_type off_type;
N
N    // constructor/destructor
N    explicit basic_iostream(basic_streambuf<char_type, traits_type>* sb);
N    basic_iostream(basic_iostream&& rhs);
N    virtual ~basic_iostream();
N
N    // assign/swap
N    basic_iostream& operator=(basic_iostream&& rhs);
N    void swap(basic_iostream& rhs);
N};
N
Ntemplate <class charT, class traits>
N  void
N  swap(basic_iostream<charT, traits>& x, basic_iostream<charT, traits>& y);
N
Ntypedef basic_iostream<char> iostream;
Ntypedef basic_iostream<wchar_t> wiostream;
N
Ntemplate <class charT, class traits>
N  basic_istream<charT,traits>&
N  ws(basic_istream<charT,traits>& is);
N
Ntemplate <class charT, class traits, class T>
N  basic_istream<charT, traits>&
N  operator>>(basic_istream<charT, traits>&& is, T& x);
N
N}  // std
N
N*/
N
N#include <__config>
N#include <ostream>
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N_LIBCPP_PUSH_MACROS
X_Pragma("push_macro(\"min\")") _Pragma("push_macro(\"max\")")
N#include <__undef_macros>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/__undef_macros" 1
N// -*- C++ -*-
N//===------------------------ __undef_macros ------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is distributed under the University of Illinois Open Source
N// License. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N
N#ifdef min
S#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
S#if defined(_LIBCPP_WARNING)
S_LIBCPP_WARNING("macro min is incompatible with C++.  Try #define NOMINMAX "
S                "before any Windows header. #undefing min")
S#else
S#warning: macro min is incompatible with C++.  #undefing min
S#endif
S#endif
S#undef min
N#endif
N
N#ifdef max
S#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
S#if defined(_LIBCPP_WARNING)
S_LIBCPP_WARNING("macro max is incompatible with C++.  Try #define NOMINMAX "
S                "before any Windows header. #undefing max")
S#else
S#warning: macro max is incompatible with C++.  #undefing max
S#endif
S#endif
S#undef max
N#endif
L 171 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/istream" 2
N
N
N_LIBCPP_BEGIN_NAMESPACE_STD
Xnamespace std { inline namespace __2 {
N
Ntemplate <class _CharT, class _Traits>
Nclass _LIBCPP_TEMPLATE_VIS basic_istream
Xclass  basic_istream
N    : virtual public basic_ios<_CharT, _Traits>
N{
N    streamsize __gc_;
Npublic:
N    // types (inherited from basic_ios (27.5.4)):
N    typedef _CharT                         char_type;
N    typedef _Traits                        traits_type;
N    typedef typename traits_type::int_type int_type;
N    typedef typename traits_type::pos_type pos_type;
N    typedef typename traits_type::off_type off_type;
N
N    // 27.7.1.1.1 Constructor/destructor:
N    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY
X    inline __attribute__((__always_inline__))
N    explicit basic_istream(basic_streambuf<char_type, traits_type>* __sb) : __gc_(0)
N    { this->init(__sb); }
N    virtual ~basic_istream();
Nprotected:
N#ifndef _LIBCPP_CXX03_LANG
N    inline _LIBCPP_INLINE_VISIBILITY
X    inline __attribute__ ((__always_inline__))
N    basic_istream(basic_istream&& __rhs);
N
N    // 27.7.1.1.2 Assign/swap:
N    inline _LIBCPP_INLINE_VISIBILITY
X    inline __attribute__ ((__always_inline__))
N    basic_istream& operator=(basic_istream&& __rhs);
N#endif
N
N    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY
X    inline __attribute__((__always_inline__))
N    void swap(basic_istream& __rhs) {
N      _VSTD::swap(__gc_, __rhs.__gc_);
X      std::__2::swap(__gc_, __rhs.__gc_);
N      basic_ios<char_type, traits_type>::swap(__rhs);
N    }
N
N#ifndef _LIBCPP_CXX03_LANG
N    basic_istream           (const basic_istream& __rhs) = delete;
N    basic_istream& operator=(const basic_istream& __rhs) = delete;
N#endif
Npublic:
N
N    // 27.7.1.1.3 Prefix/suffix:
N    class _LIBCPP_TEMPLATE_VIS sentry;
X    class  sentry;
N
N    // 27.7.1.2 Formatted input:
N    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY
X    inline __attribute__((__always_inline__))
N    basic_istream& operator>>(basic_istream& (*__pf)(basic_istream&))
N    { return __pf(*this); }
N
N    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY
X    inline __attribute__((__always_inline__))
N    basic_istream& operator>>(basic_ios<char_type, traits_type>&
N                              (*__pf)(basic_ios<char_type, traits_type>&))
N    { __pf(*this); return *this; }
N
N    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY
X    inline __attribute__((__always_inline__))
N    basic_istream& operator>>(ios_base& (*__pf)(ios_base&))
N    { __pf(*this); return *this; }
N
N    basic_istream& operator>>(basic_streambuf<char_type, traits_type>* __sb);
N    basic_istream& operator>>(bool& __n);
N    basic_istream& operator>>(short& __n);
N    basic_istream& operator>>(unsigned short& __n);
N    basic_istream& operator>>(int& __n);
N    basic_istream& operator>>(unsigned int& __n);
N    basic_istream& operator>>(long& __n);
N    basic_istream& operator>>(unsigned long& __n);
N    basic_istream& operator>>(long long& __n);
N    basic_istream& operator>>(unsigned long long& __n);
N    basic_istream& operator>>(float& __f);
N    basic_istream& operator>>(double& __f);
N    basic_istream& operator>>(long double& __f);
N    basic_istream& operator>>(void*& __p);
N
N    // 27.7.1.3 Unformatted input:
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    streamsize gcount() const {return __gc_;}
N    int_type get();
N
N    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY
X    inline __attribute__((__always_inline__))
N    basic_istream& get(char_type& __c) {
N      int_type __ch = get();
N      if (__ch != traits_type::eof())
N        __c = traits_type::to_char_type(__ch);
N      return *this;
N    }
N
N    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY
X    inline __attribute__((__always_inline__))
N    basic_istream& get(char_type* __s, streamsize __n)
N    { return get(__s, __n, this->widen('\n')); }
N
N    basic_istream& get(char_type* __s, streamsize __n, char_type __dlm);
N
N    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY
X    inline __attribute__((__always_inline__))
N    basic_istream& get(basic_streambuf<char_type, traits_type>& __sb)
N    { return get(__sb, this->widen('\n')); }
N
N    basic_istream& get(basic_streambuf<char_type, traits_type>& __sb, char_type __dlm);
N
N    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY
X    inline __attribute__((__always_inline__))
N    basic_istream& getline(char_type* __s, streamsize __n)
N    { return getline(__s, __n, this->widen('\n')); }
N
N    basic_istream& getline(char_type* __s, streamsize __n, char_type __dlm);
N
N    basic_istream& ignore(streamsize __n = 1, int_type __dlm = traits_type::eof());
N    int_type peek();
N    basic_istream& read (char_type* __s, streamsize __n);
N    streamsize readsome(char_type* __s, streamsize __n);
N
N    basic_istream& putback(char_type __c);
N    basic_istream& unget();
N    int sync();
N
N    pos_type tellg();
N    basic_istream& seekg(pos_type __pos);
N    basic_istream& seekg(off_type __off, ios_base::seekdir __dir);
N};
N
Ntemplate <class _CharT, class _Traits>
Nclass _LIBCPP_TEMPLATE_VIS basic_istream<_CharT, _Traits>::sentry
Xclass  basic_istream<_CharT, _Traits>::sentry
N{
N    bool __ok_;
N
N    sentry(const sentry&); // = delete;
N    sentry& operator=(const sentry&); // = delete;
N
Npublic:
N    explicit sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);
N//    ~sentry() = default;
N
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N        _LIBCPP_EXPLICIT
X        explicit
N        operator bool() const {return __ok_;}
N};
N
Ntemplate <class _CharT, class _Traits>
Nbasic_istream<_CharT, _Traits>::sentry::sentry(basic_istream<_CharT, _Traits>& __is,
N                                               bool __noskipws)
N    : __ok_(false)
N{
N    if (__is.good())
N    {
N        if (__is.tie())
N            __is.tie()->flush();
N        if (!__noskipws && (__is.flags() & ios_base::skipws))
N        {
N            typedef istreambuf_iterator<_CharT, _Traits> _Ip;
N            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());
N            _Ip __i(__is);
N            _Ip __eof;
N            for (; __i != __eof; ++__i)
N                if (!__ct.is(__ct.space, *__i))
N                    break;
N            if (__i == __eof)
N                __is.setstate(ios_base::failbit | ios_base::eofbit);
N        }
N        __ok_ = __is.good();
N    }
N    else
N        __is.setstate(ios_base::failbit);
N}
N
N#ifndef _LIBCPP_CXX03_LANG
N
Ntemplate <class _CharT, class _Traits>
Nbasic_istream<_CharT, _Traits>::basic_istream(basic_istream&& __rhs)
N    : __gc_(__rhs.__gc_)
N{
N    __rhs.__gc_ = 0;
N    this->move(__rhs);
N}
N
Ntemplate <class _CharT, class _Traits>
Nbasic_istream<_CharT, _Traits>&
Nbasic_istream<_CharT, _Traits>::operator=(basic_istream&& __rhs)
N{
N    swap(__rhs);
N    return *this;
N}
N
N#endif  // _LIBCPP_CXX03_LANG
N
Ntemplate <class _CharT, class _Traits>
Nbasic_istream<_CharT, _Traits>::~basic_istream()
N{
N}
N
Ntemplate <class _CharT, class _Traits>
Nbasic_istream<_CharT, _Traits>&
Nbasic_istream<_CharT, _Traits>::operator>>(unsigned short& __n)
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        sentry __s(*this);
N        if (__s)
N        {
N            typedef istreambuf_iterator<char_type, traits_type> _Ip;
N            typedef num_get<char_type, _Ip> _Fp;
N            ios_base::iostate __err = ios_base::goodbit;
N            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
N            this->setstate(__err);
N        }
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        this->__set_badbit_and_consider_rethrow();
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    return *this;
N}
N
Ntemplate <class _CharT, class _Traits>
Nbasic_istream<_CharT, _Traits>&
Nbasic_istream<_CharT, _Traits>::operator>>(unsigned int& __n)
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        sentry __s(*this);
N        if (__s)
N        {
N            typedef istreambuf_iterator<char_type, traits_type> _Ip;
N            typedef num_get<char_type, _Ip> _Fp;
N            ios_base::iostate __err = ios_base::goodbit;
N            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
N            this->setstate(__err);
N        }
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        this->__set_badbit_and_consider_rethrow();
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    return *this;
N}
N
Ntemplate <class _CharT, class _Traits>
Nbasic_istream<_CharT, _Traits>&
Nbasic_istream<_CharT, _Traits>::operator>>(long& __n)
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        sentry __s(*this);
N        if (__s)
N        {
N            typedef istreambuf_iterator<char_type, traits_type> _Ip;
N            typedef num_get<char_type, _Ip> _Fp;
N            ios_base::iostate __err = ios_base::goodbit;
N            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
N            this->setstate(__err);
N        }
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        this->__set_badbit_and_consider_rethrow();
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    return *this;
N}
N
Ntemplate <class _CharT, class _Traits>
Nbasic_istream<_CharT, _Traits>&
Nbasic_istream<_CharT, _Traits>::operator>>(unsigned long& __n)
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        sentry __s(*this);
N        if (__s)
N        {
N            typedef istreambuf_iterator<char_type, traits_type> _Ip;
N            typedef num_get<char_type, _Ip> _Fp;
N            ios_base::iostate __err = ios_base::goodbit;
N            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
N            this->setstate(__err);
N        }
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        this->__set_badbit_and_consider_rethrow();
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    return *this;
N}
N
Ntemplate <class _CharT, class _Traits>
Nbasic_istream<_CharT, _Traits>&
Nbasic_istream<_CharT, _Traits>::operator>>(long long& __n)
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        sentry __s(*this);
N        if (__s)
N        {
N            typedef istreambuf_iterator<char_type, traits_type> _Ip;
N            typedef num_get<char_type, _Ip> _Fp;
N            ios_base::iostate __err = ios_base::goodbit;
N            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
N            this->setstate(__err);
N        }
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        this->__set_badbit_and_consider_rethrow();
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    return *this;
N}
N
Ntemplate <class _CharT, class _Traits>
Nbasic_istream<_CharT, _Traits>&
Nbasic_istream<_CharT, _Traits>::operator>>(unsigned long long& __n)
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        sentry __s(*this);
N        if (__s)
N        {
N            typedef istreambuf_iterator<char_type, traits_type> _Ip;
N            typedef num_get<char_type, _Ip> _Fp;
N            ios_base::iostate __err = ios_base::goodbit;
N            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
N            this->setstate(__err);
N        }
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        this->__set_badbit_and_consider_rethrow();
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    return *this;
N}
N
Ntemplate <class _CharT, class _Traits>
Nbasic_istream<_CharT, _Traits>&
Nbasic_istream<_CharT, _Traits>::operator>>(float& __n)
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        sentry __s(*this);
N        if (__s)
N        {
N            typedef istreambuf_iterator<char_type, traits_type> _Ip;
N            typedef num_get<char_type, _Ip> _Fp;
N            ios_base::iostate __err = ios_base::goodbit;
N            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
N            this->setstate(__err);
N        }
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        this->__set_badbit_and_consider_rethrow();
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    return *this;
N}
N
Ntemplate <class _CharT, class _Traits>
Nbasic_istream<_CharT, _Traits>&
Nbasic_istream<_CharT, _Traits>::operator>>(double& __n)
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        sentry __s(*this);
N        if (__s)
N        {
N            typedef istreambuf_iterator<char_type, traits_type> _Ip;
N            typedef num_get<char_type, _Ip> _Fp;
N            ios_base::iostate __err = ios_base::goodbit;
N            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
N            this->setstate(__err);
N        }
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        this->__set_badbit_and_consider_rethrow();
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    return *this;
N}
N
Ntemplate <class _CharT, class _Traits>
Nbasic_istream<_CharT, _Traits>&
Nbasic_istream<_CharT, _Traits>::operator>>(long double& __n)
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        sentry __s(*this);
N        if (__s)
N        {
N            typedef istreambuf_iterator<char_type, traits_type> _Ip;
N            typedef num_get<char_type, _Ip> _Fp;
N            ios_base::iostate __err = ios_base::goodbit;
N            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
N            this->setstate(__err);
N        }
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        this->__set_badbit_and_consider_rethrow();
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    return *this;
N}
N
Ntemplate <class _CharT, class _Traits>
Nbasic_istream<_CharT, _Traits>&
Nbasic_istream<_CharT, _Traits>::operator>>(bool& __n)
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        sentry __s(*this);
N        if (__s)
N        {
N            typedef istreambuf_iterator<char_type, traits_type> _Ip;
N            typedef num_get<char_type, _Ip> _Fp;
N            ios_base::iostate __err = ios_base::goodbit;
N            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
N            this->setstate(__err);
N        }
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        this->__set_badbit_and_consider_rethrow();
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    return *this;
N}
N
Ntemplate <class _CharT, class _Traits>
Nbasic_istream<_CharT, _Traits>&
Nbasic_istream<_CharT, _Traits>::operator>>(void*& __n)
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        sentry __s(*this);
N        if (__s)
N        {
N            typedef istreambuf_iterator<char_type, traits_type> _Ip;
N            typedef num_get<char_type, _Ip> _Fp;
N            ios_base::iostate __err = ios_base::goodbit;
N            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
N            this->setstate(__err);
N        }
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        this->__set_badbit_and_consider_rethrow();
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    return *this;
N}
N
Ntemplate <class _CharT, class _Traits>
Nbasic_istream<_CharT, _Traits>&
Nbasic_istream<_CharT, _Traits>::operator>>(short& __n)
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        sentry __s(*this);
N        if (__s)
N        {
N            typedef istreambuf_iterator<char_type, traits_type> _Ip;
N            typedef num_get<char_type, _Ip> _Fp;
N            ios_base::iostate __err = ios_base::goodbit;
N            long __temp;
N            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __temp);
N            if (__temp < numeric_limits<short>::min())
N            {
N                __err |= ios_base::failbit;
N                __n = numeric_limits<short>::min();
N            }
N            else if (__temp > numeric_limits<short>::max())
N            {
N                __err |= ios_base::failbit;
N                __n = numeric_limits<short>::max();
N            }
N            else
N                __n = static_cast<short>(__temp);
N            this->setstate(__err);
N        }
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        this->__set_badbit_and_consider_rethrow();
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    return *this;
N}
N
Ntemplate <class _CharT, class _Traits>
Nbasic_istream<_CharT, _Traits>&
Nbasic_istream<_CharT, _Traits>::operator>>(int& __n)
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        sentry __s(*this);
N        if (__s)
N        {
N            typedef istreambuf_iterator<char_type, traits_type> _Ip;
N            typedef num_get<char_type, _Ip> _Fp;
N            ios_base::iostate __err = ios_base::goodbit;
N            long __temp;
N            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __temp);
N            if (__temp < numeric_limits<int>::min())
N            {
N                __err |= ios_base::failbit;
N                __n = numeric_limits<int>::min();
N            }
N            else if (__temp > numeric_limits<int>::max())
N            {
N                __err |= ios_base::failbit;
N                __n = numeric_limits<int>::max();
N            }
N            else
N                __n = static_cast<int>(__temp);
N            this->setstate(__err);
N        }
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        this->__set_badbit_and_consider_rethrow();
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    return *this;
N}
N
Ntemplate<class _CharT, class _Traits>
Nbasic_istream<_CharT, _Traits>&
Noperator>>(basic_istream<_CharT, _Traits>& __is, _CharT* __s)
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        typename basic_istream<_CharT, _Traits>::sentry __sen(__is);
N        if (__sen)
N        {
N            streamsize __n = __is.width();
N            if (__n <= 0)
N                __n = numeric_limits<streamsize>::max() / sizeof(_CharT) - 1;
N            streamsize __c = 0;
N            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());
N            ios_base::iostate __err = ios_base::goodbit;
N            while (__c < __n-1)
N            {
N                typename _Traits::int_type __i = __is.rdbuf()->sgetc();
N                if (_Traits::eq_int_type(__i, _Traits::eof()))
N                {
N                   __err |= ios_base::eofbit;
N                   break;
N                }
N                _CharT __ch = _Traits::to_char_type(__i);
N                if (__ct.is(__ct.space, __ch))
N                    break;
N                *__s++ = __ch;
N                ++__c;
N                 __is.rdbuf()->sbumpc();
N            }
N            *__s = _CharT();
N            __is.width(0);
N            if (__c == 0)
N               __err |= ios_base::failbit;
N            __is.setstate(__err);
N        }
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        __is.__set_badbit_and_consider_rethrow();
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    return __is;
N}
N
Ntemplate<class _Traits>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbasic_istream<char, _Traits>&
Noperator>>(basic_istream<char, _Traits>& __is, unsigned char* __s)
N{
N    return __is >> (char*)__s;
N}
N
Ntemplate<class _Traits>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbasic_istream<char, _Traits>&
Noperator>>(basic_istream<char, _Traits>& __is, signed char* __s)
N{
N    return __is >> (char*)__s;
N}
N
Ntemplate<class _CharT, class _Traits>
Nbasic_istream<_CharT, _Traits>&
Noperator>>(basic_istream<_CharT, _Traits>& __is, _CharT& __c)
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        typename basic_istream<_CharT, _Traits>::sentry __sen(__is);
N        if (__sen)
N        {
N            typename _Traits::int_type __i = __is.rdbuf()->sbumpc();
N            if (_Traits::eq_int_type(__i, _Traits::eof()))
N                __is.setstate(ios_base::eofbit | ios_base::failbit);
N            else
N                __c = _Traits::to_char_type(__i);
N        }
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        __is.__set_badbit_and_consider_rethrow();
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    return __is;
N}
N
Ntemplate<class _Traits>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbasic_istream<char, _Traits>&
Noperator>>(basic_istream<char, _Traits>& __is, unsigned char& __c)
N{
N    return __is >> (char&)__c;
N}
N
Ntemplate<class _Traits>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbasic_istream<char, _Traits>&
Noperator>>(basic_istream<char, _Traits>& __is, signed char& __c)
N{
N    return __is >> (char&)__c;
N}
N
Ntemplate<class _CharT, class _Traits>
Nbasic_istream<_CharT, _Traits>&
Nbasic_istream<_CharT, _Traits>::operator>>(basic_streambuf<char_type, traits_type>* __sb)
N{
N    __gc_ = 0;
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        sentry __s(*this, true);
N        if (__s)
N        {
N            if (__sb)
N            {
N#ifndef _LIBCPP_NO_EXCEPTIONS
S                try
S                {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N                    ios_base::iostate __err = ios_base::goodbit;
N                    while (true)
N                    {
N                        typename traits_type::int_type __i = this->rdbuf()->sgetc();
N                        if (traits_type::eq_int_type(__i, _Traits::eof()))
N                        {
N                           __err |= ios_base::eofbit;
N                           break;
N                        }
N                        if (traits_type::eq_int_type(
N                                __sb->sputc(traits_type::to_char_type(__i)),
N                                traits_type::eof()))
N                            break;
N                        ++__gc_;
N                        this->rdbuf()->sbumpc();
N                    }
N                    if (__gc_ == 0)
N                       __err |= ios_base::failbit;
N                    this->setstate(__err);
N#ifndef _LIBCPP_NO_EXCEPTIONS
S                }
S                catch (...)
S                {
S                    if (__gc_ == 0)
S                        this->__set_failbit_and_consider_rethrow();
S                }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N            }
N            else
N                this->setstate(ios_base::failbit);
N        }
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        this->__set_badbit_and_consider_rethrow();
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    return *this;
N}
N
Ntemplate<class _CharT, class _Traits>
Ntypename basic_istream<_CharT, _Traits>::int_type
Nbasic_istream<_CharT, _Traits>::get()
N{
N    __gc_ = 0;
N    int_type __r = traits_type::eof();
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        sentry __s(*this, true);
N        if (__s)
N        {
N            __r = this->rdbuf()->sbumpc();
N            if (traits_type::eq_int_type(__r, traits_type::eof()))
N               this->setstate(ios_base::failbit | ios_base::eofbit);
N            else
N                __gc_ = 1;
N        }
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        this->__set_badbit_and_consider_rethrow();
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    return __r;
N}
N
Ntemplate<class _CharT, class _Traits>
Nbasic_istream<_CharT, _Traits>&
Nbasic_istream<_CharT, _Traits>::get(char_type* __s, streamsize __n, char_type __dlm)
N{
N    __gc_ = 0;
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        sentry __sen(*this, true);
N        if (__sen)
N        {
N            if (__n > 0)
N            {
N                ios_base::iostate __err = ios_base::goodbit;
N                while (__gc_ < __n-1)
N                {
N                    int_type __i = this->rdbuf()->sgetc();
N                    if (traits_type::eq_int_type(__i, traits_type::eof()))
N                    {
N                       __err |= ios_base::eofbit;
N                       break;
N                    }
N                    char_type __ch = traits_type::to_char_type(__i);
N                    if (traits_type::eq(__ch, __dlm))
N                        break;
N                    *__s++ = __ch;
N                    ++__gc_;
N                     this->rdbuf()->sbumpc();
N                }
N                *__s = char_type();
N                if (__gc_ == 0)
N                   __err |= ios_base::failbit;
N                this->setstate(__err);
N            }
N            else
N                this->setstate(ios_base::failbit);
N        }
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        this->__set_badbit_and_consider_rethrow();
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    return *this;
N}
N
Ntemplate<class _CharT, class _Traits>
Nbasic_istream<_CharT, _Traits>&
Nbasic_istream<_CharT, _Traits>::get(basic_streambuf<char_type, traits_type>& __sb,
N                                    char_type __dlm)
N{
N    __gc_ = 0;
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        sentry __sen(*this, true);
N        if (__sen)
N        {
N            ios_base::iostate __err = ios_base::goodbit;
N#ifndef _LIBCPP_NO_EXCEPTIONS
S            try
S            {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N                while (true)
N                {
N                    typename traits_type::int_type __i = this->rdbuf()->sgetc();
N                    if (traits_type::eq_int_type(__i, traits_type::eof()))
N                    {
N                       __err |= ios_base::eofbit;
N                       break;
N                    }
N                    char_type __ch = traits_type::to_char_type(__i);
N                    if (traits_type::eq(__ch, __dlm))
N                        break;
N                    if (traits_type::eq_int_type(__sb.sputc(__ch), traits_type::eof()))
N                        break;
N                    ++__gc_;
N                    this->rdbuf()->sbumpc();
N                }
N#ifndef _LIBCPP_NO_EXCEPTIONS
S            }
S            catch (...)
S            {
S            }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N            if (__gc_ == 0)
N               __err |= ios_base::failbit;
N            this->setstate(__err);
N        }
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        this->__set_badbit_and_consider_rethrow();
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    return *this;
N}
N
Ntemplate<class _CharT, class _Traits>
Nbasic_istream<_CharT, _Traits>&
Nbasic_istream<_CharT, _Traits>::getline(char_type* __s, streamsize __n, char_type __dlm)
N{
N    __gc_ = 0;
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        sentry __sen(*this, true);
N        if (__sen)
N        {
N            ios_base::iostate __err = ios_base::goodbit;
N            while (true)
N            {
N                typename traits_type::int_type __i = this->rdbuf()->sgetc();
N                if (traits_type::eq_int_type(__i, traits_type::eof()))
N                {
N                   __err |= ios_base::eofbit;
N                   break;
N                }
N                char_type __ch = traits_type::to_char_type(__i);
N                if (traits_type::eq(__ch, __dlm))
N                {
N                    this->rdbuf()->sbumpc();
N                    ++__gc_;
N                    break;
N                }
N                if (__gc_ >= __n-1)
N                {
N                    __err |= ios_base::failbit;
N                    break;
N                }
N                *__s++ = __ch;
N                this->rdbuf()->sbumpc();
N                ++__gc_;
N            }
N            if (__n > 0)
N                *__s = char_type();
N            if (__gc_ == 0)
N               __err |= ios_base::failbit;
N            this->setstate(__err);
N        }
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        this->__set_badbit_and_consider_rethrow();
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    return *this;
N}
N
Ntemplate<class _CharT, class _Traits>
Nbasic_istream<_CharT, _Traits>&
Nbasic_istream<_CharT, _Traits>::ignore(streamsize __n, int_type __dlm)
N{
N    __gc_ = 0;
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        sentry __sen(*this, true);
N        if (__sen)
N        {
N            ios_base::iostate __err = ios_base::goodbit;
N            if (__n == numeric_limits<streamsize>::max())
N            {
N                while (true)
N                {
N                    typename traits_type::int_type __i = this->rdbuf()->sbumpc();
N                    if (traits_type::eq_int_type(__i, traits_type::eof()))
N                    {
N                       __err |= ios_base::eofbit;
N                       break;
N                    }
N                    ++__gc_;
N                    if (traits_type::eq_int_type(__i, __dlm))
N                        break;
N                }
N            }
N            else
N            {
N                while (__gc_ < __n)
N                {
N                    typename traits_type::int_type __i = this->rdbuf()->sbumpc();
N                    if (traits_type::eq_int_type(__i, traits_type::eof()))
N                    {
N                       __err |= ios_base::eofbit;
N                       break;
N                    }
N                    ++__gc_;
N                    if (traits_type::eq_int_type(__i, __dlm))
N                        break;
N                }
N            }
N            this->setstate(__err);
N        }
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        this->__set_badbit_and_consider_rethrow();
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    return *this;
N}
N
Ntemplate<class _CharT, class _Traits>
Ntypename basic_istream<_CharT, _Traits>::int_type
Nbasic_istream<_CharT, _Traits>::peek()
N{
N    __gc_ = 0;
N    int_type __r = traits_type::eof();
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        sentry __sen(*this, true);
N        if (__sen)
N        {
N            __r = this->rdbuf()->sgetc();
N            if (traits_type::eq_int_type(__r, traits_type::eof()))
N                this->setstate(ios_base::eofbit);
N        }
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        this->__set_badbit_and_consider_rethrow();
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    return __r;
N}
N
Ntemplate<class _CharT, class _Traits>
Nbasic_istream<_CharT, _Traits>&
Nbasic_istream<_CharT, _Traits>::read(char_type* __s, streamsize __n)
N{
N    __gc_ = 0;
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        sentry __sen(*this, true);
N        if (__sen)
N        {
N            __gc_ = this->rdbuf()->sgetn(__s, __n);
N            if (__gc_ != __n)
N                this->setstate(ios_base::failbit | ios_base::eofbit);
N        }
N        else
N            this->setstate(ios_base::failbit);
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        this->__set_badbit_and_consider_rethrow();
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    return *this;
N}
N
Ntemplate<class _CharT, class _Traits>
Nstreamsize
Nbasic_istream<_CharT, _Traits>::readsome(char_type* __s, streamsize __n)
N{
N    __gc_ = 0;
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        sentry __sen(*this, true);
N        if (__sen)
N        {
N            streamsize __c = this->rdbuf()->in_avail();
N            switch (__c)
N            {
N            case -1:
N                this->setstate(ios_base::eofbit);
N                break;
N            case 0:
N                break;
N            default:
N                read(__s, _VSTD::min(__c, __n));
X                read(__s, std::__2::min(__c, __n));
N                break;
N            }
N        }
N        else
N            this->setstate(ios_base::failbit);
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        this->__set_badbit_and_consider_rethrow();
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    return __gc_;
N}
N
Ntemplate<class _CharT, class _Traits>
Nbasic_istream<_CharT, _Traits>&
Nbasic_istream<_CharT, _Traits>::putback(char_type __c)
N{
N    __gc_ = 0;
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        this->clear(this->rdstate() & ~ios_base::eofbit);
N        sentry __sen(*this, true);
N        if (__sen)
N        {
N            if (this->rdbuf() == 0 || this->rdbuf()->sputbackc(__c) == traits_type::eof())
N                this->setstate(ios_base::badbit);
N        }
N        else
N            this->setstate(ios_base::failbit);
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        this->__set_badbit_and_consider_rethrow();
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    return *this;
N}
N
Ntemplate<class _CharT, class _Traits>
Nbasic_istream<_CharT, _Traits>&
Nbasic_istream<_CharT, _Traits>::unget()
N{
N    __gc_ = 0;
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        this->clear(this->rdstate() & ~ios_base::eofbit);
N        sentry __sen(*this, true);
N        if (__sen)
N        {
N            if (this->rdbuf() == 0 || this->rdbuf()->sungetc() == traits_type::eof())
N                this->setstate(ios_base::badbit);
N        }
N        else
N            this->setstate(ios_base::failbit);
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        this->__set_badbit_and_consider_rethrow();
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    return *this;
N}
N
Ntemplate<class _CharT, class _Traits>
Nint
Nbasic_istream<_CharT, _Traits>::sync()
N{
N    int __r = 0;
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        sentry __sen(*this, true);
N        if (__sen)
N        {
N            if (this->rdbuf() == 0)
N                return -1;
N            if (this->rdbuf()->pubsync() == -1)
N            {
N                this->setstate(ios_base::badbit);
N                return -1;
N            }
N        }
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        this->__set_badbit_and_consider_rethrow();
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    return __r;
N}
N
Ntemplate<class _CharT, class _Traits>
Ntypename basic_istream<_CharT, _Traits>::pos_type
Nbasic_istream<_CharT, _Traits>::tellg()
N{
N    pos_type __r(-1);
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        sentry __sen(*this, true);
N        if (__sen)
N            __r = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::in);
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        this->__set_badbit_and_consider_rethrow();
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    return __r;
N}
N
Ntemplate<class _CharT, class _Traits>
Nbasic_istream<_CharT, _Traits>&
Nbasic_istream<_CharT, _Traits>::seekg(pos_type __pos)
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        this->clear(this->rdstate() & ~ios_base::eofbit);
N        sentry __sen(*this, true);
N        if (__sen)
N        {
N            if (this->rdbuf()->pubseekpos(__pos, ios_base::in) == pos_type(-1))
N                this->setstate(ios_base::failbit);
N        }
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        this->__set_badbit_and_consider_rethrow();
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    return *this;
N}
N
Ntemplate<class _CharT, class _Traits>
Nbasic_istream<_CharT, _Traits>&
Nbasic_istream<_CharT, _Traits>::seekg(off_type __off, ios_base::seekdir __dir)
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        this->clear(this->rdstate() & ~ios_base::eofbit);
N        sentry __sen(*this, true);
N        if (__sen)
N        {
N            if (this->rdbuf()->pubseekoff(__off, __dir, ios_base::in) == pos_type(-1))
N                this->setstate(ios_base::failbit);
N        }
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        this->__set_badbit_and_consider_rethrow();
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    return *this;
N}
N
Ntemplate <class _CharT, class _Traits>
Nbasic_istream<_CharT, _Traits>&
Nws(basic_istream<_CharT, _Traits>& __is)
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        typename basic_istream<_CharT, _Traits>::sentry __sen(__is, true);
N        if (__sen)
N        {
N            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());
N            while (true)
N            {
N                typename _Traits::int_type __i = __is.rdbuf()->sgetc();
N                if (_Traits::eq_int_type(__i, _Traits::eof()))
N                {
N                   __is.setstate(ios_base::eofbit);
N                   break;
N                }
N                if (!__ct.is(__ct.space, _Traits::to_char_type(__i)))
N                    break;
N                __is.rdbuf()->sbumpc();
N            }
N        }
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        __is.__set_badbit_and_consider_rethrow();
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    return __is;
N}
N
N#ifndef _LIBCPP_CXX03_LANG
N
Ntemplate <class _CharT, class _Traits, class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbasic_istream<_CharT, _Traits>&
Noperator>>(basic_istream<_CharT, _Traits>&& __is, _Tp&& __x)
N{
N    __is >> _VSTD::forward<_Tp>(__x);
X    __is >> std::__2::forward<_Tp>(__x);
N    return __is;
N}
N
N#endif  // _LIBCPP_CXX03_LANG
N
Ntemplate <class _CharT, class _Traits>
Nclass _LIBCPP_TEMPLATE_VIS basic_iostream
Xclass  basic_iostream
N    : public basic_istream<_CharT, _Traits>,
N      public basic_ostream<_CharT, _Traits>
N{
Npublic:
N    // types:
N    typedef _CharT                         char_type;
N    typedef _Traits                        traits_type;
N    typedef typename traits_type::int_type int_type;
N    typedef typename traits_type::pos_type pos_type;
N    typedef typename traits_type::off_type off_type;
N
N    // constructor/destructor
N    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY
X    inline __attribute__((__always_inline__))
N    explicit basic_iostream(basic_streambuf<char_type, traits_type>* __sb)
N      : basic_istream<_CharT, _Traits>(__sb)
N    {}
N
N    virtual ~basic_iostream();
Nprotected:
N#ifndef _LIBCPP_CXX03_LANG
N    inline _LIBCPP_INLINE_VISIBILITY
X    inline __attribute__ ((__always_inline__))
N    basic_iostream(basic_iostream&& __rhs);
N
N    // assign/swap
N    inline _LIBCPP_INLINE_VISIBILITY
X    inline __attribute__ ((__always_inline__))
N    basic_iostream& operator=(basic_iostream&& __rhs);
N#endif
N    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY
X    inline __attribute__((__always_inline__))
N    void swap(basic_iostream& __rhs)
N    { basic_istream<char_type, traits_type>::swap(__rhs); }
Npublic:
N};
N
N#ifndef _LIBCPP_CXX03_LANG
N
Ntemplate <class _CharT, class _Traits>
Nbasic_iostream<_CharT, _Traits>::basic_iostream(basic_iostream&& __rhs)
N    : basic_istream<_CharT, _Traits>(_VSTD::move(__rhs))
X    : basic_istream<_CharT, _Traits>(std::__2::move(__rhs))
N{
N}
N
Ntemplate <class _CharT, class _Traits>
Nbasic_iostream<_CharT, _Traits>&
Nbasic_iostream<_CharT, _Traits>::operator=(basic_iostream&& __rhs)
N{
N    swap(__rhs);
N    return *this;
N}
N
N#endif  // _LIBCPP_CXX03_LANG
N
Ntemplate <class _CharT, class _Traits>
Nbasic_iostream<_CharT, _Traits>::~basic_iostream()
N{
N}
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Nbasic_istream<_CharT, _Traits>&
Noperator>>(basic_istream<_CharT, _Traits>& __is,
N           basic_string<_CharT, _Traits, _Allocator>& __str)
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        typename basic_istream<_CharT, _Traits>::sentry __sen(__is);
N        if (__sen)
N        {
N            __str.clear();
N            streamsize __n = __is.width();
N            if (__n <= 0)
N                __n = __str.max_size();
N            if (__n <= 0)
N                __n = numeric_limits<streamsize>::max();
N            streamsize __c = 0;
N            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());
N            ios_base::iostate __err = ios_base::goodbit;
N            while (__c < __n)
N            {
N                typename _Traits::int_type __i = __is.rdbuf()->sgetc();
N                if (_Traits::eq_int_type(__i, _Traits::eof()))
N                {
N                   __err |= ios_base::eofbit;
N                   break;
N                }
N                _CharT __ch = _Traits::to_char_type(__i);
N                if (__ct.is(__ct.space, __ch))
N                    break;
N                __str.push_back(__ch);
N                ++__c;
N                 __is.rdbuf()->sbumpc();
N            }
N            __is.width(0);
N            if (__c == 0)
N               __err |= ios_base::failbit;
N            __is.setstate(__err);
N        }
N        else
N            __is.setstate(ios_base::failbit);
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        __is.__set_badbit_and_consider_rethrow();
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    return __is;
N}
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Nbasic_istream<_CharT, _Traits>&
Ngetline(basic_istream<_CharT, _Traits>& __is,
N        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm)
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        typename basic_istream<_CharT, _Traits>::sentry __sen(__is, true);
N        if (__sen)
N        {
N            __str.clear();
N            ios_base::iostate __err = ios_base::goodbit;
N            streamsize __extr = 0;
N            while (true)
N            {
N                typename _Traits::int_type __i = __is.rdbuf()->sbumpc();
N                if (_Traits::eq_int_type(__i, _Traits::eof()))
N                {
N                   __err |= ios_base::eofbit;
N                   break;
N                }
N                ++__extr;
N                _CharT __ch = _Traits::to_char_type(__i);
N                if (_Traits::eq(__ch, __dlm))
N                    break;
N                __str.push_back(__ch);
N                if (__str.size() == __str.max_size())
N                {
N                    __err |= ios_base::failbit;
N                    break;
N                }
N            }
N            if (__extr == 0)
N               __err |= ios_base::failbit;
N            __is.setstate(__err);
N        }
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        __is.__set_badbit_and_consider_rethrow();
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    return __is;
N}
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbasic_istream<_CharT, _Traits>&
Ngetline(basic_istream<_CharT, _Traits>& __is,
N        basic_string<_CharT, _Traits, _Allocator>& __str)
N{
N    return getline(__is, __str, __is.widen('\n'));
N}
N
N#ifndef _LIBCPP_CXX03_LANG
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbasic_istream<_CharT, _Traits>&
Ngetline(basic_istream<_CharT, _Traits>&& __is,
N        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm)
N{
N    return getline(__is, __str, __dlm);
N}
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nbasic_istream<_CharT, _Traits>&
Ngetline(basic_istream<_CharT, _Traits>&& __is,
N        basic_string<_CharT, _Traits, _Allocator>& __str)
N{
N    return getline(__is, __str, __is.widen('\n'));
N}
N
N#endif  // _LIBCPP_CXX03_LANG
N
Ntemplate <class _CharT, class _Traits, size_t _Size>
Nbasic_istream<_CharT, _Traits>&
Noperator>>(basic_istream<_CharT, _Traits>& __is, bitset<_Size>& __x)
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        typename basic_istream<_CharT, _Traits>::sentry __sen(__is);
N        if (__sen)
N        {
N            basic_string<_CharT, _Traits> __str;
N            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());
N            size_t __c = 0;
N            ios_base::iostate __err = ios_base::goodbit;
N            _CharT __zero = __ct.widen('0');
N            _CharT __one = __ct.widen('1');
N            while (__c < _Size)
N            {
N                typename _Traits::int_type __i = __is.rdbuf()->sgetc();
N                if (_Traits::eq_int_type(__i, _Traits::eof()))
N                {
N                   __err |= ios_base::eofbit;
N                   break;
N                }
N                _CharT __ch = _Traits::to_char_type(__i);
N                if (!_Traits::eq(__ch, __zero) && !_Traits::eq(__ch, __one))
N                    break;
N                __str.push_back(__ch);
N                ++__c;
N                 __is.rdbuf()->sbumpc();
N            }
N            __x = bitset<_Size>(__str);
N            if (__c == 0)
N               __err |= ios_base::failbit;
N            __is.setstate(__err);
N        }
N        else
N            __is.setstate(ios_base::failbit);
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        __is.__set_badbit_and_consider_rethrow();
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    return __is;
N}
N
N#ifndef _LIBCPP_AVAILABILITY_NO_STREAMS_EXTERN_TEMPLATE
N_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_istream<char>)
Xextern template class basic_istream<char>;
N_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_istream<wchar_t>)
Xextern template class basic_istream<wchar_t>;
N_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_iostream<char>)
Xextern template class basic_iostream<char>;
N#endif
N
N_LIBCPP_END_NAMESPACE_STD
X} }
N
N_LIBCPP_POP_MACROS
X_Pragma("pop_macro(\"min\")") _Pragma("pop_macro(\"max\")")
N
N#endif  // _LIBCPP_ISTREAM
L 176 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/sstream" 2
N#include <string>
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N_LIBCPP_PUSH_MACROS
X_Pragma("push_macro(\"min\")") _Pragma("push_macro(\"max\")")
N#include <__undef_macros>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/__undef_macros" 1
N// -*- C++ -*-
N//===------------------------ __undef_macros ------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is distributed under the University of Illinois Open Source
N// License. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N
N#ifdef min
S#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
S#if defined(_LIBCPP_WARNING)
S_LIBCPP_WARNING("macro min is incompatible with C++.  Try #define NOMINMAX "
S                "before any Windows header. #undefing min")
S#else
S#warning: macro min is incompatible with C++.  #undefing min
S#endif
S#endif
S#undef min
N#endif
N
N#ifdef max
S#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
S#if defined(_LIBCPP_WARNING)
S_LIBCPP_WARNING("macro max is incompatible with C++.  Try #define NOMINMAX "
S                "before any Windows header. #undefing max")
S#else
S#warning: macro max is incompatible with C++.  #undefing max
S#endif
S#endif
S#undef max
N#endif
L 184 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/sstream" 2
N
N
N_LIBCPP_BEGIN_NAMESPACE_STD
Xnamespace std { inline namespace __2 {
N
N// basic_stringbuf
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nclass _LIBCPP_TEMPLATE_VIS basic_stringbuf
Xclass  basic_stringbuf
N    : public basic_streambuf<_CharT, _Traits>
N{
Npublic:
N    typedef _CharT                         char_type;
N    typedef _Traits                        traits_type;
N    typedef typename traits_type::int_type int_type;
N    typedef typename traits_type::pos_type pos_type;
N    typedef typename traits_type::off_type off_type;
N    typedef _Allocator                     allocator_type;
N
N    typedef basic_string<char_type, traits_type, allocator_type> string_type;
N
Nprivate:
N
N    string_type __str_;
N    mutable char_type* __hm_;
N    ios_base::openmode __mode_;
N
Npublic:
N    // 27.8.1.1 Constructors:
N    inline _LIBCPP_INLINE_VISIBILITY
X    inline __attribute__ ((__always_inline__))
N    explicit basic_stringbuf(ios_base::openmode __wch = ios_base::in | ios_base::out);
N    inline _LIBCPP_INLINE_VISIBILITY
X    inline __attribute__ ((__always_inline__))
N    explicit basic_stringbuf(const string_type& __s,
N                             ios_base::openmode __wch = ios_base::in | ios_base::out);
N#ifndef _LIBCPP_CXX03_LANG
N    basic_stringbuf(basic_stringbuf&& __rhs);
N
N    // 27.8.1.2 Assign and swap:
N    basic_stringbuf& operator=(basic_stringbuf&& __rhs);
N#endif
N    void swap(basic_stringbuf& __rhs);
N
N    // 27.8.1.3 Get and set:
N    string_type str() const;
N    void str(const string_type& __s);
N
Nprotected:
N    // 27.8.1.4 Overridden virtual functions:
N    virtual int_type underflow();
N    virtual int_type pbackfail(int_type __c = traits_type::eof());
N    virtual int_type overflow (int_type __c = traits_type::eof());
N    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,
N                             ios_base::openmode __wch = ios_base::in | ios_base::out);
N    inline _LIBCPP_INLINE_VISIBILITY
X    inline __attribute__ ((__always_inline__))
N    virtual pos_type seekpos(pos_type __sp,
N                             ios_base::openmode __wch = ios_base::in | ios_base::out);
N};
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_stringbuf<_CharT, _Traits, _Allocator>::basic_stringbuf(ios_base::openmode __wch)
N    : __hm_(0),
N      __mode_(__wch)
N{
N    str(string_type());
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_stringbuf<_CharT, _Traits, _Allocator>::basic_stringbuf(const string_type& __s,
N                             ios_base::openmode __wch)
N    : __str_(__s.get_allocator()),
N      __hm_(0),
N      __mode_(__wch)
N{
N    str(__s);
N}
N
N#ifndef _LIBCPP_CXX03_LANG
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_stringbuf<_CharT, _Traits, _Allocator>::basic_stringbuf(basic_stringbuf&& __rhs)
N    : __mode_(__rhs.__mode_)
N{
N    char_type* __p = const_cast<char_type*>(__rhs.__str_.data());
N    ptrdiff_t __binp = -1;
N    ptrdiff_t __ninp = -1;
N    ptrdiff_t __einp = -1;
N    if (__rhs.eback() != nullptr)
N    {
N        __binp = __rhs.eback() - __p;
N        __ninp = __rhs.gptr() - __p;
N        __einp = __rhs.egptr() - __p;
N    }
N    ptrdiff_t __bout = -1;
N    ptrdiff_t __nout = -1;
N    ptrdiff_t __eout = -1;
N    if (__rhs.pbase() != nullptr)
N    {
N        __bout = __rhs.pbase() - __p;
N        __nout = __rhs.pptr() - __p;
N        __eout = __rhs.epptr() - __p;
N    }
N    ptrdiff_t __hm = __rhs.__hm_ == nullptr ? -1 : __rhs.__hm_ - __p;
N    __str_ = _VSTD::move(__rhs.__str_);
X    __str_ = std::__2::move(__rhs.__str_);
N    __p = const_cast<char_type*>(__str_.data());
N    if (__binp != -1)
N        this->setg(__p + __binp, __p + __ninp, __p + __einp);
N    if (__bout != -1)
N    {
N        this->setp(__p + __bout, __p + __eout);
N        this->__pbump(__nout);
N    }
N    __hm_ = __hm == -1 ? nullptr : __p + __hm;
N    __p = const_cast<char_type*>(__rhs.__str_.data());
N    __rhs.setg(__p, __p, __p);
N    __rhs.setp(__p, __p);
N    __rhs.__hm_ = __p;
N    this->pubimbue(__rhs.getloc());
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_stringbuf<_CharT, _Traits, _Allocator>&
Nbasic_stringbuf<_CharT, _Traits, _Allocator>::operator=(basic_stringbuf&& __rhs)
N{
N    char_type* __p = const_cast<char_type*>(__rhs.__str_.data());
N    ptrdiff_t __binp = -1;
N    ptrdiff_t __ninp = -1;
N    ptrdiff_t __einp = -1;
N    if (__rhs.eback() != nullptr)
N    {
N        __binp = __rhs.eback() - __p;
N        __ninp = __rhs.gptr() - __p;
N        __einp = __rhs.egptr() - __p;
N    }
N    ptrdiff_t __bout = -1;
N    ptrdiff_t __nout = -1;
N    ptrdiff_t __eout = -1;
N    if (__rhs.pbase() != nullptr)
N    {
N        __bout = __rhs.pbase() - __p;
N        __nout = __rhs.pptr() - __p;
N        __eout = __rhs.epptr() - __p;
N    }
N    ptrdiff_t __hm = __rhs.__hm_ == nullptr ? -1 : __rhs.__hm_ - __p;
N    __str_ = _VSTD::move(__rhs.__str_);
X    __str_ = std::__2::move(__rhs.__str_);
N    __p = const_cast<char_type*>(__str_.data());
N    if (__binp != -1)
N        this->setg(__p + __binp, __p + __ninp, __p + __einp);
N    else
N        this->setg(nullptr, nullptr, nullptr);
N    if (__bout != -1)
N    {
N        this->setp(__p + __bout, __p + __eout);
N        this->__pbump(__nout);
N    }
N    else
N        this->setp(nullptr, nullptr);
N
N    __hm_ = __hm == -1 ? nullptr : __p + __hm;
N    __mode_ = __rhs.__mode_;
N    __p = const_cast<char_type*>(__rhs.__str_.data());
N    __rhs.setg(__p, __p, __p);
N    __rhs.setp(__p, __p);
N    __rhs.__hm_ = __p;
N    this->pubimbue(__rhs.getloc());
N    return *this;
N}
N
N#endif  // _LIBCPP_CXX03_LANG
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nvoid
Nbasic_stringbuf<_CharT, _Traits, _Allocator>::swap(basic_stringbuf& __rhs)
N{
N    char_type* __p = const_cast<char_type*>(__rhs.__str_.data());
N    ptrdiff_t __rbinp = -1;
N    ptrdiff_t __rninp = -1;
N    ptrdiff_t __reinp = -1;
N    if (__rhs.eback() != nullptr)
N    {
N        __rbinp = __rhs.eback() - __p;
N        __rninp = __rhs.gptr() - __p;
N        __reinp = __rhs.egptr() - __p;
N    }
N    ptrdiff_t __rbout = -1;
N    ptrdiff_t __rnout = -1;
N    ptrdiff_t __reout = -1;
N    if (__rhs.pbase() != nullptr)
N    {
N        __rbout = __rhs.pbase() - __p;
N        __rnout = __rhs.pptr() - __p;
N        __reout = __rhs.epptr() - __p;
N    }
N    ptrdiff_t __rhm = __rhs.__hm_ == nullptr ? -1 : __rhs.__hm_ - __p;
N    __p = const_cast<char_type*>(__str_.data());
N    ptrdiff_t __lbinp = -1;
N    ptrdiff_t __lninp = -1;
N    ptrdiff_t __leinp = -1;
N    if (this->eback() != nullptr)
N    {
N        __lbinp = this->eback() - __p;
N        __lninp = this->gptr() - __p;
N        __leinp = this->egptr() - __p;
N    }
N    ptrdiff_t __lbout = -1;
N    ptrdiff_t __lnout = -1;
N    ptrdiff_t __leout = -1;
N    if (this->pbase() != nullptr)
N    {
N        __lbout = this->pbase() - __p;
N        __lnout = this->pptr() - __p;
N        __leout = this->epptr() - __p;
N    }
N    ptrdiff_t __lhm = __hm_ == nullptr ? -1 : __hm_ - __p;
N    _VSTD::swap(__mode_, __rhs.__mode_);
X    std::__2::swap(__mode_, __rhs.__mode_);
N    __str_.swap(__rhs.__str_);
N    __p = const_cast<char_type*>(__str_.data());
N    if (__rbinp != -1)
N        this->setg(__p + __rbinp, __p + __rninp, __p + __reinp);
N    else
N        this->setg(nullptr, nullptr, nullptr);
N    if (__rbout != -1)
N    {
N        this->setp(__p + __rbout, __p + __reout);
N        this->__pbump(__rnout);
N    }
N    else
N        this->setp(nullptr, nullptr);
N    __hm_ = __rhm == -1 ? nullptr : __p + __rhm;
N    __p = const_cast<char_type*>(__rhs.__str_.data());
N    if (__lbinp != -1)
N        __rhs.setg(__p + __lbinp, __p + __lninp, __p + __leinp);
N    else
N        __rhs.setg(nullptr, nullptr, nullptr);
N    if (__lbout != -1)
N    {
N        __rhs.setp(__p + __lbout, __p + __leout);
N        __rhs.__pbump(__lnout);
N    }
N    else
N        __rhs.setp(nullptr, nullptr);
N    __rhs.__hm_ = __lhm == -1 ? nullptr : __p + __lhm;
N    locale __tl = __rhs.getloc();
N    __rhs.pubimbue(this->getloc());
N    this->pubimbue(__tl);
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Nswap(basic_stringbuf<_CharT, _Traits, _Allocator>& __x,
N     basic_stringbuf<_CharT, _Traits, _Allocator>& __y)
N{
N    __x.swap(__y);
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>
Nbasic_stringbuf<_CharT, _Traits, _Allocator>::str() const
N{
N    if (__mode_ & ios_base::out)
N    {
N        if (__hm_ < this->pptr())
N            __hm_ = this->pptr();
N        return string_type(this->pbase(), __hm_, __str_.get_allocator());
N    }
N    else if (__mode_ & ios_base::in)
N        return string_type(this->eback(), this->egptr(), __str_.get_allocator());
N    return string_type(__str_.get_allocator());
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nvoid
Nbasic_stringbuf<_CharT, _Traits, _Allocator>::str(const string_type& __s)
N{
N    __str_ = __s;
N    __hm_ = 0;
N    if (__mode_ & ios_base::in)
N    {
N        __hm_ = const_cast<char_type*>(__str_.data()) + __str_.size();
N        this->setg(const_cast<char_type*>(__str_.data()),
N                   const_cast<char_type*>(__str_.data()),
N                   __hm_);
N    }
N    if (__mode_ & ios_base::out)
N    {
N        typename string_type::size_type __sz = __str_.size();
N        __hm_ = const_cast<char_type*>(__str_.data()) + __sz;
N        __str_.resize(__str_.capacity());
N        this->setp(const_cast<char_type*>(__str_.data()),
N                   const_cast<char_type*>(__str_.data()) + __str_.size());
N        if (__mode_ & (ios_base::app | ios_base::ate))
N        {
N            while (__sz > INT_MAX)
X            while (__sz > 2147483647)
N            {
N            	this->pbump(INT_MAX);
X            	this->pbump(2147483647);
N            	__sz -= INT_MAX;
X            	__sz -= 2147483647;
N            }
N            if (__sz > 0)
N            	this->pbump(__sz);
N    	}
N    }
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ntypename basic_stringbuf<_CharT, _Traits, _Allocator>::int_type
Nbasic_stringbuf<_CharT, _Traits, _Allocator>::underflow()
N{
N    if (__hm_ < this->pptr())
N        __hm_ = this->pptr();
N    if (__mode_ & ios_base::in)
N    {
N        if (this->egptr() < __hm_)
N            this->setg(this->eback(), this->gptr(), __hm_);
N        if (this->gptr() < this->egptr())
N            return traits_type::to_int_type(*this->gptr());
N    }
N    return traits_type::eof();
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ntypename basic_stringbuf<_CharT, _Traits, _Allocator>::int_type
Nbasic_stringbuf<_CharT, _Traits, _Allocator>::pbackfail(int_type __c)
N{
N    if (__hm_ < this->pptr())
N        __hm_ = this->pptr();
N    if (this->eback() < this->gptr())
N    {
N        if (traits_type::eq_int_type(__c, traits_type::eof()))
N        {
N            this->setg(this->eback(), this->gptr()-1, __hm_);
N            return traits_type::not_eof(__c);
N        }
N        if ((__mode_ & ios_base::out) ||
N            traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1]))
N        {
N            this->setg(this->eback(), this->gptr()-1, __hm_);
N            *this->gptr() = traits_type::to_char_type(__c);
N            return __c;
N        }
N    }
N    return traits_type::eof();
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ntypename basic_stringbuf<_CharT, _Traits, _Allocator>::int_type
Nbasic_stringbuf<_CharT, _Traits, _Allocator>::overflow(int_type __c)
N{
N    if (!traits_type::eq_int_type(__c, traits_type::eof()))
N    {
N        ptrdiff_t __ninp = this->gptr()  - this->eback();
N        if (this->pptr() == this->epptr())
N        {
N            if (!(__mode_ & ios_base::out))
N                return traits_type::eof();
N#ifndef _LIBCPP_NO_EXCEPTIONS
S            try
S            {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N                ptrdiff_t __nout = this->pptr()  - this->pbase();
N                ptrdiff_t __hm = __hm_ - this->pbase();
N                __str_.push_back(char_type());
N                __str_.resize(__str_.capacity());
N                char_type* __p = const_cast<char_type*>(__str_.data());
N                this->setp(__p, __p + __str_.size());
N                this->__pbump(__nout);
N                __hm_ = this->pbase() + __hm;
N#ifndef _LIBCPP_NO_EXCEPTIONS
S            }
S            catch (...)
S            {
S                return traits_type::eof();
S            }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        }
N        __hm_ = _VSTD::max(this->pptr() + 1, __hm_);
X        __hm_ = std::__2::max(this->pptr() + 1, __hm_);
N        if (__mode_ & ios_base::in)
N        {
N            char_type* __p = const_cast<char_type*>(__str_.data());
N            this->setg(__p, __p + __ninp, __hm_);
N        }
N        return this->sputc(__c);
N    }
N    return traits_type::not_eof(__c);
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ntypename basic_stringbuf<_CharT, _Traits, _Allocator>::pos_type
Nbasic_stringbuf<_CharT, _Traits, _Allocator>::seekoff(off_type __off,
N                                                      ios_base::seekdir __way,
N                                                      ios_base::openmode __wch)
N{
N    if (__hm_ < this->pptr())
N        __hm_ = this->pptr();
N    if ((__wch & (ios_base::in | ios_base::out)) == 0)
N        return pos_type(-1);
N    if ((__wch & (ios_base::in | ios_base::out)) == (ios_base::in | ios_base::out)
N        && __way == ios_base::cur)
N        return pos_type(-1);
N    off_type __noff;
N    switch (__way)
N    {
N    case ios_base::beg:
N        __noff = 0;
N        break;
N    case ios_base::cur:
N        if (__wch & ios_base::in)
N            __noff = this->gptr() - this->eback();
N        else
N            __noff = this->pptr() - this->pbase();
N        break;
N    case ios_base::end:
N        __noff = __hm_ - __str_.data();
N        break;
N    default:
N        return pos_type(-1);
N    }
N    __noff += __off;
N    if (__noff < 0 || __hm_ - __str_.data() < __noff)
N        return pos_type(-1);
N    if (__noff != 0)
N    {
N        if ((__wch & ios_base::in) && this->gptr() == 0)
N            return pos_type(-1);
N        if ((__wch & ios_base::out) && this->pptr() == 0)
N            return pos_type(-1);
N    }
N    if (__wch & ios_base::in)
N        this->setg(this->eback(), this->eback() + __noff, __hm_);
N    if (__wch & ios_base::out)
N    {
N        this->setp(this->pbase(), this->epptr());
N        this->pbump(__noff);
N    }
N    return pos_type(__noff);
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ntypename basic_stringbuf<_CharT, _Traits, _Allocator>::pos_type
Nbasic_stringbuf<_CharT, _Traits, _Allocator>::seekpos(pos_type __sp,
N                                                      ios_base::openmode __wch)
N{
N    return seekoff(__sp, ios_base::beg, __wch);
N}
N
N// basic_istringstream
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nclass _LIBCPP_TEMPLATE_VIS basic_istringstream
Xclass  basic_istringstream
N    : public basic_istream<_CharT, _Traits>
N{
Npublic:
N    typedef _CharT                         char_type;
N    typedef _Traits                        traits_type;
N    typedef typename traits_type::int_type int_type;
N    typedef typename traits_type::pos_type pos_type;
N    typedef typename traits_type::off_type off_type;
N    typedef _Allocator                     allocator_type;
N
N    typedef basic_string<char_type, traits_type, allocator_type> string_type;
N
Nprivate:
N    basic_stringbuf<char_type, traits_type, allocator_type> __sb_;
N
Npublic:
N    // 27.8.2.1 Constructors:
N    inline _LIBCPP_INLINE_VISIBILITY
X    inline __attribute__ ((__always_inline__))
N    explicit basic_istringstream(ios_base::openmode __wch = ios_base::in);
N    inline _LIBCPP_INLINE_VISIBILITY
X    inline __attribute__ ((__always_inline__))
N    explicit basic_istringstream(const string_type& __s,
N                                 ios_base::openmode __wch = ios_base::in);
N#ifndef _LIBCPP_CXX03_LANG
N    inline _LIBCPP_INLINE_VISIBILITY
X    inline __attribute__ ((__always_inline__))
N    basic_istringstream(basic_istringstream&& __rhs);
N
N    // 27.8.2.2 Assign and swap:
N    basic_istringstream& operator=(basic_istringstream&& __rhs);
N#endif  // _LIBCPP_CXX03_LANG
N    inline _LIBCPP_INLINE_VISIBILITY
X    inline __attribute__ ((__always_inline__))
N    void swap(basic_istringstream& __rhs);
N
N    // 27.8.2.3 Members:
N    inline _LIBCPP_INLINE_VISIBILITY
X    inline __attribute__ ((__always_inline__))
N    basic_stringbuf<char_type, traits_type, allocator_type>* rdbuf() const;
N    inline _LIBCPP_INLINE_VISIBILITY
X    inline __attribute__ ((__always_inline__))
N    string_type str() const;
N    inline _LIBCPP_INLINE_VISIBILITY
X    inline __attribute__ ((__always_inline__))
N    void str(const string_type& __s);
N};
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_istringstream<_CharT, _Traits, _Allocator>::basic_istringstream(ios_base::openmode __wch)
N    : basic_istream<_CharT, _Traits>(&__sb_),
N      __sb_(__wch | ios_base::in)
N{
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_istringstream<_CharT, _Traits, _Allocator>::basic_istringstream(const string_type& __s,
N                                                                      ios_base::openmode __wch)
N    : basic_istream<_CharT, _Traits>(&__sb_),
N      __sb_(__s, __wch | ios_base::in)
N{
N}
N
N#ifndef _LIBCPP_CXX03_LANG
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_istringstream<_CharT, _Traits, _Allocator>::basic_istringstream(basic_istringstream&& __rhs)
N    : basic_istream<_CharT, _Traits>(_VSTD::move(__rhs)),
X    : basic_istream<_CharT, _Traits>(std::__2::move(__rhs)),
N      __sb_(_VSTD::move(__rhs.__sb_))
X      __sb_(std::__2::move(__rhs.__sb_))
N{
N    basic_istream<_CharT, _Traits>::set_rdbuf(&__sb_);
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_istringstream<_CharT, _Traits, _Allocator>&
Nbasic_istringstream<_CharT, _Traits, _Allocator>::operator=(basic_istringstream&& __rhs)
N{
N    basic_istream<char_type, traits_type>::operator=(_VSTD::move(__rhs));
X    basic_istream<char_type, traits_type>::operator=(std::__2::move(__rhs));
N    __sb_ = _VSTD::move(__rhs.__sb_);
X    __sb_ = std::__2::move(__rhs.__sb_);
N    return *this;
N}
N
N#endif  // _LIBCPP_CXX03_LANG
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nvoid basic_istringstream<_CharT, _Traits, _Allocator>::swap(basic_istringstream& __rhs)
N{
N    basic_istream<char_type, traits_type>::swap(__rhs);
N    __sb_.swap(__rhs.__sb_);
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Nswap(basic_istringstream<_CharT, _Traits, _Allocator>& __x,
N     basic_istringstream<_CharT, _Traits, _Allocator>& __y)
N{
N    __x.swap(__y);
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_stringbuf<_CharT, _Traits, _Allocator>*
Nbasic_istringstream<_CharT, _Traits, _Allocator>::rdbuf() const
N{
N    return const_cast<basic_stringbuf<char_type, traits_type, allocator_type>*>(&__sb_);
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>
Nbasic_istringstream<_CharT, _Traits, _Allocator>::str() const
N{
N    return __sb_.str();
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nvoid basic_istringstream<_CharT, _Traits, _Allocator>::str(const string_type& __s)
N{
N    __sb_.str(__s);
N}
N
N// basic_ostringstream
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nclass _LIBCPP_TEMPLATE_VIS basic_ostringstream
Xclass  basic_ostringstream
N    : public basic_ostream<_CharT, _Traits>
N{
Npublic:
N    typedef _CharT                         char_type;
N    typedef _Traits                        traits_type;
N    typedef typename traits_type::int_type int_type;
N    typedef typename traits_type::pos_type pos_type;
N    typedef typename traits_type::off_type off_type;
N    typedef _Allocator                     allocator_type;
N
N    typedef basic_string<char_type, traits_type, allocator_type> string_type;
N
Nprivate:
N    basic_stringbuf<char_type, traits_type, allocator_type> __sb_;
N
Npublic:
N    // 27.8.2.1 Constructors:
N    inline _LIBCPP_INLINE_VISIBILITY
X    inline __attribute__ ((__always_inline__))
N    explicit basic_ostringstream(ios_base::openmode __wch = ios_base::out);
N    inline _LIBCPP_INLINE_VISIBILITY
X    inline __attribute__ ((__always_inline__))
N    explicit basic_ostringstream(const string_type& __s,
N                                 ios_base::openmode __wch = ios_base::out);
N#ifndef _LIBCPP_CXX03_LANG
N    inline _LIBCPP_INLINE_VISIBILITY
X    inline __attribute__ ((__always_inline__))
N    basic_ostringstream(basic_ostringstream&& __rhs);
N
N    // 27.8.2.2 Assign and swap:
N    basic_ostringstream& operator=(basic_ostringstream&& __rhs);
N#endif  // _LIBCPP_CXX03_LANG
N    inline _LIBCPP_INLINE_VISIBILITY
X    inline __attribute__ ((__always_inline__))
N    void swap(basic_ostringstream& __rhs);
N
N    // 27.8.2.3 Members:
N    inline _LIBCPP_INLINE_VISIBILITY
X    inline __attribute__ ((__always_inline__))
N    basic_stringbuf<char_type, traits_type, allocator_type>* rdbuf() const;
N    inline _LIBCPP_INLINE_VISIBILITY
X    inline __attribute__ ((__always_inline__))
N    string_type str() const;
N    inline _LIBCPP_INLINE_VISIBILITY
X    inline __attribute__ ((__always_inline__))
N    void str(const string_type& __s);
N};
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_ostringstream<_CharT, _Traits, _Allocator>::basic_ostringstream(ios_base::openmode __wch)
N    : basic_ostream<_CharT, _Traits>(&__sb_),
N      __sb_(__wch | ios_base::out)
N{
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_ostringstream<_CharT, _Traits, _Allocator>::basic_ostringstream(const string_type& __s,
N                                                                      ios_base::openmode __wch)
N    : basic_ostream<_CharT, _Traits>(&__sb_),
N      __sb_(__s, __wch | ios_base::out)
N{
N}
N
N#ifndef _LIBCPP_CXX03_LANG
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_ostringstream<_CharT, _Traits, _Allocator>::basic_ostringstream(basic_ostringstream&& __rhs)
N    : basic_ostream<_CharT, _Traits>(_VSTD::move(__rhs)),
X    : basic_ostream<_CharT, _Traits>(std::__2::move(__rhs)),
N      __sb_(_VSTD::move(__rhs.__sb_))
X      __sb_(std::__2::move(__rhs.__sb_))
N{
N    basic_ostream<_CharT, _Traits>::set_rdbuf(&__sb_);
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_ostringstream<_CharT, _Traits, _Allocator>&
Nbasic_ostringstream<_CharT, _Traits, _Allocator>::operator=(basic_ostringstream&& __rhs)
N{
N    basic_ostream<char_type, traits_type>::operator=(_VSTD::move(__rhs));
X    basic_ostream<char_type, traits_type>::operator=(std::__2::move(__rhs));
N    __sb_ = _VSTD::move(__rhs.__sb_);
X    __sb_ = std::__2::move(__rhs.__sb_);
N    return *this;
N}
N
N#endif  // _LIBCPP_CXX03_LANG
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nvoid
Nbasic_ostringstream<_CharT, _Traits, _Allocator>::swap(basic_ostringstream& __rhs)
N{
N    basic_ostream<char_type, traits_type>::swap(__rhs);
N    __sb_.swap(__rhs.__sb_);
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Nswap(basic_ostringstream<_CharT, _Traits, _Allocator>& __x,
N     basic_ostringstream<_CharT, _Traits, _Allocator>& __y)
N{
N    __x.swap(__y);
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_stringbuf<_CharT, _Traits, _Allocator>*
Nbasic_ostringstream<_CharT, _Traits, _Allocator>::rdbuf() const
N{
N    return const_cast<basic_stringbuf<char_type, traits_type, allocator_type>*>(&__sb_);
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>
Nbasic_ostringstream<_CharT, _Traits, _Allocator>::str() const
N{
N    return __sb_.str();
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nvoid
Nbasic_ostringstream<_CharT, _Traits, _Allocator>::str(const string_type& __s)
N{
N    __sb_.str(__s);
N}
N
N// basic_stringstream
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nclass _LIBCPP_TEMPLATE_VIS basic_stringstream
Xclass  basic_stringstream
N    : public basic_iostream<_CharT, _Traits>
N{
Npublic:
N    typedef _CharT                         char_type;
N    typedef _Traits                        traits_type;
N    typedef typename traits_type::int_type int_type;
N    typedef typename traits_type::pos_type pos_type;
N    typedef typename traits_type::off_type off_type;
N    typedef _Allocator                     allocator_type;
N
N    typedef basic_string<char_type, traits_type, allocator_type> string_type;
N
Nprivate:
N    basic_stringbuf<char_type, traits_type, allocator_type> __sb_;
N
Npublic:
N    // 27.8.2.1 Constructors:
N    inline _LIBCPP_INLINE_VISIBILITY
X    inline __attribute__ ((__always_inline__))
N    explicit basic_stringstream(ios_base::openmode __wch = ios_base::in | ios_base::out);
N    inline _LIBCPP_INLINE_VISIBILITY
X    inline __attribute__ ((__always_inline__))
N    explicit basic_stringstream(const string_type& __s,
N                                ios_base::openmode __wch = ios_base::in | ios_base::out);
N#ifndef _LIBCPP_CXX03_LANG
N    inline _LIBCPP_INLINE_VISIBILITY
X    inline __attribute__ ((__always_inline__))
N    basic_stringstream(basic_stringstream&& __rhs);
N
N    // 27.8.2.2 Assign and swap:
N    basic_stringstream& operator=(basic_stringstream&& __rhs);
N#endif  // _LIBCPP_CXX03_LANG
N    inline _LIBCPP_INLINE_VISIBILITY
X    inline __attribute__ ((__always_inline__))
N    void swap(basic_stringstream& __rhs);
N
N    // 27.8.2.3 Members:
N    inline _LIBCPP_INLINE_VISIBILITY
X    inline __attribute__ ((__always_inline__))
N    basic_stringbuf<char_type, traits_type, allocator_type>* rdbuf() const;
N    inline _LIBCPP_INLINE_VISIBILITY
X    inline __attribute__ ((__always_inline__))
N    string_type str() const;
N    inline _LIBCPP_INLINE_VISIBILITY
X    inline __attribute__ ((__always_inline__))
N    void str(const string_type& __s);
N};
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_stringstream<_CharT, _Traits, _Allocator>::basic_stringstream(ios_base::openmode __wch)
N    : basic_iostream<_CharT, _Traits>(&__sb_),
N      __sb_(__wch)
N{
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_stringstream<_CharT, _Traits, _Allocator>::basic_stringstream(const string_type& __s,
N                                                                    ios_base::openmode __wch)
N    : basic_iostream<_CharT, _Traits>(&__sb_),
N      __sb_(__s, __wch)
N{
N}
N
N#ifndef _LIBCPP_CXX03_LANG
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_stringstream<_CharT, _Traits, _Allocator>::basic_stringstream(basic_stringstream&& __rhs)
N    : basic_iostream<_CharT, _Traits>(_VSTD::move(__rhs)),
X    : basic_iostream<_CharT, _Traits>(std::__2::move(__rhs)),
N      __sb_(_VSTD::move(__rhs.__sb_))
X      __sb_(std::__2::move(__rhs.__sb_))
N{
N    basic_istream<_CharT, _Traits>::set_rdbuf(&__sb_);
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_stringstream<_CharT, _Traits, _Allocator>&
Nbasic_stringstream<_CharT, _Traits, _Allocator>::operator=(basic_stringstream&& __rhs)
N{
N    basic_iostream<char_type, traits_type>::operator=(_VSTD::move(__rhs));
X    basic_iostream<char_type, traits_type>::operator=(std::__2::move(__rhs));
N    __sb_ = _VSTD::move(__rhs.__sb_);
X    __sb_ = std::__2::move(__rhs.__sb_);
N    return *this;
N}
N
N#endif  // _LIBCPP_CXX03_LANG
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nvoid
Nbasic_stringstream<_CharT, _Traits, _Allocator>::swap(basic_stringstream& __rhs)
N{
N    basic_iostream<char_type, traits_type>::swap(__rhs);
N    __sb_.swap(__rhs.__sb_);
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Nswap(basic_stringstream<_CharT, _Traits, _Allocator>& __x,
N     basic_stringstream<_CharT, _Traits, _Allocator>& __y)
N{
N    __x.swap(__y);
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_stringbuf<_CharT, _Traits, _Allocator>*
Nbasic_stringstream<_CharT, _Traits, _Allocator>::rdbuf() const
N{
N    return const_cast<basic_stringbuf<char_type, traits_type, allocator_type>*>(&__sb_);
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>
Nbasic_stringstream<_CharT, _Traits, _Allocator>::str() const
N{
N    return __sb_.str();
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nvoid
Nbasic_stringstream<_CharT, _Traits, _Allocator>::str(const string_type& __s)
N{
N    __sb_.str(__s);
N}
N
N_LIBCPP_END_NAMESPACE_STD
X} }
N
N_LIBCPP_POP_MACROS
X_Pragma("pop_macro(\"min\")") _Pragma("pop_macro(\"max\")")
N
N#endif  // _LIBCPP_SSTREAM
L 13 "..\PID.h" 2
N#include <iomanip>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/iomanip" 1
N// -*- C++ -*-
N//===--------------------------- iomanip ----------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is dual licensed under the MIT and the University of Illinois Open
N// Source Licenses. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP_IOMANIP
N#define _LIBCPP_IOMANIP
N
N/*
N    iomanip synopsis
N
Nnamespace std {
N
N// types T1, T2, ... are unspecified implementation types
NT1 resetiosflags(ios_base::fmtflags mask);
NT2 setiosflags (ios_base::fmtflags mask);
NT3 setbase(int base);
Ntemplate<charT> T4 setfill(charT c);
NT5 setprecision(int n);
NT6 setw(int n);
Ntemplate <class moneyT> T7 get_money(moneyT& mon, bool intl = false);
Ntemplate <class charT, class moneyT> T8 put_money(const moneyT& mon, bool intl = false);
Ntemplate <class charT> T9 get_time(struct tm* tmb, const charT* fmt);
Ntemplate <class charT> T10 put_time(const struct tm* tmb, const charT* fmt);
N
Ntemplate <class charT>
N  T11 quoted(const charT* s, charT delim=charT('"'), charT escape=charT('\\')); // C++14
N
Ntemplate <class charT, class traits, class Allocator>
N  T12 quoted(const basic_string<charT, traits, Allocator>& s,
N             charT delim=charT('"'), charT escape=charT('\\')); // C++14
N
Ntemplate <class charT, class traits, class Allocator>
N  T13 quoted(basic_string<charT, traits, Allocator>& s,
N             charT delim=charT('"'), charT escape=charT('\\')); // C++14
N
N}  // std
N
N*/
N
N#include <__config>
N#include <__string>
N#include <istream>
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N_LIBCPP_BEGIN_NAMESPACE_STD
Xnamespace std { inline namespace __2 {
N
N// resetiosflags
N
Nclass __iom_t1
N{
N    ios_base::fmtflags __mask_;
Npublic:
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    explicit __iom_t1(ios_base::fmtflags __m) : __mask_(__m) {}
N
N    template <class _CharT, class _Traits>
N    friend
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    basic_istream<_CharT, _Traits>&
N    operator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t1& __x)
N    {
N        __is.unsetf(__x.__mask_);
N        return __is;
N    }
N
N    template <class _CharT, class _Traits>
N    friend
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    basic_ostream<_CharT, _Traits>&
N    operator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t1& __x)
N    {
N        __os.unsetf(__x.__mask_);
N        return __os;
N    }
N};
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N__iom_t1
Nresetiosflags(ios_base::fmtflags __mask)
N{
N    return __iom_t1(__mask);
N}
N
N// setiosflags
N
Nclass __iom_t2
N{
N    ios_base::fmtflags __mask_;
Npublic:
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    explicit __iom_t2(ios_base::fmtflags __m) : __mask_(__m) {}
N
N    template <class _CharT, class _Traits>
N    friend
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    basic_istream<_CharT, _Traits>&
N    operator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t2& __x)
N    {
N        __is.setf(__x.__mask_);
N        return __is;
N    }
N
N    template <class _CharT, class _Traits>
N    friend
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    basic_ostream<_CharT, _Traits>&
N    operator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t2& __x)
N    {
N        __os.setf(__x.__mask_);
N        return __os;
N    }
N};
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N__iom_t2
Nsetiosflags(ios_base::fmtflags __mask)
N{
N    return __iom_t2(__mask);
N}
N
N// setbase
N
Nclass __iom_t3
N{
N    int __base_;
Npublic:
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    explicit __iom_t3(int __b) : __base_(__b) {}
N
N    template <class _CharT, class _Traits>
N    friend
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    basic_istream<_CharT, _Traits>&
N    operator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t3& __x)
N    {
N        __is.setf(__x.__base_ == 8  ? ios_base::oct :
N                  __x.__base_ == 10 ? ios_base::dec :
N                  __x.__base_ == 16 ? ios_base::hex :
N                  ios_base::fmtflags(0), ios_base::basefield);
N        return __is;
N    }
N
N    template <class _CharT, class _Traits>
N    friend
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    basic_ostream<_CharT, _Traits>&
N    operator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t3& __x)
N    {
N        __os.setf(__x.__base_ == 8  ? ios_base::oct :
N                  __x.__base_ == 10 ? ios_base::dec :
N                  __x.__base_ == 16 ? ios_base::hex :
N                  ios_base::fmtflags(0), ios_base::basefield);
N        return __os;
N    }
N};
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N__iom_t3
Nsetbase(int __base)
N{
N    return __iom_t3(__base);
N}
N
N// setfill
N
Ntemplate<class _CharT>
Nclass __iom_t4
N{
N    _CharT __fill_;
Npublic:
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    explicit __iom_t4(_CharT __c) : __fill_(__c) {}
N
N    template <class _Traits>
N    friend
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    basic_ostream<_CharT, _Traits>&
N    operator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t4& __x)
N    {
N        __os.fill(__x.__fill_);
N        return __os;
N    }
N};
N
Ntemplate<class _CharT>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N__iom_t4<_CharT>
Nsetfill(_CharT __c)
N{
N    return __iom_t4<_CharT>(__c);
N}
N
N// setprecision
N
Nclass __iom_t5
N{
N    int __n_;
Npublic:
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    explicit __iom_t5(int __n) : __n_(__n) {}
N
N    template <class _CharT, class _Traits>
N    friend
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    basic_istream<_CharT, _Traits>&
N    operator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t5& __x)
N    {
N        __is.precision(__x.__n_);
N        return __is;
N    }
N
N    template <class _CharT, class _Traits>
N    friend
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    basic_ostream<_CharT, _Traits>&
N    operator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t5& __x)
N    {
N        __os.precision(__x.__n_);
N        return __os;
N    }
N};
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N__iom_t5
Nsetprecision(int __n)
N{
N    return __iom_t5(__n);
N}
N
N// setw
N
Nclass __iom_t6
N{
N    int __n_;
Npublic:
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    explicit __iom_t6(int __n) : __n_(__n) {}
N
N    template <class _CharT, class _Traits>
N    friend
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    basic_istream<_CharT, _Traits>&
N    operator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t6& __x)
N    {
N        __is.width(__x.__n_);
N        return __is;
N    }
N
N    template <class _CharT, class _Traits>
N    friend
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    basic_ostream<_CharT, _Traits>&
N    operator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t6& __x)
N    {
N        __os.width(__x.__n_);
N        return __os;
N    }
N};
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N__iom_t6
Nsetw(int __n)
N{
N    return __iom_t6(__n);
N}
N
N// get_money
N
Ntemplate <class _MoneyT> class __iom_t7;
N
Ntemplate <class _CharT, class _Traits, class _MoneyT>
Nbasic_istream<_CharT, _Traits>&
Noperator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t7<_MoneyT>& __x);
N
Ntemplate <class _MoneyT>
Nclass __iom_t7
N{
N    _MoneyT& __mon_;
N    bool __intl_;
Npublic:
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    __iom_t7(_MoneyT& __mon, bool __intl)
N        : __mon_(__mon), __intl_(__intl) {}
N
N    template <class _CharT, class _Traits, class _Mp>
N    friend
N    basic_istream<_CharT, _Traits>&
N    operator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t7<_Mp>& __x);
N};
N
Ntemplate <class _CharT, class _Traits, class _MoneyT>
Nbasic_istream<_CharT, _Traits>&
Noperator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t7<_MoneyT>& __x)
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        typename basic_istream<_CharT, _Traits>::sentry __s(__is);
N        if (__s)
N        {
N            typedef istreambuf_iterator<_CharT, _Traits> _Ip;
N            typedef money_get<_CharT, _Ip> _Fp;
N            ios_base::iostate __err = ios_base::goodbit;
N            const _Fp& __mf = use_facet<_Fp>(__is.getloc());
N            __mf.get(_Ip(__is), _Ip(), __x.__intl_, __is, __err, __x.__mon_);
N            __is.setstate(__err);
N        }
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        __is.__set_badbit_and_consider_rethrow();
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    return __is;
N}
N
Ntemplate <class _MoneyT>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N__iom_t7<_MoneyT>
Nget_money(_MoneyT& __mon, bool __intl = false)
N{
N    return __iom_t7<_MoneyT>(__mon, __intl);
N}
N
N// put_money
N
Ntemplate <class _MoneyT> class __iom_t8;
N
Ntemplate <class _CharT, class _Traits, class _MoneyT>
Nbasic_ostream<_CharT, _Traits>&
Noperator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t8<_MoneyT>& __x);
N
Ntemplate <class _MoneyT>
Nclass __iom_t8
N{
N    const _MoneyT& __mon_;
N    bool __intl_;
Npublic:
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    __iom_t8(const _MoneyT& __mon, bool __intl)
N        : __mon_(__mon), __intl_(__intl) {}
N
N    template <class _CharT, class _Traits, class _Mp>
N    friend
N    basic_ostream<_CharT, _Traits>&
N    operator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t8<_Mp>& __x);
N};
N
Ntemplate <class _CharT, class _Traits, class _MoneyT>
Nbasic_ostream<_CharT, _Traits>&
Noperator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t8<_MoneyT>& __x)
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);
N        if (__s)
N        {
N            typedef ostreambuf_iterator<_CharT, _Traits> _Op;
N            typedef money_put<_CharT, _Op> _Fp;
N            const _Fp& __mf = use_facet<_Fp>(__os.getloc());
N            if (__mf.put(_Op(__os), __x.__intl_, __os, __os.fill(), __x.__mon_).failed())
N                __os.setstate(ios_base::badbit);
N        }
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        __os.__set_badbit_and_consider_rethrow();
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    return __os;
N}
N
Ntemplate <class _MoneyT>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N__iom_t8<_MoneyT>
Nput_money(const _MoneyT& __mon, bool __intl = false)
N{
N    return __iom_t8<_MoneyT>(__mon, __intl);
N}
N
N// get_time
N
Ntemplate <class _CharT> class __iom_t9;
N
Ntemplate <class _CharT, class _Traits>
Nbasic_istream<_CharT, _Traits>&
Noperator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t9<_CharT>& __x);
N
Ntemplate <class _CharT>
Nclass __iom_t9
N{
N    tm* __tm_;
N    const _CharT* __fmt_;
Npublic:
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    __iom_t9(tm* __tm, const _CharT* __fmt)
N        : __tm_(__tm), __fmt_(__fmt) {}
N
N    template <class _Cp, class _Traits>
N    friend
N    basic_istream<_Cp, _Traits>&
N    operator>>(basic_istream<_Cp, _Traits>& __is, const __iom_t9<_Cp>& __x);
N};
N
Ntemplate <class _CharT, class _Traits>
Nbasic_istream<_CharT, _Traits>&
Noperator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t9<_CharT>& __x)
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        typename basic_istream<_CharT, _Traits>::sentry __s(__is);
N        if (__s)
N        {
N            typedef istreambuf_iterator<_CharT, _Traits> _Ip;
N            typedef time_get<_CharT, _Ip> _Fp;
N            ios_base::iostate __err = ios_base::goodbit;
N            const _Fp& __tf = use_facet<_Fp>(__is.getloc());
N            __tf.get(_Ip(__is), _Ip(), __is, __err, __x.__tm_,
N                     __x.__fmt_, __x.__fmt_ + _Traits::length(__x.__fmt_));
N            __is.setstate(__err);
N        }
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        __is.__set_badbit_and_consider_rethrow();
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    return __is;
N}
N
Ntemplate <class _CharT>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N__iom_t9<_CharT>
Nget_time(tm* __tm, const _CharT* __fmt)
N{
N    return __iom_t9<_CharT>(__tm, __fmt);
N}
N
N// put_time
N
Ntemplate <class _CharT> class __iom_t10;
N
Ntemplate <class _CharT, class _Traits>
Nbasic_ostream<_CharT, _Traits>&
Noperator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t10<_CharT>& __x);
N
Ntemplate <class _CharT>
Nclass __iom_t10
N{
N    const tm* __tm_;
N    const _CharT* __fmt_;
Npublic:
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N    __iom_t10(const tm* __tm, const _CharT* __fmt)
N        : __tm_(__tm), __fmt_(__fmt) {}
N
N    template <class _Cp, class _Traits>
N    friend
N    basic_ostream<_Cp, _Traits>&
N    operator<<(basic_ostream<_Cp, _Traits>& __os, const __iom_t10<_Cp>& __x);
N};
N
Ntemplate <class _CharT, class _Traits>
Nbasic_ostream<_CharT, _Traits>&
Noperator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t10<_CharT>& __x)
N{
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    try
S    {
N#endif  // _LIBCPP_NO_EXCEPTIONS
N        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);
N        if (__s)
N        {
N            typedef ostreambuf_iterator<_CharT, _Traits> _Op;
N            typedef time_put<_CharT, _Op> _Fp;
N            const _Fp& __tf = use_facet<_Fp>(__os.getloc());
N            if (__tf.put(_Op(__os), __os, __os.fill(), __x.__tm_,
N                         __x.__fmt_, __x.__fmt_ + _Traits::length(__x.__fmt_)).failed())
N                __os.setstate(ios_base::badbit);
N        }
N#ifndef _LIBCPP_NO_EXCEPTIONS
S    }
S    catch (...)
S    {
S        __os.__set_badbit_and_consider_rethrow();
S    }
N#endif  // _LIBCPP_NO_EXCEPTIONS
N    return __os;
N}
N
Ntemplate <class _CharT>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N__iom_t10<_CharT>
Nput_time(const tm* __tm, const _CharT* __fmt)
N{
N    return __iom_t10<_CharT>(__tm, __fmt);
N}
N
Ntemplate <class _CharT, class _Traits, class _ForwardIterator>
Nstd::basic_ostream<_CharT, _Traits> &
N__quoted_output ( basic_ostream<_CharT, _Traits> &__os, 
N        _ForwardIterator __first, _ForwardIterator __last, _CharT __delim, _CharT __escape )
N{
N    _VSTD::basic_string<_CharT, _Traits> __str;
X    std::__2::basic_string<_CharT, _Traits> __str;
N    __str.push_back(__delim);
N    for ( ; __first != __last; ++ __first )
N    {
N        if (_Traits::eq (*__first, __escape) || _Traits::eq (*__first, __delim))
N            __str.push_back(__escape);
N        __str.push_back(*__first);
N    }
N    __str.push_back(__delim);
N    return __put_character_sequence(__os, __str.data(), __str.size());
N}
N
Ntemplate <class _CharT, class _Traits, class _String>
Nbasic_istream<_CharT, _Traits> &
N__quoted_input ( basic_istream<_CharT, _Traits> &__is, _String & __string, _CharT __delim, _CharT __escape )
N{
N    __string.clear ();
N    _CharT __c;
N    __is >> __c;
N    if ( __is.fail ())
N        return __is;
N
N    if (!_Traits::eq (__c, __delim))    // no delimiter, read the whole string
N    {
N        __is.unget ();
N        __is >> __string;
N        return __is;
N    }
N
N    __save_flags<_CharT, _Traits> sf(__is);
N    noskipws (__is);
N    while (true)
N        {
N        __is >> __c;
N        if ( __is.fail ())
N            break;
N        if (_Traits::eq (__c, __escape))
N        {
N            __is >> __c;
N            if ( __is.fail ())
N                break;
N        }
N        else if (_Traits::eq (__c, __delim))
N            break;
N        __string.push_back ( __c );
N        }
N    return __is;
N}
N
N
Ntemplate <class _CharT, class _Traits, class _Iter>
Nbasic_ostream<_CharT, _Traits>& operator<<(
N         basic_ostream<_CharT, _Traits>& __os, 
N         const __quoted_output_proxy<_CharT, _Iter, _Traits> & __proxy)
N{
N    return __quoted_output (__os, __proxy.__first, __proxy.__last, __proxy.__delim, __proxy.__escape);
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nstruct __quoted_proxy
N{
N    basic_string<_CharT, _Traits, _Allocator> &__string;
N    _CharT  __delim;
N    _CharT  __escape;
N
N    __quoted_proxy(basic_string<_CharT, _Traits, _Allocator> &__s, _CharT __d, _CharT __e)
N    : __string(__s), __delim(__d), __escape(__e) {}
N};
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
N_LIBCPP_INLINE_VISIBILITY
X__attribute__ ((__always_inline__))
Nbasic_ostream<_CharT, _Traits>& operator<<(
N        basic_ostream<_CharT, _Traits>& __os, 
N        const __quoted_proxy<_CharT, _Traits, _Allocator> & __proxy)
N{
N    return __quoted_output (__os, __proxy.__string.cbegin (), __proxy.__string.cend (), __proxy.__delim, __proxy.__escape);
N}
N
N//  extractor for non-const basic_string& proxies
Ntemplate <class _CharT, class _Traits, class _Allocator>
N_LIBCPP_INLINE_VISIBILITY
X__attribute__ ((__always_inline__))
Nbasic_istream<_CharT, _Traits>& operator>>(
N        basic_istream<_CharT, _Traits>& __is, 
N        const __quoted_proxy<_CharT, _Traits, _Allocator> & __proxy)
N{
N    return __quoted_input ( __is, __proxy.__string, __proxy.__delim, __proxy.__escape );
N}
N
N
Ntemplate <class _CharT>
N_LIBCPP_INLINE_VISIBILITY
X__attribute__ ((__always_inline__))
N__quoted_output_proxy<_CharT, const _CharT *>
Nquoted ( const _CharT *__s, _CharT __delim = _CharT('"'), _CharT __escape =_CharT('\\'))
N{
N    const _CharT *__end = __s;
N    while ( *__end ) ++__end;
N    return __quoted_output_proxy<_CharT, const _CharT *> ( __s, __end, __delim, __escape );
N}
N
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
N_LIBCPP_INLINE_VISIBILITY
X__attribute__ ((__always_inline__))
N__quoted_output_proxy<_CharT, typename basic_string <_CharT, _Traits, _Allocator>::const_iterator>
N__quoted ( const basic_string <_CharT, _Traits, _Allocator> &__s, _CharT __delim = _CharT('"'), _CharT __escape=_CharT('\\'))
N{
N    return __quoted_output_proxy<_CharT,
N            typename basic_string <_CharT, _Traits, _Allocator>::const_iterator>
N                    ( __s.cbegin(), __s.cend (), __delim, __escape );
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
N_LIBCPP_INLINE_VISIBILITY
X__attribute__ ((__always_inline__))
N__quoted_proxy<_CharT, _Traits, _Allocator>
N__quoted ( basic_string <_CharT, _Traits, _Allocator> &__s, _CharT __delim = _CharT('"'), _CharT __escape=_CharT('\\'))
N{
N    return __quoted_proxy<_CharT, _Traits, _Allocator>( __s, __delim, __escape );
N}
N
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
N_LIBCPP_INLINE_VISIBILITY
X__attribute__ ((__always_inline__))
N__quoted_output_proxy<_CharT, typename basic_string <_CharT, _Traits, _Allocator>::const_iterator>
Nquoted ( const basic_string <_CharT, _Traits, _Allocator> &__s, _CharT __delim = _CharT('"'), _CharT __escape=_CharT('\\'))
N{
N    return __quoted(__s, __delim, __escape);
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
N_LIBCPP_INLINE_VISIBILITY
X__attribute__ ((__always_inline__))
N__quoted_proxy<_CharT, _Traits, _Allocator>
Nquoted ( basic_string <_CharT, _Traits, _Allocator> &__s, _CharT __delim = _CharT('"'), _CharT __escape=_CharT('\\'))
N{
N    return __quoted(__s, __delim, __escape);
N}
N
Ntemplate <class _CharT, class _Traits>
N__quoted_output_proxy<_CharT, const _CharT *, _Traits>
Nquoted (basic_string_view <_CharT, _Traits> __sv,
N             _CharT __delim = _CharT('"'), _CharT __escape=_CharT('\\'))
N{
N    return __quoted_output_proxy<_CharT, const _CharT *, _Traits> 
N         ( __sv.data(), __sv.data() + __sv.size(), __delim, __escape );
N}
N#endif
N
N_LIBCPP_END_NAMESPACE_STD
X} }
N
N#endif  // _LIBCPP_IOMANIP
L 14 "..\PID.h" 2
N
Nclass PID{
Npublic:
N    double Kp = 0;
N    double Ki = 0;
N    double Kd = 0;
N
N    double setpoint;
N    double measuredState;
N    double error;
N    double prevError = 0;
N    double acumError = 0;
N    double errorRate;
N    double dt;
N    double antiWindup;
N
N    double out_d;
N    double out_p;
N    double out_i;
N    double output;
N
N    PID(double Kp, double Ki, double Kd, double dt, double antiWindup = 225);
N
N    double updatePID(double setpoint, double input);
N
N    double updatePID(double setpoint, double input, double inputRate);
N
N    std::string getPIDconfig();
N
N
N
N
N};
N
N
N
N
N#endif /* PID_H_ */
L 9 "../PID.cpp" 2
N
NPID::PID(double Kp, double Ki, double Kd, double dt, double antiWindup):
N         Kp(Kp), Kd(Kd), Ki(Ki), antiWindup(antiWindup), dt(dt){}
N
Ndouble PID::updatePID(double setpoint, double input){
N    this->setpoint = setpoint;
N    this->measuredState = input;
N    error = this->setpoint - input;
N    out_p = Kp*error;
N    errorRate = (error - prevError)/dt;
N    out_d = Kp*Kd*errorRate;
N    if((acumError + error)*Kp*Ki<antiWindup)acumError+=(error);
N    out_i = Kp*Ki*acumError;
N    output = out_p + out_d + out_i;
N    prevError = error;
N    return output;
N}
N
Ndouble PID::updatePID(double setpoint, double input, double inputRate){
N    this->setpoint = setpoint;
N    this->measuredState = input;
N    error = this->setpoint - input;
N    out_p = Kp*error;
N    errorRate = -inputRate;
N    out_d = Kp*Kd*errorRate;
N
N    if((acumError + error)*Kp*Ki<antiWindup)acumError+=(error);
N    out_i = Kp*Ki*acumError;
N    output = out_p + out_d + out_i;
N    prevError = error;
N    return output;
N}
N
Nstd::string PID::getPIDconfig(){
N    std::ostringstream stream;
N    stream << std::setprecision(4) << "P: " << this->Kp << ", I: " << this->Ki << " , D: " << this->Kd;
N    return stream.str();
N}
N
N
N
R "../PID.cpp" 10 6 (ULP 5.2) Detected floating point operation(s). Recommend moving them to RAM during run time or not using as these are processing/power intensive
R "../PID.cpp" 11 10 (ULP 5.2) Detected floating point operation(s). Recommend moving them to RAM during run time or not using as these are processing/power intensive
R "" 0 0 (ULP 5.2) Detected floating point operation(s). Recommend moving them to RAM during run time or not using as these are processing/power intensive
R "../PID.cpp" 13 13 (ULP 5.2) Detected floating point operation(s). Recommend moving them to RAM during run time or not using as these are processing/power intensive
R "../PID.cpp" 14 20 (ULP 5.2) Detected floating point operation(s). Recommend moving them to RAM during run time or not using as these are processing/power intensive
R "../PID.cpp" 15 25 (ULP 5.2) Detected floating point operation(s). Recommend moving them to RAM during run time or not using as these are processing/power intensive
R "../PID.cpp" 16 11 (ULP 5.2) Detected floating point operation(s). Recommend moving them to RAM during run time or not using as these are processing/power intensive
R "../PID.cpp" 17 11 (ULP 5.2) Detected floating point operation(s). Recommend moving them to RAM during run time or not using as these are processing/power intensive
R "../PID.cpp" 18 15 (ULP 5.2) Detected floating point operation(s). Recommend moving them to RAM during run time or not using as these are processing/power intensive
R "../PID.cpp" 19 11 (ULP 5.2) Detected floating point operation(s). Recommend moving them to RAM during run time or not using as these are processing/power intensive
R "../PID.cpp" 20 33 (ULP 5.2) Detected floating point operation(s). Recommend moving them to RAM during run time or not using as these are processing/power intensive
R "../PID.cpp" 21 11 (ULP 5.2) Detected floating point operation(s). Recommend moving them to RAM during run time or not using as these are processing/power intensive
R "../PID.cpp" 22 12 (ULP 5.2) Detected floating point operation(s). Recommend moving them to RAM during run time or not using as these are processing/power intensive
R "../PID.cpp" 23 15 (ULP 5.2) Detected floating point operation(s). Recommend moving them to RAM during run time or not using as these are processing/power intensive
R "../PID.cpp" 27 13 (ULP 5.2) Detected floating point operation(s). Recommend moving them to RAM during run time or not using as these are processing/power intensive
R "../PID.cpp" 28 20 (ULP 5.2) Detected floating point operation(s). Recommend moving them to RAM during run time or not using as these are processing/power intensive
R "../PID.cpp" 29 25 (ULP 5.2) Detected floating point operation(s). Recommend moving them to RAM during run time or not using as these are processing/power intensive
R "../PID.cpp" 30 11 (ULP 5.2) Detected floating point operation(s). Recommend moving them to RAM during run time or not using as these are processing/power intensive
R "../PID.cpp" 31 11 (ULP 5.2) Detected floating point operation(s). Recommend moving them to RAM during run time or not using as these are processing/power intensive
R "../PID.cpp" 32 15 (ULP 5.2) Detected floating point operation(s). Recommend moving them to RAM during run time or not using as these are processing/power intensive
R "../PID.cpp" 33 11 (ULP 5.2) Detected floating point operation(s). Recommend moving them to RAM during run time or not using as these are processing/power intensive
R "../PID.cpp" 35 33 (ULP 5.2) Detected floating point operation(s). Recommend moving them to RAM during run time or not using as these are processing/power intensive
R "../PID.cpp" 36 11 (ULP 5.2) Detected floating point operation(s). Recommend moving them to RAM during run time or not using as these are processing/power intensive
R "../PID.cpp" 37 12 (ULP 5.2) Detected floating point operation(s). Recommend moving them to RAM during run time or not using as these are processing/power intensive
R "../PID.cpp" 38 15 (ULP 5.2) Detected floating point operation(s). Recommend moving them to RAM during run time or not using as these are processing/power intensive
R "../PID.cpp" 44 92 (ULP 5.2) Detected floating point operation(s). Recommend moving them to RAM during run time or not using as these are processing/power intensive
