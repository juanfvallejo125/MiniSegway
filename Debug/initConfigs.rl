L 1 "../initConfigs.cpp"
N/*
N * initConfigs.cpp
N *
N *  Created on: Jun 17, 2020
N *      Author: Juan Francisco Valle
N */
N
N#include "initConfigs.h"
L 1 "..\initConfigs.h" 1
N/*
N * initConfigs.h
N *
N *  Created on: Jun 17, 2020
N *      Author: Juan Francisco Valle
N */
N
N#ifndef INITCONFIGS_H_
N#define INITCONFIGS_H_
N
N#include "MiniSegway.h"
L 1 "..\MiniSegway.h" 1
N/*
N * MiniSegway.h
N *
N *  Created on: Jun 17, 2020
N *      Author: Juan Francisco Vallejo
N */
N
N#ifndef MINISEGWAY_H_
N#define MINISEGWAY_H_
N
N#include "driverlib.h"
L 1 "C:/ti/msp432_driverlib_3_21_00_05/driverlib/MSP432P4xx/driverlib.h" 1
N/*
N * -------------------------------------------
N *    MSP432 DriverLib - v3_21_00_05 
N * -------------------------------------------
N *
N * --COPYRIGHT--,BSD,BSD
N * Copyright (c) 2016, Texas Instruments Incorporated
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N *
N * *  Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N *
N * *  Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * *  Neither the name of Texas Instruments Incorporated nor the names of
N *    its contributors may be used to endorse or promote products derived
N *    from this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
N * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
N * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
N * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
N * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
N * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
N * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
N * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
N * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * --/COPYRIGHT--*/
N#ifndef __DRIVERLIB__H_
N#define __DRIVERLIB__H_
N
N#include "adc14.h"
L 1 "C:\ti\msp432_driverlib_3_21_00_05\driverlib\MSP432P4xx\adc14.h" 1
N/*
N * -------------------------------------------
N *    MSP432 DriverLib - v3_21_00_05 
N * -------------------------------------------
N *
N * --COPYRIGHT--,BSD,BSD
N * Copyright (c) 2016, Texas Instruments Incorporated
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N *
N * *  Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N *
N * *  Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * *  Neither the name of Texas Instruments Incorporated nor the names of
N *    its contributors may be used to endorse or promote products derived
N *    from this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
N * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
N * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
N * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
N * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
N * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
N * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
N * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
N * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * --/COPYRIGHT--*/
N#ifndef ADC14_H_
N#define ADC14_H_
N
N//*****************************************************************************
N//
N//!
N//! \addtogroup adc14_api
N//! @{
N//
N//*****************************************************************************
N
N//*****************************************************************************
N//
N// If building with a C++ compiler, make all of the definitions in this header
N// have a C binding.
N//
N//*****************************************************************************
N#ifdef __cplusplus
Nextern "C"
N{
N#endif
N
N#include <stdint.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/stdint.h" 1
N/* -*- C++ -*- */
N/*===--------------------------- complex.h --------------------------------===*/
N/*                                                                            */
N/*                     The LLVM Compiler Infrastructure                       */
N/*                                                                            */
N/* This file is dual licensed under the MIT and the University of Illinois Open
N** Source Licenses. See LICENSE.TXT for details.
N*/
N/*===----------------------------------------------------------------------===*/
N
N#ifndef _LIBCPP_STDINT_H
N#define _LIBCPP_STDINT_H
N
N/*
N    stdint.h synopsis
N
NMacros:
N
N    INT8_MIN
N    INT16_MIN
N    INT32_MIN
N    INT64_MIN
N
N    INT8_MAX
N    INT16_MAX
N    INT32_MAX
N    INT64_MAX
N
N    UINT8_MAX
N    UINT16_MAX
N    UINT32_MAX
N    UINT64_MAX
N
N    INT_LEAST8_MIN
N    INT_LEAST16_MIN
N    INT_LEAST32_MIN
N    INT_LEAST64_MIN
N
N    INT_LEAST8_MAX
N    INT_LEAST16_MAX
N    INT_LEAST32_MAX
N    INT_LEAST64_MAX
N
N    UINT_LEAST8_MAX
N    UINT_LEAST16_MAX
N    UINT_LEAST32_MAX
N    UINT_LEAST64_MAX
N
N    INT_FAST8_MIN
N    INT_FAST16_MIN
N    INT_FAST32_MIN
N    INT_FAST64_MIN
N
N    INT_FAST8_MAX
N    INT_FAST16_MAX
N    INT_FAST32_MAX
N    INT_FAST64_MAX
N
N    UINT_FAST8_MAX
N    UINT_FAST16_MAX
N    UINT_FAST32_MAX
N    UINT_FAST64_MAX
N
N    INTPTR_MIN
N    INTPTR_MAX
N    UINTPTR_MAX
N
N    INTMAX_MIN
N    INTMAX_MAX
N
N    UINTMAX_MAX
N
N    PTRDIFF_MIN
N    PTRDIFF_MAX
N
N    SIG_ATOMIC_MIN
N    SIG_ATOMIC_MAX
N
N    SIZE_MAX
N
N    WCHAR_MIN
N    WCHAR_MAX
N
N    WINT_MIN
N    WINT_MAX
N
N    INT8_C(value)
N    INT16_C(value)
N    INT32_C(value)
N    INT64_C(value)
N
N    UINT8_C(value)
N    UINT16_C(value)
N    UINT32_C(value)
N    UINT64_C(value)
N
N    INTMAX_C(value)
N    UINTMAX_C(value)
N
N*/
N
N#include <__config>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/__config" 1
N/* -*- C++ -*- */
N/*===--------------------------- complex.h --------------------------------===*/
N/*                                                                            */
N/*                     The LLVM Compiler Infrastructure                       */
N/*                                                                            */
N/* This file is dual licensed under the MIT and the University of Illinois Open
N** Source Licenses. See LICENSE.TXT for details.
N*/
N/*===----------------------------------------------------------------------===*/
N
N#ifndef _LIBCPP_CONFIG
N#define _LIBCPP_CONFIG
N
N#pragma diag_push
N/* Avoid warning on C++ comments in this file */
N#pragma diag_suppress 2581
N#pragma CHECK_MISRA("-2.2")
N#pragma CHECK_MISRA("-19.4")
N#pragma CHECK_MISRA("-19.10")
N
N// The libc++ cmake build system expects to preinclude __config site during
N// library builds (_LIBCPP_BUILDING_LIBRARY defined). Then, as part of
N// installation, will prepend the contents of __config_site to __config and
N// install the result as __config. __config_site does not exist as part of the
N// cmake installation.
N//
N// The TI mkrts system follows the same behavior while bulding the library.
N// However, it does not support prepending as part of installation, and so must
N// have __config_site exist separately as a pre-generated file.
N//
N// To ensure that the cmake system still works, we only include __config_site
N// when it exists as part of an installation. That is: If a TI compiler is
N// being used, the library has been built/installed, and __config_site exists.
N#if defined(__TI_COMPILER_VERSION__) && !defined(_LIBCPP_BUILDING_LIBRARY) && \
N    __has_include("__config_site")
X#if 1L && !0L &&     1
N#include "__config_site"
L 1 "C:\ti\ccs930\ccs\tools\compiler\ti-cgt-arm_18.12.5.LTS\include\libcxx\__config_site" 1
N//===----------------------------------------------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is dual licensed under the MIT and the University of Illinois Open
N// Source Licenses. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP_CONFIG_SITE
N#define _LIBCPP_CONFIG_SITE
N
N#define _LIBCPP_ABI_VERSION 2
N/* #undef _LIBCPP_ABI_UNSTABLE */
N/* #undef _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE */
N/* #undef _LIBCPP_HAS_NO_STDIN */
N/* #undef _LIBCPP_HAS_NO_STDOUT */
N#define _LIBCPP_HAS_NO_THREADS
N/* #undef _LIBCPP_HAS_NO_MONOTONIC_CLOCK */
N/* #undef _LIBCPP_HAS_NO_THREAD_UNSAFE_C_FUNCTIONS */
N/* #undef _LIBCPP_HAS_MUSL_LIBC */
N/* #undef _LIBCPP_HAS_THREAD_API_PTHREAD */
N/* #undef _LIBCPP_HAS_THREAD_API_EXTERNAL */
N/* #undef _LIBCPP_HAS_THREAD_LIBRARY_EXTERNAL */
N#define _LIBCPP_DISABLE_VISIBILITY_ANNOTATIONS
N
N#include "__libcxx_extra.h"
L 1 "C:\ti\ccs930\ccs\tools\compiler\ti-cgt-arm_18.12.5.LTS\include\libcxx\__libcxx_extra.h" 1
N/*****************************************************************************/
N/* LIBCXX_EXTRA.H                                                            */
N/*                                                                           */
N/* Copyright (c) 2017 Texas Instruments Incorporated                         */
N/* http://www.ti.com/                                                        */
N/*                                                                           */
N/*  Redistribution and  use in source  and binary forms, with  or without    */
N/*  modification,  are permitted provided  that the  following conditions    */
N/*  are met:                                                                 */
N/*                                                                           */
N/*     Redistributions  of source  code must  retain the  above copyright    */
N/*     notice, this list of conditions and the following disclaimer.         */
N/*                                                                           */
N/*     Redistributions in binary form  must reproduce the above copyright    */
N/*     notice, this  list of conditions  and the following  disclaimer in    */
N/*     the  documentation  and/or   other  materials  provided  with  the    */
N/*     distribution.                                                         */
N/*                                                                           */
N/*     Neither the  name of Texas Instruments Incorporated  nor the names    */
N/*     of its  contributors may  be used to  endorse or  promote products    */
N/*     derived  from   this  software  without   specific  prior  written    */
N/*     permission.                                                           */
N/*                                                                           */
N/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS    */
N/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT    */
N/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    */
N/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT    */
N/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    */
N/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT    */
N/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    */
N/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    */
N/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT    */
N/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    */
N/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     */
N/*                                                                           */
N/*****************************************************************************/
N#ifndef __LIBCXX_EXTRA_H__
N#define __LIBCXX_EXTRA_H__
N
N/*
NChanges made to this file affect how TI libc++ is BOTH built and used in
Nproduction environments.
N*/
N
N/*
NThe TI RTS has all source and header files flattened into a single directory.
N*/
N#define _LIBCPP_SOURCE_IS_FLATTENED
N
N/* #pragma diag_suppress 1585,2866 */
N
N#endif /* __LIBCXX_EXTRA_H__ */
L 28 "C:\ti\ccs930\ccs\tools\compiler\ti-cgt-arm_18.12.5.LTS\include\libcxx\__config_site" 2
N
N#endif // _LIBCPP_CONFIG_SITE
L 37 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/__config" 2
N#endif
N
N#if defined(_MSC_VER) && !defined(__clang__)
X#if 0L && !0L
S#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
S#define _LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER
S#endif
N#endif
N
N#ifndef _LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER
N#pragma GCC system_header
N#endif
N
N#ifdef __cplusplus
N
N#ifdef __GNUC__
S#define _GNUC_VER (__GNUC__ * 100 + __GNUC_MINOR__)
S// The _GNUC_VER_NEW macro better represents the new GCC versioning scheme
S// introduced in GCC 5.0.
S#define _GNUC_VER_NEW (_GNUC_VER * 10 + __GNUC_PATCHLEVEL__)
N#else
N#define _GNUC_VER 0
N#define _GNUC_VER_NEW 0
N#endif
N
N#define _LIBCPP_VERSION 6000
N
N#ifndef _LIBCPP_ABI_VERSION
S#define _LIBCPP_ABI_VERSION 1
N#endif
N
N#if defined(__ELF__)
X#if 1L
N#define _LIBCPP_OBJECT_FORMAT_ELF   1
N#elif defined(__MACH__)
S#define _LIBCPP_OBJECT_FORMAT_MACHO 1
S#elif defined(_WIN32)
S#define _LIBCPP_OBJECT_FORMAT_COFF  1
S#else
S#error Unknown object file format
N#endif
N
N#if defined(_LIBCPP_ABI_UNSTABLE) || _LIBCPP_ABI_VERSION >= 2
X#if 0L || 2 >= 2
N// Change short string representation so that string data starts at offset 0,
N// improving its alignment in some cases.
N#define _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT
N// Fix deque iterator type in order to support incomplete types.
N#define _LIBCPP_ABI_INCOMPLETE_TYPES_IN_DEQUE
N// Fix undefined behavior in how std::list stores its linked nodes.
N#define _LIBCPP_ABI_LIST_REMOVE_NODE_POINTER_UB
N// Fix undefined behavior in  how __tree stores its end and parent nodes.
N#define _LIBCPP_ABI_TREE_REMOVE_NODE_POINTER_UB
N// Fix undefined behavior in how __hash_table stores its pointer types.
N#define _LIBCPP_ABI_FIX_UNORDERED_NODE_POINTER_UB
N#define _LIBCPP_ABI_FORWARD_LIST_REMOVE_NODE_POINTER_UB
N#define _LIBCPP_ABI_FIX_UNORDERED_CONTAINER_SIZE_TYPE
N// Don't use a nullptr_t simulation type in C++03 instead using C++11 nullptr
N// provided under the alternate keyword __nullptr, which changes the mangling
N// of nullptr_t. This option is ABI incompatible with GCC in C++03 mode.
N#define _LIBCPP_ABI_ALWAYS_USE_CXX11_NULLPTR
N// Define the `pointer_safety` enum as a C++11 strongly typed enumeration
N// instead of as a class simulating an enum. If this option is enabled
N// `pointer_safety` and `get_pointer_safety()` will no longer be available
N// in C++03.
N#define _LIBCPP_ABI_POINTER_SAFETY_ENUM_TYPE
N// Define a key function for `bad_function_call` in the library, to centralize
N// its vtable and typeinfo to libc++ rather than having all other libraries
N// using that class define their own copies.
N#define _LIBCPP_ABI_BAD_FUNCTION_CALL_KEY_FUNCTION
N
N// Enable optimized version of __do_get_(un)signed which avoids redundant copies.
N#define _LIBCPP_ABI_OPTIMIZED_LOCALE_NUM_GET
N#elif _LIBCPP_ABI_VERSION == 1
S#if !defined(_LIBCPP_OBJECT_FORMAT_COFF)
S// Enable compiling copies of now inline methods into the dylib to support
S// applications compiled against older libraries. This is unnecessary with
S// COFF dllexport semantics, since dllexport forces a non-inline definition
S// of inline functions to be emitted anyway. Our own non-inline copy would
S// conflict with the dllexport-emitted copy, so we disable it.
S#define _LIBCPP_DEPRECATED_ABI_LEGACY_LIBRARY_DEFINITIONS_FOR_INLINE_FUNCTIONS
S#endif
S// Feature macros for disabling pre ABI v1 features. All of these options
S// are deprecated.
S#if defined(__FreeBSD__)
S#define _LIBCPP_DEPRECATED_ABI_DISABLE_PAIR_TRIVIAL_COPY_CTOR
S#endif
N#endif
N
N#ifdef _LIBCPP_TRIVIAL_PAIR_COPY_CTOR
S#error "_LIBCPP_TRIVIAL_PAIR_COPY_CTOR" is no longer supported. \
S       use _LIBCPP_DEPRECATED_ABI_DISABLE_PAIR_TRIVIAL_COPY_CTOR instead
X#error "_LIBCPP_TRIVIAL_PAIR_COPY_CTOR" is no longer supported.        use _LIBCPP_DEPRECATED_ABI_DISABLE_PAIR_TRIVIAL_COPY_CTOR instead
N#endif
N
N#define _LIBCPP_CONCAT1(_LIBCPP_X,_LIBCPP_Y) _LIBCPP_X##_LIBCPP_Y
N#define _LIBCPP_CONCAT(_LIBCPP_X,_LIBCPP_Y) _LIBCPP_CONCAT1(_LIBCPP_X,_LIBCPP_Y)
N
N#define _LIBCPP_NAMESPACE _LIBCPP_CONCAT(__,_LIBCPP_ABI_VERSION)
N
N#if __cplusplus < 201103L
X#if 201402L < 201103L
S#define _LIBCPP_CXX03_LANG
N#endif
N
N#ifndef __has_attribute
S#define __has_attribute(__x) 0
N#endif
N#ifndef __has_builtin
S#define __has_builtin(__x) 0
N#endif
N#ifndef __has_extension
S#define __has_extension(__x) 0
N#endif
N#ifndef __has_feature
S#define __has_feature(__x) 0
N#endif
N// '__is_identifier' returns '0' if '__x' is a reserved identifier provided by
N// the compiler and '1' otherwise.
N#ifndef __is_identifier
N#define __is_identifier(__x) 1
N#endif
N#ifndef __has_declspec_attribute
N#define __has_declspec_attribute(__x) 0
N#endif
N
N#define __has_keyword(__x) !(__is_identifier(__x))
N
N#ifdef __has_include
N#define __libcpp_has_include(__x) __has_include(__x)
N#else
S#define __libcpp_has_include(__x) 0
N#endif
N
N#if defined(__clang__)
X#if 0L
S#define _LIBCPP_COMPILER_CLANG
S# ifndef __apple_build_version__
S#   define _LIBCPP_CLANG_VER (__clang_major__ * 100 + __clang_minor__)
S# endif
S#elif defined(__GNUC__)
X#elif 0L
S#define _LIBCPP_COMPILER_GCC
S#elif defined(_MSC_VER)
X#elif 0L
S#define _LIBCPP_COMPILER_MSVC
S#elif defined(__IBMCPP__)
X#elif 0L
S#define _LIBCPP_COMPILER_IBM
N#elif defined(__TI_COMPILER_VERSION__)
X#elif 1L
N#define _LIBCPP_COMPILER_TI
N#endif
N
N#ifndef _LIBCPP_CLANG_VER
N#define _LIBCPP_CLANG_VER 0
N#endif
N
N// FIXME: ABI detection should be done via compiler builtin macros. This
N// is just a placeholder until Clang implements such macros. For now assume
N// that Windows compilers pretending to be MSVC++ target the Microsoft ABI,
N// and allow the user to explicitly specify the ABI to handle cases where this
N// heuristic falls short.
N#if defined(_LIBCPP_ABI_FORCE_ITANIUM) && defined(_LIBCPP_ABI_FORCE_MICROSOFT)
X#if 0L && 0L
S# error "Only one of _LIBCPP_ABI_FORCE_ITANIUM and _LIBCPP_ABI_FORCE_MICROSOFT can be defined"
S#elif defined(_LIBCPP_ABI_FORCE_ITANIUM)
X#elif 0L
S# define _LIBCPP_ABI_ITANIUM
S#elif defined(_LIBCPP_ABI_FORCE_MICROSOFT)
X#elif 0L
S# define _LIBCPP_ABI_MICROSOFT
N#else
N# if defined(_WIN32) && defined(_MSC_VER)
X# if 0L && 0L
S#  define _LIBCPP_ABI_MICROSOFT
N# else
N#  define _LIBCPP_ABI_ITANIUM
N# endif
N#endif
N
N// Need to detect which libc we're using if we're on Linux.
N#if defined(__linux__)
X#if 0L
S#include <features.h>
S#if !defined(__GLIBC_PREREQ)
S#define __GLIBC_PREREQ(a, b) 0
S#endif // !defined(__GLIBC_PREREQ)
N#endif // defined(__linux__)
N
N#ifdef __LITTLE_ENDIAN__
N#if __LITTLE_ENDIAN__
X#if 1
N#define _LIBCPP_LITTLE_ENDIAN
N#endif  // __LITTLE_ENDIAN__
N#endif  // __LITTLE_ENDIAN__
N
N#ifdef __BIG_ENDIAN__
S#if __BIG_ENDIAN__
S#define _LIBCPP_BIG_ENDIAN
S#endif  // __BIG_ENDIAN__
N#endif  // __BIG_ENDIAN__
N
N#ifdef __BYTE_ORDER__
S#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
S#define _LIBCPP_LITTLE_ENDIAN
S#elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
S#define _LIBCPP_BIG_ENDIAN
S#endif // __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
N#endif // __BYTE_ORDER__
N
N#ifdef __FreeBSD__
S# include <sys/endian.h>
S#  if _BYTE_ORDER == _LITTLE_ENDIAN
S#   define _LIBCPP_LITTLE_ENDIAN
S# else  // _BYTE_ORDER == _LITTLE_ENDIAN
S#   define _LIBCPP_BIG_ENDIAN
S# endif  // _BYTE_ORDER == _LITTLE_ENDIAN
S# ifndef __LONG_LONG_SUPPORTED
S#  define _LIBCPP_HAS_NO_LONG_LONG
S# endif  // __LONG_LONG_SUPPORTED
N#endif  // __FreeBSD__
N
N#ifdef __NetBSD__
S# include <sys/endian.h>
S#  if _BYTE_ORDER == _LITTLE_ENDIAN
S#   define _LIBCPP_LITTLE_ENDIAN
S# else  // _BYTE_ORDER == _LITTLE_ENDIAN
S#   define _LIBCPP_BIG_ENDIAN
S# endif  // _BYTE_ORDER == _LITTLE_ENDIAN
S# define _LIBCPP_HAS_QUICK_EXIT
N#endif  // __NetBSD__
N
N#if defined(_WIN32)
X#if 0L
S#  define _LIBCPP_WIN32API
S#  define _LIBCPP_LITTLE_ENDIAN
S#  define _LIBCPP_SHORT_WCHAR   1
S// Both MinGW and native MSVC provide a "MSVC"-like enviroment
S#  define _LIBCPP_MSVCRT_LIKE
S// If mingw not explicitly detected, assume using MS C runtime only if
S// a MS compatibility version is specified.
S#  if defined(_MSC_VER) && !defined(__MINGW32__)
S#    define _LIBCPP_MSVCRT // Using Microsoft's C Runtime library
S#  endif
S#  if (defined(_M_AMD64) || defined(__x86_64__)) || (defined(_M_ARM) || defined(__arm__))
S#    define _LIBCPP_HAS_BITSCAN64
S#  endif
S# if defined(_LIBCPP_MSVCRT)
S#   define _LIBCPP_HAS_QUICK_EXIT
S# endif
S
S// Some CRT APIs are unavailable to store apps
S#if defined(WINAPI_FAMILY)
S#include <winapifamily.h>
S#if !WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) &&                      \
S    (!defined(WINAPI_PARTITION_SYSTEM) ||                                      \
S     !WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_SYSTEM))
X#if !WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) &&                          (!defined(WINAPI_PARTITION_SYSTEM) ||                                           !WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_SYSTEM))
S#define _LIBCPP_WINDOWS_STORE_APP
S#endif
S#endif
N#endif // defined(_WIN32)
N
N#ifdef __sun__
S# include <sys/isa_defs.h>
S# ifdef _LITTLE_ENDIAN
S#   define _LIBCPP_LITTLE_ENDIAN
S# else
S#   define _LIBCPP_BIG_ENDIAN
S# endif
N#endif // __sun__
N
N#if defined(__CloudABI__)
X#if 0L
S  // Certain architectures provide arc4random(). Prefer using
S  // arc4random() over /dev/{u,}random to make it possible to obtain
S  // random data even when using sandboxing mechanisms such as chroots,
S  // Capsicum, etc.
S# define _LIBCPP_USING_ARC4_RANDOM
S#elif defined(__native_client__)
X#elif 0L
S  // NaCl's sandbox (which PNaCl also runs in) doesn't allow filesystem access,
S  // including accesses to the special files under /dev. C++11's
S  // std::random_device is instead exposed through a NaCl syscall.
S# define _LIBCPP_USING_NACL_RANDOM
S#elif defined(_LIBCPP_WIN32API)
X#elif 0L
S# define _LIBCPP_USING_WIN32_RANDOM
N#elif defined(_LIBCPP_COMPILER_TI)
X#elif 1L
N# define _LIBCPP_USING_MERSENNE_RANDOM
N#else
S# define _LIBCPP_USING_DEV_RANDOM
N#endif
N
N#if !defined(_LIBCPP_LITTLE_ENDIAN) && !defined(_LIBCPP_BIG_ENDIAN)
X#if !1L && !0L
S# include <endian.h>
S# if __BYTE_ORDER == __LITTLE_ENDIAN
S#  define _LIBCPP_LITTLE_ENDIAN
S# elif __BYTE_ORDER == __BIG_ENDIAN
S#  define _LIBCPP_BIG_ENDIAN
S# else  // __BYTE_ORDER == __BIG_ENDIAN
S#  error unable to determine endian
S# endif
N#endif  // !defined(_LIBCPP_LITTLE_ENDIAN) && !defined(_LIBCPP_BIG_ENDIAN)
N
N#if __has_attribute(__no_sanitize__) && !defined(_LIBCPP_COMPILER_GCC)
X#if 0 && !0L
S#define _LIBCPP_NO_CFI __attribute__((__no_sanitize__("cfi")))
N#else
N#define _LIBCPP_NO_CFI
N#endif
N
N#if defined(_LIBCPP_COMPILER_CLANG)
X#if 0L
S
S// _LIBCPP_ALTERNATE_STRING_LAYOUT is an old name for
S// _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT left here for backward compatibility.
S#if (defined(__APPLE__) && !defined(__i386__) && !defined(__x86_64__) &&       \
S     (!defined(__arm__) || __ARM_ARCH_7K__ >= 2)) ||                           \
S    defined(_LIBCPP_ALTERNATE_STRING_LAYOUT)
X#if (defined(__APPLE__) && !defined(__i386__) && !defined(__x86_64__) &&            (!defined(__arm__) || __ARM_ARCH_7K__ >= 2)) ||                               defined(_LIBCPP_ALTERNATE_STRING_LAYOUT)
S#define _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT
S#endif
S
S#if __has_feature(cxx_alignas)
S#  define _ALIGNAS_TYPE(x) alignas(x)
S#  define _ALIGNAS(x) alignas(x)
S#else
S#  define _ALIGNAS_TYPE(x) __attribute__((__aligned__(__alignof(x))))
S#  define _ALIGNAS(x) __attribute__((__aligned__(x)))
S#endif
S
S#if __cplusplus < 201103L
Stypedef __char16_t char16_t;
Stypedef __char32_t char32_t;
S#endif
S
S#if !(__has_feature(cxx_exceptions)) && !defined(_LIBCPP_NO_EXCEPTIONS)
S#define _LIBCPP_NO_EXCEPTIONS
S#endif
S
S#if !(__has_feature(cxx_rtti)) && !defined(_LIBCPP_NO_RTTI)
S#define _LIBCPP_NO_RTTI
S#endif
S
S#if !(__has_feature(cxx_strong_enums))
S#define _LIBCPP_HAS_NO_STRONG_ENUMS
S#endif
S
S#if !(__has_feature(cxx_decltype))
S#define _LIBCPP_HAS_NO_DECLTYPE
S#endif
S
S#if __has_feature(cxx_attributes)
S#  define _LIBCPP_NORETURN [[noreturn]]
S#else
S#  define _LIBCPP_NORETURN __attribute__ ((noreturn))
S#endif
S
S#if !(__has_feature(cxx_lambdas))
S#define _LIBCPP_HAS_NO_LAMBDAS
S#endif
S
S#if !(__has_feature(cxx_nullptr))
S# if (__has_extension(cxx_nullptr) || __has_keyword(__nullptr)) && defined(_LIBCPP_ABI_ALWAYS_USE_CXX11_NULLPTR)
S#   define nullptr __nullptr
S# else
S#   define _LIBCPP_HAS_NO_NULLPTR
S# endif
S#endif
S
S#if !(__has_feature(cxx_rvalue_references))
S#define _LIBCPP_HAS_NO_RVALUE_REFERENCES
S#endif
S
S#if !(__has_feature(cxx_auto_type))
S#define _LIBCPP_HAS_NO_AUTO_TYPE
S#endif
S
S#if !(__has_feature(cxx_variadic_templates))
S#define _LIBCPP_HAS_NO_VARIADICS
S#endif
S
S#if !(__has_feature(cxx_generalized_initializers))
S#define _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS
S#endif
S
S#if __has_feature(is_base_of)
S#  define _LIBCPP_HAS_IS_BASE_OF
S#endif
S
S#if __has_feature(is_final)
S#  define _LIBCPP_HAS_IS_FINAL
S#endif
S
S// Objective-C++ features (opt-in)
S#if __has_feature(objc_arc)
S#define _LIBCPP_HAS_OBJC_ARC
S#endif
S
S#if __has_feature(objc_arc_weak)
S#define _LIBCPP_HAS_OBJC_ARC_WEAK
S#endif
S
S#if !(__has_feature(cxx_constexpr))
S#define _LIBCPP_HAS_NO_CONSTEXPR
S#endif
S
S#if !(__has_feature(cxx_relaxed_constexpr))
S#define _LIBCPP_HAS_NO_CXX14_CONSTEXPR
S#endif
S
S#if !(__has_feature(cxx_variable_templates))
S#define _LIBCPP_HAS_NO_VARIABLE_TEMPLATES
S#endif
S
S#if __ISO_C_VISIBLE >= 2011 || __cplusplus >= 201103L
S#if defined(__FreeBSD__)
S#define _LIBCPP_HAS_QUICK_EXIT
S#define _LIBCPP_HAS_C11_FEATURES
S#elif defined(__Fuchsia__)
S#define _LIBCPP_HAS_QUICK_EXIT
S#define _LIBCPP_HAS_C11_FEATURES
S#elif defined(__linux__)
S#if !defined(_LIBCPP_HAS_MUSL_LIBC)
S#if __GLIBC_PREREQ(2, 15) || defined(__BIONIC__)
S#define _LIBCPP_HAS_QUICK_EXIT
S#endif
S#if __GLIBC_PREREQ(2, 17)
S#define _LIBCPP_HAS_C11_FEATURES
S#endif
S#else // defined(_LIBCPP_HAS_MUSL_LIBC)
S#define _LIBCPP_HAS_QUICK_EXIT
S#define _LIBCPP_HAS_C11_FEATURES
S#endif
S#endif // __linux__
S#endif
S
S#if !(__has_feature(cxx_noexcept))
S#define _LIBCPP_HAS_NO_NOEXCEPT
S#endif
S
S#if __has_feature(underlying_type)
S#  define _LIBCPP_UNDERLYING_TYPE(T) __underlying_type(T)
S#endif
S
S#if __has_feature(is_literal)
S#  define _LIBCPP_IS_LITERAL(T) __is_literal(T)
S#endif
S
S// Inline namespaces are available in Clang regardless of C++ dialect.
S#define _LIBCPP_BEGIN_NAMESPACE_STD namespace std {inline namespace _LIBCPP_NAMESPACE {
S#define _LIBCPP_END_NAMESPACE_STD  } }
S#define _VSTD std::_LIBCPP_NAMESPACE
S
Snamespace std {
S  inline namespace _LIBCPP_NAMESPACE {
S  }
S}
S
S#if !defined(_LIBCPP_HAS_NO_ASAN) && !__has_feature(address_sanitizer)
S#define _LIBCPP_HAS_NO_ASAN
S#endif
S
S// Allow for build-time disabling of unsigned integer sanitization
S#if !defined(_LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK) && __has_attribute(no_sanitize)
S#define _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK __attribute__((__no_sanitize__("unsigned-integer-overflow")))
S#endif 
S
S#elif defined(_LIBCPP_COMPILER_GCC)
X#elif 0L
S
S#define _ALIGNAS(x) __attribute__((__aligned__(x)))
S#define _ALIGNAS_TYPE(x) __attribute__((__aligned__(__alignof(x))))
S
S#define _LIBCPP_NORETURN __attribute__((noreturn))
S
S#if _GNUC_VER >= 407
S#define _LIBCPP_UNDERLYING_TYPE(T) __underlying_type(T)
S#define _LIBCPP_IS_LITERAL(T) __is_literal_type(T)
S#define _LIBCPP_HAS_IS_FINAL
S#endif
S
S#if defined(__GNUC__) && _GNUC_VER >= 403
S#  define _LIBCPP_HAS_IS_BASE_OF
S#endif
S
S#if !__EXCEPTIONS
S#define _LIBCPP_NO_EXCEPTIONS
S#endif
S
S// constexpr was added to GCC in 4.6.
S#if _GNUC_VER < 406
S#define _LIBCPP_HAS_NO_CONSTEXPR
S// Can only use constexpr in c++11 mode.
S#elif !defined(__GXX_EXPERIMENTAL_CXX0X__) && __cplusplus < 201103L
S#define _LIBCPP_HAS_NO_CONSTEXPR
S#endif
S
S// Determine if GCC supports relaxed constexpr
S#if !defined(__cpp_constexpr) || __cpp_constexpr < 201304L
S#define _LIBCPP_HAS_NO_CXX14_CONSTEXPR
S#endif
S
S// GCC 5 will support variable templates
S#if !defined(__cpp_variable_templates) || __cpp_variable_templates < 201304L
S#define _LIBCPP_HAS_NO_VARIABLE_TEMPLATES
S#endif
S
S#ifndef __GXX_EXPERIMENTAL_CXX0X__
S#define _LIBCPP_HAS_NO_DECLTYPE
S#define _LIBCPP_HAS_NO_NULLPTR
S#define _LIBCPP_HAS_NO_UNICODE_CHARS
S#define _LIBCPP_HAS_NO_VARIADICS
S#define _LIBCPP_HAS_NO_RVALUE_REFERENCES
S#define _LIBCPP_HAS_NO_STRONG_ENUMS
S#define _LIBCPP_HAS_NO_NOEXCEPT
S
S#else  // __GXX_EXPERIMENTAL_CXX0X__
S
S#if _GNUC_VER < 403
S#define _LIBCPP_HAS_NO_RVALUE_REFERENCES
S#endif
S
S
S#if _GNUC_VER < 404
S#define _LIBCPP_HAS_NO_DECLTYPE
S#define _LIBCPP_HAS_NO_UNICODE_CHARS
S#define _LIBCPP_HAS_NO_VARIADICS
S#define _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS
S#endif  // _GNUC_VER < 404
S
S#if _GNUC_VER < 406
S#define _LIBCPP_HAS_NO_NOEXCEPT
S#define _LIBCPP_HAS_NO_NULLPTR
S#endif
S
S#endif  // __GXX_EXPERIMENTAL_CXX0X__
S
S#define _LIBCPP_BEGIN_NAMESPACE_STD namespace std { inline namespace _LIBCPP_NAMESPACE {
S#define _LIBCPP_END_NAMESPACE_STD  } }
S#define _VSTD std::_LIBCPP_NAMESPACE
S
Snamespace std {
S  inline namespace _LIBCPP_NAMESPACE {
S  }
S}
S
S#if !defined(_LIBCPP_HAS_NO_ASAN) && !defined(__SANITIZE_ADDRESS__)
S#define _LIBCPP_HAS_NO_ASAN
S#endif
S
S#elif defined(_LIBCPP_COMPILER_MSVC)
X#elif 0L
S
S#define _LIBCPP_TOSTRING2(x) #x
S#define _LIBCPP_TOSTRING(x) _LIBCPP_TOSTRING2(x)
S#define _LIBCPP_WARNING(x) __pragma(message(__FILE__ "(" _LIBCPP_TOSTRING(__LINE__) ") : warning note: " x))
S
S#if _MSC_VER < 1900
S#error "MSVC versions prior to Visual Studio 2015 are not supported"
S#endif
S
S#define _LIBCPP_HAS_IS_BASE_OF
S#define _LIBCPP_HAS_NO_CONSTEXPR
S#define _LIBCPP_HAS_NO_CXX14_CONSTEXPR
S#define _LIBCPP_HAS_NO_VARIABLE_TEMPLATES
S#if _MSC_VER <= 1800
S#define _LIBCPP_HAS_NO_UNICODE_CHARS
S#endif
S#define _LIBCPP_HAS_NO_NOEXCEPT
S#define __alignof__ __alignof
S#define _LIBCPP_NORETURN __declspec(noreturn)
S#define _ALIGNAS(x) __declspec(align(x))
S#define _LIBCPP_HAS_NO_VARIADICS
S
S#define _LIBCPP_BEGIN_NAMESPACE_STD namespace std {
S#define _LIBCPP_END_NAMESPACE_STD  }
S#define _VSTD std
S
S#  define _LIBCPP_WEAK
Snamespace std {
S}
S
S#define _LIBCPP_HAS_NO_ASAN
S
S#elif defined(_LIBCPP_COMPILER_IBM)
X#elif 0L
S
S#define _ALIGNAS(x) __attribute__((__aligned__(x)))
S#define _ALIGNAS_TYPE(x) __attribute__((__aligned__(__alignof(x))))
S#define _ATTRIBUTE(x) __attribute__((x))
S#define _LIBCPP_NORETURN __attribute__((noreturn))
S
S#define _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS
S#define _LIBCPP_HAS_NO_NOEXCEPT
S#define _LIBCPP_HAS_NO_NULLPTR
S#define _LIBCPP_HAS_NO_UNICODE_CHARS
S#define _LIBCPP_HAS_IS_BASE_OF
S#define _LIBCPP_HAS_IS_FINAL
S#define _LIBCPP_HAS_NO_VARIABLE_TEMPLATES
S
S#if defined(_AIX)
S#define __MULTILOCALE_API
S#endif
S
S#define _LIBCPP_BEGIN_NAMESPACE_STD namespace std {inline namespace _LIBCPP_NAMESPACE {
S#define _LIBCPP_END_NAMESPACE_STD  } }
S#define _VSTD std::_LIBCPP_NAMESPACE
S
Snamespace std {
S  inline namespace _LIBCPP_NAMESPACE {
S  }
S}
S
S#define _LIBCPP_HAS_NO_ASAN
S
N#elif defined(_LIBCPP_COMPILER_TI)
X#elif 1L
N
N// Add a defined(__TARGET__) in the following check for each TARGET
N// that supports LIBCPP atomics
N#if defined(__TMS470__) || defined(__MSP430__)
X#if 1L || 0L
N#define _LIBCPP_TI_HAS_ATOMIC_HEADER
N#endif
N
N// __builtin_strlen can be trivially replaced, but with a hefty runtime cost
N#define __builtin_strlen strlen
N
N// TI targets do not support aligned operator new()
N#define _LIBCPP_HAS_NO_ALIGNED_ALLOCATION
N
N// Currently a dummy value. std::strerror will return "Unknown" for errors that
N// are out of the range of those we can print.
N#define ELAST 4095
N
N#if __has_feature(cxx_alignas)
X#if 1
N#  define _ALIGNAS_TYPE(x) alignas(x)
N#  define _ALIGNAS(x) alignas(x)
N#else
S#  define _ALIGNAS_TYPE(x) __attribute__((__aligned__(__alignof(x))))
S#  define _ALIGNAS(x) __attribute__((__aligned__(x)))
N#endif
N
N#if !(__has_feature(cxx_exceptions)) && !defined(_LIBCPP_NO_EXCEPTIONS)
X#if !(0) && !0L
N#define _LIBCPP_NO_EXCEPTIONS
N#endif
N
N#if !(__has_feature(cxx_rtti)) && !defined(_LIBCPP_NO_RTTI)
X#if !(1) && !0L
S#define _LIBCPP_NO_RTTI
N#endif
N
N#if !(__has_feature(cxx_strong_enums))
X#if !(1)
S#define _LIBCPP_HAS_NO_STRONG_ENUMS
N#endif
N
N#if !(__has_feature(cxx_decltype))
X#if !(1)
S#define _LIBCPP_HAS_NO_DECLTYPE
N#endif
N
N#if __has_feature(cxx_attributes)
X#if 1
N#  define _LIBCPP_NORETURN [[noreturn]]
N#else
S#  define _LIBCPP_NORETURN __attribute__ ((noreturn))
N#endif
N
N#if !(__has_feature(cxx_lambdas))
X#if !(1)
S#define _LIBCPP_HAS_NO_LAMBDAS
N#endif
N
N#if !(__has_feature(cxx_nullptr))
X#if !(1)
S# if (__has_extension(cxx_nullptr) || __has_keyword(__nullptr)) && defined(_LIBCPP_ABI_ALWAYS_USE_CXX11_NULLPTR)
S#   define nullptr __nullptr
S# else
S#   define _LIBCPP_HAS_NO_NULLPTR
S# endif
N#endif
N
N#if !(__has_feature(cxx_rvalue_references))
X#if !(1)
S#define _LIBCPP_HAS_NO_RVALUE_REFERENCES
N#endif
N
N#if !(__has_feature(cxx_auto_type))
X#if !(1)
S#define _LIBCPP_HAS_NO_AUTO_TYPE
N#endif
N
N#if !(__has_feature(cxx_variadic_templates))
X#if !(1)
S#define _LIBCPP_HAS_NO_VARIADICS
N#endif
N
N#if !(__has_feature(cxx_generalized_initializers))
X#if !(1)
S#define _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS
N#endif
N
N#if __has_feature(is_base_of)
X#if 1
N#  define _LIBCPP_HAS_IS_BASE_OF
N#endif
N
N#if __has_feature(is_final)
X#if 1
N#  define _LIBCPP_HAS_IS_FINAL
N#endif
N
N#if !(__has_feature(cxx_constexpr))
X#if !(1)
S#define _LIBCPP_HAS_NO_CONSTEXPR
N#endif
N
N#if !(__has_feature(cxx_relaxed_constexpr))
X#if !(1)
S#define _LIBCPP_HAS_NO_CXX14_CONSTEXPR
N#endif
N
N#if !(__has_feature(cxx_variable_templates))
X#if !(1)
S#define _LIBCPP_HAS_NO_VARIABLE_TEMPLATES
N#endif
N
N#if !(__has_feature(cxx_noexcept))
X#if !(1)
S#define _LIBCPP_HAS_NO_NOEXCEPT
N#endif
N
N#if __has_feature(underlying_type)
X#if 1
N#  define _LIBCPP_UNDERLYING_TYPE(T) __underlying_type(T)
N#endif
N
N#if __has_feature(is_literal)
X#if 0
S#  define _LIBCPP_IS_LITERAL(T) __is_literal(T)
N#else
N// EDG supports __is_literal_type, which is analagous to __is_literal
N#  define _LIBCPP_IS_LITERAL(T) __is_literal_type(T)
N#endif
N
N// TI compilers using libc++ always accept inline namespaces
N#define _LIBCPP_BEGIN_NAMESPACE_STD namespace std { inline namespace _LIBCPP_NAMESPACE {
N#define _LIBCPP_END_NAMESPACE_STD  } }
N#define _VSTD std::_LIBCPP_NAMESPACE
N
Nnamespace std {
N  inline namespace _LIBCPP_NAMESPACE {
X  inline namespace __2 {
N  }
N}
N
N#if !defined(_LIBCPP_HAS_NO_ASAN) && !__has_feature(address_sanitizer)
X#if !0L && !0
N#define _LIBCPP_HAS_NO_ASAN
N#endif
N
N// Allow for build-time disabling of unsigned integer sanitization
N#if !defined(_LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK) && __has_attribute(no_sanitize)
X#if !0L && 0
S#define _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK __attribute__((__no_sanitize__("unsigned-integer-overflow")))
N#endif 
N
N// The TI compiler is strict about the difference between extern "C" and
N// extern "C++" functions. One cannot be conflated with the other, even if
N// the types are otherwise the same.
N#define _LIBCPP_C_AND_CPP_FUNCS_ARE_DISTINCT
N
N#endif // _LIBCPP_COMPILER_[CLANG|GCC|MSVC|IBM|TI]
N
N#if defined(_LIBCPP_OBJECT_FORMAT_COFF)
X#if 0L
S#if defined(_LIBCPP_DISABLE_VISIBILITY_ANNOTATIONS)
S# define _LIBCPP_DLL_VIS
S# define _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS
S# define _LIBCPP_CLASS_TEMPLATE_INSTANTIATION_VIS
S# define _LIBCPP_OVERRIDABLE_FUNC_VIS
S#elif defined(_LIBCPP_BUILDING_LIBRARY)
S# define _LIBCPP_DLL_VIS __declspec(dllexport)
S# define _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS
S# define _LIBCPP_CLASS_TEMPLATE_INSTANTIATION_VIS _LIBCPP_DLL_VIS
S# define _LIBCPP_OVERRIDABLE_FUNC_VIS _LIBCPP_DLL_VIS
S#else
S# define _LIBCPP_DLL_VIS __declspec(dllimport)
S# define _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS _LIBCPP_DLL_VIS
S# define _LIBCPP_CLASS_TEMPLATE_INSTANTIATION_VIS
S# define _LIBCPP_OVERRIDABLE_FUNC_VIS
S#endif
S
S#define _LIBCPP_TYPE_VIS            _LIBCPP_DLL_VIS
S#define _LIBCPP_FUNC_VIS            _LIBCPP_DLL_VIS
S#define _LIBCPP_EXTERN_VIS          _LIBCPP_DLL_VIS
S#define _LIBCPP_EXCEPTION_ABI       _LIBCPP_DLL_VIS
S#define _LIBCPP_HIDDEN
S#define _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
S#define _LIBCPP_TEMPLATE_VIS
S#define _LIBCPP_ENUM_VIS
S
S#if defined(_LIBCPP_COMPILER_MSVC)
S# define _LIBCPP_INLINE_VISIBILITY __forceinline
S# define _LIBCPP_ALWAYS_INLINE     __forceinline
S# define _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY __forceinline
S#else
S# define _LIBCPP_INLINE_VISIBILITY __attribute__ ((__always_inline__))
S# define _LIBCPP_ALWAYS_INLINE     __attribute__ ((__always_inline__))
S# define _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY __attribute__ ((__always_inline__))
S#endif
N#endif // defined(_LIBCPP_OBJECT_FORMAT_COFF)
N
N#ifndef _LIBCPP_HIDDEN
N#if !defined(_LIBCPP_DISABLE_VISIBILITY_ANNOTATIONS)
X#if !1L
S#define _LIBCPP_HIDDEN __attribute__ ((__visibility__("hidden")))
N#else
N#define _LIBCPP_HIDDEN
N#endif
N#endif
N
N#ifndef _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
N#if !defined(_LIBCPP_DISABLE_VISIBILITY_ANNOTATIONS)
X#if !1L
S// The inline should be removed once PR32114 is resolved
S#define _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS inline _LIBCPP_HIDDEN
N#else
N#define _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
N#endif
N#endif
N
N#ifndef _LIBCPP_FUNC_VIS
N#if !defined(_LIBCPP_DISABLE_VISIBILITY_ANNOTATIONS)
X#if !1L
S#define _LIBCPP_FUNC_VIS __attribute__ ((__visibility__("default")))
N#else
N#define _LIBCPP_FUNC_VIS
N#endif
N#endif
N
N#ifndef _LIBCPP_TYPE_VIS
N#  if !defined(_LIBCPP_DISABLE_VISIBILITY_ANNOTATIONS)
X#  if !1L
S#    define _LIBCPP_TYPE_VIS __attribute__ ((__visibility__("default")))
N#  else
N#    define _LIBCPP_TYPE_VIS
N#  endif
N#endif
N
N#ifndef _LIBCPP_TEMPLATE_VIS
N#  if !defined(_LIBCPP_DISABLE_VISIBILITY_ANNOTATIONS)
X#  if !1L
S#    if __has_attribute(__type_visibility__)
S#      define _LIBCPP_TEMPLATE_VIS __attribute__ ((__type_visibility__("default")))
S#    else
S#      define _LIBCPP_TEMPLATE_VIS __attribute__ ((__visibility__("default")))
S#    endif
N#  else
N#    define _LIBCPP_TEMPLATE_VIS
N#  endif
N#endif
N
N#ifndef _LIBCPP_EXTERN_VIS
N# define _LIBCPP_EXTERN_VIS
N#endif
N
N#ifndef _LIBCPP_OVERRIDABLE_FUNC_VIS
N# define _LIBCPP_OVERRIDABLE_FUNC_VIS _LIBCPP_FUNC_VIS
N#endif
N
N#ifndef _LIBCPP_EXCEPTION_ABI
N#if !defined(_LIBCPP_DISABLE_VISIBILITY_ANNOTATIONS)
X#if !1L
S#define _LIBCPP_EXCEPTION_ABI __attribute__ ((__visibility__("default")))
N#else
N#define _LIBCPP_EXCEPTION_ABI
N#endif
N#endif
N
N#ifndef _LIBCPP_ENUM_VIS
N#  if !defined(_LIBCPP_DISABLE_VISIBILITY_ANNOTATIONS) && __has_attribute(__type_visibility__)
X#  if !1L && 0
S#    define _LIBCPP_ENUM_VIS __attribute__ ((__type_visibility__("default")))
N#  else
N#    define _LIBCPP_ENUM_VIS
N#  endif
N#endif
N
N#ifndef _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS
N#  if !defined(_LIBCPP_DISABLE_VISIBILITY_ANNOTATIONS) && __has_attribute(__type_visibility__)
X#  if !1L && 0
S#    define _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __attribute__ ((__visibility__("default")))
N#  else
N#    define _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS
N#  endif
N#endif
N
N#ifndef _LIBCPP_CLASS_TEMPLATE_INSTANTIATION_VIS
N#  define _LIBCPP_CLASS_TEMPLATE_INSTANTIATION_VIS
N#endif
N
N#ifndef _LIBCPP_INLINE_VISIBILITY
N#if !defined(_LIBCPP_DISABLE_VISIBILITY_ANNOTATIONS)
X#if !1L
S#define _LIBCPP_INLINE_VISIBILITY __attribute__ ((__visibility__("hidden"), __always_inline__))
N#else
N#define _LIBCPP_INLINE_VISIBILITY __attribute__ ((__always_inline__))
N#endif
N#endif
N
N#ifndef _LIBCPP_ALWAYS_INLINE
N#if !defined(_LIBCPP_DISABLE_VISIBILITY_ANNOTATIONS)
X#if !1L
S#define _LIBCPP_ALWAYS_INLINE  __attribute__ ((__visibility__("hidden"), __always_inline__))
N#else
N#define _LIBCPP_ALWAYS_INLINE  __attribute__ ((__always_inline__))
N#endif
N#endif
N
N#ifndef _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY
N# if !defined(_LIBCPP_DISABLE_VISIBILITY_ANNOTATIONS)
X# if !1L
S#  define _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY __attribute__((__visibility__("default"), __always_inline__))
N# else
N#  define _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY __attribute__((__always_inline__))
N# endif
N#endif
N
N#ifndef _LIBCPP_PREFERRED_OVERLOAD
N#  if __has_attribute(__enable_if__)
X#  if 0
S#    define _LIBCPP_PREFERRED_OVERLOAD __attribute__ ((__enable_if__(true, "")))
N#  endif
N#endif
N
N#ifndef _LIBCPP_HAS_NO_NOEXCEPT
N#  define _NOEXCEPT noexcept
N#  define _NOEXCEPT_(x) noexcept(x)
N#else
S#  define _NOEXCEPT throw()
S#  define _NOEXCEPT_(x)
N#endif
N
N#if defined(_LIBCPP_DEBUG_USE_EXCEPTIONS)
X#if 0L
S# if !defined(_LIBCPP_DEBUG)
S#   error cannot use _LIBCPP_DEBUG_USE_EXCEPTIONS unless _LIBCPP_DEBUG is defined
S# endif
S# define _NOEXCEPT_DEBUG noexcept(false)
S# define _NOEXCEPT_DEBUG_(x) noexcept(false)
N#else
N# define _NOEXCEPT_DEBUG _NOEXCEPT
N# define _NOEXCEPT_DEBUG_(x) _NOEXCEPT_(x)
N#endif
N
N#ifdef _LIBCPP_HAS_NO_UNICODE_CHARS
Stypedef unsigned short char16_t;
Stypedef unsigned int   char32_t;
N#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS
N
N#ifndef __SIZEOF_INT128__
N#define _LIBCPP_HAS_NO_INT128
N#endif
N
N#ifdef _LIBCPP_CXX03_LANG
S# if __has_extension(c_static_assert)
S#   define static_assert(__b, __m) _Static_assert(__b, __m)
S# else
Sextern "C++" {
Stemplate <bool> struct __static_assert_test;
Stemplate <> struct __static_assert_test<true> {};
Stemplate <unsigned> struct __static_assert_check {};
S}
S#define static_assert(__b, __m) \
S    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
S    _LIBCPP_CONCAT(__t, __LINE__)
X#define static_assert(__b, __m)     typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)>     _LIBCPP_CONCAT(__t, __LINE__)
S# endif // __has_extension(c_static_assert)
N#endif  // _LIBCPP_CXX03_LANG
N
N#ifdef _LIBCPP_HAS_NO_DECLTYPE
S// GCC 4.6 provides __decltype in all standard modes.
S#if __has_keyword(__decltype) || _LIBCPP_CLANG_VER >= 304 || _GNUC_VER >= 406
S#  define decltype(__x) __decltype(__x)
S#else
S#  define decltype(__x) __typeof__(__x)
S#endif
N#endif
N
N#ifdef _LIBCPP_HAS_NO_CONSTEXPR
S#define _LIBCPP_CONSTEXPR
N#else
N#define _LIBCPP_CONSTEXPR constexpr
N#endif
N
N#ifdef _LIBCPP_CXX03_LANG
S#define _LIBCPP_DEFAULT {}
N#else
N#define _LIBCPP_DEFAULT = default;
N#endif
N
N#ifdef _LIBCPP_CXX03_LANG
S#define _LIBCPP_EQUAL_DELETE
N#else
N#define _LIBCPP_EQUAL_DELETE = delete
N#endif
N
N#ifdef __GNUC__
S#define _NOALIAS __attribute__((__malloc__))
N#else
N#define _NOALIAS
N#endif
N
N#if __has_feature(cxx_explicit_conversions) || defined(__IBMCPP__) || \
N    (!defined(_LIBCPP_CXX03_LANG) && defined(__GNUC__)) // All supported GCC versions
X#if 1 || 0L ||     (!0L && 0L) 
N#   define _LIBCPP_EXPLICIT explicit
N#else
S#   define _LIBCPP_EXPLICIT
N#endif
N
N#if !__has_builtin(__builtin_operator_new) || !__has_builtin(__builtin_operator_delete)
X#if !0 || !0
N#   define _LIBCPP_HAS_NO_BUILTIN_OPERATOR_NEW_DELETE
N#endif
N
N#ifdef _LIBCPP_HAS_NO_STRONG_ENUMS
S#define _LIBCPP_DECLARE_STRONG_ENUM(x) struct _LIBCPP_TYPE_VIS x { enum __lx
S#define _LIBCPP_DECLARE_STRONG_ENUM_EPILOG(x) \
S    __lx __v_; \
S    _LIBCPP_ALWAYS_INLINE x(__lx __v) : __v_(__v) {} \
S    _LIBCPP_ALWAYS_INLINE explicit x(int __v) : __v_(static_cast<__lx>(__v)) {} \
S    _LIBCPP_ALWAYS_INLINE operator int() const {return __v_;} \
S    };
X#define _LIBCPP_DECLARE_STRONG_ENUM_EPILOG(x)     __lx __v_;     _LIBCPP_ALWAYS_INLINE x(__lx __v) : __v_(__v) {}     _LIBCPP_ALWAYS_INLINE explicit x(int __v) : __v_(static_cast<__lx>(__v)) {}     _LIBCPP_ALWAYS_INLINE operator int() const {return __v_;}     };
N#else  // _LIBCPP_HAS_NO_STRONG_ENUMS
N#define _LIBCPP_DECLARE_STRONG_ENUM(x) enum class _LIBCPP_ENUM_VIS x
N#define _LIBCPP_DECLARE_STRONG_ENUM_EPILOG(x)
N#endif  // _LIBCPP_HAS_NO_STRONG_ENUMS
N
N#ifdef _LIBCPP_DEBUG
S#   if _LIBCPP_DEBUG == 0
S#       define _LIBCPP_DEBUG_LEVEL 1
S#   elif _LIBCPP_DEBUG == 1
S#       define _LIBCPP_DEBUG_LEVEL 2
S#   else
S#       error Supported values for _LIBCPP_DEBUG are 0 and 1
S#   endif
S# if !defined(_LIBCPP_BUILDING_LIBRARY)
S#   define _LIBCPP_EXTERN_TEMPLATE(...)
S# endif
N#endif
N
N#ifdef _LIBCPP_DISABLE_EXTERN_TEMPLATE
S#define _LIBCPP_EXTERN_TEMPLATE(...)
S#define _LIBCPP_EXTERN_TEMPLATE2(...)
N#endif
N
N#ifndef _LIBCPP_EXTERN_TEMPLATE
N#define _LIBCPP_EXTERN_TEMPLATE(...) extern template __VA_ARGS__;
N#endif
N
N#ifndef _LIBCPP_EXTERN_TEMPLATE2
N#define _LIBCPP_EXTERN_TEMPLATE2(...) extern template __VA_ARGS__;
N#endif
N
N#if defined(__APPLE__) && defined(__LP64__) && !defined(__x86_64__)
X#if 0L && 0L && !0L
S#define _LIBCPP_NONUNIQUE_RTTI_BIT (1ULL << 63)
N#endif
N
N#if defined(__APPLE__) || defined(__FreeBSD__) || defined(_LIBCPP_MSVCRT) ||   \
N    defined(__sun__) || defined(__NetBSD__) || defined(__CloudABI__) ||        \
N    defined(__TI_COMPILER_VERSION__)
X#if 0L || 0L || 0L ||       0L || 0L || 0L ||            1L
N#define _LIBCPP_LOCALE__L_EXTENSIONS 1
N#endif
N
N#if defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))
X#if 0L || (0L && 0L)
S// Most unix variants have catopen.  These are the specific ones that don't.
S#if !defined(__BIONIC__) && !defined(_NEWLIB_VERSION)
S#define _LIBCPP_HAS_CATOPEN 1
S#endif
N#endif
N
N#ifdef __FreeBSD__
S#define _DECLARE_C99_LDBL_MATH 1
N#endif
N
N#if defined(__APPLE__)
X#if 0L
S# if !defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && \
S     defined(__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__)
X# if !defined(__MAC_OS_X_VERSION_MIN_REQUIRED) &&      defined(__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__)
S#   define __MAC_OS_X_VERSION_MIN_REQUIRED __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__
S# endif
S# if defined(__MAC_OS_X_VERSION_MIN_REQUIRED)
S#   if __MAC_OS_X_VERSION_MIN_REQUIRED < 1060
S#     define _LIBCPP_HAS_NO_ALIGNED_ALLOCATION
S#   endif
S# endif
N#endif // defined(__APPLE__)
N
N#if defined(__APPLE__) || defined(__FreeBSD__)
X#if 0L || 0L
S#define _LIBCPP_HAS_DEFAULTRUNELOCALE
N#endif
N
N#if defined(__APPLE__) || defined(__FreeBSD__) || defined(__sun__)
X#if 0L || 0L || 0L
S#define _LIBCPP_WCTYPE_IS_MASK
N#endif
N
N#ifndef _LIBCPP_STD_VER
N#  if  __cplusplus <= 201103L
X#  if  201402L <= 201103L
S#    define _LIBCPP_STD_VER 11
N#  elif __cplusplus <= 201402L
X#  elif 201402L <= 201402L
N#    define _LIBCPP_STD_VER 14
N#  elif __cplusplus <= 201703L
S#    define _LIBCPP_STD_VER 17
S#  else
S#    define _LIBCPP_STD_VER 18  // current year, or date of c++2a ratification
N#  endif
N#endif  // _LIBCPP_STD_VER
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
N#define _LIBCPP_DEPRECATED [[deprecated]]
N#else
S#define _LIBCPP_DEPRECATED
N#endif
N
N#if _LIBCPP_STD_VER <= 11
X#if 14 <= 11
S#define _LIBCPP_EXPLICIT_AFTER_CXX11
S#define _LIBCPP_DEPRECATED_AFTER_CXX11
N#else
N#define _LIBCPP_EXPLICIT_AFTER_CXX11 explicit
N#define _LIBCPP_DEPRECATED_AFTER_CXX11 [[deprecated]]
N#endif
N
N#if _LIBCPP_STD_VER > 11 && !defined(_LIBCPP_HAS_NO_CXX14_CONSTEXPR)
X#if 14 > 11 && !0L
N#define _LIBCPP_CONSTEXPR_AFTER_CXX11 constexpr
N#else
S#define _LIBCPP_CONSTEXPR_AFTER_CXX11
N#endif
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_CXX14_CONSTEXPR)
X#if 14 > 14 && !0L
S#define _LIBCPP_CONSTEXPR_AFTER_CXX14 constexpr
N#else
N#define _LIBCPP_CONSTEXPR_AFTER_CXX14
N#endif
N
N// FIXME: Remove all usages of this macro once compilers catch up.
N#if !defined(__cpp_inline_variables) || (__cpp_inline_variables < 201606L)
X#if !0L || (__cpp_inline_variables < 201606L)
N# define _LIBCPP_HAS_NO_INLINE_VARIABLES
N#endif
N
N#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES
S#  define _LIBCPP_EXPLICIT_MOVE(x) _VSTD::move(x)
N#else
N#  define _LIBCPP_EXPLICIT_MOVE(x) (x)
N#endif
N
N#ifndef _LIBCPP_HAS_NO_ASAN
S_LIBCPP_FUNC_VIS extern "C" void __sanitizer_annotate_contiguous_container(
S  const void *, const void *, const void *, const void *);
N#endif
N
N// Try to find out if RTTI is disabled.
N// g++ and cl.exe have RTTI on by default and define a macro when it is.
N// g++ only defines the macro in 4.3.2 and onwards.
N#if !defined(_LIBCPP_NO_RTTI)
X#if !0L
N#  if defined(__GNUC__) && ((__GNUC__ >= 5) || (__GNUC__ == 4 && \
N   (__GNUC_MINOR__ >= 3 || __GNUC_PATCHLEVEL__ >= 2))) && !defined(__GXX_RTTI)
X#  if 0L && ((__GNUC__ >= 5) || (__GNUC__ == 4 &&    (__GNUC_MINOR__ >= 3 || __GNUC_PATCHLEVEL__ >= 2))) && !1L
S#    define _LIBCPP_NO_RTTI
S#  elif defined(_LIBCPP_COMPILER_MSVC) && !defined(_CPPRTTI)
X#  elif 0L && !0L
S#    define _LIBCPP_NO_RTTI
N#  endif
N#endif
N
N#ifndef _LIBCPP_WEAK
N#  define _LIBCPP_WEAK __attribute__((__weak__))
N#endif
N
N// Thread API
N#if !defined(_LIBCPP_HAS_NO_THREADS) && \
N    !defined(_LIBCPP_HAS_THREAD_API_PTHREAD) && \
N    !defined(_LIBCPP_HAS_THREAD_API_WIN32) && \
N    !defined(_LIBCPP_HAS_THREAD_API_EXTERNAL)
X#if !1L &&     !0L &&     !0L &&     !0L
S# if defined(__FreeBSD__) || \
S    defined(__Fuchsia__) || \
S    defined(__NetBSD__) || \
S    defined(__linux__) || \
S    defined(__APPLE__) || \
S    defined(__CloudABI__) || \
S    defined(__sun__) || \
S    (defined(__MINGW32__) && __libcpp_has_include(<pthread.h>))
X# if defined(__FreeBSD__) ||     defined(__Fuchsia__) ||     defined(__NetBSD__) ||     defined(__linux__) ||     defined(__APPLE__) ||     defined(__CloudABI__) ||     defined(__sun__) ||     (defined(__MINGW32__) && __libcpp_has_include(<pthread.h>))
S#   define _LIBCPP_HAS_THREAD_API_PTHREAD
S# elif defined(_LIBCPP_WIN32API)
S#  define _LIBCPP_HAS_THREAD_API_WIN32
S# else
S#  error "No thread API"
S# endif // _LIBCPP_HAS_THREAD_API
N#endif // _LIBCPP_HAS_NO_THREADS
N
N#if defined(_LIBCPP_HAS_NO_THREADS) && defined(_LIBCPP_HAS_THREAD_API_PTHREAD)
X#if 1L && 0L
S#  error _LIBCPP_HAS_THREAD_API_PTHREAD may only be defined when \
S         _LIBCPP_HAS_NO_THREADS is not defined.
X#  error _LIBCPP_HAS_THREAD_API_PTHREAD may only be defined when          _LIBCPP_HAS_NO_THREADS is not defined.
N#endif
N
N#if defined(_LIBCPP_HAS_NO_THREADS) && defined(_LIBCPP_HAS_THREAD_API_EXTERNAL)
X#if 1L && 0L
S#  error _LIBCPP_HAS_THREAD_API_EXTERNAL may not be defined when \
S         _LIBCPP_HAS_NO_THREADS is defined.
X#  error _LIBCPP_HAS_THREAD_API_EXTERNAL may not be defined when          _LIBCPP_HAS_NO_THREADS is defined.
N#endif
N
N#if defined(_LIBCPP_HAS_NO_MONOTONIC_CLOCK) && !defined(_LIBCPP_HAS_NO_THREADS)
X#if 0L && !1L
S#  error _LIBCPP_HAS_NO_MONOTONIC_CLOCK may only be defined when \
S         _LIBCPP_HAS_NO_THREADS is defined.
X#  error _LIBCPP_HAS_NO_MONOTONIC_CLOCK may only be defined when          _LIBCPP_HAS_NO_THREADS is defined.
N#endif
N
N// Systems that use capability-based security (FreeBSD with Capsicum,
N// Nuxi CloudABI) may only provide local filesystem access (using *at()).
N// Functions like open(), rename(), unlink() and stat() should not be
N// used, as they attempt to access the global filesystem namespace.
N#ifdef __CloudABI__
S#define _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE
N#endif
N
N// CloudABI is intended for running networked services. Processes do not
N// have standard input and output channels.
N#ifdef __CloudABI__
S#define _LIBCPP_HAS_NO_STDIN
S#define _LIBCPP_HAS_NO_STDOUT
N#endif
N
N#if defined(__BIONIC__) || defined(__CloudABI__) ||                            \
N    defined(__Fuchsia__) || defined(_LIBCPP_HAS_MUSL_LIBC)
X#if 0L || 0L ||                                0L || 0L
S#define _LIBCPP_PROVIDES_DEFAULT_RUNE_TABLE
N#endif
N
N// Thread-unsafe functions such as strtok() and localtime()
N// are not available.
N#ifdef __CloudABI__
S#define _LIBCPP_HAS_NO_THREAD_UNSAFE_C_FUNCTIONS
N#endif
N
N#if __has_feature(cxx_atomic) || __has_extension(c_atomic) || __has_keyword(_Atomic)
X#if 0 || 0 || !(1)
S#define _LIBCPP_HAS_C_ATOMIC_IMP
N#elif _GNUC_VER > 407 || defined(__TI_COMPILER_VERSION__)
X#elif 0 > 407 || 1L
N#define _LIBCPP_HAS_GCC_ATOMIC_IMP
N#endif
N
N// TODO: Remove "&& !defined(__TI_COMPILER_VERSION__) when we enable threads.
N#if (!defined(_LIBCPP_HAS_C_ATOMIC_IMP) && !defined(_LIBCPP_HAS_GCC_ATOMIC_IMP)) \
N     || defined(_LIBCPP_HAS_NO_THREADS) && !defined(_LIBCPP_TI_HAS_ATOMIC_HEADER)
X#if (!0L && !1L)      || 1L && !1L
S#define _LIBCPP_HAS_NO_ATOMIC_HEADER
N#endif
N
N#ifndef _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK
N#define _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK
N#endif
N
N#if defined(_LIBCPP_ENABLE_THREAD_SAFETY_ANNOTATIONS)
X#if 0L
S#if defined(__clang__) && __has_attribute(acquire_capability)
S// Work around the attribute handling in clang.  When both __declspec and
S// __attribute__ are present, the processing goes awry preventing the definition
S// of the types.
S#if !defined(_LIBCPP_OBJECT_FORMAT_COFF)
S#define _LIBCPP_HAS_THREAD_SAFETY_ANNOTATIONS
S#endif
S#endif
N#endif
N
N#if __has_attribute(require_constant_initialization)
X#if 0
S#define _LIBCPP_SAFE_STATIC __attribute__((__require_constant_initialization__))
N#else
N#define _LIBCPP_SAFE_STATIC
N#endif
N
N#if !__has_builtin(__builtin_addressof) && _GNUC_VER < 700  && \
N    !defined(_LIBCPP_COMPILER_TI)
X#if !0 && 0 < 700  &&     !1L
S# define _LIBCPP_HAS_NO_BUILTIN_ADDRESSOF
N#endif
N
N#if !defined(_LIBCPP_HAS_NO_OFF_T_FUNCTIONS)
X#if !0L
N#if defined(_LIBCPP_MSVCRT) || defined(_NEWLIB_VERSION) || \
N    defined(_LIBCPP_COMPILER_TI)
X#if 0L || 0L ||     1L
N#define _LIBCPP_HAS_NO_OFF_T_FUNCTIONS
N#endif
N#endif
N
N#if __has_attribute(diagnose_if) && !defined(_LIBCPP_DISABLE_ADDITIONAL_DIAGNOSTICS)
X#if 0 && !0L
S# define _LIBCPP_DIAGNOSE_WARNING(...) \
S    __attribute__((diagnose_if(__VA_ARGS__, "warning")))
X# define _LIBCPP_DIAGNOSE_WARNING(...)     __attribute__((diagnose_if(__VA_ARGS__, "warning")))
S# define _LIBCPP_DIAGNOSE_ERROR(...) \
S    __attribute__((diagnose_if(__VA_ARGS__, "error")))
X# define _LIBCPP_DIAGNOSE_ERROR(...)     __attribute__((diagnose_if(__VA_ARGS__, "error")))
N#else
N# define _LIBCPP_DIAGNOSE_WARNING(...)
N# define _LIBCPP_DIAGNOSE_ERROR(...)
N#endif
N
N#if __has_attribute(fallthough) || _GNUC_VER >= 700
X#if 0 || 0 >= 700
S// Use a function like macro to imply that it must be followed by a semicolon
S#define _LIBCPP_FALLTHROUGH() __attribute__((__fallthrough__))
N#else
N#define _LIBCPP_FALLTHROUGH() ((void)0)
N#endif
N
N#if defined(_LIBCPP_ABI_MICROSOFT) && \
N   (defined(_LIBCPP_COMPILER_MSVC) || __has_declspec_attribute(empty_bases))
X#if 0L &&    (0L || 0)
S# define _LIBCPP_DECLSPEC_EMPTY_BASES __declspec(empty_bases)
N#else
N# define _LIBCPP_DECLSPEC_EMPTY_BASES
N#endif
N
N#if defined(_LIBCPP_ENABLE_CXX17_REMOVED_FEATURES)
X#if 0L
S# define _LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR
S# define _LIBCPP_ENABLE_CXX17_REMOVED_UNEXPECTED_FUNCTIONS
S# define _LIBCPP_ENABLE_CXX17_REMOVED_RANDOM_SHUFFLE
S# define _LIBCPP_ENABLE_CXX17_REMOVED_BINDERS
N#endif // _LIBCPP_ENABLE_CXX17_REMOVED_FEATURES
N
N#if !defined(__cpp_deduction_guides) || __cpp_deduction_guides < 201611
X#if !0L || __cpp_deduction_guides < 201611
N# define _LIBCPP_HAS_NO_DEDUCTION_GUIDES
N#endif
N
N#if !__has_keyword(__is_aggregate) && (_GNUC_VER_NEW < 7001)
X#if ! !(1) && (0 < 7001)
N# define _LIBCPP_HAS_NO_IS_AGGREGATE
N#endif
N
N#if !defined(__cpp_coroutines) || __cpp_coroutines < 201703L
X#if !0L || __cpp_coroutines < 201703L
N# define _LIBCPP_HAS_NO_COROUTINES
N#endif
N
N// Decide whether to use availability macros.
N#if !defined(_LIBCPP_BUILDING_LIBRARY) &&                                      \
N    !defined(_LIBCPP_DISABLE_AVAILABILITY) &&                                  \
N    __has_feature(attribute_availability_with_strict) &&                       \
N    __has_feature(attribute_availability_in_templates)
X#if !0L &&                                          !0L &&                                      0 &&                           0
S#ifdef __APPLE__
S#define _LIBCPP_USE_AVAILABILITY_APPLE
S#endif
N#endif
N
N// Define availability macros.
N#if defined(_LIBCPP_USE_AVAILABILITY_APPLE)
X#if 0L
S#define _LIBCPP_AVAILABILITY_SHARED_MUTEX                                      \
S  __attribute__((availability(macosx,strict,introduced=10.12)))                \
S  __attribute__((availability(ios,strict,introduced=10.0)))                    \
S  __attribute__((availability(tvos,strict,introduced=10.0)))                   \
S  __attribute__((availability(watchos,strict,introduced=3.0)))
X#define _LIBCPP_AVAILABILITY_SHARED_MUTEX                                        __attribute__((availability(macosx,strict,introduced=10.12)))                  __attribute__((availability(ios,strict,introduced=10.0)))                      __attribute__((availability(tvos,strict,introduced=10.0)))                     __attribute__((availability(watchos,strict,introduced=3.0)))
S#define _LIBCPP_AVAILABILITY_BAD_OPTIONAL_ACCESS __attribute__((unavailable))
S#define _LIBCPP_AVAILABILITY_BAD_ARRAY_LENGTH __attribute__((unavailable))
S#define _LIBCPP_AVAILABILITY_BAD_ANY_CAST __attribute__((unavailable))
S#define _LIBCPP_AVAILABILITY_UNCAUGHT_EXCEPTIONS                               \
S  __attribute__((availability(macosx,strict,introduced=10.12)))                \
S  __attribute__((availability(ios,strict,introduced=10.0)))                    \
S  __attribute__((availability(tvos,strict,introduced=10.0)))                   \
S  __attribute__((availability(watchos,strict,introduced=3.0)))
X#define _LIBCPP_AVAILABILITY_UNCAUGHT_EXCEPTIONS                                 __attribute__((availability(macosx,strict,introduced=10.12)))                  __attribute__((availability(ios,strict,introduced=10.0)))                      __attribute__((availability(tvos,strict,introduced=10.0)))                     __attribute__((availability(watchos,strict,introduced=3.0)))
S#define _LIBCPP_AVAILABILITY_SIZED_NEW_DELETE                                  \
S  __attribute__((availability(macosx,strict,introduced=10.12)))                \
S  __attribute__((availability(ios,strict,introduced=10.0)))                    \
S  __attribute__((availability(tvos,strict,introduced=10.0)))                   \
S  __attribute__((availability(watchos,strict,introduced=3.0)))
X#define _LIBCPP_AVAILABILITY_SIZED_NEW_DELETE                                    __attribute__((availability(macosx,strict,introduced=10.12)))                  __attribute__((availability(ios,strict,introduced=10.0)))                      __attribute__((availability(tvos,strict,introduced=10.0)))                     __attribute__((availability(watchos,strict,introduced=3.0)))
S#define _LIBCPP_AVAILABILITY_FUTURE_ERROR                                      \
S  __attribute__((availability(ios,strict,introduced=6.0)))
X#define _LIBCPP_AVAILABILITY_FUTURE_ERROR                                        __attribute__((availability(ios,strict,introduced=6.0)))
S#define _LIBCPP_AVAILABILITY_TYPEINFO_VTABLE                                   \
S  __attribute__((availability(macosx,strict,introduced=10.9)))                 \
S  __attribute__((availability(ios,strict,introduced=7.0)))
X#define _LIBCPP_AVAILABILITY_TYPEINFO_VTABLE                                     __attribute__((availability(macosx,strict,introduced=10.9)))                   __attribute__((availability(ios,strict,introduced=7.0)))
S#define _LIBCPP_AVAILABILITY_LOCALE_CATEGORY                                   \
S  __attribute__((availability(macosx,strict,introduced=10.9)))                 \
S  __attribute__((availability(ios,strict,introduced=7.0)))
X#define _LIBCPP_AVAILABILITY_LOCALE_CATEGORY                                     __attribute__((availability(macosx,strict,introduced=10.9)))                   __attribute__((availability(ios,strict,introduced=7.0)))
S#define _LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR                                 \
S  __attribute__((availability(macosx,strict,introduced=10.9)))                 \
S  __attribute__((availability(ios,strict,introduced=7.0)))
X#define _LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR                                   __attribute__((availability(macosx,strict,introduced=10.9)))                   __attribute__((availability(ios,strict,introduced=7.0)))
N#else
N#define _LIBCPP_AVAILABILITY_SHARED_MUTEX
N#define _LIBCPP_AVAILABILITY_BAD_OPTIONAL_ACCESS
N#define _LIBCPP_AVAILABILITY_BAD_ARRAY_LENGTH
N#define _LIBCPP_AVAILABILITY_BAD_ANY_CAST
N#define _LIBCPP_AVAILABILITY_UNCAUGHT_EXCEPTIONS
N#define _LIBCPP_AVAILABILITY_SIZED_NEW_DELETE
N#define _LIBCPP_AVAILABILITY_FUTURE_ERROR
N#define _LIBCPP_AVAILABILITY_TYPEINFO_VTABLE
N#define _LIBCPP_AVAILABILITY_LOCALE_CATEGORY
N#define _LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR
N#endif
N
N// Define availability that depends on _LIBCPP_NO_EXCEPTIONS.
N#ifdef _LIBCPP_NO_EXCEPTIONS
N#define _LIBCPP_AVAILABILITY_DYNARRAY
N#define _LIBCPP_AVAILABILITY_FUTURE
N#define _LIBCPP_AVAILABILITY_THROW_BAD_ANY_CAST
N#else
S#define _LIBCPP_AVAILABILITY_DYNARRAY _LIBCPP_AVAILABILITY_BAD_ARRAY_LENGTH
S#define _LIBCPP_AVAILABILITY_FUTURE _LIBCPP_AVAILABILITY_FUTURE_ERROR
S#define _LIBCPP_AVAILABILITY_THROW_BAD_ANY_CAST                                \
S  _LIBCPP_AVAILABILITY_BAD_ANY_CAST
X#define _LIBCPP_AVAILABILITY_THROW_BAD_ANY_CAST                                  _LIBCPP_AVAILABILITY_BAD_ANY_CAST
N#endif
N
N// Availability of stream API in the dylib got dropped and re-added.  The
N// extern template should effectively be available at:
N//    availability(macosx,introduced=10.9)
N//    availability(ios,introduced=7.0)
N#if defined(_LIBCPP_USE_AVAILABILITY_APPLE) &&                                 \
N    ((defined(__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__) &&                \
N      __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ < 1090) ||                 \
N     (defined(__ENVIRONMENT_IPHONE_OS_VERSION_MIN_REQUIRED__) &&               \
N      __ENVIRONMENT_IPHONE_OS_VERSION_MIN_REQUIRED__ < 70000))
X#if 0L &&                                     ((0L &&                      __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ < 1090) ||                      (0L &&                     __ENVIRONMENT_IPHONE_OS_VERSION_MIN_REQUIRED__ < 70000))
S#define _LIBCPP_AVAILABILITY_NO_STREAMS_EXTERN_TEMPLATE
N#endif
N
N#if defined(_LIBCPP_COMPILER_IBM)
X#if 0L
S#define _LIBCPP_HAS_NO_PRAGMA_PUSH_POP_MACRO
N#endif
N
N#if defined(_LIBCPP_HAS_NO_PRAGMA_PUSH_POP_MACRO)
X#if 0L
S# define _LIBCPP_PUSH_MACROS
S# define _LIBCPP_POP_MACROS
N#else
N  // Don't warn about macro conflicts when we can restore them at the
N  // end of the header.
N# ifndef _LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS
N#   define _LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS
N# endif
N# if defined(_LIBCPP_COMPILER_MSVC)
X# if 0L
S#   define _LIBCPP_PUSH_MACROS    \
S      __pragma(push_macro("min")) \
S      __pragma(push_macro("max"))
X#   define _LIBCPP_PUSH_MACROS          __pragma(push_macro("min"))       __pragma(push_macro("max"))
S#   define _LIBCPP_POP_MACROS     \
S      __pragma(pop_macro("min"))  \
S      __pragma(pop_macro("max"))
X#   define _LIBCPP_POP_MACROS           __pragma(pop_macro("min"))        __pragma(pop_macro("max"))
N# else
N#   define _LIBCPP_PUSH_MACROS        \
N      _Pragma("push_macro(\"min\")")  \
N      _Pragma("push_macro(\"max\")")
X#   define _LIBCPP_PUSH_MACROS              _Pragma("push_macro(\"min\")")        _Pragma("push_macro(\"max\")")
N#   define _LIBCPP_POP_MACROS         \
N      _Pragma("pop_macro(\"min\")")   \
N      _Pragma("pop_macro(\"max\")")
X#   define _LIBCPP_POP_MACROS               _Pragma("pop_macro(\"min\")")         _Pragma("pop_macro(\"max\")")
N# endif
N#endif // defined(_LIBCPP_HAS_NO_PRAGMA_PUSH_POP_MACRO)
N
N#ifdef _LIBCPP_C_AND_CPP_FUNCS_ARE_DISTINCT
N#define _LIBCPP_FREE [] (void *p) { free(p); }
N#define _LIBCPP_FCLOSE [] (FILE *f) { return fclose(f); }
N#else
S#define _LIBCPP_FREE free
S#define _LIBCPP_FCLOSE fclose
N#endif // defined(_LIBCPP_C_AND_CPP_FUNCS_ARE_DISTINCT)
N
N#endif // __cplusplus
N
N#pragma diag_pop
N
N#endif // _LIBCPP_CONFIG
L 103 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/stdint.h" 2
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N/* C99 stdlib (e.g. glibc < 2.18) does not provide macros needed
N   for C++11 unless __STDC_LIMIT_MACROS and __STDC_CONSTANT_MACROS
N   are defined
N*/
N#if defined(__cplusplus) && !defined(__STDC_LIMIT_MACROS)
X#if 1L && !0L
N#   define __STDC_LIMIT_MACROS
N#endif
N#if defined(__cplusplus) && !defined(__STDC_CONSTANT_MACROS)
X#if 1L && !0L
N#   define __STDC_CONSTANT_MACROS
N#endif
N
N#include_next <stdint.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/stdint.h" 1
N/*****************************************************************************/
N/* STDINT.H                                                                  */
N/*                                                                           */
N/* Copyright (c) 2002 Texas Instruments Incorporated                         */
N/* http://www.ti.com/                                                        */
N/*                                                                           */
N/*  Redistribution and  use in source  and binary forms, with  or without    */
N/*  modification,  are permitted provided  that the  following conditions    */
N/*  are met:                                                                 */
N/*                                                                           */
N/*     Redistributions  of source  code must  retain the  above copyright    */
N/*     notice, this list of conditions and the following disclaimer.         */
N/*                                                                           */
N/*     Redistributions in binary form  must reproduce the above copyright    */
N/*     notice, this  list of conditions  and the following  disclaimer in    */
N/*     the  documentation  and/or   other  materials  provided  with  the    */
N/*     distribution.                                                         */
N/*                                                                           */
N/*     Neither the  name of Texas Instruments Incorporated  nor the names    */
N/*     of its  contributors may  be used to  endorse or  promote products    */
N/*     derived  from   this  software  without   specific  prior  written    */
N/*     permission.                                                           */
N/*                                                                           */
N/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS    */
N/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT    */
N/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    */
N/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT    */
N/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    */
N/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT    */
N/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    */
N/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    */
N/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT    */
N/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    */
N/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     */
N/*                                                                           */
N/*****************************************************************************/
N#ifndef _STDINT_H_
N#define _STDINT_H_
N
N#include <_stdint40.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/_stdint40.h" 1
N/*****************************************************************************/
N/* _STDINT40.H                                                               */
N/*                                                                           */
N/* Copyright (c) 2018 Texas Instruments Incorporated                         */
N/* http://www.ti.com/                                                        */
N/*                                                                           */
N/*  Redistribution and  use in source  and binary forms, with  or without    */
N/*  modification,  are permitted provided  that the  following conditions    */
N/*  are met:                                                                 */
N/*                                                                           */
N/*     Redistributions  of source  code must  retain the  above copyright    */
N/*     notice, this list of conditions and the following disclaimer.         */
N/*                                                                           */
N/*     Redistributions in binary form  must reproduce the above copyright    */
N/*     notice, this  list of conditions  and the following  disclaimer in    */
N/*     the  documentation  and/or   other  materials  provided  with  the    */
N/*     distribution.                                                         */
N/*                                                                           */
N/*     Neither the  name of Texas Instruments Incorporated  nor the names    */
N/*     of its  contributors may  be used to  endorse or  promote products    */
N/*     derived  from   this  software  without   specific  prior  written    */
N/*     permission.                                                           */
N/*                                                                           */
N/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS    */
N/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT    */
N/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    */
N/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT    */
N/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    */
N/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT    */
N/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    */
N/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    */
N/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT    */
N/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    */
N/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     */
N/*                                                                           */
N/*****************************************************************************/
N#ifndef __STDINT40_H_
N#define __STDINT40_H_
N
N#if defined(_TMS320C6X) && !defined(__C6X_MIGRATION__)
X#if 0L && !0L
S    typedef          __int40_t  int40_t;
S    typedef unsigned __int40_t uint40_t;
S
S    typedef  int40_t  int_least40_t;
S    typedef uint40_t uint_least40_t;
S
S    typedef  int40_t  int_fast40_t;
S    typedef uint40_t uint_fast40_t;
N#endif
N
N/* 
N   According to footnotes in the 1999 C standard, "C++ implementations
N   should define these macros only when __STDC_LIMIT_MACROS is defined
N   before <stdint.h> is included." 
N*/
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !1L || 1L
N
N#if defined(_TMS320C6X) && !defined(__C6X_MIGRATION__)
X#if 0L && !0L
S    #define  INT40_MAX  0x7fffffffff
S    #define  INT40_MIN  (-INT40_MAX-1)
S    #define UINT40_MAX  0xffffffffff
S
S    #define  INT_LEAST40_MAX  (INT40_MAX)
S    #define  INT_LEAST40_MIN  (INT40_MIN)
S    #define UINT_LEAST40_MAX  (UINT40_MAX)
S
S    #define  INT_FAST40_MAX  (INT40_MAX)
S    #define  INT_FAST40_MIN  (INT40_MIN)
S    #define UINT_FAST40_MAX  (UINT40_MAX)
S
S    #define  INT40_C(value) ((int_least40_t)(value))
S    #define UINT40_C(value) ((uint_least40_t)(value))
N#endif
N
N#endif /* !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS) */
N#endif /* __STDINT40_H_ */
L 41 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/stdint.h" 2
N#if __has_include(<sys/stdint.h>) 
X#if 1 
N#include <sys/stdint.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/sys/stdint.h" 1
N/*-
N * SPDX-License-Identifier: BSD-2-Clause-FreeBSD
N *
N * Copyright (c) 2001 Mike Barcroft <mike@FreeBSD.org>
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N * 1. Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
N * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
N * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
N * SUCH DAMAGE.
N *
N * $FreeBSD$
N */
N
N#ifndef _SYS_STDINT_H_
N#define _SYS_STDINT_H_
N
N#include <sys/cdefs.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/sys/cdefs.h" 1
N/*-
N * SPDX-License-Identifier: BSD-3-Clause
N *
N * Copyright (c) 1991, 1993
N *	The Regents of the University of California.  All rights reserved.
N *
N * This code is derived from software contributed to Berkeley by
N * Berkeley Software Design, Inc.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N * 1. Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N * 3. Neither the name of the University nor the names of its contributors
N *    may be used to endorse or promote products derived from this software
N *    without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
N * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
N * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
N * SUCH DAMAGE.
N *
N *	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
N * $FreeBSD$
N */
N
N#ifndef	_SYS_CDEFS_H_
N#define	_SYS_CDEFS_H_
N
N#if defined(__TI_COMPILER_VERSION__)
X#if 1L
N#pragma diag_push
N#pragma CHECK_MISRA("none")
N#endif
N
N/*
N * Testing against Clang-specific extensions.
N */
N#ifndef	__has_attribute
S#define	__has_attribute(x)	0
N#endif
N#ifndef	__has_extension
S#define	__has_extension		__has_feature
N#endif
N#ifndef	__has_feature
S#define	__has_feature(x)	0
N#endif
N#ifndef	__has_include
S#define	__has_include(x)	0
N#endif
N#ifndef	__has_builtin
S#define	__has_builtin(x)	0
N#endif
N
N#if defined(__cplusplus)
X#if 1L
N#define	__BEGIN_DECLS	extern "C" {
N#define	__END_DECLS	}
N#else
S#define	__BEGIN_DECLS
S#define	__END_DECLS
N#endif
N
N/*
N * This code has been put in place to help reduce the addition of
N * compiler specific defines in FreeBSD code.  It helps to aid in
N * having a compiler-agnostic source tree.
N */
N
N#if defined(__GNUC__) || defined(__INTEL_COMPILER)
X#if 0L || 0L
S
S#if __GNUC__ >= 3 || defined(__INTEL_COMPILER)
S#define	__GNUCLIKE_ASM 3
S#define	__GNUCLIKE_MATH_BUILTIN_CONSTANTS
S#else
S#define	__GNUCLIKE_ASM 2
S#endif
S#define	__GNUCLIKE___TYPEOF 1
S#define	__GNUCLIKE___OFFSETOF 1
S#define	__GNUCLIKE___SECTION 1
S
S#ifndef __INTEL_COMPILER
S#define	__GNUCLIKE_CTOR_SECTION_HANDLING 1
S#endif
S
S#define	__GNUCLIKE_BUILTIN_CONSTANT_P 1
S#if defined(__INTEL_COMPILER) && defined(__cplusplus) && \
S   __INTEL_COMPILER < 800
X#if defined(__INTEL_COMPILER) && defined(__cplusplus) &&    __INTEL_COMPILER < 800
S#undef __GNUCLIKE_BUILTIN_CONSTANT_P
S#endif
S
S#if (__GNUC_MINOR__ > 95 || __GNUC__ >= 3)
S#define	__GNUCLIKE_BUILTIN_VARARGS 1
S#define	__GNUCLIKE_BUILTIN_STDARG 1
S#define	__GNUCLIKE_BUILTIN_VAALIST 1
S#endif
S
S#if defined(__GNUC__)
S#define	__GNUC_VA_LIST_COMPATIBILITY 1
S#endif
S
S/*
S * Compiler memory barriers, specific to gcc and clang.
S */
S#if defined(__GNUC__)
S#define	__compiler_membar()	__asm __volatile(" " : : : "memory")
S#endif
S
S#ifndef __INTEL_COMPILER
S#define	__GNUCLIKE_BUILTIN_NEXT_ARG 1
S#define	__GNUCLIKE_MATH_BUILTIN_RELOPS
S#endif
S
S#define	__GNUCLIKE_BUILTIN_MEMCPY 1
S
S/* XXX: if __GNUC__ >= 2: not tested everywhere originally, where replaced */
S#define	__CC_SUPPORTS_INLINE 1
S#define	__CC_SUPPORTS___INLINE 1
S#define	__CC_SUPPORTS___INLINE__ 1
S
S#define	__CC_SUPPORTS___FUNC__ 1
S#define	__CC_SUPPORTS_WARNING 1
S
S#define	__CC_SUPPORTS_VARADIC_XXX 1 /* see varargs.h */
S
S#define	__CC_SUPPORTS_DYNAMIC_ARRAY_INIT 1
S
N#endif /* __GNUC__ || __INTEL_COMPILER */
N
N#ifdef __TI_COMPILER_VERSION__
N#define	__GNUCLIKE___TYPEOF 1
N#define	__GNUCLIKE___OFFSETOF 1
N#define	__GNUCLIKE___SECTION 1
N
N#define	__CC_SUPPORTS_INLINE 1
N#define	__CC_SUPPORTS___INLINE 1
N#define	__CC_SUPPORTS___INLINE__ 1
N
N#define	__CC_SUPPORTS___FUNC__ 1
N#define	__CC_SUPPORTS_WARNING 1
N
N#define	__CC_SUPPORTS_VARADIC_XXX 1 /* see varargs.h */
N
N#define	__CC_SUPPORTS_DYNAMIC_ARRAY_INIT 1
N#endif /* __TI_COMPILER_VERSION__ */
N
N/*
N * Macro to test if we're using a specific version of gcc or later.
N */
N#if defined(__GNUC__) && !defined(__INTEL_COMPILER)
X#if 0L && !0L
S#define	__GNUC_PREREQ__(ma, mi)	\
S	(__GNUC__ > (ma) || __GNUC__ == (ma) && __GNUC_MINOR__ >= (mi))
X#define	__GNUC_PREREQ__(ma, mi)		(__GNUC__ > (ma) || __GNUC__ == (ma) && __GNUC_MINOR__ >= (mi))
N#else
N#define	__GNUC_PREREQ__(ma, mi)	0
N#endif
N
N/*
N * The __CONCAT macro is used to concatenate parts of symbol names, e.g.
N * with "#define OLD(foo) __CONCAT(old,foo)", OLD(foo) produces oldfoo.
N * The __CONCAT macro is a bit tricky to use if it must work in non-ANSI
N * mode -- there must be no spaces between its arguments, and for nested
N * __CONCAT's, all the __CONCAT's must be at the left.  __CONCAT can also
N * concatenate double-quoted strings produced by the __STRING macro, but
N * this only works with ANSI C.
N *
N * __XSTRING is like __STRING, but it expands any macros in its argument
N * first.  It is only available with ANSI C.
N */
N#if defined(__STDC__) || defined(__cplusplus)
X#if 1L || 1L
N#define	__P(protos)	protos		/* full-blown ANSI C */
N#define	__CONCAT1(x,y)	x ## y
N#define	__CONCAT(x,y)	__CONCAT1(x,y)
N#define	__STRING(x)	#x		/* stringify without expanding x */
N#define	__XSTRING(x)	__STRING(x)	/* expand x, then stringify */
N
N#define	__const		const		/* define reserved names to standard */
N#define	__signed	signed
N#define	__volatile	volatile
N#if defined(__cplusplus)
X#if 1L
N#define	__inline	inline		/* convert to C++ keyword */
N#else
S#if !(defined(__CC_SUPPORTS___INLINE))
S#define	__inline			/* delete GCC keyword */
S#endif /* ! __CC_SUPPORTS___INLINE */
N#endif /* !__cplusplus */
N
N#else	/* !(__STDC__ || __cplusplus) */
S#define	__P(protos)	()		/* traditional C preprocessor */
S#define	__CONCAT(x,y)	x/**/y
S#define	__STRING(x)	"x"
S
S#if !defined(__CC_SUPPORTS___INLINE)
S#define	__const				/* delete pseudo-ANSI C keywords */
S#define	__inline
S#define	__signed
S#define	__volatile
S/*
S * In non-ANSI C environments, new programs will want ANSI-only C keywords
S * deleted from the program and old programs will want them left alone.
S * When using a compiler other than gcc, programs using the ANSI C keywords
S * const, inline etc. as normal identifiers should define -DNO_ANSI_KEYWORDS.
S * When using "gcc -traditional", we assume that this is the intent; if
S * __GNUC__ is defined but __STDC__ is not, we leave the new keywords alone.
S */
S#ifndef	NO_ANSI_KEYWORDS
S#define	const				/* delete ANSI C keywords */
S#define	inline
S#define	signed
S#define	volatile
S#endif	/* !NO_ANSI_KEYWORDS */
S#endif	/* !__CC_SUPPORTS___INLINE */
N#endif	/* !(__STDC__ || __cplusplus) */
N
N/*
N * Compiler-dependent macros to help declare dead (non-returning) and
N * pure (no side effects) functions, and unused variables.  They are
N * null except for versions of gcc that are known to support the features
N * properly (old versions of gcc-2 supported the dead and pure features
N * in a different (wrong) way).  If we do not provide an implementation
N * for a given compiler, let the compile fail if it is told to use
N * a feature that we cannot live without.
N */
N#define	__weak_symbol	__attribute__((__weak__))
N#if !__GNUC_PREREQ__(2, 5) && !defined(__INTEL_COMPILER) && !defined(__TI_COMPILER_VERSION__)
X#if !0 && !0L && !1L
S#define	__dead2
S#define	__pure2
S#define	__unused
N#endif
N
N/*
N * TI ADD - check that __GNUC__ is defined before referencing it to avoid
N *          generating an error when __GNUC__ treated as zero warning is
N *          promoted to an error via -pdse195 option.
N */
N#if defined(__GNUC__) && __GNUC__ == 2 && __GNUC_MINOR__ >= 5 && __GNUC_MINOR__ < 7 && !defined(__INTEL_COMPILER)
X#if 0L && __GNUC__ == 2 && __GNUC_MINOR__ >= 5 && __GNUC_MINOR__ < 7 && !0L
S#define	__dead2		__attribute__((__noreturn__))
S#define	__pure2		__attribute__((__const__))
S#define	__unused
S/* XXX Find out what to do for __packed, __aligned and __section */
N#endif
N
N#if __GNUC_PREREQ__(2, 7) || defined(__INTEL_COMPILER) || defined(__TI_COMPILER_VERSION__)
X#if 0 || 0L || 1L
N#define	__dead2		__attribute__((__noreturn__))
N#define	__pure2		__attribute__((__const__))
N#define	__unused	__attribute__((__unused__))
N#define	__used		__attribute__((__used__))
N#define	__packed	__attribute__((__packed__))
N#define	__aligned(x)	__attribute__((__aligned__(x)))
N#define	__section(x)	__attribute__((__section__(x)))
N#endif
N#if __GNUC_PREREQ__(4, 3) || __has_attribute(__alloc_size__)
X#if 0 || 1
N#define	__alloc_size(x)	__attribute__((__alloc_size__(x)))
N#else
S#define	__alloc_size(x)
N#endif
N#if __GNUC_PREREQ__(4, 9) || __has_attribute(__alloc_align__)
X#if 0 || 0
S#define	__alloc_align(x)	__attribute__((__alloc_align__(x)))
N#else
N#define	__alloc_align(x)
N#endif
N
N#if defined(__TI_COMPILER_VERSION__)
X#if 1L
N#define __alignof(x)    __alignof__(x)
N#elif !__GNUC_PREREQ__(2, 95)
S#define	__alignof(x)	__offsetof(struct { char __a; x __b; }, __b)
N#endif
N
N/*
N * Keywords added in C11.
N */
N
N#if !defined(__STDC_VERSION__) || __STDC_VERSION__ < 201112L
X#if !0L || __STDC_VERSION__ < 201112L
N
N#if !__has_extension(c_alignas)
X#if !0
N#if (defined(__cplusplus) && __cplusplus >= 201103L) || \
N    __has_extension(cxx_alignas)
X#if (1L && 201402L >= 201103L) ||     1
N#define	_Alignas(x)		alignas(x)
N#else
S/* XXX: Only emulates _Alignas(constant-expression); not _Alignas(type-name). */
S#define	_Alignas(x)		__aligned(x)
N#endif
N#endif
N
N#if defined(__cplusplus) && __cplusplus >= 201103L
X#if 1L && 201402L >= 201103L
N#define	_Alignof(x)		alignof(x)
N#else
S#define	_Alignof(x)		__alignof(x)
N#endif
N
N#if !defined(__cplusplus) && !__has_extension(c_atomic) && \
N    !__has_extension(cxx_atomic)
X#if !1L && !0 &&     !0
S/*
S * No native support for _Atomic(). Place object in structure to prevent
S * most forms of direct non-atomic access.
S */
S#define	_Atomic(T)		struct { T volatile __val; }
N#endif
N
N#if defined(__cplusplus) && __cplusplus >= 201103L
X#if 1L && 201402L >= 201103L
N#define	_Noreturn		[[noreturn]]
N#else
S#define	_Noreturn		__dead2
N#endif
N
N#if !__has_extension(c_static_assert)
X#if !0
N#if (defined(__cplusplus) && __cplusplus >= 201103L) || \
N    __has_extension(cxx_static_assert)
X#if (1L && 201402L >= 201103L) ||     1
N#define	_Static_assert(x, y)	static_assert(x, y)
N#elif __GNUC_PREREQ__(4,6) && !defined(__cplusplus)
S/* Nothing, gcc 4.6 and higher has _Static_assert built-in */
S#elif defined(__COUNTER__)
S#define	_Static_assert(x, y)	__Static_assert(x, __COUNTER__)
S#define	__Static_assert(x, y)	___Static_assert(x, y)
S#define	___Static_assert(x, y)	typedef char __assert_ ## y[(x) ? 1 : -1] \
S				__unused
X#define	___Static_assert(x, y)	typedef char __assert_ ## y[(x) ? 1 : -1] 				__unused
S#else
S#define	_Static_assert(x, y)	struct __hack
N#endif
N#endif
N
N#if !__has_extension(c_thread_local)
X#if !0
N/*
N * XXX: Some compilers (Clang 3.3, GCC 4.7) falsely announce C++11 mode
N * without actually supporting the thread_local keyword. Don't check for
N * the presence of C++11 when defining _Thread_local.
N */
N#if /* (defined(__cplusplus) && __cplusplus >= 201103L) || */ \
N    __has_extension(cxx_thread_local)
X#if       1
N#define	_Thread_local		thread_local
N#else
S#define	_Thread_local		__thread
N#endif
N#endif
N
N#endif /* __STDC_VERSION__ || __STDC_VERSION__ < 201112L */
N
N/*
N * Emulation of C11 _Generic().  Unlike the previously defined C11
N * keywords, it is not possible to implement this using exactly the same
N * syntax.  Therefore implement something similar under the name
N * __generic().  Unlike _Generic(), this macro can only distinguish
N * between a single type, so it requires nested invocations to
N * distinguish multiple cases.
N */
N
N#if (defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L) || \
N    __has_extension(c_generic_selections)
X#if (0L && __STDC_VERSION__ >= 201112L) ||     0
S#define	__generic(expr, t, yes, no)					\
S	_Generic(expr, t: yes, default: no)
X#define	__generic(expr, t, yes, no)						_Generic(expr, t: yes, default: no)
S#elif __GNUC_PREREQ__(3, 1) && !defined(__cplusplus)
X#elif 0 && !1L
S#define	__generic(expr, t, yes, no)					\
S	__builtin_choose_expr(						\
S	    __builtin_types_compatible_p(__typeof(expr), t), yes, no)
X#define	__generic(expr, t, yes, no)						__builtin_choose_expr(							    __builtin_types_compatible_p(__typeof(expr), t), yes, no)
N#endif
N
N/*
N * C99 Static array indices in function parameter declarations.  Syntax such as:
N * void bar(int myArray[static 10]);
N * is allowed in C99 but not in C++.  Define __min_size appropriately so
N * headers using it can be compiled in either language.  Use like this:
N * void bar(int myArray[__min_size(10)]);
N */
N#if !defined(__cplusplus) && \
N    (defined(__clang__) || __GNUC_PREREQ__(4, 6)) && \
N    (!defined(__STDC_VERSION__) || (__STDC_VERSION__ >= 199901))
X#if !1L &&     (0L || 0) &&     (!0L || (__STDC_VERSION__ >= 199901))
S#define __min_size(x)	static (x)
N#else
N#define __min_size(x)	(x)
N#endif
N
N#if __GNUC_PREREQ__(2, 96)
X#if 0
S#define	__malloc_like	__attribute__((__malloc__))
S#define	__pure		__attribute__((__pure__))
N#else
N#define	__malloc_like
N#define	__pure
N#endif
N
N#if __GNUC_PREREQ__(3, 1) || (defined(__INTEL_COMPILER) && __INTEL_COMPILER >= 800) || defined(__TI_COMPILER_VERSION__)
X#if 0 || (0L && __INTEL_COMPILER >= 800) || 1L
N#define	__always_inline	__attribute__((__always_inline__))
N#else
S#define	__always_inline
N#endif
N
N#if __GNUC_PREREQ__(3, 1) || defined(__TI_COMPILER_VERSION__)
X#if 0 || 1L
N#define	__noinline	__attribute__ ((__noinline__))
N#else
S#define	__noinline
N#endif
N
N#if __GNUC_PREREQ__(3, 4)
X#if 0
S#define	__fastcall	__attribute__((__fastcall__))
S#define	__result_use_check	__attribute__((__warn_unused_result__))
N#else
N#define	__fastcall
N#define	__result_use_check
N#endif
N
N#if __GNUC_PREREQ__(4, 1)
X#if 0
S#define	__returns_twice	__attribute__((__returns_twice__))
N#else
N#define	__returns_twice
N#endif
N
N#if __GNUC_PREREQ__(4, 6) || __has_builtin(__builtin_unreachable)
X#if 0 || 0
S#define	__unreachable()	__builtin_unreachable()
N#else
N#define	__unreachable()	((void)0)
N#endif
N
N/* XXX: should use `#if __STDC_VERSION__ < 199901'. */
N#if !__GNUC_PREREQ__(2, 7) && !defined(__INTEL_COMPILER) && !defined(__TI_COMPILER_VERSION__)
X#if !0 && !0L && !1L
S#define	__func__	NULL
N#endif
N
N#if (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901)) || \
N    defined(__TI_COMPILER_VERSION__) || ((defined(__INTEL_COMPILER) || (defined(__GNUC__) && __GNUC__ >= 2)) && !defined(__STRICT_ANSI__))
X#if (0L && (__STDC_VERSION__ >= 199901)) ||     1L || ((0L || (0L && __GNUC__ >= 2)) && !0L)
N#define	__LONG_LONG_SUPPORTED
N#endif
N
N/* C++11 exposes a load of C99 stuff */
N#if defined(__cplusplus) && __cplusplus >= 201103L
X#if 1L && 201402L >= 201103L
N#define	__LONG_LONG_SUPPORTED
N#ifndef	__STDC_LIMIT_MACROS
S#define	__STDC_LIMIT_MACROS
N#endif
N#ifndef	__STDC_CONSTANT_MACROS
S#define	__STDC_CONSTANT_MACROS
N#endif
N#endif
N
N/*
N * GCC 2.95 provides `__restrict' as an extension to C90 to support the
N * C99-specific `restrict' type qualifier.  We happen to use `__restrict' as
N * a way to define the `restrict' type qualifier without disturbing older
N * software that is unaware of C99 keywords.
N * The TI compiler supports __restrict in all compilation modes.
N */
N#if !defined(__TI_COMPILER_VERSION__)
X#if !1L
S#if !(__GNUC__ == 2 && __GNUC_MINOR__ == 95)
S#if !defined(__STDC_VERSION__) || __STDC_VERSION__ < 199901
S#define	__restrict
S#else
S#define	__restrict	restrict
S#endif
S#endif
N#endif
N
N/*
N * GNU C version 2.96 adds explicit branch prediction so that
N * the CPU back-end can hint the processor and also so that
N * code blocks can be reordered such that the predicted path
N * sees a more linear flow, thus improving cache behavior, etc.
N *
N * The following two macros provide us with a way to utilize this
N * compiler feature.  Use __predict_true() if you expect the expression
N * to evaluate to true, and __predict_false() if you expect the
N * expression to evaluate to false.
N *
N * A few notes about usage:
N *
N *	* Generally, __predict_false() error condition checks (unless
N *	  you have some _strong_ reason to do otherwise, in which case
N *	  document it), and/or __predict_true() `no-error' condition
N *	  checks, assuming you want to optimize for the no-error case.
N *
N *	* Other than that, if you don't know the likelihood of a test
N *	  succeeding from empirical or other `hard' evidence, don't
N *	  make predictions.
N *
N *	* These are meant to be used in places that are run `a lot'.
N *	  It is wasteful to make predictions in code that is run
N *	  seldomly (e.g. at subsystem initialization time) as the
N *	  basic block reordering that this affects can often generate
N *	  larger code.
N */
N#if __GNUC_PREREQ__(2, 96)
X#if 0
S#define	__predict_true(exp)     __builtin_expect((exp), 1)
S#define	__predict_false(exp)    __builtin_expect((exp), 0)
N#else
N#define	__predict_true(exp)     (exp)
N#define	__predict_false(exp)    (exp)
N#endif
N
N#if __GNUC_PREREQ__(4, 0)
X#if 0
S#define	__null_sentinel	__attribute__((__sentinel__))
S#define	__exported	__attribute__((__visibility__("default")))
S#define	__hidden	__attribute__((__visibility__("hidden")))
N#else
N#define	__null_sentinel
N#define	__exported
N#define	__hidden
N#endif
N
N/*
N * We define this here since <stddef.h>, <sys/queue.h>, and <sys/types.h>
N * require it.
N */
N#if __GNUC_PREREQ__(4, 1)
X#if 0
S#define	__offsetof(type, field)	 __builtin_offsetof(type, field)
N#else
N#ifndef __cplusplus
S#define	__offsetof(type, field) \
S	((__size_t)(__uintptr_t)((const volatile void *)&((type *)0)->field))
X#define	__offsetof(type, field) 	((__size_t)(__uintptr_t)((const volatile void *)&((type *)0)->field))
N#else
N#define	__offsetof(type, field)					\
N  (__offsetof__ (reinterpret_cast <__size_t>			\
N                 (&reinterpret_cast <const volatile char &>	\
N                  (static_cast<type *> (0)->field))))
X#define	__offsetof(type, field)					  (__offsetof__ (reinterpret_cast <__size_t>			                 (&reinterpret_cast <const volatile char &>	                  (static_cast<type *> (0)->field))))
N#endif
N#endif
N#define	__rangeof(type, start, end) \
N	(__offsetof(type, end) - __offsetof(type, start))
X#define	__rangeof(type, start, end) 	(__offsetof(type, end) - __offsetof(type, start))
N
N/*
N * Given the pointer x to the member m of the struct s, return
N * a pointer to the containing structure.  When using GCC, we first
N * assign pointer x to a local variable, to check that its type is
N * compatible with member m.
N */
N#if __GNUC_PREREQ__(3, 1)
X#if 0
S#define	__containerof(x, s, m) ({					\
S	const volatile __typeof(((s *)0)->m) *__x = (x);		\
S	__DEQUALIFY(s *, (const volatile char *)__x - __offsetof(s, m));\
S})
X#define	__containerof(x, s, m) ({						const volatile __typeof(((s *)0)->m) *__x = (x);			__DEQUALIFY(s *, (const volatile char *)__x - __offsetof(s, m));})
N#else
N#define	__containerof(x, s, m)						\
N	__DEQUALIFY(s *, (const volatile char *)(x) - __offsetof(s, m))
X#define	__containerof(x, s, m)							__DEQUALIFY(s *, (const volatile char *)(x) - __offsetof(s, m))
N#endif
N
N/*
N * Compiler-dependent macros to declare that functions take printf-like
N * or scanf-like arguments.  They are null except for versions of gcc
N * that are known to support the features properly (old versions of gcc-2
N * didn't permit keeping the keywords out of the application namespace).
N */
N#if !__GNUC_PREREQ__(2, 7) && !defined(__INTEL_COMPILER)
X#if !0 && !0L
N#define	__printflike(fmtarg, firstvararg)
N#define	__scanflike(fmtarg, firstvararg)
N#define	__format_arg(fmtarg)
N#define	__strfmonlike(fmtarg, firstvararg)
N#define	__strftimelike(fmtarg, firstvararg)
N#else
S#define	__printflike(fmtarg, firstvararg) \
S	    __attribute__((__format__ (__printf__, fmtarg, firstvararg)))
X#define	__printflike(fmtarg, firstvararg) 	    __attribute__((__format__ (__printf__, fmtarg, firstvararg)))
S#define	__scanflike(fmtarg, firstvararg) \
S	    __attribute__((__format__ (__scanf__, fmtarg, firstvararg)))
X#define	__scanflike(fmtarg, firstvararg) 	    __attribute__((__format__ (__scanf__, fmtarg, firstvararg)))
S#define	__format_arg(fmtarg)	__attribute__((__format_arg__ (fmtarg)))
S#define	__strfmonlike(fmtarg, firstvararg) \
S	    __attribute__((__format__ (__strfmon__, fmtarg, firstvararg)))
X#define	__strfmonlike(fmtarg, firstvararg) 	    __attribute__((__format__ (__strfmon__, fmtarg, firstvararg)))
S#define	__strftimelike(fmtarg, firstvararg) \
S	    __attribute__((__format__ (__strftime__, fmtarg, firstvararg)))
X#define	__strftimelike(fmtarg, firstvararg) 	    __attribute__((__format__ (__strftime__, fmtarg, firstvararg)))
N#endif
N
N/* Compiler-dependent macros that rely on FreeBSD-specific extensions. */
N#if defined(__FreeBSD_cc_version) && __FreeBSD_cc_version >= 300001 && \
N    defined(__GNUC__) && !defined(__INTEL_COMPILER)
X#if 0L && __FreeBSD_cc_version >= 300001 &&     0L && !0L
S#define	__printf0like(fmtarg, firstvararg) \
S	    __attribute__((__format__ (__printf0__, fmtarg, firstvararg)))
X#define	__printf0like(fmtarg, firstvararg) 	    __attribute__((__format__ (__printf0__, fmtarg, firstvararg)))
N#else
N#define	__printf0like(fmtarg, firstvararg)
N#endif
N
N#if defined(__GNUC__) || defined(__INTEL_COMPILER)
X#if 0L || 0L
S#ifndef __INTEL_COMPILER
S#define	__strong_reference(sym,aliassym)	\
S	extern __typeof (sym) aliassym __attribute__ ((__alias__ (#sym)))
X#define	__strong_reference(sym,aliassym)		extern __typeof (sym) aliassym __attribute__ ((__alias__ (#sym)))
S#endif
S#ifdef __STDC__
S#define	__weak_reference(sym,alias)	\
S	__asm__(".weak " #alias);	\
S	__asm__(".equ "  #alias ", " #sym)
X#define	__weak_reference(sym,alias)		__asm__(".weak " #alias);		__asm__(".equ "  #alias ", " #sym)
S#define	__warn_references(sym,msg)	\
S	__asm__(".section .gnu.warning." #sym);	\
S	__asm__(".asciz \"" msg "\"");	\
S	__asm__(".previous")
X#define	__warn_references(sym,msg)		__asm__(".section .gnu.warning." #sym);		__asm__(".asciz \"" msg "\"");		__asm__(".previous")
S#define	__sym_compat(sym,impl,verid)	\
S	__asm__(".symver " #impl ", " #sym "@" #verid)
X#define	__sym_compat(sym,impl,verid)		__asm__(".symver " #impl ", " #sym "@" #verid)
S#define	__sym_default(sym,impl,verid)	\
S	__asm__(".symver " #impl ", " #sym "@@@" #verid)
X#define	__sym_default(sym,impl,verid)		__asm__(".symver " #impl ", " #sym "@@@" #verid)
S#else
S#define	__weak_reference(sym,alias)	\
S	__asm__(".weak alias");		\
S	__asm__(".equ alias, sym")
X#define	__weak_reference(sym,alias)		__asm__(".weak alias");			__asm__(".equ alias, sym")
S#define	__warn_references(sym,msg)	\
S	__asm__(".section .gnu.warning.sym"); \
S	__asm__(".asciz \"msg\"");	\
S	__asm__(".previous")
X#define	__warn_references(sym,msg)		__asm__(".section .gnu.warning.sym"); 	__asm__(".asciz \"msg\"");		__asm__(".previous")
S#define	__sym_compat(sym,impl,verid)	\
S	__asm__(".symver impl, sym@verid")
X#define	__sym_compat(sym,impl,verid)		__asm__(".symver impl, sym@verid")
S#define	__sym_default(impl,sym,verid)	\
S	__asm__(".symver impl, sym@@@verid")
X#define	__sym_default(impl,sym,verid)		__asm__(".symver impl, sym@@@verid")
S#endif	/* __STDC__ */
N#endif	/* __GNUC__ || __INTEL_COMPILER */
N
N#define	__GLOBL1(sym)	__asm__(".globl " #sym)
N#define	__GLOBL(sym)	__GLOBL1(sym)
N
N#if defined(__GNUC__) || defined(__INTEL_COMPILER)
X#if 0L || 0L
S#define	__IDSTRING(name,string)	__asm__(".ident\t\"" string "\"")
N#else
N/*
N * The following definition might not work well if used in header files,
N * but it should be better than nothing.  If you want a "do nothing"
N * version, then it should generate some harmless declaration, such as:
N *    #define	__IDSTRING(name,string)	struct __hack
N */
N#define	__IDSTRING(name,string)	static const char name[] __unused = string
N#endif
N
N#if defined(__TI_COMPILER_VERSION__) && defined(__TI_STRICT_ANSI_MODE__)
X#if 1L && 1L
N#define __extension__
N#endif
N
N/*
N * Embed the rcs id of a source file in the resulting library.  Note that in
N * more recent ELF binutils, we use .ident allowing the ID to be stripped.
N * Usage:
N *	__FBSDID("$FreeBSD$");
N */
N#ifndef	__FBSDID
N#if !defined(lint) && !defined(STRIP_FBSDID)
X#if !0L && !0L
N#define	__FBSDID(s)	__IDSTRING(__CONCAT(__rcsid_,__LINE__),s)
N#else
S#define	__FBSDID(s)	struct __hack
N#endif
N#endif
N
N#ifndef	__RCSID
N#ifndef	NO__RCSID
N#define	__RCSID(s)	__IDSTRING(__CONCAT(__rcsid_,__LINE__),s)
N#else
S#define	__RCSID(s)	struct __hack
N#endif
N#endif
N
N#ifndef	__RCSID_SOURCE
N#ifndef	NO__RCSID_SOURCE
N#define	__RCSID_SOURCE(s)	__IDSTRING(__CONCAT(__rcsid_source_,__LINE__),s)
N#else
S#define	__RCSID_SOURCE(s)	struct __hack
N#endif
N#endif
N
N#ifndef	__SCCSID
N#ifndef	NO__SCCSID
N#define	__SCCSID(s)	__IDSTRING(__CONCAT(__sccsid_,__LINE__),s)
N#else
S#define	__SCCSID(s)	struct __hack
N#endif
N#endif
N
N#ifndef	__COPYRIGHT
N#ifndef	NO__COPYRIGHT
N#define	__COPYRIGHT(s)	__IDSTRING(__CONCAT(__copyright_,__LINE__),s)
N#else
S#define	__COPYRIGHT(s)	struct __hack
N#endif
N#endif
N
N#ifndef	__DECONST
N#define	__DECONST(type, var)	((type)(__uintptr_t)(const void *)(var))
N#endif
N
N#ifndef	__DEVOLATILE
N#define	__DEVOLATILE(type, var)	((type)(__uintptr_t)(volatile void *)(var))
N#endif
N
N#ifndef	__DEQUALIFY
N#define	__DEQUALIFY(type, var)	((type)(__uintptr_t)(const volatile void *)(var))
N#endif
N
N/*-
N * The following definitions are an extension of the behavior originally
N * implemented in <sys/_posix.h>, but with a different level of granularity.
N * POSIX.1 requires that the macros we test be defined before any standard
N * header file is included.
N *
N * Here's a quick run-down of the versions:
N *  defined(_POSIX_SOURCE)		1003.1-1988
N *  _POSIX_C_SOURCE == 1		1003.1-1990
N *  _POSIX_C_SOURCE == 2		1003.2-1992 C Language Binding Option
N *  _POSIX_C_SOURCE == 199309		1003.1b-1993
N *  _POSIX_C_SOURCE == 199506		1003.1c-1995, 1003.1i-1995,
N *					and the omnibus ISO/IEC 9945-1: 1996
N *  _POSIX_C_SOURCE == 200112		1003.1-2001
N *  _POSIX_C_SOURCE == 200809		1003.1-2008
N *
N * In addition, the X/Open Portability Guide, which is now the Single UNIX
N * Specification, defines a feature-test macro which indicates the version of
N * that specification, and which subsumes _POSIX_C_SOURCE.
N *
N * Our macros begin with two underscores to avoid namespace screwage.
N */
N
N/* Deal with IEEE Std. 1003.1-1990, in which _POSIX_C_SOURCE == 1. */
N#if defined(_POSIX_C_SOURCE) && _POSIX_C_SOURCE == 1
X#if 0L && _POSIX_C_SOURCE == 1
S#undef _POSIX_C_SOURCE		/* Probably illegal, but beyond caring now. */
S#define	_POSIX_C_SOURCE		199009
N#endif
N
N/* Deal with IEEE Std. 1003.2-1992, in which _POSIX_C_SOURCE == 2. */
N#if defined(_POSIX_C_SOURCE) && _POSIX_C_SOURCE == 2
X#if 0L && _POSIX_C_SOURCE == 2
S#undef _POSIX_C_SOURCE
S#define	_POSIX_C_SOURCE		199209
N#endif
N
N/* Deal with various X/Open Portability Guides and Single UNIX Spec. */
N#ifdef _XOPEN_SOURCE
S#if _XOPEN_SOURCE - 0 >= 700
S#define	__XSI_VISIBLE		700
S#undef _POSIX_C_SOURCE
S#define	_POSIX_C_SOURCE		200809
S#elif _XOPEN_SOURCE - 0 >= 600
S#define	__XSI_VISIBLE		600
S#undef _POSIX_C_SOURCE
S#define	_POSIX_C_SOURCE		200112
S#elif _XOPEN_SOURCE - 0 >= 500
S#define	__XSI_VISIBLE		500
S#undef _POSIX_C_SOURCE
S#define	_POSIX_C_SOURCE		199506
S#endif
N#endif
N
N/*
N * Deal with all versions of POSIX.  The ordering relative to the tests above is
N * important.
N */
N#if defined(_POSIX_SOURCE) && !defined(_POSIX_C_SOURCE)
X#if 0L && !0L
S#define	_POSIX_C_SOURCE		198808
N#endif
N#ifdef _POSIX_C_SOURCE
S#if _POSIX_C_SOURCE >= 200809
S#define	__POSIX_VISIBLE		200809
S#define	__ISO_C_VISIBLE		1999
S#elif _POSIX_C_SOURCE >= 200112
S#define	__POSIX_VISIBLE		200112
S#define	__ISO_C_VISIBLE		1999
S#elif _POSIX_C_SOURCE >= 199506
S#define	__POSIX_VISIBLE		199506
S#define	__ISO_C_VISIBLE		1990
S#elif _POSIX_C_SOURCE >= 199309
S#define	__POSIX_VISIBLE		199309
S#define	__ISO_C_VISIBLE		1990
S#elif _POSIX_C_SOURCE >= 199209
S#define	__POSIX_VISIBLE		199209
S#define	__ISO_C_VISIBLE		1990
S#elif _POSIX_C_SOURCE >= 199009
S#define	__POSIX_VISIBLE		199009
S#define	__ISO_C_VISIBLE		1990
S#else
S#define	__POSIX_VISIBLE		198808
S#define	__ISO_C_VISIBLE		0
S#endif /* _POSIX_C_SOURCE */
N#else
N/*-
N * Deal with _ANSI_SOURCE:
N * If it is defined, and no other compilation environment is explicitly
N * requested, then define our internal feature-test macros to zero.  This
N * makes no difference to the preprocessor (undefined symbols in preprocessing
N * expressions are defined to have value zero), but makes it more convenient for
N * a test program to print out the values.
N *
N * If a program mistakenly defines _ANSI_SOURCE and some other macro such as
N * _POSIX_C_SOURCE, we will assume that it wants the broader compilation
N * environment (and in fact we will never get here).
N */
N#if defined(_ANSI_SOURCE)	/* Hide almost everything. */
X#if 0L	 
S#define	__POSIX_VISIBLE		0
S#define	__XSI_VISIBLE		0
S#define	__BSD_VISIBLE		0
S#define	__ISO_C_VISIBLE		1990
S#define	__EXT1_VISIBLE		0
S#elif defined(_C99_SOURCE)	/* Localism to specify strict C99 env. */
X#elif 0L	 
S#define	__POSIX_VISIBLE		0
S#define	__XSI_VISIBLE		0
S#define	__BSD_VISIBLE		0
S#define	__ISO_C_VISIBLE		1999
S#define	__EXT1_VISIBLE		0
S#elif defined(_C11_SOURCE)	/* Localism to specify strict C11 env. */
X#elif 0L	 
S#define	__POSIX_VISIBLE		0
S#define	__XSI_VISIBLE		0
S#define	__BSD_VISIBLE		0
S#define	__ISO_C_VISIBLE		2011
S#define	__EXT1_VISIBLE		0
N#else				/* Default environment: show everything. */
N#define	__POSIX_VISIBLE		200809
N#define	__XSI_VISIBLE		700
N#define	__BSD_VISIBLE		1
N#define	__ISO_C_VISIBLE		2011
N#define	__EXT1_VISIBLE		1
N#endif
N#endif
N
N/* User override __EXT1_VISIBLE */
N#if defined(__STDC_WANT_LIB_EXT1__)
X#if 0L
S#undef	__EXT1_VISIBLE
S#if __STDC_WANT_LIB_EXT1__
S#define	__EXT1_VISIBLE		1
S#else
S#define	__EXT1_VISIBLE		0
S#endif
N#endif /* __STDC_WANT_LIB_EXT1__ */
N
N#if defined(__mips) || defined(__powerpc64__) || defined(__riscv)
X#if 0L || 0L || 0L
S#define	__NO_TLS 1
N#endif
N
N/*
N * Old versions of GCC use non-standard ARM arch symbols; acle-compat.h
N * translates them to __ARM_ARCH and the modern feature symbols defined by ARM.
N */
N#if defined(__arm__) && !defined(__ARM_ARCH)
X#if 0L && !1L
S#include <machine/acle-compat.h>
N#endif
N
N/*
N * Nullability qualifiers: currently only supported by Clang.
N */
N#if !(defined(__clang__) && __has_feature(nullability))
X#if !(0L && 0)
N#define	_Nonnull
N#define	_Nullable
N#define	_Null_unspecified
N#define	__NULLABILITY_PRAGMA_PUSH
N#define	__NULLABILITY_PRAGMA_POP
N#else
S#define	__NULLABILITY_PRAGMA_PUSH _Pragma("clang diagnostic push")	\
S	_Pragma("clang diagnostic ignored \"-Wnullability-completeness\"")
X#define	__NULLABILITY_PRAGMA_PUSH _Pragma("clang diagnostic push")		_Pragma("clang diagnostic ignored \"-Wnullability-completeness\"")
S#define	__NULLABILITY_PRAGMA_POP _Pragma("clang diagnostic pop")
N#endif
N
N/*
N * Type Safety Checking
N *
N * Clang provides additional attributes to enable checking type safety
N * properties that cannot be enforced by the C type system. 
N */
N
N#if __has_attribute(__argument_with_type_tag__) && \
N    __has_attribute(__type_tag_for_datatype__)
X#if 0 &&     0
S#define	__arg_type_tag(arg_kind, arg_idx, type_tag_idx) \
S	    __attribute__((__argument_with_type_tag__(arg_kind, arg_idx, type_tag_idx)))
X#define	__arg_type_tag(arg_kind, arg_idx, type_tag_idx) 	    __attribute__((__argument_with_type_tag__(arg_kind, arg_idx, type_tag_idx)))
S#define	__datatype_type_tag(kind, type) \
S	    __attribute__((__type_tag_for_datatype__(kind, type)))
X#define	__datatype_type_tag(kind, type) 	    __attribute__((__type_tag_for_datatype__(kind, type)))
N#else
N#define	__arg_type_tag(arg_kind, arg_idx, type_tag_idx)
N#define	__datatype_type_tag(kind, type)
N#endif
N
N/*
N * Lock annotations.
N *
N * Clang provides support for doing basic thread-safety tests at
N * compile-time, by marking which locks will/should be held when
N * entering/leaving a functions.
N *
N * Furthermore, it is also possible to annotate variables and structure
N * members to enforce that they are only accessed when certain locks are
N * held.
N */
N
N#if __has_extension(c_thread_safety_attributes)
X#if 0
S#define	__lock_annotate(x)	__attribute__((x))
N#else
N#define	__lock_annotate(x)
N#endif
N
N/* Structure implements a lock. */
N#define	__lockable		__lock_annotate(lockable)
N
N/* Function acquires an exclusive or shared lock. */
N#define	__locks_exclusive(...) \
N	__lock_annotate(exclusive_lock_function(__VA_ARGS__))
X#define	__locks_exclusive(...) 	__lock_annotate(exclusive_lock_function(__VA_ARGS__))
N#define	__locks_shared(...) \
N	__lock_annotate(shared_lock_function(__VA_ARGS__))
X#define	__locks_shared(...) 	__lock_annotate(shared_lock_function(__VA_ARGS__))
N
N/* Function attempts to acquire an exclusive or shared lock. */
N#define	__trylocks_exclusive(...) \
N	__lock_annotate(exclusive_trylock_function(__VA_ARGS__))
X#define	__trylocks_exclusive(...) 	__lock_annotate(exclusive_trylock_function(__VA_ARGS__))
N#define	__trylocks_shared(...) \
N	__lock_annotate(shared_trylock_function(__VA_ARGS__))
X#define	__trylocks_shared(...) 	__lock_annotate(shared_trylock_function(__VA_ARGS__))
N
N/* Function releases a lock. */
N#define	__unlocks(...)		__lock_annotate(unlock_function(__VA_ARGS__))
N
N/* Function asserts that an exclusive or shared lock is held. */
N#define	__asserts_exclusive(...) \
N	__lock_annotate(assert_exclusive_lock(__VA_ARGS__))
X#define	__asserts_exclusive(...) 	__lock_annotate(assert_exclusive_lock(__VA_ARGS__))
N#define	__asserts_shared(...) \
N	__lock_annotate(assert_shared_lock(__VA_ARGS__))
X#define	__asserts_shared(...) 	__lock_annotate(assert_shared_lock(__VA_ARGS__))
N
N/* Function requires that an exclusive or shared lock is or is not held. */
N#define	__requires_exclusive(...) \
N	__lock_annotate(exclusive_locks_required(__VA_ARGS__))
X#define	__requires_exclusive(...) 	__lock_annotate(exclusive_locks_required(__VA_ARGS__))
N#define	__requires_shared(...) \
N	__lock_annotate(shared_locks_required(__VA_ARGS__))
X#define	__requires_shared(...) 	__lock_annotate(shared_locks_required(__VA_ARGS__))
N#define	__requires_unlocked(...) \
N	__lock_annotate(locks_excluded(__VA_ARGS__))
X#define	__requires_unlocked(...) 	__lock_annotate(locks_excluded(__VA_ARGS__))
N
N/* Function should not be analyzed. */
N#define	__no_lock_analysis	__lock_annotate(no_thread_safety_analysis)
N
N/* Guard variables and structure members by lock. */
N#define	__guarded_by(x)		__lock_annotate(guarded_by(x))
N#define	__pt_guarded_by(x)	__lock_annotate(pt_guarded_by(x))
N
N#ifdef __TI_COMPILER_VERSION__
N#pragma diag_pop
N#endif
N
N#endif /* !_SYS_CDEFS_H_ */
L 35 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/sys/stdint.h" 2
N#include <sys/_types.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/sys/_types.h" 1
N/*-
N * SPDX-License-Identifier: BSD-2-Clause-FreeBSD
N *
N * Copyright (c) 2002 Mike Barcroft <mike@FreeBSD.org>
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N * 1. Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
N * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
N * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
N * SUCH DAMAGE.
N *
N * $FreeBSD$
N */
N
N#ifndef _SYS__TYPES_H_
N#define _SYS__TYPES_H_
N
N#include <sys/cdefs.h>
N#include <machine/_types.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/machine/_types.h" 1
N/*-
N * SPDX-License-Identifier: BSD-4-Clause
N *
N * Copyright (c) 2002 Mike Barcroft <mike@FreeBSD.org>
N * Copyright (c) 1990, 1993
N *	The Regents of the University of California.  All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N * 1. Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N * 3. All advertising materials mentioning features or use of this software
N *    must display the following acknowledgement:
N *	This product includes software developed by the University of
N *	California, Berkeley and its contributors.
N * 4. Neither the name of the University nor the names of its contributors
N *    may be used to endorse or promote products derived from this software
N *    without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
N * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
N * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
N * SUCH DAMAGE.
N *
N *	From: @(#)ansi.h	8.2 (Berkeley) 1/4/94
N *	From: @(#)types.h	8.3 (Berkeley) 1/5/94
N * $FreeBSD$
N */
N
N#ifndef _MACHINE__TYPES_H_
N#define	_MACHINE__TYPES_H_
N
N#ifndef _SYS_CDEFS_H_
S#error this file needs sys/cdefs.h as a prerequisite
N#endif
N
N#ifdef __TI_COMPILER_VERSION__
N#pragma diag_push
N/* This file is required to use base types */
N#pragma CHECK_MISRA("-6.3")
N#endif
N
N/*
N * Basic types upon which most other types are built.
N */
Ntypedef	signed char		__int8_t;
Ntypedef	unsigned char		__uint8_t;
Ntypedef	short			__int16_t;
Ntypedef	unsigned short		__uint16_t;
Ntypedef	int			__int32_t;
Ntypedef	unsigned int		__uint32_t;
N#ifndef lint
N__extension__
X
N#endif
N/* LONGLONG */
Ntypedef	long long		__int64_t;
N#ifndef lint
N__extension__
X
N#endif
N/* LONGLONG */
Ntypedef	unsigned long long	__uint64_t;
N
N/*
N * Standard type definitions.
N */
Ntypedef	__uint32_t	__clock_t;		/* clock()... */
Ntypedef	__int32_t	__critical_t;
Ntypedef	double		__double_t;
Ntypedef	float		__float_t;
Ntypedef	__int32_t	__intfptr_t;
Ntypedef	__int64_t	__intmax_t;
Ntypedef	__int32_t	__intptr_t;
Ntypedef	__int32_t	__int_fast8_t;
Ntypedef	__int32_t	__int_fast16_t;
Ntypedef	__int32_t	__int_fast32_t;
Ntypedef	__int64_t	__int_fast64_t;
Ntypedef	__int8_t	__int_least8_t;
Ntypedef	__int16_t	__int_least16_t;
Ntypedef	__int32_t	__int_least32_t;
Ntypedef	__int64_t	__int_least64_t;
Ntypedef	__int32_t	__ptrdiff_t;		/* ptr1 - ptr2 */
Ntypedef	__int32_t	__register_t;
Ntypedef	__int32_t	__segsz_t;		/* segment size (in pages) */
Ntypedef	__uint32_t	__size_t;		/* sizeof() */
Ntypedef	__int32_t	__ssize_t;		/* byte count or error */
N#if (defined(__TI_TIME_USES_64) && __TI_TIME_USES_64)
X#if (0L && __TI_TIME_USES_64)
Stypedef	__int64_t	__time_t;		/* time()... */
N#else
Ntypedef __uint32_t      __time_t;
N#endif
Ntypedef	__uint32_t	__uintfptr_t;
Ntypedef	__uint64_t	__uintmax_t;
Ntypedef	__uint32_t	__uintptr_t;
Ntypedef	__uint32_t	__uint_fast8_t;
Ntypedef	__uint32_t	__uint_fast16_t;
Ntypedef	__uint32_t	__uint_fast32_t;
Ntypedef	__uint64_t	__uint_fast64_t;
Ntypedef	__uint8_t	__uint_least8_t;
Ntypedef	__uint16_t	__uint_least16_t;
Ntypedef	__uint32_t	__uint_least32_t;
Ntypedef	__uint64_t	__uint_least64_t;
Ntypedef	__uint32_t	__u_register_t;
Ntypedef	__uint32_t	__vm_offset_t;
Ntypedef	__uint32_t	__vm_paddr_t;
Ntypedef	__uint32_t	__vm_size_t;
N
N# ifdef __clang__
Stypedef __WCHAR_TYPE__ __WCHAR_T_TYPE__;
N# endif
Ntypedef	__WCHAR_T_TYPE__ ___wchar_t;
Xtypedef	unsigned short ___wchar_t;
N
N#define	__WCHAR_MIN	0		/* min value for a wchar_t */
N
N#ifdef __TI_COMPILER_VERSION__
N#if !defined(__TI_WCHAR_T_BITS__) || __TI_WCHAR_T_BITS__ == 16
X#if !1L || 16 == 16
N#    define __WCHAR_MAX 0xffffu
N#else
S#    define __WCHAR_MAX 0xffffffffu
N#endif
N#else
S#define	__WCHAR_MAX	__UINT_MAX	/* max value for a wchar_t */
N#endif
N
N/*
N * Unusual type definitions.
N */
N#ifdef __TI_COMPILER_VERSION__
Ntypedef struct __va_list_t {
N    void * __ap;
N} __va_list;
N#elif defined(__GNUCLIKE_BUILTIN_VARARGS)
Stypedef __builtin_va_list	__va_list;	/* internally known to gcc */
S#else
Stypedef	char *			__va_list;
N#endif /* __GNUCLIKE_BUILTIN_VARARGS */
N#if defined(__GNUCLIKE_BUILTIN_VAALIST) \
N    && !defined(__NO_GNUC_VA_LIST) && !defined(__GNUC_VA_LIST)
X#if 0L     && !0L && !0L
S#define __GNUC_VA_LIST	1
Stypedef __va_list		__gnuc_va_list;	/* compatibility w/GNU headers*/
N#endif
N
N#if defined(__TI_COMPILER_VERSION__)
X#if 1L
N#pragma diag_pop
N#endif
N
N#endif /* !_MACHINE__TYPES_H_ */
L 36 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/sys/_types.h" 2
N
N#if defined(__TI_COMPILER_VERSION__)
X#if 1L
N#pragma diag_push
N/* This file is required to use types without size and signedness */
N#pragma CHECK_MISRA("-6.3")
N#endif
N
N/*
N * Standard type definitions.
N */
Ntypedef	__int32_t	__blksize_t;	/* file block size */
Ntypedef	__int64_t	__blkcnt_t;	/* file block count */
Ntypedef	__int32_t	__clockid_t;	/* clock_gettime()... */
Ntypedef	__uint32_t	__fflags_t;	/* file flags */
Ntypedef	__uint64_t	__fsblkcnt_t;
Ntypedef	__uint64_t	__fsfilcnt_t;
Ntypedef	__uint32_t	__gid_t;
Ntypedef	__int64_t	__id_t;		/* can hold a gid_t, pid_t, or uid_t */
Ntypedef	__uint64_t	__ino_t;	/* inode number */
Ntypedef	long		__key_t;	/* IPC key (for Sys V IPC) */
Ntypedef	__int32_t	__lwpid_t;	/* Thread ID (a.k.a. LWP) */
Ntypedef	__uint16_t	__mode_t;	/* permissions */
Ntypedef	int		__accmode_t;	/* access permissions */
Ntypedef	int		__nl_item;
Ntypedef	__uint64_t	__nlink_t;	/* link count */
Ntypedef	__int64_t	__off_t;	/* file offset */
Ntypedef	__int64_t	__off64_t;	/* file offset (alias) */
Ntypedef	__int32_t	__pid_t;	/* process [group] */
Ntypedef	__int64_t	__rlim_t;	/* resource limit - intentionally */
N					/* signed, because of legacy code */
N					/* that uses -1 for RLIM_INFINITY */
N#if defined(__TI_COMPILER_VERSION__) &&  defined(__TMS320C2000__)
X#if 1L &&  0L
Stypedef	__uint16_t	__sa_family_t;
N#else
Ntypedef	__uint8_t	__sa_family_t;
N#endif
Ntypedef	__uint32_t	__socklen_t;
Ntypedef	long		__suseconds_t;	/* microseconds (signed) */
Ntypedef	struct __timer	*__timer_t;	/* timer_gettime()... */
Ntypedef	struct __mq	*__mqd_t;	/* mq_open()... */
Ntypedef	__uint32_t	__uid_t;
Ntypedef	unsigned int	__useconds_t;	/* microseconds (unsigned) */
Ntypedef	int		__cpuwhich_t;	/* which parameter for cpuset. */
Ntypedef	int		__cpulevel_t;	/* level parameter for cpuset. */
Ntypedef int		__cpusetid_t;	/* cpuset identifier. */
N
N/*
N * Unusual type definitions.
N */
N/*
N * rune_t is declared to be an ``int'' instead of the more natural
N * ``unsigned long'' or ``long''.  Two things are happening here.  It is not
N * unsigned so that EOF (-1) can be naturally assigned to it and used.  Also,
N * it looks like 10646 will be a 31 bit standard.  This means that if your
N * ints cannot hold 32 bits, you will be in trouble.  The reason an int was
N * chosen over a long is that the is*() and to*() routines take ints (says
N * ANSI C), but they use __ct_rune_t instead of int.
N *
N * NOTE: rune_t is not covered by ANSI nor other standards, and should not
N * be instantiated outside of lib/libc/locale.  Use wchar_t.  wint_t and
N * rune_t must be the same type.  Also, wint_t should be able to hold all
N * members of the largest character set plus one extra value (WEOF), and
N * must be at least 16 bits.
N */
N#if defined(__TI_COMPILER_VERSION__) && \
N    defined(__TMS320C2000__) && defined(__TI_EABI__)
X#if 1L &&     0L && 1L
Stypedef	unsigned long	__ct_rune_t;	/* arg type for ctype funcs */
N#else
Ntypedef	int		__ct_rune_t;	/* arg type for ctype funcs */
N#endif
N
Ntypedef	__ct_rune_t	__rune_t;	/* rune_t (see above) */
Ntypedef	__ct_rune_t	__wint_t;	/* wint_t (see above) */
N
N/* Clang already provides these types as built-ins, but only in C++ mode. */
N#if !defined(__clang__) || !defined(__cplusplus)
X#if !0L || !1L
Ntypedef	__uint_least16_t __char16_t;
Ntypedef	__uint_least32_t __char32_t;
N#endif
N/* In C++11, char16_t and char32_t are built-in types. */
N#if defined(__cplusplus) && __cplusplus >= 201103L
X#if 1L && 201402L >= 201103L
N#define	_CHAR16_T_DECLARED
N#define	_CHAR32_T_DECLARED
N#endif
N
Ntypedef struct {
N	long long __max_align1 __attribute__((aligned(_Alignof(long long))));
X	long long __max_align1 __attribute__((aligned(alignof(long long))));
N	long double __max_align2 __attribute__((aligned(_Alignof(long double))));
X	long double __max_align2 __attribute__((aligned(alignof(long double))));
N} __max_align_t;
N
Ntypedef	__uint64_t	__dev_t;	/* device number */
N
Ntypedef	__uint32_t	__fixpt_t;	/* fixed point number */
N
N/*
N * mbstate_t is an opaque object to keep conversion state during multibyte
N * stream conversions.
N */
N
N#ifdef __TI_COMPILER_VERSION__
N#if defined(_AEABI_PORTABILITY_LEVEL) && _AEABI_PORTABILITY_LEVEL != 0
X#if 0L && _AEABI_PORTABILITY_LEVEL != 0
Stypedef struct _Mbstatet
S{
S    unsigned int __state, __state2;
S} _Mbstatet;
N#else
Ntypedef int _Mbstatet;
N#endif /* _AEABI_PORTABILITY_LEVEL */
N
Ntypedef _Mbstatet __mbstate_t;
N#else
Stypedef union {
S	char		__mbstate8[128];
S	__int64_t	_mbstateL;	/* for alignment */
S} __mbstate_t;
N#endif
N
Ntypedef __uintmax_t     __rman_res_t;
N
N/*
N * When the following macro is defined, the system uses 64-bit inode numbers.
N * Programs can use this to avoid including <sys/param.h>, with its associated
N * namespace pollution.
N */
N#define	__INO64
N
N#if defined(__TI_COMPILER_VERSION__)
X#if 1L
N#pragma diag_pop
N#endif
N
N#endif /* !_SYS__TYPES_H_ */
L 36 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/sys/stdint.h" 2
N
N#include <machine/_stdint.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/machine/_stdint.h" 1
N/*-
N * SPDX-License-Identifier: BSD-2-Clause-NetBSD
N *
N * Copyright (c) 2001, 2002 Mike Barcroft <mike@FreeBSD.org>
N * Copyright (c) 2001 The NetBSD Foundation, Inc.
N * All rights reserved.
N *
N * This code is derived from software contributed to The NetBSD Foundation
N * by Klaus Klein.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N * 1. Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
N * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
N * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
N * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
N * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *
N * $FreeBSD$
N */
N
N#ifndef _MACHINE__STDINT_H_
N#define	_MACHINE__STDINT_H_
N
N#pragma diag_push
N/* 19.4 is issued for macros that are defined in terms of other macros. */
N#pragma CHECK_MISRA("-19.4")
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !1L || 1L
N
N#define	INT8_C(c)		(c)
N#define	INT16_C(c)		(c)
N#define	INT32_C(c)		(c)
N#define	INT64_C(c)		(c ## LL)
N
N#define	UINT8_C(c)		(c)
N#define	UINT16_C(c)		(c)
N#define	UINT32_C(c)		(c ## U)
N#define	UINT64_C(c)		(c ## ULL)
N
N#define	INTMAX_C(c)		INT64_C(c)
N#define	UINTMAX_C(c)		UINT64_C(c)
N
N#endif /* !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS) */
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !1L || 1L
N
N/*
N * ISO/IEC 9899:1999
N * 7.18.2.1 Limits of exact-width integer types
N */
N/* Minimum values of exact-width signed integer types. */
N#define	INT8_MIN	(-0x7f-1)
N#define	INT16_MIN	(-0x7fff-1)
N#define	INT32_MIN	(-0x7fffffff-1)
N#define	INT64_MIN	(-0x7fffffffffffffffLL-1)
N
N/* Maximum values of exact-width signed integer types. */
N#define	INT8_MAX	0x7f
N#define	INT16_MAX	0x7fff
N#define	INT32_MAX	0x7fffffff
N#define	INT64_MAX	0x7fffffffffffffffLL
N
N/* Maximum values of exact-width unsigned integer types. */
N#define	UINT8_MAX	0xff
N#define	UINT16_MAX	0xffff
N#define	UINT32_MAX	0xffffffffU
N#define	UINT64_MAX	0xffffffffffffffffULL
N
N/*
N * ISO/IEC 9899:1999
N * 7.18.2.2  Limits of minimum-width integer types
N */
N/* Minimum values of minimum-width signed integer types. */
N#define	INT_LEAST8_MIN	INT8_MIN
N#define	INT_LEAST16_MIN	INT16_MIN
N#define	INT_LEAST32_MIN	INT32_MIN
N#define	INT_LEAST64_MIN	INT64_MIN
N
N/* Maximum values of minimum-width signed integer types. */
N#define	INT_LEAST8_MAX	INT8_MAX
N#define	INT_LEAST16_MAX	INT16_MAX
N#define	INT_LEAST32_MAX	INT32_MAX
N#define	INT_LEAST64_MAX	INT64_MAX
N
N/* Maximum values of minimum-width unsigned integer types. */
N#define	UINT_LEAST8_MAX	 UINT8_MAX
N#define	UINT_LEAST16_MAX UINT16_MAX
N#define	UINT_LEAST32_MAX UINT32_MAX
N#define	UINT_LEAST64_MAX UINT64_MAX
N
N/*
N * ISO/IEC 9899:1999
N * 7.18.2.3  Limits of fastest minimum-width integer types
N */
N/* Minimum values of fastest minimum-width signed integer types. */
N#define	INT_FAST8_MIN	INT32_MIN
N#define	INT_FAST16_MIN	INT32_MIN
N#define	INT_FAST32_MIN	INT32_MIN
N#define	INT_FAST64_MIN	INT64_MIN
N
N/* Maximum values of fastest minimum-width signed integer types. */
N#define	INT_FAST8_MAX	INT32_MAX
N#define	INT_FAST16_MAX	INT32_MAX
N#define	INT_FAST32_MAX	INT32_MAX
N#define	INT_FAST64_MAX	INT64_MAX
N
N/* Maximum values of fastest minimum-width unsigned integer types. */
N#define	UINT_FAST8_MAX	UINT32_MAX
N#define	UINT_FAST16_MAX	UINT32_MAX
N#define	UINT_FAST32_MAX	UINT32_MAX
N#define	UINT_FAST64_MAX	UINT64_MAX
N
N/*
N * ISO/IEC 9899:1999
N * 7.18.2.4  Limits of integer types capable of holding object pointers
N */
N#define	INTPTR_MIN	INT32_MIN
N#define	INTPTR_MAX	INT32_MAX
N#define	UINTPTR_MAX	UINT32_MAX
N
N/*
N * ISO/IEC 9899:1999
N * 7.18.2.5  Limits of greatest-width integer types
N */
N#define	INTMAX_MIN	INT64_MIN
N#define	INTMAX_MAX	INT64_MAX
N#define	UINTMAX_MAX	UINT64_MAX
N
N/*
N * ISO/IEC 9899:1999
N * 7.18.3  Limits of other integer types
N */
N/* Limits of ptrdiff_t. */
N#define	PTRDIFF_MIN	INT32_MIN
N#define	PTRDIFF_MAX	INT32_MAX
N
N/* Limits of sig_atomic_t. */
N#define	SIG_ATOMIC_MIN	INT32_MIN
N#define	SIG_ATOMIC_MAX	INT32_MAX
N
N/* Limit of size_t. */
N#define	SIZE_MAX	UINT32_MAX
N
N/* Limits of wint_t. */
N#define	WINT_MIN	INT32_MIN
N#define	WINT_MAX	INT32_MAX
N
N#endif /* !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS) */
N
N#pragma diag_pop
N
N#endif /* !_MACHINE__STDINT_H_ */
L 38 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/sys/stdint.h" 2
N#include <sys/_stdint.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/sys/_stdint.h" 1
N/*-
N * SPDX-License-Identifier: BSD-2-Clause-FreeBSD
N *
N * Copyright (c) 2011 David E. O'Brien <obrien@FreeBSD.org>
N * Copyright (c) 2001 Mike Barcroft <mike@FreeBSD.org>
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N * 1. Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
N * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
N * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
N * SUCH DAMAGE.
N *
N * $FreeBSD$
N */
N
N#ifndef _SYS__STDINT_H_
N#define _SYS__STDINT_H_
N
N#if !defined(__TI_COMPILER_VERSION__) ||  !defined(__TMS320C2000__)
X#if !1L ||  !0L
N#ifndef _INT8_T_DECLARED
Ntypedef	__int8_t		int8_t;
N#define	_INT8_T_DECLARED
N#endif
N#endif
N
N#ifndef _INT16_T_DECLARED
Ntypedef	__int16_t		int16_t;
N#define	_INT16_T_DECLARED
N#endif
N
N#ifndef _INT32_T_DECLARED
Ntypedef	__int32_t		int32_t;
N#define	_INT32_T_DECLARED
N#endif
N
N#ifndef _INT64_T_DECLARED
Ntypedef	__int64_t		int64_t;
N#define	_INT64_T_DECLARED
N#endif
N
N#if !defined(__TI_COMPILER_VERSION__) ||  !defined(__TMS320C2000__)
X#if !1L ||  !0L
N#ifndef _UINT8_T_DECLARED
Ntypedef	__uint8_t		uint8_t;
N#define	_UINT8_T_DECLARED
N#endif
N#endif
N
N#ifndef _UINT16_T_DECLARED
Ntypedef	__uint16_t		uint16_t;
N#define	_UINT16_T_DECLARED
N#endif
N
N#ifndef _UINT32_T_DECLARED
Ntypedef	__uint32_t		uint32_t;
N#define	_UINT32_T_DECLARED
N#endif
N
N#ifndef _UINT64_T_DECLARED
Ntypedef	__uint64_t		uint64_t;
N#define	_UINT64_T_DECLARED
N#endif
N
N#ifndef _INTPTR_T_DECLARED
Ntypedef	__intptr_t		intptr_t;
N#define	_INTPTR_T_DECLARED
N#endif
N#ifndef _UINTPTR_T_DECLARED
Ntypedef	__uintptr_t		uintptr_t;
N#define	_UINTPTR_T_DECLARED
N#endif
N#ifndef _INTMAX_T_DECLARED
Ntypedef	__intmax_t		intmax_t;
N#define	_INTMAX_T_DECLARED
N#endif
N#ifndef _UINTMAX_T_DECLARED
Ntypedef	__uintmax_t		uintmax_t;
N#define	_UINTMAX_T_DECLARED
N#endif
N
N#endif /* !_SYS__STDINT_H_ */
L 39 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/sys/stdint.h" 2
N
Ntypedef	__int_least8_t		int_least8_t;
Ntypedef	__int_least16_t		int_least16_t;
Ntypedef	__int_least32_t		int_least32_t;
Ntypedef	__int_least64_t		int_least64_t;
N
Ntypedef	__uint_least8_t		uint_least8_t;
Ntypedef	__uint_least16_t	uint_least16_t;
Ntypedef	__uint_least32_t	uint_least32_t;
Ntypedef	__uint_least64_t	uint_least64_t;
N
Ntypedef	__int_fast8_t		int_fast8_t;
Ntypedef	__int_fast16_t		int_fast16_t;
Ntypedef	__int_fast32_t		int_fast32_t;
Ntypedef	__int_fast64_t		int_fast64_t;
N
Ntypedef	__uint_fast8_t		uint_fast8_t;
Ntypedef	__uint_fast16_t		uint_fast16_t;
Ntypedef	__uint_fast32_t		uint_fast32_t;
Ntypedef	__uint_fast64_t		uint_fast64_t;
N
N/* GNU and Darwin define this and people seem to think it's portable */
N#if defined(UINTPTR_MAX) && defined(UINT64_MAX) && (UINTPTR_MAX == UINT64_MAX)
X#if 1L && 1L && (0xffffffffU == 0xffffffffffffffffULL)
S#define	__WORDSIZE		64
N#else
N#define	__WORDSIZE		32
N#endif
N
N#pragma diag_push
N#pragma CHECK_MISRA("-19.4")
N/* Limits of wchar_t. */
N#define	WCHAR_MIN	__WCHAR_MIN
N#define	WCHAR_MAX	__WCHAR_MAX
N#pragma diag_pop
N
N#if __EXT1_VISIBLE
X#if 1
N/* ISO/IEC 9899:2011 K.3.4.4 */
N#ifndef RSIZE_MAX
N#define RSIZE_MAX (SIZE_MAX >> 1)
N#endif
N#endif /* __EXT1_VISIBLE */
N
N#endif /* !_SYS_STDINT_H_ */
L 43 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/stdint.h" 2
N#else
S/* 7.18.1.1 Exact-width integer types */
S
S#if defined(__MSP430__) || defined(__TMS320C55X_PLUS_BYTE__)
S    typedef   signed char    int8_t;
S    typedef unsigned char   uint8_t;
S    typedef          int    int16_t;
S    typedef unsigned int   uint16_t;
S    typedef          long   int32_t;
S    typedef unsigned long  uint32_t;
S#elif defined(_TMS320C5XX) || defined(__TMS320C55X__)
S    typedef          int    int16_t;
S    typedef unsigned int   uint16_t;
S    typedef          long   int32_t;
S    typedef unsigned long  uint32_t;
S#elif defined(_TMS320C6X) || defined(__ARM_ARCH) || defined(__ARP32__) || \
S      defined(__PRU__)    || defined(__C7000__)
X#elif defined(_TMS320C6X) || defined(__ARM_ARCH) || defined(__ARP32__) ||       defined(__PRU__)    || defined(__C7000__)
S    typedef   signed char   int8_t;
S    typedef unsigned char  uint8_t;
S    typedef          short  int16_t;
S    typedef unsigned short uint16_t;
S    typedef          int    int32_t;
S    typedef unsigned int   uint32_t;
S#elif defined (__TMS320C2000__)
S#if defined(__TMS320C28XX_CLA__)
S    typedef          short  int16_t;
S    typedef unsigned short uint16_t;
S    typedef          int    int32_t;
S    typedef unsigned int   uint32_t;
S#else
S    typedef          int    int16_t;
S    typedef unsigned int   uint16_t;
S    typedef          long   int32_t;
S    typedef unsigned long  uint32_t;
S#endif
S#endif
S
S#if defined(__ARM_ARCH) || defined(_TMS320C6X) || defined(__ARP32__) || \
S    defined(__MSP430__) || defined(__PRU__)    || defined(__C7000__)
X#if defined(__ARM_ARCH) || defined(_TMS320C6X) || defined(__ARP32__) ||     defined(__MSP430__) || defined(__PRU__)    || defined(__C7000__)
S    typedef          long long  int64_t;
S    typedef unsigned long long uint64_t;
S#elif defined(__TMS320C2000__)
S#if defined(__TMS320C28X__) || \
S    (defined(__TMS320C28XX_CLA__) && defined(__TI_EABI__))
X#if defined(__TMS320C28X__) ||     (defined(__TMS320C28XX_CLA__) && defined(__TI_EABI__))
S    typedef          long long  int64_t;
S    typedef unsigned long long uint64_t;
S#endif
S#endif
S
S/* 7.18.1.2 Minimum-width integer types */
S
S#if defined(_TMS320C6X) || defined(__ARM_ARCH) || defined(__MSP430__) || \
S    defined(__TMS320C55X_PLUS_BYTE__)          || defined(__ARP32__)  || \
S    defined(__PRU__)    || defined(__C7000__)
X#if defined(_TMS320C6X) || defined(__ARM_ARCH) || defined(__MSP430__) ||     defined(__TMS320C55X_PLUS_BYTE__)          || defined(__ARP32__)  ||     defined(__PRU__)    || defined(__C7000__)
S    typedef  int8_t   int_least8_t;
S    typedef uint8_t  uint_least8_t;
S#elif defined(__TMS320C2000__) || defined(_TMS320C5XX) || defined(__TMS320C55X__)
S    typedef  int16_t  int_least8_t;
S    typedef uint16_t uint_least8_t;
S#endif
S
S    typedef  int16_t  int_least16_t;
S    typedef uint16_t uint_least16_t;
S    typedef  int32_t  int_least32_t;
S    typedef uint32_t uint_least32_t;
S
S#if defined(__ARM_ARCH) || defined(_TMS320C6X) || defined(__C7000__) || \
S    defined(__ARP32__)  || defined(__MSP430__) || defined(__PRU__)
X#if defined(__ARM_ARCH) || defined(_TMS320C6X) || defined(__C7000__) ||     defined(__ARP32__)  || defined(__MSP430__) || defined(__PRU__)
S    typedef  int64_t  int_least64_t;
S    typedef uint64_t uint_least64_t;
S#elif defined(__TMS320C2000__)
S#if defined(__TMS320C28X__) || \
S    (defined(__TMS320C28XX_CLA__) && defined(__TI_EABI__))
X#if defined(__TMS320C28X__) ||     (defined(__TMS320C28XX_CLA__) && defined(__TI_EABI__))
S    typedef  int64_t  int_least64_t;
S    typedef uint64_t uint_least64_t;
S#else
S/* sorry, [u]int_least64_t not implemented for C27X, CLA */
S#endif
S#elif defined(_TMS320C5XX) || defined(__TMS320C55X__) 
S/* sorry, [u]int_least64_t not implemented for C54x, C55x */
S#endif
S
S/* 7.18.1.3 Fastest minimum-width integer types */
S
S#if defined(_TMS320C5XX) || defined(__TMS320C55X__)  || defined(__MSP430__)
S    typedef  int16_t  int_fast8_t;
S    typedef uint16_t uint_fast8_t;
S    typedef  int16_t  int_fast16_t;
S    typedef uint16_t uint_fast16_t;
S#elif defined(_TMS320C6X) || defined(__ARM_ARCH) || defined(__ARP32__) || \
S      defined(__PRU__)    || defined(__C7000__)
X#elif defined(_TMS320C6X) || defined(__ARM_ARCH) || defined(__ARP32__) ||       defined(__PRU__)    || defined(__C7000__)
S    typedef  int32_t  int_fast8_t;
S    typedef uint32_t uint_fast8_t;
S    typedef  int32_t  int_fast16_t;
S    typedef uint32_t uint_fast16_t;
S#elif defined (__TMS320C2000__)
S#if defined(__TMS320C28XX_CLA__)
S    typedef  int32_t  int_fast8_t;
S    typedef uint32_t uint_fast8_t;
S    typedef  int32_t  int_fast16_t;
S    typedef uint32_t uint_fast16_t;
S#else
S    typedef  int16_t  int_fast8_t;
S    typedef uint16_t uint_fast8_t;
S    typedef  int16_t  int_fast16_t;
S    typedef uint16_t uint_fast16_t;
S#endif
S#endif
S
S    typedef  int32_t  int_fast32_t;
S    typedef uint32_t uint_fast32_t;
S
S#if defined(__ARM_ARCH) || defined(_TMS320C6X) || defined(__C7000__) || \
S    defined(__ARP32__)  || defined(__MSP430__) || defined(__PRU__)
X#if defined(__ARM_ARCH) || defined(_TMS320C6X) || defined(__C7000__) ||     defined(__ARP32__)  || defined(__MSP430__) || defined(__PRU__)
S    typedef  int64_t  int_fast64_t;
S    typedef uint64_t uint_fast64_t;
S#elif defined(__TMS320C2000__)
S#if defined(__TMS320C28X__) || \
S    (defined(__TMS320C28XX_CLA__) && defined(__TI_EABI__))
X#if defined(__TMS320C28X__) ||     (defined(__TMS320C28XX_CLA__) && defined(__TI_EABI__))
S    typedef  int64_t  int_fast64_t;
S    typedef uint64_t uint_fast64_t;
S#else
S/* sorry, [u]int_fast64_t not implemented for C27X, CLA */
S#endif
S#elif defined(_TMS320C5XX) || defined(__TMS320C55X__) 
S/* sorry, [u]int_fast64_t not implemented for C54x, C55x */
S#endif
S
S/* 7.18.1.4 Integer types capable of holding object pointers */
S#if defined(_TMS320C5XX) || defined(__TMS320C55X__)        || \
S    (defined(__MSP430__) && defined(__LARGE_CODE_MODEL__)) || \
S    defined(__C7000__)
X#if defined(_TMS320C5XX) || defined(__TMS320C55X__)        ||     (defined(__MSP430__) && defined(__LARGE_CODE_MODEL__)) ||     defined(__C7000__)
S    typedef          long intptr_t;
S    typedef unsigned long uintptr_t;
S#elif defined(_TMS320C6X) || defined(__ARM_ARCH) || defined(__MSP430__) || \
S      defined(__ARP32__)  || defined(__PRU__)
X#elif defined(_TMS320C6X) || defined(__ARM_ARCH) || defined(__MSP430__) ||       defined(__ARP32__)  || defined(__PRU__)
S    typedef          int intptr_t;
S    typedef unsigned int uintptr_t;
S#elif defined(__TMS320C2000__)
S#if defined(__TMS320C28XX_CLA__)
S    typedef          short intptr_t;
S    typedef unsigned short uintptr_t;
S#else
S    typedef          long intptr_t;
S    typedef unsigned long uintptr_t;
S#endif
S#endif
S
S/* 7.18.1.5 Greatest-width integer types */
S#if defined(__TMS320C55X__) || defined(__ARM_ARCH) || defined(_TMS320C6X) || \
S    defined(__ARP32__)      || defined(__MSP430__) || defined(__PRU__)    || \
S    defined(__C7000__)
X#if defined(__TMS320C55X__) || defined(__ARM_ARCH) || defined(_TMS320C6X) ||     defined(__ARP32__)      || defined(__MSP430__) || defined(__PRU__)    ||     defined(__C7000__)
S    typedef          long long intmax_t;
S    typedef unsigned long long uintmax_t;
S#elif defined(_TMS320C5XX)
S    typedef          long intmax_t;
S    typedef unsigned long uintmax_t;
S#elif defined(__TMS320C2000__)
S#if defined(__TMS320C28X__) || \
S    (defined(__TMS320C28XX_CLA__) && defined(__TI_EABI__))
X#if defined(__TMS320C28X__) ||     (defined(__TMS320C28XX_CLA__) && defined(__TI_EABI__))
S    typedef          long long intmax_t;
S    typedef unsigned long long uintmax_t;
S#else /* C27X or CLA */
S    typedef          long intmax_t;
S    typedef unsigned long uintmax_t;
S#endif
S#endif
S
S/* 
S   According to footnotes in the 1999 C standard, "C++ implementations
S   should define these macros only when __STDC_LIMIT_MACROS is defined
S   before <stdint.h> is included." 
S*/
S#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
S
S/* 7.18.2 Limits of specified width integer types */
S
S#if defined(_TMS320C6X) || defined(__ARM_ARCH) || defined(__MSP430__) || \
S    defined(__TMS320C55X_PLUS_BYTE__)          || defined(__ARP32__)  || \
S    defined(__PRU__)    || defined(__C7000__)
X#if defined(_TMS320C6X) || defined(__ARM_ARCH) || defined(__MSP430__) ||     defined(__TMS320C55X_PLUS_BYTE__)          || defined(__ARP32__)  ||     defined(__PRU__)    || defined(__C7000__)
S    #define  INT8_MAX   0x7f
S    #define  INT8_MIN   (-INT8_MAX-1)
S    #define UINT8_MAX   0xff
S#endif
S
S    #define  INT16_MAX  0x7fff
S    #define  INT16_MIN  (-INT16_MAX-1)
S    #define UINT16_MAX  0xffff
S
S    #define  INT32_MAX  0x7fffffff
S    #define  INT32_MIN  (-INT32_MAX-1)
S    #define UINT32_MAX  0xffffffff
S
S#if defined(__ARM_ARCH) || defined(_TMS320C6X) || defined(__C7000__) || \
S    defined(__ARP32__)  || defined(__MSP430__) || defined(__PRU__)
X#if defined(__ARM_ARCH) || defined(_TMS320C6X) || defined(__C7000__) ||     defined(__ARP32__)  || defined(__MSP430__) || defined(__PRU__)
S    #define  INT64_MAX  0x7fffffffffffffff
S    #define  INT64_MIN  (-INT64_MAX-1)
S    #define UINT64_MAX  0xffffffffffffffff
S#elif defined(__TMS320C2000__)
S#if defined(__TMS320C28X__) || \
S    (defined(__TMS320C28XX_CLA__) && defined(__TI_EABI__))
X#if defined(__TMS320C28X__) ||     (defined(__TMS320C28XX_CLA__) && defined(__TI_EABI__))
S    #define  INT64_MAX  0x7fffffffffffffff
S    #define  INT64_MIN  (-INT64_MAX-1)
S    #define UINT64_MAX  0xffffffffffffffff
S#endif
S#endif
S
S#if defined(_TMS320C6X) || defined(__ARM_ARCH) || defined(__MSP430__) || \
S    defined(__TMS320C55X_PLUS_BYTE__)          || defined(__ARP32__)  || \
S    defined(__PRU__)    || defined(__C7000__)
X#if defined(_TMS320C6X) || defined(__ARM_ARCH) || defined(__MSP430__) ||     defined(__TMS320C55X_PLUS_BYTE__)          || defined(__ARP32__)  ||     defined(__PRU__)    || defined(__C7000__)
S    #define  INT_LEAST8_MAX   (INT8_MAX)
S    #define  INT_LEAST8_MIN   (INT8_MIN)
S    #define UINT_LEAST8_MAX   (UINT8_MAX)
S#elif defined(__TMS320C2000__) || defined(_TMS320C5XX) || defined(__TMS320C55X__)
S    #define  INT_LEAST8_MAX   (INT16_MAX)
S    #define  INT_LEAST8_MIN   (INT16_MIN)
S    #define UINT_LEAST8_MAX   (UINT16_MAX)
S#endif
S
S    #define  INT_LEAST16_MAX  (INT16_MAX)
S    #define  INT_LEAST16_MIN  (INT16_MIN)
S    #define UINT_LEAST16_MAX  (UINT16_MAX)
S    #define  INT_LEAST32_MAX  (INT32_MAX)
S    #define  INT_LEAST32_MIN  (INT32_MIN)
S    #define UINT_LEAST32_MAX  (UINT32_MAX)
S
S#if defined(__ARM_ARCH) || defined(_TMS320C6X) || defined(__C7000__) || \
S    defined(__ARP32__)  || defined(__MSP430__) || defined(__PRU__)
X#if defined(__ARM_ARCH) || defined(_TMS320C6X) || defined(__C7000__) ||     defined(__ARP32__)  || defined(__MSP430__) || defined(__PRU__)
S    #define  INT_LEAST64_MAX  (INT64_MAX)
S    #define  INT_LEAST64_MIN  (INT64_MIN)
S    #define UINT_LEAST64_MAX  (UINT64_MAX)
S#elif defined(__TMS320C2000__)
S#if defined(__TMS320C28X__) || \
S    (defined(__TMS320C28XX_CLA__) && defined(__TI_EABI__))
X#if defined(__TMS320C28X__) ||     (defined(__TMS320C28XX_CLA__) && defined(__TI_EABI__))
S    #define  INT_LEAST64_MAX  (INT64_MAX)
S    #define  INT_LEAST64_MIN  (INT64_MIN)
S    #define UINT_LEAST64_MAX  (UINT64_MAX)
S#endif
S#endif
S
S#if defined(_TMS320C5XX) || defined(__TMS320C55X__)
S    #define  INT_FAST8_MAX   (INT16_MAX)
S    #define  INT_FAST8_MIN   (INT16_MIN)
S    #define UINT_FAST8_MAX   (UINT16_MAX)
S    #define  INT_FAST16_MAX  (INT16_MAX)
S    #define  INT_FAST16_MIN  (INT16_MIN)
S    #define UINT_FAST16_MAX  (UINT16_MAX)
S#elif defined(_TMS320C6X) || defined(__ARM_ARCH) || defined(__ARP32__) || \
S      defined(__PRU__)    || defined(__C7000__)
X#elif defined(_TMS320C6X) || defined(__ARM_ARCH) || defined(__ARP32__) ||       defined(__PRU__)    || defined(__C7000__)
S    #define  INT_FAST8_MAX   (INT32_MAX)
S    #define  INT_FAST8_MIN   (INT32_MIN)
S    #define UINT_FAST8_MAX   (UINT32_MAX)
S    #define  INT_FAST16_MAX  (INT32_MAX)
S    #define  INT_FAST16_MIN  (INT32_MIN)
S    #define UINT_FAST16_MAX  (UINT32_MAX)
S#elif defined(__MSP430__)
S    #define  INT_FAST8_MAX    (INT16_MAX)
S    #define  INT_FAST8_MIN    (INT16_MIN)
S    #define  UINT_FAST8_MAX   (UINT16_MAX)
S    #define  INT_FAST16_MAX   (INT16_MAX)
S    #define  INT_FAST16_MIN   (INT16_MIN)
S    #define  UINT_FAST16_MAX  (UINT16_MAX)
S#elif defined (__TMS320C2000__)
S#if defined(__TMS320C28XX_CLA__)
S    #define  INT_FAST8_MAX   (INT32_MAX)
S    #define  INT_FAST8_MIN   (INT32_MIN)
S    #define UINT_FAST8_MAX   (UINT32_MAX)
S    #define  INT_FAST16_MAX  (INT32_MAX)
S    #define  INT_FAST16_MIN  (INT32_MIN)
S    #define UINT_FAST16_MAX  (UINT32_MAX)
S#else
S    #define  INT_FAST8_MAX   (INT16_MAX)
S    #define  INT_FAST8_MIN   (INT16_MIN)
S    #define UINT_FAST8_MAX   (UINT16_MAX)
S    #define  INT_FAST16_MAX  (INT16_MAX)
S    #define  INT_FAST16_MIN  (INT16_MIN)
S    #define UINT_FAST16_MAX  (UINT16_MAX)
S#endif
S#endif
S
S    #define  INT_FAST32_MAX  (INT32_MAX)
S    #define  INT_FAST32_MIN  (INT32_MIN)
S    #define UINT_FAST32_MAX  (UINT32_MAX)
S
S#if defined(__ARM_ARCH) || defined(_TMS320C6X) || defined(__C7000__) || \
S    defined(__ARP32__)  || defined(__MSP430__) || defined(__PRU__)
X#if defined(__ARM_ARCH) || defined(_TMS320C6X) || defined(__C7000__) ||     defined(__ARP32__)  || defined(__MSP430__) || defined(__PRU__)
S    #define  INT_FAST64_MAX  (INT64_MAX)
S    #define  INT_FAST64_MIN  (INT64_MIN)
S    #define UINT_FAST64_MAX  (UINT64_MAX)
S#elif defined(__TMS320C2000__)
S#if defined(__TMS320C28X__) || \
S    (defined(__TMS320C28XX_CLA__) && defined(__TI_EABI__))
X#if defined(__TMS320C28X__) ||     (defined(__TMS320C28XX_CLA__) && defined(__TI_EABI__))
S    #define  INT_FAST64_MAX  (INT64_MAX)
S    #define  INT_FAST64_MIN  (INT64_MIN)
S    #define UINT_FAST64_MAX  (UINT64_MAX)
S#endif
S#endif
S
S#if defined(__MSP430__) && !defined(__LARGE_CODE_MODEL__)
S    #define INTPTR_MAX   (INT16_MAX)
S    #define INTPTR_MIN   (INT16_MIN)
S    #define UINTPTR_MAX  (UINT16_MAX)
S#elif defined(__C7000__)
S    #define INTPTR_MAX   (INT64_MAX)
S    #define INTPTR_MIN   (INT64_MIN)
S    #define UINTPTR_MAX  (UINT64_MAX)
S#else
S    #define INTPTR_MAX   (INT32_MAX)
S    #define INTPTR_MIN   (INT32_MIN)
S    #define UINTPTR_MAX  (UINT32_MAX)
S#endif
S
S#if defined(__ARM_ARCH) || defined(_TMS320C6X) || defined(__C7000__) || \
S    defined(__ARP32__)  || defined(__MSP430__) || defined(__PRU__)
X#if defined(__ARM_ARCH) || defined(_TMS320C6X) || defined(__C7000__) ||     defined(__ARP32__)  || defined(__MSP430__) || defined(__PRU__)
S    #define INTMAX_MIN   (INT64_MIN)
S    #define INTMAX_MAX   (INT64_MAX)
S    #define UINTMAX_MAX  (UINT64_MAX)
S#elif defined(_TMS320C5XX)
S    #define INTMAX_MIN   (INT32_MIN)
S    #define INTMAX_MAX   (INT32_MAX)
S    #define UINTMAX_MAX  (UINT32_MAX)
S#elif defined(__TMS320C2000__)
S#if defined(__TMS320C28X__) || \
S    (defined(__TMS320C28XX_CLA__) && defined(__TI_EABI__))
X#if defined(__TMS320C28X__) ||     (defined(__TMS320C28XX_CLA__) && defined(__TI_EABI__))
S    #define INTMAX_MIN   (INT64_MIN)
S    #define INTMAX_MAX   (INT64_MAX)
S    #define UINTMAX_MAX  (UINT64_MAX)
S#else
S    #define INTMAX_MIN   (INT32_MIN)
S    #define INTMAX_MAX   (INT32_MAX)
S    #define UINTMAX_MAX  (UINT32_MAX)
S#endif
S#endif
S
S/* 7.18.3 Limits of other integer types */
S
S#if defined(_TMS320C5XX) || defined(__TMS320C55X__) || \
S    (defined(__MSP430__) && !defined(__LONG_PTRDIFF_T__))
X#if defined(_TMS320C5XX) || defined(__TMS320C55X__) ||     (defined(__MSP430__) && !defined(__LONG_PTRDIFF_T__))
S    #define PTRDIFF_MAX (INT16_MAX)
S    #define PTRDIFF_MIN (INT16_MIN)
S#elif defined(__TMS320C2000__) || defined(__MSP430__) || \
S      (defined(_TMS320C6X) && !defined(__C6X_MIGRATION__)) || \
S      defined(__ARM_ARCH)      || defined(__ARP32__) || defined(__PRU__)
X#elif defined(__TMS320C2000__) || defined(__MSP430__) ||       (defined(_TMS320C6X) && !defined(__C6X_MIGRATION__)) ||       defined(__ARM_ARCH)      || defined(__ARP32__) || defined(__PRU__)
S    #define PTRDIFF_MAX (INT32_MAX)
S    #define PTRDIFF_MIN (INT32_MIN)
S#elif defined(__C7000__)
S    #define PTRDIFF_MAX (INT64_MAX)
S    #define PTRDIFF_MIN (INT64_MIN)
S#endif
S
S#if defined(_TMS320C5XX) || defined(__TMS320C55X__) || defined(__MSP430__)
S    #define SIG_ATOMIC_MIN (INT16_MIN)
S    #define SIG_ATOMIC_MAX (INT16_MAX)
S#elif defined(__TMS320C2000__) || defined(_TMS320C6X) || defined(__C7000__) || \
S      defined(__ARM_ARCH)      || defined(__ARP32__)  || defined(__PRU__)
X#elif defined(__TMS320C2000__) || defined(_TMS320C6X) || defined(__C7000__) ||       defined(__ARM_ARCH)      || defined(__ARP32__)  || defined(__PRU__)
S    #define SIG_ATOMIC_MIN (INT32_MIN)
S    #define SIG_ATOMIC_MAX (INT32_MAX)
S#endif
S
S#if defined(_TMS320C5XX) || defined(__TMS320C55X__) || \
S    (defined(__MSP430__) && !defined(__LONG_PTRDIFF_T__))
X#if defined(_TMS320C5XX) || defined(__TMS320C55X__) ||     (defined(__MSP430__) && !defined(__LONG_PTRDIFF_T__))
S    #define SIZE_MAX (UINT16_MAX)
S#elif defined(__TMS320C2000__) || defined(__MSP430__) || \
S      (defined(_TMS320C6X) && !defined(__C6X_MIGRATION__)) || \
S      defined(__ARM_ARCH)      || defined(__ARP32__)  || defined(__PRU__)
X#elif defined(__TMS320C2000__) || defined(__MSP430__) ||       (defined(_TMS320C6X) && !defined(__C6X_MIGRATION__)) ||       defined(__ARM_ARCH)      || defined(__ARP32__)  || defined(__PRU__)
S    #define SIZE_MAX (UINT32_MAX)
S#elif defined(__C7000__)
S    #define SIZE_MAX (UINT64_MAX)
S#endif
S
S#ifndef WCHAR_MAX
S#if !defined(__TI_WCHAR_T_BITS__) || __TI_WCHAR_T_BITS__ == 16
S#define WCHAR_MAX 0xffffu
S#else 
S#define WCHAR_MAX 0xffffffffu
S#endif
S#endif
S
S#ifndef WCHAR_MIN
S#define WCHAR_MIN 0
S#endif
S
S#if defined(_TMS320C5XX) || defined(__TMS320C55X__) || defined(__MSP430__)
S    #define WINT_MIN (INT16_MIN)
S    #define WINT_MAX (INT16_MAX)
S#elif defined(__TMS320C2000__) || defined(_TMS320C6X) || defined(__C7000__) || \
S      defined(__ARM_ARCH)      || defined(__ARP32__)  || defined(__PRU__)
X#elif defined(__TMS320C2000__) || defined(_TMS320C6X) || defined(__C7000__) ||       defined(__ARM_ARCH)      || defined(__ARP32__)  || defined(__PRU__)
S    #define WINT_MIN (INT32_MIN)
S    #define WINT_MAX (INT32_MAX)
S#endif
S
S/* 7.18.4.1 Macros for minimum-width integer constants */
S
S/*
S   There is a defect report filed against the C99 standard concerning how 
S   the (U)INTN_C macros should be implemented.  Please refer to --
S   http://wwwold.dkuug.dk/JTC1/SC22/WG14/www/docs/dr_209.htm 
S   for more information.  These macros are implemented according to the
S   suggestion given at this web site.
S*/
S
S    #define  INT8_C(value)  ((int_least8_t)(value))
S    #define UINT8_C(value)  ((uint_least8_t)(value))
S    #define  INT16_C(value) ((int_least16_t)(value))
S    #define UINT16_C(value) ((uint_least16_t)(value))
S    #define  INT32_C(value) ((int_least32_t)(value))
S    #define UINT32_C(value) ((uint_least32_t)(value))
S
S#if defined(__ARM_ARCH) || defined(_TMS320C6X) || defined(__C7000__) || \
S    defined(__ARP32__)  || defined(__MSP430__) || defined(__PRU__)
X#if defined(__ARM_ARCH) || defined(_TMS320C6X) || defined(__C7000__) ||     defined(__ARP32__)  || defined(__MSP430__) || defined(__PRU__)
S    #define  INT64_C(value) ((int_least64_t)(value))
S    #define UINT64_C(value) ((uint_least64_t)(value))
S#elif defined(__TMS320C2000__)
S#if defined(__TMS320C28X__) || \
S    (defined(__TMS320C28XX_CLA__) && defined(__TI_EABI__))
X#if defined(__TMS320C28X__) ||     (defined(__TMS320C28XX_CLA__) && defined(__TI_EABI__))
S    #define  INT64_C(value) ((int_least64_t)(value))
S    #define UINT64_C(value) ((uint_least64_t)(value))
S#endif
S#endif
S
S/* 7.18.4.2 Macros for greatest-width integer constants */
S
S    #define  INTMAX_C(value) ((intmax_t)(value))
S    #define UINTMAX_C(value) ((uintmax_t)(value))
S
S#endif /* !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS) */
N#endif
N#endif /* _STDINT_H_ */
L 120 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/stdint.h" 2
N
N#endif  /* _LIBCPP_STDINT_H */
L 60 "C:\ti\msp432_driverlib_3_21_00_05\driverlib\MSP432P4xx\adc14.h" 2
N#include <msp.h>
L 1 "C:/ti/ccs930/ccs/ccs_base/arm/include/msp.h" 1
N/******************************************************************************
N*
N* Copyright (C) 2012 - 2017 Texas Instruments Incorporated - http://www.ti.com/ 
N*
N* Redistribution and use in source and binary forms, with or without 
N* modification, are permitted provided that the following conditions 
N* are met:
N*
N*  Redistributions of source code must retain the above copyright 
N*  notice, this list of conditions and the following disclaimer.
N*
N*  Redistributions in binary form must reproduce the above copyright
N*  notice, this list of conditions and the following disclaimer in the 
N*  documentation and/or other materials provided with the   
N*  distribution.
N*
N*  Neither the name of Texas Instruments Incorporated nor the names of
N*  its contributors may be used to endorse or promote products derived
N*  from this software without specific prior written permission.
N*
N* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
N* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
N* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
N* A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
N* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
N* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
N* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
N* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
N* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
N* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
N* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N*
N* MSP432 Family Generic Include File
N*
N* File creation date: 12/06/17
N*
N******************************************************************************/
N
N#ifndef __MSP432_H__
N#define __MSP432_H__
N
N/******************************************************************************
N* MSP432 devices                                                              *
N******************************************************************************/
N#if defined (__MSP432P401R__)
X#if 1L
N#include "msp432p401r.h"
L 1 "C:\ti\ccs930\ccs\ccs_base\arm\include\msp432p401r.h" 1
N/******************************************************************************
N*
N* Copyright (C) 2012 - 2017 Texas Instruments Incorporated - http://www.ti.com/
N*
N* Redistribution and use in source and binary forms, with or without
N* modification, are permitted provided that the following conditions
N* are met:
N*
N*  Redistributions of source code must retain the above copyright
N*  notice, this list of conditions and the following disclaimer.
N*
N*  Redistributions in binary form must reproduce the above copyright
N*  notice, this list of conditions and the following disclaimer in the
N*  documentation and/or other materials provided with the
N*  distribution.
N*
N*  Neither the name of Texas Instruments Incorporated nor the names of
N*  its contributors may be used to endorse or promote products derived
N*  from this software without specific prior written permission.
N*
N* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
N* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
N* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
N* A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
N* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
N* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
N* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
N* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
N* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
N* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N*
N* MSP432P401R Register Definitions
N*
N* This file includes CMSIS compliant component and register definitions
N*
N* For legacy components the definitions that are compatible with MSP430 code,
N* are included with msp432p401r_classic.h
N* 
N* With CMSIS definitions, the register defines have been reformatted:
N*     ModuleName[ModuleInstance]->RegisterName
N*
N* Writing to CMSIS bit fields can be done through register level
N* or via bitband area access:
N*  - ADC14->CTL0 |= ADC14_CTL0_ENC;
N*  - BITBAND_PERI(ADC14->CTL0, ADC14_CTL0_ENC_OFS) = 1;
N*
N* File creation date: 2017-12-06
N*
N******************************************************************************/
N
N#ifndef __MSP432P401R_H__
N#define __MSP432P401R_H__
N
N/* Use standard integer types with explicit width */
N#include <stdint.h>
N
N#ifdef __cplusplus
N extern "C" {
N#endif
N
N#define __MSP432_HEADER_VERSION__ 3230
N
N/* Remap MSP432 intrinsics to ARM equivalents */
N#include "msp_compatibility.h"
L 1 "C:\ti\ccs930\ccs\ccs_base\arm\include\msp_compatibility.h" 1
N//*****************************************************************************
N//
N// Copyright (C) 2013 - 2015 Texas Instruments Incorporated - http://www.ti.com/
N//
N// Redistribution and use in source and binary forms, with or without
N// modification, are permitted provided that the following conditions
N// are met:
N//
N//  Redistributions of source code must retain the above copyright
N//  notice, this list of conditions and the following disclaimer.
N//
N//  Redistributions in binary form must reproduce the above copyright
N//  notice, this list of conditions and the following disclaimer in the
N//  documentation and/or other materials provided with the
N//  distribution.
N//
N//  Neither the name of Texas Instruments Incorporated nor the names of
N//  its contributors may be used to endorse or promote products derived
N//  from this software without specific prior written permission.
N//
N// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
N// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
N// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
N// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
N// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
N// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
N// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
N// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
N// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
N// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N//
N// MSP430 intrinsic redefinitions for use with MSP432 Family Devices
N//
N//****************************************************************************
N
N/******************************************************************************
N* Definitions for 8/16/32-bit wide memory access                              *
N******************************************************************************/
N#define HWREG8(x)         (*((volatile uint8_t *)(x)))
N#define HWREG16(x)        (*((volatile uint16_t *)(x)))
N#define HWREG32(x)        (*((volatile uint32_t *)(x)))
N#define HWREG(x)          (HWREG16(x))
N#define HWREG8_L(x)       (*((volatile uint8_t *)((uint8_t *)&x)))
N#define HWREG8_H(x)       (*((volatile uint8_t *)(((uint8_t *)&x)+1)))
N#define HWREG16_L(x)      (*((volatile uint16_t *)((uint16_t *)&x)))
N#define HWREG16_H(x)      (*((volatile uint16_t *)(((uint16_t *)&x)+1)))
N
N/******************************************************************************
N* Definitions for 8/16/32-bit wide bit band access                            *
N******************************************************************************/
N#define HWREGBIT8(x, b)   (HWREG8(((uint32_t)(x) & 0xF0000000) | 0x02000000 | (((uint32_t)(x) & 0x000FFFFF) << 5) | ((b) << 2)))
N#define HWREGBIT16(x, b)  (HWREG16(((uint32_t)(x) & 0xF0000000) | 0x02000000 | (((uint32_t)(x) & 0x000FFFFF) << 5) | ((b) << 2)))
N#define HWREGBIT32(x, b)  (HWREG32(((uint32_t)(x) & 0xF0000000) | 0x02000000 | (((uint32_t)(x) & 0x000FFFFF) << 5) | ((b) << 2)))
N
N// Intrinsics with ARM equivalents
N#if defined ( __TI_ARM__ ) /* TI CGT Compiler */
X#if 1L  
N
N#define __sleep()                       __wfi()
N#define __deep_sleep()                  { (*((volatile uint32_t *)(0xE000ED10))) |= 0x00000004; __wfi(); (*((volatile uint32_t *)(0xE000ED10))) &= ~0x00000004; }
N#define __low_power_mode_off_on_exit()  { (*((volatile uint32_t *)(0xE000ED10))) &= ~0x00000002; }
N#define __get_SP_register()             __get_MSP()
N#define __set_SP_register(x)            __set_MSP(x)
N#define __get_interrupt_state()         __get_PRIMASK()
N#define __set_interrupt_state(x)        __set_PRIMASK(x)
N#define __enable_interrupt()            _enable_IRQ()
N#define __enable_interrupts()           _enable_IRQ()
N#define __disable_interrupt()           _disable_IRQ()
N#define __disable_interrupts()          _disable_IRQ()
N#define __no_operation()                __asm("  nop")
N
N#elif defined ( __ICCARM__ )  /* IAR Compiler */
S
S#include <stdint.h>
S
S#define __INLINE                        inline
S#define __sleep()                       __WFI()
S#define __deep_sleep()                  { (*((volatile uint32_t *)(0xE000ED10))) |= 0x00000004; __WFI(); (*((volatile uint32_t *)(0xE000ED10))) &= ~0x00000004; }
S#define __low_power_mode_off_on_exit()  { (*((volatile uint32_t *)(0xE000ED10))) &= ~0x00000002; }
S
S#if (__VER__ < 8020002)
S#define __get_SP_register()             __get_MSP()
S#define __set_SP_register()             __set_MSP()
S#define __get_interrupt_state()         __get_PRIMASK()
S#define __set_interrupt_state(x)        __set_PRIMASK(x)
S#define __enable_interrupt()            __asm("  cpsie i")
S#define __enable_interrupts()           __asm("  cpsie i")
S#define __disable_interrupt()           __asm("  cpsid i")
S#define __disable_interrupts()          __asm("  cpsid i")
S#define __no_operation()                __asm("  nop")
S#endif
S
S// Intrinsics without ARM equivalents
S#define __bcd_add_short(x,y)            { while(1); /* Using not-supported MSP430 intrinsic. No replacement available. */ }
S#define __bcd_add_long(x,y)             { while(1); /* Using not-supported MSP430 intrinsic. No replacement available. */ }
S#define __bcd_add_long_long(x,y)        { while(1); /* Using not-supported MSP430 intrinsic. No replacement available. */ }
S#define __even_in_range(x,y)            { while(1); /* Using not-supported MSP430 intrinsic. No replacement available. */ }
S#define __data20_write_char(x,y)        { while(1); /* Using not-supported MSP430 intrinsic. No replacement available. */ }
S#define __data20_write_short(x,y)       { while(1); /* Using not-supported MSP430 intrinsic. No replacement available. */ }
S#define __data20_write_long(x,y)        { while(1); /* Using not-supported MSP430 intrinsic. No replacement available. */ }
S#define __never_executed()              { while(1); /* Using not-supported MSP430 intrinsic. No replacement available. */ }
S#define __op_code()                     { while(1); /* Using not-supported MSP430 intrinsic. No replacement available. */ }
S#define __code_distance()               { while(1); /* Using not-supported MSP430 intrinsic. No replacement available. */ }
S#define __bic_SR_register(x)            { while(1); /* Using not-supported MSP430 intrinsic. No replacement available. */ }
S#define __bis_SR_register(x)            { while(1); /* Using not-supported MSP430 intrinsic. No replacement available. */ }
S#define __bis_SR_register_on_exit(x)    { while(1); /* Using not-supported MSP430 intrinsic. Recommended to write to SCS_SCR register. */ }
S#define __bic_SR_register_on_exit(x)    { while(1); /* Using not-supported MSP430 intrinsic. Recommended to write to SCS_SCR register. */ }
S#define __delay_cycles(x)               { while(1); /* Using not-supported MSP430 intrinsic. Recommended to use a timer or a custom for loop. */ }
S
S#elif defined ( __CC_ARM ) /* ARM Compiler */
S
S#define __sleep()                       __wfi()
S#define __deep_sleep()                  { (*((volatile uint32_t *)(0xE000ED10))) |= 0x00000004; __wfi(); (*((volatile uint32_t *)(0xE000ED10))) &= ~0x00000004; }
S#define __low_power_mode_off_on_exit()  { (*((volatile uint32_t *)(0xE000ED10))) &= ~0x00000002; }
S#define __get_SP_register()             __get_MSP()
S#define __set_SP_register(x)            __set_MSP(x)
S#define __get_interrupt_state()         __get_PRIMASK()
S#define __set_interrupt_state(x)        __set_PRIMASK(x)
S#define __enable_interrupt()            __asm("  cpsie i")
S#define __enable_interrupts()           __asm("  cpsie i")
S#define __disable_interrupt()           __asm("  cpsid i")
S#define __disable_interrupts()          __asm("  cpsid i")
S#define __no_operation()                __asm("  nop")
S
S// Intrinsics without ARM equivalents
S#define __bcd_add_short(x,y)            { while(1); /* Using not-supported MSP430 intrinsic. No replacement available. */ }
S#define __bcd_add_long(x,y)             { while(1); /* Using not-supported MSP430 intrinsic. No replacement available. */ }
S#define __bcd_add_long_long(x,y)        { while(1); /* Using not-supported MSP430 intrinsic. No replacement available. */ }
S#define __even_in_range(x,y)            { while(1); /* Using not-supported MSP430 intrinsic. No replacement available. */ }
S#define __data20_write_char(x,y)        { while(1); /* Using not-supported MSP430 intrinsic. No replacement available. */ }
S#define __data20_write_short(x,y)       { while(1); /* Using not-supported MSP430 intrinsic. No replacement available. */ }
S#define __data20_write_long(x,y)        { while(1); /* Using not-supported MSP430 intrinsic. No replacement available. */ }
S#define __never_executed()              { while(1); /* Using not-supported MSP430 intrinsic. No replacement available. */ }
S#define __op_code()                     { while(1); /* Using not-supported MSP430 intrinsic. No replacement available. */ }
S#define __code_distance()               { while(1); /* Using not-supported MSP430 intrinsic. No replacement available. */ }
S#define __bic_SR_register(x)            { while(1); /* Using not-supported MSP430 intrinsic. No replacement available. */ }
S#define __bis_SR_register(x)            { while(1); /* Using not-supported MSP430 intrinsic. No replacement available. */ }
S#define __bis_SR_register_on_exit(x)    { while(1); /* Using not-supported MSP430 intrinsic. Recommended to write to SCS_SCR register. */ }
S#define __bic_SR_register_on_exit(x)    { while(1); /* Using not-supported MSP430 intrinsic. Recommended to write to SCS_SCR register. */ }
S#define __delay_cycles(x)               { while(1); /* Using not-supported MSP430 intrinsic. Recommended to use a timer or a custom for loop. */ }
S
S#elif defined ( __GNUC__ ) /* GCC Compiler */
S#undef __wfi
S#define __wfi()                         __asm("  wfi")
S#define __sleep()                       __wfi()
S#define __deep_sleep()                  { (*((volatile uint32_t *)(0xE000ED10))) |= 0x00000004; __wfi(); (*((volatile uint32_t *)(0xE000ED10))) &= ~0x00000004; }
S#define __low_power_mode_off_on_exit()  { (*((volatile uint32_t *)(0xE000ED10))) &= ~0x00000002; }
S#define __get_SP_register()             __get_MSP()
S#define __set_SP_register(x)            __set_MSP(x)
S#define __get_interrupt_state()         __get_PRIMASK()
S#define __set_interrupt_state(x)        __set_PRIMASK(x)
S#define __enable_interrupt()            __asm("  cpsie i")
S#define __enable_interrupts()           __asm("  cpsie i")
S#define __disable_interrupt()           __asm("  cpsid i")
S#define __disable_interrupts()          __asm("  cpsid i")
S#define __no_operation()                __asm("  nop")
S
S// Intrinsics without ARM equivalents
S#define __bcd_add_short(x,y)            { while(1); /* Using not-supported MSP430 intrinsic. No replacement available. */ }
S#define __bcd_add_long(x,y)             { while(1); /* Using not-supported MSP430 intrinsic. No replacement available. */ }
S#define __bcd_add_long_long(x,y)        { while(1); /* Using not-supported MSP430 intrinsic. No replacement available. */ }
S#define __even_in_range(x,y)            { while(1); /* Using not-supported MSP430 intrinsic. No replacement available. */ }
S#define __data20_write_char(x,y)        { while(1); /* Using not-supported MSP430 intrinsic. No replacement available. */ }
S#define __data20_write_short(x,y)       { while(1); /* Using not-supported MSP430 intrinsic. No replacement available. */ }
S#define __data20_write_long(x,y)        { while(1); /* Using not-supported MSP430 intrinsic. No replacement available. */ }
S#define __never_executed()              { while(1); /* Using not-supported MSP430 intrinsic. No replacement available. */ }
S#define __op_code()                     { while(1); /* Using not-supported MSP430 intrinsic. No replacement available. */ }
S#define __code_distance()               { while(1); /* Using not-supported MSP430 intrinsic. No replacement available. */ }
S#define __bic_SR_register(x)            { while(1); /* Using not-supported MSP430 intrinsic. No replacement available. */ }
S#define __bis_SR_register(x)            { while(1); /* Using not-supported MSP430 intrinsic. No replacement available. */ }
S#define __bis_SR_register_on_exit(x)    { while(1); /* Using not-supported MSP430 intrinsic. Recommended to write to SCS_SCR register. */ }
S#define __bic_SR_register_on_exit(x)    { while(1); /* Using not-supported MSP430 intrinsic. Recommended to write to SCS_SCR register. */ }
S#define __delay_cycles(x)               { while(1); /* Using not-supported MSP430 intrinsic. Recommended to use a timer or a custom for loop. */ }
S
N#endif
N
N// Intrinsics without ARM equivalents
N#define __low_power_mode_0()            { __sleep(); }
N#define __low_power_mode_1()            { __sleep(); }
N#define __low_power_mode_2()            { __sleep(); }
N#define __low_power_mode_3()            { __deep_sleep(); }
N#define __low_power_mode_4()            { __deep_sleep(); }
N#define __data16_read_addr(x)           (*((volatile uint32_t *)(x)))
N#define __data20_read_char(x)           (*((volatile uint8_t *)(x)))
N#define __data20_read_short(x)          (*((volatile uint16_t *)(x)))
N#define __data20_read_long(x)           (*((volatile uint32_t *)(x)))
N#define __data16_write_addr(x,y)        { (*((volatile uint32_t *)(x))) }
N#define __get_SR_register()             0
N#define __get_SR_register_on_exit()     0
N
N// the following defines are deprecated and will be removed in future releases
N#define ATLBASE                                  ALTBASE
N#define CS_CTL1_SELM_7                           ((uint32_t)0x00000007)          /*!< for future use. Defaults to DCOCLK. Not recommended for use to ensure future  */
N                                                                                 /* compatibilities. */
N#define CS_CTL1_SELS_7                           ((uint32_t)0x00000070)          /*!< for furture use. Defaults to DCOCLK. Do not use to ensure future  */
N                                                                                 /* compatibilities. */
N#define CS_CTL1_SELA_3                           ((uint32_t)0x00000300)          /*!< for future use. Defaults to REFOCLK. Not recommended for use to ensure future  */
N                                                                                 /* compatibilities. */
N#define CS_CTL1_SELA_4                           ((uint32_t)0x00000400)          /*!< for future use. Defaults to REFOCLK. Not recommended for use to ensure future  */
N                                                                                 /* compatibilities. */
N#define CS_CTL1_SELA_5                           ((uint32_t)0x00000500)          /*!< for future use. Defaults to REFOCLK. Not recommended for use to ensure future  */
N                                                                                 /* compatibilities. */
N#define CS_CTL1_SELA_6                           ((uint32_t)0x00000600)          /*!< for future use. Defaults to REFOCLK. Not recommended for use to ensure future  */
N                                                                                 /* compatibilities. */
N#define CS_CTL1_SELA_7                           ((uint32_t)0x00000700)          /*!< for future use. Defaults to REFOCLK. Not recommended for use to ensure future  */
N                                                                                 /* compatibilities. */
N                                                                                 /* CS_CTL2[LFXTAGCOFF] Bits */
N#define CS_CTL2_LFXTAGCOFF_OFS                   ( 7)                            /*!< LFXTAGCOFF Bit Offset */
N#define CS_CTL2_LFXTAGCOFF                       ((uint32_t)0x00000080)          /*!< Disables the automatic gain control of the LFXT crystal */
N
N/* CS_CTL3[FCNTHF2] Bits */
N#define CS_CTL3_FCNTHF2_OFS                      ( 8)                            /*!< FCNTHF2 Bit Offset */
N#define CS_CTL3_FCNTHF2_MASK                     ((uint32_t)0x00000300)          /*!< FCNTHF2 Bit Mask */
N#define CS_CTL3_FCNTHF20                         ((uint32_t)0x00000100)          /*!< FCNTHF2 Bit 0 */
N#define CS_CTL3_FCNTHF21                         ((uint32_t)0x00000200)          /*!< FCNTHF2 Bit 1 */
N#define CS_CTL3_FCNTHF2_0                        ((uint32_t)0x00000000)          /*!< 2048 cycles */
N#define CS_CTL3_FCNTHF2_1                        ((uint32_t)0x00000100)          /*!< 4096 cycles */
N#define CS_CTL3_FCNTHF2_2                        ((uint32_t)0x00000200)          /*!< 8192 cycles */
N#define CS_CTL3_FCNTHF2_3                        ((uint32_t)0x00000300)          /*!< 16384 cycles */
N#define CS_CTL3_FCNTHF2__2048                    ((uint32_t)0x00000000)          /*!< 2048 cycles */
N#define CS_CTL3_FCNTHF2__4096                    ((uint32_t)0x00000100)          /*!< 4096 cycles */
N#define CS_CTL3_FCNTHF2__8192                    ((uint32_t)0x00000200)          /*!< 8192 cycles */
N#define CS_CTL3_FCNTHF2__16384                   ((uint32_t)0x00000300)          /*!< 16384 cycles */
N/* CS_CTL3[RFCNTHF2] Bits */
N#define CS_CTL3_RFCNTHF2_OFS                     (10)                            /*!< RFCNTHF2 Bit Offset */
N#define CS_CTL3_RFCNTHF2                         ((uint32_t)0x00000400)          /*!< Reset start fault counter for HFXT2 */
N/* CS_CTL3[FCNTHF2_EN] Bits */
N#define CS_CTL3_FCNTHF2_EN_OFS                   (11)                            /*!< FCNTHF2_EN Bit Offset */
N#define CS_CTL3_FCNTHF2_EN                       ((uint32_t)0x00000800)          /*!< Enable start fault counter for HFXT2 */
N/* CS_STAT[HFXT2_ON] Bits */
N#define CS_STAT_HFXT2_ON_OFS                     ( 3)                            /*!< HFXT2_ON Bit Offset */
N#define CS_STAT_HFXT2_ON                         ((uint32_t)0x00000008)          /*!< HFXT2 status */
N/* CS_IE[HFXT2IE] Bits */
N#define CS_IE_HFXT2IE_OFS                        ( 2)                            /*!< HFXT2IE Bit Offset */
N#define CS_IE_HFXT2IE                            ((uint32_t)0x00000004)          /*!< HFXT2 oscillator fault flag interrupt enable */
N/* CS_IE[FCNTHF2IE] Bits */
N#define CS_IE_FCNTHF2IE_OFS                      (10)                            /*!< FCNTHF2IE Bit Offset */
N#define CS_IE_FCNTHF2IE                          ((uint32_t)0x00000400)          /*!< Start fault counter interrupt enable HFXT2 */
N/* CS_IE[PLLOOLIE] Bits */
N#define CS_IE_PLLOOLIE_OFS                       (12)                            /*!< PLLOOLIE Bit Offset */
N#define CS_IE_PLLOOLIE                           ((uint32_t)0x00001000)          /*!< PLL out-of-lock interrupt enable */
N/* CS_IE[PLLLOSIE] Bits */
N#define CS_IE_PLLLOSIE_OFS                       (13)                            /*!< PLLLOSIE Bit Offset */
N#define CS_IE_PLLLOSIE                           ((uint32_t)0x00002000)          /*!< PLL loss-of-signal interrupt enable */
N/* CS_IE[PLLOORIE] Bits */
N#define CS_IE_PLLOORIE_OFS                       (14)                            /*!< PLLOORIE Bit Offset */
N#define CS_IE_PLLOORIE                           ((uint32_t)0x00004000)          /*!< PLL out-of-range interrupt enable */
N/* CS_IE[CALIE] Bits */
N#define CS_IE_CALIE_OFS                          (15)                            /*!< CALIE Bit Offset */
N#define CS_IE_CALIE                              ((uint32_t)0x00008000)          /*!< REFCNT period counter interrupt enable */
N/* CS_IFG[HFXT2IFG] Bits */
N#define CS_IFG_HFXT2IFG_OFS                      ( 2)                            /*!< HFXT2IFG Bit Offset */
N#define CS_IFG_HFXT2IFG                          ((uint32_t)0x00000004)          /*!< HFXT2 oscillator fault flag */
N/* CS_IFG[FCNTHF2IFG] Bits */
N#define CS_IFG_FCNTHF2IFG_OFS                    (11)                            /*!< FCNTHF2IFG Bit Offset */
N#define CS_IFG_FCNTHF2IFG                        ((uint32_t)0x00000800)          /*!< Start fault counter interrupt flag HFXT2 */
N/* CS_IFG[PLLOOLIFG] Bits */
N#define CS_IFG_PLLOOLIFG_OFS                     (12)                            /*!< PLLOOLIFG Bit Offset */
N#define CS_IFG_PLLOOLIFG                         ((uint32_t)0x00001000)          /*!< PLL out-of-lock interrupt flag */
N/* CS_IFG[PLLLOSIFG] Bits */
N#define CS_IFG_PLLLOSIFG_OFS                     (13)                            /*!< PLLLOSIFG Bit Offset */
N#define CS_IFG_PLLLOSIFG                         ((uint32_t)0x00002000)          /*!< PLL loss-of-signal interrupt flag */
N/* CS_IFG[PLLOORIFG] Bits */
N#define CS_IFG_PLLOORIFG_OFS                     (14)                            /*!< PLLOORIFG Bit Offset */
N#define CS_IFG_PLLOORIFG                         ((uint32_t)0x00004000)          /*!< PLL out-of-range interrupt flag */
N/* CS_IFG[CALIFG] Bits */
N#define CS_IFG_CALIFG_OFS                        (15)                            /*!< CALIFG Bit Offset */
N#define CS_IFG_CALIFG                            ((uint32_t)0x00008000)          /*!< REFCNT period counter expired */
N/* CS_CLRIFG[CLR_HFXT2IFG] Bits */
N#define CS_CLRIFG_CLR_HFXT2IFG_OFS               ( 2)                            /*!< CLR_HFXT2IFG Bit Offset */
N#define CS_CLRIFG_CLR_HFXT2IFG                   ((uint32_t)0x00000004)          /*!< Clear HFXT2 oscillator fault interrupt flag */
N/* CS_CLRIFG[CLR_CALIFG] Bits */
N#define CS_CLRIFG_CLR_CALIFG_OFS                 (15)                            /*!< CLR_CALIFG Bit Offset */
N#define CS_CLRIFG_CLR_CALIFG                     ((uint32_t)0x00008000)          /*!< REFCNT period counter clear interrupt flag */
N/* CS_CLRIFG[CLR_FCNTHF2IFG] Bits */
N#define CS_CLRIFG_CLR_FCNTHF2IFG_OFS             (10)                            /*!< CLR_FCNTHF2IFG Bit Offset */
N#define CS_CLRIFG_CLR_FCNTHF2IFG                 ((uint32_t)0x00000400)          /*!< Start fault counter clear interrupt flag HFXT2 */
N/* CS_CLRIFG[CLR_PLLOOLIFG] Bits */
N#define CS_CLRIFG_CLR_PLLOOLIFG_OFS              (12)                            /*!< CLR_PLLOOLIFG Bit Offset */
N#define CS_CLRIFG_CLR_PLLOOLIFG                  ((uint32_t)0x00001000)          /*!< PLL out-of-lock clear interrupt flag */
N/* CS_CLRIFG[CLR_PLLLOSIFG] Bits */
N#define CS_CLRIFG_CLR_PLLLOSIFG_OFS              (13)                            /*!< CLR_PLLLOSIFG Bit Offset */
N#define CS_CLRIFG_CLR_PLLLOSIFG                  ((uint32_t)0x00002000)          /*!< PLL loss-of-signal clear interrupt flag */
N/* CS_CLRIFG[CLR_PLLOORIFG] Bits */
N#define CS_CLRIFG_CLR_PLLOORIFG_OFS              (14)                            /*!< CLR_PLLOORIFG Bit Offset */
N#define CS_CLRIFG_CLR_PLLOORIFG                  ((uint32_t)0x00004000)          /*!< PLL out-of-range clear interrupt flag */
N/* CS_SETIFG[SET_HFXT2IFG] Bits */
N#define CS_SETIFG_SET_HFXT2IFG_OFS               ( 2)                            /*!< SET_HFXT2IFG Bit Offset */
N#define CS_SETIFG_SET_HFXT2IFG                   ((uint32_t)0x00000004)          /*!< Set HFXT2 oscillator fault interrupt flag */
N/* CS_SETIFG[SET_CALIFG] Bits */
N#define CS_SETIFG_SET_CALIFG_OFS                 (15)                            /*!< SET_CALIFG Bit Offset */
N#define CS_SETIFG_SET_CALIFG                     ((uint32_t)0x00008000)          /*!< REFCNT period counter set interrupt flag */
N/* CS_SETIFG[SET_FCNTHF2IFG] Bits */
N#define CS_SETIFG_SET_FCNTHF2IFG_OFS             (10)                            /*!< SET_FCNTHF2IFG Bit Offset */
N#define CS_SETIFG_SET_FCNTHF2IFG                 ((uint32_t)0x00000400)          /*!< Start fault counter set interrupt flag HFXT2 */
N/* CS_SETIFG[SET_PLLOOLIFG] Bits */
N#define CS_SETIFG_SET_PLLOOLIFG_OFS              (12)                            /*!< SET_PLLOOLIFG Bit Offset */
N#define CS_SETIFG_SET_PLLOOLIFG                  ((uint32_t)0x00001000)          /*!< PLL out-of-lock set interrupt flag */
N/* CS_SETIFG[SET_PLLLOSIFG] Bits */
N#define CS_SETIFG_SET_PLLLOSIFG_OFS              (13)                            /*!< SET_PLLLOSIFG Bit Offset */
N#define CS_SETIFG_SET_PLLLOSIFG                  ((uint32_t)0x00002000)          /*!< PLL loss-of-signal set interrupt flag */
N/* CS_SETIFG[SET_PLLOORIFG] Bits */
N#define CS_SETIFG_SET_PLLOORIFG_OFS              (14)                            /*!< SET_PLLOORIFG Bit Offset */
N#define CS_SETIFG_SET_PLLOORIFG                  ((uint32_t)0x00004000)          /*!< PLL out-of-range set interrupt flag */
N
N/* EUSCI_x_CTLW0[SSEL] Bits */
N#define EUSCI_A_CTLW0_SSEL_0                     ((uint16_t)0x0000)              /*!< Reserved */
N#define EUSCI_B_CTLW0_SSEL_0                     ((uint16_t)0x0000)              /*!< Reserved */
N#define EUSCI_B_CTLW0_SSEL_3                     ((uint16_t)0x00C0)              /*!< SMCLK */
N
N/* RSTCTL_PSSRESET_STAT[SVSL] Bits */
N#define RSTCTL_PSSRESET_STAT_SVSL_OFS            ( 0)                            /*!< SVSL Bit Offset */
N#define RSTCTL_PSSRESET_STAT_SVSL                ((uint32_t)0x00000001)          /*!< Indicates if POR was caused by an SVSL trip condition in the PSS */
N
N/* SYSCTL_SYSTEM_STAT[DBG_SEC_ACT] Bits */
N#define SYSCTL_SYSTEM_STAT_DBG_SEC_ACT_OFS       ( 3)                            /*!< DBG_SEC_ACT Bit Offset */
N#define SYSCTL_SYSTEM_STAT_DBG_SEC_ACT           ((uint32_t)0x00000008)          /*!< Debug Security active */
N/* SYSCTL_SYSTEM_STAT[JTAG_SWD_LOCK_ACT] Bits */
N#define SYSCTL_SYSTEM_STAT_JTAG_SWD_LOCK_ACT_OFS ( 4)                            /*!< JTAG_SWD_LOCK_ACT Bit Offset */
N#define SYSCTL_SYSTEM_STAT_JTAG_SWD_LOCK_ACT     ((uint32_t)0x00000010)          /*!< Indicates if JTAG and SWD Lock is active */
N/* SYSCTL_SYSTEM_STAT[IP_PROT_ACT] Bits */
N#define SYSCTL_SYSTEM_STAT_IP_PROT_ACT_OFS       ( 5)                            /*!< IP_PROT_ACT Bit Offset */
N#define SYSCTL_SYSTEM_STAT_IP_PROT_ACT           ((uint32_t)0x00000020)          /*!< Indicates if IP protection is active */
N
L 66 "C:\ti\ccs930\ccs\ccs_base\arm\include\msp432p401r.h" 2
N
N/******************************************************************************
N* include MSP430 legacy definitions to make porting of code from MSP430       *
N* code base easier                                                            *
N* With fully CMSIS compliant code, NO_MSP_CLASSIC_DEFINES may be defined in   *
N* your project to omit including the classic defines                          *
N******************************************************************************/
N#ifndef NO_MSP_CLASSIC_DEFINES
N#include "msp432p401r_classic.h"
L 1 "C:\ti\ccs930\ccs\ccs_base\arm\include\msp432p401r_classic.h" 1
N/******************************************************************************
N*
N* Copyright (C) 2012 - 2017 Texas Instruments Incorporated - http://www.ti.com/
N*
N* Redistribution and use in source and binary forms, with or without
N* modification, are permitted provided that the following conditions
N* are met:
N*
N*  Redistributions of source code must retain the above copyright
N*  notice, this list of conditions and the following disclaimer.
N*
N*  Redistributions in binary form must reproduce the above copyright
N*  notice, this list of conditions and the following disclaimer in the
N*  documentation and/or other materials provided with the
N*  distribution.
N*
N*  Neither the name of Texas Instruments Incorporated nor the names of
N*  its contributors may be used to endorse or promote products derived
N*  from this software without specific prior written permission.
N*
N* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
N* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
N* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
N* A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
N* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
N* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
N* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
N* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
N* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
N* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N*
N* MSP432P401R Register Definitions
N*
N* This file includes MSP430 style component and register definitions
N* for legacy components re-used in MSP432
N*
N* File creation date: 2017-12-06
N*
N******************************************************************************/
N
N#ifndef __MSP432P401R_CLASSIC_H__
N#define __MSP432P401R_CLASSIC_H__
N
N/* Use standard integer types with explicit width */
N#include <stdint.h>
N
N#ifdef __cplusplus
N extern "C" {
N#endif
N
N/******************************************************************************
N* Device memory map                                                           *
N******************************************************************************/
N#define __MAIN_MEMORY_START__                              (0x00000000)          /*!< Main Flash memory start address */
N#define __MAIN_MEMORY_END__                                (0x0003FFFF)          /*!< Main Flash memory end address */
N#define __BSL_MEMORY_START__                               (0x00202000)          /*!< BSL memory start address */
N#define __BSL_MEMORY_END__                                 (0x00203FFF)          /*!< BSL memory end address */
N#define __SRAM_START__                                     (0x20000000)          /*!< SRAM memory start address */
N#define __SRAM_END__                                       (0x2000FFFF)          /*!< SRAM memory end address */
N
N/******************************************************************************
N* MSP-format peripheral registers                                             *
N******************************************************************************/
N
N/******************************************************************************
N* AES256 Registers
N******************************************************************************/
N#define AESACTL0                                 (HWREG16(0x40003C00))           /*!< AES Accelerator Control Register 0 */
N#define AESACTL1                                 (HWREG16(0x40003C02))           /*!< AES Accelerator Control Register 1 */
N#define AESASTAT                                 (HWREG16(0x40003C04))           /*!< AES Accelerator Status Register */
N#define AESAKEY                                  (HWREG16(0x40003C06))           /*!< AES Accelerator Key Register */
N#define AESADIN                                  (HWREG16(0x40003C08))           /*!< AES Accelerator Data In Register */
N#define AESADOUT                                 (HWREG16(0x40003C0A))           /*!< AES Accelerator Data Out Register */
N#define AESAXDIN                                 (HWREG16(0x40003C0C))           /*!< AES Accelerator XORed Data In Register */
N#define AESAXIN                                  (HWREG16(0x40003C0E))           /*!< AES Accelerator XORed Data In Register */
N
N/* Register offsets from AES256_BASE address */
N#define OFS_AESACTL0                                       (0x0000)              /*!< AES Accelerator Control Register 0 */
N#define OFS_AESACTL1                                       (0x0002)              /*!< AES Accelerator Control Register 1 */
N#define OFS_AESASTAT                                       (0x0004)              /*!< AES Accelerator Status Register */
N#define OFS_AESAKEY                                        (0x0006)              /*!< AES Accelerator Key Register */
N#define OFS_AESADIN                                        (0x0008)              /*!< AES Accelerator Data In Register */
N#define OFS_AESADOUT                                       (0x000A)              /*!< AES Accelerator Data Out Register */
N#define OFS_AESAXDIN                                       (0x000C)              /*!< AES Accelerator XORed Data In Register */
N#define OFS_AESAXIN                                        (0x000E)              /*!< AES Accelerator XORed Data In Register */
N
N
N/******************************************************************************
N* CAPTIO0 Registers
N******************************************************************************/
N#define CAPTIO0CTL                               (HWREG16(0x4000540E))           /*!< Capacitive Touch IO x Control Register */
N
N/* Register offsets from CAPTIO0_BASE address */
N#define OFS_CAPTIO0CTL                                     (0x000E)              /*!< Capacitive Touch IO x Control Register */
N
N#define CAPTIO0CTL_L                                       (HWREG8_L(CAPTIO0CTL))/* Capacitive Touch IO x Control Register */
N#define CAPTIO0CTL_H                                       (HWREG8_H(CAPTIO0CTL))/* Capacitive Touch IO x Control Register */
N
N/******************************************************************************
N* CAPTIO1 Registers
N******************************************************************************/
N#define CAPTIO1CTL                               (HWREG16(0x4000580E))           /*!< Capacitive Touch IO x Control Register */
N
N/* Register offsets from CAPTIO1_BASE address */
N#define OFS_CAPTIO1CTL                                     (0x000E)              /*!< Capacitive Touch IO x Control Register */
N
N#define CAPTIO1CTL_L                                       (HWREG8_L(CAPTIO1CTL))/* Capacitive Touch IO x Control Register */
N#define CAPTIO1CTL_H                                       (HWREG8_H(CAPTIO1CTL))/* Capacitive Touch IO x Control Register */
N
N/******************************************************************************
N* COMP_E0 Registers
N******************************************************************************/
N#define CE0CTL0                                  (HWREG16(0x40003400))           /*!< Comparator Control Register 0 */
N#define CE0CTL1                                  (HWREG16(0x40003402))           /*!< Comparator Control Register 1 */
N#define CE0CTL2                                  (HWREG16(0x40003404))           /*!< Comparator Control Register 2 */
N#define CE0CTL3                                  (HWREG16(0x40003406))           /*!< Comparator Control Register 3 */
N#define CE0INT                                   (HWREG16(0x4000340C))           /*!< Comparator Interrupt Control Register */
N#define CE0IV                                    (HWREG16(0x4000340E))           /*!< Comparator Interrupt Vector Word Register */
N
N/* Register offsets from COMP_E0_BASE address */
N#define OFS_CE0CTL0                                        (0x0000)              /*!< Comparator Control Register 0 */
N#define OFS_CE0CTL1                                        (0x0002)              /*!< Comparator Control Register 1 */
N#define OFS_CE0CTL2                                        (0x0004)              /*!< Comparator Control Register 2 */
N#define OFS_CE0CTL3                                        (0x0006)              /*!< Comparator Control Register 3 */
N#define OFS_CE0INT                                         (0x000C)              /*!< Comparator Interrupt Control Register */
N#define OFS_CE0IV                                          (0x000E)              /*!< Comparator Interrupt Vector Word Register */
N
N
N/******************************************************************************
N* COMP_E1 Registers
N******************************************************************************/
N#define CE1CTL0                                  (HWREG16(0x40003800))           /*!< Comparator Control Register 0 */
N#define CE1CTL1                                  (HWREG16(0x40003802))           /*!< Comparator Control Register 1 */
N#define CE1CTL2                                  (HWREG16(0x40003804))           /*!< Comparator Control Register 2 */
N#define CE1CTL3                                  (HWREG16(0x40003806))           /*!< Comparator Control Register 3 */
N#define CE1INT                                   (HWREG16(0x4000380C))           /*!< Comparator Interrupt Control Register */
N#define CE1IV                                    (HWREG16(0x4000380E))           /*!< Comparator Interrupt Vector Word Register */
N
N/* Register offsets from COMP_E1_BASE address */
N#define OFS_CE1CTL0                                        (0x0000)              /*!< Comparator Control Register 0 */
N#define OFS_CE1CTL1                                        (0x0002)              /*!< Comparator Control Register 1 */
N#define OFS_CE1CTL2                                        (0x0004)              /*!< Comparator Control Register 2 */
N#define OFS_CE1CTL3                                        (0x0006)              /*!< Comparator Control Register 3 */
N#define OFS_CE1INT                                         (0x000C)              /*!< Comparator Interrupt Control Register */
N#define OFS_CE1IV                                          (0x000E)              /*!< Comparator Interrupt Vector Word Register */
N
N
N/******************************************************************************
N* CRC32 Registers
N******************************************************************************/
N#define CRC32DI                                  (HWREG16(0x40004000))           /*!< Data Input for CRC32 Signature Computation */
N#define CRC32DIRB                                (HWREG16(0x40004004))           /*!< Data In Reverse for CRC32 Computation */
N#define CRC32INIRES_LO                           (HWREG16(0x40004008))           /*!< CRC32 Initialization and Result, lower 16 bits */
N#define CRC32INIRES_HI                           (HWREG16(0x4000400A))           /*!< CRC32 Initialization and Result, upper 16 bits */
N#define CRC32RESR_LO                             (HWREG16(0x4000400C))           /*!< CRC32 Result Reverse, lower 16 bits */
N#define CRC32RESR_HI                             (HWREG16(0x4000400E))           /*!< CRC32 Result Reverse, Upper 16 bits */
N#define CRC16DI                                  (HWREG16(0x40004010))           /*!< Data Input for CRC16 computation */
N#define CRC16DIRB                                (HWREG16(0x40004014))           /*!< CRC16 Data In Reverse */
N#define CRC16INIRES                              (HWREG16(0x40004018))           /*!< CRC16 Initialization and Result register */
N#define CRC16RESR                                (HWREG16(0x4000401E))           /*!< CRC16 Result Reverse */
N
N/* Register offsets from CRC32_BASE address */
N#define OFS_CRC32DI                                        (0x0000)              /*!< Data Input for CRC32 Signature Computation */
N#define OFS_CRC32DIRB                                      (0x0004)              /*!< Data In Reverse for CRC32 Computation */
N#define OFS_CRC32INIRES_LO                                 (0x0008)              /*!< CRC32 Initialization and Result, lower 16 bits */
N#define OFS_CRC32INIRES_HI                                 (0x000A)              /*!< CRC32 Initialization and Result, upper 16 bits */
N#define OFS_CRC32RESR_LO                                   (0x000C)              /*!< CRC32 Result Reverse, lower 16 bits */
N#define OFS_CRC32RESR_HI                                   (0x000E)              /*!< CRC32 Result Reverse, Upper 16 bits */
N#define OFS_CRC16DI                                        (0x0010)              /*!< Data Input for CRC16 computation */
N#define OFS_CRC16DIRB                                      (0x0014)              /*!< CRC16 Data In Reverse */
N#define OFS_CRC16INIRES                                    (0x0018)              /*!< CRC16 Initialization and Result register */
N#define OFS_CRC16RESR                                      (0x001E)              /*!< CRC16 Result Reverse */
N
N
N/******************************************************************************
N* DIO Registers
N******************************************************************************/
N#define PAIN                                     (HWREG16(0x40004C00))           /*!< Port A Input */
N#define PAOUT                                    (HWREG16(0x40004C02))           /*!< Port A Output */
N#define PADIR                                    (HWREG16(0x40004C04))           /*!< Port A Direction */
N#define PAREN                                    (HWREG16(0x40004C06))           /*!< Port A Resistor Enable */
N#define PADS                                     (HWREG16(0x40004C08))           /*!< Port A Drive Strength */
N#define PASEL0                                   (HWREG16(0x40004C0A))           /*!< Port A Select 0 */
N#define PASEL1                                   (HWREG16(0x40004C0C))           /*!< Port A Select 1 */
N#define P1IV                                     (HWREG16(0x40004C0E))           /*!< Port 1 Interrupt Vector Register */
N#define PASELC                                   (HWREG16(0x40004C16))           /*!< Port A Complement Select */
N#define PAIES                                    (HWREG16(0x40004C18))           /*!< Port A Interrupt Edge Select */
N#define PAIE                                     (HWREG16(0x40004C1A))           /*!< Port A Interrupt Enable */
N#define PAIFG                                    (HWREG16(0x40004C1C))           /*!< Port A Interrupt Flag */
N#define P2IV                                     (HWREG16(0x40004C1E))           /*!< Port 2 Interrupt Vector Register */
N#define PBIN                                     (HWREG16(0x40004C20))           /*!< Port B Input */
N#define PBOUT                                    (HWREG16(0x40004C22))           /*!< Port B Output */
N#define PBDIR                                    (HWREG16(0x40004C24))           /*!< Port B Direction */
N#define PBREN                                    (HWREG16(0x40004C26))           /*!< Port B Resistor Enable */
N#define PBDS                                     (HWREG16(0x40004C28))           /*!< Port B Drive Strength */
N#define PBSEL0                                   (HWREG16(0x40004C2A))           /*!< Port B Select 0 */
N#define PBSEL1                                   (HWREG16(0x40004C2C))           /*!< Port B Select 1 */
N#define P3IV                                     (HWREG16(0x40004C2E))           /*!< Port 3 Interrupt Vector Register */
N#define PBSELC                                   (HWREG16(0x40004C36))           /*!< Port B Complement Select */
N#define PBIES                                    (HWREG16(0x40004C38))           /*!< Port B Interrupt Edge Select */
N#define PBIE                                     (HWREG16(0x40004C3A))           /*!< Port B Interrupt Enable */
N#define PBIFG                                    (HWREG16(0x40004C3C))           /*!< Port B Interrupt Flag */
N#define P4IV                                     (HWREG16(0x40004C3E))           /*!< Port 4 Interrupt Vector Register */
N#define PCIN                                     (HWREG16(0x40004C40))           /*!< Port C Input */
N#define PCOUT                                    (HWREG16(0x40004C42))           /*!< Port C Output */
N#define PCDIR                                    (HWREG16(0x40004C44))           /*!< Port C Direction */
N#define PCREN                                    (HWREG16(0x40004C46))           /*!< Port C Resistor Enable */
N#define PCDS                                     (HWREG16(0x40004C48))           /*!< Port C Drive Strength */
N#define PCSEL0                                   (HWREG16(0x40004C4A))           /*!< Port C Select 0 */
N#define PCSEL1                                   (HWREG16(0x40004C4C))           /*!< Port C Select 1 */
N#define P5IV                                     (HWREG16(0x40004C4E))           /*!< Port 5 Interrupt Vector Register */
N#define PCSELC                                   (HWREG16(0x40004C56))           /*!< Port C Complement Select */
N#define PCIES                                    (HWREG16(0x40004C58))           /*!< Port C Interrupt Edge Select */
N#define PCIE                                     (HWREG16(0x40004C5A))           /*!< Port C Interrupt Enable */
N#define PCIFG                                    (HWREG16(0x40004C5C))           /*!< Port C Interrupt Flag */
N#define P6IV                                     (HWREG16(0x40004C5E))           /*!< Port 6 Interrupt Vector Register */
N#define PDIN                                     (HWREG16(0x40004C60))           /*!< Port D Input */
N#define PDOUT                                    (HWREG16(0x40004C62))           /*!< Port D Output */
N#define PDDIR                                    (HWREG16(0x40004C64))           /*!< Port D Direction */
N#define PDREN                                    (HWREG16(0x40004C66))           /*!< Port D Resistor Enable */
N#define PDDS                                     (HWREG16(0x40004C68))           /*!< Port D Drive Strength */
N#define PDSEL0                                   (HWREG16(0x40004C6A))           /*!< Port D Select 0 */
N#define PDSEL1                                   (HWREG16(0x40004C6C))           /*!< Port D Select 1 */
N#define P7IV                                     (HWREG16(0x40004C6E))           /*!< Port 7 Interrupt Vector Register */
N#define PDSELC                                   (HWREG16(0x40004C76))           /*!< Port D Complement Select */
N#define PDIES                                    (HWREG16(0x40004C78))           /*!< Port D Interrupt Edge Select */
N#define PDIE                                     (HWREG16(0x40004C7A))           /*!< Port D Interrupt Enable */
N#define PDIFG                                    (HWREG16(0x40004C7C))           /*!< Port D Interrupt Flag */
N#define P8IV                                     (HWREG16(0x40004C7E))           /*!< Port 8 Interrupt Vector Register */
N#define PEIN                                     (HWREG16(0x40004C80))           /*!< Port E Input */
N#define PEOUT                                    (HWREG16(0x40004C82))           /*!< Port E Output */
N#define PEDIR                                    (HWREG16(0x40004C84))           /*!< Port E Direction */
N#define PEREN                                    (HWREG16(0x40004C86))           /*!< Port E Resistor Enable */
N#define PEDS                                     (HWREG16(0x40004C88))           /*!< Port E Drive Strength */
N#define PESEL0                                   (HWREG16(0x40004C8A))           /*!< Port E Select 0 */
N#define PESEL1                                   (HWREG16(0x40004C8C))           /*!< Port E Select 1 */
N#define P9IV                                     (HWREG16(0x40004C8E))           /*!< Port 9 Interrupt Vector Register */
N#define PESELC                                   (HWREG16(0x40004C96))           /*!< Port E Complement Select */
N#define PEIES                                    (HWREG16(0x40004C98))           /*!< Port E Interrupt Edge Select */
N#define PEIE                                     (HWREG16(0x40004C9A))           /*!< Port E Interrupt Enable */
N#define PEIFG                                    (HWREG16(0x40004C9C))           /*!< Port E Interrupt Flag */
N#define P10IV                                    (HWREG16(0x40004C9E))           /*!< Port 10 Interrupt Vector Register */
N#define PJIN                                     (HWREG16(0x40004D20))           /*!< Port J Input */
N#define PJOUT                                    (HWREG16(0x40004D22))           /*!< Port J Output */
N#define PJDIR                                    (HWREG16(0x40004D24))           /*!< Port J Direction */
N#define PJREN                                    (HWREG16(0x40004D26))           /*!< Port J Resistor Enable */
N#define PJDS                                     (HWREG16(0x40004D28))           /*!< Port J Drive Strength */
N#define PJSEL0                                   (HWREG16(0x40004D2A))           /*!< Port J Select 0 */
N#define PJSEL1                                   (HWREG16(0x40004D2C))           /*!< Port J Select 1 */
N#define PJSELC                                   (HWREG16(0x40004D36))           /*!< Port J Complement Select */
N#define P1IN                                     (HWREG8(0x40004C00))            /*!< Port 1 Input */
N#define P2IN                                     (HWREG8(0x40004C01))            /*!< Port 2 Input */
N#define P2OUT                                    (HWREG8(0x40004C03))            /*!< Port 2 Output */
N#define P1OUT                                    (HWREG8(0x40004C02))            /*!< Port 1 Output */
N#define P1DIR                                    (HWREG8(0x40004C04))            /*!< Port 1 Direction */
N#define P2DIR                                    (HWREG8(0x40004C05))            /*!< Port 2 Direction */
N#define P1REN                                    (HWREG8(0x40004C06))            /*!< Port 1 Resistor Enable */
N#define P2REN                                    (HWREG8(0x40004C07))            /*!< Port 2 Resistor Enable */
N#define P1DS                                     (HWREG8(0x40004C08))            /*!< Port 1 Drive Strength */
N#define P2DS                                     (HWREG8(0x40004C09))            /*!< Port 2 Drive Strength */
N#define P1SEL0                                   (HWREG8(0x40004C0A))            /*!< Port 1 Select 0 */
N#define P2SEL0                                   (HWREG8(0x40004C0B))            /*!< Port 2 Select 0 */
N#define P1SEL1                                   (HWREG8(0x40004C0C))            /*!< Port 1 Select 1 */
N#define P2SEL1                                   (HWREG8(0x40004C0D))            /*!< Port 2 Select 1 */
N#define P1SELC                                   (HWREG8(0x40004C16))            /*!< Port 1 Complement Select */
N#define P2SELC                                   (HWREG8(0x40004C17))            /*!< Port 2 Complement Select */
N#define P1IES                                    (HWREG8(0x40004C18))            /*!< Port 1 Interrupt Edge Select */
N#define P2IES                                    (HWREG8(0x40004C19))            /*!< Port 2 Interrupt Edge Select */
N#define P1IE                                     (HWREG8(0x40004C1A))            /*!< Port 1 Interrupt Enable */
N#define P2IE                                     (HWREG8(0x40004C1B))            /*!< Port 2 Interrupt Enable */
N#define P1IFG                                    (HWREG8(0x40004C1C))            /*!< Port 1 Interrupt Flag */
N#define P2IFG                                    (HWREG8(0x40004C1D))            /*!< Port 2 Interrupt Flag */
N#define P3IN                                     (HWREG8(0x40004C20))            /*!< Port 3 Input */
N#define P4IN                                     (HWREG8(0x40004C21))            /*!< Port 4 Input */
N#define P3OUT                                    (HWREG8(0x40004C22))            /*!< Port 3 Output */
N#define P4OUT                                    (HWREG8(0x40004C23))            /*!< Port 4 Output */
N#define P3DIR                                    (HWREG8(0x40004C24))            /*!< Port 3 Direction */
N#define P4DIR                                    (HWREG8(0x40004C25))            /*!< Port 4 Direction */
N#define P3REN                                    (HWREG8(0x40004C26))            /*!< Port 3 Resistor Enable */
N#define P4REN                                    (HWREG8(0x40004C27))            /*!< Port 4 Resistor Enable */
N#define P3DS                                     (HWREG8(0x40004C28))            /*!< Port 3 Drive Strength */
N#define P4DS                                     (HWREG8(0x40004C29))            /*!< Port 4 Drive Strength */
N#define P4SEL0                                   (HWREG8(0x40004C2B))            /*!< Port 4 Select 0 */
N#define P3SEL0                                   (HWREG8(0x40004C2A))            /*!< Port 3 Select 0 */
N#define P3SEL1                                   (HWREG8(0x40004C2C))            /*!< Port 3 Select 1 */
N#define P4SEL1                                   (HWREG8(0x40004C2D))            /*!< Port 4 Select 1 */
N#define P3SELC                                   (HWREG8(0x40004C36))            /*!< Port 3 Complement Select */
N#define P4SELC                                   (HWREG8(0x40004C37))            /*!< Port 4 Complement Select */
N#define P3IES                                    (HWREG8(0x40004C38))            /*!< Port 3 Interrupt Edge Select */
N#define P4IES                                    (HWREG8(0x40004C39))            /*!< Port 4 Interrupt Edge Select */
N#define P3IE                                     (HWREG8(0x40004C3A))            /*!< Port 3 Interrupt Enable */
N#define P4IE                                     (HWREG8(0x40004C3B))            /*!< Port 4 Interrupt Enable */
N#define P3IFG                                    (HWREG8(0x40004C3C))            /*!< Port 3 Interrupt Flag */
N#define P4IFG                                    (HWREG8(0x40004C3D))            /*!< Port 4 Interrupt Flag */
N#define P5IN                                     (HWREG8(0x40004C40))            /*!< Port 5 Input */
N#define P6IN                                     (HWREG8(0x40004C41))            /*!< Port 6 Input */
N#define P5OUT                                    (HWREG8(0x40004C42))            /*!< Port 5 Output */
N#define P6OUT                                    (HWREG8(0x40004C43))            /*!< Port 6 Output */
N#define P5DIR                                    (HWREG8(0x40004C44))            /*!< Port 5 Direction */
N#define P6DIR                                    (HWREG8(0x40004C45))            /*!< Port 6 Direction */
N#define P5REN                                    (HWREG8(0x40004C46))            /*!< Port 5 Resistor Enable */
N#define P6REN                                    (HWREG8(0x40004C47))            /*!< Port 6 Resistor Enable */
N#define P5DS                                     (HWREG8(0x40004C48))            /*!< Port 5 Drive Strength */
N#define P6DS                                     (HWREG8(0x40004C49))            /*!< Port 6 Drive Strength */
N#define P5SEL0                                   (HWREG8(0x40004C4A))            /*!< Port 5 Select 0 */
N#define P6SEL0                                   (HWREG8(0x40004C4B))            /*!< Port 6 Select 0 */
N#define P5SEL1                                   (HWREG8(0x40004C4C))            /*!< Port 5 Select 1 */
N#define P6SEL1                                   (HWREG8(0x40004C4D))            /*!< Port 6 Select 1 */
N#define P5SELC                                   (HWREG8(0x40004C56))            /*!< Port 5 Complement Select */
N#define P6SELC                                   (HWREG8(0x40004C57))            /*!< Port 6 Complement Select */
N#define P5IES                                    (HWREG8(0x40004C58))            /*!< Port 5 Interrupt Edge Select */
N#define P6IES                                    (HWREG8(0x40004C59))            /*!< Port 6 Interrupt Edge Select */
N#define P5IE                                     (HWREG8(0x40004C5A))            /*!< Port 5 Interrupt Enable */
N#define P6IE                                     (HWREG8(0x40004C5B))            /*!< Port 6 Interrupt Enable */
N#define P5IFG                                    (HWREG8(0x40004C5C))            /*!< Port 5 Interrupt Flag */
N#define P6IFG                                    (HWREG8(0x40004C5D))            /*!< Port 6 Interrupt Flag */
N#define P7IN                                     (HWREG8(0x40004C60))            /*!< Port 7 Input */
N#define P8IN                                     (HWREG8(0x40004C61))            /*!< Port 8 Input */
N#define P7OUT                                    (HWREG8(0x40004C62))            /*!< Port 7 Output */
N#define P8OUT                                    (HWREG8(0x40004C63))            /*!< Port 8 Output */
N#define P7DIR                                    (HWREG8(0x40004C64))            /*!< Port 7 Direction */
N#define P8DIR                                    (HWREG8(0x40004C65))            /*!< Port 8 Direction */
N#define P7REN                                    (HWREG8(0x40004C66))            /*!< Port 7 Resistor Enable */
N#define P8REN                                    (HWREG8(0x40004C67))            /*!< Port 8 Resistor Enable */
N#define P7DS                                     (HWREG8(0x40004C68))            /*!< Port 7 Drive Strength */
N#define P8DS                                     (HWREG8(0x40004C69))            /*!< Port 8 Drive Strength */
N#define P7SEL0                                   (HWREG8(0x40004C6A))            /*!< Port 7 Select 0 */
N#define P8SEL0                                   (HWREG8(0x40004C6B))            /*!< Port 8 Select 0 */
N#define P7SEL1                                   (HWREG8(0x40004C6C))            /*!< Port 7 Select 1 */
N#define P8SEL1                                   (HWREG8(0x40004C6D))            /*!< Port 8 Select 1 */
N#define P7SELC                                   (HWREG8(0x40004C76))            /*!< Port 7 Complement Select */
N#define P8SELC                                   (HWREG8(0x40004C77))            /*!< Port 8 Complement Select */
N#define P7IES                                    (HWREG8(0x40004C78))            /*!< Port 7 Interrupt Edge Select */
N#define P8IES                                    (HWREG8(0x40004C79))            /*!< Port 8 Interrupt Edge Select */
N#define P7IE                                     (HWREG8(0x40004C7A))            /*!< Port 7 Interrupt Enable */
N#define P8IE                                     (HWREG8(0x40004C7B))            /*!< Port 8 Interrupt Enable */
N#define P7IFG                                    (HWREG8(0x40004C7C))            /*!< Port 7 Interrupt Flag */
N#define P8IFG                                    (HWREG8(0x40004C7D))            /*!< Port 8 Interrupt Flag */
N#define P9IN                                     (HWREG8(0x40004C80))            /*!< Port 9 Input */
N#define P10IN                                    (HWREG8(0x40004C81))            /*!< Port 10 Input */
N#define P9OUT                                    (HWREG8(0x40004C82))            /*!< Port 9 Output */
N#define P10OUT                                   (HWREG8(0x40004C83))            /*!< Port 10 Output */
N#define P9DIR                                    (HWREG8(0x40004C84))            /*!< Port 9 Direction */
N#define P10DIR                                   (HWREG8(0x40004C85))            /*!< Port 10 Direction */
N#define P9REN                                    (HWREG8(0x40004C86))            /*!< Port 9 Resistor Enable */
N#define P10REN                                   (HWREG8(0x40004C87))            /*!< Port 10 Resistor Enable */
N#define P9DS                                     (HWREG8(0x40004C88))            /*!< Port 9 Drive Strength */
N#define P10DS                                    (HWREG8(0x40004C89))            /*!< Port 10 Drive Strength */
N#define P9SEL0                                   (HWREG8(0x40004C8A))            /*!< Port 9 Select 0 */
N#define P10SEL0                                  (HWREG8(0x40004C8B))            /*!< Port 10 Select 0 */
N#define P9SEL1                                   (HWREG8(0x40004C8C))            /*!< Port 9 Select 1 */
N#define P10SEL1                                  (HWREG8(0x40004C8D))            /*!< Port 10 Select 1 */
N#define P9SELC                                   (HWREG8(0x40004C96))            /*!< Port 9 Complement Select */
N#define P10SELC                                  (HWREG8(0x40004C97))            /*!< Port 10 Complement Select */
N#define P9IES                                    (HWREG8(0x40004C98))            /*!< Port 9 Interrupt Edge Select */
N#define P10IES                                   (HWREG8(0x40004C99))            /*!< Port 10 Interrupt Edge Select */
N#define P9IE                                     (HWREG8(0x40004C9A))            /*!< Port 9 Interrupt Enable */
N#define P10IE                                    (HWREG8(0x40004C9B))            /*!< Port 10 Interrupt Enable */
N#define P9IFG                                    (HWREG8(0x40004C9C))            /*!< Port 9 Interrupt Flag */
N#define P10IFG                                   (HWREG8(0x40004C9D))            /*!< Port 10 Interrupt Flag */
N
N/* Register offsets from DIO_BASE address */
N#define OFS_PAIN                                           (0x0000)              /*!< Port A Input */
N#define OFS_PAOUT                                          (0x0002)              /*!< Port A Output */
N#define OFS_PADIR                                          (0x0004)              /*!< Port A Direction */
N#define OFS_PAREN                                          (0x0006)              /*!< Port A Resistor Enable */
N#define OFS_PADS                                           (0x0008)              /*!< Port A Drive Strength */
N#define OFS_PASEL0                                         (0x000A)              /*!< Port A Select 0 */
N#define OFS_PASEL1                                         (0x000C)              /*!< Port A Select 1 */
N#define OFS_P1IV                                           (0x000E)              /*!< Port 1 Interrupt Vector Register */
N#define OFS_PASELC                                         (0x0016)              /*!< Port A Complement Select */
N#define OFS_PAIES                                          (0x0018)              /*!< Port A Interrupt Edge Select */
N#define OFS_PAIE                                           (0x001A)              /*!< Port A Interrupt Enable */
N#define OFS_PAIFG                                          (0x001C)              /*!< Port A Interrupt Flag */
N#define OFS_P2IV                                           (0x001E)              /*!< Port 2 Interrupt Vector Register */
N#define OFS_PBIN                                           (0x0020)              /*!< Port B Input */
N#define OFS_PBOUT                                          (0x0022)              /*!< Port B Output */
N#define OFS_PBDIR                                          (0x0024)              /*!< Port B Direction */
N#define OFS_PBREN                                          (0x0026)              /*!< Port B Resistor Enable */
N#define OFS_PBDS                                           (0x0028)              /*!< Port B Drive Strength */
N#define OFS_PBSEL0                                         (0x002A)              /*!< Port B Select 0 */
N#define OFS_PBSEL1                                         (0x002C)              /*!< Port B Select 1 */
N#define OFS_P3IV                                           (0x002E)              /*!< Port 3 Interrupt Vector Register */
N#define OFS_PBSELC                                         (0x0036)              /*!< Port B Complement Select */
N#define OFS_PBIES                                          (0x0038)              /*!< Port B Interrupt Edge Select */
N#define OFS_PBIE                                           (0x003A)              /*!< Port B Interrupt Enable */
N#define OFS_PBIFG                                          (0x003C)              /*!< Port B Interrupt Flag */
N#define OFS_P4IV                                           (0x003E)              /*!< Port 4 Interrupt Vector Register */
N#define OFS_PCIN                                           (0x0040)              /*!< Port C Input */
N#define OFS_PCOUT                                          (0x0042)              /*!< Port C Output */
N#define OFS_PCDIR                                          (0x0044)              /*!< Port C Direction */
N#define OFS_PCREN                                          (0x0046)              /*!< Port C Resistor Enable */
N#define OFS_PCDS                                           (0x0048)              /*!< Port C Drive Strength */
N#define OFS_PCSEL0                                         (0x004A)              /*!< Port C Select 0 */
N#define OFS_PCSEL1                                         (0x004C)              /*!< Port C Select 1 */
N#define OFS_P5IV                                           (0x004E)              /*!< Port 5 Interrupt Vector Register */
N#define OFS_PCSELC                                         (0x0056)              /*!< Port C Complement Select */
N#define OFS_PCIES                                          (0x0058)              /*!< Port C Interrupt Edge Select */
N#define OFS_PCIE                                           (0x005A)              /*!< Port C Interrupt Enable */
N#define OFS_PCIFG                                          (0x005C)              /*!< Port C Interrupt Flag */
N#define OFS_P6IV                                           (0x005E)              /*!< Port 6 Interrupt Vector Register */
N#define OFS_PDIN                                           (0x0060)              /*!< Port D Input */
N#define OFS_PDOUT                                          (0x0062)              /*!< Port D Output */
N#define OFS_PDDIR                                          (0x0064)              /*!< Port D Direction */
N#define OFS_PDREN                                          (0x0066)              /*!< Port D Resistor Enable */
N#define OFS_PDDS                                           (0x0068)              /*!< Port D Drive Strength */
N#define OFS_PDSEL0                                         (0x006A)              /*!< Port D Select 0 */
N#define OFS_PDSEL1                                         (0x006C)              /*!< Port D Select 1 */
N#define OFS_P7IV                                           (0x006E)              /*!< Port 7 Interrupt Vector Register */
N#define OFS_PDSELC                                         (0x0076)              /*!< Port D Complement Select */
N#define OFS_PDIES                                          (0x0078)              /*!< Port D Interrupt Edge Select */
N#define OFS_PDIE                                           (0x007A)              /*!< Port D Interrupt Enable */
N#define OFS_PDIFG                                          (0x007C)              /*!< Port D Interrupt Flag */
N#define OFS_P8IV                                           (0x007E)              /*!< Port 8 Interrupt Vector Register */
N#define OFS_PEIN                                           (0x0080)              /*!< Port E Input */
N#define OFS_PEOUT                                          (0x0082)              /*!< Port E Output */
N#define OFS_PEDIR                                          (0x0084)              /*!< Port E Direction */
N#define OFS_PEREN                                          (0x0086)              /*!< Port E Resistor Enable */
N#define OFS_PEDS                                           (0x0088)              /*!< Port E Drive Strength */
N#define OFS_PESEL0                                         (0x008A)              /*!< Port E Select 0 */
N#define OFS_PESEL1                                         (0x008C)              /*!< Port E Select 1 */
N#define OFS_P9IV                                           (0x008E)              /*!< Port 9 Interrupt Vector Register */
N#define OFS_PESELC                                         (0x0096)              /*!< Port E Complement Select */
N#define OFS_PEIES                                          (0x0098)              /*!< Port E Interrupt Edge Select */
N#define OFS_PEIE                                           (0x009A)              /*!< Port E Interrupt Enable */
N#define OFS_PEIFG                                          (0x009C)              /*!< Port E Interrupt Flag */
N#define OFS_P10IV                                          (0x009E)              /*!< Port 10 Interrupt Vector Register */
N#define OFS_PJIN                                           (0x0120)              /*!< Port J Input */
N#define OFS_PJOUT                                          (0x0122)              /*!< Port J Output */
N#define OFS_PJDIR                                          (0x0124)              /*!< Port J Direction */
N#define OFS_PJREN                                          (0x0126)              /*!< Port J Resistor Enable */
N#define OFS_PJDS                                           (0x0128)              /*!< Port J Drive Strength */
N#define OFS_PJSEL0                                         (0x012A)              /*!< Port J Select 0 */
N#define OFS_PJSEL1                                         (0x012C)              /*!< Port J Select 1 */
N#define OFS_PJSELC                                         (0x0136)              /*!< Port J Complement Select */
N#define OFS_P1IN                                           (0x0000)              /*!< Port 1 Input */
N#define OFS_P2IN                                           (0x0001)              /*!< Port 2 Input */
N#define OFS_P2OUT                                          (0x0003)              /*!< Port 2 Output */
N#define OFS_P1OUT                                          (0x0002)              /*!< Port 1 Output */
N#define OFS_P1DIR                                          (0x0004)              /*!< Port 1 Direction */
N#define OFS_P2DIR                                          (0x0005)              /*!< Port 2 Direction */
N#define OFS_P1REN                                          (0x0006)              /*!< Port 1 Resistor Enable */
N#define OFS_P2REN                                          (0x0007)              /*!< Port 2 Resistor Enable */
N#define OFS_P1DS                                           (0x0008)              /*!< Port 1 Drive Strength */
N#define OFS_P2DS                                           (0x0009)              /*!< Port 2 Drive Strength */
N#define OFS_P1SEL0                                         (0x000A)              /*!< Port 1 Select 0 */
N#define OFS_P2SEL0                                         (0x000B)              /*!< Port 2 Select 0 */
N#define OFS_P1SEL1                                         (0x000C)              /*!< Port 1 Select 1 */
N#define OFS_P2SEL1                                         (0x000D)              /*!< Port 2 Select 1 */
N#define OFS_P1SELC                                         (0x0016)              /*!< Port 1 Complement Select */
N#define OFS_P2SELC                                         (0x0017)              /*!< Port 2 Complement Select */
N#define OFS_P1IES                                          (0x0018)              /*!< Port 1 Interrupt Edge Select */
N#define OFS_P2IES                                          (0x0019)              /*!< Port 2 Interrupt Edge Select */
N#define OFS_P1IE                                           (0x001A)              /*!< Port 1 Interrupt Enable */
N#define OFS_P2IE                                           (0x001B)              /*!< Port 2 Interrupt Enable */
N#define OFS_P1IFG                                          (0x001C)              /*!< Port 1 Interrupt Flag */
N#define OFS_P2IFG                                          (0x001D)              /*!< Port 2 Interrupt Flag */
N#define OFS_P3IN                                           (0x0020)              /*!< Port 3 Input */
N#define OFS_P4IN                                           (0x0021)              /*!< Port 4 Input */
N#define OFS_P3OUT                                          (0x0022)              /*!< Port 3 Output */
N#define OFS_P4OUT                                          (0x0023)              /*!< Port 4 Output */
N#define OFS_P3DIR                                          (0x0024)              /*!< Port 3 Direction */
N#define OFS_P4DIR                                          (0x0025)              /*!< Port 4 Direction */
N#define OFS_P3REN                                          (0x0026)              /*!< Port 3 Resistor Enable */
N#define OFS_P4REN                                          (0x0027)              /*!< Port 4 Resistor Enable */
N#define OFS_P3DS                                           (0x0028)              /*!< Port 3 Drive Strength */
N#define OFS_P4DS                                           (0x0029)              /*!< Port 4 Drive Strength */
N#define OFS_P4SEL0                                         (0x002B)              /*!< Port 4 Select 0 */
N#define OFS_P3SEL0                                         (0x002A)              /*!< Port 3 Select 0 */
N#define OFS_P3SEL1                                         (0x002C)              /*!< Port 3 Select 1 */
N#define OFS_P4SEL1                                         (0x002D)              /*!< Port 4 Select 1 */
N#define OFS_P3SELC                                         (0x0036)              /*!< Port 3 Complement Select */
N#define OFS_P4SELC                                         (0x0037)              /*!< Port 4 Complement Select */
N#define OFS_P3IES                                          (0x0038)              /*!< Port 3 Interrupt Edge Select */
N#define OFS_P4IES                                          (0x0039)              /*!< Port 4 Interrupt Edge Select */
N#define OFS_P3IE                                           (0x003A)              /*!< Port 3 Interrupt Enable */
N#define OFS_P4IE                                           (0x003B)              /*!< Port 4 Interrupt Enable */
N#define OFS_P3IFG                                          (0x003C)              /*!< Port 3 Interrupt Flag */
N#define OFS_P4IFG                                          (0x003D)              /*!< Port 4 Interrupt Flag */
N#define OFS_P5IN                                           (0x0040)              /*!< Port 5 Input */
N#define OFS_P6IN                                           (0x0041)              /*!< Port 6 Input */
N#define OFS_P5OUT                                          (0x0042)              /*!< Port 5 Output */
N#define OFS_P6OUT                                          (0x0043)              /*!< Port 6 Output */
N#define OFS_P5DIR                                          (0x0044)              /*!< Port 5 Direction */
N#define OFS_P6DIR                                          (0x0045)              /*!< Port 6 Direction */
N#define OFS_P5REN                                          (0x0046)              /*!< Port 5 Resistor Enable */
N#define OFS_P6REN                                          (0x0047)              /*!< Port 6 Resistor Enable */
N#define OFS_P5DS                                           (0x0048)              /*!< Port 5 Drive Strength */
N#define OFS_P6DS                                           (0x0049)              /*!< Port 6 Drive Strength */
N#define OFS_P5SEL0                                         (0x004A)              /*!< Port 5 Select 0 */
N#define OFS_P6SEL0                                         (0x004B)              /*!< Port 6 Select 0 */
N#define OFS_P5SEL1                                         (0x004C)              /*!< Port 5 Select 1 */
N#define OFS_P6SEL1                                         (0x004D)              /*!< Port 6 Select 1 */
N#define OFS_P5SELC                                         (0x0056)              /*!< Port 5 Complement Select */
N#define OFS_P6SELC                                         (0x0057)              /*!< Port 6 Complement Select */
N#define OFS_P5IES                                          (0x0058)              /*!< Port 5 Interrupt Edge Select */
N#define OFS_P6IES                                          (0x0059)              /*!< Port 6 Interrupt Edge Select */
N#define OFS_P5IE                                           (0x005A)              /*!< Port 5 Interrupt Enable */
N#define OFS_P6IE                                           (0x005B)              /*!< Port 6 Interrupt Enable */
N#define OFS_P5IFG                                          (0x005C)              /*!< Port 5 Interrupt Flag */
N#define OFS_P6IFG                                          (0x005D)              /*!< Port 6 Interrupt Flag */
N#define OFS_P7IN                                           (0x0060)              /*!< Port 7 Input */
N#define OFS_P8IN                                           (0x0061)              /*!< Port 8 Input */
N#define OFS_P7OUT                                          (0x0062)              /*!< Port 7 Output */
N#define OFS_P8OUT                                          (0x0063)              /*!< Port 8 Output */
N#define OFS_P7DIR                                          (0x0064)              /*!< Port 7 Direction */
N#define OFS_P8DIR                                          (0x0065)              /*!< Port 8 Direction */
N#define OFS_P7REN                                          (0x0066)              /*!< Port 7 Resistor Enable */
N#define OFS_P8REN                                          (0x0067)              /*!< Port 8 Resistor Enable */
N#define OFS_P7DS                                           (0x0068)              /*!< Port 7 Drive Strength */
N#define OFS_P8DS                                           (0x0069)              /*!< Port 8 Drive Strength */
N#define OFS_P7SEL0                                         (0x006A)              /*!< Port 7 Select 0 */
N#define OFS_P8SEL0                                         (0x006B)              /*!< Port 8 Select 0 */
N#define OFS_P7SEL1                                         (0x006C)              /*!< Port 7 Select 1 */
N#define OFS_P8SEL1                                         (0x006D)              /*!< Port 8 Select 1 */
N#define OFS_P7SELC                                         (0x0076)              /*!< Port 7 Complement Select */
N#define OFS_P8SELC                                         (0x0077)              /*!< Port 8 Complement Select */
N#define OFS_P7IES                                          (0x0078)              /*!< Port 7 Interrupt Edge Select */
N#define OFS_P8IES                                          (0x0079)              /*!< Port 8 Interrupt Edge Select */
N#define OFS_P7IE                                           (0x007A)              /*!< Port 7 Interrupt Enable */
N#define OFS_P8IE                                           (0x007B)              /*!< Port 8 Interrupt Enable */
N#define OFS_P7IFG                                          (0x007C)              /*!< Port 7 Interrupt Flag */
N#define OFS_P8IFG                                          (0x007D)              /*!< Port 8 Interrupt Flag */
N#define OFS_P9IN                                           (0x0080)              /*!< Port 9 Input */
N#define OFS_P10IN                                          (0x0081)              /*!< Port 10 Input */
N#define OFS_P9OUT                                          (0x0082)              /*!< Port 9 Output */
N#define OFS_P10OUT                                         (0x0083)              /*!< Port 10 Output */
N#define OFS_P9DIR                                          (0x0084)              /*!< Port 9 Direction */
N#define OFS_P10DIR                                         (0x0085)              /*!< Port 10 Direction */
N#define OFS_P9REN                                          (0x0086)              /*!< Port 9 Resistor Enable */
N#define OFS_P10REN                                         (0x0087)              /*!< Port 10 Resistor Enable */
N#define OFS_P9DS                                           (0x0088)              /*!< Port 9 Drive Strength */
N#define OFS_P10DS                                          (0x0089)              /*!< Port 10 Drive Strength */
N#define OFS_P9SEL0                                         (0x008A)              /*!< Port 9 Select 0 */
N#define OFS_P10SEL0                                        (0x008B)              /*!< Port 10 Select 0 */
N#define OFS_P9SEL1                                         (0x008C)              /*!< Port 9 Select 1 */
N#define OFS_P10SEL1                                        (0x008D)              /*!< Port 10 Select 1 */
N#define OFS_P9SELC                                         (0x0096)              /*!< Port 9 Complement Select */
N#define OFS_P10SELC                                        (0x0097)              /*!< Port 10 Complement Select */
N#define OFS_P9IES                                          (0x0098)              /*!< Port 9 Interrupt Edge Select */
N#define OFS_P10IES                                         (0x0099)              /*!< Port 10 Interrupt Edge Select */
N#define OFS_P9IE                                           (0x009A)              /*!< Port 9 Interrupt Enable */
N#define OFS_P10IE                                          (0x009B)              /*!< Port 10 Interrupt Enable */
N#define OFS_P9IFG                                          (0x009C)              /*!< Port 9 Interrupt Flag */
N#define OFS_P10IFG                                         (0x009D)              /*!< Port 10 Interrupt Flag */
N
N
N/******************************************************************************
N* EUSCI_A0 Registers
N******************************************************************************/
N#define UCA0CTLW0                                (HWREG16(0x40001000))           /*!< eUSCI_Ax Control Word Register 0 */
N#define UCA0CTLW0_SPI                            (HWREG16(0x40001000))           
N#define UCA0CTLW1                                (HWREG16(0x40001002))           /*!< eUSCI_Ax Control Word Register 1 */
N#define UCA0BRW                                  (HWREG16(0x40001006))           /*!< eUSCI_Ax Baud Rate Control Word Register */
N#define UCA0BRW_SPI                              (HWREG16(0x40001006))           
N#define UCA0MCTLW                                (HWREG16(0x40001008))           /*!< eUSCI_Ax Modulation Control Word Register */
N#define UCA0STATW                                (HWREG16(0x4000100A))           /*!< eUSCI_Ax Status Register */
N#define UCA0STATW_SPI                            (HWREG16(0x4000100A))           
N#define UCA0RXBUF                                (HWREG16(0x4000100C))           /*!< eUSCI_Ax Receive Buffer Register */
N#define UCA0RXBUF_SPI                            (HWREG16(0x4000100C))           
N#define UCA0TXBUF                                (HWREG16(0x4000100E))           /*!< eUSCI_Ax Transmit Buffer Register */
N#define UCA0TXBUF_SPI                            (HWREG16(0x4000100E))           
N#define UCA0ABCTL                                (HWREG16(0x40001010))           /*!< eUSCI_Ax Auto Baud Rate Control Register */
N#define UCA0IRCTL                                (HWREG16(0x40001012))           /*!< eUSCI_Ax IrDA Control Word Register */
N#define UCA0IE                                   (HWREG16(0x4000101A))           /*!< eUSCI_Ax Interrupt Enable Register */
N#define UCA0IE_SPI                               (HWREG16(0x4000101A))           
N#define UCA0IFG                                  (HWREG16(0x4000101C))           /*!< eUSCI_Ax Interrupt Flag Register */
N#define UCA0IFG_SPI                              (HWREG16(0x4000101C))           
N#define UCA0IV                                   (HWREG16(0x4000101E))           /*!< eUSCI_Ax Interrupt Vector Register */
N#define UCA0IV_SPI                               (HWREG16(0x4000101E))           
N
N/* Register offsets from EUSCI_A0_BASE address */
N#define OFS_UCA0CTLW0                                      (0x0000)              /*!< eUSCI_Ax Control Word Register 0 */
N#define OFS_UCA0CTLW0_SPI                                  (0x0000)              
N#define OFS_UCA0CTLW1                                      (0x0002)              /*!< eUSCI_Ax Control Word Register 1 */
N#define OFS_UCA0BRW                                        (0x0006)              /*!< eUSCI_Ax Baud Rate Control Word Register */
N#define OFS_UCA0BRW_SPI                                    (0x0006)              
N#define OFS_UCA0MCTLW                                      (0x0008)              /*!< eUSCI_Ax Modulation Control Word Register */
N#define OFS_UCA0STATW                                      (0x000A)              /*!< eUSCI_Ax Status Register */
N#define OFS_UCA0STATW_SPI                                  (0x000A)              
N#define OFS_UCA0RXBUF                                      (0x000C)              /*!< eUSCI_Ax Receive Buffer Register */
N#define OFS_UCA0RXBUF_SPI                                  (0x000C)              
N#define OFS_UCA0TXBUF                                      (0x000E)              /*!< eUSCI_Ax Transmit Buffer Register */
N#define OFS_UCA0TXBUF_SPI                                  (0x000E)              
N#define OFS_UCA0ABCTL                                      (0x0010)              /*!< eUSCI_Ax Auto Baud Rate Control Register */
N#define OFS_UCA0IRCTL                                      (0x0012)              /*!< eUSCI_Ax IrDA Control Word Register */
N#define OFS_UCA0IE                                         (0x001A)              /*!< eUSCI_Ax Interrupt Enable Register */
N#define OFS_UCA0IE_SPI                                     (0x001A)              
N#define OFS_UCA0IFG                                        (0x001C)              /*!< eUSCI_Ax Interrupt Flag Register */
N#define OFS_UCA0IFG_SPI                                    (0x001C)              
N#define OFS_UCA0IV                                         (0x001E)              /*!< eUSCI_Ax Interrupt Vector Register */
N#define OFS_UCA0IV_SPI                                     (0x001E)              
N
N#define UCA0CTL0                                           (HWREG8_L(UCA0CTLW0)) /* eUSCI_Ax Control 0 */
N#define UCA0CTL1                                           (HWREG8_H(UCA0CTLW0)) /* eUSCI_Ax Control 1 */
N#define UCA0BR0                                            (HWREG8_L(UCA0BRW))   /* eUSCI_Ax Baud Rate Control 0 */
N#define UCA0BR1                                            (HWREG8_H(UCA0BRW))   /* eUSCI_Ax Baud Rate Control 1 */
N#define UCA0IRTCTL                                         (HWREG8_L(UCA0IRCTL)) /* eUSCI_Ax IrDA Transmit Control */
N#define UCA0IRRCTL                                         (HWREG8_H(UCA0IRCTL)) /* eUSCI_Ax IrDA Receive Control */
N
N/******************************************************************************
N* EUSCI_A1 Registers
N******************************************************************************/
N#define UCA1CTLW0                                (HWREG16(0x40001400))           /*!< eUSCI_Ax Control Word Register 0 */
N#define UCA1CTLW0_SPI                            (HWREG16(0x40001400))           
N#define UCA1CTLW1                                (HWREG16(0x40001402))           /*!< eUSCI_Ax Control Word Register 1 */
N#define UCA1BRW                                  (HWREG16(0x40001406))           /*!< eUSCI_Ax Baud Rate Control Word Register */
N#define UCA1BRW_SPI                              (HWREG16(0x40001406))           
N#define UCA1MCTLW                                (HWREG16(0x40001408))           /*!< eUSCI_Ax Modulation Control Word Register */
N#define UCA1STATW                                (HWREG16(0x4000140A))           /*!< eUSCI_Ax Status Register */
N#define UCA1STATW_SPI                            (HWREG16(0x4000140A))           
N#define UCA1RXBUF                                (HWREG16(0x4000140C))           /*!< eUSCI_Ax Receive Buffer Register */
N#define UCA1RXBUF_SPI                            (HWREG16(0x4000140C))           
N#define UCA1TXBUF                                (HWREG16(0x4000140E))           /*!< eUSCI_Ax Transmit Buffer Register */
N#define UCA1TXBUF_SPI                            (HWREG16(0x4000140E))           
N#define UCA1ABCTL                                (HWREG16(0x40001410))           /*!< eUSCI_Ax Auto Baud Rate Control Register */
N#define UCA1IRCTL                                (HWREG16(0x40001412))           /*!< eUSCI_Ax IrDA Control Word Register */
N#define UCA1IE                                   (HWREG16(0x4000141A))           /*!< eUSCI_Ax Interrupt Enable Register */
N#define UCA1IE_SPI                               (HWREG16(0x4000141A))           
N#define UCA1IFG                                  (HWREG16(0x4000141C))           /*!< eUSCI_Ax Interrupt Flag Register */
N#define UCA1IFG_SPI                              (HWREG16(0x4000141C))           
N#define UCA1IV                                   (HWREG16(0x4000141E))           /*!< eUSCI_Ax Interrupt Vector Register */
N#define UCA1IV_SPI                               (HWREG16(0x4000141E))           
N
N/* Register offsets from EUSCI_A1_BASE address */
N#define OFS_UCA1CTLW0                                      (0x0000)              /*!< eUSCI_Ax Control Word Register 0 */
N#define OFS_UCA1CTLW0_SPI                                  (0x0000)              
N#define OFS_UCA1CTLW1                                      (0x0002)              /*!< eUSCI_Ax Control Word Register 1 */
N#define OFS_UCA1BRW                                        (0x0006)              /*!< eUSCI_Ax Baud Rate Control Word Register */
N#define OFS_UCA1BRW_SPI                                    (0x0006)              
N#define OFS_UCA1MCTLW                                      (0x0008)              /*!< eUSCI_Ax Modulation Control Word Register */
N#define OFS_UCA1STATW                                      (0x000A)              /*!< eUSCI_Ax Status Register */
N#define OFS_UCA1STATW_SPI                                  (0x000A)              
N#define OFS_UCA1RXBUF                                      (0x000C)              /*!< eUSCI_Ax Receive Buffer Register */
N#define OFS_UCA1RXBUF_SPI                                  (0x000C)              
N#define OFS_UCA1TXBUF                                      (0x000E)              /*!< eUSCI_Ax Transmit Buffer Register */
N#define OFS_UCA1TXBUF_SPI                                  (0x000E)              
N#define OFS_UCA1ABCTL                                      (0x0010)              /*!< eUSCI_Ax Auto Baud Rate Control Register */
N#define OFS_UCA1IRCTL                                      (0x0012)              /*!< eUSCI_Ax IrDA Control Word Register */
N#define OFS_UCA1IE                                         (0x001A)              /*!< eUSCI_Ax Interrupt Enable Register */
N#define OFS_UCA1IE_SPI                                     (0x001A)              
N#define OFS_UCA1IFG                                        (0x001C)              /*!< eUSCI_Ax Interrupt Flag Register */
N#define OFS_UCA1IFG_SPI                                    (0x001C)              
N#define OFS_UCA1IV                                         (0x001E)              /*!< eUSCI_Ax Interrupt Vector Register */
N#define OFS_UCA1IV_SPI                                     (0x001E)              
N
N#define UCA1CTL0                                           (HWREG8_L(UCA1CTLW0)) /* eUSCI_Ax Control 0 */
N#define UCA1CTL1                                           (HWREG8_H(UCA1CTLW0)) /* eUSCI_Ax Control 1 */
N#define UCA1BR0                                            (HWREG8_L(UCA1BRW))   /* eUSCI_Ax Baud Rate Control 0 */
N#define UCA1BR1                                            (HWREG8_H(UCA1BRW))   /* eUSCI_Ax Baud Rate Control 1 */
N#define UCA1IRTCTL                                         (HWREG8_L(UCA1IRCTL)) /* eUSCI_Ax IrDA Transmit Control */
N#define UCA1IRRCTL                                         (HWREG8_H(UCA1IRCTL)) /* eUSCI_Ax IrDA Receive Control */
N
N/******************************************************************************
N* EUSCI_A2 Registers
N******************************************************************************/
N#define UCA2CTLW0                                (HWREG16(0x40001800))           /*!< eUSCI_Ax Control Word Register 0 */
N#define UCA2CTLW0_SPI                            (HWREG16(0x40001800))           
N#define UCA2CTLW1                                (HWREG16(0x40001802))           /*!< eUSCI_Ax Control Word Register 1 */
N#define UCA2BRW                                  (HWREG16(0x40001806))           /*!< eUSCI_Ax Baud Rate Control Word Register */
N#define UCA2BRW_SPI                              (HWREG16(0x40001806))           
N#define UCA2MCTLW                                (HWREG16(0x40001808))           /*!< eUSCI_Ax Modulation Control Word Register */
N#define UCA2STATW                                (HWREG16(0x4000180A))           /*!< eUSCI_Ax Status Register */
N#define UCA2STATW_SPI                            (HWREG16(0x4000180A))           
N#define UCA2RXBUF                                (HWREG16(0x4000180C))           /*!< eUSCI_Ax Receive Buffer Register */
N#define UCA2RXBUF_SPI                            (HWREG16(0x4000180C))           
N#define UCA2TXBUF                                (HWREG16(0x4000180E))           /*!< eUSCI_Ax Transmit Buffer Register */
N#define UCA2TXBUF_SPI                            (HWREG16(0x4000180E))           
N#define UCA2ABCTL                                (HWREG16(0x40001810))           /*!< eUSCI_Ax Auto Baud Rate Control Register */
N#define UCA2IRCTL                                (HWREG16(0x40001812))           /*!< eUSCI_Ax IrDA Control Word Register */
N#define UCA2IE                                   (HWREG16(0x4000181A))           /*!< eUSCI_Ax Interrupt Enable Register */
N#define UCA2IE_SPI                               (HWREG16(0x4000181A))           
N#define UCA2IFG                                  (HWREG16(0x4000181C))           /*!< eUSCI_Ax Interrupt Flag Register */
N#define UCA2IFG_SPI                              (HWREG16(0x4000181C))           
N#define UCA2IV                                   (HWREG16(0x4000181E))           /*!< eUSCI_Ax Interrupt Vector Register */
N#define UCA2IV_SPI                               (HWREG16(0x4000181E))           
N
N/* Register offsets from EUSCI_A2_BASE address */
N#define OFS_UCA2CTLW0                                      (0x0000)              /*!< eUSCI_Ax Control Word Register 0 */
N#define OFS_UCA2CTLW0_SPI                                  (0x0000)              
N#define OFS_UCA2CTLW1                                      (0x0002)              /*!< eUSCI_Ax Control Word Register 1 */
N#define OFS_UCA2BRW                                        (0x0006)              /*!< eUSCI_Ax Baud Rate Control Word Register */
N#define OFS_UCA2BRW_SPI                                    (0x0006)              
N#define OFS_UCA2MCTLW                                      (0x0008)              /*!< eUSCI_Ax Modulation Control Word Register */
N#define OFS_UCA2STATW                                      (0x000A)              /*!< eUSCI_Ax Status Register */
N#define OFS_UCA2STATW_SPI                                  (0x000A)              
N#define OFS_UCA2RXBUF                                      (0x000C)              /*!< eUSCI_Ax Receive Buffer Register */
N#define OFS_UCA2RXBUF_SPI                                  (0x000C)              
N#define OFS_UCA2TXBUF                                      (0x000E)              /*!< eUSCI_Ax Transmit Buffer Register */
N#define OFS_UCA2TXBUF_SPI                                  (0x000E)              
N#define OFS_UCA2ABCTL                                      (0x0010)              /*!< eUSCI_Ax Auto Baud Rate Control Register */
N#define OFS_UCA2IRCTL                                      (0x0012)              /*!< eUSCI_Ax IrDA Control Word Register */
N#define OFS_UCA2IE                                         (0x001A)              /*!< eUSCI_Ax Interrupt Enable Register */
N#define OFS_UCA2IE_SPI                                     (0x001A)              
N#define OFS_UCA2IFG                                        (0x001C)              /*!< eUSCI_Ax Interrupt Flag Register */
N#define OFS_UCA2IFG_SPI                                    (0x001C)              
N#define OFS_UCA2IV                                         (0x001E)              /*!< eUSCI_Ax Interrupt Vector Register */
N#define OFS_UCA2IV_SPI                                     (0x001E)              
N
N#define UCA2CTL0                                           (HWREG8_L(UCA2CTLW0)) /* eUSCI_Ax Control 0 */
N#define UCA2CTL1                                           (HWREG8_H(UCA2CTLW0)) /* eUSCI_Ax Control 1 */
N#define UCA2BR0                                            (HWREG8_L(UCA2BRW))   /* eUSCI_Ax Baud Rate Control 0 */
N#define UCA2BR1                                            (HWREG8_H(UCA2BRW))   /* eUSCI_Ax Baud Rate Control 1 */
N#define UCA2IRTCTL                                         (HWREG8_L(UCA2IRCTL)) /* eUSCI_Ax IrDA Transmit Control */
N#define UCA2IRRCTL                                         (HWREG8_H(UCA2IRCTL)) /* eUSCI_Ax IrDA Receive Control */
N
N/******************************************************************************
N* EUSCI_A3 Registers
N******************************************************************************/
N#define UCA3CTLW0                                (HWREG16(0x40001C00))           /*!< eUSCI_Ax Control Word Register 0 */
N#define UCA3CTLW0_SPI                            (HWREG16(0x40001C00))           
N#define UCA3CTLW1                                (HWREG16(0x40001C02))           /*!< eUSCI_Ax Control Word Register 1 */
N#define UCA3BRW                                  (HWREG16(0x40001C06))           /*!< eUSCI_Ax Baud Rate Control Word Register */
N#define UCA3BRW_SPI                              (HWREG16(0x40001C06))           
N#define UCA3MCTLW                                (HWREG16(0x40001C08))           /*!< eUSCI_Ax Modulation Control Word Register */
N#define UCA3STATW                                (HWREG16(0x40001C0A))           /*!< eUSCI_Ax Status Register */
N#define UCA3STATW_SPI                            (HWREG16(0x40001C0A))           
N#define UCA3RXBUF                                (HWREG16(0x40001C0C))           /*!< eUSCI_Ax Receive Buffer Register */
N#define UCA3RXBUF_SPI                            (HWREG16(0x40001C0C))           
N#define UCA3TXBUF                                (HWREG16(0x40001C0E))           /*!< eUSCI_Ax Transmit Buffer Register */
N#define UCA3TXBUF_SPI                            (HWREG16(0x40001C0E))           
N#define UCA3ABCTL                                (HWREG16(0x40001C10))           /*!< eUSCI_Ax Auto Baud Rate Control Register */
N#define UCA3IRCTL                                (HWREG16(0x40001C12))           /*!< eUSCI_Ax IrDA Control Word Register */
N#define UCA3IE                                   (HWREG16(0x40001C1A))           /*!< eUSCI_Ax Interrupt Enable Register */
N#define UCA3IE_SPI                               (HWREG16(0x40001C1A))           
N#define UCA3IFG                                  (HWREG16(0x40001C1C))           /*!< eUSCI_Ax Interrupt Flag Register */
N#define UCA3IFG_SPI                              (HWREG16(0x40001C1C))           
N#define UCA3IV                                   (HWREG16(0x40001C1E))           /*!< eUSCI_Ax Interrupt Vector Register */
N#define UCA3IV_SPI                               (HWREG16(0x40001C1E))           
N
N/* Register offsets from EUSCI_A3_BASE address */
N#define OFS_UCA3CTLW0                                      (0x0000)              /*!< eUSCI_Ax Control Word Register 0 */
N#define OFS_UCA3CTLW0_SPI                                  (0x0000)              
N#define OFS_UCA3CTLW1                                      (0x0002)              /*!< eUSCI_Ax Control Word Register 1 */
N#define OFS_UCA3BRW                                        (0x0006)              /*!< eUSCI_Ax Baud Rate Control Word Register */
N#define OFS_UCA3BRW_SPI                                    (0x0006)              
N#define OFS_UCA3MCTLW                                      (0x0008)              /*!< eUSCI_Ax Modulation Control Word Register */
N#define OFS_UCA3STATW                                      (0x000A)              /*!< eUSCI_Ax Status Register */
N#define OFS_UCA3STATW_SPI                                  (0x000A)              
N#define OFS_UCA3RXBUF                                      (0x000C)              /*!< eUSCI_Ax Receive Buffer Register */
N#define OFS_UCA3RXBUF_SPI                                  (0x000C)              
N#define OFS_UCA3TXBUF                                      (0x000E)              /*!< eUSCI_Ax Transmit Buffer Register */
N#define OFS_UCA3TXBUF_SPI                                  (0x000E)              
N#define OFS_UCA3ABCTL                                      (0x0010)              /*!< eUSCI_Ax Auto Baud Rate Control Register */
N#define OFS_UCA3IRCTL                                      (0x0012)              /*!< eUSCI_Ax IrDA Control Word Register */
N#define OFS_UCA3IE                                         (0x001A)              /*!< eUSCI_Ax Interrupt Enable Register */
N#define OFS_UCA3IE_SPI                                     (0x001A)              
N#define OFS_UCA3IFG                                        (0x001C)              /*!< eUSCI_Ax Interrupt Flag Register */
N#define OFS_UCA3IFG_SPI                                    (0x001C)              
N#define OFS_UCA3IV                                         (0x001E)              /*!< eUSCI_Ax Interrupt Vector Register */
N#define OFS_UCA3IV_SPI                                     (0x001E)              
N
N#define UCA3CTL0                                           (HWREG8_L(UCA3CTLW0)) /* eUSCI_Ax Control 0 */
N#define UCA3CTL1                                           (HWREG8_H(UCA3CTLW0)) /* eUSCI_Ax Control 1 */
N#define UCA3BR0                                            (HWREG8_L(UCA3BRW))   /* eUSCI_Ax Baud Rate Control 0 */
N#define UCA3BR1                                            (HWREG8_H(UCA3BRW))   /* eUSCI_Ax Baud Rate Control 1 */
N#define UCA3IRTCTL                                         (HWREG8_L(UCA3IRCTL)) /* eUSCI_Ax IrDA Transmit Control */
N#define UCA3IRRCTL                                         (HWREG8_H(UCA3IRCTL)) /* eUSCI_Ax IrDA Receive Control */
N
N/******************************************************************************
N* EUSCI_B0 Registers
N******************************************************************************/
N#define UCB0CTLW0                                (HWREG16(0x40002000))           /*!< eUSCI_Bx Control Word Register 0 */
N#define UCB0CTLW0_SPI                            (HWREG16(0x40002000))           
N#define UCB0CTLW1                                (HWREG16(0x40002002))           /*!< eUSCI_Bx Control Word Register 1 */
N#define UCB0BRW                                  (HWREG16(0x40002006))           /*!< eUSCI_Bx Baud Rate Control Word Register */
N#define UCB0BRW_SPI                              (HWREG16(0x40002006))           
N#define UCB0STATW                                (HWREG16(0x40002008))           /*!< eUSCI_Bx Status Register */
N#define UCB0STATW_SPI                            (HWREG16(0x40002008))           
N#define UCB0TBCNT                                (HWREG16(0x4000200A))           /*!< eUSCI_Bx Byte Counter Threshold Register */
N#define UCB0RXBUF                                (HWREG16(0x4000200C))           /*!< eUSCI_Bx Receive Buffer Register */
N#define UCB0RXBUF_SPI                            (HWREG16(0x4000200C))           
N#define UCB0TXBUF                                (HWREG16(0x4000200E))           /*!< eUSCI_Bx Transmit Buffer Register */
N#define UCB0TXBUF_SPI                            (HWREG16(0x4000200E))           
N#define UCB0I2COA0                               (HWREG16(0x40002014))           /*!< eUSCI_Bx I2C Own Address 0 Register */
N#define UCB0I2COA1                               (HWREG16(0x40002016))           /*!< eUSCI_Bx I2C Own Address 1 Register */
N#define UCB0I2COA2                               (HWREG16(0x40002018))           /*!< eUSCI_Bx I2C Own Address 2 Register */
N#define UCB0I2COA3                               (HWREG16(0x4000201A))           /*!< eUSCI_Bx I2C Own Address 3 Register */
N#define UCB0ADDRX                                (HWREG16(0x4000201C))           /*!< eUSCI_Bx I2C Received Address Register */
N#define UCB0ADDMASK                              (HWREG16(0x4000201E))           /*!< eUSCI_Bx I2C Address Mask Register */
N#define UCB0I2CSA                                (HWREG16(0x40002020))           /*!< eUSCI_Bx I2C Slave Address Register */
N#define UCB0IE                                   (HWREG16(0x4000202A))           /*!< eUSCI_Bx Interrupt Enable Register */
N#define UCB0IE_SPI                               (HWREG16(0x4000202A))           
N#define UCB0IFG                                  (HWREG16(0x4000202C))           /*!< eUSCI_Bx Interrupt Flag Register */
N#define UCB0IFG_SPI                              (HWREG16(0x4000202C))           
N#define UCB0IV                                   (HWREG16(0x4000202E))           /*!< eUSCI_Bx Interrupt Vector Register */
N#define UCB0IV_SPI                               (HWREG16(0x4000202E))           
N
N/* Register offsets from EUSCI_B0_BASE address */
N#define OFS_UCB0CTLW0                                      (0x0000)              /*!< eUSCI_Bx Control Word Register 0 */
N#define OFS_UCB0CTLW0_SPI                                  (0x0000)              
N#define OFS_UCB0CTLW1                                      (0x0002)              /*!< eUSCI_Bx Control Word Register 1 */
N#define OFS_UCB0BRW                                        (0x0006)              /*!< eUSCI_Bx Baud Rate Control Word Register */
N#define OFS_UCB0BRW_SPI                                    (0x0006)              
N#define OFS_UCB0STATW                                      (0x0008)              /*!< eUSCI_Bx Status Register */
N#define OFS_UCB0STATW_SPI                                  (0x0008)              
N#define OFS_UCB0TBCNT                                      (0x000A)              /*!< eUSCI_Bx Byte Counter Threshold Register */
N#define OFS_UCB0RXBUF                                      (0x000C)              /*!< eUSCI_Bx Receive Buffer Register */
N#define OFS_UCB0RXBUF_SPI                                  (0x000C)              
N#define OFS_UCB0TXBUF                                      (0x000E)              /*!< eUSCI_Bx Transmit Buffer Register */
N#define OFS_UCB0TXBUF_SPI                                  (0x000E)              
N#define OFS_UCB0I2COA0                                     (0x0014)              /*!< eUSCI_Bx I2C Own Address 0 Register */
N#define OFS_UCB0I2COA1                                     (0x0016)              /*!< eUSCI_Bx I2C Own Address 1 Register */
N#define OFS_UCB0I2COA2                                     (0x0018)              /*!< eUSCI_Bx I2C Own Address 2 Register */
N#define OFS_UCB0I2COA3                                     (0x001A)              /*!< eUSCI_Bx I2C Own Address 3 Register */
N#define OFS_UCB0ADDRX                                      (0x001C)              /*!< eUSCI_Bx I2C Received Address Register */
N#define OFS_UCB0ADDMASK                                    (0x001E)              /*!< eUSCI_Bx I2C Address Mask Register */
N#define OFS_UCB0I2CSA                                      (0x0020)              /*!< eUSCI_Bx I2C Slave Address Register */
N#define OFS_UCB0IE                                         (0x002A)              /*!< eUSCI_Bx Interrupt Enable Register */
N#define OFS_UCB0IE_SPI                                     (0x002A)              
N#define OFS_UCB0IFG                                        (0x002C)              /*!< eUSCI_Bx Interrupt Flag Register */
N#define OFS_UCB0IFG_SPI                                    (0x002C)              
N#define OFS_UCB0IV                                         (0x002E)              /*!< eUSCI_Bx Interrupt Vector Register */
N#define OFS_UCB0IV_SPI                                     (0x002E)              
N
N#define UCB0CTL0                                           (HWREG8_L(UCB0CTLW0)) /* eUSCI_Bx Control 1 */
N#define UCB0CTL1                                           (HWREG8_H(UCB0CTLW0)) /* eUSCI_Bx Control 0 */
N#define UCB0BR0                                            (HWREG8_L(UCB0BRW))   /* eUSCI_Bx Bit Rate Control 0 */
N#define UCB0BR1                                            (HWREG8_H(UCB0BRW))   /* eUSCI_Bx Bit Rate Control 1 */
N#define UCB0STAT                                           (HWREG8_L(UCB0STATW)) /* eUSCI_Bx Status */
N#define UCB0BCNT                                           (HWREG8_H(UCB0STATW)) /* eUSCI_Bx Byte Counter Register */
N
N/******************************************************************************
N* EUSCI_B1 Registers
N******************************************************************************/
N#define UCB1CTLW0                                (HWREG16(0x40002400))           /*!< eUSCI_Bx Control Word Register 0 */
N#define UCB1CTLW0_SPI                            (HWREG16(0x40002400))           
N#define UCB1CTLW1                                (HWREG16(0x40002402))           /*!< eUSCI_Bx Control Word Register 1 */
N#define UCB1BRW                                  (HWREG16(0x40002406))           /*!< eUSCI_Bx Baud Rate Control Word Register */
N#define UCB1BRW_SPI                              (HWREG16(0x40002406))           
N#define UCB1STATW                                (HWREG16(0x40002408))           /*!< eUSCI_Bx Status Register */
N#define UCB1STATW_SPI                            (HWREG16(0x40002408))           
N#define UCB1TBCNT                                (HWREG16(0x4000240A))           /*!< eUSCI_Bx Byte Counter Threshold Register */
N#define UCB1RXBUF                                (HWREG16(0x4000240C))           /*!< eUSCI_Bx Receive Buffer Register */
N#define UCB1RXBUF_SPI                            (HWREG16(0x4000240C))           
N#define UCB1TXBUF                                (HWREG16(0x4000240E))           /*!< eUSCI_Bx Transmit Buffer Register */
N#define UCB1TXBUF_SPI                            (HWREG16(0x4000240E))           
N#define UCB1I2COA0                               (HWREG16(0x40002414))           /*!< eUSCI_Bx I2C Own Address 0 Register */
N#define UCB1I2COA1                               (HWREG16(0x40002416))           /*!< eUSCI_Bx I2C Own Address 1 Register */
N#define UCB1I2COA2                               (HWREG16(0x40002418))           /*!< eUSCI_Bx I2C Own Address 2 Register */
N#define UCB1I2COA3                               (HWREG16(0x4000241A))           /*!< eUSCI_Bx I2C Own Address 3 Register */
N#define UCB1ADDRX                                (HWREG16(0x4000241C))           /*!< eUSCI_Bx I2C Received Address Register */
N#define UCB1ADDMASK                              (HWREG16(0x4000241E))           /*!< eUSCI_Bx I2C Address Mask Register */
N#define UCB1I2CSA                                (HWREG16(0x40002420))           /*!< eUSCI_Bx I2C Slave Address Register */
N#define UCB1IE                                   (HWREG16(0x4000242A))           /*!< eUSCI_Bx Interrupt Enable Register */
N#define UCB1IE_SPI                               (HWREG16(0x4000242A))           
N#define UCB1IFG                                  (HWREG16(0x4000242C))           /*!< eUSCI_Bx Interrupt Flag Register */
N#define UCB1IFG_SPI                              (HWREG16(0x4000242C))           
N#define UCB1IV                                   (HWREG16(0x4000242E))           /*!< eUSCI_Bx Interrupt Vector Register */
N#define UCB1IV_SPI                               (HWREG16(0x4000242E))           
N
N/* Register offsets from EUSCI_B1_BASE address */
N#define OFS_UCB1CTLW0                                      (0x0000)              /*!< eUSCI_Bx Control Word Register 0 */
N#define OFS_UCB1CTLW0_SPI                                  (0x0000)              
N#define OFS_UCB1CTLW1                                      (0x0002)              /*!< eUSCI_Bx Control Word Register 1 */
N#define OFS_UCB1BRW                                        (0x0006)              /*!< eUSCI_Bx Baud Rate Control Word Register */
N#define OFS_UCB1BRW_SPI                                    (0x0006)              
N#define OFS_UCB1STATW                                      (0x0008)              /*!< eUSCI_Bx Status Register */
N#define OFS_UCB1STATW_SPI                                  (0x0008)              
N#define OFS_UCB1TBCNT                                      (0x000A)              /*!< eUSCI_Bx Byte Counter Threshold Register */
N#define OFS_UCB1RXBUF                                      (0x000C)              /*!< eUSCI_Bx Receive Buffer Register */
N#define OFS_UCB1RXBUF_SPI                                  (0x000C)              
N#define OFS_UCB1TXBUF                                      (0x000E)              /*!< eUSCI_Bx Transmit Buffer Register */
N#define OFS_UCB1TXBUF_SPI                                  (0x000E)              
N#define OFS_UCB1I2COA0                                     (0x0014)              /*!< eUSCI_Bx I2C Own Address 0 Register */
N#define OFS_UCB1I2COA1                                     (0x0016)              /*!< eUSCI_Bx I2C Own Address 1 Register */
N#define OFS_UCB1I2COA2                                     (0x0018)              /*!< eUSCI_Bx I2C Own Address 2 Register */
N#define OFS_UCB1I2COA3                                     (0x001A)              /*!< eUSCI_Bx I2C Own Address 3 Register */
N#define OFS_UCB1ADDRX                                      (0x001C)              /*!< eUSCI_Bx I2C Received Address Register */
N#define OFS_UCB1ADDMASK                                    (0x001E)              /*!< eUSCI_Bx I2C Address Mask Register */
N#define OFS_UCB1I2CSA                                      (0x0020)              /*!< eUSCI_Bx I2C Slave Address Register */
N#define OFS_UCB1IE                                         (0x002A)              /*!< eUSCI_Bx Interrupt Enable Register */
N#define OFS_UCB1IE_SPI                                     (0x002A)              
N#define OFS_UCB1IFG                                        (0x002C)              /*!< eUSCI_Bx Interrupt Flag Register */
N#define OFS_UCB1IFG_SPI                                    (0x002C)              
N#define OFS_UCB1IV                                         (0x002E)              /*!< eUSCI_Bx Interrupt Vector Register */
N#define OFS_UCB1IV_SPI                                     (0x002E)              
N
N#define UCB1CTL0                                           (HWREG8_L(UCB1CTLW0)) /* eUSCI_Bx Control 1 */
N#define UCB1CTL1                                           (HWREG8_H(UCB1CTLW0)) /* eUSCI_Bx Control 0 */
N#define UCB1BR0                                            (HWREG8_L(UCB1BRW))   /* eUSCI_Bx Bit Rate Control 0 */
N#define UCB1BR1                                            (HWREG8_H(UCB1BRW))   /* eUSCI_Bx Bit Rate Control 1 */
N#define UCB1STAT                                           (HWREG8_L(UCB1STATW)) /* eUSCI_Bx Status */
N#define UCB1BCNT                                           (HWREG8_H(UCB1STATW)) /* eUSCI_Bx Byte Counter Register */
N
N/******************************************************************************
N* EUSCI_B2 Registers
N******************************************************************************/
N#define UCB2CTLW0                                (HWREG16(0x40002800))           /*!< eUSCI_Bx Control Word Register 0 */
N#define UCB2CTLW0_SPI                            (HWREG16(0x40002800))           
N#define UCB2CTLW1                                (HWREG16(0x40002802))           /*!< eUSCI_Bx Control Word Register 1 */
N#define UCB2BRW                                  (HWREG16(0x40002806))           /*!< eUSCI_Bx Baud Rate Control Word Register */
N#define UCB2BRW_SPI                              (HWREG16(0x40002806))           
N#define UCB2STATW                                (HWREG16(0x40002808))           /*!< eUSCI_Bx Status Register */
N#define UCB2STATW_SPI                            (HWREG16(0x40002808))           
N#define UCB2TBCNT                                (HWREG16(0x4000280A))           /*!< eUSCI_Bx Byte Counter Threshold Register */
N#define UCB2RXBUF                                (HWREG16(0x4000280C))           /*!< eUSCI_Bx Receive Buffer Register */
N#define UCB2RXBUF_SPI                            (HWREG16(0x4000280C))           
N#define UCB2TXBUF                                (HWREG16(0x4000280E))           /*!< eUSCI_Bx Transmit Buffer Register */
N#define UCB2TXBUF_SPI                            (HWREG16(0x4000280E))           
N#define UCB2I2COA0                               (HWREG16(0x40002814))           /*!< eUSCI_Bx I2C Own Address 0 Register */
N#define UCB2I2COA1                               (HWREG16(0x40002816))           /*!< eUSCI_Bx I2C Own Address 1 Register */
N#define UCB2I2COA2                               (HWREG16(0x40002818))           /*!< eUSCI_Bx I2C Own Address 2 Register */
N#define UCB2I2COA3                               (HWREG16(0x4000281A))           /*!< eUSCI_Bx I2C Own Address 3 Register */
N#define UCB2ADDRX                                (HWREG16(0x4000281C))           /*!< eUSCI_Bx I2C Received Address Register */
N#define UCB2ADDMASK                              (HWREG16(0x4000281E))           /*!< eUSCI_Bx I2C Address Mask Register */
N#define UCB2I2CSA                                (HWREG16(0x40002820))           /*!< eUSCI_Bx I2C Slave Address Register */
N#define UCB2IE                                   (HWREG16(0x4000282A))           /*!< eUSCI_Bx Interrupt Enable Register */
N#define UCB2IE_SPI                               (HWREG16(0x4000282A))           
N#define UCB2IFG                                  (HWREG16(0x4000282C))           /*!< eUSCI_Bx Interrupt Flag Register */
N#define UCB2IFG_SPI                              (HWREG16(0x4000282C))           
N#define UCB2IV                                   (HWREG16(0x4000282E))           /*!< eUSCI_Bx Interrupt Vector Register */
N#define UCB2IV_SPI                               (HWREG16(0x4000282E))           
N
N/* Register offsets from EUSCI_B2_BASE address */
N#define OFS_UCB2CTLW0                                      (0x0000)              /*!< eUSCI_Bx Control Word Register 0 */
N#define OFS_UCB2CTLW0_SPI                                  (0x0000)              
N#define OFS_UCB2CTLW1                                      (0x0002)              /*!< eUSCI_Bx Control Word Register 1 */
N#define OFS_UCB2BRW                                        (0x0006)              /*!< eUSCI_Bx Baud Rate Control Word Register */
N#define OFS_UCB2BRW_SPI                                    (0x0006)              
N#define OFS_UCB2STATW                                      (0x0008)              /*!< eUSCI_Bx Status Register */
N#define OFS_UCB2STATW_SPI                                  (0x0008)              
N#define OFS_UCB2TBCNT                                      (0x000A)              /*!< eUSCI_Bx Byte Counter Threshold Register */
N#define OFS_UCB2RXBUF                                      (0x000C)              /*!< eUSCI_Bx Receive Buffer Register */
N#define OFS_UCB2RXBUF_SPI                                  (0x000C)              
N#define OFS_UCB2TXBUF                                      (0x000E)              /*!< eUSCI_Bx Transmit Buffer Register */
N#define OFS_UCB2TXBUF_SPI                                  (0x000E)              
N#define OFS_UCB2I2COA0                                     (0x0014)              /*!< eUSCI_Bx I2C Own Address 0 Register */
N#define OFS_UCB2I2COA1                                     (0x0016)              /*!< eUSCI_Bx I2C Own Address 1 Register */
N#define OFS_UCB2I2COA2                                     (0x0018)              /*!< eUSCI_Bx I2C Own Address 2 Register */
N#define OFS_UCB2I2COA3                                     (0x001A)              /*!< eUSCI_Bx I2C Own Address 3 Register */
N#define OFS_UCB2ADDRX                                      (0x001C)              /*!< eUSCI_Bx I2C Received Address Register */
N#define OFS_UCB2ADDMASK                                    (0x001E)              /*!< eUSCI_Bx I2C Address Mask Register */
N#define OFS_UCB2I2CSA                                      (0x0020)              /*!< eUSCI_Bx I2C Slave Address Register */
N#define OFS_UCB2IE                                         (0x002A)              /*!< eUSCI_Bx Interrupt Enable Register */
N#define OFS_UCB2IE_SPI                                     (0x002A)              
N#define OFS_UCB2IFG                                        (0x002C)              /*!< eUSCI_Bx Interrupt Flag Register */
N#define OFS_UCB2IFG_SPI                                    (0x002C)              
N#define OFS_UCB2IV                                         (0x002E)              /*!< eUSCI_Bx Interrupt Vector Register */
N#define OFS_UCB2IV_SPI                                     (0x002E)              
N
N#define UCB2CTL0                                           (HWREG8_L(UCB2CTLW0)) /* eUSCI_Bx Control 1 */
N#define UCB2CTL1                                           (HWREG8_H(UCB2CTLW0)) /* eUSCI_Bx Control 0 */
N#define UCB2BR0                                            (HWREG8_L(UCB2BRW))   /* eUSCI_Bx Bit Rate Control 0 */
N#define UCB2BR1                                            (HWREG8_H(UCB2BRW))   /* eUSCI_Bx Bit Rate Control 1 */
N#define UCB2STAT                                           (HWREG8_L(UCB2STATW)) /* eUSCI_Bx Status */
N#define UCB2BCNT                                           (HWREG8_H(UCB2STATW)) /* eUSCI_Bx Byte Counter Register */
N
N/******************************************************************************
N* EUSCI_B3 Registers
N******************************************************************************/
N#define UCB3CTLW0                                (HWREG16(0x40002C00))           /*!< eUSCI_Bx Control Word Register 0 */
N#define UCB3CTLW0_SPI                            (HWREG16(0x40002C00))           
N#define UCB3CTLW1                                (HWREG16(0x40002C02))           /*!< eUSCI_Bx Control Word Register 1 */
N#define UCB3BRW                                  (HWREG16(0x40002C06))           /*!< eUSCI_Bx Baud Rate Control Word Register */
N#define UCB3BRW_SPI                              (HWREG16(0x40002C06))           
N#define UCB3STATW                                (HWREG16(0x40002C08))           /*!< eUSCI_Bx Status Register */
N#define UCB3STATW_SPI                            (HWREG16(0x40002C08))           
N#define UCB3TBCNT                                (HWREG16(0x40002C0A))           /*!< eUSCI_Bx Byte Counter Threshold Register */
N#define UCB3RXBUF                                (HWREG16(0x40002C0C))           /*!< eUSCI_Bx Receive Buffer Register */
N#define UCB3RXBUF_SPI                            (HWREG16(0x40002C0C))           
N#define UCB3TXBUF                                (HWREG16(0x40002C0E))           /*!< eUSCI_Bx Transmit Buffer Register */
N#define UCB3TXBUF_SPI                            (HWREG16(0x40002C0E))           
N#define UCB3I2COA0                               (HWREG16(0x40002C14))           /*!< eUSCI_Bx I2C Own Address 0 Register */
N#define UCB3I2COA1                               (HWREG16(0x40002C16))           /*!< eUSCI_Bx I2C Own Address 1 Register */
N#define UCB3I2COA2                               (HWREG16(0x40002C18))           /*!< eUSCI_Bx I2C Own Address 2 Register */
N#define UCB3I2COA3                               (HWREG16(0x40002C1A))           /*!< eUSCI_Bx I2C Own Address 3 Register */
N#define UCB3ADDRX                                (HWREG16(0x40002C1C))           /*!< eUSCI_Bx I2C Received Address Register */
N#define UCB3ADDMASK                              (HWREG16(0x40002C1E))           /*!< eUSCI_Bx I2C Address Mask Register */
N#define UCB3I2CSA                                (HWREG16(0x40002C20))           /*!< eUSCI_Bx I2C Slave Address Register */
N#define UCB3IE                                   (HWREG16(0x40002C2A))           /*!< eUSCI_Bx Interrupt Enable Register */
N#define UCB3IE_SPI                               (HWREG16(0x40002C2A))           
N#define UCB3IFG                                  (HWREG16(0x40002C2C))           /*!< eUSCI_Bx Interrupt Flag Register */
N#define UCB3IFG_SPI                              (HWREG16(0x40002C2C))           
N#define UCB3IV                                   (HWREG16(0x40002C2E))           /*!< eUSCI_Bx Interrupt Vector Register */
N#define UCB3IV_SPI                               (HWREG16(0x40002C2E))           
N
N/* Register offsets from EUSCI_B3_BASE address */
N#define OFS_UCB3CTLW0                                      (0x0000)              /*!< eUSCI_Bx Control Word Register 0 */
N#define OFS_UCB3CTLW0_SPI                                  (0x0000)              
N#define OFS_UCB3CTLW1                                      (0x0002)              /*!< eUSCI_Bx Control Word Register 1 */
N#define OFS_UCB3BRW                                        (0x0006)              /*!< eUSCI_Bx Baud Rate Control Word Register */
N#define OFS_UCB3BRW_SPI                                    (0x0006)              
N#define OFS_UCB3STATW                                      (0x0008)              /*!< eUSCI_Bx Status Register */
N#define OFS_UCB3STATW_SPI                                  (0x0008)              
N#define OFS_UCB3TBCNT                                      (0x000A)              /*!< eUSCI_Bx Byte Counter Threshold Register */
N#define OFS_UCB3RXBUF                                      (0x000C)              /*!< eUSCI_Bx Receive Buffer Register */
N#define OFS_UCB3RXBUF_SPI                                  (0x000C)              
N#define OFS_UCB3TXBUF                                      (0x000E)              /*!< eUSCI_Bx Transmit Buffer Register */
N#define OFS_UCB3TXBUF_SPI                                  (0x000E)              
N#define OFS_UCB3I2COA0                                     (0x0014)              /*!< eUSCI_Bx I2C Own Address 0 Register */
N#define OFS_UCB3I2COA1                                     (0x0016)              /*!< eUSCI_Bx I2C Own Address 1 Register */
N#define OFS_UCB3I2COA2                                     (0x0018)              /*!< eUSCI_Bx I2C Own Address 2 Register */
N#define OFS_UCB3I2COA3                                     (0x001A)              /*!< eUSCI_Bx I2C Own Address 3 Register */
N#define OFS_UCB3ADDRX                                      (0x001C)              /*!< eUSCI_Bx I2C Received Address Register */
N#define OFS_UCB3ADDMASK                                    (0x001E)              /*!< eUSCI_Bx I2C Address Mask Register */
N#define OFS_UCB3I2CSA                                      (0x0020)              /*!< eUSCI_Bx I2C Slave Address Register */
N#define OFS_UCB3IE                                         (0x002A)              /*!< eUSCI_Bx Interrupt Enable Register */
N#define OFS_UCB3IE_SPI                                     (0x002A)              
N#define OFS_UCB3IFG                                        (0x002C)              /*!< eUSCI_Bx Interrupt Flag Register */
N#define OFS_UCB3IFG_SPI                                    (0x002C)              
N#define OFS_UCB3IV                                         (0x002E)              /*!< eUSCI_Bx Interrupt Vector Register */
N#define OFS_UCB3IV_SPI                                     (0x002E)              
N
N#define UCB3CTL0                                           (HWREG8_L(UCB3CTLW0)) /* eUSCI_Bx Control 1 */
N#define UCB3CTL1                                           (HWREG8_H(UCB3CTLW0)) /* eUSCI_Bx Control 0 */
N#define UCB3BR0                                            (HWREG8_L(UCB3BRW))   /* eUSCI_Bx Bit Rate Control 0 */
N#define UCB3BR1                                            (HWREG8_H(UCB3BRW))   /* eUSCI_Bx Bit Rate Control 1 */
N#define UCB3STAT                                           (HWREG8_L(UCB3STATW)) /* eUSCI_Bx Status */
N#define UCB3BCNT                                           (HWREG8_H(UCB3STATW)) /* eUSCI_Bx Byte Counter Register */
N
N/******************************************************************************
N* PMAP Registers
N******************************************************************************/
N#define PMAPKEYID                                (HWREG16(0x40005000))           /*!< Port Mapping Key Register */
N#define PMAPCTL                                  (HWREG16(0x40005002))           /*!< Port Mapping Control Register */
N#define P1MAP01                                  (HWREG16(0x40005008))           /*!< Port mapping register, P1.0 and P1.1 */
N#define P1MAP23                                  (HWREG16(0x4000500A))           /*!< Port mapping register, P1.2 and P1.3 */
N#define P1MAP45                                  (HWREG16(0x4000500C))           /*!< Port mapping register, P1.4 and P1.5 */
N#define P1MAP67                                  (HWREG16(0x4000500E))           /*!< Port mapping register, P1.6 and P1.7 */
N#define P2MAP01                                  (HWREG16(0x40005010))           /*!< Port mapping register, P2.0 and P2.1 */
N#define P2MAP23                                  (HWREG16(0x40005012))           /*!< Port mapping register, P2.2 and P2.3 */
N#define P2MAP45                                  (HWREG16(0x40005014))           /*!< Port mapping register, P2.4 and P2.5 */
N#define P2MAP67                                  (HWREG16(0x40005016))           /*!< Port mapping register, P2.6 and P2.7 */
N#define P3MAP01                                  (HWREG16(0x40005018))           /*!< Port mapping register, P3.0 and P3.1 */
N#define P3MAP23                                  (HWREG16(0x4000501A))           /*!< Port mapping register, P3.2 and P3.3 */
N#define P3MAP45                                  (HWREG16(0x4000501C))           /*!< Port mapping register, P3.4 and P3.5 */
N#define P3MAP67                                  (HWREG16(0x4000501E))           /*!< Port mapping register, P3.6 and P3.7 */
N#define P4MAP01                                  (HWREG16(0x40005020))           /*!< Port mapping register, P4.0 and P4.1 */
N#define P4MAP23                                  (HWREG16(0x40005022))           /*!< Port mapping register, P4.2 and P4.3 */
N#define P4MAP45                                  (HWREG16(0x40005024))           /*!< Port mapping register, P4.4 and P4.5 */
N#define P4MAP67                                  (HWREG16(0x40005026))           /*!< Port mapping register, P4.6 and P4.7 */
N#define P5MAP01                                  (HWREG16(0x40005028))           /*!< Port mapping register, P5.0 and P5.1 */
N#define P5MAP23                                  (HWREG16(0x4000502A))           /*!< Port mapping register, P5.2 and P5.3 */
N#define P5MAP45                                  (HWREG16(0x4000502C))           /*!< Port mapping register, P5.4 and P5.5 */
N#define P5MAP67                                  (HWREG16(0x4000502E))           /*!< Port mapping register, P5.6 and P5.7 */
N#define P6MAP01                                  (HWREG16(0x40005030))           /*!< Port mapping register, P6.0 and P6.1 */
N#define P6MAP23                                  (HWREG16(0x40005032))           /*!< Port mapping register, P6.2 and P6.3 */
N#define P6MAP45                                  (HWREG16(0x40005034))           /*!< Port mapping register, P6.4 and P6.5 */
N#define P6MAP67                                  (HWREG16(0x40005036))           /*!< Port mapping register, P6.6 and P6.7 */
N#define P7MAP01                                  (HWREG16(0x40005038))           /*!< Port mapping register, P7.0 and P7.1 */
N#define P7MAP23                                  (HWREG16(0x4000503A))           /*!< Port mapping register, P7.2 and P7.3 */
N#define P7MAP45                                  (HWREG16(0x4000503C))           /*!< Port mapping register, P7.4 and P7.5 */
N#define P7MAP67                                  (HWREG16(0x4000503E))           /*!< Port mapping register, P7.6 and P7.7 */
N
N/* Register offsets from PMAP_BASE address */
N#define OFS_PMAPKEYID                                      (0x0000)              /*!< Port Mapping Key Register */
N#define OFS_PMAPCTL                                        (0x0002)              /*!< Port Mapping Control Register */
N#define OFS_P1MAP01                                        (0x0008)              /*!< Port mapping register, P1.0 and P1.1 */
N#define OFS_P1MAP23                                        (0x000A)              /*!< Port mapping register, P1.2 and P1.3 */
N#define OFS_P1MAP45                                        (0x000C)              /*!< Port mapping register, P1.4 and P1.5 */
N#define OFS_P1MAP67                                        (0x000E)              /*!< Port mapping register, P1.6 and P1.7 */
N#define OFS_P2MAP01                                        (0x0010)              /*!< Port mapping register, P2.0 and P2.1 */
N#define OFS_P2MAP23                                        (0x0012)              /*!< Port mapping register, P2.2 and P2.3 */
N#define OFS_P2MAP45                                        (0x0014)              /*!< Port mapping register, P2.4 and P2.5 */
N#define OFS_P2MAP67                                        (0x0016)              /*!< Port mapping register, P2.6 and P2.7 */
N#define OFS_P3MAP01                                        (0x0018)              /*!< Port mapping register, P3.0 and P3.1 */
N#define OFS_P3MAP23                                        (0x001A)              /*!< Port mapping register, P3.2 and P3.3 */
N#define OFS_P3MAP45                                        (0x001C)              /*!< Port mapping register, P3.4 and P3.5 */
N#define OFS_P3MAP67                                        (0x001E)              /*!< Port mapping register, P3.6 and P3.7 */
N#define OFS_P4MAP01                                        (0x0020)              /*!< Port mapping register, P4.0 and P4.1 */
N#define OFS_P4MAP23                                        (0x0022)              /*!< Port mapping register, P4.2 and P4.3 */
N#define OFS_P4MAP45                                        (0x0024)              /*!< Port mapping register, P4.4 and P4.5 */
N#define OFS_P4MAP67                                        (0x0026)              /*!< Port mapping register, P4.6 and P4.7 */
N#define OFS_P5MAP01                                        (0x0028)              /*!< Port mapping register, P5.0 and P5.1 */
N#define OFS_P5MAP23                                        (0x002A)              /*!< Port mapping register, P5.2 and P5.3 */
N#define OFS_P5MAP45                                        (0x002C)              /*!< Port mapping register, P5.4 and P5.5 */
N#define OFS_P5MAP67                                        (0x002E)              /*!< Port mapping register, P5.6 and P5.7 */
N#define OFS_P6MAP01                                        (0x0030)              /*!< Port mapping register, P6.0 and P6.1 */
N#define OFS_P6MAP23                                        (0x0032)              /*!< Port mapping register, P6.2 and P6.3 */
N#define OFS_P6MAP45                                        (0x0034)              /*!< Port mapping register, P6.4 and P6.5 */
N#define OFS_P6MAP67                                        (0x0036)              /*!< Port mapping register, P6.6 and P6.7 */
N#define OFS_P7MAP01                                        (0x0038)              /*!< Port mapping register, P7.0 and P7.1 */
N#define OFS_P7MAP23                                        (0x003A)              /*!< Port mapping register, P7.2 and P7.3 */
N#define OFS_P7MAP45                                        (0x003C)              /*!< Port mapping register, P7.4 and P7.5 */
N#define OFS_P7MAP67                                        (0x003E)              /*!< Port mapping register, P7.6 and P7.7 */
N
N
N/******************************************************************************
N* REF_A Registers
N******************************************************************************/
N#define REFCTL0                                  (HWREG16(0x40003000))           /*!< REF Control Register 0 */
N
N/* Register offsets from REF_A_BASE address */
N#define OFS_REFCTL0                                        (0x0000)              /*!< REF Control Register 0 */
N
N#define REFCTL0_L                                          (HWREG8_L(REFCTL0))   /* REF Control Register 0 */
N#define REFCTL0_H                                          (HWREG8_H(REFCTL0))   /* REF Control Register 0 */
N
N/******************************************************************************
N* RTC_C Registers
N******************************************************************************/
N#define RTCCTL0                                  (HWREG16(0x40004400))           /*!< RTCCTL0 Register */
N#define RTCCTL13                                 (HWREG16(0x40004402))           /*!< RTCCTL13 Register */
N#define RTCOCAL                                  (HWREG16(0x40004404))           /*!< RTCOCAL Register */
N#define RTCTCMP                                  (HWREG16(0x40004406))           /*!< RTCTCMP Register */
N#define RTCPS0CTL                                (HWREG16(0x40004408))           /*!< Real-Time Clock Prescale Timer 0 Control Register */
N#define RTCPS1CTL                                (HWREG16(0x4000440A))           /*!< Real-Time Clock Prescale Timer 1 Control Register */
N#define RTCPS                                    (HWREG16(0x4000440C))           /*!< Real-Time Clock Prescale Timer Counter Register */
N#define RTCIV                                    (HWREG16(0x4000440E))           /*!< Real-Time Clock Interrupt Vector Register */
N#define RTCTIM0                                  (HWREG16(0x40004410))           /*!< RTCTIM0 Register  Hexadecimal Format */
N#define RTCTIM0_BCD                              (HWREG16(0x40004410))           
N#define RTCTIM1                                  (HWREG16(0x40004412))           /*!< Real-Time Clock Hour, Day of Week */
N#define RTCTIM1_BCD                              (HWREG16(0x40004412))           
N#define RTCDATE                                  (HWREG16(0x40004414))           /*!< RTCDATE - Hexadecimal Format */
N#define RTCDATE_BCD                              (HWREG16(0x40004414))           
N#define RTCYEAR                                  (HWREG16(0x40004416))           /*!< RTCYEAR Register  Hexadecimal Format */
N#define RTCYEAR_BCD                              (HWREG16(0x40004416))           
N#define RTCAMINHR                                (HWREG16(0x40004418))           /*!< RTCMINHR - Hexadecimal Format */
N#define RTCAMINHR_BCD                            (HWREG16(0x40004418))           
N#define RTCADOWDAY                               (HWREG16(0x4000441A))           /*!< RTCADOWDAY - Hexadecimal Format */
N#define RTCADOWDAY_BCD                           (HWREG16(0x4000441A))           
N#define RTCBIN2BCD                               (HWREG16(0x4000441C))           /*!< Binary-to-BCD Conversion Register */
N#define RTCBCD2BIN                               (HWREG16(0x4000441E))           /*!< BCD-to-Binary Conversion Register */
N
N/* Register offsets from RTC_C_BASE address */
N#define OFS_RTCCTL0                                        (0x0000)              /*!< RTCCTL0 Register */
N#define OFS_RTCCTL13                                       (0x0002)              /*!< RTCCTL13 Register */
N#define OFS_RTCOCAL                                        (0x0004)              /*!< RTCOCAL Register */
N#define OFS_RTCTCMP                                        (0x0006)              /*!< RTCTCMP Register */
N#define OFS_RTCPS0CTL                                      (0x0008)              /*!< Real-Time Clock Prescale Timer 0 Control Register */
N#define OFS_RTCPS1CTL                                      (0x000A)              /*!< Real-Time Clock Prescale Timer 1 Control Register */
N#define OFS_RTCPS                                          (0x000C)              /*!< Real-Time Clock Prescale Timer Counter Register */
N#define OFS_RTCIV                                          (0x000E)              /*!< Real-Time Clock Interrupt Vector Register */
N#define OFS_RTCTIM0                                        (0x0010)              /*!< RTCTIM0 Register  Hexadecimal Format */
N#define OFS_RTCTIM0_BCD                                    (0x0010)              
N#define OFS_RTCTIM1                                        (0x0012)              /*!< Real-Time Clock Hour, Day of Week */
N#define OFS_RTCTIM1_BCD                                    (0x0012)              
N#define OFS_RTCDATE                                        (0x0014)              /*!< RTCDATE - Hexadecimal Format */
N#define OFS_RTCDATE_BCD                                    (0x0014)              
N#define OFS_RTCYEAR                                        (0x0016)              /*!< RTCYEAR Register  Hexadecimal Format */
N#define OFS_RTCYEAR_BCD                                    (0x0016)              
N#define OFS_RTCAMINHR                                      (0x0018)              /*!< RTCMINHR - Hexadecimal Format */
N#define OFS_RTCAMINHR_BCD                                  (0x0018)              
N#define OFS_RTCADOWDAY                                     (0x001A)              /*!< RTCADOWDAY - Hexadecimal Format */
N#define OFS_RTCADOWDAY_BCD                                 (0x001A)              
N#define OFS_RTCBIN2BCD                                     (0x001C)              /*!< Binary-to-BCD Conversion Register */
N#define OFS_RTCBCD2BIN                                     (0x001E)              /*!< BCD-to-Binary Conversion Register */
N
N#define RTCCTL0_L                                          (HWREG8_L(RTCCTL0))   /* RTCCTL0 Register */
N#define RTCCTL0_H                                          (HWREG8_H(RTCCTL0))   /* RTCCTL0 Register */
N#define RTCCTL1                                            (HWREG8_L(RTCCTL13))  /* RTCCTL13 Register */
N#define RTCCTL13_L                                         (HWREG8_L(RTCCTL13))  /* RTCCTL13 Register */
N#define RTCCTL3                                            (HWREG8_H(RTCCTL13))  /* RTCCTL13 Register */
N#define RTCCTL13_H                                         (HWREG8_H(RTCCTL13))  /* RTCCTL13 Register */
N#define RTCOCAL_L                                          (HWREG8_L(RTCOCAL))   /* RTCOCAL Register */
N#define RTCOCAL_H                                          (HWREG8_H(RTCOCAL))   /* RTCOCAL Register */
N#define RTCTCMP_L                                          (HWREG8_L(RTCTCMP))   /* RTCTCMP Register */
N#define RTCTCMP_H                                          (HWREG8_H(RTCTCMP))   /* RTCTCMP Register */
N#define RTCPS0CTL_L                                        (HWREG8_L(RTCPS0CTL)) /* Real-Time Clock Prescale Timer 0 Control Register */
N#define RTCPS0CTL_H                                        (HWREG8_H(RTCPS0CTL)) /* Real-Time Clock Prescale Timer 0 Control Register */
N#define RTCPS1CTL_L                                        (HWREG8_L(RTCPS1CTL)) /* Real-Time Clock Prescale Timer 1 Control Register */
N#define RTCPS1CTL_H                                        (HWREG8_H(RTCPS1CTL)) /* Real-Time Clock Prescale Timer 1 Control Register */
N#define RTCPS0                                             (HWREG8_L(RTCPS))     /* Real-Time Clock Prescale Timer Counter Register */
N#define RTCPS_L                                            (HWREG8_L(RTCPS))     /* Real-Time Clock Prescale Timer Counter Register */
N#define RTCPS1                                             (HWREG8_H(RTCPS))     /* Real-Time Clock Prescale Timer Counter Register */
N#define RTCPS_H                                            (HWREG8_H(RTCPS))     /* Real-Time Clock Prescale Timer Counter Register */
N#define RTCSEC                                             (HWREG8_L(RTCTIM0))   /* Real-Time Clock Seconds */
N#define RTCTIM0_L                                          (HWREG8_L(RTCTIM0))   /* Real-Time Clock Seconds */
N#define RTCMIN                                             (HWREG8_H(RTCTIM0))   /* Real-Time Clock Minutes */
N#define RTCTIM0_H                                          (HWREG8_H(RTCTIM0))   /* Real-Time Clock Minutes */
N#define RTCHOUR                                            (HWREG8_L(RTCTIM1))   /* Real-Time Clock Hour */
N#define RTCTIM1_L                                          (HWREG8_L(RTCTIM1))   /* Real-Time Clock Hour */
N#define RTCDOW                                             (HWREG8_H(RTCTIM1))   /* Real-Time Clock Day of Week */
N#define RTCTIM1_H                                          (HWREG8_H(RTCTIM1))   /* Real-Time Clock Day of Week */
N#define RTCDAY                                             (HWREG8_L(RTCDATE))   /* Real-Time Clock Day of Month */
N#define RTCDATE_L                                          (HWREG8_L(RTCDATE))   /* Real-Time Clock Day of Month */
N#define RTCMON                                             (HWREG8_H(RTCDATE))   /* Real-Time Clock Month */
N#define RTCDATE_H                                          (HWREG8_H(RTCDATE))   /* Real-Time Clock Month */
N#define RTCAMIN                                            (HWREG8_L(RTCAMINHR)) /* Real-Time Clock Minutes Alarm */
N#define RTCAMINHR_L                                        (HWREG8_L(RTCAMINHR)) /* Real-Time Clock Minutes Alarm */
N#define RTCAHOUR                                           (HWREG8_H(RTCAMINHR)) /* Real-Time Clock Hours Alarm */
N#define RTCAMINHR_H                                        (HWREG8_H(RTCAMINHR)) /* Real-Time Clock Hours Alarm */
N#define RTCADOW                                            (HWREG8_L(RTCADOWDAY))/* Real-Time Clock Day of Week Alarm */
N#define RTCADOWDAY_L                                       (HWREG8_L(RTCADOWDAY))/* Real-Time Clock Day of Week Alarm */
N#define RTCADAY                                            (HWREG8_H(RTCADOWDAY))/* Real-Time Clock Day of Month Alarm */
N#define RTCADOWDAY_H                                       (HWREG8_H(RTCADOWDAY))/* Real-Time Clock Day of Month Alarm */
N
N/******************************************************************************
N* TIMER_A0 Registers
N******************************************************************************/
N#define TA0CTL                                   (HWREG16(0x40000000))           /*!< TimerAx Control Register */
N#define TA0CCTL0                                 (HWREG16(0x40000002))           /*!< Timer_A Capture/Compare Control Register */
N#define TA0CCTL1                                 (HWREG16(0x40000004))           /*!< Timer_A Capture/Compare Control Register */
N#define TA0CCTL2                                 (HWREG16(0x40000006))           /*!< Timer_A Capture/Compare Control Register */
N#define TA0CCTL3                                 (HWREG16(0x40000008))           /*!< Timer_A Capture/Compare Control Register */
N#define TA0CCTL4                                 (HWREG16(0x4000000A))           /*!< Timer_A Capture/Compare Control Register */
N#define TA0R                                     (HWREG16(0x40000010))           /*!< TimerA register */
N#define TA0CCR0                                  (HWREG16(0x40000012))           /*!< Timer_A Capture/Compare  Register */
N#define TA0CCR1                                  (HWREG16(0x40000014))           /*!< Timer_A Capture/Compare  Register */
N#define TA0CCR2                                  (HWREG16(0x40000016))           /*!< Timer_A Capture/Compare  Register */
N#define TA0CCR3                                  (HWREG16(0x40000018))           /*!< Timer_A Capture/Compare  Register */
N#define TA0CCR4                                  (HWREG16(0x4000001A))           /*!< Timer_A Capture/Compare  Register */
N#define TA0EX0                                   (HWREG16(0x40000020))           /*!< TimerAx Expansion 0 Register */
N#define TA0IV                                    (HWREG16(0x4000002E))           /*!< TimerAx Interrupt Vector Register */
N
N/* Register offsets from TIMER_A0_BASE address */
N#define OFS_TA0CTL                                         (0x0000)              /*!< TimerAx Control Register */
N#define OFS_TA0CCTL0                                       (0x0002)              /*!< Timer_A Capture/Compare Control Register */
N#define OFS_TA0CCTL1                                       (0x0004)              /*!< Timer_A Capture/Compare Control Register */
N#define OFS_TA0CCTL2                                       (0x0006)              /*!< Timer_A Capture/Compare Control Register */
N#define OFS_TA0CCTL3                                       (0x0008)              /*!< Timer_A Capture/Compare Control Register */
N#define OFS_TA0CCTL4                                       (0x000A)              /*!< Timer_A Capture/Compare Control Register */
N#define OFS_TA0R                                           (0x0010)              /*!< TimerA register */
N#define OFS_TA0CCR0                                        (0x0012)              /*!< Timer_A Capture/Compare  Register */
N#define OFS_TA0CCR1                                        (0x0014)              /*!< Timer_A Capture/Compare  Register */
N#define OFS_TA0CCR2                                        (0x0016)              /*!< Timer_A Capture/Compare  Register */
N#define OFS_TA0CCR3                                        (0x0018)              /*!< Timer_A Capture/Compare  Register */
N#define OFS_TA0CCR4                                        (0x001A)              /*!< Timer_A Capture/Compare  Register */
N#define OFS_TA0EX0                                         (0x0020)              /*!< TimerAx Expansion 0 Register */
N#define OFS_TA0IV                                          (0x002E)              /*!< TimerAx Interrupt Vector Register */
N
N
N/******************************************************************************
N* TIMER_A1 Registers
N******************************************************************************/
N#define TA1CTL                                   (HWREG16(0x40000400))           /*!< TimerAx Control Register */
N#define TA1CCTL0                                 (HWREG16(0x40000402))           /*!< Timer_A Capture/Compare Control Register */
N#define TA1CCTL1                                 (HWREG16(0x40000404))           /*!< Timer_A Capture/Compare Control Register */
N#define TA1CCTL2                                 (HWREG16(0x40000406))           /*!< Timer_A Capture/Compare Control Register */
N#define TA1CCTL3                                 (HWREG16(0x40000408))           /*!< Timer_A Capture/Compare Control Register */
N#define TA1CCTL4                                 (HWREG16(0x4000040A))           /*!< Timer_A Capture/Compare Control Register */
N#define TA1R                                     (HWREG16(0x40000410))           /*!< TimerA register */
N#define TA1CCR0                                  (HWREG16(0x40000412))           /*!< Timer_A Capture/Compare  Register */
N#define TA1CCR1                                  (HWREG16(0x40000414))           /*!< Timer_A Capture/Compare  Register */
N#define TA1CCR2                                  (HWREG16(0x40000416))           /*!< Timer_A Capture/Compare  Register */
N#define TA1CCR3                                  (HWREG16(0x40000418))           /*!< Timer_A Capture/Compare  Register */
N#define TA1CCR4                                  (HWREG16(0x4000041A))           /*!< Timer_A Capture/Compare  Register */
N#define TA1EX0                                   (HWREG16(0x40000420))           /*!< TimerAx Expansion 0 Register */
N#define TA1IV                                    (HWREG16(0x4000042E))           /*!< TimerAx Interrupt Vector Register */
N
N/* Register offsets from TIMER_A1_BASE address */
N#define OFS_TA1CTL                                         (0x0000)              /*!< TimerAx Control Register */
N#define OFS_TA1CCTL0                                       (0x0002)              /*!< Timer_A Capture/Compare Control Register */
N#define OFS_TA1CCTL1                                       (0x0004)              /*!< Timer_A Capture/Compare Control Register */
N#define OFS_TA1CCTL2                                       (0x0006)              /*!< Timer_A Capture/Compare Control Register */
N#define OFS_TA1CCTL3                                       (0x0008)              /*!< Timer_A Capture/Compare Control Register */
N#define OFS_TA1CCTL4                                       (0x000A)              /*!< Timer_A Capture/Compare Control Register */
N#define OFS_TA1R                                           (0x0010)              /*!< TimerA register */
N#define OFS_TA1CCR0                                        (0x0012)              /*!< Timer_A Capture/Compare  Register */
N#define OFS_TA1CCR1                                        (0x0014)              /*!< Timer_A Capture/Compare  Register */
N#define OFS_TA1CCR2                                        (0x0016)              /*!< Timer_A Capture/Compare  Register */
N#define OFS_TA1CCR3                                        (0x0018)              /*!< Timer_A Capture/Compare  Register */
N#define OFS_TA1CCR4                                        (0x001A)              /*!< Timer_A Capture/Compare  Register */
N#define OFS_TA1EX0                                         (0x0020)              /*!< TimerAx Expansion 0 Register */
N#define OFS_TA1IV                                          (0x002E)              /*!< TimerAx Interrupt Vector Register */
N
N
N/******************************************************************************
N* TIMER_A2 Registers
N******************************************************************************/
N#define TA2CTL                                   (HWREG16(0x40000800))           /*!< TimerAx Control Register */
N#define TA2CCTL0                                 (HWREG16(0x40000802))           /*!< Timer_A Capture/Compare Control Register */
N#define TA2CCTL1                                 (HWREG16(0x40000804))           /*!< Timer_A Capture/Compare Control Register */
N#define TA2CCTL2                                 (HWREG16(0x40000806))           /*!< Timer_A Capture/Compare Control Register */
N#define TA2CCTL3                                 (HWREG16(0x40000808))           /*!< Timer_A Capture/Compare Control Register */
N#define TA2CCTL4                                 (HWREG16(0x4000080A))           /*!< Timer_A Capture/Compare Control Register */
N#define TA2R                                     (HWREG16(0x40000810))           /*!< TimerA register */
N#define TA2CCR0                                  (HWREG16(0x40000812))           /*!< Timer_A Capture/Compare  Register */
N#define TA2CCR1                                  (HWREG16(0x40000814))           /*!< Timer_A Capture/Compare  Register */
N#define TA2CCR2                                  (HWREG16(0x40000816))           /*!< Timer_A Capture/Compare  Register */
N#define TA2CCR3                                  (HWREG16(0x40000818))           /*!< Timer_A Capture/Compare  Register */
N#define TA2CCR4                                  (HWREG16(0x4000081A))           /*!< Timer_A Capture/Compare  Register */
N#define TA2EX0                                   (HWREG16(0x40000820))           /*!< TimerAx Expansion 0 Register */
N#define TA2IV                                    (HWREG16(0x4000082E))           /*!< TimerAx Interrupt Vector Register */
N
N/* Register offsets from TIMER_A2_BASE address */
N#define OFS_TA2CTL                                         (0x0000)              /*!< TimerAx Control Register */
N#define OFS_TA2CCTL0                                       (0x0002)              /*!< Timer_A Capture/Compare Control Register */
N#define OFS_TA2CCTL1                                       (0x0004)              /*!< Timer_A Capture/Compare Control Register */
N#define OFS_TA2CCTL2                                       (0x0006)              /*!< Timer_A Capture/Compare Control Register */
N#define OFS_TA2CCTL3                                       (0x0008)              /*!< Timer_A Capture/Compare Control Register */
N#define OFS_TA2CCTL4                                       (0x000A)              /*!< Timer_A Capture/Compare Control Register */
N#define OFS_TA2R                                           (0x0010)              /*!< TimerA register */
N#define OFS_TA2CCR0                                        (0x0012)              /*!< Timer_A Capture/Compare  Register */
N#define OFS_TA2CCR1                                        (0x0014)              /*!< Timer_A Capture/Compare  Register */
N#define OFS_TA2CCR2                                        (0x0016)              /*!< Timer_A Capture/Compare  Register */
N#define OFS_TA2CCR3                                        (0x0018)              /*!< Timer_A Capture/Compare  Register */
N#define OFS_TA2CCR4                                        (0x001A)              /*!< Timer_A Capture/Compare  Register */
N#define OFS_TA2EX0                                         (0x0020)              /*!< TimerAx Expansion 0 Register */
N#define OFS_TA2IV                                          (0x002E)              /*!< TimerAx Interrupt Vector Register */
N
N
N/******************************************************************************
N* TIMER_A3 Registers
N******************************************************************************/
N#define TA3CTL                                   (HWREG16(0x40000C00))           /*!< TimerAx Control Register */
N#define TA3CCTL0                                 (HWREG16(0x40000C02))           /*!< Timer_A Capture/Compare Control Register */
N#define TA3CCTL1                                 (HWREG16(0x40000C04))           /*!< Timer_A Capture/Compare Control Register */
N#define TA3CCTL2                                 (HWREG16(0x40000C06))           /*!< Timer_A Capture/Compare Control Register */
N#define TA3CCTL3                                 (HWREG16(0x40000C08))           /*!< Timer_A Capture/Compare Control Register */
N#define TA3CCTL4                                 (HWREG16(0x40000C0A))           /*!< Timer_A Capture/Compare Control Register */
N#define TA3R                                     (HWREG16(0x40000C10))           /*!< TimerA register */
N#define TA3CCR0                                  (HWREG16(0x40000C12))           /*!< Timer_A Capture/Compare  Register */
N#define TA3CCR1                                  (HWREG16(0x40000C14))           /*!< Timer_A Capture/Compare  Register */
N#define TA3CCR2                                  (HWREG16(0x40000C16))           /*!< Timer_A Capture/Compare  Register */
N#define TA3CCR3                                  (HWREG16(0x40000C18))           /*!< Timer_A Capture/Compare  Register */
N#define TA3CCR4                                  (HWREG16(0x40000C1A))           /*!< Timer_A Capture/Compare  Register */
N#define TA3EX0                                   (HWREG16(0x40000C20))           /*!< TimerAx Expansion 0 Register */
N#define TA3IV                                    (HWREG16(0x40000C2E))           /*!< TimerAx Interrupt Vector Register */
N
N/* Register offsets from TIMER_A3_BASE address */
N#define OFS_TA3CTL                                         (0x0000)              /*!< TimerAx Control Register */
N#define OFS_TA3CCTL0                                       (0x0002)              /*!< Timer_A Capture/Compare Control Register */
N#define OFS_TA3CCTL1                                       (0x0004)              /*!< Timer_A Capture/Compare Control Register */
N#define OFS_TA3CCTL2                                       (0x0006)              /*!< Timer_A Capture/Compare Control Register */
N#define OFS_TA3CCTL3                                       (0x0008)              /*!< Timer_A Capture/Compare Control Register */
N#define OFS_TA3CCTL4                                       (0x000A)              /*!< Timer_A Capture/Compare Control Register */
N#define OFS_TA3R                                           (0x0010)              /*!< TimerA register */
N#define OFS_TA3CCR0                                        (0x0012)              /*!< Timer_A Capture/Compare  Register */
N#define OFS_TA3CCR1                                        (0x0014)              /*!< Timer_A Capture/Compare  Register */
N#define OFS_TA3CCR2                                        (0x0016)              /*!< Timer_A Capture/Compare  Register */
N#define OFS_TA3CCR3                                        (0x0018)              /*!< Timer_A Capture/Compare  Register */
N#define OFS_TA3CCR4                                        (0x001A)              /*!< Timer_A Capture/Compare  Register */
N#define OFS_TA3EX0                                         (0x0020)              /*!< TimerAx Expansion 0 Register */
N#define OFS_TA3IV                                          (0x002E)              /*!< TimerAx Interrupt Vector Register */
N
N
N/******************************************************************************
N* WDT_A Registers
N******************************************************************************/
N#define WDTCTL                                   (HWREG16(0x4000480C))           /*!< Watchdog Timer Control Register */
N
N/* Register offsets from WDT_A_BASE address */
N#define OFS_WDTCTL                                         (0x000C)              /*!< Watchdog Timer Control Register */
N
N
N/******************************************************************************
N* Peripheral register control bits (legacy section)                           *
N******************************************************************************/
N
N/******************************************************************************
N* AES256 Bits (legacy section)
N******************************************************************************/
N/* AESACTL0[AESOP] Bits */
N#define AESOP_OFS                                AES256_CTL0_OP_OFS              /*!< AESOP Offset */
N#define AESOP_M                                  AES256_CTL0_OP_MASK             /*!< AES operation */
N#define AESOP0                                   AES256_CTL0_OP0                 /*!< AESOP Bit 0 */
N#define AESOP1                                   AES256_CTL0_OP1                 /*!< AESOP Bit 1 */
N#define AESOP_0                                  AES256_CTL0_OP_0                /*!< Encryption */
N#define AESOP_1                                  AES256_CTL0_OP_1                /*!< Decryption. The provided key is the same key used for encryption */
N#define AESOP_2                                  AES256_CTL0_OP_2                /*!< Generate first round key required for decryption */
N#define AESOP_3                                  AES256_CTL0_OP_3                /*!< Decryption. The provided key is the first round key required for decryption */
N/* AESACTL0[AESKL] Bits */
N#define AESKL_OFS                                AES256_CTL0_KL_OFS              /*!< AESKL Offset */
N#define AESKL_M                                  AES256_CTL0_KL_MASK             /*!< AES key length */
N#define AESKL0                                   AES256_CTL0_KL0                 /*!< AESKL Bit 0 */
N#define AESKL1                                   AES256_CTL0_KL1                 /*!< AESKL Bit 1 */
N#define AESKL_0                                  AES256_CTL0_KL_0                /*!< AES128. The key size is 128 bit */
N#define AESKL_1                                  AES256_CTL0_KL_1                /*!< AES192. The key size is 192 bit. */
N#define AESKL_2                                  AES256_CTL0_KL_2                /*!< AES256. The key size is 256 bit */
N#define AESKL__128BIT                            AES256_CTL0_KL__128BIT          /*!< AES128. The key size is 128 bit */
N#define AESKL__192BIT                            AES256_CTL0_KL__192BIT          /*!< AES192. The key size is 192 bit. */
N#define AESKL__256BIT                            AES256_CTL0_KL__256BIT          /*!< AES256. The key size is 256 bit */
N/* AESACTL0[AESCM] Bits */
N#define AESCM_OFS                                AES256_CTL0_CM_OFS              /*!< AESCM Offset */
N#define AESCM_M                                  AES256_CTL0_CM_MASK             /*!< AES cipher mode select */
N#define AESCM0                                   AES256_CTL0_CM0                 /*!< AESCM Bit 0 */
N#define AESCM1                                   AES256_CTL0_CM1                 /*!< AESCM Bit 1 */
N#define AESCM_0                                  AES256_CTL0_CM_0                /*!< ECB */
N#define AESCM_1                                  AES256_CTL0_CM_1                /*!< CBC */
N#define AESCM_2                                  AES256_CTL0_CM_2                /*!< OFB */
N#define AESCM_3                                  AES256_CTL0_CM_3                /*!< CFB */
N#define AESCM__ECB                               AES256_CTL0_CM__ECB             /*!< ECB */
N#define AESCM__CBC                               AES256_CTL0_CM__CBC             /*!< CBC */
N#define AESCM__OFB                               AES256_CTL0_CM__OFB             /*!< OFB */
N#define AESCM__CFB                               AES256_CTL0_CM__CFB             /*!< CFB */
N/* AESACTL0[AESSWRST] Bits */
N#define AESSWRST_OFS                             AES256_CTL0_SWRST_OFS           /*!< AESSWRST Offset */
N#define AESSWRST                                 AES256_CTL0_SWRST               /*!< AES software reset */
N/* AESACTL0[AESRDYIFG] Bits */
N#define AESRDYIFG_OFS                            AES256_CTL0_RDYIFG_OFS          /*!< AESRDYIFG Offset */
N#define AESRDYIFG                                AES256_CTL0_RDYIFG              /*!< AES ready interrupt flag */
N/* AESACTL0[AESERRFG] Bits */
N#define AESERRFG_OFS                             AES256_CTL0_ERRFG_OFS           /*!< AESERRFG Offset */
N#define AESERRFG                                 AES256_CTL0_ERRFG               /*!< AES error flag */
N/* AESACTL0[AESRDYIE] Bits */
N#define AESRDYIE_OFS                             AES256_CTL0_RDYIE_OFS           /*!< AESRDYIE Offset */
N#define AESRDYIE                                 AES256_CTL0_RDYIE               /*!< AES ready interrupt enable */
N/* AESACTL0[AESCMEN] Bits */
N#define AESCMEN_OFS                              AES256_CTL0_CMEN_OFS            /*!< AESCMEN Offset */
N#define AESCMEN                                  AES256_CTL0_CMEN                /*!< AES cipher mode enable */
N/* AESACTL1[AESBLKCNT] Bits */
N#define AESBLKCNT_OFS                            AES256_CTL1_BLKCNT_OFS          /*!< AESBLKCNT Offset */
N#define AESBLKCNT_M                              AES256_CTL1_BLKCNT_MASK         /*!< Cipher Block Counter */
N#define AESBLKCNT0                               AES256_CTL1_BLKCNT0             /*!< AESBLKCNT Bit 0 */
N#define AESBLKCNT1                               AES256_CTL1_BLKCNT1             /*!< AESBLKCNT Bit 1 */
N#define AESBLKCNT2                               AES256_CTL1_BLKCNT2             /*!< AESBLKCNT Bit 2 */
N#define AESBLKCNT3                               AES256_CTL1_BLKCNT3             /*!< AESBLKCNT Bit 3 */
N#define AESBLKCNT4                               AES256_CTL1_BLKCNT4             /*!< AESBLKCNT Bit 4 */
N#define AESBLKCNT5                               AES256_CTL1_BLKCNT5             /*!< AESBLKCNT Bit 5 */
N#define AESBLKCNT6                               AES256_CTL1_BLKCNT6             /*!< AESBLKCNT Bit 6 */
N#define AESBLKCNT7                               AES256_CTL1_BLKCNT7             /*!< AESBLKCNT Bit 7 */
N/* AESASTAT[AESBUSY] Bits */
N#define AESBUSY_OFS                              AES256_STAT_BUSY_OFS            /*!< AESBUSY Offset */
N#define AESBUSY                                  AES256_STAT_BUSY                /*!< AES accelerator module busy */
N/* AESASTAT[AESKEYWR] Bits */
N#define AESKEYWR_OFS                             AES256_STAT_KEYWR_OFS           /*!< AESKEYWR Offset */
N#define AESKEYWR                                 AES256_STAT_KEYWR               /*!< All 16 bytes written to AESAKEY */
N/* AESASTAT[AESDINWR] Bits */
N#define AESDINWR_OFS                             AES256_STAT_DINWR_OFS           /*!< AESDINWR Offset */
N#define AESDINWR                                 AES256_STAT_DINWR               /*!< All 16 bytes written to AESADIN, AESAXDIN or AESAXIN */
N/* AESASTAT[AESDOUTRD] Bits */
N#define AESDOUTRD_OFS                            AES256_STAT_DOUTRD_OFS          /*!< AESDOUTRD Offset */
N#define AESDOUTRD                                AES256_STAT_DOUTRD              /*!< All 16 bytes read from AESADOUT */
N/* AESASTAT[AESKEYCNT] Bits */
N#define AESKEYCNT_OFS                            AES256_STAT_KEYCNT_OFS          /*!< AESKEYCNT Offset */
N#define AESKEYCNT_M                              AES256_STAT_KEYCNT_MASK         /*!< Bytes written via AESAKEY for AESKLx=00, half-words written via AESAKEY */
N#define AESKEYCNT0                               AES256_STAT_KEYCNT0             /*!< AESKEYCNT Bit 0 */
N#define AESKEYCNT1                               AES256_STAT_KEYCNT1             /*!< AESKEYCNT Bit 1 */
N#define AESKEYCNT2                               AES256_STAT_KEYCNT2             /*!< AESKEYCNT Bit 2 */
N#define AESKEYCNT3                               AES256_STAT_KEYCNT3             /*!< AESKEYCNT Bit 3 */
N/* AESASTAT[AESDINCNT] Bits */
N#define AESDINCNT_OFS                            AES256_STAT_DINCNT_OFS          /*!< AESDINCNT Offset */
N#define AESDINCNT_M                              AES256_STAT_DINCNT_MASK         /*!< Bytes written via AESADIN, AESAXDIN or AESAXIN */
N#define AESDINCNT0                               AES256_STAT_DINCNT0             /*!< AESDINCNT Bit 0 */
N#define AESDINCNT1                               AES256_STAT_DINCNT1             /*!< AESDINCNT Bit 1 */
N#define AESDINCNT2                               AES256_STAT_DINCNT2             /*!< AESDINCNT Bit 2 */
N#define AESDINCNT3                               AES256_STAT_DINCNT3             /*!< AESDINCNT Bit 3 */
N/* AESASTAT[AESDOUTCNT] Bits */
N#define AESDOUTCNT_OFS                           AES256_STAT_DOUTCNT_OFS         /*!< AESDOUTCNT Offset */
N#define AESDOUTCNT_M                             AES256_STAT_DOUTCNT_MASK        /*!< Bytes read via AESADOUT */
N#define AESDOUTCNT0                              AES256_STAT_DOUTCNT0            /*!< AESDOUTCNT Bit 0 */
N#define AESDOUTCNT1                              AES256_STAT_DOUTCNT1            /*!< AESDOUTCNT Bit 1 */
N#define AESDOUTCNT2                              AES256_STAT_DOUTCNT2            /*!< AESDOUTCNT Bit 2 */
N#define AESDOUTCNT3                              AES256_STAT_DOUTCNT3            /*!< AESDOUTCNT Bit 3 */
N/* AESAKEY[AESKEY0] Bits */
N#define AESKEY0_OFS                              AES256_KEY_KEY0_OFS             /*!< AESKEY0 Offset */
N#define AESKEY0_M                                AES256_KEY_KEY0_MASK            /*!< AES key byte n when AESAKEY is written as half-word */
N#define AESKEY00                                 AES256_KEY_KEY00                /*!< AESKEY0 Bit 0 */
N#define AESKEY01                                 AES256_KEY_KEY01                /*!< AESKEY0 Bit 1 */
N#define AESKEY02                                 AES256_KEY_KEY02                /*!< AESKEY0 Bit 2 */
N#define AESKEY03                                 AES256_KEY_KEY03                /*!< AESKEY0 Bit 3 */
N#define AESKEY04                                 AES256_KEY_KEY04                /*!< AESKEY0 Bit 4 */
N#define AESKEY05                                 AES256_KEY_KEY05                /*!< AESKEY0 Bit 5 */
N#define AESKEY06                                 AES256_KEY_KEY06                /*!< AESKEY0 Bit 6 */
N#define AESKEY07                                 AES256_KEY_KEY07                /*!< AESKEY0 Bit 7 */
N/* AESAKEY[AESKEY1] Bits */
N#define AESKEY1_OFS                              AES256_KEY_KEY1_OFS             /*!< AESKEY1 Offset */
N#define AESKEY1_M                                AES256_KEY_KEY1_MASK            /*!< AES key byte n+1 when AESAKEY is written as half-word */
N#define AESKEY10                                 AES256_KEY_KEY10                /*!< AESKEY1 Bit 0 */
N#define AESKEY11                                 AES256_KEY_KEY11                /*!< AESKEY1 Bit 1 */
N#define AESKEY12                                 AES256_KEY_KEY12                /*!< AESKEY1 Bit 2 */
N#define AESKEY13                                 AES256_KEY_KEY13                /*!< AESKEY1 Bit 3 */
N#define AESKEY14                                 AES256_KEY_KEY14                /*!< AESKEY1 Bit 4 */
N#define AESKEY15                                 AES256_KEY_KEY15                /*!< AESKEY1 Bit 5 */
N#define AESKEY16                                 AES256_KEY_KEY16                /*!< AESKEY1 Bit 6 */
N#define AESKEY17                                 AES256_KEY_KEY17                /*!< AESKEY1 Bit 7 */
N/* AESADIN[AESDIN0] Bits */
N#define AESDIN0_OFS                              AES256_DIN_DIN0_OFS             /*!< AESDIN0 Offset */
N#define AESDIN0_M                                AES256_DIN_DIN0_MASK            /*!< AES data in byte n when AESADIN is written as half-word */
N#define AESDIN00                                 AES256_DIN_DIN00                /*!< AESDIN0 Bit 0 */
N#define AESDIN01                                 AES256_DIN_DIN01                /*!< AESDIN0 Bit 1 */
N#define AESDIN02                                 AES256_DIN_DIN02                /*!< AESDIN0 Bit 2 */
N#define AESDIN03                                 AES256_DIN_DIN03                /*!< AESDIN0 Bit 3 */
N#define AESDIN04                                 AES256_DIN_DIN04                /*!< AESDIN0 Bit 4 */
N#define AESDIN05                                 AES256_DIN_DIN05                /*!< AESDIN0 Bit 5 */
N#define AESDIN06                                 AES256_DIN_DIN06                /*!< AESDIN0 Bit 6 */
N#define AESDIN07                                 AES256_DIN_DIN07                /*!< AESDIN0 Bit 7 */
N/* AESADIN[AESDIN1] Bits */
N#define AESDIN1_OFS                              AES256_DIN_DIN1_OFS             /*!< AESDIN1 Offset */
N#define AESDIN1_M                                AES256_DIN_DIN1_MASK            /*!< AES data in byte n+1 when AESADIN is written as half-word */
N#define AESDIN10                                 AES256_DIN_DIN10                /*!< AESDIN1 Bit 0 */
N#define AESDIN11                                 AES256_DIN_DIN11                /*!< AESDIN1 Bit 1 */
N#define AESDIN12                                 AES256_DIN_DIN12                /*!< AESDIN1 Bit 2 */
N#define AESDIN13                                 AES256_DIN_DIN13                /*!< AESDIN1 Bit 3 */
N#define AESDIN14                                 AES256_DIN_DIN14                /*!< AESDIN1 Bit 4 */
N#define AESDIN15                                 AES256_DIN_DIN15                /*!< AESDIN1 Bit 5 */
N#define AESDIN16                                 AES256_DIN_DIN16                /*!< AESDIN1 Bit 6 */
N#define AESDIN17                                 AES256_DIN_DIN17                /*!< AESDIN1 Bit 7 */
N/* AESADOUT[AESDOUT0] Bits */
N#define AESDOUT0_OFS                             AES256_DOUT_DOUT0_OFS           /*!< AESDOUT0 Offset */
N#define AESDOUT0_M                               AES256_DOUT_DOUT0_MASK          /*!< AES data out byte n when AESADOUT is read as half-word */
N#define AESDOUT00                                AES256_DOUT_DOUT00              /*!< AESDOUT0 Bit 0 */
N#define AESDOUT01                                AES256_DOUT_DOUT01              /*!< AESDOUT0 Bit 1 */
N#define AESDOUT02                                AES256_DOUT_DOUT02              /*!< AESDOUT0 Bit 2 */
N#define AESDOUT03                                AES256_DOUT_DOUT03              /*!< AESDOUT0 Bit 3 */
N#define AESDOUT04                                AES256_DOUT_DOUT04              /*!< AESDOUT0 Bit 4 */
N#define AESDOUT05                                AES256_DOUT_DOUT05              /*!< AESDOUT0 Bit 5 */
N#define AESDOUT06                                AES256_DOUT_DOUT06              /*!< AESDOUT0 Bit 6 */
N#define AESDOUT07                                AES256_DOUT_DOUT07              /*!< AESDOUT0 Bit 7 */
N/* AESADOUT[AESDOUT1] Bits */
N#define AESDOUT1_OFS                             AES256_DOUT_DOUT1_OFS           /*!< AESDOUT1 Offset */
N#define AESDOUT1_M                               AES256_DOUT_DOUT1_MASK          /*!< AES data out byte n+1 when AESADOUT is read as half-word */
N#define AESDOUT10                                AES256_DOUT_DOUT10              /*!< AESDOUT1 Bit 0 */
N#define AESDOUT11                                AES256_DOUT_DOUT11              /*!< AESDOUT1 Bit 1 */
N#define AESDOUT12                                AES256_DOUT_DOUT12              /*!< AESDOUT1 Bit 2 */
N#define AESDOUT13                                AES256_DOUT_DOUT13              /*!< AESDOUT1 Bit 3 */
N#define AESDOUT14                                AES256_DOUT_DOUT14              /*!< AESDOUT1 Bit 4 */
N#define AESDOUT15                                AES256_DOUT_DOUT15              /*!< AESDOUT1 Bit 5 */
N#define AESDOUT16                                AES256_DOUT_DOUT16              /*!< AESDOUT1 Bit 6 */
N#define AESDOUT17                                AES256_DOUT_DOUT17              /*!< AESDOUT1 Bit 7 */
N/* AESAXDIN[AESXDIN0] Bits */
N#define AESXDIN0_OFS                             AES256_XDIN_XDIN0_OFS           /*!< AESXDIN0 Offset */
N#define AESXDIN0_M                               AES256_XDIN_XDIN0_MASK          /*!< AES data in byte n when AESAXDIN is written as half-word */
N#define AESXDIN00                                AES256_XDIN_XDIN00              /*!< AESXDIN0 Bit 0 */
N#define AESXDIN01                                AES256_XDIN_XDIN01              /*!< AESXDIN0 Bit 1 */
N#define AESXDIN02                                AES256_XDIN_XDIN02              /*!< AESXDIN0 Bit 2 */
N#define AESXDIN03                                AES256_XDIN_XDIN03              /*!< AESXDIN0 Bit 3 */
N#define AESXDIN04                                AES256_XDIN_XDIN04              /*!< AESXDIN0 Bit 4 */
N#define AESXDIN05                                AES256_XDIN_XDIN05              /*!< AESXDIN0 Bit 5 */
N#define AESXDIN06                                AES256_XDIN_XDIN06              /*!< AESXDIN0 Bit 6 */
N#define AESXDIN07                                AES256_XDIN_XDIN07              /*!< AESXDIN0 Bit 7 */
N/* AESAXDIN[AESXDIN1] Bits */
N#define AESXDIN1_OFS                             AES256_XDIN_XDIN1_OFS           /*!< AESXDIN1 Offset */
N#define AESXDIN1_M                               AES256_XDIN_XDIN1_MASK          /*!< AES data in byte n+1 when AESAXDIN is written as half-word */
N#define AESXDIN10                                AES256_XDIN_XDIN10              /*!< AESXDIN1 Bit 0 */
N#define AESXDIN11                                AES256_XDIN_XDIN11              /*!< AESXDIN1 Bit 1 */
N#define AESXDIN12                                AES256_XDIN_XDIN12              /*!< AESXDIN1 Bit 2 */
N#define AESXDIN13                                AES256_XDIN_XDIN13              /*!< AESXDIN1 Bit 3 */
N#define AESXDIN14                                AES256_XDIN_XDIN14              /*!< AESXDIN1 Bit 4 */
N#define AESXDIN15                                AES256_XDIN_XDIN15              /*!< AESXDIN1 Bit 5 */
N#define AESXDIN16                                AES256_XDIN_XDIN16              /*!< AESXDIN1 Bit 6 */
N#define AESXDIN17                                AES256_XDIN_XDIN17              /*!< AESXDIN1 Bit 7 */
N/* AESAXIN[AESXIN0] Bits */
N#define AESXIN0_OFS                              AES256_XIN_XIN0_OFS             /*!< AESXIN0 Offset */
N#define AESXIN0_M                                AES256_XIN_XIN0_MASK            /*!< AES data in byte n when AESAXIN is written as half-word */
N#define AESXIN00                                 AES256_XIN_XIN00                /*!< AESXIN0 Bit 0 */
N#define AESXIN01                                 AES256_XIN_XIN01                /*!< AESXIN0 Bit 1 */
N#define AESXIN02                                 AES256_XIN_XIN02                /*!< AESXIN0 Bit 2 */
N#define AESXIN03                                 AES256_XIN_XIN03                /*!< AESXIN0 Bit 3 */
N#define AESXIN04                                 AES256_XIN_XIN04                /*!< AESXIN0 Bit 4 */
N#define AESXIN05                                 AES256_XIN_XIN05                /*!< AESXIN0 Bit 5 */
N#define AESXIN06                                 AES256_XIN_XIN06                /*!< AESXIN0 Bit 6 */
N#define AESXIN07                                 AES256_XIN_XIN07                /*!< AESXIN0 Bit 7 */
N/* AESAXIN[AESXIN1] Bits */
N#define AESXIN1_OFS                              AES256_XIN_XIN1_OFS             /*!< AESXIN1 Offset */
N#define AESXIN1_M                                AES256_XIN_XIN1_MASK            /*!< AES data in byte n+1 when AESAXIN is written as half-word */
N#define AESXIN10                                 AES256_XIN_XIN10                /*!< AESXIN1 Bit 0 */
N#define AESXIN11                                 AES256_XIN_XIN11                /*!< AESXIN1 Bit 1 */
N#define AESXIN12                                 AES256_XIN_XIN12                /*!< AESXIN1 Bit 2 */
N#define AESXIN13                                 AES256_XIN_XIN13                /*!< AESXIN1 Bit 3 */
N#define AESXIN14                                 AES256_XIN_XIN14                /*!< AESXIN1 Bit 4 */
N#define AESXIN15                                 AES256_XIN_XIN15                /*!< AESXIN1 Bit 5 */
N#define AESXIN16                                 AES256_XIN_XIN16                /*!< AESXIN1 Bit 6 */
N#define AESXIN17                                 AES256_XIN_XIN17                /*!< AESXIN1 Bit 7 */
N
N/******************************************************************************
N* CAPTIO Bits (legacy section)
N******************************************************************************/
N/* CAPTIO0CTL[CAPTIOPISEL] Bits */
N#define CAPTIOPISEL_OFS                          CAPTIO_CTL_PISEL_OFS            /*!< CAPTIOPISEL Offset */
N#define CAPTIOPISEL_M                            CAPTIO_CTL_PISEL_MASK           /*!< Capacitive Touch IO pin select */
N#define CAPTIOPISEL0                             CAPTIO_CTL_PISEL0               /*!< CAPTIOPISEL Bit 0 */
N#define CAPTIOPISEL1                             CAPTIO_CTL_PISEL1               /*!< CAPTIOPISEL Bit 1 */
N#define CAPTIOPISEL2                             CAPTIO_CTL_PISEL2               /*!< CAPTIOPISEL Bit 2 */
N#define CAPTIOPISEL_0                            CAPTIO_CTL_PISEL_0              /*!< Px.0 */
N#define CAPTIOPISEL_1                            CAPTIO_CTL_PISEL_1              /*!< Px.1 */
N#define CAPTIOPISEL_2                            CAPTIO_CTL_PISEL_2              /*!< Px.2 */
N#define CAPTIOPISEL_3                            CAPTIO_CTL_PISEL_3              /*!< Px.3 */
N#define CAPTIOPISEL_4                            CAPTIO_CTL_PISEL_4              /*!< Px.4 */
N#define CAPTIOPISEL_5                            CAPTIO_CTL_PISEL_5              /*!< Px.5 */
N#define CAPTIOPISEL_6                            CAPTIO_CTL_PISEL_6              /*!< Px.6 */
N#define CAPTIOPISEL_7                            CAPTIO_CTL_PISEL_7              /*!< Px.7 */
N/* CAPTIO0CTL[CAPTIOPOSEL] Bits */
N#define CAPTIOPOSEL_OFS                          CAPTIO_CTL_POSEL_OFS            /*!< CAPTIOPOSEL Offset */
N#define CAPTIOPOSEL_M                            CAPTIO_CTL_POSEL_MASK           /*!< Capacitive Touch IO port select */
N#define CAPTIOPOSEL0                             CAPTIO_CTL_POSEL0               /*!< CAPTIOPOSEL Bit 0 */
N#define CAPTIOPOSEL1                             CAPTIO_CTL_POSEL1               /*!< CAPTIOPOSEL Bit 1 */
N#define CAPTIOPOSEL2                             CAPTIO_CTL_POSEL2               /*!< CAPTIOPOSEL Bit 2 */
N#define CAPTIOPOSEL3                             CAPTIO_CTL_POSEL3               /*!< CAPTIOPOSEL Bit 3 */
N#define CAPTIOPOSEL_0                            CAPTIO_CTL_POSEL_0              /*!< Px = PJ */
N#define CAPTIOPOSEL_1                            CAPTIO_CTL_POSEL_1              /*!< Px = P1 */
N#define CAPTIOPOSEL_2                            CAPTIO_CTL_POSEL_2              /*!< Px = P2 */
N#define CAPTIOPOSEL_3                            CAPTIO_CTL_POSEL_3              /*!< Px = P3 */
N#define CAPTIOPOSEL_4                            CAPTIO_CTL_POSEL_4              /*!< Px = P4 */
N#define CAPTIOPOSEL_5                            CAPTIO_CTL_POSEL_5              /*!< Px = P5 */
N#define CAPTIOPOSEL_6                            CAPTIO_CTL_POSEL_6              /*!< Px = P6 */
N#define CAPTIOPOSEL_7                            CAPTIO_CTL_POSEL_7              /*!< Px = P7 */
N#define CAPTIOPOSEL_8                            CAPTIO_CTL_POSEL_8              /*!< Px = P8 */
N#define CAPTIOPOSEL_9                            CAPTIO_CTL_POSEL_9              /*!< Px = P9 */
N#define CAPTIOPOSEL_10                           CAPTIO_CTL_POSEL_10             /*!< Px = P10 */
N#define CAPTIOPOSEL_11                           CAPTIO_CTL_POSEL_11             /*!< Px = P11 */
N#define CAPTIOPOSEL_12                           CAPTIO_CTL_POSEL_12             /*!< Px = P12 */
N#define CAPTIOPOSEL_13                           CAPTIO_CTL_POSEL_13             /*!< Px = P13 */
N#define CAPTIOPOSEL_14                           CAPTIO_CTL_POSEL_14             /*!< Px = P14 */
N#define CAPTIOPOSEL_15                           CAPTIO_CTL_POSEL_15             /*!< Px = P15 */
N#define CAPTIOPOSEL__PJ                          CAPTIO_CTL_POSEL__PJ            /*!< Px = PJ */
N#define CAPTIOPOSEL__P1                          CAPTIO_CTL_POSEL__P1            /*!< Px = P1 */
N#define CAPTIOPOSEL__P2                          CAPTIO_CTL_POSEL__P2            /*!< Px = P2 */
N#define CAPTIOPOSEL__P3                          CAPTIO_CTL_POSEL__P3            /*!< Px = P3 */
N#define CAPTIOPOSEL__P4                          CAPTIO_CTL_POSEL__P4            /*!< Px = P4 */
N#define CAPTIOPOSEL__P5                          CAPTIO_CTL_POSEL__P5            /*!< Px = P5 */
N#define CAPTIOPOSEL__P6                          CAPTIO_CTL_POSEL__P6            /*!< Px = P6 */
N#define CAPTIOPOSEL__P7                          CAPTIO_CTL_POSEL__P7            /*!< Px = P7 */
N#define CAPTIOPOSEL__P8                          CAPTIO_CTL_POSEL__P8            /*!< Px = P8 */
N#define CAPTIOPOSEL__P9                          CAPTIO_CTL_POSEL__P9            /*!< Px = P9 */
N#define CAPTIOPOSEL__P10                         CAPTIO_CTL_POSEL__P10           /*!< Px = P10 */
N#define CAPTIOPOSEL__P11                         CAPTIO_CTL_POSEL__P11           /*!< Px = P11 */
N#define CAPTIOPOSEL__P12                         CAPTIO_CTL_POSEL__P12           /*!< Px = P12 */
N#define CAPTIOPOSEL__P13                         CAPTIO_CTL_POSEL__P13           /*!< Px = P13 */
N#define CAPTIOPOSEL__P14                         CAPTIO_CTL_POSEL__P14           /*!< Px = P14 */
N#define CAPTIOPOSEL__P15                         CAPTIO_CTL_POSEL__P15           /*!< Px = P15 */
N/* CAPTIO0CTL[CAPTIOEN] Bits */
N#define CAPTIOEN_OFS                             CAPTIO_CTL_EN_OFS               /*!< CAPTIOEN Offset */
N#define CAPTIOEN                                 CAPTIO_CTL_EN                   /*!< Capacitive Touch IO enable */
N/* CAPTIO0CTL[CAPTIOSTATE] Bits */
N#define CAPTIOSTATE_OFS                          CAPTIO_CTL_STATE_OFS            /*!< CAPTIOSTATE Offset */
N#define CAPTIOSTATE                              CAPTIO_CTL_STATE                /*!< Capacitive Touch IO state */
N
N/******************************************************************************
N* COMP_E Bits (legacy section)
N******************************************************************************/
N/* CE0CTL0[CEIPSEL] Bits */
N#define CEIPSEL_OFS                              COMP_E_CTL0_IPSEL_OFS           /*!< CEIPSEL Offset */
N#define CEIPSEL_M                                COMP_E_CTL0_IPSEL_MASK          /*!< Channel input selected for the V+ terminal */
N#define CEIPSEL0                                 COMP_E_CTL0_IPSEL0              /*!< CEIPSEL Bit 0 */
N#define CEIPSEL1                                 COMP_E_CTL0_IPSEL1              /*!< CEIPSEL Bit 1 */
N#define CEIPSEL2                                 COMP_E_CTL0_IPSEL2              /*!< CEIPSEL Bit 2 */
N#define CEIPSEL3                                 COMP_E_CTL0_IPSEL3              /*!< CEIPSEL Bit 3 */
N#define CEIPSEL_0                                COMP_E_CTL0_IPSEL_0             /*!< Channel 0 selected */
N#define CEIPSEL_1                                COMP_E_CTL0_IPSEL_1             /*!< Channel 1 selected */
N#define CEIPSEL_2                                COMP_E_CTL0_IPSEL_2             /*!< Channel 2 selected */
N#define CEIPSEL_3                                COMP_E_CTL0_IPSEL_3             /*!< Channel 3 selected */
N#define CEIPSEL_4                                COMP_E_CTL0_IPSEL_4             /*!< Channel 4 selected */
N#define CEIPSEL_5                                COMP_E_CTL0_IPSEL_5             /*!< Channel 5 selected */
N#define CEIPSEL_6                                COMP_E_CTL0_IPSEL_6             /*!< Channel 6 selected */
N#define CEIPSEL_7                                COMP_E_CTL0_IPSEL_7             /*!< Channel 7 selected */
N#define CEIPSEL_8                                COMP_E_CTL0_IPSEL_8             /*!< Channel 8 selected */
N#define CEIPSEL_9                                COMP_E_CTL0_IPSEL_9             /*!< Channel 9 selected */
N#define CEIPSEL_10                               COMP_E_CTL0_IPSEL_10            /*!< Channel 10 selected */
N#define CEIPSEL_11                               COMP_E_CTL0_IPSEL_11            /*!< Channel 11 selected */
N#define CEIPSEL_12                               COMP_E_CTL0_IPSEL_12            /*!< Channel 12 selected */
N#define CEIPSEL_13                               COMP_E_CTL0_IPSEL_13            /*!< Channel 13 selected */
N#define CEIPSEL_14                               COMP_E_CTL0_IPSEL_14            /*!< Channel 14 selected */
N#define CEIPSEL_15                               COMP_E_CTL0_IPSEL_15            /*!< Channel 15 selected */
N/* CE0CTL0[CEIPEN] Bits */
N#define CEIPEN_OFS                               COMP_E_CTL0_IPEN_OFS            /*!< CEIPEN Offset */
N#define CEIPEN                                   COMP_E_CTL0_IPEN                /*!< Channel input enable for the V+ terminal */
N/* CE0CTL0[CEIMSEL] Bits */
N#define CEIMSEL_OFS                              COMP_E_CTL0_IMSEL_OFS           /*!< CEIMSEL Offset */
N#define CEIMSEL_M                                COMP_E_CTL0_IMSEL_MASK          /*!< Channel input selected for the - terminal */
N#define CEIMSEL0                                 COMP_E_CTL0_IMSEL0              /*!< CEIMSEL Bit 0 */
N#define CEIMSEL1                                 COMP_E_CTL0_IMSEL1              /*!< CEIMSEL Bit 1 */
N#define CEIMSEL2                                 COMP_E_CTL0_IMSEL2              /*!< CEIMSEL Bit 2 */
N#define CEIMSEL3                                 COMP_E_CTL0_IMSEL3              /*!< CEIMSEL Bit 3 */
N#define CEIMSEL_0                                COMP_E_CTL0_IMSEL_0             /*!< Channel 0 selected */
N#define CEIMSEL_1                                COMP_E_CTL0_IMSEL_1             /*!< Channel 1 selected */
N#define CEIMSEL_2                                COMP_E_CTL0_IMSEL_2             /*!< Channel 2 selected */
N#define CEIMSEL_3                                COMP_E_CTL0_IMSEL_3             /*!< Channel 3 selected */
N#define CEIMSEL_4                                COMP_E_CTL0_IMSEL_4             /*!< Channel 4 selected */
N#define CEIMSEL_5                                COMP_E_CTL0_IMSEL_5             /*!< Channel 5 selected */
N#define CEIMSEL_6                                COMP_E_CTL0_IMSEL_6             /*!< Channel 6 selected */
N#define CEIMSEL_7                                COMP_E_CTL0_IMSEL_7             /*!< Channel 7 selected */
N#define CEIMSEL_8                                COMP_E_CTL0_IMSEL_8             /*!< Channel 8 selected */
N#define CEIMSEL_9                                COMP_E_CTL0_IMSEL_9             /*!< Channel 9 selected */
N#define CEIMSEL_10                               COMP_E_CTL0_IMSEL_10            /*!< Channel 10 selected */
N#define CEIMSEL_11                               COMP_E_CTL0_IMSEL_11            /*!< Channel 11 selected */
N#define CEIMSEL_12                               COMP_E_CTL0_IMSEL_12            /*!< Channel 12 selected */
N#define CEIMSEL_13                               COMP_E_CTL0_IMSEL_13            /*!< Channel 13 selected */
N#define CEIMSEL_14                               COMP_E_CTL0_IMSEL_14            /*!< Channel 14 selected */
N#define CEIMSEL_15                               COMP_E_CTL0_IMSEL_15            /*!< Channel 15 selected */
N/* CE0CTL0[CEIMEN] Bits */
N#define CEIMEN_OFS                               COMP_E_CTL0_IMEN_OFS            /*!< CEIMEN Offset */
N#define CEIMEN                                   COMP_E_CTL0_IMEN                /*!< Channel input enable for the - terminal */
N/* CE0CTL1[CEOUT] Bits */
N#define CEOUT_OFS                                COMP_E_CTL1_OUT_OFS             /*!< CEOUT Offset */
N#define CEOUT                                    COMP_E_CTL1_OUT                 /*!< Comparator output value */
N/* CE0CTL1[CEOUTPOL] Bits */
N#define CEOUTPOL_OFS                             COMP_E_CTL1_OUTPOL_OFS          /*!< CEOUTPOL Offset */
N#define CEOUTPOL                                 COMP_E_CTL1_OUTPOL              /*!< Comparator output polarity */
N/* CE0CTL1[CEF] Bits */
N#define CEF_OFS                                  COMP_E_CTL1_F_OFS               /*!< CEF Offset */
N#define CEF                                      COMP_E_CTL1_F                   /*!< Comparator output filter */
N/* CE0CTL1[CEIES] Bits */
N#define CEIES_OFS                                COMP_E_CTL1_IES_OFS             /*!< CEIES Offset */
N#define CEIES                                    COMP_E_CTL1_IES                 /*!< Interrupt edge select for CEIIFG and CEIFG */
N/* CE0CTL1[CESHORT] Bits */
N#define CESHORT_OFS                              COMP_E_CTL1_SHORT_OFS           /*!< CESHORT Offset */
N#define CESHORT                                  COMP_E_CTL1_SHORT               /*!< Input short */
N/* CE0CTL1[CEEX] Bits */
N#define CEEX_OFS                                 COMP_E_CTL1_EX_OFS              /*!< CEEX Offset */
N#define CEEX                                     COMP_E_CTL1_EX                  /*!< Exchange */
N/* CE0CTL1[CEFDLY] Bits */
N#define CEFDLY_OFS                               COMP_E_CTL1_FDLY_OFS            /*!< CEFDLY Offset */
N#define CEFDLY_M                                 COMP_E_CTL1_FDLY_MASK           /*!< Filter delay */
N#define CEFDLY0                                  COMP_E_CTL1_FDLY0               /*!< CEFDLY Bit 0 */
N#define CEFDLY1                                  COMP_E_CTL1_FDLY1               /*!< CEFDLY Bit 1 */
N#define CEFDLY_0                                 COMP_E_CTL1_FDLY_0              /*!< Typical filter delay of TBD (450) ns */
N#define CEFDLY_1                                 COMP_E_CTL1_FDLY_1              /*!< Typical filter delay of TBD (900) ns */
N#define CEFDLY_2                                 COMP_E_CTL1_FDLY_2              /*!< Typical filter delay of TBD (1800) ns */
N#define CEFDLY_3                                 COMP_E_CTL1_FDLY_3              /*!< Typical filter delay of TBD (3600) ns */
N/* CE0CTL1[CEPWRMD] Bits */
N#define CEPWRMD_OFS                              COMP_E_CTL1_PWRMD_OFS           /*!< CEPWRMD Offset */
N#define CEPWRMD_M                                COMP_E_CTL1_PWRMD_MASK          /*!< Power Mode */
N#define CEPWRMD0                                 COMP_E_CTL1_PWRMD0              /*!< CEPWRMD Bit 0 */
N#define CEPWRMD1                                 COMP_E_CTL1_PWRMD1              /*!< CEPWRMD Bit 1 */
N#define CEPWRMD_0                                COMP_E_CTL1_PWRMD_0             /*!< High-speed mode */
N#define CEPWRMD_1                                COMP_E_CTL1_PWRMD_1             /*!< Normal mode */
N#define CEPWRMD_2                                COMP_E_CTL1_PWRMD_2             /*!< Ultra-low power mode */
N/* CE0CTL1[CEON] Bits */
N#define CEON_OFS                                 COMP_E_CTL1_ON_OFS              /*!< CEON Offset */
N#define CEON                                     COMP_E_CTL1_ON                  /*!< Comparator On */
N/* CE0CTL1[CEMRVL] Bits */
N#define CEMRVL_OFS                               COMP_E_CTL1_MRVL_OFS            /*!< CEMRVL Offset */
N#define CEMRVL                                   COMP_E_CTL1_MRVL                /*!< This bit is valid of CEMRVS is set to 1 */
N/* CE0CTL1[CEMRVS] Bits */
N#define CEMRVS_OFS                               COMP_E_CTL1_MRVS_OFS            /*!< CEMRVS Offset */
N#define CEMRVS                                   COMP_E_CTL1_MRVS                
N/* CE0CTL2[CEREF0] Bits */
N#define CEREF0_OFS                               COMP_E_CTL2_REF0_OFS            /*!< CEREF0 Offset */
N#define CEREF0_M                                 COMP_E_CTL2_REF0_MASK           /*!< Reference resistor tap 0 */
N#define CEREF00                                  COMP_E_CTL2_REF00               /*!< CEREF0 Bit 0 */
N#define CEREF01                                  COMP_E_CTL2_REF01               /*!< CEREF0 Bit 1 */
N#define CEREF02                                  COMP_E_CTL2_REF02               /*!< CEREF0 Bit 2 */
N#define CEREF03                                  COMP_E_CTL2_REF03               /*!< CEREF0 Bit 3 */
N#define CEREF04                                  COMP_E_CTL2_REF04               /*!< CEREF0 Bit 4 */
N#define CEREF0_0                                 COMP_E_CTL2_REF0_0              /*!< Reference resistor tap for setting 0. */
N#define CEREF0_1                                 COMP_E_CTL2_REF0_1              /*!< Reference resistor tap for setting 1. */
N#define CEREF0_2                                 COMP_E_CTL2_REF0_2              /*!< Reference resistor tap for setting 2. */
N#define CEREF0_3                                 COMP_E_CTL2_REF0_3              /*!< Reference resistor tap for setting 3. */
N#define CEREF0_4                                 COMP_E_CTL2_REF0_4              /*!< Reference resistor tap for setting 4. */
N#define CEREF0_5                                 COMP_E_CTL2_REF0_5              /*!< Reference resistor tap for setting 5. */
N#define CEREF0_6                                 COMP_E_CTL2_REF0_6              /*!< Reference resistor tap for setting 6. */
N#define CEREF0_7                                 COMP_E_CTL2_REF0_7              /*!< Reference resistor tap for setting 7. */
N#define CEREF0_8                                 COMP_E_CTL2_REF0_8              /*!< Reference resistor tap for setting 8. */
N#define CEREF0_9                                 COMP_E_CTL2_REF0_9              /*!< Reference resistor tap for setting 9. */
N#define CEREF0_10                                COMP_E_CTL2_REF0_10             /*!< Reference resistor tap for setting 10. */
N#define CEREF0_11                                COMP_E_CTL2_REF0_11             /*!< Reference resistor tap for setting 11. */
N#define CEREF0_12                                COMP_E_CTL2_REF0_12             /*!< Reference resistor tap for setting 12. */
N#define CEREF0_13                                COMP_E_CTL2_REF0_13             /*!< Reference resistor tap for setting 13. */
N#define CEREF0_14                                COMP_E_CTL2_REF0_14             /*!< Reference resistor tap for setting 14. */
N#define CEREF0_15                                COMP_E_CTL2_REF0_15             /*!< Reference resistor tap for setting 15. */
N#define CEREF0_16                                COMP_E_CTL2_REF0_16             /*!< Reference resistor tap for setting 16. */
N#define CEREF0_17                                COMP_E_CTL2_REF0_17             /*!< Reference resistor tap for setting 17. */
N#define CEREF0_18                                COMP_E_CTL2_REF0_18             /*!< Reference resistor tap for setting 18. */
N#define CEREF0_19                                COMP_E_CTL2_REF0_19             /*!< Reference resistor tap for setting 19. */
N#define CEREF0_20                                COMP_E_CTL2_REF0_20             /*!< Reference resistor tap for setting 20. */
N#define CEREF0_21                                COMP_E_CTL2_REF0_21             /*!< Reference resistor tap for setting 21. */
N#define CEREF0_22                                COMP_E_CTL2_REF0_22             /*!< Reference resistor tap for setting 22. */
N#define CEREF0_23                                COMP_E_CTL2_REF0_23             /*!< Reference resistor tap for setting 23. */
N#define CEREF0_24                                COMP_E_CTL2_REF0_24             /*!< Reference resistor tap for setting 24. */
N#define CEREF0_25                                COMP_E_CTL2_REF0_25             /*!< Reference resistor tap for setting 25. */
N#define CEREF0_26                                COMP_E_CTL2_REF0_26             /*!< Reference resistor tap for setting 26. */
N#define CEREF0_27                                COMP_E_CTL2_REF0_27             /*!< Reference resistor tap for setting 27. */
N#define CEREF0_28                                COMP_E_CTL2_REF0_28             /*!< Reference resistor tap for setting 28. */
N#define CEREF0_29                                COMP_E_CTL2_REF0_29             /*!< Reference resistor tap for setting 29. */
N#define CEREF0_30                                COMP_E_CTL2_REF0_30             /*!< Reference resistor tap for setting 30. */
N#define CEREF0_31                                COMP_E_CTL2_REF0_31             /*!< Reference resistor tap for setting 31. */
N/* CE0CTL2[CERSEL] Bits */
N#define CERSEL_OFS                               COMP_E_CTL2_RSEL_OFS            /*!< CERSEL Offset */
N#define CERSEL                                   COMP_E_CTL2_RSEL                /*!< Reference select */
N/* CE0CTL2[CERS] Bits */
N#define CERS_OFS                                 COMP_E_CTL2_RS_OFS              /*!< CERS Offset */
N#define CERS_M                                   COMP_E_CTL2_RS_MASK             /*!< Reference source */
N#define CERS0                                    COMP_E_CTL2_RS0                 /*!< CERS Bit 0 */
N#define CERS1                                    COMP_E_CTL2_RS1                 /*!< CERS Bit 1 */
N#define CERS_0                                   COMP_E_CTL2_RS_0                /*!< No current is drawn by the reference circuitry */
N#define CERS_1                                   COMP_E_CTL2_RS_1                /*!< VCC applied to the resistor ladder */
N#define CERS_2                                   COMP_E_CTL2_RS_2                /*!< Shared reference voltage applied to the resistor ladder */
N#define CERS_3                                   COMP_E_CTL2_RS_3                /*!< Shared reference voltage supplied to V(CREF). Resistor ladder is off */
N/* CE0CTL2[CEREF1] Bits */
N#define CEREF1_OFS                               COMP_E_CTL2_REF1_OFS            /*!< CEREF1 Offset */
N#define CEREF1_M                                 COMP_E_CTL2_REF1_MASK           /*!< Reference resistor tap 1 */
N#define CEREF10                                  COMP_E_CTL2_REF10               /*!< CEREF1 Bit 0 */
N#define CEREF11                                  COMP_E_CTL2_REF11               /*!< CEREF1 Bit 1 */
N#define CEREF12                                  COMP_E_CTL2_REF12               /*!< CEREF1 Bit 2 */
N#define CEREF13                                  COMP_E_CTL2_REF13               /*!< CEREF1 Bit 3 */
N#define CEREF14                                  COMP_E_CTL2_REF14               /*!< CEREF1 Bit 4 */
N#define CEREF1_0                                 COMP_E_CTL2_REF1_0              /*!< Reference resistor tap for setting 0. */
N#define CEREF1_1                                 COMP_E_CTL2_REF1_1              /*!< Reference resistor tap for setting 1. */
N#define CEREF1_2                                 COMP_E_CTL2_REF1_2              /*!< Reference resistor tap for setting 2. */
N#define CEREF1_3                                 COMP_E_CTL2_REF1_3              /*!< Reference resistor tap for setting 3. */
N#define CEREF1_4                                 COMP_E_CTL2_REF1_4              /*!< Reference resistor tap for setting 4. */
N#define CEREF1_5                                 COMP_E_CTL2_REF1_5              /*!< Reference resistor tap for setting 5. */
N#define CEREF1_6                                 COMP_E_CTL2_REF1_6              /*!< Reference resistor tap for setting 6. */
N#define CEREF1_7                                 COMP_E_CTL2_REF1_7              /*!< Reference resistor tap for setting 7. */
N#define CEREF1_8                                 COMP_E_CTL2_REF1_8              /*!< Reference resistor tap for setting 8. */
N#define CEREF1_9                                 COMP_E_CTL2_REF1_9              /*!< Reference resistor tap for setting 9. */
N#define CEREF1_10                                COMP_E_CTL2_REF1_10             /*!< Reference resistor tap for setting 10. */
N#define CEREF1_11                                COMP_E_CTL2_REF1_11             /*!< Reference resistor tap for setting 11. */
N#define CEREF1_12                                COMP_E_CTL2_REF1_12             /*!< Reference resistor tap for setting 12. */
N#define CEREF1_13                                COMP_E_CTL2_REF1_13             /*!< Reference resistor tap for setting 13. */
N#define CEREF1_14                                COMP_E_CTL2_REF1_14             /*!< Reference resistor tap for setting 14. */
N#define CEREF1_15                                COMP_E_CTL2_REF1_15             /*!< Reference resistor tap for setting 15. */
N#define CEREF1_16                                COMP_E_CTL2_REF1_16             /*!< Reference resistor tap for setting 16. */
N#define CEREF1_17                                COMP_E_CTL2_REF1_17             /*!< Reference resistor tap for setting 17. */
N#define CEREF1_18                                COMP_E_CTL2_REF1_18             /*!< Reference resistor tap for setting 18. */
N#define CEREF1_19                                COMP_E_CTL2_REF1_19             /*!< Reference resistor tap for setting 19. */
N#define CEREF1_20                                COMP_E_CTL2_REF1_20             /*!< Reference resistor tap for setting 20. */
N#define CEREF1_21                                COMP_E_CTL2_REF1_21             /*!< Reference resistor tap for setting 21. */
N#define CEREF1_22                                COMP_E_CTL2_REF1_22             /*!< Reference resistor tap for setting 22. */
N#define CEREF1_23                                COMP_E_CTL2_REF1_23             /*!< Reference resistor tap for setting 23. */
N#define CEREF1_24                                COMP_E_CTL2_REF1_24             /*!< Reference resistor tap for setting 24. */
N#define CEREF1_25                                COMP_E_CTL2_REF1_25             /*!< Reference resistor tap for setting 25. */
N#define CEREF1_26                                COMP_E_CTL2_REF1_26             /*!< Reference resistor tap for setting 26. */
N#define CEREF1_27                                COMP_E_CTL2_REF1_27             /*!< Reference resistor tap for setting 27. */
N#define CEREF1_28                                COMP_E_CTL2_REF1_28             /*!< Reference resistor tap for setting 28. */
N#define CEREF1_29                                COMP_E_CTL2_REF1_29             /*!< Reference resistor tap for setting 29. */
N#define CEREF1_30                                COMP_E_CTL2_REF1_30             /*!< Reference resistor tap for setting 30. */
N#define CEREF1_31                                COMP_E_CTL2_REF1_31             /*!< Reference resistor tap for setting 31. */
N/* CE0CTL2[CEREFL] Bits */
N#define CEREFL_OFS                               COMP_E_CTL2_REFL_OFS            /*!< CEREFL Offset */
N#define CEREFL_M                                 COMP_E_CTL2_REFL_MASK           /*!< Reference voltage level */
N#define CEREFL0                                  COMP_E_CTL2_REFL0               /*!< CEREFL Bit 0 */
N#define CEREFL1                                  COMP_E_CTL2_REFL1               /*!< CEREFL Bit 1 */
N#define CEREFL_0                                 COMP_E_CTL2_CEREFL_0            /*!< Reference amplifier is disabled. No reference voltage is requested */
N#define CEREFL_1                                 COMP_E_CTL2_CEREFL_1            /*!< 1.2 V is selected as shared reference voltage input */
N#define CEREFL_2                                 COMP_E_CTL2_CEREFL_2            /*!< 2.0 V is selected as shared reference voltage input */
N#define CEREFL_3                                 COMP_E_CTL2_CEREFL_3            /*!< 2.5 V is selected as shared reference voltage input */
N#define CEREFL__OFF                              COMP_E_CTL2_REFL__OFF           /*!< Reference amplifier is disabled. No reference voltage is requested */
N#define CEREFL__1P2V                             COMP_E_CTL2_REFL__1P2V          /*!< 1.2 V is selected as shared reference voltage input */
N#define CEREFL__2P0V                             COMP_E_CTL2_REFL__2P0V          /*!< 2.0 V is selected as shared reference voltage input */
N#define CEREFL__2P5V                             COMP_E_CTL2_REFL__2P5V          /*!< 2.5 V is selected as shared reference voltage input */
N/* CE0CTL2[CEREFACC] Bits */
N#define CEREFACC_OFS                             COMP_E_CTL2_REFACC_OFS          /*!< CEREFACC Offset */
N#define CEREFACC                                 COMP_E_CTL2_REFACC              /*!< Reference accuracy */
N/* CE0CTL3[CEPD0] Bits */
N#define CEPD0_OFS                                COMP_E_CTL3_PD0_OFS             /*!< CEPD0 Offset */
N#define CEPD0                                    COMP_E_CTL3_PD0                 /*!< Port disable */
N/* CE0CTL3[CEPD1] Bits */
N#define CEPD1_OFS                                COMP_E_CTL3_PD1_OFS             /*!< CEPD1 Offset */
N#define CEPD1                                    COMP_E_CTL3_PD1                 /*!< Port disable */
N/* CE0CTL3[CEPD2] Bits */
N#define CEPD2_OFS                                COMP_E_CTL3_PD2_OFS             /*!< CEPD2 Offset */
N#define CEPD2                                    COMP_E_CTL3_PD2                 /*!< Port disable */
N/* CE0CTL3[CEPD3] Bits */
N#define CEPD3_OFS                                COMP_E_CTL3_PD3_OFS             /*!< CEPD3 Offset */
N#define CEPD3                                    COMP_E_CTL3_PD3                 /*!< Port disable */
N/* CE0CTL3[CEPD4] Bits */
N#define CEPD4_OFS                                COMP_E_CTL3_PD4_OFS             /*!< CEPD4 Offset */
N#define CEPD4                                    COMP_E_CTL3_PD4                 /*!< Port disable */
N/* CE0CTL3[CEPD5] Bits */
N#define CEPD5_OFS                                COMP_E_CTL3_PD5_OFS             /*!< CEPD5 Offset */
N#define CEPD5                                    COMP_E_CTL3_PD5                 /*!< Port disable */
N/* CE0CTL3[CEPD6] Bits */
N#define CEPD6_OFS                                COMP_E_CTL3_PD6_OFS             /*!< CEPD6 Offset */
N#define CEPD6                                    COMP_E_CTL3_PD6                 /*!< Port disable */
N/* CE0CTL3[CEPD7] Bits */
N#define CEPD7_OFS                                COMP_E_CTL3_PD7_OFS             /*!< CEPD7 Offset */
N#define CEPD7                                    COMP_E_CTL3_PD7                 /*!< Port disable */
N/* CE0CTL3[CEPD8] Bits */
N#define CEPD8_OFS                                COMP_E_CTL3_PD8_OFS             /*!< CEPD8 Offset */
N#define CEPD8                                    COMP_E_CTL3_PD8                 /*!< Port disable */
N/* CE0CTL3[CEPD9] Bits */
N#define CEPD9_OFS                                COMP_E_CTL3_PD9_OFS             /*!< CEPD9 Offset */
N#define CEPD9                                    COMP_E_CTL3_PD9                 /*!< Port disable */
N/* CE0CTL3[CEPD10] Bits */
N#define CEPD10_OFS                               COMP_E_CTL3_PD10_OFS            /*!< CEPD10 Offset */
N#define CEPD10                                   COMP_E_CTL3_PD10                /*!< Port disable */
N/* CE0CTL3[CEPD11] Bits */
N#define CEPD11_OFS                               COMP_E_CTL3_PD11_OFS            /*!< CEPD11 Offset */
N#define CEPD11                                   COMP_E_CTL3_PD11                /*!< Port disable */
N/* CE0CTL3[CEPD12] Bits */
N#define CEPD12_OFS                               COMP_E_CTL3_PD12_OFS            /*!< CEPD12 Offset */
N#define CEPD12                                   COMP_E_CTL3_PD12                /*!< Port disable */
N/* CE0CTL3[CEPD13] Bits */
N#define CEPD13_OFS                               COMP_E_CTL3_PD13_OFS            /*!< CEPD13 Offset */
N#define CEPD13                                   COMP_E_CTL3_PD13                /*!< Port disable */
N/* CE0CTL3[CEPD14] Bits */
N#define CEPD14_OFS                               COMP_E_CTL3_PD14_OFS            /*!< CEPD14 Offset */
N#define CEPD14                                   COMP_E_CTL3_PD14                /*!< Port disable */
N/* CE0CTL3[CEPD15] Bits */
N#define CEPD15_OFS                               COMP_E_CTL3_PD15_OFS            /*!< CEPD15 Offset */
N#define CEPD15                                   COMP_E_CTL3_PD15                /*!< Port disable */
N/* CE0INT[CEIFG] Bits */
N#define CEIFG_OFS                                COMP_E_INT_IFG_OFS              /*!< CEIFG Offset */
N#define CEIFG                                    COMP_E_INT_IFG                  /*!< Comparator output interrupt flag */
N/* CE0INT[CEIIFG] Bits */
N#define CEIIFG_OFS                               COMP_E_INT_IIFG_OFS             /*!< CEIIFG Offset */
N#define CEIIFG                                   COMP_E_INT_IIFG                 /*!< Comparator output inverted interrupt flag */
N/* CE0INT[CERDYIFG] Bits */
N#define CERDYIFG_OFS                             COMP_E_INT_RDYIFG_OFS           /*!< CERDYIFG Offset */
N#define CERDYIFG                                 COMP_E_INT_RDYIFG               /*!< Comparator ready interrupt flag */
N/* CE0INT[CEIE] Bits */
N#define CEIE_OFS                                 COMP_E_INT_IE_OFS               /*!< CEIE Offset */
N#define CEIE                                     COMP_E_INT_IE                   /*!< Comparator output interrupt enable */
N/* CE0INT[CEIIE] Bits */
N#define CEIIE_OFS                                COMP_E_INT_IIE_OFS              /*!< CEIIE Offset */
N#define CEIIE                                    COMP_E_INT_IIE                  /*!< Comparator output interrupt enable inverted polarity */
N/* CE0INT[CERDYIE] Bits */
N#define CERDYIE_OFS                              COMP_E_INT_RDYIE_OFS            /*!< CERDYIE Offset */
N#define CERDYIE                                  COMP_E_INT_RDYIE                /*!< Comparator ready interrupt enable */
N
N/******************************************************************************
N* CRC32 Bits (legacy section)
N******************************************************************************/
N/* DIO_PAIN[P1IN] Bits */
N#define P1IN_OFS                                           ( 0)                  /*!< P1IN Offset */
N#define P1IN_M                                             (0x00ff)              /*!< Port 1 Input */
N/* DIO_PAIN[P2IN] Bits */
N#define P2IN_OFS                                           ( 8)                  /*!< P2IN Offset */
N#define P2IN_M                                             (0xff00)              /*!< Port 2 Input */
N/* DIO_PAOUT[P2OUT] Bits */
N#define P2OUT_OFS                                          ( 8)                  /*!< P2OUT Offset */
N#define P2OUT_M                                            (0xff00)              /*!< Port 2 Output */
N/* DIO_PAOUT[P1OUT] Bits */
N#define P1OUT_OFS                                          ( 0)                  /*!< P1OUT Offset */
N#define P1OUT_M                                            (0x00ff)              /*!< Port 1 Output */
N/* DIO_PADIR[P1DIR] Bits */
N#define P1DIR_OFS                                          ( 0)                  /*!< P1DIR Offset */
N#define P1DIR_M                                            (0x00ff)              /*!< Port 1 Direction */
N/* DIO_PADIR[P2DIR] Bits */
N#define P2DIR_OFS                                          ( 8)                  /*!< P2DIR Offset */
N#define P2DIR_M                                            (0xff00)              /*!< Port 2 Direction */
N/* DIO_PAREN[P1REN] Bits */
N#define P1REN_OFS                                          ( 0)                  /*!< P1REN Offset */
N#define P1REN_M                                            (0x00ff)              /*!< Port 1 Resistor Enable */
N/* DIO_PAREN[P2REN] Bits */
N#define P2REN_OFS                                          ( 8)                  /*!< P2REN Offset */
N#define P2REN_M                                            (0xff00)              /*!< Port 2 Resistor Enable */
N/* DIO_PADS[P1DS] Bits */
N#define P1DS_OFS                                           ( 0)                  /*!< P1DS Offset */
N#define P1DS_M                                             (0x00ff)              /*!< Port 1 Drive Strength */
N/* DIO_PADS[P2DS] Bits */
N#define P2DS_OFS                                           ( 8)                  /*!< P2DS Offset */
N#define P2DS_M                                             (0xff00)              /*!< Port 2 Drive Strength */
N/* DIO_PASEL0[P1SEL0] Bits */
N#define P1SEL0_OFS                                         ( 0)                  /*!< P1SEL0 Offset */
N#define P1SEL0_M                                           (0x00ff)              /*!< Port 1 Select 0 */
N/* DIO_PASEL0[P2SEL0] Bits */
N#define P2SEL0_OFS                                         ( 8)                  /*!< P2SEL0 Offset */
N#define P2SEL0_M                                           (0xff00)              /*!< Port 2 Select 0 */
N/* DIO_PASEL1[P1SEL1] Bits */
N#define P1SEL1_OFS                                         ( 0)                  /*!< P1SEL1 Offset */
N#define P1SEL1_M                                           (0x00ff)              /*!< Port 1 Select 1 */
N/* DIO_PASEL1[P2SEL1] Bits */
N#define P2SEL1_OFS                                         ( 8)                  /*!< P2SEL1 Offset */
N#define P2SEL1_M                                           (0xff00)              /*!< Port 2 Select 1 */
N/* DIO_P1IV[P1IV] Bits */
N#define P1IV_OFS                                           ( 0)                  /*!< P1IV Offset */
N#define P1IV_M                                             (0x001f)              /*!< Port 1 interrupt vector value */
N#define P1IV0                                              (0x0001)              /*!< Port 1 interrupt vector value */
N#define P1IV1                                              (0x0002)              /*!< Port 1 interrupt vector value */
N#define P1IV2                                              (0x0004)              /*!< Port 1 interrupt vector value */
N#define P1IV3                                              (0x0008)              /*!< Port 1 interrupt vector value */
N#define P1IV4                                              (0x0010)              /*!< Port 1 interrupt vector value */
N#define P1IV_0                                             (0x0000)              /*!< No interrupt pending */
N#define P1IV_2                                             (0x0002)              /*!< Interrupt Source: Port 1.0 interrupt; Interrupt Flag: P1IFG0; Interrupt Priority: Highest */
N#define P1IV_4                                             (0x0004)              /*!< Interrupt Source: Port 1.1 interrupt; Interrupt Flag: P1IFG1 */
N#define P1IV_6                                             (0x0006)              /*!< Interrupt Source: Port 1.2 interrupt; Interrupt Flag: P1IFG2 */
N#define P1IV_8                                             (0x0008)              /*!< Interrupt Source: Port 1.3 interrupt; Interrupt Flag: P1IFG3 */
N#define P1IV_10                                            (0x000a)              /*!< Interrupt Source: Port 1.4 interrupt; Interrupt Flag: P1IFG4 */
N#define P1IV_12                                            (0x000c)              /*!< Interrupt Source: Port 1.5 interrupt; Interrupt Flag: P1IFG5 */
N#define P1IV_14                                            (0x000e)              /*!< Interrupt Source: Port 1.6 interrupt; Interrupt Flag: P1IFG6 */
N#define P1IV_16                                            (0x0010)              /*!< Interrupt Source: Port 1.7 interrupt; Interrupt Flag: P1IFG7; Interrupt Priority: Lowest */
N#define P1IV__NONE                                         (0x0000)              /*!< No interrupt pending */
N#define P1IV__P1IFG0                                       (0x0002)              /*!< Interrupt Source: Port 1.0 interrupt; Interrupt Flag: P1IFG0; Interrupt Priority: Highest */
N#define P1IV__P1IFG1                                       (0x0004)              /*!< Interrupt Source: Port 1.1 interrupt; Interrupt Flag: P1IFG1 */
N#define P1IV__P1IFG2                                       (0x0006)              /*!< Interrupt Source: Port 1.2 interrupt; Interrupt Flag: P1IFG2 */
N#define P1IV__P1IFG3                                       (0x0008)              /*!< Interrupt Source: Port 1.3 interrupt; Interrupt Flag: P1IFG3 */
N#define P1IV__P1IFG4                                       (0x000a)              /*!< Interrupt Source: Port 1.4 interrupt; Interrupt Flag: P1IFG4 */
N#define P1IV__P1IFG5                                       (0x000c)              /*!< Interrupt Source: Port 1.5 interrupt; Interrupt Flag: P1IFG5 */
N#define P1IV__P1IFG6                                       (0x000e)              /*!< Interrupt Source: Port 1.6 interrupt; Interrupt Flag: P1IFG6 */
N#define P1IV__P1IFG7                                       (0x0010)              /*!< Interrupt Source: Port 1.7 interrupt; Interrupt Flag: P1IFG7; Interrupt Priority: Lowest */
N/* DIO_PASELC[P1SELC] Bits */
N#define P1SELC_OFS                                         ( 0)                  /*!< P1SELC Offset */
N#define P1SELC_M                                           (0x00ff)              /*!< Port 1 Complement Select */
N/* DIO_PASELC[P2SELC] Bits */
N#define P2SELC_OFS                                         ( 8)                  /*!< P2SELC Offset */
N#define P2SELC_M                                           (0xff00)              /*!< Port 2 Complement Select */
N/* DIO_PAIES[P1IES] Bits */
N#define P1IES_OFS                                          ( 0)                  /*!< P1IES Offset */
N#define P1IES_M                                            (0x00ff)              /*!< Port 1 Interrupt Edge Select */
N/* DIO_PAIES[P2IES] Bits */
N#define P2IES_OFS                                          ( 8)                  /*!< P2IES Offset */
N#define P2IES_M                                            (0xff00)              /*!< Port 2 Interrupt Edge Select */
N/* DIO_PAIE[P1IE] Bits */
N#define P1IE_OFS                                           ( 0)                  /*!< P1IE Offset */
N#define P1IE_M                                             (0x00ff)              /*!< Port 1 Interrupt Enable */
N/* DIO_PAIE[P2IE] Bits */
N#define P2IE_OFS                                           ( 8)                  /*!< P2IE Offset */
N#define P2IE_M                                             (0xff00)              /*!< Port 2 Interrupt Enable */
N/* DIO_PAIFG[P1IFG] Bits */
N#define P1IFG_OFS                                          ( 0)                  /*!< P1IFG Offset */
N#define P1IFG_M                                            (0x00ff)              /*!< Port 1 Interrupt Flag */
N/* DIO_PAIFG[P2IFG] Bits */
N#define P2IFG_OFS                                          ( 8)                  /*!< P2IFG Offset */
N#define P2IFG_M                                            (0xff00)              /*!< Port 2 Interrupt Flag */
N/* DIO_P2IV[P2IV] Bits */
N#define P2IV_OFS                                           ( 0)                  /*!< P2IV Offset */
N#define P2IV_M                                             (0x001f)              /*!< Port 2 interrupt vector value */
N#define P2IV0                                              (0x0001)              /*!< Port 2 interrupt vector value */
N#define P2IV1                                              (0x0002)              /*!< Port 2 interrupt vector value */
N#define P2IV2                                              (0x0004)              /*!< Port 2 interrupt vector value */
N#define P2IV3                                              (0x0008)              /*!< Port 2 interrupt vector value */
N#define P2IV4                                              (0x0010)              /*!< Port 2 interrupt vector value */
N#define P2IV_0                                             (0x0000)              /*!< No interrupt pending */
N#define P2IV_2                                             (0x0002)              /*!< Interrupt Source: Port 2.0 interrupt; Interrupt Flag: P2IFG0; Interrupt Priority: Highest */
N#define P2IV_4                                             (0x0004)              /*!< Interrupt Source: Port 2.1 interrupt; Interrupt Flag: P2IFG1 */
N#define P2IV_6                                             (0x0006)              /*!< Interrupt Source: Port 2.2 interrupt; Interrupt Flag: P2IFG2 */
N#define P2IV_8                                             (0x0008)              /*!< Interrupt Source: Port 2.3 interrupt; Interrupt Flag: P2IFG3 */
N#define P2IV_10                                            (0x000a)              /*!< Interrupt Source: Port 2.4 interrupt; Interrupt Flag: P2IFG4 */
N#define P2IV_12                                            (0x000c)              /*!< Interrupt Source: Port 2.5 interrupt; Interrupt Flag: P2IFG5 */
N#define P2IV_14                                            (0x000e)              /*!< Interrupt Source: Port 2.6 interrupt; Interrupt Flag: P2IFG6 */
N#define P2IV_16                                            (0x0010)              /*!< Interrupt Source: Port 2.7 interrupt; Interrupt Flag: P2IFG7; Interrupt Priority: Lowest */
N#define P2IV__NONE                                         (0x0000)              /*!< No interrupt pending */
N#define P2IV__P2IFG0                                       (0x0002)              /*!< Interrupt Source: Port 2.0 interrupt; Interrupt Flag: P2IFG0; Interrupt Priority: Highest */
N#define P2IV__P2IFG1                                       (0x0004)              /*!< Interrupt Source: Port 2.1 interrupt; Interrupt Flag: P2IFG1 */
N#define P2IV__P2IFG2                                       (0x0006)              /*!< Interrupt Source: Port 2.2 interrupt; Interrupt Flag: P2IFG2 */
N#define P2IV__P2IFG3                                       (0x0008)              /*!< Interrupt Source: Port 2.3 interrupt; Interrupt Flag: P2IFG3 */
N#define P2IV__P2IFG4                                       (0x000a)              /*!< Interrupt Source: Port 2.4 interrupt; Interrupt Flag: P2IFG4 */
N#define P2IV__P2IFG5                                       (0x000c)              /*!< Interrupt Source: Port 2.5 interrupt; Interrupt Flag: P2IFG5 */
N#define P2IV__P2IFG6                                       (0x000e)              /*!< Interrupt Source: Port 2.6 interrupt; Interrupt Flag: P2IFG6 */
N#define P2IV__P2IFG7                                       (0x0010)              /*!< Interrupt Source: Port 2.7 interrupt; Interrupt Flag: P2IFG7; Interrupt Priority: Lowest */
N/* DIO_PBIN[P3IN] Bits */
N#define P3IN_OFS                                           ( 0)                  /*!< P3IN Offset */
N#define P3IN_M                                             (0x00ff)              /*!< Port 3 Input */
N/* DIO_PBIN[P4IN] Bits */
N#define P4IN_OFS                                           ( 8)                  /*!< P4IN Offset */
N#define P4IN_M                                             (0xff00)              /*!< Port 4 Input */
N/* DIO_PBOUT[P3OUT] Bits */
N#define P3OUT_OFS                                          ( 0)                  /*!< P3OUT Offset */
N#define P3OUT_M                                            (0x00ff)              /*!< Port 3 Output */
N/* DIO_PBOUT[P4OUT] Bits */
N#define P4OUT_OFS                                          ( 8)                  /*!< P4OUT Offset */
N#define P4OUT_M                                            (0xff00)              /*!< Port 4 Output */
N/* DIO_PBDIR[P3DIR] Bits */
N#define P3DIR_OFS                                          ( 0)                  /*!< P3DIR Offset */
N#define P3DIR_M                                            (0x00ff)              /*!< Port 3 Direction */
N/* DIO_PBDIR[P4DIR] Bits */
N#define P4DIR_OFS                                          ( 8)                  /*!< P4DIR Offset */
N#define P4DIR_M                                            (0xff00)              /*!< Port 4 Direction */
N/* DIO_PBREN[P3REN] Bits */
N#define P3REN_OFS                                          ( 0)                  /*!< P3REN Offset */
N#define P3REN_M                                            (0x00ff)              /*!< Port 3 Resistor Enable */
N/* DIO_PBREN[P4REN] Bits */
N#define P4REN_OFS                                          ( 8)                  /*!< P4REN Offset */
N#define P4REN_M                                            (0xff00)              /*!< Port 4 Resistor Enable */
N/* DIO_PBDS[P3DS] Bits */
N#define P3DS_OFS                                           ( 0)                  /*!< P3DS Offset */
N#define P3DS_M                                             (0x00ff)              /*!< Port 3 Drive Strength */
N/* DIO_PBDS[P4DS] Bits */
N#define P4DS_OFS                                           ( 8)                  /*!< P4DS Offset */
N#define P4DS_M                                             (0xff00)              /*!< Port 4 Drive Strength */
N/* DIO_PBSEL0[P4SEL0] Bits */
N#define P4SEL0_OFS                                         ( 8)                  /*!< P4SEL0 Offset */
N#define P4SEL0_M                                           (0xff00)              /*!< Port 4 Select 0 */
N/* DIO_PBSEL0[P3SEL0] Bits */
N#define P3SEL0_OFS                                         ( 0)                  /*!< P3SEL0 Offset */
N#define P3SEL0_M                                           (0x00ff)              /*!< Port 3 Select 0 */
N/* DIO_PBSEL1[P3SEL1] Bits */
N#define P3SEL1_OFS                                         ( 0)                  /*!< P3SEL1 Offset */
N#define P3SEL1_M                                           (0x00ff)              /*!< Port 3 Select 1 */
N/* DIO_PBSEL1[P4SEL1] Bits */
N#define P4SEL1_OFS                                         ( 8)                  /*!< P4SEL1 Offset */
N#define P4SEL1_M                                           (0xff00)              /*!< Port 4 Select 1 */
N/* DIO_P3IV[P3IV] Bits */
N#define P3IV_OFS                                           ( 0)                  /*!< P3IV Offset */
N#define P3IV_M                                             (0x001f)              /*!< Port 3 interrupt vector value */
N#define P3IV0                                              (0x0001)              /*!< Port 3 interrupt vector value */
N#define P3IV1                                              (0x0002)              /*!< Port 3 interrupt vector value */
N#define P3IV2                                              (0x0004)              /*!< Port 3 interrupt vector value */
N#define P3IV3                                              (0x0008)              /*!< Port 3 interrupt vector value */
N#define P3IV4                                              (0x0010)              /*!< Port 3 interrupt vector value */
N#define P3IV_0                                             (0x0000)              /*!< No interrupt pending */
N#define P3IV_2                                             (0x0002)              /*!< Interrupt Source: Port 3.0 interrupt; Interrupt Flag: P3IFG0; Interrupt Priority: Highest */
N#define P3IV_4                                             (0x0004)              /*!< Interrupt Source: Port 3.1 interrupt; Interrupt Flag: P3IFG1 */
N#define P3IV_6                                             (0x0006)              /*!< Interrupt Source: Port 3.2 interrupt; Interrupt Flag: P3IFG2 */
N#define P3IV_8                                             (0x0008)              /*!< Interrupt Source: Port 3.3 interrupt; Interrupt Flag: P3IFG3 */
N#define P3IV_10                                            (0x000a)              /*!< Interrupt Source: Port 3.4 interrupt; Interrupt Flag: P3IFG4 */
N#define P3IV_12                                            (0x000c)              /*!< Interrupt Source: Port 3.5 interrupt; Interrupt Flag: P3IFG5 */
N#define P3IV_14                                            (0x000e)              /*!< Interrupt Source: Port 3.6 interrupt; Interrupt Flag: P3IFG6 */
N#define P3IV_16                                            (0x0010)              /*!< Interrupt Source: Port 3.7 interrupt; Interrupt Flag: P3IFG7; Interrupt Priority: Lowest */
N#define P3IV__NONE                                         (0x0000)              /*!< No interrupt pending */
N#define P3IV__P3IFG0                                       (0x0002)              /*!< Interrupt Source: Port 3.0 interrupt; Interrupt Flag: P3IFG0; Interrupt Priority: Highest */
N#define P3IV__P3IFG1                                       (0x0004)              /*!< Interrupt Source: Port 3.1 interrupt; Interrupt Flag: P3IFG1 */
N#define P3IV__P3IFG2                                       (0x0006)              /*!< Interrupt Source: Port 3.2 interrupt; Interrupt Flag: P3IFG2 */
N#define P3IV__P3IFG3                                       (0x0008)              /*!< Interrupt Source: Port 3.3 interrupt; Interrupt Flag: P3IFG3 */
N#define P3IV__P3IFG4                                       (0x000a)              /*!< Interrupt Source: Port 3.4 interrupt; Interrupt Flag: P3IFG4 */
N#define P3IV__P3IFG5                                       (0x000c)              /*!< Interrupt Source: Port 3.5 interrupt; Interrupt Flag: P3IFG5 */
N#define P3IV__P3IFG6                                       (0x000e)              /*!< Interrupt Source: Port 3.6 interrupt; Interrupt Flag: P3IFG6 */
N#define P3IV__P3IFG7                                       (0x0010)              /*!< Interrupt Source: Port 3.7 interrupt; Interrupt Flag: P3IFG7; Interrupt Priority: Lowest */
N/* DIO_PBSELC[P3SELC] Bits */
N#define P3SELC_OFS                                         ( 0)                  /*!< P3SELC Offset */
N#define P3SELC_M                                           (0x00ff)              /*!< Port 3 Complement Select */
N/* DIO_PBSELC[P4SELC] Bits */
N#define P4SELC_OFS                                         ( 8)                  /*!< P4SELC Offset */
N#define P4SELC_M                                           (0xff00)              /*!< Port 4 Complement Select */
N/* DIO_PBIES[P3IES] Bits */
N#define P3IES_OFS                                          ( 0)                  /*!< P3IES Offset */
N#define P3IES_M                                            (0x00ff)              /*!< Port 3 Interrupt Edge Select */
N/* DIO_PBIES[P4IES] Bits */
N#define P4IES_OFS                                          ( 8)                  /*!< P4IES Offset */
N#define P4IES_M                                            (0xff00)              /*!< Port 4 Interrupt Edge Select */
N/* DIO_PBIE[P3IE] Bits */
N#define P3IE_OFS                                           ( 0)                  /*!< P3IE Offset */
N#define P3IE_M                                             (0x00ff)              /*!< Port 3 Interrupt Enable */
N/* DIO_PBIE[P4IE] Bits */
N#define P4IE_OFS                                           ( 8)                  /*!< P4IE Offset */
N#define P4IE_M                                             (0xff00)              /*!< Port 4 Interrupt Enable */
N/* DIO_PBIFG[P3IFG] Bits */
N#define P3IFG_OFS                                          ( 0)                  /*!< P3IFG Offset */
N#define P3IFG_M                                            (0x00ff)              /*!< Port 3 Interrupt Flag */
N/* DIO_PBIFG[P4IFG] Bits */
N#define P4IFG_OFS                                          ( 8)                  /*!< P4IFG Offset */
N#define P4IFG_M                                            (0xff00)              /*!< Port 4 Interrupt Flag */
N/* DIO_P4IV[P4IV] Bits */
N#define P4IV_OFS                                           ( 0)                  /*!< P4IV Offset */
N#define P4IV_M                                             (0x001f)              /*!< Port 4 interrupt vector value */
N#define P4IV0                                              (0x0001)              /*!< Port 4 interrupt vector value */
N#define P4IV1                                              (0x0002)              /*!< Port 4 interrupt vector value */
N#define P4IV2                                              (0x0004)              /*!< Port 4 interrupt vector value */
N#define P4IV3                                              (0x0008)              /*!< Port 4 interrupt vector value */
N#define P4IV4                                              (0x0010)              /*!< Port 4 interrupt vector value */
N#define P4IV_0                                             (0x0000)              /*!< No interrupt pending */
N#define P4IV_2                                             (0x0002)              /*!< Interrupt Source: Port 4.0 interrupt; Interrupt Flag: P4IFG0; Interrupt Priority: Highest */
N#define P4IV_4                                             (0x0004)              /*!< Interrupt Source: Port 4.1 interrupt; Interrupt Flag: P4IFG1 */
N#define P4IV_6                                             (0x0006)              /*!< Interrupt Source: Port 4.2 interrupt; Interrupt Flag: P4IFG2 */
N#define P4IV_8                                             (0x0008)              /*!< Interrupt Source: Port 4.3 interrupt; Interrupt Flag: P4IFG3 */
N#define P4IV_10                                            (0x000a)              /*!< Interrupt Source: Port 4.4 interrupt; Interrupt Flag: P4IFG4 */
N#define P4IV_12                                            (0x000c)              /*!< Interrupt Source: Port 4.5 interrupt; Interrupt Flag: P4IFG5 */
N#define P4IV_14                                            (0x000e)              /*!< Interrupt Source: Port 4.6 interrupt; Interrupt Flag: P4IFG6 */
N#define P4IV_16                                            (0x0010)              /*!< Interrupt Source: Port 4.7 interrupt; Interrupt Flag: P4IFG7; Interrupt Priority: Lowest */
N#define P4IV__NONE                                         (0x0000)              /*!< No interrupt pending */
N#define P4IV__P4IFG0                                       (0x0002)              /*!< Interrupt Source: Port 4.0 interrupt; Interrupt Flag: P4IFG0; Interrupt Priority: Highest */
N#define P4IV__P4IFG1                                       (0x0004)              /*!< Interrupt Source: Port 4.1 interrupt; Interrupt Flag: P4IFG1 */
N#define P4IV__P4IFG2                                       (0x0006)              /*!< Interrupt Source: Port 4.2 interrupt; Interrupt Flag: P4IFG2 */
N#define P4IV__P4IFG3                                       (0x0008)              /*!< Interrupt Source: Port 4.3 interrupt; Interrupt Flag: P4IFG3 */
N#define P4IV__P4IFG4                                       (0x000a)              /*!< Interrupt Source: Port 4.4 interrupt; Interrupt Flag: P4IFG4 */
N#define P4IV__P4IFG5                                       (0x000c)              /*!< Interrupt Source: Port 4.5 interrupt; Interrupt Flag: P4IFG5 */
N#define P4IV__P4IFG6                                       (0x000e)              /*!< Interrupt Source: Port 4.6 interrupt; Interrupt Flag: P4IFG6 */
N#define P4IV__P4IFG7                                       (0x0010)              /*!< Interrupt Source: Port 4.7 interrupt; Interrupt Flag: P4IFG7; Interrupt Priority: Lowest */
N/* DIO_PCIN[P5IN] Bits */
N#define P5IN_OFS                                           ( 0)                  /*!< P5IN Offset */
N#define P5IN_M                                             (0x00ff)              /*!< Port 5 Input */
N/* DIO_PCIN[P6IN] Bits */
N#define P6IN_OFS                                           ( 8)                  /*!< P6IN Offset */
N#define P6IN_M                                             (0xff00)              /*!< Port 6 Input */
N/* DIO_PCOUT[P5OUT] Bits */
N#define P5OUT_OFS                                          ( 0)                  /*!< P5OUT Offset */
N#define P5OUT_M                                            (0x00ff)              /*!< Port 5 Output */
N/* DIO_PCOUT[P6OUT] Bits */
N#define P6OUT_OFS                                          ( 8)                  /*!< P6OUT Offset */
N#define P6OUT_M                                            (0xff00)              /*!< Port 6 Output */
N/* DIO_PCDIR[P5DIR] Bits */
N#define P5DIR_OFS                                          ( 0)                  /*!< P5DIR Offset */
N#define P5DIR_M                                            (0x00ff)              /*!< Port 5 Direction */
N/* DIO_PCDIR[P6DIR] Bits */
N#define P6DIR_OFS                                          ( 8)                  /*!< P6DIR Offset */
N#define P6DIR_M                                            (0xff00)              /*!< Port 6 Direction */
N/* DIO_PCREN[P5REN] Bits */
N#define P5REN_OFS                                          ( 0)                  /*!< P5REN Offset */
N#define P5REN_M                                            (0x00ff)              /*!< Port 5 Resistor Enable */
N/* DIO_PCREN[P6REN] Bits */
N#define P6REN_OFS                                          ( 8)                  /*!< P6REN Offset */
N#define P6REN_M                                            (0xff00)              /*!< Port 6 Resistor Enable */
N/* DIO_PCDS[P5DS] Bits */
N#define P5DS_OFS                                           ( 0)                  /*!< P5DS Offset */
N#define P5DS_M                                             (0x00ff)              /*!< Port 5 Drive Strength */
N/* DIO_PCDS[P6DS] Bits */
N#define P6DS_OFS                                           ( 8)                  /*!< P6DS Offset */
N#define P6DS_M                                             (0xff00)              /*!< Port 6 Drive Strength */
N/* DIO_PCSEL0[P5SEL0] Bits */
N#define P5SEL0_OFS                                         ( 0)                  /*!< P5SEL0 Offset */
N#define P5SEL0_M                                           (0x00ff)              /*!< Port 5 Select 0 */
N/* DIO_PCSEL0[P6SEL0] Bits */
N#define P6SEL0_OFS                                         ( 8)                  /*!< P6SEL0 Offset */
N#define P6SEL0_M                                           (0xff00)              /*!< Port 6 Select 0 */
N/* DIO_PCSEL1[P5SEL1] Bits */
N#define P5SEL1_OFS                                         ( 0)                  /*!< P5SEL1 Offset */
N#define P5SEL1_M                                           (0x00ff)              /*!< Port 5 Select 1 */
N/* DIO_PCSEL1[P6SEL1] Bits */
N#define P6SEL1_OFS                                         ( 8)                  /*!< P6SEL1 Offset */
N#define P6SEL1_M                                           (0xff00)              /*!< Port 6 Select 1 */
N/* DIO_P5IV[P5IV] Bits */
N#define P5IV_OFS                                           ( 0)                  /*!< P5IV Offset */
N#define P5IV_M                                             (0x001f)              /*!< Port 5 interrupt vector value */
N#define P5IV0                                              (0x0001)              /*!< Port 5 interrupt vector value */
N#define P5IV1                                              (0x0002)              /*!< Port 5 interrupt vector value */
N#define P5IV2                                              (0x0004)              /*!< Port 5 interrupt vector value */
N#define P5IV3                                              (0x0008)              /*!< Port 5 interrupt vector value */
N#define P5IV4                                              (0x0010)              /*!< Port 5 interrupt vector value */
N#define P5IV_0                                             (0x0000)              /*!< No interrupt pending */
N#define P5IV_2                                             (0x0002)              /*!< Interrupt Source: Port 5.0 interrupt; Interrupt Flag: P5IFG0; Interrupt Priority: Highest */
N#define P5IV_4                                             (0x0004)              /*!< Interrupt Source: Port 5.1 interrupt; Interrupt Flag: P5IFG1 */
N#define P5IV_6                                             (0x0006)              /*!< Interrupt Source: Port 5.2 interrupt; Interrupt Flag: P5IFG2 */
N#define P5IV_8                                             (0x0008)              /*!< Interrupt Source: Port 5.3 interrupt; Interrupt Flag: P5IFG3 */
N#define P5IV_10                                            (0x000a)              /*!< Interrupt Source: Port 5.4 interrupt; Interrupt Flag: P5IFG4 */
N#define P5IV_12                                            (0x000c)              /*!< Interrupt Source: Port 5.5 interrupt; Interrupt Flag: P5IFG5 */
N#define P5IV_14                                            (0x000e)              /*!< Interrupt Source: Port 5.6 interrupt; Interrupt Flag: P5IFG6 */
N#define P5IV_16                                            (0x0010)              /*!< Interrupt Source: Port 5.7 interrupt; Interrupt Flag: P5IFG7; Interrupt Priority: Lowest */
N#define P5IV__NONE                                         (0x0000)              /*!< No interrupt pending */
N#define P5IV__P5IFG0                                       (0x0002)              /*!< Interrupt Source: Port 5.0 interrupt; Interrupt Flag: P5IFG0; Interrupt Priority: Highest */
N#define P5IV__P5IFG1                                       (0x0004)              /*!< Interrupt Source: Port 5.1 interrupt; Interrupt Flag: P5IFG1 */
N#define P5IV__P5IFG2                                       (0x0006)              /*!< Interrupt Source: Port 5.2 interrupt; Interrupt Flag: P5IFG2 */
N#define P5IV__P5IFG3                                       (0x0008)              /*!< Interrupt Source: Port 5.3 interrupt; Interrupt Flag: P5IFG3 */
N#define P5IV__P5IFG4                                       (0x000a)              /*!< Interrupt Source: Port 5.4 interrupt; Interrupt Flag: P5IFG4 */
N#define P5IV__P5IFG5                                       (0x000c)              /*!< Interrupt Source: Port 5.5 interrupt; Interrupt Flag: P5IFG5 */
N#define P5IV__P5IFG6                                       (0x000e)              /*!< Interrupt Source: Port 5.6 interrupt; Interrupt Flag: P5IFG6 */
N#define P5IV__P5IFG7                                       (0x0010)              /*!< Interrupt Source: Port 5.7 interrupt; Interrupt Flag: P5IFG7; Interrupt Priority: Lowest */
N/* DIO_PCSELC[P5SELC] Bits */
N#define P5SELC_OFS                                         ( 0)                  /*!< P5SELC Offset */
N#define P5SELC_M                                           (0x00ff)              /*!< Port 5 Complement Select */
N/* DIO_PCSELC[P6SELC] Bits */
N#define P6SELC_OFS                                         ( 8)                  /*!< P6SELC Offset */
N#define P6SELC_M                                           (0xff00)              /*!< Port 6 Complement Select */
N/* DIO_PCIES[P5IES] Bits */
N#define P5IES_OFS                                          ( 0)                  /*!< P5IES Offset */
N#define P5IES_M                                            (0x00ff)              /*!< Port 5 Interrupt Edge Select */
N/* DIO_PCIES[P6IES] Bits */
N#define P6IES_OFS                                          ( 8)                  /*!< P6IES Offset */
N#define P6IES_M                                            (0xff00)              /*!< Port 6 Interrupt Edge Select */
N/* DIO_PCIE[P5IE] Bits */
N#define P5IE_OFS                                           ( 0)                  /*!< P5IE Offset */
N#define P5IE_M                                             (0x00ff)              /*!< Port 5 Interrupt Enable */
N/* DIO_PCIE[P6IE] Bits */
N#define P6IE_OFS                                           ( 8)                  /*!< P6IE Offset */
N#define P6IE_M                                             (0xff00)              /*!< Port 6 Interrupt Enable */
N/* DIO_PCIFG[P5IFG] Bits */
N#define P5IFG_OFS                                          ( 0)                  /*!< P5IFG Offset */
N#define P5IFG_M                                            (0x00ff)              /*!< Port 5 Interrupt Flag */
N/* DIO_PCIFG[P6IFG] Bits */
N#define P6IFG_OFS                                          ( 8)                  /*!< P6IFG Offset */
N#define P6IFG_M                                            (0xff00)              /*!< Port 6 Interrupt Flag */
N/* DIO_P6IV[P6IV] Bits */
N#define P6IV_OFS                                           ( 0)                  /*!< P6IV Offset */
N#define P6IV_M                                             (0x001f)              /*!< Port 6 interrupt vector value */
N#define P6IV0                                              (0x0001)              /*!< Port 6 interrupt vector value */
N#define P6IV1                                              (0x0002)              /*!< Port 6 interrupt vector value */
N#define P6IV2                                              (0x0004)              /*!< Port 6 interrupt vector value */
N#define P6IV3                                              (0x0008)              /*!< Port 6 interrupt vector value */
N#define P6IV4                                              (0x0010)              /*!< Port 6 interrupt vector value */
N#define P6IV_0                                             (0x0000)              /*!< No interrupt pending */
N#define P6IV_2                                             (0x0002)              /*!< Interrupt Source: Port 6.0 interrupt; Interrupt Flag: P6IFG0; Interrupt Priority: Highest */
N#define P6IV_4                                             (0x0004)              /*!< Interrupt Source: Port 6.1 interrupt; Interrupt Flag: P6IFG1 */
N#define P6IV_6                                             (0x0006)              /*!< Interrupt Source: Port 6.2 interrupt; Interrupt Flag: P6IFG2 */
N#define P6IV_8                                             (0x0008)              /*!< Interrupt Source: Port 6.3 interrupt; Interrupt Flag: P6IFG3 */
N#define P6IV_10                                            (0x000a)              /*!< Interrupt Source: Port 6.4 interrupt; Interrupt Flag: P6IFG4 */
N#define P6IV_12                                            (0x000c)              /*!< Interrupt Source: Port 6.5 interrupt; Interrupt Flag: P6IFG5 */
N#define P6IV_14                                            (0x000e)              /*!< Interrupt Source: Port 6.6 interrupt; Interrupt Flag: P6IFG6 */
N#define P6IV_16                                            (0x0010)              /*!< Interrupt Source: Port 6.7 interrupt; Interrupt Flag: P6IFG7; Interrupt Priority: Lowest */
N#define P6IV__NONE                                         (0x0000)              /*!< No interrupt pending */
N#define P6IV__P6IFG0                                       (0x0002)              /*!< Interrupt Source: Port 6.0 interrupt; Interrupt Flag: P6IFG0; Interrupt Priority: Highest */
N#define P6IV__P6IFG1                                       (0x0004)              /*!< Interrupt Source: Port 6.1 interrupt; Interrupt Flag: P6IFG1 */
N#define P6IV__P6IFG2                                       (0x0006)              /*!< Interrupt Source: Port 6.2 interrupt; Interrupt Flag: P6IFG2 */
N#define P6IV__P6IFG3                                       (0x0008)              /*!< Interrupt Source: Port 6.3 interrupt; Interrupt Flag: P6IFG3 */
N#define P6IV__P6IFG4                                       (0x000a)              /*!< Interrupt Source: Port 6.4 interrupt; Interrupt Flag: P6IFG4 */
N#define P6IV__P6IFG5                                       (0x000c)              /*!< Interrupt Source: Port 6.5 interrupt; Interrupt Flag: P6IFG5 */
N#define P6IV__P6IFG6                                       (0x000e)              /*!< Interrupt Source: Port 6.6 interrupt; Interrupt Flag: P6IFG6 */
N#define P6IV__P6IFG7                                       (0x0010)              /*!< Interrupt Source: Port 6.7 interrupt; Interrupt Flag: P6IFG7; Interrupt Priority: Lowest */
N/* DIO_PDIN[P7IN] Bits */
N#define P7IN_OFS                                           ( 0)                  /*!< P7IN Offset */
N#define P7IN_M                                             (0x00ff)              /*!< Port 7 Input */
N/* DIO_PDIN[P8IN] Bits */
N#define P8IN_OFS                                           ( 8)                  /*!< P8IN Offset */
N#define P8IN_M                                             (0xff00)              /*!< Port 8 Input */
N/* DIO_PDOUT[P7OUT] Bits */
N#define P7OUT_OFS                                          ( 0)                  /*!< P7OUT Offset */
N#define P7OUT_M                                            (0x00ff)              /*!< Port 7 Output */
N/* DIO_PDOUT[P8OUT] Bits */
N#define P8OUT_OFS                                          ( 8)                  /*!< P8OUT Offset */
N#define P8OUT_M                                            (0xff00)              /*!< Port 8 Output */
N/* DIO_PDDIR[P7DIR] Bits */
N#define P7DIR_OFS                                          ( 0)                  /*!< P7DIR Offset */
N#define P7DIR_M                                            (0x00ff)              /*!< Port 7 Direction */
N/* DIO_PDDIR[P8DIR] Bits */
N#define P8DIR_OFS                                          ( 8)                  /*!< P8DIR Offset */
N#define P8DIR_M                                            (0xff00)              /*!< Port 8 Direction */
N/* DIO_PDREN[P7REN] Bits */
N#define P7REN_OFS                                          ( 0)                  /*!< P7REN Offset */
N#define P7REN_M                                            (0x00ff)              /*!< Port 7 Resistor Enable */
N/* DIO_PDREN[P8REN] Bits */
N#define P8REN_OFS                                          ( 8)                  /*!< P8REN Offset */
N#define P8REN_M                                            (0xff00)              /*!< Port 8 Resistor Enable */
N/* DIO_PDDS[P7DS] Bits */
N#define P7DS_OFS                                           ( 0)                  /*!< P7DS Offset */
N#define P7DS_M                                             (0x00ff)              /*!< Port 7 Drive Strength */
N/* DIO_PDDS[P8DS] Bits */
N#define P8DS_OFS                                           ( 8)                  /*!< P8DS Offset */
N#define P8DS_M                                             (0xff00)              /*!< Port 8 Drive Strength */
N/* DIO_PDSEL0[P7SEL0] Bits */
N#define P7SEL0_OFS                                         ( 0)                  /*!< P7SEL0 Offset */
N#define P7SEL0_M                                           (0x00ff)              /*!< Port 7 Select 0 */
N/* DIO_PDSEL0[P8SEL0] Bits */
N#define P8SEL0_OFS                                         ( 8)                  /*!< P8SEL0 Offset */
N#define P8SEL0_M                                           (0xff00)              /*!< Port 8 Select 0 */
N/* DIO_PDSEL1[P7SEL1] Bits */
N#define P7SEL1_OFS                                         ( 0)                  /*!< P7SEL1 Offset */
N#define P7SEL1_M                                           (0x00ff)              /*!< Port 7 Select 1 */
N/* DIO_PDSEL1[P8SEL1] Bits */
N#define P8SEL1_OFS                                         ( 8)                  /*!< P8SEL1 Offset */
N#define P8SEL1_M                                           (0xff00)              /*!< Port 8 Select 1 */
N/* DIO_P7IV[P7IV] Bits */
N#define P7IV_OFS                                           ( 0)                  /*!< P7IV Offset */
N#define P7IV_M                                             (0x001f)              /*!< Port 7 interrupt vector value */
N#define P7IV0                                              (0x0001)              /*!< Port 7 interrupt vector value */
N#define P7IV1                                              (0x0002)              /*!< Port 7 interrupt vector value */
N#define P7IV2                                              (0x0004)              /*!< Port 7 interrupt vector value */
N#define P7IV3                                              (0x0008)              /*!< Port 7 interrupt vector value */
N#define P7IV4                                              (0x0010)              /*!< Port 7 interrupt vector value */
N#define P7IV_0                                             (0x0000)              /*!< No interrupt pending */
N#define P7IV_2                                             (0x0002)              /*!< Interrupt Source: Port 7.0 interrupt; Interrupt Flag: P7IFG0; Interrupt Priority: Highest */
N#define P7IV_4                                             (0x0004)              /*!< Interrupt Source: Port 7.1 interrupt; Interrupt Flag: P7IFG1 */
N#define P7IV_6                                             (0x0006)              /*!< Interrupt Source: Port 7.2 interrupt; Interrupt Flag: P7IFG2 */
N#define P7IV_8                                             (0x0008)              /*!< Interrupt Source: Port 7.3 interrupt; Interrupt Flag: P7IFG3 */
N#define P7IV_10                                            (0x000a)              /*!< Interrupt Source: Port 7.4 interrupt; Interrupt Flag: P7IFG4 */
N#define P7IV_12                                            (0x000c)              /*!< Interrupt Source: Port 7.5 interrupt; Interrupt Flag: P7IFG5 */
N#define P7IV_14                                            (0x000e)              /*!< Interrupt Source: Port 7.6 interrupt; Interrupt Flag: P7IFG6 */
N#define P7IV_16                                            (0x0010)              /*!< Interrupt Source: Port 7.7 interrupt; Interrupt Flag: P7IFG7; Interrupt Priority: Lowest */
N#define P7IV__NONE                                         (0x0000)              /*!< No interrupt pending */
N#define P7IV__P7IFG0                                       (0x0002)              /*!< Interrupt Source: Port 7.0 interrupt; Interrupt Flag: P7IFG0; Interrupt Priority: Highest */
N#define P7IV__P7IFG1                                       (0x0004)              /*!< Interrupt Source: Port 7.1 interrupt; Interrupt Flag: P7IFG1 */
N#define P7IV__P7IFG2                                       (0x0006)              /*!< Interrupt Source: Port 7.2 interrupt; Interrupt Flag: P7IFG2 */
N#define P7IV__P7IFG3                                       (0x0008)              /*!< Interrupt Source: Port 7.3 interrupt; Interrupt Flag: P7IFG3 */
N#define P7IV__P7IFG4                                       (0x000a)              /*!< Interrupt Source: Port 7.4 interrupt; Interrupt Flag: P7IFG4 */
N#define P7IV__P7IFG5                                       (0x000c)              /*!< Interrupt Source: Port 7.5 interrupt; Interrupt Flag: P7IFG5 */
N#define P7IV__P7IFG6                                       (0x000e)              /*!< Interrupt Source: Port 7.6 interrupt; Interrupt Flag: P7IFG6 */
N#define P7IV__P7IFG7                                       (0x0010)              /*!< Interrupt Source: Port 7.7 interrupt; Interrupt Flag: P7IFG7; Interrupt Priority: Lowest */
N/* DIO_PDSELC[P7SELC] Bits */
N#define P7SELC_OFS                                         ( 0)                  /*!< P7SELC Offset */
N#define P7SELC_M                                           (0x00ff)              /*!< Port 7 Complement Select */
N/* DIO_PDSELC[P8SELC] Bits */
N#define P8SELC_OFS                                         ( 8)                  /*!< P8SELC Offset */
N#define P8SELC_M                                           (0xff00)              /*!< Port 8 Complement Select */
N/* DIO_PDIES[P7IES] Bits */
N#define P7IES_OFS                                          ( 0)                  /*!< P7IES Offset */
N#define P7IES_M                                            (0x00ff)              /*!< Port 7 Interrupt Edge Select */
N/* DIO_PDIES[P8IES] Bits */
N#define P8IES_OFS                                          ( 8)                  /*!< P8IES Offset */
N#define P8IES_M                                            (0xff00)              /*!< Port 8 Interrupt Edge Select */
N/* DIO_PDIE[P7IE] Bits */
N#define P7IE_OFS                                           ( 0)                  /*!< P7IE Offset */
N#define P7IE_M                                             (0x00ff)              /*!< Port 7 Interrupt Enable */
N/* DIO_PDIE[P8IE] Bits */
N#define P8IE_OFS                                           ( 8)                  /*!< P8IE Offset */
N#define P8IE_M                                             (0xff00)              /*!< Port 8 Interrupt Enable */
N/* DIO_PDIFG[P7IFG] Bits */
N#define P7IFG_OFS                                          ( 0)                  /*!< P7IFG Offset */
N#define P7IFG_M                                            (0x00ff)              /*!< Port 7 Interrupt Flag */
N/* DIO_PDIFG[P8IFG] Bits */
N#define P8IFG_OFS                                          ( 8)                  /*!< P8IFG Offset */
N#define P8IFG_M                                            (0xff00)              /*!< Port 8 Interrupt Flag */
N/* DIO_P8IV[P8IV] Bits */
N#define P8IV_OFS                                           ( 0)                  /*!< P8IV Offset */
N#define P8IV_M                                             (0x001f)              /*!< Port 8 interrupt vector value */
N#define P8IV0                                              (0x0001)              /*!< Port 8 interrupt vector value */
N#define P8IV1                                              (0x0002)              /*!< Port 8 interrupt vector value */
N#define P8IV2                                              (0x0004)              /*!< Port 8 interrupt vector value */
N#define P8IV3                                              (0x0008)              /*!< Port 8 interrupt vector value */
N#define P8IV4                                              (0x0010)              /*!< Port 8 interrupt vector value */
N#define P8IV_0                                             (0x0000)              /*!< No interrupt pending */
N#define P8IV_2                                             (0x0002)              /*!< Interrupt Source: Port 8.0 interrupt; Interrupt Flag: P8IFG0; Interrupt Priority: Highest */
N#define P8IV_4                                             (0x0004)              /*!< Interrupt Source: Port 8.1 interrupt; Interrupt Flag: P8IFG1 */
N#define P8IV_6                                             (0x0006)              /*!< Interrupt Source: Port 8.2 interrupt; Interrupt Flag: P8IFG2 */
N#define P8IV_8                                             (0x0008)              /*!< Interrupt Source: Port 8.3 interrupt; Interrupt Flag: P8IFG3 */
N#define P8IV_10                                            (0x000a)              /*!< Interrupt Source: Port 8.4 interrupt; Interrupt Flag: P8IFG4 */
N#define P8IV_12                                            (0x000c)              /*!< Interrupt Source: Port 8.5 interrupt; Interrupt Flag: P8IFG5 */
N#define P8IV_14                                            (0x000e)              /*!< Interrupt Source: Port 8.6 interrupt; Interrupt Flag: P8IFG6 */
N#define P8IV_16                                            (0x0010)              /*!< Interrupt Source: Port 8.7 interrupt; Interrupt Flag: P8IFG7; Interrupt Priority: Lowest */
N#define P8IV__NONE                                         (0x0000)              /*!< No interrupt pending */
N#define P8IV__P8IFG0                                       (0x0002)              /*!< Interrupt Source: Port 8.0 interrupt; Interrupt Flag: P8IFG0; Interrupt Priority: Highest */
N#define P8IV__P8IFG1                                       (0x0004)              /*!< Interrupt Source: Port 8.1 interrupt; Interrupt Flag: P8IFG1 */
N#define P8IV__P8IFG2                                       (0x0006)              /*!< Interrupt Source: Port 8.2 interrupt; Interrupt Flag: P8IFG2 */
N#define P8IV__P8IFG3                                       (0x0008)              /*!< Interrupt Source: Port 8.3 interrupt; Interrupt Flag: P8IFG3 */
N#define P8IV__P8IFG4                                       (0x000a)              /*!< Interrupt Source: Port 8.4 interrupt; Interrupt Flag: P8IFG4 */
N#define P8IV__P8IFG5                                       (0x000c)              /*!< Interrupt Source: Port 8.5 interrupt; Interrupt Flag: P8IFG5 */
N#define P8IV__P8IFG6                                       (0x000e)              /*!< Interrupt Source: Port 8.6 interrupt; Interrupt Flag: P8IFG6 */
N#define P8IV__P8IFG7                                       (0x0010)              /*!< Interrupt Source: Port 8.7 interrupt; Interrupt Flag: P8IFG7; Interrupt Priority: Lowest */
N/* DIO_PEIN[P9IN] Bits */
N#define P9IN_OFS                                           ( 0)                  /*!< P9IN Offset */
N#define P9IN_M                                             (0x00ff)              /*!< Port 9 Input */
N/* DIO_PEIN[P10IN] Bits */
N#define P10IN_OFS                                          ( 8)                  /*!< P10IN Offset */
N#define P10IN_M                                            (0xff00)              /*!< Port 10 Input */
N/* DIO_PEOUT[P9OUT] Bits */
N#define P9OUT_OFS                                          ( 0)                  /*!< P9OUT Offset */
N#define P9OUT_M                                            (0x00ff)              /*!< Port 9 Output */
N/* DIO_PEOUT[P10OUT] Bits */
N#define P10OUT_OFS                                         ( 8)                  /*!< P10OUT Offset */
N#define P10OUT_M                                           (0xff00)              /*!< Port 10 Output */
N/* DIO_PEDIR[P9DIR] Bits */
N#define P9DIR_OFS                                          ( 0)                  /*!< P9DIR Offset */
N#define P9DIR_M                                            (0x00ff)              /*!< Port 9 Direction */
N/* DIO_PEDIR[P10DIR] Bits */
N#define P10DIR_OFS                                         ( 8)                  /*!< P10DIR Offset */
N#define P10DIR_M                                           (0xff00)              /*!< Port 10 Direction */
N/* DIO_PEREN[P9REN] Bits */
N#define P9REN_OFS                                          ( 0)                  /*!< P9REN Offset */
N#define P9REN_M                                            (0x00ff)              /*!< Port 9 Resistor Enable */
N/* DIO_PEREN[P10REN] Bits */
N#define P10REN_OFS                                         ( 8)                  /*!< P10REN Offset */
N#define P10REN_M                                           (0xff00)              /*!< Port 10 Resistor Enable */
N/* DIO_PEDS[P9DS] Bits */
N#define P9DS_OFS                                           ( 0)                  /*!< P9DS Offset */
N#define P9DS_M                                             (0x00ff)              /*!< Port 9 Drive Strength */
N/* DIO_PEDS[P10DS] Bits */
N#define P10DS_OFS                                          ( 8)                  /*!< P10DS Offset */
N#define P10DS_M                                            (0xff00)              /*!< Port 10 Drive Strength */
N/* DIO_PESEL0[P9SEL0] Bits */
N#define P9SEL0_OFS                                         ( 0)                  /*!< P9SEL0 Offset */
N#define P9SEL0_M                                           (0x00ff)              /*!< Port 9 Select 0 */
N/* DIO_PESEL0[P10SEL0] Bits */
N#define P10SEL0_OFS                                        ( 8)                  /*!< P10SEL0 Offset */
N#define P10SEL0_M                                          (0xff00)              /*!< Port 10 Select 0 */
N/* DIO_PESEL1[P9SEL1] Bits */
N#define P9SEL1_OFS                                         ( 0)                  /*!< P9SEL1 Offset */
N#define P9SEL1_M                                           (0x00ff)              /*!< Port 9 Select 1 */
N/* DIO_PESEL1[P10SEL1] Bits */
N#define P10SEL1_OFS                                        ( 8)                  /*!< P10SEL1 Offset */
N#define P10SEL1_M                                          (0xff00)              /*!< Port 10 Select 1 */
N/* DIO_P9IV[P9IV] Bits */
N#define P9IV_OFS                                           ( 0)                  /*!< P9IV Offset */
N#define P9IV_M                                             (0x001f)              /*!< Port 9 interrupt vector value */
N#define P9IV0                                              (0x0001)              /*!< Port 9 interrupt vector value */
N#define P9IV1                                              (0x0002)              /*!< Port 9 interrupt vector value */
N#define P9IV2                                              (0x0004)              /*!< Port 9 interrupt vector value */
N#define P9IV3                                              (0x0008)              /*!< Port 9 interrupt vector value */
N#define P9IV4                                              (0x0010)              /*!< Port 9 interrupt vector value */
N#define P9IV_0                                             (0x0000)              /*!< No interrupt pending */
N#define P9IV_2                                             (0x0002)              /*!< Interrupt Source: Port 9.0 interrupt; Interrupt Flag: P9IFG0; Interrupt Priority: Highest */
N#define P9IV_4                                             (0x0004)              /*!< Interrupt Source: Port 9.1 interrupt; Interrupt Flag: P9IFG1 */
N#define P9IV_6                                             (0x0006)              /*!< Interrupt Source: Port 9.2 interrupt; Interrupt Flag: P9IFG2 */
N#define P9IV_8                                             (0x0008)              /*!< Interrupt Source: Port 9.3 interrupt; Interrupt Flag: P9IFG3 */
N#define P9IV_10                                            (0x000a)              /*!< Interrupt Source: Port 9.4 interrupt; Interrupt Flag: P9IFG4 */
N#define P9IV_12                                            (0x000c)              /*!< Interrupt Source: Port 9.5 interrupt; Interrupt Flag: P9IFG5 */
N#define P9IV_14                                            (0x000e)              /*!< Interrupt Source: Port 9.6 interrupt; Interrupt Flag: P9IFG6 */
N#define P9IV_16                                            (0x0010)              /*!< Interrupt Source: Port 9.7 interrupt; Interrupt Flag: P9IFG7; Interrupt Priority: Lowest */
N#define P9IV__NONE                                         (0x0000)              /*!< No interrupt pending */
N#define P9IV__P9IFG0                                       (0x0002)              /*!< Interrupt Source: Port 9.0 interrupt; Interrupt Flag: P9IFG0; Interrupt Priority: Highest */
N#define P9IV__P9IFG1                                       (0x0004)              /*!< Interrupt Source: Port 9.1 interrupt; Interrupt Flag: P9IFG1 */
N#define P9IV__P9IFG2                                       (0x0006)              /*!< Interrupt Source: Port 9.2 interrupt; Interrupt Flag: P9IFG2 */
N#define P9IV__P9IFG3                                       (0x0008)              /*!< Interrupt Source: Port 9.3 interrupt; Interrupt Flag: P9IFG3 */
N#define P9IV__P9IFG4                                       (0x000a)              /*!< Interrupt Source: Port 9.4 interrupt; Interrupt Flag: P9IFG4 */
N#define P9IV__P9IFG5                                       (0x000c)              /*!< Interrupt Source: Port 9.5 interrupt; Interrupt Flag: P9IFG5 */
N#define P9IV__P9IFG6                                       (0x000e)              /*!< Interrupt Source: Port 9.6 interrupt; Interrupt Flag: P9IFG6 */
N#define P9IV__P9IFG7                                       (0x0010)              /*!< Interrupt Source: Port 9.7 interrupt; Interrupt Flag: P9IFG7; Interrupt Priority: Lowest */
N/* DIO_PESELC[P9SELC] Bits */
N#define P9SELC_OFS                                         ( 0)                  /*!< P9SELC Offset */
N#define P9SELC_M                                           (0x00ff)              /*!< Port 9 Complement Select */
N/* DIO_PESELC[P10SELC] Bits */
N#define P10SELC_OFS                                        ( 8)                  /*!< P10SELC Offset */
N#define P10SELC_M                                          (0xff00)              /*!< Port 10 Complement Select */
N/* DIO_PEIES[P9IES] Bits */
N#define P9IES_OFS                                          ( 0)                  /*!< P9IES Offset */
N#define P9IES_M                                            (0x00ff)              /*!< Port 9 Interrupt Edge Select */
N/* DIO_PEIES[P10IES] Bits */
N#define P10IES_OFS                                         ( 8)                  /*!< P10IES Offset */
N#define P10IES_M                                           (0xff00)              /*!< Port 10 Interrupt Edge Select */
N/* DIO_PEIE[P9IE] Bits */
N#define P9IE_OFS                                           ( 0)                  /*!< P9IE Offset */
N#define P9IE_M                                             (0x00ff)              /*!< Port 9 Interrupt Enable */
N/* DIO_PEIE[P10IE] Bits */
N#define P10IE_OFS                                          ( 8)                  /*!< P10IE Offset */
N#define P10IE_M                                            (0xff00)              /*!< Port 10 Interrupt Enable */
N/* DIO_PEIFG[P9IFG] Bits */
N#define P9IFG_OFS                                          ( 0)                  /*!< P9IFG Offset */
N#define P9IFG_M                                            (0x00ff)              /*!< Port 9 Interrupt Flag */
N/* DIO_PEIFG[P10IFG] Bits */
N#define P10IFG_OFS                                         ( 8)                  /*!< P10IFG Offset */
N#define P10IFG_M                                           (0xff00)              /*!< Port 10 Interrupt Flag */
N/* DIO_P10IV[P10IV] Bits */
N#define P10IV_OFS                                          ( 0)                  /*!< P10IV Offset */
N#define P10IV_M                                            (0x001f)              /*!< Port 10 interrupt vector value */
N#define P10IV0                                             (0x0001)              /*!< Port 10 interrupt vector value */
N#define P10IV1                                             (0x0002)              /*!< Port 10 interrupt vector value */
N#define P10IV2                                             (0x0004)              /*!< Port 10 interrupt vector value */
N#define P10IV3                                             (0x0008)              /*!< Port 10 interrupt vector value */
N#define P10IV4                                             (0x0010)              /*!< Port 10 interrupt vector value */
N#define P10IV_0                                            (0x0000)              /*!< No interrupt pending */
N#define P10IV_2                                            (0x0002)              /*!< Interrupt Source: Port 10.0 interrupt; Interrupt Flag: P10IFG0; Interrupt Priority: Highest */
N#define P10IV_4                                            (0x0004)              /*!< Interrupt Source: Port 10.1 interrupt; Interrupt Flag: P10IFG1 */
N#define P10IV_6                                            (0x0006)              /*!< Interrupt Source: Port 10.2 interrupt; Interrupt Flag: P10IFG2 */
N#define P10IV_8                                            (0x0008)              /*!< Interrupt Source: Port 10.3 interrupt; Interrupt Flag: P10IFG3 */
N#define P10IV_10                                           (0x000a)              /*!< Interrupt Source: Port 10.4 interrupt; Interrupt Flag: P10IFG4 */
N#define P10IV_12                                           (0x000c)              /*!< Interrupt Source: Port 10.5 interrupt; Interrupt Flag: P10IFG5 */
N#define P10IV_14                                           (0x000e)              /*!< Interrupt Source: Port 10.6 interrupt; Interrupt Flag: P10IFG6 */
N#define P10IV_16                                           (0x0010)              /*!< Interrupt Source: Port 10.7 interrupt; Interrupt Flag: P10IFG7; Interrupt Priority: Lowest */
N#define P10IV__NONE                                        (0x0000)              /*!< No interrupt pending */
N#define P10IV__P10IFG0                                     (0x0002)              /*!< Interrupt Source: Port 10.0 interrupt; Interrupt Flag: P10IFG0; Interrupt Priority: Highest */
N#define P10IV__P10IFG1                                     (0x0004)              /*!< Interrupt Source: Port 10.1 interrupt; Interrupt Flag: P10IFG1 */
N#define P10IV__P10IFG2                                     (0x0006)              /*!< Interrupt Source: Port 10.2 interrupt; Interrupt Flag: P10IFG2 */
N#define P10IV__P10IFG3                                     (0x0008)              /*!< Interrupt Source: Port 10.3 interrupt; Interrupt Flag: P10IFG3 */
N#define P10IV__P10IFG4                                     (0x000a)              /*!< Interrupt Source: Port 10.4 interrupt; Interrupt Flag: P10IFG4 */
N#define P10IV__P10IFG5                                     (0x000c)              /*!< Interrupt Source: Port 10.5 interrupt; Interrupt Flag: P10IFG5 */
N#define P10IV__P10IFG6                                     (0x000e)              /*!< Interrupt Source: Port 10.6 interrupt; Interrupt Flag: P10IFG6 */
N#define P10IV__P10IFG7                                     (0x0010)              /*!< Interrupt Source: Port 10.7 interrupt; Interrupt Flag: P10IFG7; Interrupt Priority: Lowest */
N
N
N/******************************************************************************
N* EUSCI_A Bits (legacy section)
N******************************************************************************/
N/* UCA0CTLW0[UCSWRST] Bits */
N#define UCSWRST_OFS                              EUSCI_A_CTLW0_SWRST_OFS         /*!< UCSWRST Offset */
N#define UCSWRST                                  EUSCI_A_CTLW0_SWRST             /*!< Software reset enable */
N/* UCA0CTLW0[UCTXBRK] Bits */
N#define UCTXBRK_OFS                              EUSCI_A_CTLW0_TXBRK_OFS         /*!< UCTXBRK Offset */
N#define UCTXBRK                                  EUSCI_A_CTLW0_TXBRK             /*!< Transmit break */
N/* UCA0CTLW0[UCTXADDR] Bits */
N#define UCTXADDR_OFS                             EUSCI_A_CTLW0_TXADDR_OFS        /*!< UCTXADDR Offset */
N#define UCTXADDR                                 EUSCI_A_CTLW0_TXADDR            /*!< Transmit address */
N/* UCA0CTLW0[UCDORM] Bits */
N#define UCDORM_OFS                               EUSCI_A_CTLW0_DORM_OFS          /*!< UCDORM Offset */
N#define UCDORM                                   EUSCI_A_CTLW0_DORM              /*!< Dormant */
N/* UCA0CTLW0[UCBRKIE] Bits */
N#define UCBRKIE_OFS                              EUSCI_A_CTLW0_BRKIE_OFS         /*!< UCBRKIE Offset */
N#define UCBRKIE                                  EUSCI_A_CTLW0_BRKIE             /*!< Receive break character interrupt enable */
N/* UCA0CTLW0[UCRXEIE] Bits */
N#define UCRXEIE_OFS                              EUSCI_A_CTLW0_RXEIE_OFS         /*!< UCRXEIE Offset */
N#define UCRXEIE                                  EUSCI_A_CTLW0_RXEIE             /*!< Receive erroneous-character interrupt enable */
N/* UCA0CTLW0[UCSSEL] Bits */
N#define UCSSEL_OFS                               EUSCI_A_CTLW0_SSEL_OFS          /*!< UCSSEL Offset */
N#define UCSSEL_M                                 EUSCI_A_CTLW0_SSEL_MASK         /*!< eUSCI_A clock source select */
N#define UCSSEL0                                  EUSCI_A_CTLW0_SSEL0             /*!< UCSSEL Bit 0 */
N#define UCSSEL1                                  EUSCI_A_CTLW0_SSEL1             /*!< UCSSEL Bit 1 */
N#define UCSSEL_0                                 EUSCI_A_CTLW0_UCSSEL_0          /*!< UCLK */
N#define UCSSEL_1                                 EUSCI_A_CTLW0_UCSSEL_1          /*!< ACLK */
N#define UCSSEL_2                                 EUSCI_A_CTLW0_UCSSEL_2          /*!< SMCLK */
N#define UCSSEL__UCLK                             EUSCI_A_CTLW0_SSEL__UCLK        /*!< UCLK */
N#define UCSSEL__ACLK                             EUSCI_A_CTLW0_SSEL__ACLK        /*!< ACLK */
N#define UCSSEL__SMCLK                            EUSCI_A_CTLW0_SSEL__SMCLK       /*!< SMCLK */
N/* UCA0CTLW0[UCSYNC] Bits */
N#define UCSYNC_OFS                               EUSCI_A_CTLW0_SYNC_OFS          /*!< UCSYNC Offset */
N#define UCSYNC                                   EUSCI_A_CTLW0_SYNC              /*!< Synchronous mode enable */
N/* UCA0CTLW0[UCMODE] Bits */
N#define UCMODE_OFS                               EUSCI_A_CTLW0_MODE_OFS          /*!< UCMODE Offset */
N#define UCMODE_M                                 EUSCI_A_CTLW0_MODE_MASK         /*!< eUSCI_A mode */
N#define UCMODE0                                  EUSCI_A_CTLW0_MODE0             /*!< UCMODE Bit 0 */
N#define UCMODE1                                  EUSCI_A_CTLW0_MODE1             /*!< UCMODE Bit 1 */
N#define UCMODE_0                                 EUSCI_A_CTLW0_MODE_0            /*!< UART mode */
N#define UCMODE_1                                 EUSCI_A_CTLW0_MODE_1            /*!< Idle-line multiprocessor mode */
N#define UCMODE_2                                 EUSCI_A_CTLW0_MODE_2            /*!< Address-bit multiprocessor mode */
N#define UCMODE_3                                 EUSCI_A_CTLW0_MODE_3            /*!< UART mode with automatic baud-rate detection */
N/* UCA0CTLW0[UCSPB] Bits */
N#define UCSPB_OFS                                EUSCI_A_CTLW0_SPB_OFS           /*!< UCSPB Offset */
N#define UCSPB                                    EUSCI_A_CTLW0_SPB               /*!< Stop bit select */
N/* UCA0CTLW0[UC7BIT] Bits */
N#define UC7BIT_OFS                               EUSCI_A_CTLW0_SEVENBIT_OFS      /*!< UC7BIT Offset */
N#define UC7BIT                                   EUSCI_A_CTLW0_SEVENBIT          /*!< Character length */
N/* UCA0CTLW0[UCMSB] Bits */
N#define UCMSB_OFS                                EUSCI_A_CTLW0_MSB_OFS           /*!< UCMSB Offset */
N#define UCMSB                                    EUSCI_A_CTLW0_MSB               /*!< MSB first select */
N/* UCA0CTLW0[UCPAR] Bits */
N#define UCPAR_OFS                                EUSCI_A_CTLW0_PAR_OFS           /*!< UCPAR Offset */
N#define UCPAR                                    EUSCI_A_CTLW0_PAR               /*!< Parity select */
N/* UCA0CTLW0[UCPEN] Bits */
N#define UCPEN_OFS                                EUSCI_A_CTLW0_PEN_OFS           /*!< UCPEN Offset */
N#define UCPEN                                    EUSCI_A_CTLW0_PEN               /*!< Parity enable */
N/* UCA0CTLW0_SPI[UCSWRST] Bits */
N//#define UCSWRST_OFS                              EUSCI_A_CTLW0_SWRST_OFS         /*!< UCSWRST Offset */
N//#define UCSWRST                                  EUSCI_A_CTLW0_SWRST             /*!< Software reset enable */
N/* UCA0CTLW0_SPI[UCSTEM] Bits */
N#define UCSTEM_OFS                               EUSCI_A_CTLW0_STEM_OFS          /*!< UCSTEM Offset */
N#define UCSTEM                                   EUSCI_A_CTLW0_STEM              /*!< STE mode select in master mode. */
N/* UCA0CTLW0_SPI[UCSSEL] Bits */
N//#define UCSSEL_OFS                               EUSCI_A_CTLW0_SSEL_OFS          /*!< UCSSEL Offset */
N//#define UCSSEL_M                                 EUSCI_A_CTLW0_SSEL_MASK         /*!< eUSCI_A clock source select */
N//#define UCSSEL0                                  EUSCI_A_CTLW0_SSEL0             /*!< UCSSEL Bit 0 */
N//#define UCSSEL1                                  EUSCI_A_CTLW0_SSEL1             /*!< UCSSEL Bit 1 */
N//#define UCSSEL_0                                 EUSCI_A_CTLW0_UCSSEL_0          /*!< Reserved */
N//#define UCSSEL_1                                 EUSCI_A_CTLW0_UCSSEL_1          /*!< ACLK */
N//#define UCSSEL_2                                 EUSCI_A_CTLW0_UCSSEL_2          /*!< SMCLK */
N//#define UCSSEL__ACLK                             EUSCI_A_CTLW0_SSEL__ACLK        /*!< ACLK */
N//#define UCSSEL__SMCLK                            EUSCI_A_CTLW0_SSEL__SMCLK       /*!< SMCLK */
N/* UCA0CTLW0_SPI[UCSYNC] Bits */
N//#define UCSYNC_OFS                               EUSCI_A_CTLW0_SYNC_OFS          /*!< UCSYNC Offset */
N//#define UCSYNC                                   EUSCI_A_CTLW0_SYNC              /*!< Synchronous mode enable */
N/* UCA0CTLW0_SPI[UCMODE] Bits */
N//#define UCMODE_OFS                               EUSCI_A_CTLW0_MODE_OFS          /*!< UCMODE Offset */
N//#define UCMODE_M                                 EUSCI_A_CTLW0_MODE_MASK         /*!< eUSCI mode */
N//#define UCMODE0                                  EUSCI_A_CTLW0_MODE0             /*!< UCMODE Bit 0 */
N//#define UCMODE1                                  EUSCI_A_CTLW0_MODE1             /*!< UCMODE Bit 1 */
N//#define UCMODE_0                                 EUSCI_A_CTLW0_MODE_0            /*!< 3-pin SPI */
N//#define UCMODE_1                                 EUSCI_A_CTLW0_MODE_1            /*!< 4-pin SPI with UCxSTE active high: Slave enabled when UCxSTE = 1 */
N//#define UCMODE_2                                 EUSCI_A_CTLW0_MODE_2            /*!< 4-pin SPI with UCxSTE active low: Slave enabled when UCxSTE = 0 */
N/* UCA0CTLW0_SPI[UCMST] Bits */
N#define UCMST_OFS                                EUSCI_A_CTLW0_MST_OFS           /*!< UCMST Offset */
N#define UCMST                                    EUSCI_A_CTLW0_MST               /*!< Master mode select */
N/* UCA0CTLW0_SPI[UC7BIT] Bits */
N//#define UC7BIT_OFS                               EUSCI_A_CTLW0_SEVENBIT_OFS      /*!< UC7BIT Offset */
N//#define UC7BIT                                   EUSCI_A_CTLW0_SEVENBIT          /*!< Character length */
N/* UCA0CTLW0_SPI[UCMSB] Bits */
N//#define UCMSB_OFS                                EUSCI_A_CTLW0_MSB_OFS           /*!< UCMSB Offset */
N//#define UCMSB                                    EUSCI_A_CTLW0_MSB               /*!< MSB first select */
N/* UCA0CTLW0_SPI[UCCKPL] Bits */
N#define UCCKPL_OFS                               EUSCI_A_CTLW0_CKPL_OFS          /*!< UCCKPL Offset */
N#define UCCKPL                                   EUSCI_A_CTLW0_CKPL              /*!< Clock polarity select */
N/* UCA0CTLW0_SPI[UCCKPH] Bits */
N#define UCCKPH_OFS                               EUSCI_A_CTLW0_CKPH_OFS          /*!< UCCKPH Offset */
N#define UCCKPH                                   EUSCI_A_CTLW0_CKPH              /*!< Clock phase select */
N/* UCA0CTLW1[UCGLIT] Bits */
N#define UCGLIT_OFS                               EUSCI_A_CTLW1_GLIT_OFS          /*!< UCGLIT Offset */
N#define UCGLIT_M                                 EUSCI_A_CTLW1_GLIT_MASK         /*!< Deglitch time */
N#define UCGLIT0                                  EUSCI_A_CTLW1_GLIT0             /*!< UCGLIT Bit 0 */
N#define UCGLIT1                                  EUSCI_A_CTLW1_GLIT1             /*!< UCGLIT Bit 1 */
N#define UCGLIT_0                                 EUSCI_A_CTLW1_GLIT_0            /*!< Approximately 2 ns (equivalent of 1 delay element) */
N#define UCGLIT_1                                 EUSCI_A_CTLW1_GLIT_1            /*!< Approximately 50 ns */
N#define UCGLIT_2                                 EUSCI_A_CTLW1_GLIT_2            /*!< Approximately 100 ns */
N#define UCGLIT_3                                 EUSCI_A_CTLW1_GLIT_3            /*!< Approximately 200 ns */
N/* UCA0MCTLW[UCOS16] Bits */
N#define UCOS16_OFS                               EUSCI_A_MCTLW_OS16_OFS          /*!< UCOS16 Offset */
N#define UCOS16                                   EUSCI_A_MCTLW_OS16              /*!< Oversampling mode enabled */
N/* UCA0MCTLW[UCBRF] Bits */
N#define UCBRF_OFS                                EUSCI_A_MCTLW_BRF_OFS           /*!< UCBRF Offset */
N#define UCBRF_M                                  EUSCI_A_MCTLW_BRF_MASK          /*!< First modulation stage select */
N/* UCA0MCTLW[UCBRS] Bits */
N#define UCBRS_OFS                                EUSCI_A_MCTLW_BRS_OFS           /*!< UCBRS Offset */
N#define UCBRS_M                                  EUSCI_A_MCTLW_BRS_MASK          /*!< Second modulation stage select */
N/* UCA0STATW[UCBUSY] Bits */
N#define UCBUSY_OFS                               EUSCI_A_STATW_BUSY_OFS          /*!< UCBUSY Offset */
N#define UCBUSY                                   EUSCI_A_STATW_BUSY              /*!< eUSCI_A busy */
N/* UCA0STATW[UCADDR_UCIDLE] Bits */
N#define UCADDR_UCIDLE_OFS                        EUSCI_A_STATW_ADDR_IDLE_OFS     /*!< UCADDR_UCIDLE Offset */
N#define UCADDR_UCIDLE                            EUSCI_A_STATW_ADDR_IDLE         /*!< Address received / Idle line detected */
N/* UCA0STATW[UCRXERR] Bits */
N#define UCRXERR_OFS                              EUSCI_A_STATW_RXERR_OFS         /*!< UCRXERR Offset */
N#define UCRXERR                                  EUSCI_A_STATW_RXERR             /*!< Receive error flag */
N/* UCA0STATW[UCBRK] Bits */
N#define UCBRK_OFS                                EUSCI_A_STATW_BRK_OFS           /*!< UCBRK Offset */
N#define UCBRK                                    EUSCI_A_STATW_BRK               /*!< Break detect flag */
N/* UCA0STATW[UCPE] Bits */
N#define UCPE_OFS                                 EUSCI_A_STATW_PE_OFS            /*!< UCPE Offset */
N#define UCPE                                     EUSCI_A_STATW_PE                
N/* UCA0STATW[UCOE] Bits */
N#define UCOE_OFS                                 EUSCI_A_STATW_OE_OFS            /*!< UCOE Offset */
N#define UCOE                                     EUSCI_A_STATW_OE                /*!< Overrun error flag */
N/* UCA0STATW[UCFE] Bits */
N#define UCFE_OFS                                 EUSCI_A_STATW_FE_OFS            /*!< UCFE Offset */
N#define UCFE                                     EUSCI_A_STATW_FE                /*!< Framing error flag */
N/* UCA0STATW[UCLISTEN] Bits */
N#define UCLISTEN_OFS                             EUSCI_A_STATW_LISTEN_OFS        /*!< UCLISTEN Offset */
N#define UCLISTEN                                 EUSCI_A_STATW_LISTEN            /*!< Listen enable */
N/* UCA0STATW_SPI[UCBUSY] Bits */
N//#define UCBUSY_OFS                               EUSCI_A_STATW_SPI_BUSY_OFS      /*!< UCBUSY Offset */
N//#define UCBUSY                                   EUSCI_A_STATW_SPI_BUSY          /*!< eUSCI_A busy */
N/* UCA0STATW_SPI[UCOE] Bits */
N//#define UCOE_OFS                                 EUSCI_A_STATW_OE_OFS            /*!< UCOE Offset */
N//#define UCOE                                     EUSCI_A_STATW_OE                /*!< Overrun error flag */
N/* UCA0STATW_SPI[UCFE] Bits */
N//#define UCFE_OFS                                 EUSCI_A_STATW_FE_OFS            /*!< UCFE Offset */
N//#define UCFE                                     EUSCI_A_STATW_FE                /*!< Framing error flag */
N/* UCA0STATW_SPI[UCLISTEN] Bits */
N//#define UCLISTEN_OFS                             EUSCI_A_STATW_LISTEN_OFS        /*!< UCLISTEN Offset */
N//#define UCLISTEN                                 EUSCI_A_STATW_LISTEN            /*!< Listen enable */
N/* UCA0RXBUF[UCRXBUF] Bits */
N#define UCRXBUF_OFS                              EUSCI_A_RXBUF_RXBUF_OFS         /*!< UCRXBUF Offset */
N#define UCRXBUF_M                                EUSCI_A_RXBUF_RXBUF_MASK        /*!< Receive data buffer */
N/* UCA0RXBUF_SPI[UCRXBUF] Bits */
N//#define UCRXBUF_OFS                              EUSCI_A_RXBUF_RXBUF_OFS         /*!< UCRXBUF Offset */
N//#define UCRXBUF_M                                EUSCI_A_RXBUF_RXBUF_MASK        /*!< Receive data buffer */
N/* UCA0TXBUF[UCTXBUF] Bits */
N#define UCTXBUF_OFS                              EUSCI_A_TXBUF_TXBUF_OFS         /*!< UCTXBUF Offset */
N#define UCTXBUF_M                                EUSCI_A_TXBUF_TXBUF_MASK        /*!< Transmit data buffer */
N/* UCA0TXBUF_SPI[UCTXBUF] Bits */
N//#define UCTXBUF_OFS                              EUSCI_A_TXBUF_TXBUF_OFS         /*!< UCTXBUF Offset */
N//#define UCTXBUF_M                                EUSCI_A_TXBUF_TXBUF_MASK        /*!< Transmit data buffer */
N/* UCA0ABCTL[UCABDEN] Bits */
N#define UCABDEN_OFS                              EUSCI_A_ABCTL_ABDEN_OFS         /*!< UCABDEN Offset */
N#define UCABDEN                                  EUSCI_A_ABCTL_ABDEN             /*!< Automatic baud-rate detect enable */
N/* UCA0ABCTL[UCBTOE] Bits */
N#define UCBTOE_OFS                               EUSCI_A_ABCTL_BTOE_OFS          /*!< UCBTOE Offset */
N#define UCBTOE                                   EUSCI_A_ABCTL_BTOE              /*!< Break time out error */
N/* UCA0ABCTL[UCSTOE] Bits */
N#define UCSTOE_OFS                               EUSCI_A_ABCTL_STOE_OFS          /*!< UCSTOE Offset */
N#define UCSTOE                                   EUSCI_A_ABCTL_STOE              /*!< Synch field time out error */
N/* UCA0ABCTL[UCDELIM] Bits */
N#define UCDELIM_OFS                              EUSCI_A_ABCTL_DELIM_OFS         /*!< UCDELIM Offset */
N#define UCDELIM_M                                EUSCI_A_ABCTL_DELIM_MASK        /*!< Break/synch delimiter length */
N#define UCDELIM0                                 EUSCI_A_ABCTL_DELIM0            /*!< UCDELIM Bit 0 */
N#define UCDELIM1                                 EUSCI_A_ABCTL_DELIM1            /*!< UCDELIM Bit 1 */
N#define UCDELIM_0                                EUSCI_A_ABCTL_DELIM_0           /*!< 1 bit time */
N#define UCDELIM_1                                EUSCI_A_ABCTL_DELIM_1           /*!< 2 bit times */
N#define UCDELIM_2                                EUSCI_A_ABCTL_DELIM_2           /*!< 3 bit times */
N#define UCDELIM_3                                EUSCI_A_ABCTL_DELIM_3           /*!< 4 bit times */
N/* UCA0IRCTL[UCIREN] Bits */
N#define UCIREN_OFS                               EUSCI_A_IRCTL_IREN_OFS          /*!< UCIREN Offset */
N#define UCIREN                                   EUSCI_A_IRCTL_IREN              /*!< IrDA encoder/decoder enable */
N/* UCA0IRCTL[UCIRTXCLK] Bits */
N#define UCIRTXCLK_OFS                            EUSCI_A_IRCTL_IRTXCLK_OFS       /*!< UCIRTXCLK Offset */
N#define UCIRTXCLK                                EUSCI_A_IRCTL_IRTXCLK           /*!< IrDA transmit pulse clock select */
N/* UCA0IRCTL[UCIRTXPL] Bits */
N#define UCIRTXPL_OFS                             EUSCI_A_IRCTL_IRTXPL_OFS        /*!< UCIRTXPL Offset */
N#define UCIRTXPL_M                               EUSCI_A_IRCTL_IRTXPL_MASK       /*!< Transmit pulse length */
N/* UCA0IRCTL[UCIRRXFE] Bits */
N#define UCIRRXFE_OFS                             EUSCI_A_IRCTL_IRRXFE_OFS        /*!< UCIRRXFE Offset */
N#define UCIRRXFE                                 EUSCI_A_IRCTL_IRRXFE            /*!< IrDA receive filter enabled */
N/* UCA0IRCTL[UCIRRXPL] Bits */
N#define UCIRRXPL_OFS                             EUSCI_A_IRCTL_IRRXPL_OFS        /*!< UCIRRXPL Offset */
N#define UCIRRXPL                                 EUSCI_A_IRCTL_IRRXPL            /*!< IrDA receive input UCAxRXD polarity */
N/* UCA0IRCTL[UCIRRXFL] Bits */
N#define UCIRRXFL_OFS                             EUSCI_A_IRCTL_IRRXFL_OFS        /*!< UCIRRXFL Offset */
N#define UCIRRXFL_M                               EUSCI_A_IRCTL_IRRXFL_MASK       /*!< Receive filter length */
N/* UCA0IE[UCRXIE] Bits */
N#define UCRXIE_OFS                               EUSCI_A_IE_RXIE_OFS             /*!< UCRXIE Offset */
N#define UCRXIE                                   EUSCI_A_IE_RXIE                 /*!< Receive interrupt enable */
N/* UCA0IE[UCTXIE] Bits */
N#define UCTXIE_OFS                               EUSCI_A_IE_TXIE_OFS             /*!< UCTXIE Offset */
N#define UCTXIE                                   EUSCI_A_IE_TXIE                 /*!< Transmit interrupt enable */
N/* UCA0IE[UCSTTIE] Bits */
N#define UCSTTIE_OFS                              EUSCI_A_IE_STTIE_OFS            /*!< UCSTTIE Offset */
N#define UCSTTIE                                  EUSCI_A_IE_STTIE                /*!< Start bit interrupt enable */
N/* UCA0IE[UCTXCPTIE] Bits */
N#define UCTXCPTIE_OFS                            EUSCI_A_IE_TXCPTIE_OFS          /*!< UCTXCPTIE Offset */
N#define UCTXCPTIE                                EUSCI_A_IE_TXCPTIE              /*!< Transmit complete interrupt enable */
N/* UCA0IE_SPI[UCRXIE] Bits */
N//#define UCRXIE_OFS                               EUSCI_A_IE_RXIE_OFS             /*!< UCRXIE Offset */
N//#define UCRXIE                                   EUSCI_A_IE_RXIE                 /*!< Receive interrupt enable */
N/* UCA0IE_SPI[UCTXIE] Bits */
N//#define UCTXIE_OFS                               EUSCI_A_IE_TXIE_OFS             /*!< UCTXIE Offset */
N//#define UCTXIE                                   EUSCI_A_IE_TXIE                 /*!< Transmit interrupt enable */
N/* UCA0IFG[UCRXIFG] Bits */
N#define UCRXIFG_OFS                              EUSCI_A_IFG_RXIFG_OFS           /*!< UCRXIFG Offset */
N#define UCRXIFG                                  EUSCI_A_IFG_RXIFG               /*!< Receive interrupt flag */
N/* UCA0IFG[UCTXIFG] Bits */
N#define UCTXIFG_OFS                              EUSCI_A_IFG_TXIFG_OFS           /*!< UCTXIFG Offset */
N#define UCTXIFG                                  EUSCI_A_IFG_TXIFG               /*!< Transmit interrupt flag */
N/* UCA0IFG[UCSTTIFG] Bits */
N#define UCSTTIFG_OFS                             EUSCI_A_IFG_STTIFG_OFS          /*!< UCSTTIFG Offset */
N#define UCSTTIFG                                 EUSCI_A_IFG_STTIFG              /*!< Start bit interrupt flag */
N/* UCA0IFG[UCTXCPTIFG] Bits */
N#define UCTXCPTIFG_OFS                           EUSCI_A_IFG_TXCPTIFG_OFS        /*!< UCTXCPTIFG Offset */
N#define UCTXCPTIFG                               EUSCI_A_IFG_TXCPTIFG            /*!< Transmit ready interrupt enable */
N/* UCA0IFG_SPI[UCRXIFG] Bits */
N//#define UCRXIFG_OFS                              EUSCI_A_IFG_RXIFG_OFS           /*!< UCRXIFG Offset */
N//#define UCRXIFG                                  EUSCI_A_IFG_RXIFG               /*!< Receive interrupt flag */
N/* UCA0IFG_SPI[UCTXIFG] Bits */
N//#define UCTXIFG_OFS                              EUSCI_A_IFG_TXIFG_OFS           /*!< UCTXIFG Offset */
N//#define UCTXIFG                                  EUSCI_A_IFG_TXIFG               /*!< Transmit interrupt flag */
N
N/******************************************************************************
N* EUSCI_B Bits (legacy section)
N******************************************************************************/
N/* UCB0CTLW0[UCSWRST] Bits */
N//#define UCSWRST_OFS                              EUSCI_B_CTLW0_SWRST_OFS         /*!< UCSWRST Offset */
N//#define UCSWRST                                  EUSCI_B_CTLW0_SWRST             /*!< Software reset enable */
N/* UCB0CTLW0[UCTXSTT] Bits */
N#define UCTXSTT_OFS                              EUSCI_B_CTLW0_TXSTT_OFS         /*!< UCTXSTT Offset */
N#define UCTXSTT                                  EUSCI_B_CTLW0_TXSTT             /*!< Transmit START condition in master mode */
N/* UCB0CTLW0[UCTXSTP] Bits */
N#define UCTXSTP_OFS                              EUSCI_B_CTLW0_TXSTP_OFS         /*!< UCTXSTP Offset */
N#define UCTXSTP                                  EUSCI_B_CTLW0_TXSTP             /*!< Transmit STOP condition in master mode */
N/* UCB0CTLW0[UCTXNACK] Bits */
N#define UCTXNACK_OFS                             EUSCI_B_CTLW0_TXNACK_OFS        /*!< UCTXNACK Offset */
N#define UCTXNACK                                 EUSCI_B_CTLW0_TXNACK            /*!< Transmit a NACK */
N/* UCB0CTLW0[UCTR] Bits */
N#define UCTR_OFS                                 EUSCI_B_CTLW0_TR_OFS            /*!< UCTR Offset */
N#define UCTR                                     EUSCI_B_CTLW0_TR                /*!< Transmitter/receiver */
N/* UCB0CTLW0[UCTXACK] Bits */
N#define UCTXACK_OFS                              EUSCI_B_CTLW0_TXACK_OFS         /*!< UCTXACK Offset */
N#define UCTXACK                                  EUSCI_B_CTLW0_TXACK             /*!< Transmit ACK condition in slave mode */
N/* UCB0CTLW0[UCSSEL] Bits */
N//#define UCSSEL_OFS                               EUSCI_B_CTLW0_SSEL_OFS          /*!< UCSSEL Offset */
N//#define UCSSEL_M                                 EUSCI_B_CTLW0_SSEL_MASK         /*!< eUSCI_B clock source select */
N//#define UCSSEL0                                  EUSCI_B_CTLW0_SSEL0             /*!< UCSSEL Bit 0 */
N//#define UCSSEL1                                  EUSCI_B_CTLW0_SSEL1             /*!< UCSSEL Bit 1 */
N//#define UCSSEL_0                                 EUSCI_B_CTLW0_UCSSEL_0          /*!< UCLKI */
N//#define UCSSEL_1                                 EUSCI_B_CTLW0_UCSSEL_1          /*!< ACLK */
N//#define UCSSEL_2                                 EUSCI_B_CTLW0_UCSSEL_2          /*!< SMCLK */
N#define UCSSEL_3                                 EUSCI_B_CTLW0_UCSSEL_3          /*!< SMCLK */
N#define UCSSEL__UCLKI                            EUSCI_B_CTLW0_SSEL__UCLKI       /*!< UCLKI */
N//#define UCSSEL__ACLK                             EUSCI_B_CTLW0_SSEL__ACLK        /*!< ACLK */
N//#define UCSSEL__SMCLK                            EUSCI_B_CTLW0_SSEL__SMCLK       /*!< SMCLK */
N/* UCB0CTLW0[UCSYNC] Bits */
N//#define UCSYNC_OFS                               EUSCI_B_CTLW0_SYNC_OFS          /*!< UCSYNC Offset */
N//#define UCSYNC                                   EUSCI_B_CTLW0_SYNC              /*!< Synchronous mode enable */
N/* UCB0CTLW0[UCMODE] Bits */
N//#define UCMODE_OFS                               EUSCI_B_CTLW0_MODE_OFS          /*!< UCMODE Offset */
N//#define UCMODE_M                                 EUSCI_B_CTLW0_MODE_MASK         /*!< eUSCI_B mode */
N//#define UCMODE0                                  EUSCI_B_CTLW0_MODE0             /*!< UCMODE Bit 0 */
N//#define UCMODE1                                  EUSCI_B_CTLW0_MODE1             /*!< UCMODE Bit 1 */
N//#define UCMODE_0                                 EUSCI_B_CTLW0_MODE_0            /*!< 3-pin SPI */
N//#define UCMODE_1                                 EUSCI_B_CTLW0_MODE_1            /*!< 4-pin SPI (master or slave enabled if STE = 1) */
N//#define UCMODE_2                                 EUSCI_B_CTLW0_MODE_2            /*!< 4-pin SPI (master or slave enabled if STE = 0) */
N//#define UCMODE_3                                 EUSCI_B_CTLW0_MODE_3            /*!< I2C mode */
N/* UCB0CTLW0[UCMST] Bits */
N//#define UCMST_OFS                                EUSCI_B_CTLW0_MST_OFS           /*!< UCMST Offset */
N//#define UCMST                                    EUSCI_B_CTLW0_MST               /*!< Master mode select */
N/* UCB0CTLW0[UCMM] Bits */
N#define UCMM_OFS                                 EUSCI_B_CTLW0_MM_OFS            /*!< UCMM Offset */
N#define UCMM                                     EUSCI_B_CTLW0_MM                /*!< Multi-master environment select */
N/* UCB0CTLW0[UCSLA10] Bits */
N#define UCSLA10_OFS                              EUSCI_B_CTLW0_SLA10_OFS         /*!< UCSLA10 Offset */
N#define UCSLA10                                  EUSCI_B_CTLW0_SLA10             /*!< Slave addressing mode select */
N/* UCB0CTLW0[UCA10] Bits */
N#define UCA10_OFS                                EUSCI_B_CTLW0_A10_OFS           /*!< UCA10 Offset */
N#define UCA10                                    EUSCI_B_CTLW0_A10               /*!< Own addressing mode select */
N/* UCB0CTLW0_SPI[UCSWRST] Bits */
N//#define UCSWRST_OFS                              EUSCI_B_CTLW0_SWRST_OFS         /*!< UCSWRST Offset */
N//#define UCSWRST                                  EUSCI_B_CTLW0_SWRST             /*!< Software reset enable */
N/* UCB0CTLW0_SPI[UCSTEM] Bits */
N//#define UCSTEM_OFS                               EUSCI_B_CTLW0_STEM_OFS          /*!< UCSTEM Offset */
N//#define UCSTEM                                   EUSCI_B_CTLW0_STEM              /*!< STE mode select in master mode. */
N/* UCB0CTLW0_SPI[UCSSEL] Bits */
N//#define UCSSEL_OFS                               EUSCI_B_CTLW0_SSEL_OFS          /*!< UCSSEL Offset */
N//#define UCSSEL_M                                 EUSCI_B_CTLW0_SSEL_MASK         /*!< eUSCI_B clock source select */
N//#define UCSSEL0                                  EUSCI_B_CTLW0_SSEL0             /*!< UCSSEL Bit 0 */
N//#define UCSSEL1                                  EUSCI_B_CTLW0_SSEL1             /*!< UCSSEL Bit 1 */
N//#define UCSSEL_0                                 EUSCI_B_CTLW0_UCSSEL_0          /*!< Reserved */
N//#define UCSSEL_1                                 EUSCI_B_CTLW0_UCSSEL_1          /*!< ACLK */
N//#define UCSSEL_2                                 EUSCI_B_CTLW0_UCSSEL_2          /*!< SMCLK */
N//#define UCSSEL_3                                 EUSCI_B_CTLW0_UCSSEL_3          /*!< SMCLK */
N//#define UCSSEL__ACLK                             EUSCI_B_CTLW0_SSEL__ACLK        /*!< ACLK */
N//#define UCSSEL__SMCLK                            EUSCI_B_CTLW0_SSEL__SMCLK       /*!< SMCLK */
N/* UCB0CTLW0_SPI[UCSYNC] Bits */
N//#define UCSYNC_OFS                               EUSCI_B_CTLW0_SYNC_OFS          /*!< UCSYNC Offset */
N//#define UCSYNC                                   EUSCI_B_CTLW0_SYNC              /*!< Synchronous mode enable */
N/* UCB0CTLW0_SPI[UCMODE] Bits */
N//#define UCMODE_OFS                               EUSCI_B_CTLW0_MODE_OFS          /*!< UCMODE Offset */
N//#define UCMODE_M                                 EUSCI_B_CTLW0_MODE_MASK         /*!< eUSCI mode */
N//#define UCMODE0                                  EUSCI_B_CTLW0_MODE0             /*!< UCMODE Bit 0 */
N//#define UCMODE1                                  EUSCI_B_CTLW0_MODE1             /*!< UCMODE Bit 1 */
N//#define UCMODE_0                                 EUSCI_B_CTLW0_MODE_0            /*!< 3-pin SPI */
N//#define UCMODE_1                                 EUSCI_B_CTLW0_MODE_1            /*!< 4-pin SPI with UCxSTE active high: Slave enabled when UCxSTE = 1 */
N//#define UCMODE_2                                 EUSCI_B_CTLW0_MODE_2            /*!< 4-pin SPI with UCxSTE active low: Slave enabled when UCxSTE = 0 */
N//#define UCMODE_3                                 EUSCI_B_CTLW0_MODE_3            /*!< I2C mode */
N/* UCB0CTLW0_SPI[UCMST] Bits */
N//#define UCMST_OFS                                EUSCI_B_CTLW0_MST_OFS           /*!< UCMST Offset */
N//#define UCMST                                    EUSCI_B_CTLW0_MST               /*!< Master mode select */
N/* UCB0CTLW0_SPI[UC7BIT] Bits */
N//#define UC7BIT_OFS                               EUSCI_B_CTLW0_SEVENBIT_OFS      /*!< UC7BIT Offset */
N//#define UC7BIT                                   EUSCI_B_CTLW0_SEVENBIT          /*!< Character length */
N/* UCB0CTLW0_SPI[UCMSB] Bits */
N//#define UCMSB_OFS                                EUSCI_B_CTLW0_MSB_OFS           /*!< UCMSB Offset */
N//#define UCMSB                                    EUSCI_B_CTLW0_MSB               /*!< MSB first select */
N/* UCB0CTLW0_SPI[UCCKPL] Bits */
N//#define UCCKPL_OFS                               EUSCI_B_CTLW0_CKPL_OFS          /*!< UCCKPL Offset */
N//#define UCCKPL                                   EUSCI_B_CTLW0_CKPL              /*!< Clock polarity select */
N/* UCB0CTLW0_SPI[UCCKPH] Bits */
N//#define UCCKPH_OFS                               EUSCI_B_CTLW0_CKPH_OFS          /*!< UCCKPH Offset */
N//#define UCCKPH                                   EUSCI_B_CTLW0_CKPH              /*!< Clock phase select */
N/* UCB0CTLW1[UCGLIT] Bits */
N//#define UCGLIT_OFS                               EUSCI_B_CTLW1_GLIT_OFS          /*!< UCGLIT Offset */
N//#define UCGLIT_M                                 EUSCI_B_CTLW1_GLIT_MASK         /*!< Deglitch time */
N//#define UCGLIT0                                  EUSCI_B_CTLW1_GLIT0             /*!< UCGLIT Bit 0 */
N//#define UCGLIT1                                  EUSCI_B_CTLW1_GLIT1             /*!< UCGLIT Bit 1 */
N//#define UCGLIT_0                                 EUSCI_B_CTLW1_GLIT_0            /*!< 50 ns */
N//#define UCGLIT_1                                 EUSCI_B_CTLW1_GLIT_1            /*!< 25 ns */
N//#define UCGLIT_2                                 EUSCI_B_CTLW1_GLIT_2            /*!< 12.5 ns */
N//#define UCGLIT_3                                 EUSCI_B_CTLW1_GLIT_3            /*!< 6.25 ns */
N/* UCB0CTLW1[UCASTP] Bits */
N#define UCASTP_OFS                               EUSCI_B_CTLW1_ASTP_OFS          /*!< UCASTP Offset */
N#define UCASTP_M                                 EUSCI_B_CTLW1_ASTP_MASK         /*!< Automatic STOP condition generation */
N#define UCASTP0                                  EUSCI_B_CTLW1_ASTP0             /*!< UCASTP Bit 0 */
N#define UCASTP1                                  EUSCI_B_CTLW1_ASTP1             /*!< UCASTP Bit 1 */
N#define UCASTP_0                                 EUSCI_B_CTLW1_ASTP_0            /*!< No automatic STOP generation. The STOP condition is generated after the user  */
N                                                                                 /* sets the UCTXSTP bit. The value in UCBxTBCNT is a don't care. */
N#define UCASTP_1                                 EUSCI_B_CTLW1_ASTP_1            /*!< UCBCNTIFG is set with the byte counter reaches the threshold defined in  */
N                                                                                 /* UCBxTBCNT */
N#define UCASTP_2                                 EUSCI_B_CTLW1_ASTP_2            /*!< A STOP condition is generated automatically after the byte counter value  */
N                                                                                 /* reached UCBxTBCNT. UCBCNTIFG is set with the byte counter reaching the */
N                                                                                 /* threshold */
N/* UCB0CTLW1[UCSWACK] Bits */
N#define UCSWACK_OFS                              EUSCI_B_CTLW1_SWACK_OFS         /*!< UCSWACK Offset */
N#define UCSWACK                                  EUSCI_B_CTLW1_SWACK             /*!< SW or HW ACK control */
N/* UCB0CTLW1[UCSTPNACK] Bits */
N#define UCSTPNACK_OFS                            EUSCI_B_CTLW1_STPNACK_OFS       /*!< UCSTPNACK Offset */
N#define UCSTPNACK                                EUSCI_B_CTLW1_STPNACK           /*!< ACK all master bytes */
N/* UCB0CTLW1[UCCLTO] Bits */
N#define UCCLTO_OFS                               EUSCI_B_CTLW1_CLTO_OFS          /*!< UCCLTO Offset */
N#define UCCLTO_M                                 EUSCI_B_CTLW1_CLTO_MASK         /*!< Clock low timeout select */
N#define UCCLTO0                                  EUSCI_B_CTLW1_CLTO0             /*!< UCCLTO Bit 0 */
N#define UCCLTO1                                  EUSCI_B_CTLW1_CLTO1             /*!< UCCLTO Bit 1 */
N#define UCCLTO_0                                 EUSCI_B_CTLW1_CLTO_0            /*!< Disable clock low timeout counter */
N#define UCCLTO_1                                 EUSCI_B_CTLW1_CLTO_1            /*!< 135 000 SYSCLK cycles (approximately 28 ms) */
N#define UCCLTO_2                                 EUSCI_B_CTLW1_CLTO_2            /*!< 150 000 SYSCLK cycles (approximately 31 ms) */
N#define UCCLTO_3                                 EUSCI_B_CTLW1_CLTO_3            /*!< 165 000 SYSCLK cycles (approximately 34 ms) */
N/* UCB0CTLW1[UCETXINT] Bits */
N#define UCETXINT_OFS                             EUSCI_B_CTLW1_ETXINT_OFS        /*!< UCETXINT Offset */
N#define UCETXINT                                 EUSCI_B_CTLW1_ETXINT            /*!< Early UCTXIFG0 */
N/* UCB0STATW[UCBBUSY] Bits */
N#define UCBBUSY_OFS                              EUSCI_B_STATW_BBUSY_OFS         /*!< UCBBUSY Offset */
N#define UCBBUSY                                  EUSCI_B_STATW_BBUSY             /*!< Bus busy */
N/* UCB0STATW[UCGC] Bits */
N#define UCGC_OFS                                 EUSCI_B_STATW_GC_OFS            /*!< UCGC Offset */
N#define UCGC                                     EUSCI_B_STATW_GC                /*!< General call address received */
N/* UCB0STATW[UCSCLLOW] Bits */
N#define UCSCLLOW_OFS                             EUSCI_B_STATW_SCLLOW_OFS        /*!< UCSCLLOW Offset */
N#define UCSCLLOW                                 EUSCI_B_STATW_SCLLOW            /*!< SCL low */
N/* UCB0STATW[UCBCNT] Bits */
N#define UCBCNT_OFS                               EUSCI_B_STATW_BCNT_OFS          /*!< UCBCNT Offset */
N#define UCBCNT_M                                 EUSCI_B_STATW_BCNT_MASK         /*!< Hardware byte counter value */
N/* UCB0STATW_SPI[UCBUSY] Bits */
N//#define UCBUSY_OFS                               EUSCI_B_STATW_SPI_BUSY_OFS      /*!< UCBUSY Offset */
N//#define UCBUSY                                   EUSCI_B_STATW_SPI_BUSY          /*!< eUSCI_B busy */
N/* UCB0STATW_SPI[UCOE] Bits */
N//#define UCOE_OFS                                 EUSCI_B_STATW_OE_OFS            /*!< UCOE Offset */
N//#define UCOE                                     EUSCI_B_STATW_OE                /*!< Overrun error flag */
N/* UCB0STATW_SPI[UCFE] Bits */
N//#define UCFE_OFS                                 EUSCI_B_STATW_FE_OFS            /*!< UCFE Offset */
N//#define UCFE                                     EUSCI_B_STATW_FE                /*!< Framing error flag */
N/* UCB0STATW_SPI[UCLISTEN] Bits */
N//#define UCLISTEN_OFS                             EUSCI_B_STATW_LISTEN_OFS        /*!< UCLISTEN Offset */
N//#define UCLISTEN                                 EUSCI_B_STATW_LISTEN            /*!< Listen enable */
N/* UCB0TBCNT[UCTBCNT] Bits */
N#define UCTBCNT_OFS                              EUSCI_B_TBCNT_TBCNT_OFS         /*!< UCTBCNT Offset */
N#define UCTBCNT_M                                EUSCI_B_TBCNT_TBCNT_MASK        /*!< Byte counter threshold value */
N/* UCB0RXBUF[UCRXBUF] Bits */
N//#define UCRXBUF_OFS                              EUSCI_B_RXBUF_RXBUF_OFS         /*!< UCRXBUF Offset */
N//#define UCRXBUF_M                                EUSCI_B_RXBUF_RXBUF_MASK        /*!< Receive data buffer */
N/* UCB0RXBUF_SPI[UCRXBUF] Bits */
N//#define UCRXBUF_OFS                              EUSCI_B_RXBUF_RXBUF_OFS         /*!< UCRXBUF Offset */
N//#define UCRXBUF_M                                EUSCI_B_RXBUF_RXBUF_MASK        /*!< Receive data buffer */
N/* UCB0TXBUF[UCTXBUF] Bits */
N//#define UCTXBUF_OFS                              EUSCI_B_TXBUF_TXBUF_OFS         /*!< UCTXBUF Offset */
N//#define UCTXBUF_M                                EUSCI_B_TXBUF_TXBUF_MASK        /*!< Transmit data buffer */
N/* UCB0TXBUF_SPI[UCTXBUF] Bits */
N//#define UCTXBUF_OFS                              EUSCI_B_TXBUF_TXBUF_OFS         /*!< UCTXBUF Offset */
N//#define UCTXBUF_M                                EUSCI_B_TXBUF_TXBUF_MASK        /*!< Transmit data buffer */
N/* UCB0I2COA0[I2COA0] Bits */
N#define I2COA0_OFS                               EUSCI_B_I2COA0_I2COA0_OFS       /*!< I2COA0 Offset */
N#define I2COA0_M                                 EUSCI_B_I2COA0_I2COA0_MASK      /*!< I2C own address */
N/* UCB0I2COA0[UCOAEN] Bits */
N#define UCOAEN_OFS                               EUSCI_B_I2COA0_OAEN_OFS         /*!< UCOAEN Offset */
N#define UCOAEN                                   EUSCI_B_I2COA0_OAEN             /*!< Own Address enable register */
N/* UCB0I2COA0[UCGCEN] Bits */
N#define UCGCEN_OFS                               EUSCI_B_I2COA0_GCEN_OFS         /*!< UCGCEN Offset */
N#define UCGCEN                                   EUSCI_B_I2COA0_GCEN             /*!< General call response enable */
N/* UCB0I2COA1[I2COA1] Bits */
N#define I2COA1_OFS                               EUSCI_B_I2COA1_I2COA1_OFS       /*!< I2COA1 Offset */
N#define I2COA1_M                                 EUSCI_B_I2COA1_I2COA1_MASK      /*!< I2C own address */
N/* UCB0I2COA1[UCOAEN] Bits */
N//#define UCOAEN_OFS                               EUSCI_B_I2COA1_OAEN_OFS         /*!< UCOAEN Offset */
N//#define UCOAEN                                   EUSCI_B_I2COA1_OAEN             /*!< Own Address enable register */
N/* UCB0I2COA2[I2COA2] Bits */
N#define I2COA2_OFS                               EUSCI_B_I2COA2_I2COA2_OFS       /*!< I2COA2 Offset */
N#define I2COA2_M                                 EUSCI_B_I2COA2_I2COA2_MASK      /*!< I2C own address */
N/* UCB0I2COA2[UCOAEN] Bits */
N//#define UCOAEN_OFS                               EUSCI_B_I2COA2_OAEN_OFS         /*!< UCOAEN Offset */
N//#define UCOAEN                                   EUSCI_B_I2COA2_OAEN             /*!< Own Address enable register */
N/* UCB0I2COA3[I2COA3] Bits */
N#define I2COA3_OFS                               EUSCI_B_I2COA3_I2COA3_OFS       /*!< I2COA3 Offset */
N#define I2COA3_M                                 EUSCI_B_I2COA3_I2COA3_MASK      /*!< I2C own address */
N/* UCB0I2COA3[UCOAEN] Bits */
N//#define UCOAEN_OFS                               EUSCI_B_I2COA3_OAEN_OFS         /*!< UCOAEN Offset */
N//#define UCOAEN                                   EUSCI_B_I2COA3_OAEN             /*!< Own Address enable register */
N/* UCB0ADDRX[ADDRX] Bits */
N#define ADDRX_OFS                                EUSCI_B_ADDRX_ADDRX_OFS         /*!< ADDRX Offset */
N#define ADDRX_M                                  EUSCI_B_ADDRX_ADDRX_MASK        /*!< Received Address Register */
N#define ADDRX0                                   EUSCI_B_ADDRX_ADDRX0            /*!< ADDRX Bit 0 */
N#define ADDRX1                                   EUSCI_B_ADDRX_ADDRX1            /*!< ADDRX Bit 1 */
N#define ADDRX2                                   EUSCI_B_ADDRX_ADDRX2            /*!< ADDRX Bit 2 */
N#define ADDRX3                                   EUSCI_B_ADDRX_ADDRX3            /*!< ADDRX Bit 3 */
N#define ADDRX4                                   EUSCI_B_ADDRX_ADDRX4            /*!< ADDRX Bit 4 */
N#define ADDRX5                                   EUSCI_B_ADDRX_ADDRX5            /*!< ADDRX Bit 5 */
N#define ADDRX6                                   EUSCI_B_ADDRX_ADDRX6            /*!< ADDRX Bit 6 */
N#define ADDRX7                                   EUSCI_B_ADDRX_ADDRX7            /*!< ADDRX Bit 7 */
N#define ADDRX8                                   EUSCI_B_ADDRX_ADDRX8            /*!< ADDRX Bit 8 */
N#define ADDRX9                                   EUSCI_B_ADDRX_ADDRX9            /*!< ADDRX Bit 9 */
N/* UCB0ADDMASK[ADDMASK] Bits */
N#define ADDMASK_OFS                              EUSCI_B_ADDMASK_ADDMASK_OFS     /*!< ADDMASK Offset */
N#define ADDMASK_M                                EUSCI_B_ADDMASK_ADDMASK_MASK    
N/* UCB0I2CSA[I2CSA] Bits */
N#define I2CSA_OFS                                EUSCI_B_I2CSA_I2CSA_OFS         /*!< I2CSA Offset */
N#define I2CSA_M                                  EUSCI_B_I2CSA_I2CSA_MASK        /*!< I2C slave address */
N/* UCB0IE[UCRXIE0] Bits */
N#define UCRXIE0_OFS                              EUSCI_B_IE_RXIE0_OFS            /*!< UCRXIE0 Offset */
N#define UCRXIE0                                  EUSCI_B_IE_RXIE0                /*!< Receive interrupt enable 0 */
N/* UCB0IE[UCTXIE0] Bits */
N#define UCTXIE0_OFS                              EUSCI_B_IE_TXIE0_OFS            /*!< UCTXIE0 Offset */
N#define UCTXIE0                                  EUSCI_B_IE_TXIE0                /*!< Transmit interrupt enable 0 */
N/* UCB0IE[UCSTTIE] Bits */
N//#define UCSTTIE_OFS                              EUSCI_B_IE_STTIE_OFS            /*!< UCSTTIE Offset */
N//#define UCSTTIE                                  EUSCI_B_IE_STTIE                /*!< START condition interrupt enable */
N/* UCB0IE[UCSTPIE] Bits */
N#define UCSTPIE_OFS                              EUSCI_B_IE_STPIE_OFS            /*!< UCSTPIE Offset */
N#define UCSTPIE                                  EUSCI_B_IE_STPIE                /*!< STOP condition interrupt enable */
N/* UCB0IE[UCALIE] Bits */
N#define UCALIE_OFS                               EUSCI_B_IE_ALIE_OFS             /*!< UCALIE Offset */
N#define UCALIE                                   EUSCI_B_IE_ALIE                 /*!< Arbitration lost interrupt enable */
N/* UCB0IE[UCNACKIE] Bits */
N#define UCNACKIE_OFS                             EUSCI_B_IE_NACKIE_OFS           /*!< UCNACKIE Offset */
N#define UCNACKIE                                 EUSCI_B_IE_NACKIE               /*!< Not-acknowledge interrupt enable */
N/* UCB0IE[UCBCNTIE] Bits */
N#define UCBCNTIE_OFS                             EUSCI_B_IE_BCNTIE_OFS           /*!< UCBCNTIE Offset */
N#define UCBCNTIE                                 EUSCI_B_IE_BCNTIE               /*!< Byte counter interrupt enable */
N/* UCB0IE[UCCLTOIE] Bits */
N#define UCCLTOIE_OFS                             EUSCI_B_IE_CLTOIE_OFS           /*!< UCCLTOIE Offset */
N#define UCCLTOIE                                 EUSCI_B_IE_CLTOIE               /*!< Clock low timeout interrupt enable */
N/* UCB0IE[UCRXIE1] Bits */
N#define UCRXIE1_OFS                              EUSCI_B_IE_RXIE1_OFS            /*!< UCRXIE1 Offset */
N#define UCRXIE1                                  EUSCI_B_IE_RXIE1                /*!< Receive interrupt enable 1 */
N/* UCB0IE[UCTXIE1] Bits */
N#define UCTXIE1_OFS                              EUSCI_B_IE_TXIE1_OFS            /*!< UCTXIE1 Offset */
N#define UCTXIE1                                  EUSCI_B_IE_TXIE1                /*!< Transmit interrupt enable 1 */
N/* UCB0IE[UCRXIE2] Bits */
N#define UCRXIE2_OFS                              EUSCI_B_IE_RXIE2_OFS            /*!< UCRXIE2 Offset */
N#define UCRXIE2                                  EUSCI_B_IE_RXIE2                /*!< Receive interrupt enable 2 */
N/* UCB0IE[UCTXIE2] Bits */
N#define UCTXIE2_OFS                              EUSCI_B_IE_TXIE2_OFS            /*!< UCTXIE2 Offset */
N#define UCTXIE2                                  EUSCI_B_IE_TXIE2                /*!< Transmit interrupt enable 2 */
N/* UCB0IE[UCRXIE3] Bits */
N#define UCRXIE3_OFS                              EUSCI_B_IE_RXIE3_OFS            /*!< UCRXIE3 Offset */
N#define UCRXIE3                                  EUSCI_B_IE_RXIE3                /*!< Receive interrupt enable 3 */
N/* UCB0IE[UCTXIE3] Bits */
N#define UCTXIE3_OFS                              EUSCI_B_IE_TXIE3_OFS            /*!< UCTXIE3 Offset */
N#define UCTXIE3                                  EUSCI_B_IE_TXIE3                /*!< Transmit interrupt enable 3 */
N/* UCB0IE[UCBIT9IE] Bits */
N#define UCBIT9IE_OFS                             EUSCI_B_IE_BIT9IE_OFS           /*!< UCBIT9IE Offset */
N#define UCBIT9IE                                 EUSCI_B_IE_BIT9IE               /*!< Bit position 9 interrupt enable */
N/* UCB0IE_SPI[UCRXIE] Bits */
N//#define UCRXIE_OFS                               EUSCI_B_IE_RXIE_OFS             /*!< UCRXIE Offset */
N//#define UCRXIE                                   EUSCI_B_IE_RXIE                 /*!< Receive interrupt enable */
N/* UCB0IE_SPI[UCTXIE] Bits */
N//#define UCTXIE_OFS                               EUSCI_B_IE_TXIE_OFS             /*!< UCTXIE Offset */
N//#define UCTXIE                                   EUSCI_B_IE_TXIE                 /*!< Transmit interrupt enable */
N/* UCB0IFG[UCRXIFG0] Bits */
N#define UCRXIFG0_OFS                             EUSCI_B_IFG_RXIFG0_OFS          /*!< UCRXIFG0 Offset */
N#define UCRXIFG0                                 EUSCI_B_IFG_RXIFG0              /*!< eUSCI_B receive interrupt flag 0 */
N/* UCB0IFG[UCTXIFG0] Bits */
N#define UCTXIFG0_OFS                             EUSCI_B_IFG_TXIFG0_OFS          /*!< UCTXIFG0 Offset */
N#define UCTXIFG0                                 EUSCI_B_IFG_TXIFG0              /*!< eUSCI_B transmit interrupt flag 0 */
N/* UCB0IFG[UCSTTIFG] Bits */
N//#define UCSTTIFG_OFS                             EUSCI_B_IFG_STTIFG_OFS          /*!< UCSTTIFG Offset */
N//#define UCSTTIFG                                 EUSCI_B_IFG_STTIFG              /*!< START condition interrupt flag */
N/* UCB0IFG[UCSTPIFG] Bits */
N#define UCSTPIFG_OFS                             EUSCI_B_IFG_STPIFG_OFS          /*!< UCSTPIFG Offset */
N#define UCSTPIFG                                 EUSCI_B_IFG_STPIFG              /*!< STOP condition interrupt flag */
N/* UCB0IFG[UCALIFG] Bits */
N#define UCALIFG_OFS                              EUSCI_B_IFG_ALIFG_OFS           /*!< UCALIFG Offset */
N#define UCALIFG                                  EUSCI_B_IFG_ALIFG               /*!< Arbitration lost interrupt flag */
N/* UCB0IFG[UCNACKIFG] Bits */
N#define UCNACKIFG_OFS                            EUSCI_B_IFG_NACKIFG_OFS         /*!< UCNACKIFG Offset */
N#define UCNACKIFG                                EUSCI_B_IFG_NACKIFG             /*!< Not-acknowledge received interrupt flag */
N/* UCB0IFG[UCBCNTIFG] Bits */
N#define UCBCNTIFG_OFS                            EUSCI_B_IFG_BCNTIFG_OFS         /*!< UCBCNTIFG Offset */
N#define UCBCNTIFG                                EUSCI_B_IFG_BCNTIFG             /*!< Byte counter interrupt flag */
N/* UCB0IFG[UCCLTOIFG] Bits */
N#define UCCLTOIFG_OFS                            EUSCI_B_IFG_CLTOIFG_OFS         /*!< UCCLTOIFG Offset */
N#define UCCLTOIFG                                EUSCI_B_IFG_CLTOIFG             /*!< Clock low timeout interrupt flag */
N/* UCB0IFG[UCRXIFG1] Bits */
N#define UCRXIFG1_OFS                             EUSCI_B_IFG_RXIFG1_OFS          /*!< UCRXIFG1 Offset */
N#define UCRXIFG1                                 EUSCI_B_IFG_RXIFG1              /*!< eUSCI_B receive interrupt flag 1 */
N/* UCB0IFG[UCTXIFG1] Bits */
N#define UCTXIFG1_OFS                             EUSCI_B_IFG_TXIFG1_OFS          /*!< UCTXIFG1 Offset */
N#define UCTXIFG1                                 EUSCI_B_IFG_TXIFG1              /*!< eUSCI_B transmit interrupt flag 1 */
N/* UCB0IFG[UCRXIFG2] Bits */
N#define UCRXIFG2_OFS                             EUSCI_B_IFG_RXIFG2_OFS          /*!< UCRXIFG2 Offset */
N#define UCRXIFG2                                 EUSCI_B_IFG_RXIFG2              /*!< eUSCI_B receive interrupt flag 2 */
N/* UCB0IFG[UCTXIFG2] Bits */
N#define UCTXIFG2_OFS                             EUSCI_B_IFG_TXIFG2_OFS          /*!< UCTXIFG2 Offset */
N#define UCTXIFG2                                 EUSCI_B_IFG_TXIFG2              /*!< eUSCI_B transmit interrupt flag 2 */
N/* UCB0IFG[UCRXIFG3] Bits */
N#define UCRXIFG3_OFS                             EUSCI_B_IFG_RXIFG3_OFS          /*!< UCRXIFG3 Offset */
N#define UCRXIFG3                                 EUSCI_B_IFG_RXIFG3              /*!< eUSCI_B receive interrupt flag 3 */
N/* UCB0IFG[UCTXIFG3] Bits */
N#define UCTXIFG3_OFS                             EUSCI_B_IFG_TXIFG3_OFS          /*!< UCTXIFG3 Offset */
N#define UCTXIFG3                                 EUSCI_B_IFG_TXIFG3              /*!< eUSCI_B transmit interrupt flag 3 */
N/* UCB0IFG[UCBIT9IFG] Bits */
N#define UCBIT9IFG_OFS                            EUSCI_B_IFG_BIT9IFG_OFS         /*!< UCBIT9IFG Offset */
N#define UCBIT9IFG                                EUSCI_B_IFG_BIT9IFG             /*!< Bit position 9 interrupt flag */
N/* UCB0IFG_SPI[UCRXIFG] Bits */
N//#define UCRXIFG_OFS                              EUSCI_B_IFG_RXIFG_OFS           /*!< UCRXIFG Offset */
N//#define UCRXIFG                                  EUSCI_B_IFG_RXIFG               /*!< Receive interrupt flag */
N/* UCB0IFG_SPI[UCTXIFG] Bits */
N//#define UCTXIFG_OFS                              EUSCI_B_IFG_TXIFG_OFS           /*!< UCTXIFG Offset */
N//#define UCTXIFG                                  EUSCI_B_IFG_TXIFG               /*!< Transmit interrupt flag */
N
N/******************************************************************************
N* PMAP Bits (legacy section)
N******************************************************************************/
N/* PMAPCTL[PMAPLOCKED] Bits */
N#define PMAPLOCKED_OFS                           PMAP_CTL_LOCKED_OFS             /*!< PMAPLOCKED Offset */
N#define PMAPLOCKED                               PMAP_CTL_LOCKED                 /*!< Port mapping lock bit */
N/* PMAPCTL[PMAPRECFG] Bits */
N#define PMAPRECFG_OFS                            PMAP_CTL_PRECFG_OFS             /*!< PMAPRECFG Offset */
N#define PMAPRECFG                                PMAP_CTL_PRECFG                 /*!< Port mapping reconfiguration control bit */
N/* Pre-defined bitfield values */
N/* PMAP_PMAPCTL[PMAPLOCKED] Bits */
N#define PMAPLOCKED_OFS                                     PMAP_CTL_LOCKED_OFS   /*!< PMAPLOCKED Offset */
N#define PMAPLOCKED                                         PMAP_CTL_LOCKED       /*!< Port mapping lock bit */
N/* PMAP_PMAPCTL[PMAPRECFG] Bits */
N#define PMAPRECFG_OFS                                      PMAP_CTL_PRECFG_OFS   /*!< PMAPRECFG Offset */
N#define PMAPRECFG                                          PMAP_CTL_PRECFG       /*!< Port mapping reconfiguration control bit */
N
N#define PM_NONE                                            PMAP_NONE
N#define PM_UCA0CLK                                         PMAP_UCA0CLK
N#define PM_UCA0RXD                                         PMAP_UCA0RXD
N#define PM_UCA0SOMI                                        PMAP_UCA0SOMI
N#define PM_UCA0TXD                                         PMAP_UCA0TXD
N#define PM_UCA0SIMO                                        PMAP_UCA0SIMO
N#define PM_UCB0CLK                                         PMAP_UCB0CLK
N#define PM_UCB0SDA                                         PMAP_UCB0SDA
N#define PM_UCB0SIMO                                        PMAP_UCB0SIMO
N#define PM_UCB0SCL                                         PMAP_UCB0SCL
N#define PM_UCB0SOMI                                        PMAP_UCB0SOMI
N#define PM_UCA1STE                                         PMAP_UCA1STE
N#define PM_UCA1CLK                                         PMAP_UCA1CLK
N#define PM_UCA1RXD                                         PMAP_UCA1RXD
N#define PM_UCA1SOMI                                        PMAP_UCA1SOMI
N#define PM_UCA1TXD                                         PMAP_UCA1TXD
N#define PM_UCA1SIMO                                        PMAP_UCA1SIMO
N#define PM_UCA2STE                                         PMAP_UCA2STE
N#define PM_UCA2CLK                                         PMAP_UCA2CLK
N#define PM_UCA2RXD                                         PMAP_UCA2RXD
N#define PM_UCA2SOMI                                        PMAP_UCA2SOMI
N#define PM_UCA2TXD                                         PMAP_UCA2TXD
N#define PM_UCA2SIMO                                        PMAP_UCA2SIMO
N#define PM_UCB2STE                                         PMAP_UCB2STE
N#define PM_UCB2CLK                                         PMAP_UCB2CLK
N#define PM_UCB2SDA                                         PMAP_UCB2SDA
N#define PM_UCB2SIMO                                        PMAP_UCB2SIMO
N#define PM_UCB2SCL                                         PMAP_UCB2SCL
N#define PM_UCB2SOMI                                        PMAP_UCB2SOMI
N#define PM_TA0CCR0A                                        PMAP_TA0CCR0A
N#define PM_TA0CCR1A                                        PMAP_TA0CCR1A
N#define PM_TA0CCR2A                                        PMAP_TA0CCR2A
N#define PM_TA0CCR3A                                        PMAP_TA0CCR3A
N#define PM_TA0CCR4A                                        PMAP_TA0CCR4A
N#define PM_TA1CCR1A                                        PMAP_TA1CCR1A
N#define PM_TA1CCR2A                                        PMAP_TA1CCR2A
N#define PM_TA1CCR3A                                        PMAP_TA1CCR3A
N#define PM_TA1CCR4A                                        PMAP_TA1CCR4A
N#define PM_TA0CLK                                          PMAP_TA0CLK
N#define PM_CE0OUT                                          PMAP_CE0OUT
N#define PM_TA1CLK                                          PMAP_TA1CLK
N#define PM_CE1OUT                                          PMAP_CE1OUT
N#define PM_DMAE0                                           PMAP_DMAE0
N#define PM_SMCLK                                           PMAP_SMCLK
N#define PM_ANALOG                                          PMAP_ANALOG
N
N#define PMAPKEY                                            PMAP_KEYID_VAL        /*!< Port Mapping Key */
N#define PMAPPWD                                            PMAP_KEYID_VAL        /*!< Legacy Definition: Mapping Key register */
N#define PMAPPW                                             PMAP_KEYID_VAL        /*!< Legacy Definition: Port Mapping Password */
N
N
N/******************************************************************************
N* REF_A Bits (legacy section)
N******************************************************************************/
N/* REFCTL0[REFON] Bits */
N#define REFON_OFS                                REF_A_CTL0_ON_OFS               /*!< REFON Offset */
N#define REFON                                    REF_A_CTL0_ON                   /*!< Reference enable */
N/* REFCTL0[REFOUT] Bits */
N#define REFOUT_OFS                               REF_A_CTL0_OUT_OFS              /*!< REFOUT Offset */
N#define REFOUT                                   REF_A_CTL0_OUT                  /*!< Reference output buffer */
N/* REFCTL0[REFTCOFF] Bits */
N#define REFTCOFF_OFS                             REF_A_CTL0_TCOFF_OFS            /*!< REFTCOFF Offset */
N#define REFTCOFF                                 REF_A_CTL0_TCOFF                /*!< Temperature sensor disabled */
N/* REFCTL0[REFVSEL] Bits */
N#define REFVSEL_OFS                              REF_A_CTL0_VSEL_OFS             /*!< REFVSEL Offset */
N#define REFVSEL_M                                REF_A_CTL0_VSEL_MASK            /*!< Reference voltage level select */
N#define REFVSEL0                                 REF_A_CTL0_VSEL0                /*!< REFVSEL Bit 0 */
N#define REFVSEL1                                 REF_A_CTL0_VSEL1                /*!< REFVSEL Bit 1 */
N#define REFVSEL_0                                REF_A_CTL0_VSEL_0               /*!< 1.2 V available when reference requested or REFON = 1 */
N#define REFVSEL_1                                REF_A_CTL0_VSEL_1               /*!< 1.45 V available when reference requested or REFON = 1 */
N#define REFVSEL_3                                REF_A_CTL0_VSEL_3               /*!< 2.5 V available when reference requested or REFON = 1 */
N/* REFCTL0[REFGENOT] Bits */
N#define REFGENOT_OFS                             REF_A_CTL0_GENOT_OFS            /*!< REFGENOT Offset */
N#define REFGENOT                                 REF_A_CTL0_GENOT                /*!< Reference generator one-time trigger */
N/* REFCTL0[REFBGOT] Bits */
N#define REFBGOT_OFS                              REF_A_CTL0_BGOT_OFS             /*!< REFBGOT Offset */
N#define REFBGOT                                  REF_A_CTL0_BGOT                 /*!< Bandgap and bandgap buffer one-time trigger */
N/* REFCTL0[REFGENACT] Bits */
N#define REFGENACT_OFS                            REF_A_CTL0_GENACT_OFS           /*!< REFGENACT Offset */
N#define REFGENACT                                REF_A_CTL0_GENACT               /*!< Reference generator active */
N/* REFCTL0[REFBGACT] Bits */
N#define REFBGACT_OFS                             REF_A_CTL0_BGACT_OFS            /*!< REFBGACT Offset */
N#define REFBGACT                                 REF_A_CTL0_BGACT                /*!< Reference bandgap active */
N/* REFCTL0[REFGENBUSY] Bits */
N#define REFGENBUSY_OFS                           REF_A_CTL0_GENBUSY_OFS          /*!< REFGENBUSY Offset */
N#define REFGENBUSY                               REF_A_CTL0_GENBUSY              /*!< Reference generator busy */
N/* REFCTL0[BGMODE] Bits */
N#define BGMODE_OFS                               REF_A_CTL0_BGMODE_OFS           /*!< BGMODE Offset */
N#define BGMODE                                   REF_A_CTL0_BGMODE               /*!< Bandgap mode */
N/* REFCTL0[REFGENRDY] Bits */
N#define REFGENRDY_OFS                            REF_A_CTL0_GENRDY_OFS           /*!< REFGENRDY Offset */
N#define REFGENRDY                                REF_A_CTL0_GENRDY               /*!< Variable reference voltage ready status */
N/* REFCTL0[REFBGRDY] Bits */
N#define REFBGRDY_OFS                             REF_A_CTL0_BGRDY_OFS            /*!< REFBGRDY Offset */
N#define REFBGRDY                                 REF_A_CTL0_BGRDY                /*!< Buffered bandgap voltage ready status */
N
N/******************************************************************************
N* RTC_C Bits (legacy section)
N******************************************************************************/
N/* RTCCTL0[RTCRDYIFG] Bits */
N#define RTCRDYIFG_OFS                            RTC_C_CTL0_RDYIFG_OFS           /*!< RTCRDYIFG Offset */
N#define RTCRDYIFG                                RTC_C_CTL0_RDYIFG               /*!< Real-time clock ready interrupt flag */
N/* RTCCTL0[RTCAIFG] Bits */
N#define RTCAIFG_OFS                              RTC_C_CTL0_AIFG_OFS             /*!< RTCAIFG Offset */
N#define RTCAIFG                                  RTC_C_CTL0_AIFG                 /*!< Real-time clock alarm interrupt flag */
N/* RTCCTL0[RTCTEVIFG] Bits */
N#define RTCTEVIFG_OFS                            RTC_C_CTL0_TEVIFG_OFS           /*!< RTCTEVIFG Offset */
N#define RTCTEVIFG                                RTC_C_CTL0_TEVIFG               /*!< Real-time clock time event interrupt flag */
N/* RTCCTL0[RTCOFIFG] Bits */
N#define RTCOFIFG_OFS                             RTC_C_CTL0_OFIFG_OFS            /*!< RTCOFIFG Offset */
N#define RTCOFIFG                                 RTC_C_CTL0_OFIFG                /*!< 32-kHz crystal oscillator fault interrupt flag */
N/* RTCCTL0[RTCRDYIE] Bits */
N#define RTCRDYIE_OFS                             RTC_C_CTL0_RDYIE_OFS            /*!< RTCRDYIE Offset */
N#define RTCRDYIE                                 RTC_C_CTL0_RDYIE                /*!< Real-time clock ready interrupt enable */
N/* RTCCTL0[RTCAIE] Bits */
N#define RTCAIE_OFS                               RTC_C_CTL0_AIE_OFS              /*!< RTCAIE Offset */
N#define RTCAIE                                   RTC_C_CTL0_AIE                  /*!< Real-time clock alarm interrupt enable */
N/* RTCCTL0[RTCTEVIE] Bits */
N#define RTCTEVIE_OFS                             RTC_C_CTL0_TEVIE_OFS            /*!< RTCTEVIE Offset */
N#define RTCTEVIE                                 RTC_C_CTL0_TEVIE                /*!< Real-time clock time event interrupt enable */
N/* RTCCTL0[RTCOFIE] Bits */
N#define RTCOFIE_OFS                              RTC_C_CTL0_OFIE_OFS             /*!< RTCOFIE Offset */
N#define RTCOFIE                                  RTC_C_CTL0_OFIE                 /*!< 32-kHz crystal oscillator fault interrupt enable */
N/* RTCCTL0[RTCKEY] Bits */
N#define RTCKEY_OFS                               RTC_C_CTL0_KEY_OFS              /*!< RTCKEY Offset */
N#define RTCKEY_M                                 RTC_C_CTL0_KEY_MASK             /*!< Real-time clock key */
N/* RTCCTL13[RTCTEV] Bits */
N#define RTCTEV_OFS                               RTC_C_CTL13_TEV_OFS             /*!< RTCTEV Offset */
N#define RTCTEV_M                                 RTC_C_CTL13_TEV_MASK            /*!< Real-time clock time event */
N#define RTCTEV0                                  RTC_C_CTL13_TEV0                /*!< RTCTEV Bit 0 */
N#define RTCTEV1                                  RTC_C_CTL13_TEV1                /*!< RTCTEV Bit 1 */
N#define RTCTEV_0                                 RTC_C_CTL13_TEV_0               /*!< Minute changed */
N#define RTCTEV_1                                 RTC_C_CTL13_TEV_1               /*!< Hour changed */
N#define RTCTEV_2                                 RTC_C_CTL13_TEV_2               /*!< Every day at midnight (00:00) */
N#define RTCTEV_3                                 RTC_C_CTL13_TEV_3               /*!< Every day at noon (12:00) */
N/* RTCCTL13[RTCSSEL] Bits */
N#define RTCSSEL_OFS                              RTC_C_CTL13_SSEL_OFS            /*!< RTCSSEL Offset */
N#define RTCSSEL_M                                RTC_C_CTL13_SSEL_MASK           /*!< Real-time clock source select */
N#define RTCSSEL0                                 RTC_C_CTL13_SSEL0               /*!< RTCSSEL Bit 0 */
N#define RTCSSEL1                                 RTC_C_CTL13_SSEL1               /*!< RTCSSEL Bit 1 */
N#define RTCSSEL_0                                RTC_C_CTL13_SSEL_0              /*!< BCLK */
N#define RTCSSEL__BCLK                            RTC_C_CTL13_SSEL__BCLK          /*!< BCLK */
N/* RTCCTL13[RTCRDY] Bits */
N#define RTCRDY_OFS                               RTC_C_CTL13_RDY_OFS             /*!< RTCRDY Offset */
N#define RTCRDY                                   RTC_C_CTL13_RDY                 /*!< Real-time clock ready */
N/* RTCCTL13[RTCMODE] Bits */
N#define RTCMODE_OFS                              RTC_C_CTL13_MODE_OFS            /*!< RTCMODE Offset */
N#define RTCMODE                                  RTC_C_CTL13_MODE                
N/* RTCCTL13[RTCHOLD] Bits */
N#define RTCHOLD_OFS                              RTC_C_CTL13_HOLD_OFS            /*!< RTCHOLD Offset */
N#define RTCHOLD                                  RTC_C_CTL13_HOLD                /*!< Real-time clock hold */
N/* RTCCTL13[RTCBCD] Bits */
N#define RTCBCD_OFS                               RTC_C_CTL13_BCD_OFS             /*!< RTCBCD Offset */
N#define RTCBCD                                   RTC_C_CTL13_BCD                 /*!< Real-time clock BCD select */
N/* RTCCTL13[RTCCALF] Bits */
N#define RTCCALF_OFS                              RTC_C_CTL13_CALF_OFS            /*!< RTCCALF Offset */
N#define RTCCALF_M                                RTC_C_CTL13_CALF_MASK           /*!< Real-time clock calibration frequency */
N#define RTCCALF0                                 RTC_C_CTL13_CALF0               /*!< RTCCALF Bit 0 */
N#define RTCCALF1                                 RTC_C_CTL13_CALF1               /*!< RTCCALF Bit 1 */
N#define RTCCALF_0                                RTC_C_CTL13_CALF_0              /*!< No frequency output to RTCCLK pin */
N#define RTCCALF_1                                RTC_C_CTL13_CALF_1              /*!< 512 Hz */
N#define RTCCALF_2                                RTC_C_CTL13_CALF_2              /*!< 256 Hz */
N#define RTCCALF_3                                RTC_C_CTL13_CALF_3              /*!< 1 Hz */
N#define RTCCALF__NONE                            RTC_C_CTL13_CALF__NONE          /*!< No frequency output to RTCCLK pin */
N#define RTCCALF__512                             RTC_C_CTL13_CALF__512           /*!< 512 Hz */
N#define RTCCALF__256                             RTC_C_CTL13_CALF__256           /*!< 256 Hz */
N#define RTCCALF__1                               RTC_C_CTL13_CALF__1             /*!< 1 Hz */
N/* RTCOCAL[RTCOCAL] Bits */
N#define RTCOCAL_OFS                              RTC_C_OCAL_OCAL_OFS             /*!< RTCOCAL Offset */
N#define RTCOCAL_M                                RTC_C_OCAL_OCAL_MASK            /*!< Real-time clock offset error calibration */
N/* RTCOCAL[RTCOCALS] Bits */
N#define RTCOCALS_OFS                             RTC_C_OCAL_OCALS_OFS            /*!< RTCOCALS Offset */
N#define RTCOCALS                                 RTC_C_OCAL_OCALS                /*!< Real-time clock offset error calibration sign */
N/* RTCTCMP[RTCTCMP] Bits */
N#define RTCTCMP_OFS                              RTC_C_TCMP_TCMPX_OFS            /*!< RTCTCMP Offset */
N#define RTCTCMP_M                                RTC_C_TCMP_TCMPX_MASK           /*!< Real-time clock temperature compensation */
N/* RTCTCMP[RTCTCOK] Bits */
N#define RTCTCOK_OFS                              RTC_C_TCMP_TCOK_OFS             /*!< RTCTCOK Offset */
N#define RTCTCOK                                  RTC_C_TCMP_TCOK                 /*!< Real-time clock temperature compensation write OK */
N/* RTCTCMP[RTCTCRDY] Bits */
N#define RTCTCRDY_OFS                             RTC_C_TCMP_TCRDY_OFS            /*!< RTCTCRDY Offset */
N#define RTCTCRDY                                 RTC_C_TCMP_TCRDY                /*!< Real-time clock temperature compensation ready */
N/* RTCTCMP[RTCTCMPS] Bits */
N#define RTCTCMPS_OFS                             RTC_C_TCMP_TCMPS_OFS            /*!< RTCTCMPS Offset */
N#define RTCTCMPS                                 RTC_C_TCMP_TCMPS                /*!< Real-time clock temperature compensation sign */
N/* RTCPS0CTL[RT0PSIFG] Bits */
N#define RT0PSIFG_OFS                             RTC_C_PS0CTL_RT0PSIFG_OFS       /*!< RT0PSIFG Offset */
N#define RT0PSIFG                                 RTC_C_PS0CTL_RT0PSIFG           /*!< Prescale timer 0 interrupt flag */
N/* RTCPS0CTL[RT0PSIE] Bits */
N#define RT0PSIE_OFS                              RTC_C_PS0CTL_RT0PSIE_OFS        /*!< RT0PSIE Offset */
N#define RT0PSIE                                  RTC_C_PS0CTL_RT0PSIE            /*!< Prescale timer 0 interrupt enable */
N/* RTCPS0CTL[RT0IP] Bits */
N#define RT0IP_OFS                                RTC_C_PS0CTL_RT0IP_OFS          /*!< RT0IP Offset */
N#define RT0IP_M                                  RTC_C_PS0CTL_RT0IP_MASK         /*!< Prescale timer 0 interrupt interval */
N#define RT0IP0                                   RTC_C_PS0CTL_RT0IP0             /*!< RT0IP Bit 0 */
N#define RT0IP1                                   RTC_C_PS0CTL_RT0IP1             /*!< RT0IP Bit 1 */
N#define RT0IP2                                   RTC_C_PS0CTL_RT0IP2             /*!< RT0IP Bit 2 */
N#define RT0IP_0                                  RTC_C_PS0CTL_RT0IP_0            /*!< Divide by 2 */
N#define RT0IP_1                                  RTC_C_PS0CTL_RT0IP_1            /*!< Divide by 4 */
N#define RT0IP_2                                  RTC_C_PS0CTL_RT0IP_2            /*!< Divide by 8 */
N#define RT0IP_3                                  RTC_C_PS0CTL_RT0IP_3            /*!< Divide by 16 */
N#define RT0IP_4                                  RTC_C_PS0CTL_RT0IP_4            /*!< Divide by 32 */
N#define RT0IP_5                                  RTC_C_PS0CTL_RT0IP_5            /*!< Divide by 64 */
N#define RT0IP_6                                  RTC_C_PS0CTL_RT0IP_6            /*!< Divide by 128 */
N#define RT0IP_7                                  RTC_C_PS0CTL_RT0IP_7            /*!< Divide by 256 */
N#define RT0IP__2                                 RTC_C_PS0CTL_RT0IP__2           /*!< Divide by 2 */
N#define RT0IP__4                                 RTC_C_PS0CTL_RT0IP__4           /*!< Divide by 4 */
N#define RT0IP__8                                 RTC_C_PS0CTL_RT0IP__8           /*!< Divide by 8 */
N#define RT0IP__16                                RTC_C_PS0CTL_RT0IP__16          /*!< Divide by 16 */
N#define RT0IP__32                                RTC_C_PS0CTL_RT0IP__32          /*!< Divide by 32 */
N#define RT0IP__64                                RTC_C_PS0CTL_RT0IP__64          /*!< Divide by 64 */
N#define RT0IP__128                               RTC_C_PS0CTL_RT0IP__128         /*!< Divide by 128 */
N#define RT0IP__256                               RTC_C_PS0CTL_RT0IP__256         /*!< Divide by 256 */
N/* RTCPS1CTL[RT1PSIFG] Bits */
N#define RT1PSIFG_OFS                             RTC_C_PS1CTL_RT1PSIFG_OFS       /*!< RT1PSIFG Offset */
N#define RT1PSIFG                                 RTC_C_PS1CTL_RT1PSIFG           /*!< Prescale timer 1 interrupt flag */
N/* RTCPS1CTL[RT1PSIE] Bits */
N#define RT1PSIE_OFS                              RTC_C_PS1CTL_RT1PSIE_OFS        /*!< RT1PSIE Offset */
N#define RT1PSIE                                  RTC_C_PS1CTL_RT1PSIE            /*!< Prescale timer 1 interrupt enable */
N/* RTCPS1CTL[RT1IP] Bits */
N#define RT1IP_OFS                                RTC_C_PS1CTL_RT1IP_OFS          /*!< RT1IP Offset */
N#define RT1IP_M                                  RTC_C_PS1CTL_RT1IP_MASK         /*!< Prescale timer 1 interrupt interval */
N#define RT1IP0                                   RTC_C_PS1CTL_RT1IP0             /*!< RT1IP Bit 0 */
N#define RT1IP1                                   RTC_C_PS1CTL_RT1IP1             /*!< RT1IP Bit 1 */
N#define RT1IP2                                   RTC_C_PS1CTL_RT1IP2             /*!< RT1IP Bit 2 */
N#define RT1IP_0                                  RTC_C_PS1CTL_RT1IP_0            /*!< Divide by 2 */
N#define RT1IP_1                                  RTC_C_PS1CTL_RT1IP_1            /*!< Divide by 4 */
N#define RT1IP_2                                  RTC_C_PS1CTL_RT1IP_2            /*!< Divide by 8 */
N#define RT1IP_3                                  RTC_C_PS1CTL_RT1IP_3            /*!< Divide by 16 */
N#define RT1IP_4                                  RTC_C_PS1CTL_RT1IP_4            /*!< Divide by 32 */
N#define RT1IP_5                                  RTC_C_PS1CTL_RT1IP_5            /*!< Divide by 64 */
N#define RT1IP_6                                  RTC_C_PS1CTL_RT1IP_6            /*!< Divide by 128 */
N#define RT1IP_7                                  RTC_C_PS1CTL_RT1IP_7            /*!< Divide by 256 */
N#define RT1IP__2                                 RTC_C_PS1CTL_RT1IP__2           /*!< Divide by 2 */
N#define RT1IP__4                                 RTC_C_PS1CTL_RT1IP__4           /*!< Divide by 4 */
N#define RT1IP__8                                 RTC_C_PS1CTL_RT1IP__8           /*!< Divide by 8 */
N#define RT1IP__16                                RTC_C_PS1CTL_RT1IP__16          /*!< Divide by 16 */
N#define RT1IP__32                                RTC_C_PS1CTL_RT1IP__32          /*!< Divide by 32 */
N#define RT1IP__64                                RTC_C_PS1CTL_RT1IP__64          /*!< Divide by 64 */
N#define RT1IP__128                               RTC_C_PS1CTL_RT1IP__128         /*!< Divide by 128 */
N#define RT1IP__256                               RTC_C_PS1CTL_RT1IP__256         /*!< Divide by 256 */
N/* RTCPS[RT0PS] Bits */
N#define RT0PS_OFS                                RTC_C_PS_RT0PS_OFS              /*!< RT0PS Offset */
N#define RT0PS_M                                  RTC_C_PS_RT0PS_MASK             /*!< Prescale timer 0 counter value */
N/* RTCPS[RT1PS] Bits */
N#define RT1PS_OFS                                RTC_C_PS_RT1PS_OFS              /*!< RT1PS Offset */
N#define RT1PS_M                                  RTC_C_PS_RT1PS_MASK             /*!< Prescale timer 1 counter value */
N/* RTCTIM0[SECONDS] Bits */
N#define SECONDS_OFS                              RTC_C_TIM0_SEC_OFS              /*!< Seconds Offset */
N#define SECONDS_M                                RTC_C_TIM0_SEC_MASK             /*!< Seconds (0 to 59) */
N/* RTCTIM0[MINUTES] Bits */
N#define MINUTES_OFS                              RTC_C_TIM0_MIN_OFS              /*!< Minutes Offset */
N#define MINUTES_M                                RTC_C_TIM0_MIN_MASK             /*!< Minutes (0 to 59) */
N/* RTCTIM0_BCD[SECONDSLOWDIGIT] Bits */
N#define SECONDSLOWDIGIT_OFS                      RTC_C_TIM0_SEC_LD_OFS           /*!< SecondsLowDigit Offset */
N#define SECONDSLOWDIGIT_M                        RTC_C_TIM0_SEC_LD_MASK          /*!< Seconds  low digit (0 to 9) */
N/* RTCTIM0_BCD[SECONDSHIGHDIGIT] Bits */
N#define SECONDSHIGHDIGIT_OFS                     RTC_C_TIM0_SEC_HD_OFS           /*!< SecondsHighDigit Offset */
N#define SECONDSHIGHDIGIT_M                       RTC_C_TIM0_SEC_HD_MASK          /*!< Seconds  high digit (0 to 5) */
N/* RTCTIM0_BCD[MINUTESLOWDIGIT] Bits */
N#define MINUTESLOWDIGIT_OFS                      RTC_C_TIM0_MIN_LD_OFS           /*!< MinutesLowDigit Offset */
N#define MINUTESLOWDIGIT_M                        RTC_C_TIM0_MIN_LD_MASK          /*!< Minutes  low digit (0 to 9) */
N/* RTCTIM0_BCD[MINUTESHIGHDIGIT] Bits */
N#define MINUTESHIGHDIGIT_OFS                     RTC_C_TIM0_MIN_HD_OFS           /*!< MinutesHighDigit Offset */
N#define MINUTESHIGHDIGIT_M                       RTC_C_TIM0_MIN_HD_MASK          /*!< Minutes  high digit (0 to 5) */
N/* RTCTIM1[HOURS] Bits */
N#define HOURS_OFS                                RTC_C_TIM1_HOUR_OFS             /*!< Hours Offset */
N#define HOURS_M                                  RTC_C_TIM1_HOUR_MASK            /*!< Hours (0 to 23) */
N/* RTCTIM1[DAYOFWEEK] Bits */
N#define DAYOFWEEK_OFS                            RTC_C_TIM1_DOW_OFS              /*!< DayofWeek Offset */
N#define DAYOFWEEK_M                              RTC_C_TIM1_DOW_MASK             /*!< Day of week (0 to 6) */
N/* RTCTIM1_BCD[HOURSLOWDIGIT] Bits */
N#define HOURSLOWDIGIT_OFS                        RTC_C_TIM1_HOUR_LD_OFS          /*!< HoursLowDigit Offset */
N#define HOURSLOWDIGIT_M                          RTC_C_TIM1_HOUR_LD_MASK         /*!< Hours  low digit (0 to 9) */
N/* RTCTIM1_BCD[HOURSHIGHDIGIT] Bits */
N#define HOURSHIGHDIGIT_OFS                       RTC_C_TIM1_HOUR_HD_OFS          /*!< HoursHighDigit Offset */
N#define HOURSHIGHDIGIT_M                         RTC_C_TIM1_HOUR_HD_MASK         /*!< Hours  high digit (0 to 2) */
N/* RTCTIM1_BCD[DAYOFWEEK] Bits */
N//#define DAYOFWEEK_OFS                            RTC_C_TIM1_DOW_OFS              /*!< DayofWeek Offset */
N//#define DAYOFWEEK_M                              RTC_C_TIM1_DOW_MASK             /*!< Day of week (0 to 6) */
N/* RTCDATE[DAY] Bits */
N#define DAY_OFS                                  RTC_C_DATE_DAY_OFS              /*!< Day Offset */
N#define DAY_M                                    RTC_C_DATE_DAY_MASK             /*!< Day of month (1 to 28, 29, 30, 31) */
N/* RTCDATE[MONTH] Bits */
N#define MONTH_OFS                                RTC_C_DATE_MON_OFS              /*!< Month Offset */
N#define MONTH_M                                  RTC_C_DATE_MON_MASK             /*!< Month (1 to 12) */
N/* RTCDATE_BCD[DAYLOWDIGIT] Bits */
N#define DAYLOWDIGIT_OFS                          RTC_C_DATE_DAY_LD_OFS           /*!< DayLowDigit Offset */
N#define DAYLOWDIGIT_M                            RTC_C_DATE_DAY_LD_MASK          /*!< Day of month  low digit (0 to 9) */
N/* RTCDATE_BCD[DAYHIGHDIGIT] Bits */
N#define DAYHIGHDIGIT_OFS                         RTC_C_DATE_DAY_HD_OFS           /*!< DayHighDigit Offset */
N#define DAYHIGHDIGIT_M                           RTC_C_DATE_DAY_HD_MASK          /*!< Day of month  high digit (0 to 3) */
N/* RTCDATE_BCD[MONTHLOWDIGIT] Bits */
N#define MONTHLOWDIGIT_OFS                        RTC_C_DATE_MON_LD_OFS           /*!< MonthLowDigit Offset */
N#define MONTHLOWDIGIT_M                          RTC_C_DATE_MON_LD_MASK          /*!< Month  low digit (0 to 9) */
N/* RTCDATE_BCD[MONTHHIGHDIGIT] Bits */
N#define MONTHHIGHDIGIT_OFS                       RTC_C_DATE_MON_HD_OFS           /*!< MonthHighDigit Offset */
N#define MONTHHIGHDIGIT                           RTC_C_DATE_MON_HD               /*!< Month  high digit (0 or 1) */
N/* RTCYEAR[YEARLOWBYTE] Bits */
N#define YEARLOWBYTE_OFS                          RTC_C_YEAR_YEAR_LB_OFS          /*!< YearLowByte Offset */
N#define YEARLOWBYTE_M                            RTC_C_YEAR_YEAR_LB_MASK         /*!< Year  low byte. Valid values for Year are 0 to 4095. */
N/* RTCYEAR[YEARHIGHBYTE] Bits */
N#define YEARHIGHBYTE_OFS                         RTC_C_YEAR_YEAR_HB_OFS          /*!< YearHighByte Offset */
N#define YEARHIGHBYTE_M                           RTC_C_YEAR_YEAR_HB_MASK         /*!< Year  high byte. Valid values for Year are 0 to 4095. */
N/* RTCYEAR_BCD[YEAR] Bits */
N#define YEAR_OFS                                 RTC_C_YEAR_YEAR_OFS             /*!< Year Offset */
N#define YEAR_M                                   RTC_C_YEAR_YEAR_MASK            /*!< Year  lowest digit (0 to 9) */
N/* RTCYEAR_BCD[DECADE] Bits */
N#define DECADE_OFS                               RTC_C_YEAR_DEC_OFS              /*!< Decade Offset */
N#define DECADE_M                                 RTC_C_YEAR_DEC_MASK             /*!< Decade (0 to 9) */
N/* RTCYEAR_BCD[CENTURYLOWDIGIT] Bits */
N#define CENTURYLOWDIGIT_OFS                      RTC_C_YEAR_CENT_LD_OFS          /*!< CenturyLowDigit Offset */
N#define CENTURYLOWDIGIT_M                        RTC_C_YEAR_CENT_LD_MASK         /*!< Century  low digit (0 to 9) */
N/* RTCYEAR_BCD[CENTURYHIGHDIGIT] Bits */
N#define CENTURYHIGHDIGIT_OFS                     RTC_C_YEAR_CENT_HD_OFS          /*!< CenturyHighDigit Offset */
N#define CENTURYHIGHDIGIT_M                       RTC_C_YEAR_CENT_HD_MASK         /*!< Century  high digit (0 to 4) */
N/* RTCAMINHR[MINUTES] Bits */
N//#define MINUTES_OFS                              RTC_C_AMINHR_MIN_OFS            /*!< Minutes Offset */
N//#define MINUTES_M                                RTC_C_AMINHR_MIN_MASK           /*!< Minutes (0 to 59) */
N/* RTCAMINHR[MINAE] Bits */
N#define MINAE_OFS                                RTC_C_AMINHR_MINAE_OFS          /*!< MINAE Offset */
N#define MINAE                                    RTC_C_AMINHR_MINAE              /*!< Alarm enable */
N/* RTCAMINHR[HOURS] Bits */
N//#define HOURS_OFS                                RTC_C_AMINHR_HOUR_OFS           /*!< Hours Offset */
N//#define HOURS_M                                  RTC_C_AMINHR_HOUR_MASK          /*!< Hours (0 to 23) */
N/* RTCAMINHR[HOURAE] Bits */
N#define HOURAE_OFS                               RTC_C_AMINHR_HOURAE_OFS         /*!< HOURAE Offset */
N#define HOURAE                                   RTC_C_AMINHR_HOURAE             /*!< Alarm enable */
N/* RTCAMINHR_BCD[MINUTESLOWDIGIT] Bits */
N//#define MINUTESLOWDIGIT_OFS                      RTC_C_AMINHR_MIN_LD_OFS         /*!< MinutesLowDigit Offset */
N//#define MINUTESLOWDIGIT_M                        RTC_C_AMINHR_MIN_LD_MASK        /*!< Minutes  low digit (0 to 9) */
N/* RTCAMINHR_BCD[MINUTESHIGHDIGIT] Bits */
N//#define MINUTESHIGHDIGIT_OFS                     RTC_C_AMINHR_MIN_HD_OFS         /*!< MinutesHighDigit Offset */
N//#define MINUTESHIGHDIGIT_M                       RTC_C_AMINHR_MIN_HD_MASK        /*!< Minutes  high digit (0 to 5) */
N/* RTCAMINHR_BCD[MINAE] Bits */
N//#define MINAE_OFS                                RTC_C_AMINHR_MINAE_OFS          /*!< MINAE Offset */
N//#define MINAE                                    RTC_C_AMINHR_MINAE              /*!< Alarm enable */
N/* RTCAMINHR_BCD[HOURSLOWDIGIT] Bits */
N//#define HOURSLOWDIGIT_OFS                        RTC_C_AMINHR_HOUR_LD_OFS        /*!< HoursLowDigit Offset */
N//#define HOURSLOWDIGIT_M                          RTC_C_AMINHR_HOUR_LD_MASK       /*!< Hours  low digit (0 to 9) */
N/* RTCAMINHR_BCD[HOURSHIGHDIGIT] Bits */
N//#define HOURSHIGHDIGIT_OFS                       RTC_C_AMINHR_HOUR_HD_OFS        /*!< HoursHighDigit Offset */
N//#define HOURSHIGHDIGIT_M                         RTC_C_AMINHR_HOUR_HD_MASK       /*!< Hours  high digit (0 to 2) */
N/* RTCAMINHR_BCD[HOURAE] Bits */
N//#define HOURAE_OFS                               RTC_C_AMINHR_HOURAE_OFS         /*!< HOURAE Offset */
N//#define HOURAE                                   RTC_C_AMINHR_HOURAE             /*!< Alarm enable */
N/* RTCADOWDAY[DAYOFWEEK] Bits */
N//#define DAYOFWEEK_OFS                            RTC_C_ADOWDAY_DOW_OFS           /*!< DayofWeek Offset */
N//#define DAYOFWEEK_M                              RTC_C_ADOWDAY_DOW_MASK          /*!< Day of week (0 to 6) */
N/* RTCADOWDAY[DOWAE] Bits */
N#define DOWAE_OFS                                RTC_C_ADOWDAY_DOWAE_OFS         /*!< DOWAE Offset */
N#define DOWAE                                    RTC_C_ADOWDAY_DOWAE             /*!< Alarm enable */
N/* RTCADOWDAY[DAYOFMONTH] Bits */
N#define DAYOFMONTH_OFS                           RTC_C_ADOWDAY_DAY_OFS           /*!< DayofMonth Offset */
N#define DAYOFMONTH_M                             RTC_C_ADOWDAY_DAY_MASK          /*!< Day of month (1 to 28, 29, 30, 31) */
N/* RTCADOWDAY[DAYAE] Bits */
N#define DAYAE_OFS                                RTC_C_ADOWDAY_DAYAE_OFS         /*!< DAYAE Offset */
N#define DAYAE                                    RTC_C_ADOWDAY_DAYAE             /*!< Alarm enable */
N/* RTCADOWDAY_BCD[DAYOFWEEK] Bits */
N//#define DAYOFWEEK_OFS                            RTC_C_ADOWDAY_DOW_OFS           /*!< DayofWeek Offset */
N//#define DAYOFWEEK_M                              RTC_C_ADOWDAY_DOW_MASK          /*!< Day of week (0 to 6) */
N/* RTCADOWDAY_BCD[DOWAE] Bits */
N//#define DOWAE_OFS                                RTC_C_ADOWDAY_DOWAE_OFS         /*!< DOWAE Offset */
N//#define DOWAE                                    RTC_C_ADOWDAY_DOWAE             /*!< Alarm enable */
N/* RTCADOWDAY_BCD[DAYLOWDIGIT] Bits */
N//#define DAYLOWDIGIT_OFS                          RTC_C_ADOWDAY_DAY_LD_OFS        /*!< DayLowDigit Offset */
N//#define DAYLOWDIGIT_M                            RTC_C_ADOWDAY_DAY_LD_MASK       /*!< Day of month  low digit (0 to 9) */
N/* RTCADOWDAY_BCD[DAYHIGHDIGIT] Bits */
N//#define DAYHIGHDIGIT_OFS                         RTC_C_ADOWDAY_DAY_HD_OFS        /*!< DayHighDigit Offset */
N//#define DAYHIGHDIGIT_M                           RTC_C_ADOWDAY_DAY_HD_MASK       /*!< Day of month  high digit (0 to 3) */
N/* RTCADOWDAY_BCD[DAYAE] Bits */
N//#define DAYAE_OFS                                RTC_C_ADOWDAY_DAYAE_OFS         /*!< DAYAE Offset */
N//#define DAYAE                                    RTC_C_ADOWDAY_DAYAE             /*!< Alarm enable */
N/* Pre-defined bitfield values */
N#define RTCKEY                                             RTC_C_KEY              /*!< RTC_C Key Value for RTC_C write access */
N#define RTCKEY_H                                           RTC_C_KEY_H            /*!< RTC_C Key Value for RTC_C write access */
N#define RTCKEY_VAL                                         RTC_C_KEY_VAL          /*!< RTC_C Key Value for RTC_C write access */
N
N
N/******************************************************************************
N* TIMER_A Bits (legacy section)
N******************************************************************************/
N/* TA0CTL[TAIFG] Bits */
N#define TAIFG_OFS                                TIMER_A_CTL_IFG_OFS             /*!< TAIFG Offset */
N#define TAIFG                                    TIMER_A_CTL_IFG                 /*!< TimerA interrupt flag */
N/* TA0CTL[TAIE] Bits */
N#define TAIE_OFS                                 TIMER_A_CTL_IE_OFS              /*!< TAIE Offset */
N#define TAIE                                     TIMER_A_CTL_IE                  /*!< TimerA interrupt enable */
N/* TA0CTL[TACLR] Bits */
N#define TACLR_OFS                                TIMER_A_CTL_CLR_OFS             /*!< TACLR Offset */
N#define TACLR                                    TIMER_A_CTL_CLR                 /*!< TimerA clear */
N/* TA0CTL[MC] Bits */
N#define MC_OFS                                   TIMER_A_CTL_MC_OFS              /*!< MC Offset */
N#define MC_M                                     TIMER_A_CTL_MC_MASK             /*!< Mode control */
N#define MC0                                      TIMER_A_CTL_MC0                 /*!< MC Bit 0 */
N#define MC1                                      TIMER_A_CTL_MC1                 /*!< MC Bit 1 */
N#define MC_0                                     TIMER_A_CTL_MC_0                /*!< Stop mode: Timer is halted */
N#define MC_1                                     TIMER_A_CTL_MC_1                /*!< Up mode: Timer counts up to TAxCCR0 */
N#define MC_2                                     TIMER_A_CTL_MC_2                /*!< Continuous mode: Timer counts up to 0FFFFh */
N#define MC_3                                     TIMER_A_CTL_MC_3                /*!< Up/down mode: Timer counts up to TAxCCR0 then down to 0000h */
N#define MC__STOP                                 TIMER_A_CTL_MC__STOP            /*!< Stop mode: Timer is halted */
N#define MC__UP                                   TIMER_A_CTL_MC__UP              /*!< Up mode: Timer counts up to TAxCCR0 */
N#define MC__CONTINUOUS                           TIMER_A_CTL_MC__CONTINUOUS      /*!< Continuous mode: Timer counts up to 0FFFFh */
N#define MC__UPDOWN                               TIMER_A_CTL_MC__UPDOWN          /*!< Up/down mode: Timer counts up to TAxCCR0 then down to 0000h */
N/* TA0CTL[ID] Bits */
N#define ID_OFS                                   TIMER_A_CTL_ID_OFS              /*!< ID Offset */
N#define ID_M                                     TIMER_A_CTL_ID_MASK             /*!< Input divider */
N#define ID0                                      TIMER_A_CTL_ID0                 /*!< ID Bit 0 */
N#define ID1                                      TIMER_A_CTL_ID1                 /*!< ID Bit 1 */
N#define ID_0                                     TIMER_A_CTL_ID_0                /*!< /1 */
N#define ID_1                                     TIMER_A_CTL_ID_1                /*!< /2 */
N#define ID_2                                     TIMER_A_CTL_ID_2                /*!< /4 */
N#define ID_3                                     TIMER_A_CTL_ID_3                /*!< /8 */
N#define ID__1                                    TIMER_A_CTL_ID__1               /*!< /1 */
N#define ID__2                                    TIMER_A_CTL_ID__2               /*!< /2 */
N#define ID__4                                    TIMER_A_CTL_ID__4               /*!< /4 */
N#define ID__8                                    TIMER_A_CTL_ID__8               /*!< /8 */
N/* TA0CTL[TASSEL] Bits */
N#define TASSEL_OFS                               TIMER_A_CTL_SSEL_OFS            /*!< TASSEL Offset */
N#define TASSEL_M                                 TIMER_A_CTL_SSEL_MASK           /*!< TimerA clock source select */
N#define TASSEL0                                  TIMER_A_CTL_SSEL0               /*!< TASSEL Bit 0 */
N#define TASSEL1                                  TIMER_A_CTL_SSEL1               /*!< TASSEL Bit 1 */
N#define TASSEL_0                                 TIMER_A_CTL_TASSEL_0            /*!< TAxCLK */
N#define TASSEL_1                                 TIMER_A_CTL_TASSEL_1            /*!< ACLK */
N#define TASSEL_2                                 TIMER_A_CTL_TASSEL_2            /*!< SMCLK */
N#define TASSEL_3                                 TIMER_A_CTL_TASSEL_3            /*!< INCLK */
N#define TASSEL__TACLK                            TIMER_A_CTL_SSEL__TACLK         /*!< TAxCLK */
N#define TASSEL__ACLK                             TIMER_A_CTL_SSEL__ACLK          /*!< ACLK */
N#define TASSEL__SMCLK                            TIMER_A_CTL_SSEL__SMCLK         /*!< SMCLK */
N#define TASSEL__INCLK                            TIMER_A_CTL_SSEL__INCLK         /*!< INCLK */
N/* TA0CCTLn[CCIFG] Bits */
N#define CCIFG_OFS                                TIMER_A_CCTLN_CCIFG_OFS         /*!< CCIFG Offset */
N#define CCIFG                                    TIMER_A_CCTLN_CCIFG             /*!< Capture/compare interrupt flag */
N/* TA0CCTLn[COV] Bits */
N#define COV_OFS                                  TIMER_A_CCTLN_COV_OFS           /*!< COV Offset */
N#define COV                                      TIMER_A_CCTLN_COV               /*!< Capture overflow */
N/* TA0CCTLn[OUT] Bits */
N#define OUT_OFS                                  TIMER_A_CCTLN_OUT_OFS           /*!< OUT Offset */
N//#define OUT                                      TIMER_A_CCTLN_OUT               /*!< Output */
N/* TA0CCTLn[CCI] Bits */
N#define CCI_OFS                                  TIMER_A_CCTLN_CCI_OFS           /*!< CCI Offset */
N#define CCI                                      TIMER_A_CCTLN_CCI               /*!< Capture/compare input */
N/* TA0CCTLn[CCIE] Bits */
N#define CCIE_OFS                                 TIMER_A_CCTLN_CCIE_OFS          /*!< CCIE Offset */
N#define CCIE                                     TIMER_A_CCTLN_CCIE              /*!< Capture/compare interrupt enable */
N/* TA0CCTLn[OUTMOD] Bits */
N#define OUTMOD_OFS                               TIMER_A_CCTLN_OUTMOD_OFS        /*!< OUTMOD Offset */
N#define OUTMOD_M                                 TIMER_A_CCTLN_OUTMOD_MASK       /*!< Output mode */
N#define OUTMOD0                                  TIMER_A_CCTLN_OUTMOD0           /*!< OUTMOD Bit 0 */
N#define OUTMOD1                                  TIMER_A_CCTLN_OUTMOD1           /*!< OUTMOD Bit 1 */
N#define OUTMOD2                                  TIMER_A_CCTLN_OUTMOD2           /*!< OUTMOD Bit 2 */
N#define OUTMOD_0                                 TIMER_A_CCTLN_OUTMOD_0          /*!< OUT bit value */
N#define OUTMOD_1                                 TIMER_A_CCTLN_OUTMOD_1          /*!< Set */
N#define OUTMOD_2                                 TIMER_A_CCTLN_OUTMOD_2          /*!< Toggle/reset */
N#define OUTMOD_3                                 TIMER_A_CCTLN_OUTMOD_3          /*!< Set/reset */
N#define OUTMOD_4                                 TIMER_A_CCTLN_OUTMOD_4          /*!< Toggle */
N#define OUTMOD_5                                 TIMER_A_CCTLN_OUTMOD_5          /*!< Reset */
N#define OUTMOD_6                                 TIMER_A_CCTLN_OUTMOD_6          /*!< Toggle/set */
N#define OUTMOD_7                                 TIMER_A_CCTLN_OUTMOD_7          /*!< Reset/set */
N/* TA0CCTLn[CAP] Bits */
N#define CAP_OFS                                  TIMER_A_CCTLN_CAP_OFS           /*!< CAP Offset */
N#define CAP                                      TIMER_A_CCTLN_CAP               /*!< Capture mode */
N/* TA0CCTLn[SCCI] Bits */
N#define SCCI_OFS                                 TIMER_A_CCTLN_SCCI_OFS          /*!< SCCI Offset */
N#define SCCI                                     TIMER_A_CCTLN_SCCI              /*!< Synchronized capture/compare input */
N/* TA0CCTLn[SCS] Bits */
N#define SCS_OFS                                  TIMER_A_CCTLN_SCS_OFS           /*!< SCS Offset */
N#define SCS                                      TIMER_A_CCTLN_SCS               /*!< Synchronize capture source */
N/* TA0CCTLn[CCIS] Bits */
N#define CCIS_OFS                                 TIMER_A_CCTLN_CCIS_OFS          /*!< CCIS Offset */
N#define CCIS_M                                   TIMER_A_CCTLN_CCIS_MASK         /*!< Capture/compare input select */
N#define CCIS0                                    TIMER_A_CCTLN_CCIS0             /*!< CCIS Bit 0 */
N#define CCIS1                                    TIMER_A_CCTLN_CCIS1             /*!< CCIS Bit 1 */
N#define CCIS_0                                   TIMER_A_CCTLN_CCIS_0            /*!< CCIxA */
N#define CCIS_1                                   TIMER_A_CCTLN_CCIS_1            /*!< CCIxB */
N#define CCIS_2                                   TIMER_A_CCTLN_CCIS_2            /*!< GND */
N#define CCIS_3                                   TIMER_A_CCTLN_CCIS_3            /*!< VCC */
N#define CCIS__CCIA                               TIMER_A_CCTLN_CCIS__CCIA        /*!< CCIxA */
N#define CCIS__CCIB                               TIMER_A_CCTLN_CCIS__CCIB        /*!< CCIxB */
N#define CCIS__GND                                TIMER_A_CCTLN_CCIS__GND         /*!< GND */
N#define CCIS__VCC                                TIMER_A_CCTLN_CCIS__VCC         /*!< VCC */
N/* TA0CCTLn[CM] Bits */
N#define CM_OFS                                   TIMER_A_CCTLN_CM_OFS            /*!< CM Offset */
N#define CM_M                                     TIMER_A_CCTLN_CM_MASK           /*!< Capture mode */
N#define CM0                                      TIMER_A_CCTLN_CM0               /*!< CM Bit 0 */
N#define CM1                                      TIMER_A_CCTLN_CM1               /*!< CM Bit 1 */
N#define CM_0                                     TIMER_A_CCTLN_CM_0              /*!< No capture */
N#define CM_1                                     TIMER_A_CCTLN_CM_1              /*!< Capture on rising edge */
N#define CM_2                                     TIMER_A_CCTLN_CM_2              /*!< Capture on falling edge */
N#define CM_3                                     TIMER_A_CCTLN_CM_3              /*!< Capture on both rising and falling edges */
N#define CM__NONE                                 TIMER_A_CCTLN_CM__NONE          /*!< No capture */
N#define CM__RISING                               TIMER_A_CCTLN_CM__RISING        /*!< Capture on rising edge */
N#define CM__FALLING                              TIMER_A_CCTLN_CM__FALLING       /*!< Capture on falling edge */
N#define CM__BOTH                                 TIMER_A_CCTLN_CM__BOTH          /*!< Capture on both rising and falling edges */
N/* TA0EX0[TAIDEX] Bits */
N#define TAIDEX_OFS                               TIMER_A_EX0_IDEX_OFS            /*!< TAIDEX Offset */
N#define TAIDEX_M                                 TIMER_A_EX0_IDEX_MASK           /*!< Input divider expansion */
N#define TAIDEX0                                  TIMER_A_EX0_IDEX0               /*!< TAIDEX Bit 0 */
N#define TAIDEX1                                  TIMER_A_EX0_IDEX1               /*!< TAIDEX Bit 1 */
N#define TAIDEX2                                  TIMER_A_EX0_IDEX2               /*!< TAIDEX Bit 2 */
N#define TAIDEX_0                                 TIMER_A_EX0_TAIDEX_0            /*!< Divide by 1 */
N#define TAIDEX_1                                 TIMER_A_EX0_TAIDEX_1            /*!< Divide by 2 */
N#define TAIDEX_2                                 TIMER_A_EX0_TAIDEX_2            /*!< Divide by 3 */
N#define TAIDEX_3                                 TIMER_A_EX0_TAIDEX_3            /*!< Divide by 4 */
N#define TAIDEX_4                                 TIMER_A_EX0_TAIDEX_4            /*!< Divide by 5 */
N#define TAIDEX_5                                 TIMER_A_EX0_TAIDEX_5            /*!< Divide by 6 */
N#define TAIDEX_6                                 TIMER_A_EX0_TAIDEX_6            /*!< Divide by 7 */
N#define TAIDEX_7                                 TIMER_A_EX0_TAIDEX_7            /*!< Divide by 8 */
N#define TAIDEX__1                                TIMER_A_EX0_IDEX__1             /*!< Divide by 1 */
N#define TAIDEX__2                                TIMER_A_EX0_IDEX__2             /*!< Divide by 2 */
N#define TAIDEX__3                                TIMER_A_EX0_IDEX__3             /*!< Divide by 3 */
N#define TAIDEX__4                                TIMER_A_EX0_IDEX__4             /*!< Divide by 4 */
N#define TAIDEX__5                                TIMER_A_EX0_IDEX__5             /*!< Divide by 5 */
N#define TAIDEX__6                                TIMER_A_EX0_IDEX__6             /*!< Divide by 6 */
N#define TAIDEX__7                                TIMER_A_EX0_IDEX__7             /*!< Divide by 7 */
N#define TAIDEX__8                                TIMER_A_EX0_IDEX__8             /*!< Divide by 8 */
N
N/******************************************************************************
N* WDT_A Bits (legacy section)
N******************************************************************************/
N/* WDTCTL[WDTIS] Bits */
N#define WDTIS_OFS                                WDT_A_CTL_IS_OFS                /*!< WDTIS Offset */
N#define WDTIS_M                                  WDT_A_CTL_IS_MASK               /*!< Watchdog timer interval select */
N#define WDTIS0                                   WDT_A_CTL_IS0                   /*!< WDTIS Bit 0 */
N#define WDTIS1                                   WDT_A_CTL_IS1                   /*!< WDTIS Bit 1 */
N#define WDTIS2                                   WDT_A_CTL_IS2                   /*!< WDTIS Bit 2 */
N#define WDTIS_0                                  WDT_A_CTL_IS_0                  /*!< Watchdog clock source / (2^(31)) (18:12:16 at 32.768 kHz) */
N#define WDTIS_1                                  WDT_A_CTL_IS_1                  /*!< Watchdog clock source /(2^(27)) (01:08:16 at 32.768 kHz) */
N#define WDTIS_2                                  WDT_A_CTL_IS_2                  /*!< Watchdog clock source /(2^(23)) (00:04:16 at 32.768 kHz) */
N#define WDTIS_3                                  WDT_A_CTL_IS_3                  /*!< Watchdog clock source /(2^(19)) (00:00:16 at 32.768 kHz) */
N#define WDTIS_4                                  WDT_A_CTL_IS_4                  /*!< Watchdog clock source /(2^(15)) (1 s at 32.768 kHz) */
N#define WDTIS_5                                  WDT_A_CTL_IS_5                  /*!< Watchdog clock source / (2^(13)) (250 ms at 32.768 kHz) */
N#define WDTIS_6                                  WDT_A_CTL_IS_6                  /*!< Watchdog clock source / (2^(9)) (15.625 ms at 32.768 kHz) */
N#define WDTIS_7                                  WDT_A_CTL_IS_7                  /*!< Watchdog clock source / (2^(6)) (1.95 ms at 32.768 kHz) */
N/* WDTCTL[WDTCNTCL] Bits */
N#define WDTCNTCL_OFS                             WDT_A_CTL_CNTCL_OFS             /*!< WDTCNTCL Offset */
N#define WDTCNTCL                                 WDT_A_CTL_CNTCL                 /*!< Watchdog timer counter clear */
N/* WDTCTL[WDTTMSEL] Bits */
N#define WDTTMSEL_OFS                             WDT_A_CTL_TMSEL_OFS             /*!< WDTTMSEL Offset */
N#define WDTTMSEL                                 WDT_A_CTL_TMSEL                 /*!< Watchdog timer mode select */
N/* WDTCTL[WDTSSEL] Bits */
N#define WDTSSEL_OFS                              WDT_A_CTL_SSEL_OFS              /*!< WDTSSEL Offset */
N#define WDTSSEL_M                                WDT_A_CTL_SSEL_MASK             /*!< Watchdog timer clock source select */
N#define WDTSSEL0                                 WDT_A_CTL_SSEL0                 /*!< WDTSSEL Bit 0 */
N#define WDTSSEL1                                 WDT_A_CTL_SSEL1                 /*!< WDTSSEL Bit 1 */
N#define WDTSSEL_0                                WDT_A_CTL_SSEL_0                /*!< SMCLK */
N#define WDTSSEL_1                                WDT_A_CTL_SSEL_1                /*!< ACLK */
N#define WDTSSEL_2                                WDT_A_CTL_SSEL_2                /*!< VLOCLK */
N#define WDTSSEL_3                                WDT_A_CTL_SSEL_3                /*!< BCLK */
N#define WDTSSEL__SMCLK                           WDT_A_CTL_SSEL__SMCLK           /*!< SMCLK */
N#define WDTSSEL__ACLK                            WDT_A_CTL_SSEL__ACLK            /*!< ACLK */
N#define WDTSSEL__VLOCLK                          WDT_A_CTL_SSEL__VLOCLK          /*!< VLOCLK */
N#define WDTSSEL__BCLK                            WDT_A_CTL_SSEL__BCLK            /*!< BCLK */
N/* WDTCTL[WDTHOLD] Bits */
N#define WDTHOLD_OFS                              WDT_A_CTL_HOLD_OFS              /*!< WDTHOLD Offset */
N#define WDTHOLD                                  WDT_A_CTL_HOLD                  /*!< Watchdog timer hold */
N/* WDTCTL[WDTPW] Bits */
N#define WDTPW_OFS                                WDT_A_CTL_PW_OFS                /*!< WDTPW Offset */
N#define WDTPW_M                                  WDT_A_CTL_PW_MASK               /*!< Watchdog timer password */
N/* Pre-defined bitfield values */
N#define WDTPW                                          WDT_A_CTL_PW              /*!< WDT Key Value for WDT write access */
N
N
N#ifdef __cplusplus
N}
N#endif
N
N#endif /* __MSP432P401R_CLASSIC_H__ */
L 75 "C:\ti\ccs930\ccs\ccs_base\arm\include\msp432p401r.h" 2
N#endif
N
N
N#ifndef __CMSIS_CONFIG__
N#define __CMSIS_CONFIG__
N
N/** @addtogroup MSP432P401R_Definitions MSP432P401R Definitions
N  This file defines all structures and symbols for MSP432P401R:
N    - components and registers
N    - peripheral base address
N    - peripheral ID
N    - Peripheral definitions
N  @{
N*/
N
N/******************************************************************************
N*                Processor and Core Peripherals                               *
N******************************************************************************/
N/** @addtogroup MSP432P401R_CMSIS Device CMSIS Definitions
N  Configuration of the Cortex-M4 Processor and Core Peripherals
N  @{
N*/
N
N/******************************************************************************
N* CMSIS-compatible Interrupt Number Definition                                *
N******************************************************************************/
Ntypedef enum IRQn
N{
N  /* Cortex-M4 Processor Exceptions Numbers */
N  NonMaskableInt_IRQn         = -14,    /*  2 Non Maskable Interrupt */
N  HardFault_IRQn              = -13,    /*  3 Hard Fault Interrupt */
N  MemoryManagement_IRQn       = -12,    /*  4 Memory Management Interrupt */
N  BusFault_IRQn               = -11,    /*  5 Bus Fault Interrupt */
N  UsageFault_IRQn             = -10,    /*  6 Usage Fault Interrupt */
N  SVCall_IRQn                 = -5,     /* 11 SV Call Interrupt */
N  DebugMonitor_IRQn           = -4,     /* 12 Debug Monitor Interrupt */
N  PendSV_IRQn                 = -2,     /* 14 Pend SV Interrupt */
N  SysTick_IRQn                = -1,     /* 15 System Tick Interrupt */
N  /*  Peripheral Exceptions Numbers */
N  PSS_IRQn                    = 0,     /* 16 PSS Interrupt             */
N  CS_IRQn                     = 1,     /* 17 CS Interrupt              */
N  PCM_IRQn                    = 2,     /* 18 PCM Interrupt             */
N  WDT_A_IRQn                  = 3,     /* 19 WDT_A Interrupt           */
N  FPU_IRQn                    = 4,     /* 20 FPU Interrupt             */
N  FLCTL_IRQn                  = 5,     /* 21 Flash Controller Interrupt*/
N  COMP_E0_IRQn                = 6,     /* 22 COMP_E0 Interrupt         */
N  COMP_E1_IRQn                = 7,     /* 23 COMP_E1 Interrupt         */
N  TA0_0_IRQn                  = 8,     /* 24 TA0_0 Interrupt           */
N  TA0_N_IRQn                  = 9,     /* 25 TA0_N Interrupt           */
N  TA1_0_IRQn                  = 10,     /* 26 TA1_0 Interrupt           */
N  TA1_N_IRQn                  = 11,     /* 27 TA1_N Interrupt           */
N  TA2_0_IRQn                  = 12,     /* 28 TA2_0 Interrupt           */
N  TA2_N_IRQn                  = 13,     /* 29 TA2_N Interrupt           */
N  TA3_0_IRQn                  = 14,     /* 30 TA3_0 Interrupt           */
N  TA3_N_IRQn                  = 15,     /* 31 TA3_N Interrupt           */
N  EUSCIA0_IRQn                = 16,     /* 32 EUSCIA0 Interrupt         */
N  EUSCIA1_IRQn                = 17,     /* 33 EUSCIA1 Interrupt         */
N  EUSCIA2_IRQn                = 18,     /* 34 EUSCIA2 Interrupt         */
N  EUSCIA3_IRQn                = 19,     /* 35 EUSCIA3 Interrupt         */
N  EUSCIB0_IRQn                = 20,     /* 36 EUSCIB0 Interrupt         */
N  EUSCIB1_IRQn                = 21,     /* 37 EUSCIB1 Interrupt         */
N  EUSCIB2_IRQn                = 22,     /* 38 EUSCIB2 Interrupt         */
N  EUSCIB3_IRQn                = 23,     /* 39 EUSCIB3 Interrupt         */
N  ADC14_IRQn                  = 24,     /* 40 ADC14 Interrupt           */
N  T32_INT1_IRQn               = 25,     /* 41 T32_INT1 Interrupt        */
N  T32_INT2_IRQn               = 26,     /* 42 T32_INT2 Interrupt        */
N  T32_INTC_IRQn               = 27,     /* 43 T32_INTC Interrupt        */
N  AES256_IRQn                 = 28,     /* 44 AES256 Interrupt          */
N  RTC_C_IRQn                  = 29,     /* 45 RTC_C Interrupt           */
N  DMA_ERR_IRQn                = 30,     /* 46 DMA_ERR Interrupt         */
N  DMA_INT3_IRQn               = 31,     /* 47 DMA_INT3 Interrupt        */
N  DMA_INT2_IRQn               = 32,     /* 48 DMA_INT2 Interrupt        */
N  DMA_INT1_IRQn               = 33,     /* 49 DMA_INT1 Interrupt        */
N  DMA_INT0_IRQn               = 34,     /* 50 DMA_INT0 Interrupt        */
N  PORT1_IRQn                  = 35,     /* 51 Port1 Interrupt           */
N  PORT2_IRQn                  = 36,     /* 52 Port2 Interrupt           */
N  PORT3_IRQn                  = 37,     /* 53 Port3 Interrupt           */
N  PORT4_IRQn                  = 38,     /* 54 Port4 Interrupt           */
N  PORT5_IRQn                  = 39,     /* 55 Port5 Interrupt           */
N  PORT6_IRQn                  = 40      /* 56 Port6 Interrupt           */
N} IRQn_Type;
N
N/******************************************************************************
N* Processor and Core Peripheral Section                                       *
N******************************************************************************/
N#define __CM4_REV               0x0001    /* Core revision r0p1 */
N#define __MPU_PRESENT           1         /* MPU present or not */
N#define __NVIC_PRIO_BITS        3         /* Number of Bits used for Prio Levels */
N#define __Vendor_SysTickConfig  0         /* Set to 1 if different SysTick Config is used */
N#define __FPU_PRESENT           1         /* FPU present or not */
N
N/******************************************************************************
N* Available Peripherals                                                       *
N******************************************************************************/
N#define __MCU_HAS_ADC14__                                                        /*!< Module ADC14 is available */
N#define __MCU_HAS_AES256__                                                       /*!< Module AES256 is available */
N#define __MCU_HAS_CAPTIO0__                                                      /*!< Module CAPTIO0 is available */
N#define __MCU_HAS_CAPTIO1__                                                      /*!< Module CAPTIO1 is available */
N#define __MCU_HAS_COMP_E0__                                                      /*!< Module COMP_E0 is available */
N#define __MCU_HAS_COMP_E1__                                                      /*!< Module COMP_E1 is available */
N#define __MCU_HAS_CRC32__                                                        /*!< Module CRC32 is available */
N#define __MCU_HAS_CS__                                                           /*!< Module CS is available */
N#define __MCU_HAS_DIO__                                                          /*!< Module DIO is available */
N#define __MCU_HAS_DMA__                                                          /*!< Module DMA is available */
N#define __MCU_HAS_EUSCI_A0__                                                     /*!< Module EUSCI_A0 is available */
N#define __MCU_HAS_EUSCI_A1__                                                     /*!< Module EUSCI_A1 is available */
N#define __MCU_HAS_EUSCI_A2__                                                     /*!< Module EUSCI_A2 is available */
N#define __MCU_HAS_EUSCI_A3__                                                     /*!< Module EUSCI_A3 is available */
N#define __MCU_HAS_EUSCI_B0__                                                     /*!< Module EUSCI_B0 is available */
N#define __MCU_HAS_EUSCI_B1__                                                     /*!< Module EUSCI_B1 is available */
N#define __MCU_HAS_EUSCI_B2__                                                     /*!< Module EUSCI_B2 is available */
N#define __MCU_HAS_EUSCI_B3__                                                     /*!< Module EUSCI_B3 is available */
N#define __MCU_HAS_FLCTL__                                                        /*!< Module FLCTL is available */
N#define __MCU_HAS_FL_BOOTOVER_MAILBOX__                                          /*!< Module FL_BOOTOVER_MAILBOX is available */
N#define __MCU_HAS_PCM__                                                          /*!< Module PCM is available */
N#define __MCU_HAS_PMAP__                                                         /*!< Module PMAP is available */
N#define __MCU_HAS_PSS__                                                          /*!< Module PSS is available */
N#define __MCU_HAS_REF_A__                                                        /*!< Module REF_A is available */
N#define __MCU_HAS_RSTCTL__                                                       /*!< Module RSTCTL is available */
N#define __MCU_HAS_RTC_C__                                                        /*!< Module RTC_C is available */
N#define __MCU_HAS_SYSCTL__                                                       /*!< Module SYSCTL is available */
N#define __MCU_HAS_TIMER32__                                                      /*!< Module TIMER32 is available */
N#define __MCU_HAS_TIMER_A0__                                                     /*!< Module TIMER_A0 is available */
N#define __MCU_HAS_TIMER_A1__                                                     /*!< Module TIMER_A1 is available */
N#define __MCU_HAS_TIMER_A2__                                                     /*!< Module TIMER_A2 is available */
N#define __MCU_HAS_TIMER_A3__                                                     /*!< Module TIMER_A3 is available */
N#define __MCU_HAS_TLV__                                                          /*!< Module TLV is available */
N#define __MCU_HAS_WDT_A__                                                        /*!< Module WDT_A is available */
N
N/* Definitions to show that specific ports are available */
N
N#define __MSP432_HAS_PORTA_R__
N#define __MSP432_HAS_PORTB_R__
N#define __MSP432_HAS_PORTC_R__
N#define __MSP432_HAS_PORTD_R__
N#define __MSP432_HAS_PORTE_R__
N#define __MSP432_HAS_PORTJ_R__
N
N#define __MSP432_HAS_PORT1_R__
N#define __MSP432_HAS_PORT2_R__
N#define __MSP432_HAS_PORT3_R__
N#define __MSP432_HAS_PORT4_R__
N#define __MSP432_HAS_PORT5_R__
N#define __MSP432_HAS_PORT6_R__
N#define __MSP432_HAS_PORT7_R__
N#define __MSP432_HAS_PORT8_R__
N#define __MSP432_HAS_PORT9_R__
N#define __MSP432_HAS_PORT10_R__
N
N
N/*@}*/ /* end of group MSP432P401R_CMSIS */
N
N/* Include CMSIS Cortex-M4 Core Peripheral Access Layer Header File */
N#ifdef __TI_ARM__
N/* disable the TI ULP advisor check for the core header file definitions */
N#pragma diag_push
N#pragma CHECK_ULP("none")
N#include "core_cm4.h"
L 1 "C:/ti/ccs930/ccs/ccs_base/arm/include/CMSIS/core_cm4.h" 1
N/**************************************************************************//**
N * @file     core_cm4.h
N * @brief    CMSIS Cortex-M4 Core Peripheral Access Layer Header File
N * @version  V5.0.1
N * @date     30. January 2017
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2016 ARM Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 0L && (__ARMCC_VERSION >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CM4_H_GENERIC
N#define __CORE_CM4_H_GENERIC
N
N#include <stdint.h>
N
N#ifdef __cplusplus
N extern "C" {
N#endif
N
N/**
N  \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/**
N  \ingroup Cortex_M4
N  @{
N */
N
N/*  CMSIS CM4 definitions */
N#define __CM4_CMSIS_VERSION_MAIN  ( 5U)                                  /*!< [31:16] CMSIS HAL main version */
N#define __CM4_CMSIS_VERSION_SUB   ( 0U)                                  /*!< [15:0]  CMSIS HAL sub version */
N#define __CM4_CMSIS_VERSION       ((__CM4_CMSIS_VERSION_MAIN << 16U) | \
N                                    __CM4_CMSIS_VERSION_SUB           )  /*!< CMSIS HAL version number */
X#define __CM4_CMSIS_VERSION       ((__CM4_CMSIS_VERSION_MAIN << 16U) |                                     __CM4_CMSIS_VERSION_SUB           )   
N
N#define __CORTEX_M                (4U)                                   /*!< Cortex-M Core */
N
N/** __FPU_USED indicates whether an FPU is used or not.
N    For this, __FPU_PRESENT has to be checked prior to making use of FPU specific registers and functions.
N*/
N#if defined ( __CC_ARM )
X#if 0L
S  #if defined __TARGET_FPU_VFP
S    #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 0L && (__ARMCC_VERSION >= 6010050)
S  #if defined __ARM_PCS_VFP
S    #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined ( __GNUC__ )
X#elif 0L
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined ( __ICCARM__ )
X#elif 0L
S  #if defined __ARMVFP__
S    #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
N#elif defined ( __TI_ARM__ )
X#elif 1L
N  #if defined __TI_VFP_SUPPORT__
X  #if 1L
N    #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
X    #if 1L && (1 == 1U)
N      #define __FPU_USED       1U
N    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
N    #endif
N  #else
S    #define __FPU_USED         0U
N  #endif
N
N#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined ( __CSMC__ )
S  #if ( __CSMC__ & 0x400U)
S    #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
N#endif
N
N#include "cmsis_compiler.h"               /* CMSIS compiler specific defines */
L 1 "C:\ti\ccs930\ccs\ccs_base\arm\include\CMSIS\cmsis_compiler.h" 1
N/**************************************************************************//**
N * @file     cmsis_compiler.h
N * @brief    CMSIS compiler generic header file
N * @version  V5.0.1
N * @date     30. January 2017
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2017 ARM Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __CMSIS_COMPILER_H
N#define __CMSIS_COMPILER_H
N
N#include <stdint.h>
N
N/*
N * ARM Compiler 4/5
N */
N#if   defined ( __CC_ARM )
X#if   0L
S  #include "cmsis_armcc.h"
S
S
S/*
S * ARM Compiler 6 (armclang)
S */
S#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 0L && (__ARMCC_VERSION >= 6010050)
S  #include "cmsis_armclang.h"
S
S
S/*
S * GNU Compiler
S */
S#elif defined ( __GNUC__ )
X#elif 0L
S  #include "cmsis_gcc.h"
S
S
S/*
S * IAR Compiler
S */
S#elif defined ( __ICCARM__ )
X#elif 0L
S
S  #ifndef   __ASM
S    #define __ASM                     __asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                  inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE           static inline
S  #endif
S
S  #include <cmsis_iar.h>
S
S  #ifndef   __NO_RETURN
S    #define __NO_RETURN               __noreturn
S  #endif
S  #ifndef   __USED
S    #define __USED                    __root
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                    __weak
S  #endif
S  #ifndef   __UNALIGNED_UINT32
S    __packed struct T_UINT32 { uint32_t v; };
S      #define __UNALIGNED_UINT32(x)     (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #warning No compiler specific solution for __ALIGNED. __ALIGNED is ignored.
S    #define __ALIGNED(x)
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                  __packed
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT           __packed struct
S  #endif
S
S
S/*
S * TI ARM Compiler
S */
N#elif defined ( __TI_ARM__ )
X#elif 1L
N  #include <cmsis_ccs.h>
L 1 "C:/ti/ccs930/ccs/ccs_base/arm/include/CMSIS/cmsis_ccs.h" 1
N//*****************************************************************************
N//
N// Copyright (C) 2012 - 2017 Texas Instruments Incorporated - http://www.ti.com/
N//
N// Redistribution and use in source and binary forms, with or without
N// modification, are permitted provided that the following conditions
N// are met:
N//
N//  Redistributions of source code must retain the above copyright
N//  notice, this list of conditions and the following disclaimer.
N//
N//  Redistributions in binary form must reproduce the above copyright
N//  notice, this list of conditions and the following disclaimer in the
N//  documentation and/or other materials provided with the
N//  distribution.
N//
N//  Neither the name of Texas Instruments Incorporated nor the names of
N//  its contributors may be used to endorse or promote products derived
N//  from this software without specific prior written permission.
N//
N// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
N// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
N// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
N// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
N// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
N// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
N// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
N// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
N// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
N// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N//
N// MSP432 Family CMSIS Definitions
N//
N//****************************************************************************
N
N#ifndef CMSIS_CCS_H_
N#define CMSIS_CCS_H_
N
N#ifndef __TI_ARM__
S  #error This file should only be compiled by TI compiler (minimum version 15.12.x)
N#endif
N
N/** CMSIS compiler control architecture macros */
N#if defined ( __TI_ARM_V6M0__ )
X#if 0L
S  #define __ARM_ARCH_6M__                   1
N#endif
N
N#if defined ( __TI_ARM_V7M3__ )
X#if 0L
S  #define __ARM_ARCH_7M__                   1
N#endif
N
N#if defined ( __TI_ARM_V7M4__ )
X#if 1L
N  #define __ARM_ARCH_7EM__                  1
N#endif
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N *  \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N *  @{
N */
N
N/**
N * \brief   Enable IRQ Interrupts
N * \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
N *          Can only be executed in Privileged modes.
N */
N#define __enable_irq                        _enable_IRQ
N
N/**
N * \brief   Disable IRQ Interrupts
N * \details Disables IRQ interrupts by setting the I-bit in the CPSR.
N *          Can only be executed in Privileged modes.
N */
N#define __disable_irq                       _disable_IRQ
N
N/** @} */ /* end of CMSIS_Core_RegAccFunctions */
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N *  Access to dedicated instructions
N *  @{
N*/
N
N/**
N * \brief   Count leading zeros
N * \details Counts the number of leading zeros of a data value.
N * \param [in]  VAL  Value to count the leading zeros
N * \return           number of leading zeros in value
N */
N#define __CLZ(VAL)                          ((unsigned char)__clz(VAL))
N
N/**
N * \brief   Signed Saturate
N * \details Saturates a signed value.
N * \param [in]  VAL      Value to be saturated
N * \param [in]  BITPOS   Bit position to saturate to (1..32)
N * \return               Saturated value
N */
N#define __SSAT(VAL, BITPOS)                 _ssatl(VAL, 0, BITPOS)
N
N/**
N * \brief   No Operation
N * \details No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                               __nop
N
N/**
N * \brief   Wait For Interrupt
N * \details Wait For Interrupt is a hint instruction that suspends execution until one of a number of events occurs.
N */
N#define __WFI                               __wfi
N
N
N/**
N * \brief   Wait For Event
N * \details Wait For Event is a hint instruction that permits the processor to enter
N *          a low-power state until one of a number of events occurs.
N */
N#define __WFE                               __wfe
N
N/**
N * \brief   Data Synchronization Barrier
N * \details Acts as a special kind of Data Memory Barrier.
N *          It completes when all explicit memory accesses before this instruction complete.
N */
N 
N#define __DSB                               _dsb
N/**
N * \brief   Instruction Synchronization Barrier
N * \details Instruction Synchronization Barrier flushes the pipeline in the processor,
N *          so that all instructions following the ISB are fetched from cache or memory,
N *          after the instruction has been completed.
N */
N#define __ISB                               _isb
N
N/**
N * \brief   Rotate Right in unsigned value (32 bit)
N * \details Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N * \param [in]  VAL     Value to rotate
N * \param [in]  SHIFT   Number of Bits to rotate
N * \return              Rotated value
N */
N#define __ROR(VAL, SHIFT)                   ((unsigned int)__ror(VAL, SHIFT))
N
N/** @} */ /* end of group CMSIS_Core_InstructionInterface */
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N/** \defgroup CMSIS_SIMD_intrinsics CMSIS SIMD Intrinsics
N *  Access to dedicated SIMD instructions
N *  @{
N*/
N#if (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))
X#if (1L && (1 == 1))
N
N#define __SADD8(VAL1, VAL2)                 ((unsigned int)_sadd8(VAL1, VAL2))
N#define __QADD8(VAL1, VAL2)                 ((unsigned int)_qadd8(VAL1, VAL2))
N#define __SHADD8(VAL1, VAL2)                ((unsigned int)_shadd8(VAL1, VAL2))
N#define __UADD8(VAL1, VAL2)                 ((unsigned int)_uadd8(VAL1, VAL2))
N#define __UQADD8(VAL1, VAL2)                ((unsigned int)_uqadd8(VAL1, VAL2))
N#define __UHADD8(VAL1, VAL2)                ((unsigned int)_uhadd8(VAL1, VAL2))
N#define __SSUB8(VAL1, VAL2)                 ((unsigned int)_ssub8(VAL1, VAL2))
N#define __QSUB8(VAL1, VAL2)                 ((unsigned int)_qsub8(VAL1, VAL2))
N#define __SHSUB8(VAL1, VAL2)                ((unsigned int)_shsub8(VAL1, VAL2))
N#define __USUB8(VAL1, VAL2)                 ((unsigned int)_usub8(VAL1, VAL2))
N#define __UQSUB8(VAL1, VAL2)                ((unsigned int)_uqsub8(VAL1, VAL2))
N#define __UHSUB8(VAL1, VAL2)                ((unsigned int)_uhsub8(VAL1, VAL2))
N#define __SADD16(VAL1, VAL2)                ((unsigned int)_sadd16(VAL1, VAL2))
N#define __QADD16(VAL1, VAL2)                ((unsigned int)_qadd16(VAL1, VAL2))
N#define __SHADD16(VAL1, VAL2)               ((unsigned int)_shadd16(VAL1, VAL2))
N#define __UADD16(VAL1, VAL2)                ((unsigned int)_uadd16(VAL1, VAL2))
N#define __UQADD16(VAL1, VAL2)               ((unsigned int)_uqadd16(VAL1, VAL2))
N#define __UHADD16(VAL1, VAL2)               ((unsigned int)_uhadd16(VAL1, VAL2))
N#define __SSUB16(VAL1, VAL2)                ((unsigned int)_ssub16(VAL1, VAL2))
N#define __QSUB16(VAL1, VAL2)                ((unsigned int)_qsub16(VAL1, VAL2))
N#define __SHSUB16(VAL1, VAL2)               ((unsigned int)_shsub16(VAL1, VAL2))
N#define __USUB16(VAL1, VAL2)                ((unsigned int)_usub16(VAL1, VAL2))
N#define __UQSUB16(VAL1, VAL2)               ((unsigned int)_uqsub16(VAL1, VAL2))
N#define __UHSUB16(VAL1, VAL2)               ((unsigned int)_uhsub16(VAL1, VAL2))
N#define __SASX(VAL1, VAL2)                  ((unsigned int)_saddsubx(VAL1, VAL2))
N#define __QASX(VAL1, VAL2)                  ((unsigned int)_qaddsubx(VAL1, VAL2))
N#define __SHASX(VAL1, VAL2)                 ((unsigned int)_shaddsubx(VAL1, VAL2))
N#define __UASX(VAL1, VAL2)                  ((unsigned int)_uaddsubx(VAL1, VAL2))
N#define __UQASX(VAL1, VAL2)                 ((unsigned int)_uqaddsubx(VAL1, VAL2))
N#define __UHASX(VAL1, VAL2)                 ((unsigned int)_uhaddsubx(VAL1, VAL2)))
N#define __SSAX(VAL1, VAL2)                  ((unsigned int)_ssubaddx(VAL1, VAL2))
N#define __QSAX(VAL1, VAL2)                  ((unsigned int)_qsubaddx(VAL1, VAL2))
N#define __SHSAX(VAL1, VAL2)                 ((unsigned int)_shsubaddx(VAL1, VAL2))
N#define __USAX(VAL1, VAL2)                  ((unsigned int)_usubaddx(VAL1, VAL2))
N#define __UQSAX(VAL1, VAL2)                 ((unsigned int)_uqsubaddx(VAL1, VAL2))
N#define __UHSAX(VAL1, VAL2)                 ((unsigned int)_uhsubaddx(VAL1, VAL2))
N#define __USAD8(VAL1, VAL2)                 ((unsigned int)_usad8(VAL1, VAL2))
N#define __USADA8(VAL1, VAL2, VAL3)          ((unsigned int)_usada8(VAL1, VAL2, VAL3))
N#define __SSAT16(VAL, BITPOS)               ((unsigned int)_ssat16(VAL, BITPOS))
N#define __USAT16(VAL, BITPOS)               ((unsigned int)_usat16(VAL, BITPOS))
N#define __UXTB16(VAL)                       ((unsigned int)_uxtb16(VAL, 0))
N#define __UXTAB16(VAL1, VAL2)               ((unsigned int)_uxtab16(VAL1, VAL2, 0))
N#define __SXTB16(VAL)                       ((unsigned int)_sxtb16(VAL, 0))
N#define __SXTAB16(VAL1, VAL2)               ((unsigned int)_sxtab16(VAL1, VAL2, 0))
N#define __SMUAD(VAL1, VAL2)                 ((unsigned int)_smuad(VAL1, VAL2))
N#define __SMUADX(VAL1, VAL2)                ((unsigned int)_smuadx(VAL1, VAL2))
N#define __SMLAD(VAL1, VAL2, ACCUMULATOR)    ((unsigned int)_smlad(VAL1, VAL2, ACCUMULATOR))
N#define __SMLADX(VAL1, VAL2, ACCUMULATOR)   ((unsigned int)_smladx(VAL1, VAL2, ACCUMULATOR))
N#define __SMLALD(VAL1, VAL2, ACCUMULATOR)   ((unsigned long long)_smlald(ACCUMULATOR, VAL1, VAL2))
N#define __SMLALDX(VAL1, VAL2, ACCUMULATOR)  ((unsigned long long)_smlaldx(ACCUMULATOR, VAL1, VAL2))
N#define __SMUSD(VAL1, VAL2)                 ((unsigned int)_smusd(VAL1, VAL2))
N#define __SMUSDX(VAL1, VAL2)                ((unsigned int)_smusdx(VAL1, VAL2))
N#define __SMLSD(VAL1, VAL2, ACCUMULATOR)    ((unsigned int)_smlsd(VAL1, VAL2, ACCUMULATOR))
N#define __SMLSDX(VAL1, VAL2, ACCUMULATOR)   ((unsigned int)_smlsdx(VAL1, VAL2, ACCUMULATOR))
N#define __SMLSLD(VAL1, VAL2, ACCUMULATOR)   ((unsigned long long)_smlsld(ACCUMULATOR, VAL1, VAL2))
N#define __SMLSLDX(VAL1, VAL2, ACCUMULATOR)  ((unsigned long long)_smlsldx(ACCUMULATOR, VAL1, VAL2))
N#define __SEL(VAL1, VAL2)                   ((unsigned int)_sel(VAL1, VAL2))
N#define __QADD                              _sadd
N#define __QSUB                              _ssub
N#define __PKHBT                             _pkhbt
N#define __PKHTB                             _pkhtb
N#define __SMMLA                             _smmla
N
N#define __QDADD                             _sdadd
N#define __QDSUB                             _sdsub
N#define __SMLABB                            _smlabb
N#define __SMLABT                            _smlabt
N#define __SMLALBB                           _smlalbb
N#define __SMLALBT                           _smlalbt
N#define __SMLALTB                           _smlaltb
N#define __SMLALTT                           _smlaltt
N#define __SMLATB                            _smlatb
N#define __SMLATT                            _smlatt
N#define __SMLAWB                            _smlawb
N#define __SMLAWT                            _smlawt
N#define __SMULBB                            _smulbb
N#define __SMULBT                            _smulbt
N#define __SMULTB                            _smultb
N#define __SMULTT                            _smultt
N#define __SMULWB                            _smulwb
N#define __SMULWT                            _smulwt
N#define __SMMLAR                            _smmlar
N#define __SMMLS                             _smmls
N#define __SMMLSR                            _smmlsr
N#define __SMMUL                             _smmul
N#define __SMMULR                            _smmulr
N#define __SXTAB                             _sxtab
N#define __SXTAH                             _sxtah
N#define __UMAAL                             _umaal
N#define __UXTAB                             _uxtab
N#define __UXTAH                             _uxtah
N#define __SUBC                              _subc
N
N#endif /* (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1)) */
N
N#if (defined (__ARM_ARCH_6M__) && (__ARM_ARCH_6M__ == 1))
X#if (0L && (__ARM_ARCH_6M__ == 1))
S
S#define __SXTB                              _sxtb
S#define __SXTH                              _sxth
S#define __UXTB                              _uxtb
S#define __UXTH                              _uxth
S
N#endif /* (defined (__ARM_ARCH_6M__) && (__ARM_ARCH_6M__ == 1)) */
N
N/** @} */ /* end of group CMSIS_SIMD_intrinsics */
N
N#endif /* CMSIS_CCS_H_ */
L 98 "C:\ti\ccs930\ccs\ccs_base\arm\include\CMSIS\cmsis_compiler.h" 2
N
N  #ifndef   __ASM
N    #define __ASM                     __asm
N  #endif
N  #ifndef   __INLINE
N    #define __INLINE                  inline
N  #endif
N  #ifndef   __STATIC_INLINE
N    #define __STATIC_INLINE           static inline
N  #endif
N  #ifndef   __NO_RETURN
N    #define __NO_RETURN               __attribute__((noreturn))
N  #endif
N  #ifndef   __USED
N    #define __USED                    __attribute__((used))
N  #endif
N  #ifndef   __WEAK
N    #define __WEAK                    __attribute__((weak))
N  #endif
N  #ifndef   __UNALIGNED_UINT32
N    struct __attribute__((packed)) T_UINT32 { uint32_t v; };
N    #define __UNALIGNED_UINT32(x)     (((struct T_UINT32 *)(x))->v)
N  #endif
N  #ifndef   __ALIGNED
N    #define __ALIGNED(x)              __attribute__((aligned(x)))
N  #endif
N  #ifndef   __PACKED
N    #define __PACKED                  __attribute__((packed))
N  #endif
N  #ifndef   __PACKED_STRUCT
N    #define __PACKED_STRUCT           struct __attribute__((packed))
N  #endif
N
N
N/*
N * TASKING Compiler
N */
N#elif defined ( __TASKING__ )
S  /*
S   * The CMSIS functions have been implemented as intrinsics in the compiler.
S   * Please use "carm -?i" to get an up to date list of all intrinsics,
S   * Including the CMSIS ones.
S   */
S
S  #ifndef   __ASM
S    #define __ASM                     __asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                  inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE           static inline
S  #endif
S  #ifndef   __NO_RETURN
S    #define __NO_RETURN               __attribute__((noreturn))
S  #endif
S  #ifndef   __USED
S    #define __USED                    __attribute__((used))
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                    __attribute__((weak))
S  #endif
S  #ifndef   __UNALIGNED_UINT32
S    struct __packed__ T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)     (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #define __ALIGNED(x)              __align(x)
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                  __packed__
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT           struct __packed__
S  #endif
S
S
S/*
S * COSMIC Compiler
S */
S#elif defined ( __CSMC__ )
S   #include <cmsis_csm.h>
S
S #ifndef   __ASM
S    #define __ASM                     _asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                  inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE           static inline
S  #endif
S  #ifndef   __NO_RETURN
S    // NO RETURN is automatically detected hence no warning here
S    #define __NO_RETURN
S  #endif
S  #ifndef   __USED
S    #warning No compiler specific solution for __USED. __USED is ignored.
S    #define __USED
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                    __weak
S  #endif
S  #ifndef   __UNALIGNED_UINT32
S    @packed struct T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)     (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #warning No compiler specific solution for __ALIGNED. __ALIGNED is ignored.
S    #define __ALIGNED(x)
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                  @packed
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT           @packed struct
S  #endif
S
S
S#else
S  #error Unknown compiler.
N#endif
N
N
N#endif /* __CMSIS_COMPILER_H */
N
L 161 "C:/ti/ccs930/ccs/ccs_base/arm/include/CMSIS/core_cm4.h" 2
N
N
N#ifdef __cplusplus
N}
N#endif
N
N#endif /* __CORE_CM4_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM4_H_DEPENDANT
N#define __CORE_CM4_H_DEPENDANT
N
N#ifdef __cplusplus
N extern "C" {
N#endif
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 0L
S  #ifndef __CM4_REV
S    #define __CM4_REV               0x0000U
S    #warning "__CM4_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __FPU_PRESENT
S    #define __FPU_PRESENT             0U
S    #warning "__FPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __MPU_PRESENT
S    #define __MPU_PRESENT             0U
S    #warning "__MPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          3U
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0U
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N/**
N    \defgroup CMSIS_glob_defs CMSIS Global Defines
N
N    <strong>IO Type Qualifiers</strong> are used
N    \li to specify the access to peripheral variables.
N    \li for automatic generation of peripheral register debug information.
N*/
N#ifdef __cplusplus
N  #define   __I     volatile             /*!< Defines 'read only' permissions */
N#else
S  #define   __I     volatile const       /*!< Defines 'read only' permissions */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions */
N
N/* following defines should be used for structure members */
N#define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
N#define     __OM     volatile            /*! Defines 'write only' structure member permissions */
N#define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
N
N/*@} end of group Cortex_M4 */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N  - Core Debug Register
N  - Core MPU Register
N  - Core FPU Register
N ******************************************************************************/
N/**
N  \defgroup CMSIS_core_register Defines and Type Definitions
N  \brief Type definitions and defines for Cortex-M processor based devices.
N*/
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_CORE  Status and Control Registers
N  \brief      Core Register type definitions.
N  @{
N */
N
N/**
N  \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved */
N    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags */
N    uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} APSR_Type;
N
N/* APSR Register Definitions */
N#define APSR_N_Pos                         31U                                            /*!< APSR: N Position */
N#define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR: N Mask */
N
N#define APSR_Z_Pos                         30U                                            /*!< APSR: Z Position */
N#define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR: Z Mask */
N
N#define APSR_C_Pos                         29U                                            /*!< APSR: C Position */
N#define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR: C Mask */
N
N#define APSR_V_Pos                         28U                                            /*!< APSR: V Position */
N#define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR: V Mask */
N
N#define APSR_Q_Pos                         27U                                            /*!< APSR: Q Position */
N#define APSR_Q_Msk                         (1UL << APSR_Q_Pos)                            /*!< APSR: Q Mask */
N
N#define APSR_GE_Pos                        16U                                            /*!< APSR: GE Position */
N#define APSR_GE_Msk                        (0xFUL << APSR_GE_Pos)                         /*!< APSR: GE Mask */
N
N
N/**
N  \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} IPSR_Type;
N
N/* IPSR Register Definitions */
N#define IPSR_ISR_Pos                        0U                                            /*!< IPSR: ISR Position */
N#define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:1;               /*!< bit:      9  Reserved */
N    uint32_t ICI_IT_1:6;                 /*!< bit: 10..15  ICI/IT part 1 */
N    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags */
N    uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved */
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit */
N    uint32_t ICI_IT_2:2;                 /*!< bit: 25..26  ICI/IT part 2 */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} xPSR_Type;
N
N/* xPSR Register Definitions */
N#define xPSR_N_Pos                         31U                                            /*!< xPSR: N Position */
N#define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR: N Mask */
N
N#define xPSR_Z_Pos                         30U                                            /*!< xPSR: Z Position */
N#define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR: Z Mask */
N
N#define xPSR_C_Pos                         29U                                            /*!< xPSR: C Position */
N#define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR: C Mask */
N
N#define xPSR_V_Pos                         28U                                            /*!< xPSR: V Position */
N#define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR: V Mask */
N
N#define xPSR_Q_Pos                         27U                                            /*!< xPSR: Q Position */
N#define xPSR_Q_Msk                         (1UL << xPSR_Q_Pos)                            /*!< xPSR: Q Mask */
N
N#define xPSR_ICI_IT_2_Pos                  25U                                            /*!< xPSR: ICI/IT part 2 Position */
N#define xPSR_ICI_IT_2_Msk                  (3UL << xPSR_ICI_IT_2_Pos)                     /*!< xPSR: ICI/IT part 2 Mask */
N
N#define xPSR_T_Pos                         24U                                            /*!< xPSR: T Position */
N#define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR: T Mask */
N
N#define xPSR_GE_Pos                        16U                                            /*!< xPSR: GE Position */
N#define xPSR_GE_Msk                        (0xFUL << xPSR_GE_Pos)                         /*!< xPSR: GE Mask */
N
N#define xPSR_ICI_IT_1_Pos                  10U                                            /*!< xPSR: ICI/IT part 1 Position */
N#define xPSR_ICI_IT_1_Msk                  (0x3FUL << xPSR_ICI_IT_1_Pos)                  /*!< xPSR: ICI/IT part 1 Mask */
N
N#define xPSR_ISR_Pos                        0U                                            /*!< xPSR: ISR Position */
N#define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
N    uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag */
N    uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} CONTROL_Type;
N
N/* CONTROL Register Definitions */
N#define CONTROL_FPCA_Pos                    2U                                            /*!< CONTROL: FPCA Position */
N#define CONTROL_FPCA_Msk                   (1UL << CONTROL_FPCA_Pos)                      /*!< CONTROL: FPCA Mask */
N
N#define CONTROL_SPSEL_Pos                   1U                                            /*!< CONTROL: SPSEL Position */
N#define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONTROL: SPSEL Mask */
N
N#define CONTROL_nPRIV_Pos                   0U                                            /*!< CONTROL: nPRIV Position */
N#define CONTROL_nPRIV_Msk                  (1UL /*<< CONTROL_nPRIV_Pos*/)                 /*!< CONTROL: nPRIV Mask */
N
N/*@} end of group CMSIS_CORE */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
N  \brief      Type definitions for the NVIC Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IOM uint32_t ISER[8U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
X  volatile uint32_t ISER[8U];                
N        uint32_t RESERVED0[24U];
N  __IOM uint32_t ICER[8U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register */
X  volatile uint32_t ICER[8U];                
N        uint32_t RSERVED1[24U];
N  __IOM uint32_t ISPR[8U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register */
X  volatile uint32_t ISPR[8U];                
N        uint32_t RESERVED2[24U];
N  __IOM uint32_t ICPR[8U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register */
X  volatile uint32_t ICPR[8U];                
N        uint32_t RESERVED3[24U];
N  __IOM uint32_t IABR[8U];               /*!< Offset: 0x200 (R/W)  Interrupt Active bit Register */
X  volatile uint32_t IABR[8U];                
N        uint32_t RESERVED4[56U];
N  __IOM uint8_t  IP[240U];               /*!< Offset: 0x300 (R/W)  Interrupt Priority Register (8Bit wide) */
X  volatile uint8_t  IP[240U];                
N        uint32_t RESERVED5[644U];
N  __OM  uint32_t STIR;                   /*!< Offset: 0xE00 ( /W)  Software Trigger Interrupt Register */
X  volatile  uint32_t STIR;                    
N}  NVIC_Type;
N
N/* Software Triggered Interrupt Register Definitions */
N#define NVIC_STIR_INTID_Pos                 0U                                         /*!< STIR: INTLINESNUM Position */
N#define NVIC_STIR_INTID_Msk                (0x1FFUL /*<< NVIC_STIR_INTID_Pos*/)        /*!< STIR: INTLINESNUM Mask */
N
N/*@} end of group CMSIS_NVIC */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SCB     System Control Block (SCB)
N  \brief    Type definitions for the System Control Block Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
X  volatile const  uint32_t CPUID;                   
N  __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register */
X  volatile uint32_t ICSR;                    
N  __IOM uint32_t VTOR;                   /*!< Offset: 0x008 (R/W)  Vector Table Offset Register */
X  volatile uint32_t VTOR;                    
N  __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register */
X  volatile uint32_t AIRCR;                   
N  __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
X  volatile uint32_t SCR;                     
N  __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register */
X  volatile uint32_t CCR;                     
N  __IOM uint8_t  SHP[12U];               /*!< Offset: 0x018 (R/W)  System Handlers Priority Registers (4-7, 8-11, 12-15) */
X  volatile uint8_t  SHP[12U];                
N  __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State Register */
X  volatile uint32_t SHCSR;                   
N  __IOM uint32_t CFSR;                   /*!< Offset: 0x028 (R/W)  Configurable Fault Status Register */
X  volatile uint32_t CFSR;                    
N  __IOM uint32_t HFSR;                   /*!< Offset: 0x02C (R/W)  HardFault Status Register */
X  volatile uint32_t HFSR;                    
N  __IOM uint32_t DFSR;                   /*!< Offset: 0x030 (R/W)  Debug Fault Status Register */
X  volatile uint32_t DFSR;                    
N  __IOM uint32_t MMFAR;                  /*!< Offset: 0x034 (R/W)  MemManage Fault Address Register */
X  volatile uint32_t MMFAR;                   
N  __IOM uint32_t BFAR;                   /*!< Offset: 0x038 (R/W)  BusFault Address Register */
X  volatile uint32_t BFAR;                    
N  __IOM uint32_t AFSR;                   /*!< Offset: 0x03C (R/W)  Auxiliary Fault Status Register */
X  volatile uint32_t AFSR;                    
N  __IM  uint32_t PFR[2U];                /*!< Offset: 0x040 (R/ )  Processor Feature Register */
X  volatile const  uint32_t PFR[2U];                 
N  __IM  uint32_t DFR;                    /*!< Offset: 0x048 (R/ )  Debug Feature Register */
X  volatile const  uint32_t DFR;                     
N  __IM  uint32_t ADR;                    /*!< Offset: 0x04C (R/ )  Auxiliary Feature Register */
X  volatile const  uint32_t ADR;                     
N  __IM  uint32_t MMFR[4U];               /*!< Offset: 0x050 (R/ )  Memory Model Feature Register */
X  volatile const  uint32_t MMFR[4U];                
N  __IM  uint32_t ISAR[5U];               /*!< Offset: 0x060 (R/ )  Instruction Set Attributes Register */
X  volatile const  uint32_t ISAR[5U];                
N        uint32_t RESERVED0[5U];
N  __IOM uint32_t CPACR;                  /*!< Offset: 0x088 (R/W)  Coprocessor Access Control Register */
X  volatile uint32_t CPACR;                   
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_RETTOBASE_Pos             11U                                            /*!< SCB ICSR: RETTOBASE Position */
N#define SCB_ICSR_RETTOBASE_Msk             (1UL << SCB_ICSR_RETTOBASE_Pos)                /*!< SCB ICSR: RETTOBASE Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Vector Table Offset Register Definitions */
N#define SCB_VTOR_TBLOFF_Pos                 7U                                            /*!< SCB VTOR: TBLOFF Position */
N#define SCB_VTOR_TBLOFF_Msk                (0x1FFFFFFUL << SCB_VTOR_TBLOFF_Pos)           /*!< SCB VTOR: TBLOFF Mask */
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_PRIGROUP_Pos              8U                                            /*!< SCB AIRCR: PRIGROUP Position */
N#define SCB_AIRCR_PRIGROUP_Msk             (7UL << SCB_AIRCR_PRIGROUP_Pos)                /*!< SCB AIRCR: PRIGROUP Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N#define SCB_AIRCR_VECTRESET_Pos             0U                                            /*!< SCB AIRCR: VECTRESET Position */
N#define SCB_AIRCR_VECTRESET_Msk            (1UL /*<< SCB_AIRCR_VECTRESET_Pos*/)           /*!< SCB AIRCR: VECTRESET Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_BFHFNMIGN_Pos               8U                                            /*!< SCB CCR: BFHFNMIGN Position */
N#define SCB_CCR_BFHFNMIGN_Msk              (1UL << SCB_CCR_BFHFNMIGN_Pos)                 /*!< SCB CCR: BFHFNMIGN Mask */
N
N#define SCB_CCR_DIV_0_TRP_Pos               4U                                            /*!< SCB CCR: DIV_0_TRP Position */
N#define SCB_CCR_DIV_0_TRP_Msk              (1UL << SCB_CCR_DIV_0_TRP_Pos)                 /*!< SCB CCR: DIV_0_TRP Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N#define SCB_CCR_USERSETMPEND_Pos            1U                                            /*!< SCB CCR: USERSETMPEND Position */
N#define SCB_CCR_USERSETMPEND_Msk           (1UL << SCB_CCR_USERSETMPEND_Pos)              /*!< SCB CCR: USERSETMPEND Mask */
N
N#define SCB_CCR_NONBASETHRDENA_Pos          0U                                            /*!< SCB CCR: NONBASETHRDENA Position */
N#define SCB_CCR_NONBASETHRDENA_Msk         (1UL /*<< SCB_CCR_NONBASETHRDENA_Pos*/)        /*!< SCB CCR: NONBASETHRDENA Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_USGFAULTENA_Pos          18U                                            /*!< SCB SHCSR: USGFAULTENA Position */
N#define SCB_SHCSR_USGFAULTENA_Msk          (1UL << SCB_SHCSR_USGFAULTENA_Pos)             /*!< SCB SHCSR: USGFAULTENA Mask */
N
N#define SCB_SHCSR_BUSFAULTENA_Pos          17U                                            /*!< SCB SHCSR: BUSFAULTENA Position */
N#define SCB_SHCSR_BUSFAULTENA_Msk          (1UL << SCB_SHCSR_BUSFAULTENA_Pos)             /*!< SCB SHCSR: BUSFAULTENA Mask */
N
N#define SCB_SHCSR_MEMFAULTENA_Pos          16U                                            /*!< SCB SHCSR: MEMFAULTENA Position */
N#define SCB_SHCSR_MEMFAULTENA_Msk          (1UL << SCB_SHCSR_MEMFAULTENA_Pos)             /*!< SCB SHCSR: MEMFAULTENA Mask */
N
N#define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N#define SCB_SHCSR_BUSFAULTPENDED_Pos       14U                                            /*!< SCB SHCSR: BUSFAULTPENDED Position */
N#define SCB_SHCSR_BUSFAULTPENDED_Msk       (1UL << SCB_SHCSR_BUSFAULTPENDED_Pos)          /*!< SCB SHCSR: BUSFAULTPENDED Mask */
N
N#define SCB_SHCSR_MEMFAULTPENDED_Pos       13U                                            /*!< SCB SHCSR: MEMFAULTPENDED Position */
N#define SCB_SHCSR_MEMFAULTPENDED_Msk       (1UL << SCB_SHCSR_MEMFAULTPENDED_Pos)          /*!< SCB SHCSR: MEMFAULTPENDED Mask */
N
N#define SCB_SHCSR_USGFAULTPENDED_Pos       12U                                            /*!< SCB SHCSR: USGFAULTPENDED Position */
N#define SCB_SHCSR_USGFAULTPENDED_Msk       (1UL << SCB_SHCSR_USGFAULTPENDED_Pos)          /*!< SCB SHCSR: USGFAULTPENDED Mask */
N
N#define SCB_SHCSR_SYSTICKACT_Pos           11U                                            /*!< SCB SHCSR: SYSTICKACT Position */
N#define SCB_SHCSR_SYSTICKACT_Msk           (1UL << SCB_SHCSR_SYSTICKACT_Pos)              /*!< SCB SHCSR: SYSTICKACT Mask */
N
N#define SCB_SHCSR_PENDSVACT_Pos            10U                                            /*!< SCB SHCSR: PENDSVACT Position */
N#define SCB_SHCSR_PENDSVACT_Msk            (1UL << SCB_SHCSR_PENDSVACT_Pos)               /*!< SCB SHCSR: PENDSVACT Mask */
N
N#define SCB_SHCSR_MONITORACT_Pos            8U                                            /*!< SCB SHCSR: MONITORACT Position */
N#define SCB_SHCSR_MONITORACT_Msk           (1UL << SCB_SHCSR_MONITORACT_Pos)              /*!< SCB SHCSR: MONITORACT Mask */
N
N#define SCB_SHCSR_SVCALLACT_Pos             7U                                            /*!< SCB SHCSR: SVCALLACT Position */
N#define SCB_SHCSR_SVCALLACT_Msk            (1UL << SCB_SHCSR_SVCALLACT_Pos)               /*!< SCB SHCSR: SVCALLACT Mask */
N
N#define SCB_SHCSR_USGFAULTACT_Pos           3U                                            /*!< SCB SHCSR: USGFAULTACT Position */
N#define SCB_SHCSR_USGFAULTACT_Msk          (1UL << SCB_SHCSR_USGFAULTACT_Pos)             /*!< SCB SHCSR: USGFAULTACT Mask */
N
N#define SCB_SHCSR_BUSFAULTACT_Pos           1U                                            /*!< SCB SHCSR: BUSFAULTACT Position */
N#define SCB_SHCSR_BUSFAULTACT_Msk          (1UL << SCB_SHCSR_BUSFAULTACT_Pos)             /*!< SCB SHCSR: BUSFAULTACT Mask */
N
N#define SCB_SHCSR_MEMFAULTACT_Pos           0U                                            /*!< SCB SHCSR: MEMFAULTACT Position */
N#define SCB_SHCSR_MEMFAULTACT_Msk          (1UL /*<< SCB_SHCSR_MEMFAULTACT_Pos*/)         /*!< SCB SHCSR: MEMFAULTACT Mask */
N
N/* SCB Configurable Fault Status Register Definitions */
N#define SCB_CFSR_USGFAULTSR_Pos            16U                                            /*!< SCB CFSR: Usage Fault Status Register Position */
N#define SCB_CFSR_USGFAULTSR_Msk            (0xFFFFUL << SCB_CFSR_USGFAULTSR_Pos)          /*!< SCB CFSR: Usage Fault Status Register Mask */
N
N#define SCB_CFSR_BUSFAULTSR_Pos             8U                                            /*!< SCB CFSR: Bus Fault Status Register Position */
N#define SCB_CFSR_BUSFAULTSR_Msk            (0xFFUL << SCB_CFSR_BUSFAULTSR_Pos)            /*!< SCB CFSR: Bus Fault Status Register Mask */
N
N#define SCB_CFSR_MEMFAULTSR_Pos             0U                                            /*!< SCB CFSR: Memory Manage Fault Status Register Position */
N#define SCB_CFSR_MEMFAULTSR_Msk            (0xFFUL /*<< SCB_CFSR_MEMFAULTSR_Pos*/)        /*!< SCB CFSR: Memory Manage Fault Status Register Mask */
N
N/* MemManage Fault Status Register (part of SCB Configurable Fault Status Register) */
N#define SCB_CFSR_MMARVALID_Pos             (SCB_SHCSR_MEMFAULTACT_Pos + 7U)               /*!< SCB CFSR (MMFSR): MMARVALID Position */
N#define SCB_CFSR_MMARVALID_Msk             (1UL << SCB_CFSR_MMARVALID_Pos)                /*!< SCB CFSR (MMFSR): MMARVALID Mask */
N
N#define SCB_CFSR_MLSPERR_Pos               (SCB_SHCSR_MEMFAULTACT_Pos + 5U)               /*!< SCB CFSR (MMFSR): MLSPERR Position */
N#define SCB_CFSR_MLSPERR_Msk               (1UL << SCB_CFSR_MLSPERR_Pos)                  /*!< SCB CFSR (MMFSR): MLSPERR Mask */
N
N#define SCB_CFSR_MSTKERR_Pos               (SCB_SHCSR_MEMFAULTACT_Pos + 4U)               /*!< SCB CFSR (MMFSR): MSTKERR Position */
N#define SCB_CFSR_MSTKERR_Msk               (1UL << SCB_CFSR_MSTKERR_Pos)                  /*!< SCB CFSR (MMFSR): MSTKERR Mask */
N
N#define SCB_CFSR_MUNSTKERR_Pos             (SCB_SHCSR_MEMFAULTACT_Pos + 3U)               /*!< SCB CFSR (MMFSR): MUNSTKERR Position */
N#define SCB_CFSR_MUNSTKERR_Msk             (1UL << SCB_CFSR_MUNSTKERR_Pos)                /*!< SCB CFSR (MMFSR): MUNSTKERR Mask */
N
N#define SCB_CFSR_DACCVIOL_Pos              (SCB_SHCSR_MEMFAULTACT_Pos + 1U)               /*!< SCB CFSR (MMFSR): DACCVIOL Position */
N#define SCB_CFSR_DACCVIOL_Msk              (1UL << SCB_CFSR_DACCVIOL_Pos)                 /*!< SCB CFSR (MMFSR): DACCVIOL Mask */
N
N#define SCB_CFSR_IACCVIOL_Pos              (SCB_SHCSR_MEMFAULTACT_Pos + 0U)               /*!< SCB CFSR (MMFSR): IACCVIOL Position */
N#define SCB_CFSR_IACCVIOL_Msk              (1UL /*<< SCB_CFSR_IACCVIOL_Pos*/)             /*!< SCB CFSR (MMFSR): IACCVIOL Mask */
N
N/* BusFault Status Register (part of SCB Configurable Fault Status Register) */
N#define SCB_CFSR_BFARVALID_Pos            (SCB_CFSR_BUSFAULTSR_Pos + 7U)                  /*!< SCB CFSR (BFSR): BFARVALID Position */
N#define SCB_CFSR_BFARVALID_Msk            (1UL << SCB_CFSR_BFARVALID_Pos)                 /*!< SCB CFSR (BFSR): BFARVALID Mask */
N
N#define SCB_CFSR_LSPERR_Pos               (SCB_CFSR_BUSFAULTSR_Pos + 5U)                  /*!< SCB CFSR (BFSR): LSPERR Position */
N#define SCB_CFSR_LSPERR_Msk               (1UL << SCB_CFSR_LSPERR_Pos)                    /*!< SCB CFSR (BFSR): LSPERR Mask */
N
N#define SCB_CFSR_STKERR_Pos               (SCB_CFSR_BUSFAULTSR_Pos + 4U)                  /*!< SCB CFSR (BFSR): STKERR Position */
N#define SCB_CFSR_STKERR_Msk               (1UL << SCB_CFSR_STKERR_Pos)                    /*!< SCB CFSR (BFSR): STKERR Mask */
N
N#define SCB_CFSR_UNSTKERR_Pos             (SCB_CFSR_BUSFAULTSR_Pos + 3U)                  /*!< SCB CFSR (BFSR): UNSTKERR Position */
N#define SCB_CFSR_UNSTKERR_Msk             (1UL << SCB_CFSR_UNSTKERR_Pos)                  /*!< SCB CFSR (BFSR): UNSTKERR Mask */
N
N#define SCB_CFSR_IMPRECISERR_Pos          (SCB_CFSR_BUSFAULTSR_Pos + 2U)                  /*!< SCB CFSR (BFSR): IMPRECISERR Position */
N#define SCB_CFSR_IMPRECISERR_Msk          (1UL << SCB_CFSR_IMPRECISERR_Pos)               /*!< SCB CFSR (BFSR): IMPRECISERR Mask */
N
N#define SCB_CFSR_PRECISERR_Pos            (SCB_CFSR_BUSFAULTSR_Pos + 1U)                  /*!< SCB CFSR (BFSR): PRECISERR Position */
N#define SCB_CFSR_PRECISERR_Msk            (1UL << SCB_CFSR_PRECISERR_Pos)                 /*!< SCB CFSR (BFSR): PRECISERR Mask */
N
N#define SCB_CFSR_IBUSERR_Pos              (SCB_CFSR_BUSFAULTSR_Pos + 0U)                  /*!< SCB CFSR (BFSR): IBUSERR Position */
N#define SCB_CFSR_IBUSERR_Msk              (1UL << SCB_CFSR_IBUSERR_Pos)                   /*!< SCB CFSR (BFSR): IBUSERR Mask */
N
N/* UsageFault Status Register (part of SCB Configurable Fault Status Register) */
N#define SCB_CFSR_DIVBYZERO_Pos            (SCB_CFSR_USGFAULTSR_Pos + 9U)                  /*!< SCB CFSR (UFSR): DIVBYZERO Position */
N#define SCB_CFSR_DIVBYZERO_Msk            (1UL << SCB_CFSR_DIVBYZERO_Pos)                 /*!< SCB CFSR (UFSR): DIVBYZERO Mask */
N
N#define SCB_CFSR_UNALIGNED_Pos            (SCB_CFSR_USGFAULTSR_Pos + 8U)                  /*!< SCB CFSR (UFSR): UNALIGNED Position */
N#define SCB_CFSR_UNALIGNED_Msk            (1UL << SCB_CFSR_UNALIGNED_Pos)                 /*!< SCB CFSR (UFSR): UNALIGNED Mask */
N
N#define SCB_CFSR_NOCP_Pos                 (SCB_CFSR_USGFAULTSR_Pos + 3U)                  /*!< SCB CFSR (UFSR): NOCP Position */
N#define SCB_CFSR_NOCP_Msk                 (1UL << SCB_CFSR_NOCP_Pos)                      /*!< SCB CFSR (UFSR): NOCP Mask */
N
N#define SCB_CFSR_INVPC_Pos                (SCB_CFSR_USGFAULTSR_Pos + 2U)                  /*!< SCB CFSR (UFSR): INVPC Position */
N#define SCB_CFSR_INVPC_Msk                (1UL << SCB_CFSR_INVPC_Pos)                     /*!< SCB CFSR (UFSR): INVPC Mask */
N
N#define SCB_CFSR_INVSTATE_Pos             (SCB_CFSR_USGFAULTSR_Pos + 1U)                  /*!< SCB CFSR (UFSR): INVSTATE Position */
N#define SCB_CFSR_INVSTATE_Msk             (1UL << SCB_CFSR_INVSTATE_Pos)                  /*!< SCB CFSR (UFSR): INVSTATE Mask */
N
N#define SCB_CFSR_UNDEFINSTR_Pos           (SCB_CFSR_USGFAULTSR_Pos + 0U)                  /*!< SCB CFSR (UFSR): UNDEFINSTR Position */
N#define SCB_CFSR_UNDEFINSTR_Msk           (1UL << SCB_CFSR_UNDEFINSTR_Pos)                /*!< SCB CFSR (UFSR): UNDEFINSTR Mask */
N
N/* SCB Hard Fault Status Register Definitions */
N#define SCB_HFSR_DEBUGEVT_Pos              31U                                            /*!< SCB HFSR: DEBUGEVT Position */
N#define SCB_HFSR_DEBUGEVT_Msk              (1UL << SCB_HFSR_DEBUGEVT_Pos)                 /*!< SCB HFSR: DEBUGEVT Mask */
N
N#define SCB_HFSR_FORCED_Pos                30U                                            /*!< SCB HFSR: FORCED Position */
N#define SCB_HFSR_FORCED_Msk                (1UL << SCB_HFSR_FORCED_Pos)                   /*!< SCB HFSR: FORCED Mask */
N
N#define SCB_HFSR_VECTTBL_Pos                1U                                            /*!< SCB HFSR: VECTTBL Position */
N#define SCB_HFSR_VECTTBL_Msk               (1UL << SCB_HFSR_VECTTBL_Pos)                  /*!< SCB HFSR: VECTTBL Mask */
N
N/* SCB Debug Fault Status Register Definitions */
N#define SCB_DFSR_EXTERNAL_Pos               4U                                            /*!< SCB DFSR: EXTERNAL Position */
N#define SCB_DFSR_EXTERNAL_Msk              (1UL << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB DFSR: EXTERNAL Mask */
N
N#define SCB_DFSR_VCATCH_Pos                 3U                                            /*!< SCB DFSR: VCATCH Position */
N#define SCB_DFSR_VCATCH_Msk                (1UL << SCB_DFSR_VCATCH_Pos)                   /*!< SCB DFSR: VCATCH Mask */
N
N#define SCB_DFSR_DWTTRAP_Pos                2U                                            /*!< SCB DFSR: DWTTRAP Position */
N#define SCB_DFSR_DWTTRAP_Msk               (1UL << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB DFSR: DWTTRAP Mask */
N
N#define SCB_DFSR_BKPT_Pos                   1U                                            /*!< SCB DFSR: BKPT Position */
N#define SCB_DFSR_BKPT_Msk                  (1UL << SCB_DFSR_BKPT_Pos)                     /*!< SCB DFSR: BKPT Mask */
N
N#define SCB_DFSR_HALTED_Pos                 0U                                            /*!< SCB DFSR: HALTED Position */
N#define SCB_DFSR_HALTED_Msk                (1UL /*<< SCB_DFSR_HALTED_Pos*/)               /*!< SCB DFSR: HALTED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SCnSCB System Controls not in SCB (SCnSCB)
N  \brief    Type definitions for the System Control and ID Register not in the SCB
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Control and ID Register not in the SCB.
N */
Ntypedef struct
N{
N        uint32_t RESERVED0[1U];
N  __IM  uint32_t ICTR;                   /*!< Offset: 0x004 (R/ )  Interrupt Controller Type Register */
X  volatile const  uint32_t ICTR;                    
N  __IOM uint32_t ACTLR;                  /*!< Offset: 0x008 (R/W)  Auxiliary Control Register */
X  volatile uint32_t ACTLR;                   
N} SCnSCB_Type;
N
N/* Interrupt Controller Type Register Definitions */
N#define SCnSCB_ICTR_INTLINESNUM_Pos         0U                                         /*!< ICTR: INTLINESNUM Position */
N#define SCnSCB_ICTR_INTLINESNUM_Msk        (0xFUL /*<< SCnSCB_ICTR_INTLINESNUM_Pos*/)  /*!< ICTR: INTLINESNUM Mask */
N
N/* Auxiliary Control Register Definitions */
N#define SCnSCB_ACTLR_DISOOFP_Pos            9U                                         /*!< ACTLR: DISOOFP Position */
N#define SCnSCB_ACTLR_DISOOFP_Msk           (1UL << SCnSCB_ACTLR_DISOOFP_Pos)           /*!< ACTLR: DISOOFP Mask */
N
N#define SCnSCB_ACTLR_DISFPCA_Pos            8U                                         /*!< ACTLR: DISFPCA Position */
N#define SCnSCB_ACTLR_DISFPCA_Msk           (1UL << SCnSCB_ACTLR_DISFPCA_Pos)           /*!< ACTLR: DISFPCA Mask */
N
N#define SCnSCB_ACTLR_DISFOLD_Pos            2U                                         /*!< ACTLR: DISFOLD Position */
N#define SCnSCB_ACTLR_DISFOLD_Msk           (1UL << SCnSCB_ACTLR_DISFOLD_Pos)           /*!< ACTLR: DISFOLD Mask */
N
N#define SCnSCB_ACTLR_DISDEFWBUF_Pos         1U                                         /*!< ACTLR: DISDEFWBUF Position */
N#define SCnSCB_ACTLR_DISDEFWBUF_Msk        (1UL << SCnSCB_ACTLR_DISDEFWBUF_Pos)        /*!< ACTLR: DISDEFWBUF Mask */
N
N#define SCnSCB_ACTLR_DISMCYCINT_Pos         0U                                         /*!< ACTLR: DISMCYCINT Position */
N#define SCnSCB_ACTLR_DISMCYCINT_Msk        (1UL /*<< SCnSCB_ACTLR_DISMCYCINT_Pos*/)    /*!< ACTLR: DISMCYCINT Mask */
N
N/*@} end of group CMSIS_SCnotSCB */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
N  \brief    Type definitions for the System Timer Registers.
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
X  volatile uint32_t LOAD;                    
N  __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register */
X  volatile uint32_t VAL;                     
N  __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
X  volatile const  uint32_t CALIB;                   
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_ITM     Instrumentation Trace Macrocell (ITM)
N  \brief    Type definitions for the Instrumentation Trace Macrocell (ITM)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Instrumentation Trace Macrocell Register (ITM).
N */
Ntypedef struct
N{
N  __OM  union
X  volatile  union
N  {
N    __OM  uint8_t    u8;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 8-bit */
X    volatile  uint8_t    u8;                  
N    __OM  uint16_t   u16;                /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 16-bit */
X    volatile  uint16_t   u16;                 
N    __OM  uint32_t   u32;                /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 32-bit */
X    volatile  uint32_t   u32;                 
N  }  PORT [32U];                         /*!< Offset: 0x000 ( /W)  ITM Stimulus Port Registers */
N        uint32_t RESERVED0[864U];
N  __IOM uint32_t TER;                    /*!< Offset: 0xE00 (R/W)  ITM Trace Enable Register */
X  volatile uint32_t TER;                     
N        uint32_t RESERVED1[15U];
N  __IOM uint32_t TPR;                    /*!< Offset: 0xE40 (R/W)  ITM Trace Privilege Register */
X  volatile uint32_t TPR;                     
N        uint32_t RESERVED2[15U];
N  __IOM uint32_t TCR;                    /*!< Offset: 0xE80 (R/W)  ITM Trace Control Register */
X  volatile uint32_t TCR;                     
N        uint32_t RESERVED3[29U];
N  __OM  uint32_t IWR;                    /*!< Offset: 0xEF8 ( /W)  ITM Integration Write Register */
X  volatile  uint32_t IWR;                     
N  __IM  uint32_t IRR;                    /*!< Offset: 0xEFC (R/ )  ITM Integration Read Register */
X  volatile const  uint32_t IRR;                     
N  __IOM uint32_t IMCR;                   /*!< Offset: 0xF00 (R/W)  ITM Integration Mode Control Register */
X  volatile uint32_t IMCR;                    
N        uint32_t RESERVED4[43U];
N  __OM  uint32_t LAR;                    /*!< Offset: 0xFB0 ( /W)  ITM Lock Access Register */
X  volatile  uint32_t LAR;                     
N  __IM  uint32_t LSR;                    /*!< Offset: 0xFB4 (R/ )  ITM Lock Status Register */
X  volatile const  uint32_t LSR;                     
N        uint32_t RESERVED5[6U];
N  __IM  uint32_t PID4;                   /*!< Offset: 0xFD0 (R/ )  ITM Peripheral Identification Register #4 */
X  volatile const  uint32_t PID4;                    
N  __IM  uint32_t PID5;                   /*!< Offset: 0xFD4 (R/ )  ITM Peripheral Identification Register #5 */
X  volatile const  uint32_t PID5;                    
N  __IM  uint32_t PID6;                   /*!< Offset: 0xFD8 (R/ )  ITM Peripheral Identification Register #6 */
X  volatile const  uint32_t PID6;                    
N  __IM  uint32_t PID7;                   /*!< Offset: 0xFDC (R/ )  ITM Peripheral Identification Register #7 */
X  volatile const  uint32_t PID7;                    
N  __IM  uint32_t PID0;                   /*!< Offset: 0xFE0 (R/ )  ITM Peripheral Identification Register #0 */
X  volatile const  uint32_t PID0;                    
N  __IM  uint32_t PID1;                   /*!< Offset: 0xFE4 (R/ )  ITM Peripheral Identification Register #1 */
X  volatile const  uint32_t PID1;                    
N  __IM  uint32_t PID2;                   /*!< Offset: 0xFE8 (R/ )  ITM Peripheral Identification Register #2 */
X  volatile const  uint32_t PID2;                    
N  __IM  uint32_t PID3;                   /*!< Offset: 0xFEC (R/ )  ITM Peripheral Identification Register #3 */
X  volatile const  uint32_t PID3;                    
N  __IM  uint32_t CID0;                   /*!< Offset: 0xFF0 (R/ )  ITM Component  Identification Register #0 */
X  volatile const  uint32_t CID0;                    
N  __IM  uint32_t CID1;                   /*!< Offset: 0xFF4 (R/ )  ITM Component  Identification Register #1 */
X  volatile const  uint32_t CID1;                    
N  __IM  uint32_t CID2;                   /*!< Offset: 0xFF8 (R/ )  ITM Component  Identification Register #2 */
X  volatile const  uint32_t CID2;                    
N  __IM  uint32_t CID3;                   /*!< Offset: 0xFFC (R/ )  ITM Component  Identification Register #3 */
X  volatile const  uint32_t CID3;                    
N} ITM_Type;
N
N/* ITM Trace Privilege Register Definitions */
N#define ITM_TPR_PRIVMASK_Pos                0U                                            /*!< ITM TPR: PRIVMASK Position */
N#define ITM_TPR_PRIVMASK_Msk               (0xFUL /*<< ITM_TPR_PRIVMASK_Pos*/)            /*!< ITM TPR: PRIVMASK Mask */
N
N/* ITM Trace Control Register Definitions */
N#define ITM_TCR_BUSY_Pos                   23U                                            /*!< ITM TCR: BUSY Position */
N#define ITM_TCR_BUSY_Msk                   (1UL << ITM_TCR_BUSY_Pos)                      /*!< ITM TCR: BUSY Mask */
N
N#define ITM_TCR_TraceBusID_Pos             16U                                            /*!< ITM TCR: ATBID Position */
N#define ITM_TCR_TraceBusID_Msk             (0x7FUL << ITM_TCR_TraceBusID_Pos)             /*!< ITM TCR: ATBID Mask */
N
N#define ITM_TCR_GTSFREQ_Pos                10U                                            /*!< ITM TCR: Global timestamp frequency Position */
N#define ITM_TCR_GTSFREQ_Msk                (3UL << ITM_TCR_GTSFREQ_Pos)                   /*!< ITM TCR: Global timestamp frequency Mask */
N
N#define ITM_TCR_TSPrescale_Pos              8U                                            /*!< ITM TCR: TSPrescale Position */
N#define ITM_TCR_TSPrescale_Msk             (3UL << ITM_TCR_TSPrescale_Pos)                /*!< ITM TCR: TSPrescale Mask */
N
N#define ITM_TCR_SWOENA_Pos                  4U                                            /*!< ITM TCR: SWOENA Position */
N#define ITM_TCR_SWOENA_Msk                 (1UL << ITM_TCR_SWOENA_Pos)                    /*!< ITM TCR: SWOENA Mask */
N
N#define ITM_TCR_DWTENA_Pos                  3U                                            /*!< ITM TCR: DWTENA Position */
N#define ITM_TCR_DWTENA_Msk                 (1UL << ITM_TCR_DWTENA_Pos)                    /*!< ITM TCR: DWTENA Mask */
N
N#define ITM_TCR_SYNCENA_Pos                 2U                                            /*!< ITM TCR: SYNCENA Position */
N#define ITM_TCR_SYNCENA_Msk                (1UL << ITM_TCR_SYNCENA_Pos)                   /*!< ITM TCR: SYNCENA Mask */
N
N#define ITM_TCR_TSENA_Pos                   1U                                            /*!< ITM TCR: TSENA Position */
N#define ITM_TCR_TSENA_Msk                  (1UL << ITM_TCR_TSENA_Pos)                     /*!< ITM TCR: TSENA Mask */
N
N#define ITM_TCR_ITMENA_Pos                  0U                                            /*!< ITM TCR: ITM Enable bit Position */
N#define ITM_TCR_ITMENA_Msk                 (1UL /*<< ITM_TCR_ITMENA_Pos*/)                /*!< ITM TCR: ITM Enable bit Mask */
N
N/* ITM Integration Write Register Definitions */
N#define ITM_IWR_ATVALIDM_Pos                0U                                            /*!< ITM IWR: ATVALIDM Position */
N#define ITM_IWR_ATVALIDM_Msk               (1UL /*<< ITM_IWR_ATVALIDM_Pos*/)              /*!< ITM IWR: ATVALIDM Mask */
N
N/* ITM Integration Read Register Definitions */
N#define ITM_IRR_ATREADYM_Pos                0U                                            /*!< ITM IRR: ATREADYM Position */
N#define ITM_IRR_ATREADYM_Msk               (1UL /*<< ITM_IRR_ATREADYM_Pos*/)              /*!< ITM IRR: ATREADYM Mask */
N
N/* ITM Integration Mode Control Register Definitions */
N#define ITM_IMCR_INTEGRATION_Pos            0U                                            /*!< ITM IMCR: INTEGRATION Position */
N#define ITM_IMCR_INTEGRATION_Msk           (1UL /*<< ITM_IMCR_INTEGRATION_Pos*/)          /*!< ITM IMCR: INTEGRATION Mask */
N
N/* ITM Lock Status Register Definitions */
N#define ITM_LSR_ByteAcc_Pos                 2U                                            /*!< ITM LSR: ByteAcc Position */
N#define ITM_LSR_ByteAcc_Msk                (1UL << ITM_LSR_ByteAcc_Pos)                   /*!< ITM LSR: ByteAcc Mask */
N
N#define ITM_LSR_Access_Pos                  1U                                            /*!< ITM LSR: Access Position */
N#define ITM_LSR_Access_Msk                 (1UL << ITM_LSR_Access_Pos)                    /*!< ITM LSR: Access Mask */
N
N#define ITM_LSR_Present_Pos                 0U                                            /*!< ITM LSR: Present Position */
N#define ITM_LSR_Present_Msk                (1UL /*<< ITM_LSR_Present_Pos*/)               /*!< ITM LSR: Present Mask */
N
N/*@}*/ /* end of group CMSIS_ITM */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_DWT     Data Watchpoint and Trace (DWT)
N  \brief    Type definitions for the Data Watchpoint and Trace (DWT)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Data Watchpoint and Trace Register (DWT).
N */
Ntypedef struct
N{
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  Control Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t CYCCNT;                 /*!< Offset: 0x004 (R/W)  Cycle Count Register */
X  volatile uint32_t CYCCNT;                  
N  __IOM uint32_t CPICNT;                 /*!< Offset: 0x008 (R/W)  CPI Count Register */
X  volatile uint32_t CPICNT;                  
N  __IOM uint32_t EXCCNT;                 /*!< Offset: 0x00C (R/W)  Exception Overhead Count Register */
X  volatile uint32_t EXCCNT;                  
N  __IOM uint32_t SLEEPCNT;               /*!< Offset: 0x010 (R/W)  Sleep Count Register */
X  volatile uint32_t SLEEPCNT;                
N  __IOM uint32_t LSUCNT;                 /*!< Offset: 0x014 (R/W)  LSU Count Register */
X  volatile uint32_t LSUCNT;                  
N  __IOM uint32_t FOLDCNT;                /*!< Offset: 0x018 (R/W)  Folded-instruction Count Register */
X  volatile uint32_t FOLDCNT;                 
N  __IM  uint32_t PCSR;                   /*!< Offset: 0x01C (R/ )  Program Counter Sample Register */
X  volatile const  uint32_t PCSR;                    
N  __IOM uint32_t COMP0;                  /*!< Offset: 0x020 (R/W)  Comparator Register 0 */
X  volatile uint32_t COMP0;                   
N  __IOM uint32_t MASK0;                  /*!< Offset: 0x024 (R/W)  Mask Register 0 */
X  volatile uint32_t MASK0;                   
N  __IOM uint32_t FUNCTION0;              /*!< Offset: 0x028 (R/W)  Function Register 0 */
X  volatile uint32_t FUNCTION0;               
N        uint32_t RESERVED0[1U];
N  __IOM uint32_t COMP1;                  /*!< Offset: 0x030 (R/W)  Comparator Register 1 */
X  volatile uint32_t COMP1;                   
N  __IOM uint32_t MASK1;                  /*!< Offset: 0x034 (R/W)  Mask Register 1 */
X  volatile uint32_t MASK1;                   
N  __IOM uint32_t FUNCTION1;              /*!< Offset: 0x038 (R/W)  Function Register 1 */
X  volatile uint32_t FUNCTION1;               
N        uint32_t RESERVED1[1U];
N  __IOM uint32_t COMP2;                  /*!< Offset: 0x040 (R/W)  Comparator Register 2 */
X  volatile uint32_t COMP2;                   
N  __IOM uint32_t MASK2;                  /*!< Offset: 0x044 (R/W)  Mask Register 2 */
X  volatile uint32_t MASK2;                   
N  __IOM uint32_t FUNCTION2;              /*!< Offset: 0x048 (R/W)  Function Register 2 */
X  volatile uint32_t FUNCTION2;               
N        uint32_t RESERVED2[1U];
N  __IOM uint32_t COMP3;                  /*!< Offset: 0x050 (R/W)  Comparator Register 3 */
X  volatile uint32_t COMP3;                   
N  __IOM uint32_t MASK3;                  /*!< Offset: 0x054 (R/W)  Mask Register 3 */
X  volatile uint32_t MASK3;                   
N  __IOM uint32_t FUNCTION3;              /*!< Offset: 0x058 (R/W)  Function Register 3 */
X  volatile uint32_t FUNCTION3;               
N} DWT_Type;
N
N/* DWT Control Register Definitions */
N#define DWT_CTRL_NUMCOMP_Pos               28U                                         /*!< DWT CTRL: NUMCOMP Position */
N#define DWT_CTRL_NUMCOMP_Msk               (0xFUL << DWT_CTRL_NUMCOMP_Pos)             /*!< DWT CTRL: NUMCOMP Mask */
N
N#define DWT_CTRL_NOTRCPKT_Pos              27U                                         /*!< DWT CTRL: NOTRCPKT Position */
N#define DWT_CTRL_NOTRCPKT_Msk              (0x1UL << DWT_CTRL_NOTRCPKT_Pos)            /*!< DWT CTRL: NOTRCPKT Mask */
N
N#define DWT_CTRL_NOEXTTRIG_Pos             26U                                         /*!< DWT CTRL: NOEXTTRIG Position */
N#define DWT_CTRL_NOEXTTRIG_Msk             (0x1UL << DWT_CTRL_NOEXTTRIG_Pos)           /*!< DWT CTRL: NOEXTTRIG Mask */
N
N#define DWT_CTRL_NOCYCCNT_Pos              25U                                         /*!< DWT CTRL: NOCYCCNT Position */
N#define DWT_CTRL_NOCYCCNT_Msk              (0x1UL << DWT_CTRL_NOCYCCNT_Pos)            /*!< DWT CTRL: NOCYCCNT Mask */
N
N#define DWT_CTRL_NOPRFCNT_Pos              24U                                         /*!< DWT CTRL: NOPRFCNT Position */
N#define DWT_CTRL_NOPRFCNT_Msk              (0x1UL << DWT_CTRL_NOPRFCNT_Pos)            /*!< DWT CTRL: NOPRFCNT Mask */
N
N#define DWT_CTRL_CYCEVTENA_Pos             22U                                         /*!< DWT CTRL: CYCEVTENA Position */
N#define DWT_CTRL_CYCEVTENA_Msk             (0x1UL << DWT_CTRL_CYCEVTENA_Pos)           /*!< DWT CTRL: CYCEVTENA Mask */
N
N#define DWT_CTRL_FOLDEVTENA_Pos            21U                                         /*!< DWT CTRL: FOLDEVTENA Position */
N#define DWT_CTRL_FOLDEVTENA_Msk            (0x1UL << DWT_CTRL_FOLDEVTENA_Pos)          /*!< DWT CTRL: FOLDEVTENA Mask */
N
N#define DWT_CTRL_LSUEVTENA_Pos             20U                                         /*!< DWT CTRL: LSUEVTENA Position */
N#define DWT_CTRL_LSUEVTENA_Msk             (0x1UL << DWT_CTRL_LSUEVTENA_Pos)           /*!< DWT CTRL: LSUEVTENA Mask */
N
N#define DWT_CTRL_SLEEPEVTENA_Pos           19U                                         /*!< DWT CTRL: SLEEPEVTENA Position */
N#define DWT_CTRL_SLEEPEVTENA_Msk           (0x1UL << DWT_CTRL_SLEEPEVTENA_Pos)         /*!< DWT CTRL: SLEEPEVTENA Mask */
N
N#define DWT_CTRL_EXCEVTENA_Pos             18U                                         /*!< DWT CTRL: EXCEVTENA Position */
N#define DWT_CTRL_EXCEVTENA_Msk             (0x1UL << DWT_CTRL_EXCEVTENA_Pos)           /*!< DWT CTRL: EXCEVTENA Mask */
N
N#define DWT_CTRL_CPIEVTENA_Pos             17U                                         /*!< DWT CTRL: CPIEVTENA Position */
N#define DWT_CTRL_CPIEVTENA_Msk             (0x1UL << DWT_CTRL_CPIEVTENA_Pos)           /*!< DWT CTRL: CPIEVTENA Mask */
N
N#define DWT_CTRL_EXCTRCENA_Pos             16U                                         /*!< DWT CTRL: EXCTRCENA Position */
N#define DWT_CTRL_EXCTRCENA_Msk             (0x1UL << DWT_CTRL_EXCTRCENA_Pos)           /*!< DWT CTRL: EXCTRCENA Mask */
N
N#define DWT_CTRL_PCSAMPLENA_Pos            12U                                         /*!< DWT CTRL: PCSAMPLENA Position */
N#define DWT_CTRL_PCSAMPLENA_Msk            (0x1UL << DWT_CTRL_PCSAMPLENA_Pos)          /*!< DWT CTRL: PCSAMPLENA Mask */
N
N#define DWT_CTRL_SYNCTAP_Pos               10U                                         /*!< DWT CTRL: SYNCTAP Position */
N#define DWT_CTRL_SYNCTAP_Msk               (0x3UL << DWT_CTRL_SYNCTAP_Pos)             /*!< DWT CTRL: SYNCTAP Mask */
N
N#define DWT_CTRL_CYCTAP_Pos                 9U                                         /*!< DWT CTRL: CYCTAP Position */
N#define DWT_CTRL_CYCTAP_Msk                (0x1UL << DWT_CTRL_CYCTAP_Pos)              /*!< DWT CTRL: CYCTAP Mask */
N
N#define DWT_CTRL_POSTINIT_Pos               5U                                         /*!< DWT CTRL: POSTINIT Position */
N#define DWT_CTRL_POSTINIT_Msk              (0xFUL << DWT_CTRL_POSTINIT_Pos)            /*!< DWT CTRL: POSTINIT Mask */
N
N#define DWT_CTRL_POSTPRESET_Pos             1U                                         /*!< DWT CTRL: POSTPRESET Position */
N#define DWT_CTRL_POSTPRESET_Msk            (0xFUL << DWT_CTRL_POSTPRESET_Pos)          /*!< DWT CTRL: POSTPRESET Mask */
N
N#define DWT_CTRL_CYCCNTENA_Pos              0U                                         /*!< DWT CTRL: CYCCNTENA Position */
N#define DWT_CTRL_CYCCNTENA_Msk             (0x1UL /*<< DWT_CTRL_CYCCNTENA_Pos*/)       /*!< DWT CTRL: CYCCNTENA Mask */
N
N/* DWT CPI Count Register Definitions */
N#define DWT_CPICNT_CPICNT_Pos               0U                                         /*!< DWT CPICNT: CPICNT Position */
N#define DWT_CPICNT_CPICNT_Msk              (0xFFUL /*<< DWT_CPICNT_CPICNT_Pos*/)       /*!< DWT CPICNT: CPICNT Mask */
N
N/* DWT Exception Overhead Count Register Definitions */
N#define DWT_EXCCNT_EXCCNT_Pos               0U                                         /*!< DWT EXCCNT: EXCCNT Position */
N#define DWT_EXCCNT_EXCCNT_Msk              (0xFFUL /*<< DWT_EXCCNT_EXCCNT_Pos*/)       /*!< DWT EXCCNT: EXCCNT Mask */
N
N/* DWT Sleep Count Register Definitions */
N#define DWT_SLEEPCNT_SLEEPCNT_Pos           0U                                         /*!< DWT SLEEPCNT: SLEEPCNT Position */
N#define DWT_SLEEPCNT_SLEEPCNT_Msk          (0xFFUL /*<< DWT_SLEEPCNT_SLEEPCNT_Pos*/)   /*!< DWT SLEEPCNT: SLEEPCNT Mask */
N
N/* DWT LSU Count Register Definitions */
N#define DWT_LSUCNT_LSUCNT_Pos               0U                                         /*!< DWT LSUCNT: LSUCNT Position */
N#define DWT_LSUCNT_LSUCNT_Msk              (0xFFUL /*<< DWT_LSUCNT_LSUCNT_Pos*/)       /*!< DWT LSUCNT: LSUCNT Mask */
N
N/* DWT Folded-instruction Count Register Definitions */
N#define DWT_FOLDCNT_FOLDCNT_Pos             0U                                         /*!< DWT FOLDCNT: FOLDCNT Position */
N#define DWT_FOLDCNT_FOLDCNT_Msk            (0xFFUL /*<< DWT_FOLDCNT_FOLDCNT_Pos*/)     /*!< DWT FOLDCNT: FOLDCNT Mask */
N
N/* DWT Comparator Mask Register Definitions */
N#define DWT_MASK_MASK_Pos                   0U                                         /*!< DWT MASK: MASK Position */
N#define DWT_MASK_MASK_Msk                  (0x1FUL /*<< DWT_MASK_MASK_Pos*/)           /*!< DWT MASK: MASK Mask */
N
N/* DWT Comparator Function Register Definitions */
N#define DWT_FUNCTION_MATCHED_Pos           24U                                         /*!< DWT FUNCTION: MATCHED Position */
N#define DWT_FUNCTION_MATCHED_Msk           (0x1UL << DWT_FUNCTION_MATCHED_Pos)         /*!< DWT FUNCTION: MATCHED Mask */
N
N#define DWT_FUNCTION_DATAVADDR1_Pos        16U                                         /*!< DWT FUNCTION: DATAVADDR1 Position */
N#define DWT_FUNCTION_DATAVADDR1_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR1_Pos)      /*!< DWT FUNCTION: DATAVADDR1 Mask */
N
N#define DWT_FUNCTION_DATAVADDR0_Pos        12U                                         /*!< DWT FUNCTION: DATAVADDR0 Position */
N#define DWT_FUNCTION_DATAVADDR0_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR0_Pos)      /*!< DWT FUNCTION: DATAVADDR0 Mask */
N
N#define DWT_FUNCTION_DATAVSIZE_Pos         10U                                         /*!< DWT FUNCTION: DATAVSIZE Position */
N#define DWT_FUNCTION_DATAVSIZE_Msk         (0x3UL << DWT_FUNCTION_DATAVSIZE_Pos)       /*!< DWT FUNCTION: DATAVSIZE Mask */
N
N#define DWT_FUNCTION_LNK1ENA_Pos            9U                                         /*!< DWT FUNCTION: LNK1ENA Position */
N#define DWT_FUNCTION_LNK1ENA_Msk           (0x1UL << DWT_FUNCTION_LNK1ENA_Pos)         /*!< DWT FUNCTION: LNK1ENA Mask */
N
N#define DWT_FUNCTION_DATAVMATCH_Pos         8U                                         /*!< DWT FUNCTION: DATAVMATCH Position */
N#define DWT_FUNCTION_DATAVMATCH_Msk        (0x1UL << DWT_FUNCTION_DATAVMATCH_Pos)      /*!< DWT FUNCTION: DATAVMATCH Mask */
N
N#define DWT_FUNCTION_CYCMATCH_Pos           7U                                         /*!< DWT FUNCTION: CYCMATCH Position */
N#define DWT_FUNCTION_CYCMATCH_Msk          (0x1UL << DWT_FUNCTION_CYCMATCH_Pos)        /*!< DWT FUNCTION: CYCMATCH Mask */
N
N#define DWT_FUNCTION_EMITRANGE_Pos          5U                                         /*!< DWT FUNCTION: EMITRANGE Position */
N#define DWT_FUNCTION_EMITRANGE_Msk         (0x1UL << DWT_FUNCTION_EMITRANGE_Pos)       /*!< DWT FUNCTION: EMITRANGE Mask */
N
N#define DWT_FUNCTION_FUNCTION_Pos           0U                                         /*!< DWT FUNCTION: FUNCTION Position */
N#define DWT_FUNCTION_FUNCTION_Msk          (0xFUL /*<< DWT_FUNCTION_FUNCTION_Pos*/)    /*!< DWT FUNCTION: FUNCTION Mask */
N
N/*@}*/ /* end of group CMSIS_DWT */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_TPI     Trace Port Interface (TPI)
N  \brief    Type definitions for the Trace Port Interface (TPI)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Trace Port Interface Register (TPI).
N */
Ntypedef struct
N{
N  __IOM uint32_t SSPSR;                  /*!< Offset: 0x000 (R/ )  Supported Parallel Port Size Register */
X  volatile uint32_t SSPSR;                   
N  __IOM uint32_t CSPSR;                  /*!< Offset: 0x004 (R/W)  Current Parallel Port Size Register */
X  volatile uint32_t CSPSR;                   
N        uint32_t RESERVED0[2U];
N  __IOM uint32_t ACPR;                   /*!< Offset: 0x010 (R/W)  Asynchronous Clock Prescaler Register */
X  volatile uint32_t ACPR;                    
N        uint32_t RESERVED1[55U];
N  __IOM uint32_t SPPR;                   /*!< Offset: 0x0F0 (R/W)  Selected Pin Protocol Register */
X  volatile uint32_t SPPR;                    
N        uint32_t RESERVED2[131U];
N  __IM  uint32_t FFSR;                   /*!< Offset: 0x300 (R/ )  Formatter and Flush Status Register */
X  volatile const  uint32_t FFSR;                    
N  __IOM uint32_t FFCR;                   /*!< Offset: 0x304 (R/W)  Formatter and Flush Control Register */
X  volatile uint32_t FFCR;                    
N  __IM  uint32_t FSCR;                   /*!< Offset: 0x308 (R/ )  Formatter Synchronization Counter Register */
X  volatile const  uint32_t FSCR;                    
N        uint32_t RESERVED3[759U];
N  __IM  uint32_t TRIGGER;                /*!< Offset: 0xEE8 (R/ )  TRIGGER */
X  volatile const  uint32_t TRIGGER;                 
N  __IM  uint32_t FIFO0;                  /*!< Offset: 0xEEC (R/ )  Integration ETM Data */
X  volatile const  uint32_t FIFO0;                   
N  __IM  uint32_t ITATBCTR2;              /*!< Offset: 0xEF0 (R/ )  ITATBCTR2 */
X  volatile const  uint32_t ITATBCTR2;               
N        uint32_t RESERVED4[1U];
N  __IM  uint32_t ITATBCTR0;              /*!< Offset: 0xEF8 (R/ )  ITATBCTR0 */
X  volatile const  uint32_t ITATBCTR0;               
N  __IM  uint32_t FIFO1;                  /*!< Offset: 0xEFC (R/ )  Integration ITM Data */
X  volatile const  uint32_t FIFO1;                   
N  __IOM uint32_t ITCTRL;                 /*!< Offset: 0xF00 (R/W)  Integration Mode Control */
X  volatile uint32_t ITCTRL;                  
N        uint32_t RESERVED5[39U];
N  __IOM uint32_t CLAIMSET;               /*!< Offset: 0xFA0 (R/W)  Claim tag set */
X  volatile uint32_t CLAIMSET;                
N  __IOM uint32_t CLAIMCLR;               /*!< Offset: 0xFA4 (R/W)  Claim tag clear */
X  volatile uint32_t CLAIMCLR;                
N        uint32_t RESERVED7[8U];
N  __IM  uint32_t DEVID;                  /*!< Offset: 0xFC8 (R/ )  TPIU_DEVID */
X  volatile const  uint32_t DEVID;                   
N  __IM  uint32_t DEVTYPE;                /*!< Offset: 0xFCC (R/ )  TPIU_DEVTYPE */
X  volatile const  uint32_t DEVTYPE;                 
N} TPI_Type;
N
N/* TPI Asynchronous Clock Prescaler Register Definitions */
N#define TPI_ACPR_PRESCALER_Pos              0U                                         /*!< TPI ACPR: PRESCALER Position */
N#define TPI_ACPR_PRESCALER_Msk             (0x1FFFUL /*<< TPI_ACPR_PRESCALER_Pos*/)    /*!< TPI ACPR: PRESCALER Mask */
N
N/* TPI Selected Pin Protocol Register Definitions */
N#define TPI_SPPR_TXMODE_Pos                 0U                                         /*!< TPI SPPR: TXMODE Position */
N#define TPI_SPPR_TXMODE_Msk                (0x3UL /*<< TPI_SPPR_TXMODE_Pos*/)          /*!< TPI SPPR: TXMODE Mask */
N
N/* TPI Formatter and Flush Status Register Definitions */
N#define TPI_FFSR_FtNonStop_Pos              3U                                         /*!< TPI FFSR: FtNonStop Position */
N#define TPI_FFSR_FtNonStop_Msk             (0x1UL << TPI_FFSR_FtNonStop_Pos)           /*!< TPI FFSR: FtNonStop Mask */
N
N#define TPI_FFSR_TCPresent_Pos              2U                                         /*!< TPI FFSR: TCPresent Position */
N#define TPI_FFSR_TCPresent_Msk             (0x1UL << TPI_FFSR_TCPresent_Pos)           /*!< TPI FFSR: TCPresent Mask */
N
N#define TPI_FFSR_FtStopped_Pos              1U                                         /*!< TPI FFSR: FtStopped Position */
N#define TPI_FFSR_FtStopped_Msk             (0x1UL << TPI_FFSR_FtStopped_Pos)           /*!< TPI FFSR: FtStopped Mask */
N
N#define TPI_FFSR_FlInProg_Pos               0U                                         /*!< TPI FFSR: FlInProg Position */
N#define TPI_FFSR_FlInProg_Msk              (0x1UL /*<< TPI_FFSR_FlInProg_Pos*/)        /*!< TPI FFSR: FlInProg Mask */
N
N/* TPI Formatter and Flush Control Register Definitions */
N#define TPI_FFCR_TrigIn_Pos                 8U                                         /*!< TPI FFCR: TrigIn Position */
N#define TPI_FFCR_TrigIn_Msk                (0x1UL << TPI_FFCR_TrigIn_Pos)              /*!< TPI FFCR: TrigIn Mask */
N
N#define TPI_FFCR_EnFCont_Pos                1U                                         /*!< TPI FFCR: EnFCont Position */
N#define TPI_FFCR_EnFCont_Msk               (0x1UL << TPI_FFCR_EnFCont_Pos)             /*!< TPI FFCR: EnFCont Mask */
N
N/* TPI TRIGGER Register Definitions */
N#define TPI_TRIGGER_TRIGGER_Pos             0U                                         /*!< TPI TRIGGER: TRIGGER Position */
N#define TPI_TRIGGER_TRIGGER_Msk            (0x1UL /*<< TPI_TRIGGER_TRIGGER_Pos*/)      /*!< TPI TRIGGER: TRIGGER Mask */
N
N/* TPI Integration ETM Data Register Definitions (FIFO0) */
N#define TPI_FIFO0_ITM_ATVALID_Pos          29U                                         /*!< TPI FIFO0: ITM_ATVALID Position */
N#define TPI_FIFO0_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ITM_ATVALID_Pos)        /*!< TPI FIFO0: ITM_ATVALID Mask */
N
N#define TPI_FIFO0_ITM_bytecount_Pos        27U                                         /*!< TPI FIFO0: ITM_bytecount Position */
N#define TPI_FIFO0_ITM_bytecount_Msk        (0x3UL << TPI_FIFO0_ITM_bytecount_Pos)      /*!< TPI FIFO0: ITM_bytecount Mask */
N
N#define TPI_FIFO0_ETM_ATVALID_Pos          26U                                         /*!< TPI FIFO0: ETM_ATVALID Position */
N#define TPI_FIFO0_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ETM_ATVALID_Pos)        /*!< TPI FIFO0: ETM_ATVALID Mask */
N
N#define TPI_FIFO0_ETM_bytecount_Pos        24U                                         /*!< TPI FIFO0: ETM_bytecount Position */
N#define TPI_FIFO0_ETM_bytecount_Msk        (0x3UL << TPI_FIFO0_ETM_bytecount_Pos)      /*!< TPI FIFO0: ETM_bytecount Mask */
N
N#define TPI_FIFO0_ETM2_Pos                 16U                                         /*!< TPI FIFO0: ETM2 Position */
N#define TPI_FIFO0_ETM2_Msk                 (0xFFUL << TPI_FIFO0_ETM2_Pos)              /*!< TPI FIFO0: ETM2 Mask */
N
N#define TPI_FIFO0_ETM1_Pos                  8U                                         /*!< TPI FIFO0: ETM1 Position */
N#define TPI_FIFO0_ETM1_Msk                 (0xFFUL << TPI_FIFO0_ETM1_Pos)              /*!< TPI FIFO0: ETM1 Mask */
N
N#define TPI_FIFO0_ETM0_Pos                  0U                                         /*!< TPI FIFO0: ETM0 Position */
N#define TPI_FIFO0_ETM0_Msk                 (0xFFUL /*<< TPI_FIFO0_ETM0_Pos*/)          /*!< TPI FIFO0: ETM0 Mask */
N
N/* TPI ITATBCTR2 Register Definitions */
N#define TPI_ITATBCTR2_ATREADY_Pos           0U                                         /*!< TPI ITATBCTR2: ATREADY Position */
N#define TPI_ITATBCTR2_ATREADY_Msk          (0x1UL /*<< TPI_ITATBCTR2_ATREADY_Pos*/)    /*!< TPI ITATBCTR2: ATREADY Mask */
N
N/* TPI Integration ITM Data Register Definitions (FIFO1) */
N#define TPI_FIFO1_ITM_ATVALID_Pos          29U                                         /*!< TPI FIFO1: ITM_ATVALID Position */
N#define TPI_FIFO1_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ITM_ATVALID_Pos)        /*!< TPI FIFO1: ITM_ATVALID Mask */
N
N#define TPI_FIFO1_ITM_bytecount_Pos        27U                                         /*!< TPI FIFO1: ITM_bytecount Position */
N#define TPI_FIFO1_ITM_bytecount_Msk        (0x3UL << TPI_FIFO1_ITM_bytecount_Pos)      /*!< TPI FIFO1: ITM_bytecount Mask */
N
N#define TPI_FIFO1_ETM_ATVALID_Pos          26U                                         /*!< TPI FIFO1: ETM_ATVALID Position */
N#define TPI_FIFO1_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ETM_ATVALID_Pos)        /*!< TPI FIFO1: ETM_ATVALID Mask */
N
N#define TPI_FIFO1_ETM_bytecount_Pos        24U                                         /*!< TPI FIFO1: ETM_bytecount Position */
N#define TPI_FIFO1_ETM_bytecount_Msk        (0x3UL << TPI_FIFO1_ETM_bytecount_Pos)      /*!< TPI FIFO1: ETM_bytecount Mask */
N
N#define TPI_FIFO1_ITM2_Pos                 16U                                         /*!< TPI FIFO1: ITM2 Position */
N#define TPI_FIFO1_ITM2_Msk                 (0xFFUL << TPI_FIFO1_ITM2_Pos)              /*!< TPI FIFO1: ITM2 Mask */
N
N#define TPI_FIFO1_ITM1_Pos                  8U                                         /*!< TPI FIFO1: ITM1 Position */
N#define TPI_FIFO1_ITM1_Msk                 (0xFFUL << TPI_FIFO1_ITM1_Pos)              /*!< TPI FIFO1: ITM1 Mask */
N
N#define TPI_FIFO1_ITM0_Pos                  0U                                         /*!< TPI FIFO1: ITM0 Position */
N#define TPI_FIFO1_ITM0_Msk                 (0xFFUL /*<< TPI_FIFO1_ITM0_Pos*/)          /*!< TPI FIFO1: ITM0 Mask */
N
N/* TPI ITATBCTR0 Register Definitions */
N#define TPI_ITATBCTR0_ATREADY_Pos           0U                                         /*!< TPI ITATBCTR0: ATREADY Position */
N#define TPI_ITATBCTR0_ATREADY_Msk          (0x1UL /*<< TPI_ITATBCTR0_ATREADY_Pos*/)    /*!< TPI ITATBCTR0: ATREADY Mask */
N
N/* TPI Integration Mode Control Register Definitions */
N#define TPI_ITCTRL_Mode_Pos                 0U                                         /*!< TPI ITCTRL: Mode Position */
N#define TPI_ITCTRL_Mode_Msk                (0x1UL /*<< TPI_ITCTRL_Mode_Pos*/)          /*!< TPI ITCTRL: Mode Mask */
N
N/* TPI DEVID Register Definitions */
N#define TPI_DEVID_NRZVALID_Pos             11U                                         /*!< TPI DEVID: NRZVALID Position */
N#define TPI_DEVID_NRZVALID_Msk             (0x1UL << TPI_DEVID_NRZVALID_Pos)           /*!< TPI DEVID: NRZVALID Mask */
N
N#define TPI_DEVID_MANCVALID_Pos            10U                                         /*!< TPI DEVID: MANCVALID Position */
N#define TPI_DEVID_MANCVALID_Msk            (0x1UL << TPI_DEVID_MANCVALID_Pos)          /*!< TPI DEVID: MANCVALID Mask */
N
N#define TPI_DEVID_PTINVALID_Pos             9U                                         /*!< TPI DEVID: PTINVALID Position */
N#define TPI_DEVID_PTINVALID_Msk            (0x1UL << TPI_DEVID_PTINVALID_Pos)          /*!< TPI DEVID: PTINVALID Mask */
N
N#define TPI_DEVID_MinBufSz_Pos              6U                                         /*!< TPI DEVID: MinBufSz Position */
N#define TPI_DEVID_MinBufSz_Msk             (0x7UL << TPI_DEVID_MinBufSz_Pos)           /*!< TPI DEVID: MinBufSz Mask */
N
N#define TPI_DEVID_AsynClkIn_Pos             5U                                         /*!< TPI DEVID: AsynClkIn Position */
N#define TPI_DEVID_AsynClkIn_Msk            (0x1UL << TPI_DEVID_AsynClkIn_Pos)          /*!< TPI DEVID: AsynClkIn Mask */
N
N#define TPI_DEVID_NrTraceInput_Pos          0U                                         /*!< TPI DEVID: NrTraceInput Position */
N#define TPI_DEVID_NrTraceInput_Msk         (0x1FUL /*<< TPI_DEVID_NrTraceInput_Pos*/)  /*!< TPI DEVID: NrTraceInput Mask */
N
N/* TPI DEVTYPE Register Definitions */
N#define TPI_DEVTYPE_MajorType_Pos           4U                                         /*!< TPI DEVTYPE: MajorType Position */
N#define TPI_DEVTYPE_MajorType_Msk          (0xFUL << TPI_DEVTYPE_MajorType_Pos)        /*!< TPI DEVTYPE: MajorType Mask */
N
N#define TPI_DEVTYPE_SubType_Pos             0U                                         /*!< TPI DEVTYPE: SubType Position */
N#define TPI_DEVTYPE_SubType_Msk            (0xFUL /*<< TPI_DEVTYPE_SubType_Pos*/)      /*!< TPI DEVTYPE: SubType Mask */
N
N/*@}*/ /* end of group CMSIS_TPI */
N
N
N#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
X#if 1L && (1 == 1U)
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
N  \brief    Type definitions for the Memory Protection Unit (MPU)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Memory Protection Unit (MPU).
N */
Ntypedef struct
N{
N  __IM  uint32_t TYPE;                   /*!< Offset: 0x000 (R/ )  MPU Type Register */
X  volatile const  uint32_t TYPE;                    
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x004 (R/W)  MPU Control Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t RNR;                    /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register */
X  volatile uint32_t RNR;                     
N  __IOM uint32_t RBAR;                   /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register */
X  volatile uint32_t RBAR;                    
N  __IOM uint32_t RASR;                   /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Register */
X  volatile uint32_t RASR;                    
N  __IOM uint32_t RBAR_A1;                /*!< Offset: 0x014 (R/W)  MPU Alias 1 Region Base Address Register */
X  volatile uint32_t RBAR_A1;                 
N  __IOM uint32_t RASR_A1;                /*!< Offset: 0x018 (R/W)  MPU Alias 1 Region Attribute and Size Register */
X  volatile uint32_t RASR_A1;                 
N  __IOM uint32_t RBAR_A2;                /*!< Offset: 0x01C (R/W)  MPU Alias 2 Region Base Address Register */
X  volatile uint32_t RBAR_A2;                 
N  __IOM uint32_t RASR_A2;                /*!< Offset: 0x020 (R/W)  MPU Alias 2 Region Attribute and Size Register */
X  volatile uint32_t RASR_A2;                 
N  __IOM uint32_t RBAR_A3;                /*!< Offset: 0x024 (R/W)  MPU Alias 3 Region Base Address Register */
X  volatile uint32_t RBAR_A3;                 
N  __IOM uint32_t RASR_A3;                /*!< Offset: 0x028 (R/W)  MPU Alias 3 Region Attribute and Size Register */
X  volatile uint32_t RASR_A3;                 
N} MPU_Type;
N
N/* MPU Type Register Definitions */
N#define MPU_TYPE_IREGION_Pos               16U                                            /*!< MPU TYPE: IREGION Position */
N#define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
N
N#define MPU_TYPE_DREGION_Pos                8U                                            /*!< MPU TYPE: DREGION Position */
N#define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
N
N#define MPU_TYPE_SEPARATE_Pos               0U                                            /*!< MPU TYPE: SEPARATE Position */
N#define MPU_TYPE_SEPARATE_Msk              (1UL /*<< MPU_TYPE_SEPARATE_Pos*/)             /*!< MPU TYPE: SEPARATE Mask */
N
N/* MPU Control Register Definitions */
N#define MPU_CTRL_PRIVDEFENA_Pos             2U                                            /*!< MPU CTRL: PRIVDEFENA Position */
N#define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
N
N#define MPU_CTRL_HFNMIENA_Pos               1U                                            /*!< MPU CTRL: HFNMIENA Position */
N#define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
N
N#define MPU_CTRL_ENABLE_Pos                 0U                                            /*!< MPU CTRL: ENABLE Position */
N#define MPU_CTRL_ENABLE_Msk                (1UL /*<< MPU_CTRL_ENABLE_Pos*/)               /*!< MPU CTRL: ENABLE Mask */
N
N/* MPU Region Number Register Definitions */
N#define MPU_RNR_REGION_Pos                  0U                                            /*!< MPU RNR: REGION Position */
N#define MPU_RNR_REGION_Msk                 (0xFFUL /*<< MPU_RNR_REGION_Pos*/)             /*!< MPU RNR: REGION Mask */
N
N/* MPU Region Base Address Register Definitions */
N#define MPU_RBAR_ADDR_Pos                   5U                                            /*!< MPU RBAR: ADDR Position */
N#define MPU_RBAR_ADDR_Msk                  (0x7FFFFFFUL << MPU_RBAR_ADDR_Pos)             /*!< MPU RBAR: ADDR Mask */
N
N#define MPU_RBAR_VALID_Pos                  4U                                            /*!< MPU RBAR: VALID Position */
N#define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
N
N#define MPU_RBAR_REGION_Pos                 0U                                            /*!< MPU RBAR: REGION Position */
N#define MPU_RBAR_REGION_Msk                (0xFUL /*<< MPU_RBAR_REGION_Pos*/)             /*!< MPU RBAR: REGION Mask */
N
N/* MPU Region Attribute and Size Register Definitions */
N#define MPU_RASR_ATTRS_Pos                 16U                                            /*!< MPU RASR: MPU Region Attribute field Position */
N#define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU RASR: MPU Region Attribute field Mask */
N
N#define MPU_RASR_XN_Pos                    28U                                            /*!< MPU RASR: ATTRS.XN Position */
N#define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU RASR: ATTRS.XN Mask */
N
N#define MPU_RASR_AP_Pos                    24U                                            /*!< MPU RASR: ATTRS.AP Position */
N#define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU RASR: ATTRS.AP Mask */
N
N#define MPU_RASR_TEX_Pos                   19U                                            /*!< MPU RASR: ATTRS.TEX Position */
N#define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU RASR: ATTRS.TEX Mask */
N
N#define MPU_RASR_S_Pos                     18U                                            /*!< MPU RASR: ATTRS.S Position */
N#define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU RASR: ATTRS.S Mask */
N
N#define MPU_RASR_C_Pos                     17U                                            /*!< MPU RASR: ATTRS.C Position */
N#define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU RASR: ATTRS.C Mask */
N
N#define MPU_RASR_B_Pos                     16U                                            /*!< MPU RASR: ATTRS.B Position */
N#define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU RASR: ATTRS.B Mask */
N
N#define MPU_RASR_SRD_Pos                    8U                                            /*!< MPU RASR: Sub-Region Disable Position */
N#define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
N
N#define MPU_RASR_SIZE_Pos                   1U                                            /*!< MPU RASR: Region Size Field Position */
N#define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
N
N#define MPU_RASR_ENABLE_Pos                 0U                                            /*!< MPU RASR: Region enable bit Position */
N#define MPU_RASR_ENABLE_Msk                (1UL /*<< MPU_RASR_ENABLE_Pos*/)               /*!< MPU RASR: Region enable bit Disable Mask */
N
N/*@} end of group CMSIS_MPU */
N#endif /* defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U) */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_FPU     Floating Point Unit (FPU)
N  \brief    Type definitions for the Floating Point Unit (FPU)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Floating Point Unit (FPU).
N */
Ntypedef struct
N{
N        uint32_t RESERVED0[1U];
N  __IOM uint32_t FPCCR;                  /*!< Offset: 0x004 (R/W)  Floating-Point Context Control Register */
X  volatile uint32_t FPCCR;                   
N  __IOM uint32_t FPCAR;                  /*!< Offset: 0x008 (R/W)  Floating-Point Context Address Register */
X  volatile uint32_t FPCAR;                   
N  __IOM uint32_t FPDSCR;                 /*!< Offset: 0x00C (R/W)  Floating-Point Default Status Control Register */
X  volatile uint32_t FPDSCR;                  
N  __IM  uint32_t MVFR0;                  /*!< Offset: 0x010 (R/ )  Media and FP Feature Register 0 */
X  volatile const  uint32_t MVFR0;                   
N  __IM  uint32_t MVFR1;                  /*!< Offset: 0x014 (R/ )  Media and FP Feature Register 1 */
X  volatile const  uint32_t MVFR1;                   
N} FPU_Type;
N
N/* Floating-Point Context Control Register Definitions */
N#define FPU_FPCCR_ASPEN_Pos                31U                                            /*!< FPCCR: ASPEN bit Position */
N#define FPU_FPCCR_ASPEN_Msk                (1UL << FPU_FPCCR_ASPEN_Pos)                   /*!< FPCCR: ASPEN bit Mask */
N
N#define FPU_FPCCR_LSPEN_Pos                30U                                            /*!< FPCCR: LSPEN Position */
N#define FPU_FPCCR_LSPEN_Msk                (1UL << FPU_FPCCR_LSPEN_Pos)                   /*!< FPCCR: LSPEN bit Mask */
N
N#define FPU_FPCCR_MONRDY_Pos                8U                                            /*!< FPCCR: MONRDY Position */
N#define FPU_FPCCR_MONRDY_Msk               (1UL << FPU_FPCCR_MONRDY_Pos)                  /*!< FPCCR: MONRDY bit Mask */
N
N#define FPU_FPCCR_BFRDY_Pos                 6U                                            /*!< FPCCR: BFRDY Position */
N#define FPU_FPCCR_BFRDY_Msk                (1UL << FPU_FPCCR_BFRDY_Pos)                   /*!< FPCCR: BFRDY bit Mask */
N
N#define FPU_FPCCR_MMRDY_Pos                 5U                                            /*!< FPCCR: MMRDY Position */
N#define FPU_FPCCR_MMRDY_Msk                (1UL << FPU_FPCCR_MMRDY_Pos)                   /*!< FPCCR: MMRDY bit Mask */
N
N#define FPU_FPCCR_HFRDY_Pos                 4U                                            /*!< FPCCR: HFRDY Position */
N#define FPU_FPCCR_HFRDY_Msk                (1UL << FPU_FPCCR_HFRDY_Pos)                   /*!< FPCCR: HFRDY bit Mask */
N
N#define FPU_FPCCR_THREAD_Pos                3U                                            /*!< FPCCR: processor mode bit Position */
N#define FPU_FPCCR_THREAD_Msk               (1UL << FPU_FPCCR_THREAD_Pos)                  /*!< FPCCR: processor mode active bit Mask */
N
N#define FPU_FPCCR_USER_Pos                  1U                                            /*!< FPCCR: privilege level bit Position */
N#define FPU_FPCCR_USER_Msk                 (1UL << FPU_FPCCR_USER_Pos)                    /*!< FPCCR: privilege level bit Mask */
N
N#define FPU_FPCCR_LSPACT_Pos                0U                                            /*!< FPCCR: Lazy state preservation active bit Position */
N#define FPU_FPCCR_LSPACT_Msk               (1UL /*<< FPU_FPCCR_LSPACT_Pos*/)              /*!< FPCCR: Lazy state preservation active bit Mask */
N
N/* Floating-Point Context Address Register Definitions */
N#define FPU_FPCAR_ADDRESS_Pos               3U                                            /*!< FPCAR: ADDRESS bit Position */
N#define FPU_FPCAR_ADDRESS_Msk              (0x1FFFFFFFUL << FPU_FPCAR_ADDRESS_Pos)        /*!< FPCAR: ADDRESS bit Mask */
N
N/* Floating-Point Default Status Control Register Definitions */
N#define FPU_FPDSCR_AHP_Pos                 26U                                            /*!< FPDSCR: AHP bit Position */
N#define FPU_FPDSCR_AHP_Msk                 (1UL << FPU_FPDSCR_AHP_Pos)                    /*!< FPDSCR: AHP bit Mask */
N
N#define FPU_FPDSCR_DN_Pos                  25U                                            /*!< FPDSCR: DN bit Position */
N#define FPU_FPDSCR_DN_Msk                  (1UL << FPU_FPDSCR_DN_Pos)                     /*!< FPDSCR: DN bit Mask */
N
N#define FPU_FPDSCR_FZ_Pos                  24U                                            /*!< FPDSCR: FZ bit Position */
N#define FPU_FPDSCR_FZ_Msk                  (1UL << FPU_FPDSCR_FZ_Pos)                     /*!< FPDSCR: FZ bit Mask */
N
N#define FPU_FPDSCR_RMode_Pos               22U                                            /*!< FPDSCR: RMode bit Position */
N#define FPU_FPDSCR_RMode_Msk               (3UL << FPU_FPDSCR_RMode_Pos)                  /*!< FPDSCR: RMode bit Mask */
N
N/* Media and FP Feature Register 0 Definitions */
N#define FPU_MVFR0_FP_rounding_modes_Pos    28U                                            /*!< MVFR0: FP rounding modes bits Position */
N#define FPU_MVFR0_FP_rounding_modes_Msk    (0xFUL << FPU_MVFR0_FP_rounding_modes_Pos)     /*!< MVFR0: FP rounding modes bits Mask */
N
N#define FPU_MVFR0_Short_vectors_Pos        24U                                            /*!< MVFR0: Short vectors bits Position */
N#define FPU_MVFR0_Short_vectors_Msk        (0xFUL << FPU_MVFR0_Short_vectors_Pos)         /*!< MVFR0: Short vectors bits Mask */
N
N#define FPU_MVFR0_Square_root_Pos          20U                                            /*!< MVFR0: Square root bits Position */
N#define FPU_MVFR0_Square_root_Msk          (0xFUL << FPU_MVFR0_Square_root_Pos)           /*!< MVFR0: Square root bits Mask */
N
N#define FPU_MVFR0_Divide_Pos               16U                                            /*!< MVFR0: Divide bits Position */
N#define FPU_MVFR0_Divide_Msk               (0xFUL << FPU_MVFR0_Divide_Pos)                /*!< MVFR0: Divide bits Mask */
N
N#define FPU_MVFR0_FP_excep_trapping_Pos    12U                                            /*!< MVFR0: FP exception trapping bits Position */
N#define FPU_MVFR0_FP_excep_trapping_Msk    (0xFUL << FPU_MVFR0_FP_excep_trapping_Pos)     /*!< MVFR0: FP exception trapping bits Mask */
N
N#define FPU_MVFR0_Double_precision_Pos      8U                                            /*!< MVFR0: Double-precision bits Position */
N#define FPU_MVFR0_Double_precision_Msk     (0xFUL << FPU_MVFR0_Double_precision_Pos)      /*!< MVFR0: Double-precision bits Mask */
N
N#define FPU_MVFR0_Single_precision_Pos      4U                                            /*!< MVFR0: Single-precision bits Position */
N#define FPU_MVFR0_Single_precision_Msk     (0xFUL << FPU_MVFR0_Single_precision_Pos)      /*!< MVFR0: Single-precision bits Mask */
N
N#define FPU_MVFR0_A_SIMD_registers_Pos      0U                                            /*!< MVFR0: A_SIMD registers bits Position */
N#define FPU_MVFR0_A_SIMD_registers_Msk     (0xFUL /*<< FPU_MVFR0_A_SIMD_registers_Pos*/)  /*!< MVFR0: A_SIMD registers bits Mask */
N
N/* Media and FP Feature Register 1 Definitions */
N#define FPU_MVFR1_FP_fused_MAC_Pos         28U                                            /*!< MVFR1: FP fused MAC bits Position */
N#define FPU_MVFR1_FP_fused_MAC_Msk         (0xFUL << FPU_MVFR1_FP_fused_MAC_Pos)          /*!< MVFR1: FP fused MAC bits Mask */
N
N#define FPU_MVFR1_FP_HPFP_Pos              24U                                            /*!< MVFR1: FP HPFP bits Position */
N#define FPU_MVFR1_FP_HPFP_Msk              (0xFUL << FPU_MVFR1_FP_HPFP_Pos)               /*!< MVFR1: FP HPFP bits Mask */
N
N#define FPU_MVFR1_D_NaN_mode_Pos            4U                                            /*!< MVFR1: D_NaN mode bits Position */
N#define FPU_MVFR1_D_NaN_mode_Msk           (0xFUL << FPU_MVFR1_D_NaN_mode_Pos)            /*!< MVFR1: D_NaN mode bits Mask */
N
N#define FPU_MVFR1_FtZ_mode_Pos              0U                                            /*!< MVFR1: FtZ mode bits Position */
N#define FPU_MVFR1_FtZ_mode_Msk             (0xFUL /*<< FPU_MVFR1_FtZ_mode_Pos*/)          /*!< MVFR1: FtZ mode bits Mask */
N
N/*@} end of group CMSIS_FPU */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
N  \brief    Type definitions for the Core Debug Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the Core Debug Register (CoreDebug).
N */
Ntypedef struct
N{
N  __IOM uint32_t DHCSR;                  /*!< Offset: 0x000 (R/W)  Debug Halting Control and Status Register */
X  volatile uint32_t DHCSR;                   
N  __OM  uint32_t DCRSR;                  /*!< Offset: 0x004 ( /W)  Debug Core Register Selector Register */
X  volatile  uint32_t DCRSR;                   
N  __IOM uint32_t DCRDR;                  /*!< Offset: 0x008 (R/W)  Debug Core Register Data Register */
X  volatile uint32_t DCRDR;                   
N  __IOM uint32_t DEMCR;                  /*!< Offset: 0x00C (R/W)  Debug Exception and Monitor Control Register */
X  volatile uint32_t DEMCR;                   
N} CoreDebug_Type;
N
N/* Debug Halting Control and Status Register Definitions */
N#define CoreDebug_DHCSR_DBGKEY_Pos         16U                                            /*!< CoreDebug DHCSR: DBGKEY Position */
N#define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< CoreDebug DHCSR: DBGKEY Mask */
N
N#define CoreDebug_DHCSR_S_RESET_ST_Pos     25U                                            /*!< CoreDebug DHCSR: S_RESET_ST Position */
N#define CoreDebug_DHCSR_S_RESET_ST_Msk     (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< CoreDebug DHCSR: S_RESET_ST Mask */
N
N#define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24U                                            /*!< CoreDebug DHCSR: S_RETIRE_ST Position */
N#define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< CoreDebug DHCSR: S_RETIRE_ST Mask */
N
N#define CoreDebug_DHCSR_S_LOCKUP_Pos       19U                                            /*!< CoreDebug DHCSR: S_LOCKUP Position */
N#define CoreDebug_DHCSR_S_LOCKUP_Msk       (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< CoreDebug DHCSR: S_LOCKUP Mask */
N
N#define CoreDebug_DHCSR_S_SLEEP_Pos        18U                                            /*!< CoreDebug DHCSR: S_SLEEP Position */
N#define CoreDebug_DHCSR_S_SLEEP_Msk        (1UL << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< CoreDebug DHCSR: S_SLEEP Mask */
N
N#define CoreDebug_DHCSR_S_HALT_Pos         17U                                            /*!< CoreDebug DHCSR: S_HALT Position */
N#define CoreDebug_DHCSR_S_HALT_Msk         (1UL << CoreDebug_DHCSR_S_HALT_Pos)            /*!< CoreDebug DHCSR: S_HALT Mask */
N
N#define CoreDebug_DHCSR_S_REGRDY_Pos       16U                                            /*!< CoreDebug DHCSR: S_REGRDY Position */
N#define CoreDebug_DHCSR_S_REGRDY_Msk       (1UL << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< CoreDebug DHCSR: S_REGRDY Mask */
N
N#define CoreDebug_DHCSR_C_SNAPSTALL_Pos     5U                                            /*!< CoreDebug DHCSR: C_SNAPSTALL Position */
N#define CoreDebug_DHCSR_C_SNAPSTALL_Msk    (1UL << CoreDebug_DHCSR_C_SNAPSTALL_Pos)       /*!< CoreDebug DHCSR: C_SNAPSTALL Mask */
N
N#define CoreDebug_DHCSR_C_MASKINTS_Pos      3U                                            /*!< CoreDebug DHCSR: C_MASKINTS Position */
N#define CoreDebug_DHCSR_C_MASKINTS_Msk     (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< CoreDebug DHCSR: C_MASKINTS Mask */
N
N#define CoreDebug_DHCSR_C_STEP_Pos          2U                                            /*!< CoreDebug DHCSR: C_STEP Position */
N#define CoreDebug_DHCSR_C_STEP_Msk         (1UL << CoreDebug_DHCSR_C_STEP_Pos)            /*!< CoreDebug DHCSR: C_STEP Mask */
N
N#define CoreDebug_DHCSR_C_HALT_Pos          1U                                            /*!< CoreDebug DHCSR: C_HALT Position */
N#define CoreDebug_DHCSR_C_HALT_Msk         (1UL << CoreDebug_DHCSR_C_HALT_Pos)            /*!< CoreDebug DHCSR: C_HALT Mask */
N
N#define CoreDebug_DHCSR_C_DEBUGEN_Pos       0U                                            /*!< CoreDebug DHCSR: C_DEBUGEN Position */
N#define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1UL /*<< CoreDebug_DHCSR_C_DEBUGEN_Pos*/)     /*!< CoreDebug DHCSR: C_DEBUGEN Mask */
N
N/* Debug Core Register Selector Register Definitions */
N#define CoreDebug_DCRSR_REGWnR_Pos         16U                                            /*!< CoreDebug DCRSR: REGWnR Position */
N#define CoreDebug_DCRSR_REGWnR_Msk         (1UL << CoreDebug_DCRSR_REGWnR_Pos)            /*!< CoreDebug DCRSR: REGWnR Mask */
N
N#define CoreDebug_DCRSR_REGSEL_Pos          0U                                            /*!< CoreDebug DCRSR: REGSEL Position */
N#define CoreDebug_DCRSR_REGSEL_Msk         (0x1FUL /*<< CoreDebug_DCRSR_REGSEL_Pos*/)     /*!< CoreDebug DCRSR: REGSEL Mask */
N
N/* Debug Exception and Monitor Control Register Definitions */
N#define CoreDebug_DEMCR_TRCENA_Pos         24U                                            /*!< CoreDebug DEMCR: TRCENA Position */
N#define CoreDebug_DEMCR_TRCENA_Msk         (1UL << CoreDebug_DEMCR_TRCENA_Pos)            /*!< CoreDebug DEMCR: TRCENA Mask */
N
N#define CoreDebug_DEMCR_MON_REQ_Pos        19U                                            /*!< CoreDebug DEMCR: MON_REQ Position */
N#define CoreDebug_DEMCR_MON_REQ_Msk        (1UL << CoreDebug_DEMCR_MON_REQ_Pos)           /*!< CoreDebug DEMCR: MON_REQ Mask */
N
N#define CoreDebug_DEMCR_MON_STEP_Pos       18U                                            /*!< CoreDebug DEMCR: MON_STEP Position */
N#define CoreDebug_DEMCR_MON_STEP_Msk       (1UL << CoreDebug_DEMCR_MON_STEP_Pos)          /*!< CoreDebug DEMCR: MON_STEP Mask */
N
N#define CoreDebug_DEMCR_MON_PEND_Pos       17U                                            /*!< CoreDebug DEMCR: MON_PEND Position */
N#define CoreDebug_DEMCR_MON_PEND_Msk       (1UL << CoreDebug_DEMCR_MON_PEND_Pos)          /*!< CoreDebug DEMCR: MON_PEND Mask */
N
N#define CoreDebug_DEMCR_MON_EN_Pos         16U                                            /*!< CoreDebug DEMCR: MON_EN Position */
N#define CoreDebug_DEMCR_MON_EN_Msk         (1UL << CoreDebug_DEMCR_MON_EN_Pos)            /*!< CoreDebug DEMCR: MON_EN Mask */
N
N#define CoreDebug_DEMCR_VC_HARDERR_Pos     10U                                            /*!< CoreDebug DEMCR: VC_HARDERR Position */
N#define CoreDebug_DEMCR_VC_HARDERR_Msk     (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< CoreDebug DEMCR: VC_HARDERR Mask */
N
N#define CoreDebug_DEMCR_VC_INTERR_Pos       9U                                            /*!< CoreDebug DEMCR: VC_INTERR Position */
N#define CoreDebug_DEMCR_VC_INTERR_Msk      (1UL << CoreDebug_DEMCR_VC_INTERR_Pos)         /*!< CoreDebug DEMCR: VC_INTERR Mask */
N
N#define CoreDebug_DEMCR_VC_BUSERR_Pos       8U                                            /*!< CoreDebug DEMCR: VC_BUSERR Position */
N#define CoreDebug_DEMCR_VC_BUSERR_Msk      (1UL << CoreDebug_DEMCR_VC_BUSERR_Pos)         /*!< CoreDebug DEMCR: VC_BUSERR Mask */
N
N#define CoreDebug_DEMCR_VC_STATERR_Pos      7U                                            /*!< CoreDebug DEMCR: VC_STATERR Position */
N#define CoreDebug_DEMCR_VC_STATERR_Msk     (1UL << CoreDebug_DEMCR_VC_STATERR_Pos)        /*!< CoreDebug DEMCR: VC_STATERR Mask */
N
N#define CoreDebug_DEMCR_VC_CHKERR_Pos       6U                                            /*!< CoreDebug DEMCR: VC_CHKERR Position */
N#define CoreDebug_DEMCR_VC_CHKERR_Msk      (1UL << CoreDebug_DEMCR_VC_CHKERR_Pos)         /*!< CoreDebug DEMCR: VC_CHKERR Mask */
N
N#define CoreDebug_DEMCR_VC_NOCPERR_Pos      5U                                            /*!< CoreDebug DEMCR: VC_NOCPERR Position */
N#define CoreDebug_DEMCR_VC_NOCPERR_Msk     (1UL << CoreDebug_DEMCR_VC_NOCPERR_Pos)        /*!< CoreDebug DEMCR: VC_NOCPERR Mask */
N
N#define CoreDebug_DEMCR_VC_MMERR_Pos        4U                                            /*!< CoreDebug DEMCR: VC_MMERR Position */
N#define CoreDebug_DEMCR_VC_MMERR_Msk       (1UL << CoreDebug_DEMCR_VC_MMERR_Pos)          /*!< CoreDebug DEMCR: VC_MMERR Mask */
N
N#define CoreDebug_DEMCR_VC_CORERESET_Pos    0U                                            /*!< CoreDebug DEMCR: VC_CORERESET Position */
N#define CoreDebug_DEMCR_VC_CORERESET_Msk   (1UL /*<< CoreDebug_DEMCR_VC_CORERESET_Pos*/)  /*!< CoreDebug DEMCR: VC_CORERESET Mask */
N
N/*@} end of group CMSIS_CoreDebug */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_bitfield     Core register bit field macros
N  \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
N  @{
N */
N
N/**
N  \brief   Mask and shift a bit field value for use in a register bit range.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of the bit field. This parameter is interpreted as an uint32_t type.
N  \return           Masked and shifted value.
N*/
N#define _VAL2FLD(field, value)    (((uint32_t)(value) << field ## _Pos) & field ## _Msk)
N
N/**
N  \brief     Mask and shift a register value to extract a bit filed value.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of register. This parameter is interpreted as an uint32_t type.
N  \return           Masked and shifted bit field value.
N*/
N#define _FLD2VAL(field, value)    (((uint32_t)(value) & field ## _Msk) >> field ## _Pos)
N
N/*@} end of group CMSIS_core_bitfield */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_base     Core Definitions
N  \brief      Definitions for base addresses, unions, and structures.
N  @{
N */
N
N/* Memory mapping of Core Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
N#define ITM_BASE            (0xE0000000UL)                            /*!< ITM Base Address */
N#define DWT_BASE            (0xE0001000UL)                            /*!< DWT Base Address */
N#define TPI_BASE            (0xE0040000UL)                            /*!< TPI Base Address */
N#define CoreDebug_BASE      (0xE000EDF0UL)                            /*!< Core Debug Base Address */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
N
N#define SCnSCB              ((SCnSCB_Type    *)     SCS_BASE      )   /*!< System control Register not in SCB */
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct */
N#define ITM                 ((ITM_Type       *)     ITM_BASE      )   /*!< ITM configuration struct */
N#define DWT                 ((DWT_Type       *)     DWT_BASE      )   /*!< DWT configuration struct */
N#define TPI                 ((TPI_Type       *)     TPI_BASE      )   /*!< TPI configuration struct */
N#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct */
N
N#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
X#if 1L && (1 == 1U)
N  #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit */
N  #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit */
N#endif
N
N#define FPU_BASE            (SCS_BASE +  0x0F30UL)                    /*!< Floating Point Unit */
N#define FPU                 ((FPU_Type       *)     FPU_BASE      )   /*!< Floating Point Unit */
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Debug Functions
N  - Core Register Access Functions
N ******************************************************************************/
N/**
N  \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_NVICFunctions NVIC Functions
N  \brief    Functions that manage interrupts and exceptions via the NVIC.
N  @{
N */
N
N#ifdef CMSIS_NVIC_VIRTUAL
S  #ifndef CMSIS_NVIC_VIRTUAL_HEADER_FILE
S    #define CMSIS_NVIC_VIRTUAL_HEADER_FILE "cmsis_nvic_virtual.h"
S  #endif
S  #include CMSIS_NVIC_VIRTUAL_HEADER_FILE
N#else
N  #define NVIC_SetPriorityGrouping    __NVIC_SetPriorityGrouping
N  #define NVIC_GetPriorityGrouping    __NVIC_GetPriorityGrouping
N  #define NVIC_EnableIRQ              __NVIC_EnableIRQ
N  #define NVIC_GetEnableIRQ           __NVIC_GetEnableIRQ
N  #define NVIC_DisableIRQ             __NVIC_DisableIRQ
N  #define NVIC_GetPendingIRQ          __NVIC_GetPendingIRQ
N  #define NVIC_SetPendingIRQ          __NVIC_SetPendingIRQ
N  #define NVIC_ClearPendingIRQ        __NVIC_ClearPendingIRQ
N  #define NVIC_GetActive              __NVIC_GetActive
N  #define NVIC_SetPriority            __NVIC_SetPriority
N  #define NVIC_GetPriority            __NVIC_GetPriority
N  #define NVIC_SystemReset            __NVIC_SystemReset
N#endif /* CMSIS_NVIC_VIRTUAL */
N
N#ifdef CMSIS_VECTAB_VIRTUAL
S  #ifndef CMSIS_VECTAB_VIRTUAL_HEADER_FILE
S   #define CMSIS_VECTAB_VIRTUAL_HEADER_FILE "cmsis_vectab_virtual.h"
S  #endif
S  #include CMSIS_VECTAB_VIRTUAL_HEADER_FILE
N#else
N  #define NVIC_SetVector              __NVIC_SetVector
N  #define NVIC_GetVector              __NVIC_GetVector
N#endif  /* (CMSIS_VECTAB_VIRTUAL) */
N
N#define NVIC_USER_IRQ_OFFSET          16
N
N
N
N/**
N  \brief   Set Priority Grouping
N  \details Sets the priority grouping field using the required unlock sequence.
N           The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.
N           Only values from 0..7 are used.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
N  \param [in]      PriorityGroup  Priority grouping field.
N */
N__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
Xstatic inline void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
N{
N  uint32_t reg_value;
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
N
N  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
X  reg_value  =  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR;                                                    
N  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
X  reg_value &= ~((uint32_t)((0xFFFFUL << 16U) | (7UL << 8U)));  
N  reg_value  =  (reg_value                                   |
N                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
X                ((uint32_t)0x5FAUL << 16U) |
N                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
N  SCB->AIRCR =  reg_value;
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR =  reg_value;
N}
N
N
N/**
N  \brief   Get Priority Grouping
N  \details Reads the priority grouping field from the NVIC Interrupt Controller.
N  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
N */
N__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
Xstatic inline uint32_t __NVIC_GetPriorityGrouping(void)
N{
N  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
X  return ((uint32_t)((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8U)) >> 8U));
N}
N
N
N/**
N  \brief   Enable Interrupt
N  \details Enables a device specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic inline void __NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N  }
N}
N
N
N/**
N  \brief   Get Interrupt Enable status
N  \details Returns a device specific interrupt enable status from the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \return             0  Interrupt is not enabled.
N  \return             1  Interrupt is enabled.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)
Xstatic inline uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N  }
N  else
N  {
N    return(0U);
N  }
N}
N
N
N/**
N  \brief   Disable Interrupt
N  \details Disables a device specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic inline void __NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N    __DSB();
X    _dsb();
N    __ISB();
X    _isb();
N  }
N}
N
N
N/**
N  \brief   Get Pending Interrupt
N  \details Reads the NVIC pending register and returns the pending bit for the specified device specific interrupt.
N  \param [in]      IRQn  Device specific interrupt number.
N  \return             0  Interrupt status is not pending.
N  \return             1  Interrupt status is pending.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic inline uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N  }
N  else
N  {
N    return(0U);
N  }
N}
N
N
N/**
N  \brief   Set Pending Interrupt
N  \details Sets the pending bit of a device specific interrupt in the NVIC pending register.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic inline void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N  }
N}
N
N
N/**
N  \brief   Clear Pending Interrupt
N  \details Clears the pending bit of a device specific interrupt in the NVIC pending register.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic inline void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N  }
N}
N
N
N/**
N  \brief   Get Active Interrupt
N  \details Reads the active register in the NVIC and returns the active bit for the device specific interrupt.
N  \param [in]      IRQn  Device specific interrupt number.
N  \return             0  Interrupt status is not active.
N  \return             1  Interrupt status is active.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE uint32_t __NVIC_GetActive(IRQn_Type IRQn)
Xstatic inline uint32_t __NVIC_GetActive(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->IABR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IABR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N  }
N  else
N  {
N    return(0U);
N  }
N}
N
N
N/**
N  \brief   Set Interrupt Priority
N  \details Sets the priority of a device specific interrupt or a processor exception.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N  \param [in]      IRQn  Interrupt number.
N  \param [in]  priority  Priority to set.
N  \note    The priority cannot be set for every processor exception.
N */
N__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic inline void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - 3)) & (uint32_t)0xFFUL);
N  }
N  else
N  {
N    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - 3)) & (uint32_t)0xFFUL);
N  }
N}
N
N
N/**
N  \brief   Get Interrupt Priority
N  \details Reads the priority of a device specific interrupt or a processor exception.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N  \param [in]   IRQn  Interrupt number.
N  \return             Interrupt Priority.
N                      Value is aligned automatically to the implemented priority bits of the microcontroller.
N */
N__STATIC_INLINE uint32_t __NVIC_GetPriority(IRQn_Type IRQn)
Xstatic inline uint32_t __NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return(((uint32_t)NVIC->IP[((uint32_t)(int32_t)IRQn)]               >> (8U - __NVIC_PRIO_BITS)));
X    return(((uint32_t)((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[((uint32_t)(int32_t)IRQn)]               >> (8U - 3)));
N  }
N  else
N  {
N    return(((uint32_t)SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] >> (8U - __NVIC_PRIO_BITS)));
X    return(((uint32_t)((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] >> (8U - 3)));
N  }
N}
N
N
N/**
N  \brief   Encode Priority
N  \details Encodes the priority for an interrupt with the given priority group,
N           preemptive priority value, and subpriority value.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
N  \param [in]     PriorityGroup  Used priority group.
N  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
N  \param [in]       SubPriority  Subpriority value (starting from 0).
N  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
N */
N__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
Xstatic inline uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
X  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(3)) ? (uint32_t)(3) : (uint32_t)(7UL - PriorityGroupTmp);
N  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
X  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(3)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(3));
N
N  return (
N           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
N           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
N         );
N}
N
N
N/**
N  \brief   Decode Priority
N  \details Decodes an interrupt priority value with a given priority group to
N           preemptive priority value and subpriority value.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.
N  \param [in]         Priority   Priority value, which can be retrieved with the function \ref NVIC_GetPriority().
N  \param [in]     PriorityGroup  Used priority group.
N  \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
N  \param [out]     pSubPriority  Subpriority value (starting from 0).
N */
N__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
Xstatic inline void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
X  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(3)) ? (uint32_t)(3) : (uint32_t)(7UL - PriorityGroupTmp);
N  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
X  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(3)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(3));
N
N  *pPreemptPriority = (Priority >> SubPriorityBits) & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL);
N  *pSubPriority     = (Priority                   ) & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL);
N}
N
N
N/**
N  \brief   Set Interrupt Vector
N  \details Sets an interrupt vector in SRAM based interrupt vector table.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N           VTOR must been relocated to SRAM before.
N  \param [in]   IRQn      Interrupt number
N  \param [in]   vector    Address of interrupt handler function
N */
N__STATIC_INLINE void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)
Xstatic inline void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)
N{
N  uint32_t *vectors = (uint32_t *)SCB->VTOR;
X  uint32_t *vectors = (uint32_t *)((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->VTOR;
N  vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET] = vector;
X  vectors[(int32_t)IRQn + 16] = vector;
N}
N
N
N/**
N  \brief   Get Interrupt Vector
N  \details Reads an interrupt vector from interrupt vector table.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N  \param [in]   IRQn      Interrupt number.
N  \return                 Address of interrupt handler function
N */
N__STATIC_INLINE uint32_t __NVIC_GetVector(IRQn_Type IRQn)
Xstatic inline uint32_t __NVIC_GetVector(IRQn_Type IRQn)
N{
N  uint32_t *vectors = (uint32_t *)SCB->VTOR;
X  uint32_t *vectors = (uint32_t *)((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->VTOR;
N  return vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET];
X  return vectors[(int32_t)IRQn + 16];
N}
N
N
N/**
N  \brief   System Reset
N  \details Initiates a system reset request to reset the MCU.
N */
N__STATIC_INLINE void __NVIC_SystemReset(void)
Xstatic inline void __NVIC_SystemReset(void)
N{
N  __DSB();                                                          /* Ensure all outstanding memory accesses included
X  _dsb();                                                          
N                                                                       buffered write are completed before reset */
N  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = (uint32_t)((0x5FAUL << 16U)    |
N                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
X                           (((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8U)) |
N                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
X                            (1UL << 2U)    );          
N  __DSB();                                                          /* Ensure completion of memory access */
X  _dsb();                                                           
N
N  for(;;)                                                           /* wait until reset */
N  {
N    __NOP();
X    __nop();
N  }
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N
N/* ##########################  FPU functions  #################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_FpuFunctions FPU Functions
N  \brief    Function that provides FPU type.
N  @{
N */
N
N/**
N  \brief   get FPU type
N  \details returns the FPU type
N  \returns
N   - \b  0: No FPU
N   - \b  1: Single precision FPU
N   - \b  2: Double + Single precision FPU
N */
N__STATIC_INLINE uint32_t SCB_GetFPUType(void)
Xstatic inline uint32_t SCB_GetFPUType(void)
N{
N  uint32_t mvfr0;
N
N  mvfr0 = FPU->MVFR0;
X  mvfr0 = ((FPU_Type *) ((0xE000E000UL) + 0x0F30UL) )->MVFR0;
N  if      ((mvfr0 & (FPU_MVFR0_Single_precision_Msk | FPU_MVFR0_Double_precision_Msk)) == 0x020U)
X  if      ((mvfr0 & ((0xFUL << 4U) | (0xFUL << 8U))) == 0x020U)
N  {
N    return 1U;           /* Single precision FPU */
N  }
N  else
N  {
N    return 0U;           /* No FPU */
N  }
N}
N
N
N/*@} end of CMSIS_Core_FpuFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
N  \brief    Functions that configure the System.
N  @{
N */
N
N#if defined (__Vendor_SysTickConfig) && (__Vendor_SysTickConfig == 0U)
X#if 1L && (0 == 0U)
N
N/**
N  \brief   System Tick Configuration
N  \details Initializes the System Timer and its interrupt, and starts the System Tick Timer.
N           Counter is in free running mode to generate periodic interrupts.
N  \param [in]  ticks  Number of ticks between two interrupts.
N  \return          0  Function succeeded.
N  \return          1  Function failed.
N  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
N           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
N           must contain a vendor-specific implementation of this function.
N */
N__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
X  if ((ticks - 1UL) > (0xFFFFFFUL ))
N  {
N    return (1UL);                                                   /* Reload value impossible */
N  }
N
N  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = (uint32_t)(ticks - 1UL);                          
N  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
X  __NVIC_SetPriority (SysTick_IRQn, (1UL << 3) - 1UL);  
N  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0UL;                                              
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2U) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1UL << 1U)   |
N                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL );                          
N  return (0UL);                                                     /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N/* ##################################### Debug In/Output function ########################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_core_DebugFunctions ITM Functions
N  \brief    Functions that access the ITM debug interface.
N  @{
N */
N
Nextern volatile int32_t ITM_RxBuffer;                              /*!< External variable to receive characters. */
N#define                 ITM_RXBUFFER_EMPTY  ((int32_t)0x5AA55AA5U) /*!< Value identifying \ref ITM_RxBuffer is ready for next character. */
N
N
N/**
N  \brief   ITM Send Character
N  \details Transmits a character via the ITM channel 0, and
N           \li Just returns when no debugger is connected that has booked the output.
N           \li Is blocking when a debugger is connected, but the previous character sent has not been transmitted.
N  \param [in]     ch  Character to transmit.
N  \returns            Character to transmit.
N */
N__STATIC_INLINE uint32_t ITM_SendChar (uint32_t ch)
Xstatic inline uint32_t ITM_SendChar (uint32_t ch)
N{
N  if (((ITM->TCR & ITM_TCR_ITMENA_Msk) != 0UL) &&      /* ITM enabled */
X  if (((((ITM_Type *) (0xE0000000UL) )->TCR & (1UL )) != 0UL) &&       
N      ((ITM->TER & 1UL               ) != 0UL)   )     /* ITM Port #0 enabled */
X      ((((ITM_Type *) (0xE0000000UL) )->TER & 1UL               ) != 0UL)   )      
N  {
N    while (ITM->PORT[0U].u32 == 0UL)
X    while (((ITM_Type *) (0xE0000000UL) )->PORT[0U].u32 == 0UL)
N    {
N      __NOP();
X      __nop();
N    }
N    ITM->PORT[0U].u8 = (uint8_t)ch;
X    ((ITM_Type *) (0xE0000000UL) )->PORT[0U].u8 = (uint8_t)ch;
N  }
N  return (ch);
N}
N
N
N/**
N  \brief   ITM Receive Character
N  \details Inputs a character via the external variable \ref ITM_RxBuffer.
N  \return             Received character.
N  \return         -1  No character pending.
N */
N__STATIC_INLINE int32_t ITM_ReceiveChar (void)
Xstatic inline int32_t ITM_ReceiveChar (void)
N{
N  int32_t ch = -1;                           /* no character available */
N
N  if (ITM_RxBuffer != ITM_RXBUFFER_EMPTY)
X  if (ITM_RxBuffer != ((int32_t)0x5AA55AA5U))
N  {
N    ch = ITM_RxBuffer;
N    ITM_RxBuffer = ITM_RXBUFFER_EMPTY;       /* ready for next character */
X    ITM_RxBuffer = ((int32_t)0x5AA55AA5U);        
N  }
N
N  return (ch);
N}
N
N
N/**
N  \brief   ITM Check Character
N  \details Checks whether a character is pending for reading in the variable \ref ITM_RxBuffer.
N  \return          0  No character available.
N  \return          1  Character available.
N */
N__STATIC_INLINE int32_t ITM_CheckChar (void)
Xstatic inline int32_t ITM_CheckChar (void)
N{
N
N  if (ITM_RxBuffer == ITM_RXBUFFER_EMPTY)
X  if (ITM_RxBuffer == ((int32_t)0x5AA55AA5U))
N  {
N    return (0);                              /* no character available */
N  }
N  else
N  {
N    return (1);                              /*    character available */
N  }
N}
N
N/*@} end of CMSIS_core_DebugFunctions */
N
N
N
N
N#ifdef __cplusplus
N}
N#endif
N
N#endif /* __CORE_CM4_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
L 233 "C:\ti\ccs930\ccs\ccs_base\arm\include\msp432p401r.h" 2
N#pragma diag_pop
N#else
S#include "core_cm4.h"
N#endif
N
N/* System Header */
N#include "system_msp432p401r.h"
L 1 "C:\ti\ccs930\ccs\ccs_base\arm\include\system_msp432p401r.h" 1
N/**************************************************************************//**
N* @file     system_msp432p401r.h
N* @brief    CMSIS Cortex-M4F Device Peripheral Access Layer Header File for
N*           MSP432P401R
N* @version  3.230
N* @date     12/06/17
N*
N* @note     View configuration instructions embedded in comments
N*
N******************************************************************************/
N//*****************************************************************************
N//
N// Copyright (C) 2015 Texas Instruments Incorporated - http://www.ti.com/
N//
N// Redistribution and use in source and binary forms, with or without
N// modification, are permitted provided that the following conditions
N// are met:
N//
N//  Redistributions of source code must retain the above copyright
N//  notice, this list of conditions and the following disclaimer.
N//
N//  Redistributions in binary form must reproduce the above copyright
N//  notice, this list of conditions and the following disclaimer in the
N//  documentation and/or other materials provided with the
N//  distribution.
N//
N//  Neither the name of Texas Instruments Incorporated nor the names of
N//  its contributors may be used to endorse or promote products derived
N//  from this software without specific prior written permission.
N//
N// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
N// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
N// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
N// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
N// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
N// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
N// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
N// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
N// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
N// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N//
N//*****************************************************************************
N
N#ifndef SYSTEM_MSP432P401R_H
N#define SYSTEM_MSP432P401R_H
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
N#include <stdint.h>
N
Nextern uint32_t SystemCoreClock;     /*!< System Clock Frequency (Core Clock)  */
N
N
N/**
N * Initialize the system
N *
N * @param  none
N * @return none
N *
N * @brief  Setup the microcontroller system.
N *
N * Performs the following initialization steps:
N *     1. Enables the FPU
N *     2. Halts the WDT
N *     3. Enables all SRAM banks
N *     4. Sets up power __REGULATOR and VCORE
N *     5. Enable Flash wait states if needed
N *     6. Change MCLK to desired frequency
N *     7. Enable Flash read buffering
N */
Nextern void SystemInit (void);
N
N/**
N * Update SystemCoreClock variable
N *
N * @param  none
N * @return none
N *
N * @brief  Updates the SystemCoreClock with current core Clock
N *         retrieved from cpu registers.
N */
Nextern void SystemCoreClockUpdate (void);
N
N#ifdef __cplusplus
N}
N#endif
N
N#endif /* SYSTEM_MSP432P401R_H */
N
L 240 "C:\ti\ccs930\ccs\ccs_base\arm\include\msp432p401r.h" 2
N
N/******************************************************************************
N* Definition of standard bits                                                 *
N******************************************************************************/
N#define BIT0                                     (uint16_t)(0x0001)
N#define BIT1                                     (uint16_t)(0x0002)
N#define BIT2                                     (uint16_t)(0x0004)
N#define BIT3                                     (uint16_t)(0x0008)
N#define BIT4                                     (uint16_t)(0x0010)
N#define BIT5                                     (uint16_t)(0x0020)
N#define BIT6                                     (uint16_t)(0x0040)
N#define BIT7                                     (uint16_t)(0x0080)
N#define BIT8                                     (uint16_t)(0x0100)
N#define BIT9                                     (uint16_t)(0x0200)
N#define BITA                                     (uint16_t)(0x0400)
N#define BITB                                     (uint16_t)(0x0800)
N#define BITC                                     (uint16_t)(0x1000)
N#define BITD                                     (uint16_t)(0x2000)
N#define BITE                                     (uint16_t)(0x4000)
N#define BITF                                     (uint16_t)(0x8000)
N#define BIT(x)                                 ((uint16_t)1 << (x))
N
N/******************************************************************************
N* Device and peripheral memory map                                            *
N******************************************************************************/
N/** @addtogroup MSP432P401R_MemoryMap MSP432P401R Memory Mapping
N  @{
N*/
N
N#define FLASH_BASE                               ((uint32_t)0x00000000)          /*!< Main Flash memory start address */
N#define SRAM_BASE                                ((uint32_t)0x20000000)          /*!< SRAM memory start address */
N#define PERIPH_BASE                              ((uint32_t)0x40000000)          /*!< Peripherals start address */
N#define PERIPH_BASE2                             ((uint32_t)0xE0000000)          /*!< Peripherals start address */
N
N#define ADC14_BASE                            (PERIPH_BASE +0x00012000)          /*!< Base address of module ADC14 registers */
N#define AES256_BASE                           (PERIPH_BASE +0x00003C00)          /*!< Base address of module AES256 registers */
N#define CAPTIO0_BASE                          (PERIPH_BASE +0x00005400)          /*!< Base address of module CAPTIO0 registers */
N#define CAPTIO1_BASE                          (PERIPH_BASE +0x00005800)          /*!< Base address of module CAPTIO1 registers */
N#define COMP_E0_BASE                          (PERIPH_BASE +0x00003400)          /*!< Base address of module COMP_E0 registers */
N#define COMP_E1_BASE                          (PERIPH_BASE +0x00003800)          /*!< Base address of module COMP_E1 registers */
N#define CRC32_BASE                            (PERIPH_BASE +0x00004000)          /*!< Base address of module CRC32 registers */
N#define CS_BASE                               (PERIPH_BASE +0x00010400)          /*!< Base address of module CS registers */
N#define DIO_BASE                              (PERIPH_BASE +0x00004C00)          /*!< Base address of module DIO registers */
N#define DMA_BASE                              (PERIPH_BASE +0x0000E000)          /*!< Base address of module DMA registers */
N#define EUSCI_A0_BASE                         (PERIPH_BASE +0x00001000)          /*!< Base address of module EUSCI_A0 registers */
N#define EUSCI_A0_SPI_BASE                     (PERIPH_BASE +0x00001000)          /*!< Base address of module EUSCI_A0 registers */
N#define EUSCI_A1_BASE                         (PERIPH_BASE +0x00001400)          /*!< Base address of module EUSCI_A1 registers */
N#define EUSCI_A1_SPI_BASE                     (PERIPH_BASE +0x00001400)          /*!< Base address of module EUSCI_A1 registers */
N#define EUSCI_A2_BASE                         (PERIPH_BASE +0x00001800)          /*!< Base address of module EUSCI_A2 registers */
N#define EUSCI_A2_SPI_BASE                     (PERIPH_BASE +0x00001800)          /*!< Base address of module EUSCI_A2 registers */
N#define EUSCI_A3_BASE                         (PERIPH_BASE +0x00001C00)          /*!< Base address of module EUSCI_A3 registers */
N#define EUSCI_A3_SPI_BASE                     (PERIPH_BASE +0x00001C00)          /*!< Base address of module EUSCI_A3 registers */
N#define EUSCI_B0_BASE                         (PERIPH_BASE +0x00002000)          /*!< Base address of module EUSCI_B0 registers */
N#define EUSCI_B0_SPI_BASE                     (PERIPH_BASE +0x00002000)          /*!< Base address of module EUSCI_B0 registers */
N#define EUSCI_B1_BASE                         (PERIPH_BASE +0x00002400)          /*!< Base address of module EUSCI_B1 registers */
N#define EUSCI_B1_SPI_BASE                     (PERIPH_BASE +0x00002400)          /*!< Base address of module EUSCI_B1 registers */
N#define EUSCI_B2_BASE                         (PERIPH_BASE +0x00002800)          /*!< Base address of module EUSCI_B2 registers */
N#define EUSCI_B2_SPI_BASE                     (PERIPH_BASE +0x00002800)          /*!< Base address of module EUSCI_B2 registers */
N#define EUSCI_B3_BASE                         (PERIPH_BASE +0x00002C00)          /*!< Base address of module EUSCI_B3 registers */
N#define EUSCI_B3_SPI_BASE                     (PERIPH_BASE +0x00002C00)          /*!< Base address of module EUSCI_B3 registers */
N#define FLCTL_BASE                            (PERIPH_BASE +0x00011000)          /*!< Base address of module FLCTL registers */
N#define FL_BOOTOVER_MAILBOX_BASE                 ((uint32_t)0x00200000)          /*!< Base address of module FL_BOOTOVER_MAILBOX registers */
N#define PCM_BASE                              (PERIPH_BASE +0x00010000)          /*!< Base address of module PCM registers */
N#define PMAP_BASE                             (PERIPH_BASE +0x00005000)          /*!< Base address of module PMAP registers */
N#define PSS_BASE                              (PERIPH_BASE +0x00010800)          /*!< Base address of module PSS registers */
N#define REF_A_BASE                            (PERIPH_BASE +0x00003000)          /*!< Base address of module REF_A registers */
N#define RSTCTL_BASE                           (PERIPH_BASE2+0x00042000)          /*!< Base address of module RSTCTL registers */
N#define RTC_C_BASE                            (PERIPH_BASE +0x00004400)          /*!< Base address of module RTC_C registers */
N#define RTC_C_BCD_BASE                        (PERIPH_BASE +0x00004400)          /*!< Base address of module RTC_C registers */
N#define SYSCTL_BASE                           (PERIPH_BASE2+0x00043000)          /*!< Base address of module SYSCTL registers */
N#define TIMER32_BASE                          (PERIPH_BASE +0x0000C000)          /*!< Base address of module TIMER32 registers */
N#define TIMER_A0_BASE                         (PERIPH_BASE +0x00000000)          /*!< Base address of module TIMER_A0 registers */
N#define TIMER_A1_BASE                         (PERIPH_BASE +0x00000400)          /*!< Base address of module TIMER_A1 registers */
N#define TIMER_A2_BASE                         (PERIPH_BASE +0x00000800)          /*!< Base address of module TIMER_A2 registers */
N#define TIMER_A3_BASE                         (PERIPH_BASE +0x00000C00)          /*!< Base address of module TIMER_A3 registers */
N#define TLV_BASE                                 ((uint32_t)0x00201000)          /*!< Base address of module TLV registers */
N#define WDT_A_BASE                            (PERIPH_BASE +0x00004800)          /*!< Base address of module WDT_A registers */
N
N
N/*@}*/ /* end of group MSP432P401R_MemoryMap */
N
N/******************************************************************************
N* Definitions for bit band access                                             *
N******************************************************************************/
N#define BITBAND_SRAM_BASE                     ((uint32_t)(0x22000000))
N#define BITBAND_PERI_BASE                     ((uint32_t)(0x42000000))
N
N/* SRAM allows 32 bit bit band access */
N#define BITBAND_SRAM(x, b)  (*((__IO uint32_t *) (BITBAND_SRAM_BASE +  (((uint32_t)(volatile const uint32_t *)&(x)) - SRAM_BASE  )*32 + (b)*4)))
N/* peripherals with 8 bit or 16 bit register access allow only 8 bit or 16 bit bit band access, so cast to 8 bit always */
N#define BITBAND_PERI(x, b)  (*((__IO  uint8_t *) (BITBAND_PERI_BASE +  (((uint32_t)(volatile const uint32_t *)&(x)) - PERIPH_BASE)*32 + (b)*4)))
N
N/******************************************************************************
N* Peripheral register definitions                                             *
N******************************************************************************/
N/** @addtogroup MSP432P401R_Peripherals MSP432P401R Peripherals
N  MSP432P401R Device Specific Peripheral registers structures
N  @{
N*/
N
N/* -------  Start of section using anonymous unions and disabling warnings  ------- */
N#if defined (__CC_ARM)
X#if 0L
S  #pragma push
S  #pragma anon_unions
S#elif defined (__ICCARM__)
X#elif 0L
S  #pragma language=extended
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 0L && (__ARMCC_VERSION >= 6010050)
S  #pragma clang diagnostic push
S  #pragma clang diagnostic ignored "-Wc11-extensions"
S#elif defined (__GNUC__)
X#elif 0L
S  /* anonymous unions are enabled by default */
N#elif defined (__TI_ARM__)
X#elif 1L
N  /* anonymous unions are enabled by default */
N#else
S  #warning Not supported compiler type
N#endif
N
N
N/******************************************************************************
N* ADC14 Registers
N******************************************************************************/
N/** @addtogroup ADC14 MSP432P401R (ADC14)
N  @{
N*/
Ntypedef struct {
N  __IO uint32_t CTL0;                                                            /*!< Control 0 Register */
X  volatile uint32_t CTL0;                                                             
N  __IO uint32_t CTL1;                                                            /*!< Control 1 Register */
X  volatile uint32_t CTL1;                                                             
N  __IO uint32_t LO0;                                                             /*!< Window Comparator Low Threshold 0 Register */
X  volatile uint32_t LO0;                                                              
N  __IO uint32_t HI0;                                                             /*!< Window Comparator High Threshold 0 Register */
X  volatile uint32_t HI0;                                                              
N  __IO uint32_t LO1;                                                             /*!< Window Comparator Low Threshold 1 Register */
X  volatile uint32_t LO1;                                                              
N  __IO uint32_t HI1;                                                             /*!< Window Comparator High Threshold 1 Register */
X  volatile uint32_t HI1;                                                              
N  __IO uint32_t MCTL[32];                                                        /*!< Conversion Memory Control Register */
X  volatile uint32_t MCTL[32];                                                         
N  __IO uint32_t MEM[32];                                                         /*!< Conversion Memory Register */
X  volatile uint32_t MEM[32];                                                          
N       uint32_t RESERVED0[9];
N  __IO uint32_t IER0;                                                            /*!< Interrupt Enable 0 Register */
X  volatile uint32_t IER0;                                                             
N  __IO uint32_t IER1;                                                            /*!< Interrupt Enable 1 Register */
X  volatile uint32_t IER1;                                                             
N  __I  uint32_t IFGR0;                                                           /*!< Interrupt Flag 0 Register */
X  volatile  uint32_t IFGR0;                                                            
N  __I  uint32_t IFGR1;                                                           /*!< Interrupt Flag 1 Register */
X  volatile  uint32_t IFGR1;                                                            
N  __O  uint32_t CLRIFGR0;                                                        /*!< Clear Interrupt Flag 0 Register */
X  volatile  uint32_t CLRIFGR0;                                                         
N  __IO uint32_t CLRIFGR1;                                                        /*!< Clear Interrupt Flag 1 Register */
X  volatile uint32_t CLRIFGR1;                                                         
N  __IO uint32_t IV;                                                              /*!< Interrupt Vector Register */
X  volatile uint32_t IV;                                                               
N} ADC14_Type;
N
N/*@}*/ /* end of group ADC14 */
N
N
N/******************************************************************************
N* AES256 Registers
N******************************************************************************/
N/** @addtogroup AES256 MSP432P401R (AES256)
N  @{
N*/
Ntypedef struct {
N  __IO uint16_t CTL0;                                                            /*!< AES Accelerator Control Register 0 */
X  volatile uint16_t CTL0;                                                             
N  __IO uint16_t CTL1;                                                            /*!< AES Accelerator Control Register 1 */
X  volatile uint16_t CTL1;                                                             
N  __IO uint16_t STAT;                                                            /*!< AES Accelerator Status Register */
X  volatile uint16_t STAT;                                                             
N  __O  uint16_t KEY;                                                             /*!< AES Accelerator Key Register */
X  volatile  uint16_t KEY;                                                              
N  __O  uint16_t DIN;                                                             /*!< AES Accelerator Data In Register */
X  volatile  uint16_t DIN;                                                              
N  __O  uint16_t DOUT;                                                            /*!< AES Accelerator Data Out Register */
X  volatile  uint16_t DOUT;                                                             
N  __O  uint16_t XDIN;                                                            /*!< AES Accelerator XORed Data In Register */
X  volatile  uint16_t XDIN;                                                             
N  __O  uint16_t XIN;                                                             /*!< AES Accelerator XORed Data In Register */
X  volatile  uint16_t XIN;                                                              
N} AES256_Type;
N
N/*@}*/ /* end of group AES256 */
N
N
N/******************************************************************************
N* CAPTIO Registers
N******************************************************************************/
N/** @addtogroup CAPTIO MSP432P401R (CAPTIO)
N  @{
N*/
Ntypedef struct {
N       uint16_t RESERVED0[7];
N  __IO uint16_t CTL;                                                             /*!< Capacitive Touch IO x Control Register */
X  volatile uint16_t CTL;                                                              
N} CAPTIO_Type;
N
N/*@}*/ /* end of group CAPTIO */
N
N
N/******************************************************************************
N* COMP_E Registers
N******************************************************************************/
N/** @addtogroup COMP_E MSP432P401R (COMP_E)
N  @{
N*/
Ntypedef struct {
N  __IO uint16_t CTL0;                                                            /*!< Comparator Control Register 0 */
X  volatile uint16_t CTL0;                                                             
N  __IO uint16_t CTL1;                                                            /*!< Comparator Control Register 1 */
X  volatile uint16_t CTL1;                                                             
N  __IO uint16_t CTL2;                                                            /*!< Comparator Control Register 2 */
X  volatile uint16_t CTL2;                                                             
N  __IO uint16_t CTL3;                                                            /*!< Comparator Control Register 3 */
X  volatile uint16_t CTL3;                                                             
N       uint16_t RESERVED0[2];
N  __IO uint16_t INT;                                                             /*!< Comparator Interrupt Control Register */
X  volatile uint16_t INT;                                                              
N  __I  uint16_t IV;                                                              /*!< Comparator Interrupt Vector Word Register */
X  volatile  uint16_t IV;                                                               
N} COMP_E_Type;
N
N/*@}*/ /* end of group COMP_E */
N
N
N/******************************************************************************
N* CRC32 Registers
N******************************************************************************/
N/** @addtogroup CRC32 MSP432P401R (CRC32)
N  @{
N*/
Ntypedef struct {
N  __IO uint16_t DI32;                                                            /*!< Data Input for CRC32 Signature Computation */
X  volatile uint16_t DI32;                                                             
N       uint16_t RESERVED0;
N  __IO uint16_t DIRB32;                                                          /*!< Data In Reverse for CRC32 Computation */
X  volatile uint16_t DIRB32;                                                           
N       uint16_t RESERVED1;
N  __IO uint16_t INIRES32_LO;                                                     /*!< CRC32 Initialization and Result, lower 16 bits */
X  volatile uint16_t INIRES32_LO;                                                      
N  __IO uint16_t INIRES32_HI;                                                     /*!< CRC32 Initialization and Result, upper 16 bits */
X  volatile uint16_t INIRES32_HI;                                                      
N  __IO uint16_t RESR32_LO;                                                       /*!< CRC32 Result Reverse, lower 16 bits */
X  volatile uint16_t RESR32_LO;                                                        
N  __IO uint16_t RESR32_HI;                                                       /*!< CRC32 Result Reverse, Upper 16 bits */
X  volatile uint16_t RESR32_HI;                                                        
N  __IO uint16_t DI16;                                                            /*!< Data Input for CRC16 computation */
X  volatile uint16_t DI16;                                                             
N       uint16_t RESERVED2;
N  __IO uint16_t DIRB16;                                                          /*!< CRC16 Data In Reverse */
X  volatile uint16_t DIRB16;                                                           
N       uint16_t RESERVED3;
N  __IO uint16_t INIRES16;                                                        /*!< CRC16 Initialization and Result register */
X  volatile uint16_t INIRES16;                                                         
N       uint16_t RESERVED4[2];
N  __IO uint16_t RESR16;                                                          /*!< CRC16 Result Reverse */
X  volatile uint16_t RESR16;                                                           
N} CRC32_Type;
N
N/*@}*/ /* end of group CRC32 */
N
N
N/******************************************************************************
N* CS Registers
N******************************************************************************/
N/** @addtogroup CS MSP432P401R (CS)
N  @{
N*/
Ntypedef struct {
N  __IO uint32_t KEY;                                                             /*!< Key Register */
X  volatile uint32_t KEY;                                                              
N  __IO uint32_t CTL0;                                                            /*!< Control 0 Register */
X  volatile uint32_t CTL0;                                                             
N  __IO uint32_t CTL1;                                                            /*!< Control 1 Register */
X  volatile uint32_t CTL1;                                                             
N  __IO uint32_t CTL2;                                                            /*!< Control 2 Register */
X  volatile uint32_t CTL2;                                                             
N  __IO uint32_t CTL3;                                                            /*!< Control 3 Register */
X  volatile uint32_t CTL3;                                                             
N       uint32_t RESERVED0[7];
N  __IO uint32_t CLKEN;                                                           /*!< Clock Enable Register */
X  volatile uint32_t CLKEN;                                                            
N  __I  uint32_t STAT;                                                            /*!< Status Register */
X  volatile  uint32_t STAT;                                                             
N       uint32_t RESERVED1[2];
N  __IO uint32_t IE;                                                              /*!< Interrupt Enable Register */
X  volatile uint32_t IE;                                                               
N       uint32_t RESERVED2;
N  __I  uint32_t IFG;                                                             /*!< Interrupt Flag Register */
X  volatile  uint32_t IFG;                                                              
N       uint32_t RESERVED3;
N  __O  uint32_t CLRIFG;                                                          /*!< Clear Interrupt Flag Register */
X  volatile  uint32_t CLRIFG;                                                           
N       uint32_t RESERVED4;
N  __O  uint32_t SETIFG;                                                          /*!< Set Interrupt Flag Register */
X  volatile  uint32_t SETIFG;                                                           
N       uint32_t RESERVED5;
N  __IO uint32_t DCOERCAL0;                                                       /*!< DCO External Resistor Cailbration 0 Register */
X  volatile uint32_t DCOERCAL0;                                                        
N  __IO uint32_t DCOERCAL1;                                                       /*!< DCO External Resistor Calibration 1 Register */
X  volatile uint32_t DCOERCAL1;                                                        
N} CS_Type;
N
N/*@}*/ /* end of group CS */
N
N
N/******************************************************************************
N* DIO Registers
N******************************************************************************/
N/** @addtogroup DIO MSP432P401R (DIO)
N  @{
N*/
Ntypedef struct {
N  union {
N    __I uint16_t IN;                                                              /*!< Port Pair Input */
X    volatile uint16_t IN;                                                               
N    struct {
N      __I uint8_t IN_L;                                                           /*!< Low Port Input */
X      volatile uint8_t IN_L;                                                            
N      __I uint8_t IN_H;                                                           /*!< High Port Input */
X      volatile uint8_t IN_H;                                                            
N    };
N  };
N  union {
N    __IO uint16_t OUT;                                                            /*!< Port Pair Output */
X    volatile uint16_t OUT;                                                             
N    struct {
N      __IO uint8_t OUT_L;                                                         /*!< Low Port Output */
X      volatile uint8_t OUT_L;                                                          
N      __IO uint8_t OUT_H;                                                         /*!< High Port Output */
X      volatile uint8_t OUT_H;                                                          
N    };
N  };
N  union {
N    __IO uint16_t DIR;                                                            /*!< Port Pair Direction */
X    volatile uint16_t DIR;                                                             
N    struct {
N      __IO uint8_t DIR_L;                                                         /*!< Low Port Direction */
X      volatile uint8_t DIR_L;                                                          
N      __IO uint8_t DIR_H;                                                         /*!< High Port Direction */
X      volatile uint8_t DIR_H;                                                          
N    };
N  };
N  union {
N    __IO uint16_t REN;                                                            /*!< Port Pair Resistor Enable */
X    volatile uint16_t REN;                                                             
N    struct {
N      __IO uint8_t REN_L;                                                         /*!< Low Port Resistor Enable */
X      volatile uint8_t REN_L;                                                          
N      __IO uint8_t REN_H;                                                         /*!< High Port Resistor Enable */
X      volatile uint8_t REN_H;                                                          
N    };
N  };
N  union {
N    __IO uint16_t DS;                                                             /*!< Port Pair Drive Strength */
X    volatile uint16_t DS;                                                              
N    struct {
N      __IO uint8_t DS_L;                                                          /*!< Low Port Drive Strength */
X      volatile uint8_t DS_L;                                                           
N      __IO uint8_t DS_H;                                                          /*!< High Port Drive Strength */
X      volatile uint8_t DS_H;                                                           
N    };
N  };
N  union {
N    __IO uint16_t SEL0;                                                           /*!< Port Pair Select 0 */
X    volatile uint16_t SEL0;                                                            
N    struct {
N      __IO uint8_t SEL0_L;                                                        /*!< Low Port Select 0 */
X      volatile uint8_t SEL0_L;                                                         
N      __IO uint8_t SEL0_H;                                                        /*!< High Port Select 0 */
X      volatile uint8_t SEL0_H;                                                         
N    };
N  };
N  union {
N    __IO uint16_t SEL1;                                                           /*!< Port Pair Select 1 */
X    volatile uint16_t SEL1;                                                            
N    struct {
N      __IO uint8_t SEL1_L;                                                        /*!< Low Port Select 1 */
X      volatile uint8_t SEL1_L;                                                         
N      __IO uint8_t SEL1_H;                                                        /*!< High Port Select 1 */
X      volatile uint8_t SEL1_H;                                                         
N    };
N  };
N  __I  uint16_t IV_L;                                                             /*!< Low Port Interrupt Vector Value */
X  volatile  uint16_t IV_L;                                                              
N  uint16_t  RESERVED0[3];
N  union {
N    __IO uint16_t SELC;                                                           /*!< Port Pair Complement Select */
X    volatile uint16_t SELC;                                                            
N    struct {
N      __IO uint8_t SELC_L;                                                        /*!< Low Port Complement Select */
X      volatile uint8_t SELC_L;                                                         
N      __IO uint8_t SELC_H;                                                        /*!< High Port Complement Select */
X      volatile uint8_t SELC_H;                                                         
N    };
N  };
N  union {
N    __IO uint16_t IES;                                                            /*!< Port Pair Interrupt Edge Select */
X    volatile uint16_t IES;                                                             
N    struct {
N      __IO uint8_t IES_L;                                                         /*!< Low Port Interrupt Edge Select */
X      volatile uint8_t IES_L;                                                          
N      __IO uint8_t IES_H;                                                         /*!< High Port Interrupt Edge Select */
X      volatile uint8_t IES_H;                                                          
N    };
N  };
N  union {
N    __IO uint16_t IE;                                                             /*!< Port Pair Interrupt Enable */
X    volatile uint16_t IE;                                                              
N    struct {
N      __IO uint8_t IE_L;                                                          /*!< Low Port Interrupt Enable */
X      volatile uint8_t IE_L;                                                           
N      __IO uint8_t IE_H;                                                          /*!< High Port Interrupt Enable */
X      volatile uint8_t IE_H;                                                           
N    };
N  };
N  union {
N    __IO uint16_t IFG;                                                            /*!< Port Pair Interrupt Flag */
X    volatile uint16_t IFG;                                                             
N    struct {
N      __IO uint8_t IFG_L;                                                         /*!< Low Port Interrupt Flag */
X      volatile uint8_t IFG_L;                                                          
N      __IO uint8_t IFG_H;                                                         /*!< High Port Interrupt Flag */
X      volatile uint8_t IFG_H;                                                          
N    };
N  };
N  __I uint16_t IV_H;                                                              /*!< High Port Interrupt Vector Value */
X  volatile uint16_t IV_H;                                                               
N} DIO_PORT_Interruptable_Type;
N
Ntypedef struct {
N  union {
N    __I uint16_t IN;                                                              /*!< Port Pair Input */
X    volatile uint16_t IN;                                                               
N    struct {
N      __I uint8_t IN_L;                                                           /*!< Low Port Input */
X      volatile uint8_t IN_L;                                                            
N      __I uint8_t IN_H;                                                           /*!< High Port Input */
X      volatile uint8_t IN_H;                                                            
N    };
N  };
N  union {
N    __IO uint16_t OUT;                                                            /*!< Port Pair Output */
X    volatile uint16_t OUT;                                                             
N    struct {
N      __IO uint8_t OUT_L;                                                         /*!< Low Port Output */
X      volatile uint8_t OUT_L;                                                          
N      __IO uint8_t OUT_H;                                                         /*!< High Port Output */
X      volatile uint8_t OUT_H;                                                          
N    };
N  };
N  union {
N    __IO uint16_t DIR;                                                            /*!< Port Pair Direction */
X    volatile uint16_t DIR;                                                             
N    struct {
N      __IO uint8_t DIR_L;                                                         /*!< Low Port Direction */
X      volatile uint8_t DIR_L;                                                          
N      __IO uint8_t DIR_H;                                                         /*!< High Port Direction */
X      volatile uint8_t DIR_H;                                                          
N    };
N  };
N  union {
N    __IO uint16_t REN;                                                            /*!< Port Pair Resistor Enable */
X    volatile uint16_t REN;                                                             
N    struct {
N      __IO uint8_t REN_L;                                                         /*!< Low Port Resistor Enable */
X      volatile uint8_t REN_L;                                                          
N      __IO uint8_t REN_H;                                                         /*!< High Port Resistor Enable */
X      volatile uint8_t REN_H;                                                          
N    };
N  };
N  union {
N    __IO uint16_t DS;                                                             /*!< Port Pair Drive Strength */
X    volatile uint16_t DS;                                                              
N    struct {
N      __IO uint8_t DS_L;                                                          /*!< Low Port Drive Strength */
X      volatile uint8_t DS_L;                                                           
N      __IO uint8_t DS_H;                                                          /*!< High Port Drive Strength */
X      volatile uint8_t DS_H;                                                           
N    };
N  };
N  union {
N    __IO uint16_t SEL0;                                                           /*!< Port Pair Select 0 */
X    volatile uint16_t SEL0;                                                            
N    struct {
N      __IO uint8_t SEL0_L;                                                        /*!< Low Port Select 0 */
X      volatile uint8_t SEL0_L;                                                         
N      __IO uint8_t SEL0_H;                                                        /*!< High Port Select 0 */
X      volatile uint8_t SEL0_H;                                                         
N    };
N  };
N  union {
N    __IO uint16_t SEL1;                                                           /*!< Port Pair Select 1 */
X    volatile uint16_t SEL1;                                                            
N    struct {
N      __IO uint8_t SEL1_L;                                                        /*!< Low Port Select 1 */
X      volatile uint8_t SEL1_L;                                                         
N      __IO uint8_t SEL1_H;                                                        /*!< High Port Select 1 */
X      volatile uint8_t SEL1_H;                                                         
N    };
N  };
N  uint16_t  RESERVED0[4];
N  union {
N    __IO uint16_t SELC;                                                           /*!< Port Pair Complement Select */
X    volatile uint16_t SELC;                                                            
N    struct {
N      __IO uint8_t SELC_L;                                                        /*!< Low Port Complement Select */
X      volatile uint8_t SELC_L;                                                         
N      __IO uint8_t SELC_H;                                                        /*!< High Port Complement Select */
X      volatile uint8_t SELC_H;                                                         
N    };
N  };
N} DIO_PORT_Not_Interruptable_Type;
N
N
Ntypedef struct {
N  __I uint8_t IN;                                                                 /*!< Port Input */
X  volatile uint8_t IN;                                                                  
N  uint8_t RESERVED0;
N  __IO uint8_t OUT;                                                               /*!< Port Output */
X  volatile uint8_t OUT;                                                                
N  uint8_t RESERVED1;
N  __IO uint8_t DIR;                                                               /*!< Port Direction */
X  volatile uint8_t DIR;                                                                
N  uint8_t RESERVED2;
N  __IO uint8_t REN;                                                               /*!< Port Resistor Enable */
X  volatile uint8_t REN;                                                                
N  uint8_t RESERVED3;
N  __IO uint8_t DS;                                                                /*!< Port Drive Strength */
X  volatile uint8_t DS;                                                                 
N  uint8_t RESERVED4;
N  __IO uint8_t SEL0;                                                              /*!< Port Select 0 */
X  volatile uint8_t SEL0;                                                               
N  uint8_t RESERVED5;
N  __IO uint8_t SEL1;                                                              /*!< Port Select 1 */
X  volatile uint8_t SEL1;                                                               
N  uint8_t RESERVED6;
N  __I  uint16_t IV;                                                               /*!< Port Interrupt Vector Value */
X  volatile  uint16_t IV;                                                                
N  uint8_t RESERVED7[6];
N  __IO uint8_t SELC;                                                              /*!< Port Complement Select */
X  volatile uint8_t SELC;                                                               
N  uint8_t RESERVED8;
N  __IO uint8_t IES;                                                               /*!< Port Interrupt Edge Select */
X  volatile uint8_t IES;                                                                
N  uint8_t RESERVED9;
N  __IO uint8_t IE;                                                                /*!< Port Interrupt Enable */
X  volatile uint8_t IE;                                                                 
N  uint8_t RESERVED10;
N  __IO uint8_t IFG;                                                               /*!< Port Interrupt Flag */
X  volatile uint8_t IFG;                                                                
N  uint8_t RESERVED11;
N} DIO_PORT_Odd_Interruptable_Type;
N
Ntypedef struct {
N  uint8_t RESERVED0;
N  __I uint8_t IN;                                                                 /*!< Port Input */
X  volatile uint8_t IN;                                                                  
N  uint8_t RESERVED1;
N  __IO uint8_t OUT;                                                               /*!< Port Output */
X  volatile uint8_t OUT;                                                                
N  uint8_t RESERVED2;
N  __IO uint8_t DIR;                                                               /*!< Port Direction */
X  volatile uint8_t DIR;                                                                
N  uint8_t RESERVED3;
N  __IO uint8_t REN;                                                               /*!< Port Resistor Enable */
X  volatile uint8_t REN;                                                                
N  uint8_t RESERVED4;
N  __IO uint8_t DS;                                                                /*!< Port Drive Strength */
X  volatile uint8_t DS;                                                                 
N  uint8_t RESERVED5;
N  __IO uint8_t SEL0;                                                              /*!< Port Select 0 */
X  volatile uint8_t SEL0;                                                               
N  uint8_t RESERVED6;
N  __IO uint8_t SEL1;                                                              /*!< Port Select 1 */
X  volatile uint8_t SEL1;                                                               
N  uint8_t RESERVED7[9];
N  __IO uint8_t SELC;                                                              /*!< Port Complement Select */
X  volatile uint8_t SELC;                                                               
N  uint8_t RESERVED8;
N  __IO uint8_t IES;                                                               /*!< Port Interrupt Edge Select */
X  volatile uint8_t IES;                                                                
N  uint8_t RESERVED9;
N  __IO uint8_t IE;                                                                /*!< Port Interrupt Enable */
X  volatile uint8_t IE;                                                                 
N  uint8_t RESERVED10;
N  __IO uint8_t IFG;                                                               /*!< Port Interrupt Flag */
X  volatile uint8_t IFG;                                                                
N  __I uint16_t IV;                                                                /*!< Port Interrupt Vector Value */
X  volatile uint16_t IV;                                                                 
N} DIO_PORT_Even_Interruptable_Type;
N
N/*@}*/ /* end of group MSP432P401R_DIO */
N
N
N/******************************************************************************
N* DMA Registers
N******************************************************************************/
N/** @addtogroup DMA MSP432P401R (DMA)
N  @{
N*/
Ntypedef struct {
N  __I  uint32_t DEVICE_CFG;                                                      /*!< Device Configuration Status */
X  volatile  uint32_t DEVICE_CFG;                                                       
N  __IO uint32_t SW_CHTRIG;                                                       /*!< Software Channel Trigger Register */
X  volatile uint32_t SW_CHTRIG;                                                        
N       uint32_t RESERVED0[2];
N  __IO uint32_t CH_SRCCFG[32];                                                   /*!< Channel n Source Configuration Register */
X  volatile uint32_t CH_SRCCFG[32];                                                    
N       uint32_t RESERVED1[28];
N  __IO uint32_t INT1_SRCCFG;                                                     /*!< Interrupt 1 Source Channel Configuration */
X  volatile uint32_t INT1_SRCCFG;                                                      
N  __IO uint32_t INT2_SRCCFG;                                                     /*!< Interrupt 2 Source Channel Configuration Register */
X  volatile uint32_t INT2_SRCCFG;                                                      
N  __IO uint32_t INT3_SRCCFG;                                                     /*!< Interrupt 3 Source Channel Configuration Register */
X  volatile uint32_t INT3_SRCCFG;                                                      
N       uint32_t RESERVED2;
N  __I  uint32_t INT0_SRCFLG;                                                     /*!< Interrupt 0 Source Channel Flag Register */
X  volatile  uint32_t INT0_SRCFLG;                                                      
N  __O  uint32_t INT0_CLRFLG;                                                     /*!< Interrupt 0 Source Channel Clear Flag Register */
X  volatile  uint32_t INT0_CLRFLG;                                                      
N} DMA_Channel_Type;
N
Ntypedef struct {
N  __I  uint32_t STAT;                                                            /*!< Status Register */
X  volatile  uint32_t STAT;                                                             
N  __O  uint32_t CFG;                                                             /*!< Configuration Register */
X  volatile  uint32_t CFG;                                                              
N  __IO uint32_t CTLBASE;                                                         /*!< Channel Control Data Base Pointer Register */
X  volatile uint32_t CTLBASE;                                                          
N  __I  uint32_t ALTBASE;                                                         /*!< Channel Alternate Control Data Base Pointer Register */
X  volatile  uint32_t ALTBASE;                                                          
N  __I  uint32_t WAITSTAT;                                                        /*!< Channel Wait on Request Status Register */
X  volatile  uint32_t WAITSTAT;                                                         
N  __O  uint32_t SWREQ;                                                           /*!< Channel Software Request Register */
X  volatile  uint32_t SWREQ;                                                            
N  __IO uint32_t USEBURSTSET;                                                     /*!< Channel Useburst Set Register */
X  volatile uint32_t USEBURSTSET;                                                      
N  __O  uint32_t USEBURSTCLR;                                                     /*!< Channel Useburst Clear Register */
X  volatile  uint32_t USEBURSTCLR;                                                      
N  __IO uint32_t REQMASKSET;                                                      /*!< Channel Request Mask Set Register */
X  volatile uint32_t REQMASKSET;                                                       
N  __O  uint32_t REQMASKCLR;                                                      /*!< Channel Request Mask Clear Register */
X  volatile  uint32_t REQMASKCLR;                                                       
N  __IO uint32_t ENASET;                                                          /*!< Channel Enable Set Register */
X  volatile uint32_t ENASET;                                                           
N  __O  uint32_t ENACLR;                                                          /*!< Channel Enable Clear Register */
X  volatile  uint32_t ENACLR;                                                           
N  __IO uint32_t ALTSET;                                                          /*!< Channel Primary-Alternate Set Register */
X  volatile uint32_t ALTSET;                                                           
N  __O  uint32_t ALTCLR;                                                          /*!< Channel Primary-Alternate Clear Register */
X  volatile  uint32_t ALTCLR;                                                           
N  __IO uint32_t PRIOSET;                                                         /*!< Channel Priority Set Register */
X  volatile uint32_t PRIOSET;                                                          
N  __O  uint32_t PRIOCLR;                                                         /*!< Channel Priority Clear Register */
X  volatile  uint32_t PRIOCLR;                                                          
N       uint32_t RESERVED4[3];
N  __IO uint32_t ERRCLR;                                                          /*!< Bus Error Clear Register */
X  volatile uint32_t ERRCLR;                                                           
N} DMA_Control_Type;
N
N/*@}*/ /* end of group DMA */
N
N
N/******************************************************************************
N* EUSCI_A Registers
N******************************************************************************/
N/** @addtogroup EUSCI_A MSP432P401R (EUSCI_A)
N  @{
N*/
Ntypedef struct {
N  __IO uint16_t CTLW0;                                                           /*!< eUSCI_Ax Control Word Register 0 */
X  volatile uint16_t CTLW0;                                                            
N  __IO uint16_t CTLW1;                                                           /*!< eUSCI_Ax Control Word Register 1 */
X  volatile uint16_t CTLW1;                                                            
N       uint16_t RESERVED0;
N  __IO uint16_t BRW;                                                             /*!< eUSCI_Ax Baud Rate Control Word Register */
X  volatile uint16_t BRW;                                                              
N  __IO uint16_t MCTLW;                                                           /*!< eUSCI_Ax Modulation Control Word Register */
X  volatile uint16_t MCTLW;                                                            
N  __IO uint16_t STATW;                                                           /*!< eUSCI_Ax Status Register */
X  volatile uint16_t STATW;                                                            
N  __I  uint16_t RXBUF;                                                           /*!< eUSCI_Ax Receive Buffer Register */
X  volatile  uint16_t RXBUF;                                                            
N  __IO uint16_t TXBUF;                                                           /*!< eUSCI_Ax Transmit Buffer Register */
X  volatile uint16_t TXBUF;                                                            
N  __IO uint16_t ABCTL;                                                           /*!< eUSCI_Ax Auto Baud Rate Control Register */
X  volatile uint16_t ABCTL;                                                            
N  __IO uint16_t IRCTL;                                                           /*!< eUSCI_Ax IrDA Control Word Register */
X  volatile uint16_t IRCTL;                                                            
N       uint16_t RESERVED1[3];
N  __IO uint16_t IE;                                                              /*!< eUSCI_Ax Interrupt Enable Register */
X  volatile uint16_t IE;                                                               
N  __IO uint16_t IFG;                                                             /*!< eUSCI_Ax Interrupt Flag Register */
X  volatile uint16_t IFG;                                                              
N  __I  uint16_t IV;                                                              /*!< eUSCI_Ax Interrupt Vector Register */
X  volatile  uint16_t IV;                                                               
N} EUSCI_A_Type;
N
N/*@}*/ /* end of group EUSCI_A */
N
N/** @addtogroup EUSCI_A_SPI MSP432P401R (EUSCI_A_SPI)
N  @{
N*/
Ntypedef struct {
N  __IO uint16_t CTLW0;                                                           /*!< eUSCI_Ax Control Word Register 0 */
X  volatile uint16_t CTLW0;                                                            
N       uint16_t RESERVED0[2];
N  __IO uint16_t BRW;                                                             /*!< eUSCI_Ax Bit Rate Control Register 1 */
X  volatile uint16_t BRW;                                                              
N       uint16_t RESERVED1;
N  __IO uint16_t STATW; 
X  volatile uint16_t STATW; 
N  __I  uint16_t RXBUF;                                                           /*!< eUSCI_Ax Receive Buffer Register */
X  volatile  uint16_t RXBUF;                                                            
N  __IO uint16_t TXBUF;                                                           /*!< eUSCI_Ax Transmit Buffer Register */
X  volatile uint16_t TXBUF;                                                            
N       uint16_t RESERVED2[5];
N  __IO uint16_t IE;                                                              /*!< eUSCI_Ax Interrupt Enable Register */
X  volatile uint16_t IE;                                                               
N  __IO uint16_t IFG;                                                             /*!< eUSCI_Ax Interrupt Flag Register */
X  volatile uint16_t IFG;                                                              
N  __I  uint16_t IV;                                                              /*!< eUSCI_Ax Interrupt Vector Register */
X  volatile  uint16_t IV;                                                               
N} EUSCI_A_SPI_Type;
N
N/*@}*/ /* end of group EUSCI_A_SPI */
N
N
N/******************************************************************************
N* EUSCI_B Registers
N******************************************************************************/
N/** @addtogroup EUSCI_B MSP432P401R (EUSCI_B)
N  @{
N*/
Ntypedef struct {
N  __IO uint16_t CTLW0;                                                           /*!< eUSCI_Bx Control Word Register 0 */
X  volatile uint16_t CTLW0;                                                            
N  __IO uint16_t CTLW1;                                                           /*!< eUSCI_Bx Control Word Register 1 */
X  volatile uint16_t CTLW1;                                                            
N       uint16_t RESERVED0;
N  __IO uint16_t BRW;                                                             /*!< eUSCI_Bx Baud Rate Control Word Register */
X  volatile uint16_t BRW;                                                              
N  __IO uint16_t STATW;                                                           /*!< eUSCI_Bx Status Register */
X  volatile uint16_t STATW;                                                            
N  __IO uint16_t TBCNT;                                                           /*!< eUSCI_Bx Byte Counter Threshold Register */
X  volatile uint16_t TBCNT;                                                            
N  __I  uint16_t RXBUF;                                                           /*!< eUSCI_Bx Receive Buffer Register */
X  volatile  uint16_t RXBUF;                                                            
N  __IO uint16_t TXBUF;                                                           /*!< eUSCI_Bx Transmit Buffer Register */
X  volatile uint16_t TXBUF;                                                            
N       uint16_t RESERVED1[2];
N  __IO uint16_t I2COA0;                                                          /*!< eUSCI_Bx I2C Own Address 0 Register */
X  volatile uint16_t I2COA0;                                                           
N  __IO uint16_t I2COA1;                                                          /*!< eUSCI_Bx I2C Own Address 1 Register */
X  volatile uint16_t I2COA1;                                                           
N  __IO uint16_t I2COA2;                                                          /*!< eUSCI_Bx I2C Own Address 2 Register */
X  volatile uint16_t I2COA2;                                                           
N  __IO uint16_t I2COA3;                                                          /*!< eUSCI_Bx I2C Own Address 3 Register */
X  volatile uint16_t I2COA3;                                                           
N  __I  uint16_t ADDRX;                                                           /*!< eUSCI_Bx I2C Received Address Register */
X  volatile  uint16_t ADDRX;                                                            
N  __IO uint16_t ADDMASK;                                                         /*!< eUSCI_Bx I2C Address Mask Register */
X  volatile uint16_t ADDMASK;                                                          
N  __IO uint16_t I2CSA;                                                           /*!< eUSCI_Bx I2C Slave Address Register */
X  volatile uint16_t I2CSA;                                                            
N       uint16_t RESERVED2[4];
N  __IO uint16_t IE;                                                              /*!< eUSCI_Bx Interrupt Enable Register */
X  volatile uint16_t IE;                                                               
N  __IO uint16_t IFG;                                                             /*!< eUSCI_Bx Interrupt Flag Register */
X  volatile uint16_t IFG;                                                              
N  __I  uint16_t IV;                                                              /*!< eUSCI_Bx Interrupt Vector Register */
X  volatile  uint16_t IV;                                                               
N} EUSCI_B_Type;
N
N/*@}*/ /* end of group EUSCI_B */
N
N/** @addtogroup EUSCI_B_SPI MSP432P401R (EUSCI_B_SPI)
N  @{
N*/
Ntypedef struct {
N  __IO uint16_t CTLW0;                                                           /*!< eUSCI_Bx Control Word Register 0 */
X  volatile uint16_t CTLW0;                                                            
N       uint16_t RESERVED0[2];
N  __IO uint16_t BRW;                                                             /*!< eUSCI_Bx Bit Rate Control Register 1 */
X  volatile uint16_t BRW;                                                              
N  __IO uint16_t STATW; 
X  volatile uint16_t STATW; 
N       uint16_t RESERVED1;
N  __I  uint16_t RXBUF;                                                           /*!< eUSCI_Bx Receive Buffer Register */
X  volatile  uint16_t RXBUF;                                                            
N  __IO uint16_t TXBUF;                                                           /*!< eUSCI_Bx Transmit Buffer Register */
X  volatile uint16_t TXBUF;                                                            
N       uint16_t RESERVED2[13];
N  __IO uint16_t IE;                                                              /*!< eUSCI_Bx Interrupt Enable Register */
X  volatile uint16_t IE;                                                               
N  __IO uint16_t IFG;                                                             /*!< eUSCI_Bx Interrupt Flag Register */
X  volatile uint16_t IFG;                                                              
N  __I  uint16_t IV;                                                              /*!< eUSCI_Bx Interrupt Vector Register */
X  volatile  uint16_t IV;                                                               
N} EUSCI_B_SPI_Type;
N
N/*@}*/ /* end of group EUSCI_B_SPI */
N
N
N/******************************************************************************
N* FLCTL Registers
N******************************************************************************/
N/** @addtogroup FLCTL MSP432P401R (FLCTL)
N  @{
N*/
Ntypedef struct {
N  __I  uint32_t POWER_STAT;                                                      /*!< Power Status Register */
X  volatile  uint32_t POWER_STAT;                                                       
N       uint32_t RESERVED0[3];
N  __IO uint32_t BANK0_RDCTL;                                                     /*!< Bank0 Read Control Register */
X  volatile uint32_t BANK0_RDCTL;                                                      
N  __IO uint32_t BANK1_RDCTL;                                                     /*!< Bank1 Read Control Register */
X  volatile uint32_t BANK1_RDCTL;                                                      
N       uint32_t RESERVED1[2];
N  __IO uint32_t RDBRST_CTLSTAT;                                                  /*!< Read Burst/Compare Control and Status Register */
X  volatile uint32_t RDBRST_CTLSTAT;                                                   
N  __IO uint32_t RDBRST_STARTADDR;                                                /*!< Read Burst/Compare Start Address Register */
X  volatile uint32_t RDBRST_STARTADDR;                                                 
N  __IO uint32_t RDBRST_LEN;                                                      /*!< Read Burst/Compare Length Register */
X  volatile uint32_t RDBRST_LEN;                                                       
N       uint32_t RESERVED2[4];
N  __IO uint32_t RDBRST_FAILADDR;                                                 /*!< Read Burst/Compare Fail Address Register */
X  volatile uint32_t RDBRST_FAILADDR;                                                  
N  __IO uint32_t RDBRST_FAILCNT;                                                  /*!< Read Burst/Compare Fail Count Register */
X  volatile uint32_t RDBRST_FAILCNT;                                                   
N       uint32_t RESERVED3[3];
N  __IO uint32_t PRG_CTLSTAT;                                                     /*!< Program Control and Status Register */
X  volatile uint32_t PRG_CTLSTAT;                                                      
N  __IO uint32_t PRGBRST_CTLSTAT;                                                 /*!< Program Burst Control and Status Register */
X  volatile uint32_t PRGBRST_CTLSTAT;                                                  
N  __IO uint32_t PRGBRST_STARTADDR;                                               /*!< Program Burst Start Address Register */
X  volatile uint32_t PRGBRST_STARTADDR;                                                
N       uint32_t RESERVED4;
N  __IO uint32_t PRGBRST_DATA0_0;                                                 /*!< Program Burst Data0 Register0 */
X  volatile uint32_t PRGBRST_DATA0_0;                                                  
N  __IO uint32_t PRGBRST_DATA0_1;                                                 /*!< Program Burst Data0 Register1 */
X  volatile uint32_t PRGBRST_DATA0_1;                                                  
N  __IO uint32_t PRGBRST_DATA0_2;                                                 /*!< Program Burst Data0 Register2 */
X  volatile uint32_t PRGBRST_DATA0_2;                                                  
N  __IO uint32_t PRGBRST_DATA0_3;                                                 /*!< Program Burst Data0 Register3 */
X  volatile uint32_t PRGBRST_DATA0_3;                                                  
N  __IO uint32_t PRGBRST_DATA1_0;                                                 /*!< Program Burst Data1 Register0 */
X  volatile uint32_t PRGBRST_DATA1_0;                                                  
N  __IO uint32_t PRGBRST_DATA1_1;                                                 /*!< Program Burst Data1 Register1 */
X  volatile uint32_t PRGBRST_DATA1_1;                                                  
N  __IO uint32_t PRGBRST_DATA1_2;                                                 /*!< Program Burst Data1 Register2 */
X  volatile uint32_t PRGBRST_DATA1_2;                                                  
N  __IO uint32_t PRGBRST_DATA1_3;                                                 /*!< Program Burst Data1 Register3 */
X  volatile uint32_t PRGBRST_DATA1_3;                                                  
N  __IO uint32_t PRGBRST_DATA2_0;                                                 /*!< Program Burst Data2 Register0 */
X  volatile uint32_t PRGBRST_DATA2_0;                                                  
N  __IO uint32_t PRGBRST_DATA2_1;                                                 /*!< Program Burst Data2 Register1 */
X  volatile uint32_t PRGBRST_DATA2_1;                                                  
N  __IO uint32_t PRGBRST_DATA2_2;                                                 /*!< Program Burst Data2 Register2 */
X  volatile uint32_t PRGBRST_DATA2_2;                                                  
N  __IO uint32_t PRGBRST_DATA2_3;                                                 /*!< Program Burst Data2 Register3 */
X  volatile uint32_t PRGBRST_DATA2_3;                                                  
N  __IO uint32_t PRGBRST_DATA3_0;                                                 /*!< Program Burst Data3 Register0 */
X  volatile uint32_t PRGBRST_DATA3_0;                                                  
N  __IO uint32_t PRGBRST_DATA3_1;                                                 /*!< Program Burst Data3 Register1 */
X  volatile uint32_t PRGBRST_DATA3_1;                                                  
N  __IO uint32_t PRGBRST_DATA3_2;                                                 /*!< Program Burst Data3 Register2 */
X  volatile uint32_t PRGBRST_DATA3_2;                                                  
N  __IO uint32_t PRGBRST_DATA3_3;                                                 /*!< Program Burst Data3 Register3 */
X  volatile uint32_t PRGBRST_DATA3_3;                                                  
N  __IO uint32_t ERASE_CTLSTAT;                                                   /*!< Erase Control and Status Register */
X  volatile uint32_t ERASE_CTLSTAT;                                                    
N  __IO uint32_t ERASE_SECTADDR;                                                  /*!< Erase Sector Address Register */
X  volatile uint32_t ERASE_SECTADDR;                                                   
N       uint32_t RESERVED5[2];
N  __IO uint32_t BANK0_INFO_WEPROT;                                               /*!< Information Memory Bank0 Write/Erase Protection Register */
X  volatile uint32_t BANK0_INFO_WEPROT;                                                
N  __IO uint32_t BANK0_MAIN_WEPROT;                                               /*!< Main Memory Bank0 Write/Erase Protection Register */
X  volatile uint32_t BANK0_MAIN_WEPROT;                                                
N       uint32_t RESERVED6[2];
N  __IO uint32_t BANK1_INFO_WEPROT;                                               /*!< Information Memory Bank1 Write/Erase Protection Register */
X  volatile uint32_t BANK1_INFO_WEPROT;                                                
N  __IO uint32_t BANK1_MAIN_WEPROT;                                               /*!< Main Memory Bank1 Write/Erase Protection Register */
X  volatile uint32_t BANK1_MAIN_WEPROT;                                                
N       uint32_t RESERVED7[2];
N  __IO uint32_t BMRK_CTLSTAT;                                                    /*!< Benchmark Control and Status Register */
X  volatile uint32_t BMRK_CTLSTAT;                                                     
N  __IO uint32_t BMRK_IFETCH;                                                     /*!< Benchmark Instruction Fetch Count Register */
X  volatile uint32_t BMRK_IFETCH;                                                      
N  __IO uint32_t BMRK_DREAD;                                                      /*!< Benchmark Data Read Count Register */
X  volatile uint32_t BMRK_DREAD;                                                       
N  __IO uint32_t BMRK_CMP;                                                        /*!< Benchmark Count Compare Register */
X  volatile uint32_t BMRK_CMP;                                                         
N       uint32_t RESERVED8[4];
N  __IO uint32_t IFG;                                                             /*!< Interrupt Flag Register */
X  volatile uint32_t IFG;                                                              
N  __IO uint32_t IE;                                                              /*!< Interrupt Enable Register */
X  volatile uint32_t IE;                                                               
N  __IO uint32_t CLRIFG;                                                          /*!< Clear Interrupt Flag Register */
X  volatile uint32_t CLRIFG;                                                           
N  __IO uint32_t SETIFG;                                                          /*!< Set Interrupt Flag Register */
X  volatile uint32_t SETIFG;                                                           
N  __I  uint32_t READ_TIMCTL;                                                     /*!< Read Timing Control Register */
X  volatile  uint32_t READ_TIMCTL;                                                      
N  __I  uint32_t READMARGIN_TIMCTL;                                               /*!< Read Margin Timing Control Register */
X  volatile  uint32_t READMARGIN_TIMCTL;                                                
N  __I  uint32_t PRGVER_TIMCTL;                                                   /*!< Program Verify Timing Control Register */
X  volatile  uint32_t PRGVER_TIMCTL;                                                    
N  __I  uint32_t ERSVER_TIMCTL;                                                   /*!< Erase Verify Timing Control Register */
X  volatile  uint32_t ERSVER_TIMCTL;                                                    
N  __I  uint32_t LKGVER_TIMCTL;                                                   /*!< Leakage Verify Timing Control Register */
X  volatile  uint32_t LKGVER_TIMCTL;                                                    
N  __I  uint32_t PROGRAM_TIMCTL;                                                  /*!< Program Timing Control Register */
X  volatile  uint32_t PROGRAM_TIMCTL;                                                   
N  __I  uint32_t ERASE_TIMCTL;                                                    /*!< Erase Timing Control Register */
X  volatile  uint32_t ERASE_TIMCTL;                                                     
N  __I  uint32_t MASSERASE_TIMCTL;                                                /*!< Mass Erase Timing Control Register */
X  volatile  uint32_t MASSERASE_TIMCTL;                                                 
N  __I  uint32_t BURSTPRG_TIMCTL;                                                 /*!< Burst Program Timing Control Register */
X  volatile  uint32_t BURSTPRG_TIMCTL;                                                  
N} FLCTL_Type;
N
N/*@}*/ /* end of group FLCTL */
N
N
N/******************************************************************************
N* FL_BOOTOVER_MAILBOX Registers
N******************************************************************************/
N/** @addtogroup SEC_ZONE_PARAMS MSP432P401R (FL_BOOTOVER_MAILBOX)
N  @{
N*/
Ntypedef struct {
N  __IO uint32_t SEC_ZONE_SECEN;                                                  /*!< IP Protection Secure Zone Enable. */
X  volatile uint32_t SEC_ZONE_SECEN;                                                   
N  __IO uint32_t SEC_ZONE_START_ADDR;                                             /*!< Start address of IP protected secure zone. */
X  volatile uint32_t SEC_ZONE_START_ADDR;                                              
N  __IO uint32_t SEC_ZONE_LENGTH;                                                 /*!< Length of IP protected secure zone in number of bytes. */
X  volatile uint32_t SEC_ZONE_LENGTH;                                                  
N  __IO uint32_t SEC_ZONE_AESINIT_VECT[4];                                        /*!< IP protected secure zone 0 AES initialization vector */
X  volatile uint32_t SEC_ZONE_AESINIT_VECT[4];                                         
N  __IO uint32_t SEC_ZONE_SECKEYS[8];                                             /*!< AES-CBC security keys. */
X  volatile uint32_t SEC_ZONE_SECKEYS[8];                                              
N  __IO uint32_t SEC_ZONE_UNENC_PWD[4];                                           /*!< Unencrypted password for authentication. */
X  volatile uint32_t SEC_ZONE_UNENC_PWD[4];                                            
N  __IO uint32_t SEC_ZONE_ENCUPDATE_EN;                                           /*!< IP Protected Secure Zone Encrypted In-field Update Enable */
X  volatile uint32_t SEC_ZONE_ENCUPDATE_EN;                                            
N  __IO uint32_t SEC_ZONE_DATA_EN;                                                /*!< IP Protected Secure Zone Data Access Enable */
X  volatile uint32_t SEC_ZONE_DATA_EN;                                                 
N  __IO uint32_t SEC_ZONE_ACK;                                                    /*!< Acknowledgment for IP Protection Secure Zone Enable Command. */
X  volatile uint32_t SEC_ZONE_ACK;                                                     
N       uint32_t RESERVED0[2];
N} SEC_ZONE_PARAMS_Type;
N
N/*@}*/ /* end of group SEC_ZONE_PARAMS */
N
N/** @addtogroup SEC_ZONE_UPDATE MSP432P401R (FL_BOOTOVER_MAILBOX)
N  @{
N*/
Ntypedef struct {
N  __IO uint32_t SEC_ZONE_PAYLOADADDR;                                            /*!< Start address where the payload is loaded in the device. */
X  volatile uint32_t SEC_ZONE_PAYLOADADDR;                                             
N  __IO uint32_t SEC_ZONE_PAYLOADLEN;                                             /*!< Length of the payload in bytes. */
X  volatile uint32_t SEC_ZONE_PAYLOADLEN;                                              
N  __IO uint32_t SEC_ZONE_UPDATE_ACK;                                             /*!< Acknowledgment for the IP Protected Secure Zone Update Command */
X  volatile uint32_t SEC_ZONE_UPDATE_ACK;                                              
N       uint32_t RESERVED0;
N} SEC_ZONE_UPDATE_Type;
N
N/*@}*/ /* end of group SEC_ZONE_UPDATE */
N
N/** @addtogroup FL_BOOTOVER_MAILBOX MSP432P401R (FL_BOOTOVER_MAILBOX)
N  @{
N*/
Ntypedef struct {
N  __IO uint32_t MB_START;                                                        /*!< Flash MailBox start: 0x0115ACF6 */
X  volatile uint32_t MB_START;                                                         
N  __IO uint32_t CMD;                                                             /*!< Command for Boot override operations. */
X  volatile uint32_t CMD;                                                              
N       uint32_t RESERVED0[2];
N  __IO uint32_t JTAG_SWD_LOCK_SECEN;                                             /*!< JTAG and SWD Lock Enable */
X  volatile uint32_t JTAG_SWD_LOCK_SECEN;                                              
N  __IO uint32_t JTAG_SWD_LOCK_AES_INIT_VECT[4];                                  /*!< JTAG and SWD lock AES initialization vector for AES-CBC */
X  volatile uint32_t JTAG_SWD_LOCK_AES_INIT_VECT[4];                                   
N  __IO uint32_t JTAG_SWD_LOCK_AES_SECKEYS[8];                                    /*!< JTAG and SWD lock AES CBC security Keys 0-7. */
X  volatile uint32_t JTAG_SWD_LOCK_AES_SECKEYS[8];                                     
N  __IO uint32_t JTAG_SWD_LOCK_UNENC_PWD[4];                                      /*!< JTAG and SWD lock unencrypted password */
X  volatile uint32_t JTAG_SWD_LOCK_UNENC_PWD[4];                                       
N  __IO uint32_t JTAG_SWD_LOCK_ACK;                                               /*!< Acknowledgment for JTAG and SWD Lock command */
X  volatile uint32_t JTAG_SWD_LOCK_ACK;                                                
N       uint32_t RESERVED1[2];
N  SEC_ZONE_PARAMS_Type SEC_ZONE_PARAMS[4];                                              
N  __IO uint32_t BSL_ENABLE;                                                      /*!< BSL Enable. */
X  volatile uint32_t BSL_ENABLE;                                                       
N  __IO uint32_t BSL_START_ADDRESS;                                               /*!< Contains the pointer to the BSL function. */
X  volatile uint32_t BSL_START_ADDRESS;                                                
N  __IO uint32_t BSL_PARAMETERS;                                                  /*!< BSL hardware invoke conifguration field. */
X  volatile uint32_t BSL_PARAMETERS;                                                   
N       uint32_t RESERVED2[2];
N  __IO uint32_t BSL_ACK;                                                         /*!< Acknowledgment for the BSL Configuration Command */
X  volatile uint32_t BSL_ACK;                                                          
N  __IO uint32_t JTAG_SWD_LOCK_ENCPAYLOADADD;                                     /*!< Start address where the payload is loaded in the device. */
X  volatile uint32_t JTAG_SWD_LOCK_ENCPAYLOADADD;                                      
N  __IO uint32_t JTAG_SWD_LOCK_ENCPAYLOADLEN;                                     /*!< Length of the encrypted payload in bytes */
X  volatile uint32_t JTAG_SWD_LOCK_ENCPAYLOADLEN;                                      
N  __IO uint32_t JTAG_SWD_LOCK_DST_ADDR;                                          /*!< Destination address where the final data needs to be stored into the device. */
X  volatile uint32_t JTAG_SWD_LOCK_DST_ADDR;                                           
N  __IO uint32_t ENC_UPDATE_ACK;                                                  /*!< Acknowledgment for JTAG and SWD Lock Encrypted Update Command */
X  volatile uint32_t ENC_UPDATE_ACK;                                                   
N       uint32_t RESERVED3;
N  SEC_ZONE_UPDATE_Type SEC_ZONE_UPDATE[4];                                              
N       uint32_t RESERVED4;
N  __IO uint32_t FACTORY_RESET_ENABLE;                                            /*!< Enable/Disable Factory Reset */
X  volatile uint32_t FACTORY_RESET_ENABLE;                                             
N  __IO uint32_t FACTORY_RESET_PWDEN;                                             /*!< Factory reset password enable */
X  volatile uint32_t FACTORY_RESET_PWDEN;                                              
N  __IO uint32_t FACTORY_RESET_PWD[4];                                            /*!< 128-bit Password for factory reset to be saved into the device. */
X  volatile uint32_t FACTORY_RESET_PWD[4];                                             
N  __IO uint32_t FACTORY_RESET_PARAMS_ACK;                                        /*!< Acknowledgment for the Factory Reset Params Command */
X  volatile uint32_t FACTORY_RESET_PARAMS_ACK;                                         
N       uint32_t RESERVED5;
N  __IO uint32_t FACTORY_RESET_PASSWORD[4];                                       /*!< 128-bit Password for factory reset. */
X  volatile uint32_t FACTORY_RESET_PASSWORD[4];                                        
N  __IO uint32_t FACTORY_RESET_ACK;                                               /*!< Acknowledgment for the Factory Reset Command */
X  volatile uint32_t FACTORY_RESET_ACK;                                                
N       uint32_t RESERVED6[2];
N  __IO uint32_t MB_END;                                                          /*!< Mailbox end */
X  volatile uint32_t MB_END;                                                           
N} FL_BOOTOVER_MAILBOX_Type;
N
N/*@}*/ /* end of group FL_BOOTOVER_MAILBOX */
N
N
N/******************************************************************************
N* PCM Registers
N******************************************************************************/
N/** @addtogroup PCM MSP432P401R (PCM)
N  @{
N*/
Ntypedef struct {
N  __IO uint32_t CTL0;                                                            /*!< Control 0 Register */
X  volatile uint32_t CTL0;                                                             
N  __IO uint32_t CTL1;                                                            /*!< Control 1 Register */
X  volatile uint32_t CTL1;                                                             
N  __IO uint32_t IE;                                                              /*!< Interrupt Enable Register */
X  volatile uint32_t IE;                                                               
N  __I  uint32_t IFG;                                                             /*!< Interrupt Flag Register */
X  volatile  uint32_t IFG;                                                              
N  __O  uint32_t CLRIFG;                                                          /*!< Clear Interrupt Flag Register */
X  volatile  uint32_t CLRIFG;                                                           
N} PCM_Type;
N
N/*@}*/ /* end of group PCM */
N
N
N/******************************************************************************
N* PMAP Registers
N******************************************************************************/
N/** @addtogroup PMAP MSP432P401R (PMAP)
N  @{
N*/
Ntypedef struct {
N  __IO uint16_t KEYID;
X  volatile uint16_t KEYID;
N  __IO uint16_t CTL;
X  volatile uint16_t CTL;
N} PMAP_COMMON_Type;
N
Ntypedef struct {
N  union {
N    __IO uint16_t PMAP_REGISTER[4];
X    volatile uint16_t PMAP_REGISTER[4];
N    struct {
N      __IO uint8_t PMAP_REGISTER0;
X      volatile uint8_t PMAP_REGISTER0;
N      __IO uint8_t PMAP_REGISTER1;
X      volatile uint8_t PMAP_REGISTER1;
N      __IO uint8_t PMAP_REGISTER2;
X      volatile uint8_t PMAP_REGISTER2;
N      __IO uint8_t PMAP_REGISTER3;
X      volatile uint8_t PMAP_REGISTER3;
N      __IO uint8_t PMAP_REGISTER4;
X      volatile uint8_t PMAP_REGISTER4;
N      __IO uint8_t PMAP_REGISTER5;
X      volatile uint8_t PMAP_REGISTER5;
N      __IO uint8_t PMAP_REGISTER6;
X      volatile uint8_t PMAP_REGISTER6;
N      __IO uint8_t PMAP_REGISTER7;
X      volatile uint8_t PMAP_REGISTER7;
N    };
N  };
N} PMAP_REGISTER_Type;
N
N/*@}*/ /* end of group PMAP */
N
N
N/******************************************************************************
N* PSS Registers
N******************************************************************************/
N/** @addtogroup PSS MSP432P401R (PSS)
N  @{
N*/
Ntypedef struct {
N  __IO uint32_t KEY;                                                             /*!< Key Register */
X  volatile uint32_t KEY;                                                              
N  __IO uint32_t CTL0;                                                            /*!< Control 0 Register */
X  volatile uint32_t CTL0;                                                             
N       uint32_t RESERVED0[11];
N  __IO uint32_t IE;                                                              /*!< Interrupt Enable Register */
X  volatile uint32_t IE;                                                               
N  __I  uint32_t IFG;                                                             /*!< Interrupt Flag Register */
X  volatile  uint32_t IFG;                                                              
N  __IO uint32_t CLRIFG;                                                          /*!< Clear Interrupt Flag Register */
X  volatile uint32_t CLRIFG;                                                           
N} PSS_Type;
N
N/*@}*/ /* end of group PSS */
N
N
N/******************************************************************************
N* REF_A Registers
N******************************************************************************/
N/** @addtogroup REF_A MSP432P401R (REF_A)
N  @{
N*/
Ntypedef struct {
N  __IO uint16_t CTL0;                                                            /*!< REF Control Register 0 */
X  volatile uint16_t CTL0;                                                             
N} REF_A_Type;
N
N/*@}*/ /* end of group REF_A */
N
N
N/******************************************************************************
N* RSTCTL Registers
N******************************************************************************/
N/** @addtogroup RSTCTL MSP432P401R (RSTCTL)
N  @{
N*/
Ntypedef struct {
N  __IO uint32_t RESET_REQ;                                                       /*!< Reset Request Register */
X  volatile uint32_t RESET_REQ;                                                        
N  __I  uint32_t HARDRESET_STAT;                                                  /*!< Hard Reset Status Register */
X  volatile  uint32_t HARDRESET_STAT;                                                   
N  __IO uint32_t HARDRESET_CLR;                                                   /*!< Hard Reset Status Clear Register */
X  volatile uint32_t HARDRESET_CLR;                                                    
N  __IO uint32_t HARDRESET_SET;                                                   /*!< Hard Reset Status Set Register */
X  volatile uint32_t HARDRESET_SET;                                                    
N  __I  uint32_t SOFTRESET_STAT;                                                  /*!< Soft Reset Status Register */
X  volatile  uint32_t SOFTRESET_STAT;                                                   
N  __IO uint32_t SOFTRESET_CLR;                                                   /*!< Soft Reset Status Clear Register */
X  volatile uint32_t SOFTRESET_CLR;                                                    
N  __IO uint32_t SOFTRESET_SET;                                                   /*!< Soft Reset Status Set Register */
X  volatile uint32_t SOFTRESET_SET;                                                    
N       uint32_t RESERVED0[57];
N  __I  uint32_t PSSRESET_STAT;                                                   /*!< PSS Reset Status Register */
X  volatile  uint32_t PSSRESET_STAT;                                                    
N  __IO uint32_t PSSRESET_CLR;                                                    /*!< PSS Reset Status Clear Register */
X  volatile uint32_t PSSRESET_CLR;                                                     
N  __I  uint32_t PCMRESET_STAT;                                                   /*!< PCM Reset Status Register */
X  volatile  uint32_t PCMRESET_STAT;                                                    
N  __IO uint32_t PCMRESET_CLR;                                                    /*!< PCM Reset Status Clear Register */
X  volatile uint32_t PCMRESET_CLR;                                                     
N  __I  uint32_t PINRESET_STAT;                                                   /*!< Pin Reset Status Register */
X  volatile  uint32_t PINRESET_STAT;                                                    
N  __IO uint32_t PINRESET_CLR;                                                    /*!< Pin Reset Status Clear Register */
X  volatile uint32_t PINRESET_CLR;                                                     
N  __I  uint32_t REBOOTRESET_STAT;                                                /*!< Reboot Reset Status Register */
X  volatile  uint32_t REBOOTRESET_STAT;                                                 
N  __IO uint32_t REBOOTRESET_CLR;                                                 /*!< Reboot Reset Status Clear Register */
X  volatile uint32_t REBOOTRESET_CLR;                                                  
N  __I  uint32_t CSRESET_STAT;                                                    /*!< CS Reset Status Register */
X  volatile  uint32_t CSRESET_STAT;                                                     
N  __IO uint32_t CSRESET_CLR;                                                     /*!< CS Reset Status Clear Register */
X  volatile uint32_t CSRESET_CLR;                                                      
N} RSTCTL_Type;
N
N/*@}*/ /* end of group RSTCTL */
N
N
N/******************************************************************************
N* RTC_C Registers
N******************************************************************************/
N/** @addtogroup RTC_C MSP432P401R (RTC_C)
N  @{
N*/
Ntypedef struct {
N  __IO uint16_t CTL0;                                                            /*!< RTCCTL0 Register */
X  volatile uint16_t CTL0;                                                             
N  __IO uint16_t CTL13;                                                           /*!< RTCCTL13 Register */
X  volatile uint16_t CTL13;                                                            
N  __IO uint16_t OCAL;                                                            /*!< RTCOCAL Register */
X  volatile uint16_t OCAL;                                                             
N  __IO uint16_t TCMP;                                                            /*!< RTCTCMP Register */
X  volatile uint16_t TCMP;                                                             
N  __IO uint16_t PS0CTL;                                                          /*!< Real-Time Clock Prescale Timer 0 Control Register */
X  volatile uint16_t PS0CTL;                                                           
N  __IO uint16_t PS1CTL;                                                          /*!< Real-Time Clock Prescale Timer 1 Control Register */
X  volatile uint16_t PS1CTL;                                                           
N  __IO uint16_t PS;                                                              /*!< Real-Time Clock Prescale Timer Counter Register */
X  volatile uint16_t PS;                                                               
N  __I  uint16_t IV;                                                              /*!< Real-Time Clock Interrupt Vector Register */
X  volatile  uint16_t IV;                                                               
N  __IO uint16_t TIM0;                                                            /*!< RTCTIM0 Register  Hexadecimal Format */
X  volatile uint16_t TIM0;                                                             
N  __IO uint16_t TIM1;                                                            /*!< Real-Time Clock Hour, Day of Week */
X  volatile uint16_t TIM1;                                                             
N  __IO uint16_t DATE;                                                            /*!< RTCDATE - Hexadecimal Format */
X  volatile uint16_t DATE;                                                             
N  __IO uint16_t YEAR;                                                            /*!< RTCYEAR Register  Hexadecimal Format */
X  volatile uint16_t YEAR;                                                             
N  __IO uint16_t AMINHR;                                                          /*!< RTCMINHR - Hexadecimal Format */
X  volatile uint16_t AMINHR;                                                           
N  __IO uint16_t ADOWDAY;                                                         /*!< RTCADOWDAY - Hexadecimal Format */
X  volatile uint16_t ADOWDAY;                                                          
N  __IO uint16_t BIN2BCD;                                                         /*!< Binary-to-BCD Conversion Register */
X  volatile uint16_t BIN2BCD;                                                          
N  __IO uint16_t BCD2BIN;                                                         /*!< BCD-to-Binary Conversion Register */
X  volatile uint16_t BCD2BIN;                                                          
N} RTC_C_Type;
N
N/*@}*/ /* end of group RTC_C */
N
N/** @addtogroup RTC_C_BCD MSP432P401R (RTC_C_BCD)
N  @{
N*/
Ntypedef struct {
N       uint16_t RESERVED0[8];
N  __IO uint16_t TIM0;                                                            /*!< Real-Time Clock Seconds, Minutes Register - BCD Format */
X  volatile uint16_t TIM0;                                                             
N  __IO uint16_t TIM1;                                                            /*!< Real-Time Clock Hour, Day of Week - BCD Format */
X  volatile uint16_t TIM1;                                                             
N  __IO uint16_t DATE;                                                            /*!< Real-Time Clock Date - BCD Format */
X  volatile uint16_t DATE;                                                             
N  __IO uint16_t YEAR;                                                            /*!< Real-Time Clock Year Register - BCD Format */
X  volatile uint16_t YEAR;                                                             
N  __IO uint16_t AMINHR;                                                          /*!< Real-Time Clock Minutes, Hour Alarm - BCD Format */
X  volatile uint16_t AMINHR;                                                           
N  __IO uint16_t ADOWDAY;                                                         /*!< Real-Time Clock Day of Week, Day of Month Alarm - BCD Format */
X  volatile uint16_t ADOWDAY;                                                          
N} RTC_C_BCD_Type;
N
N/*@}*/ /* end of group RTC_C_BCD */
N
N
N/******************************************************************************
N* SYSCTL Registers
N******************************************************************************/
N/** @addtogroup SYSCTL MSP432P401R (SYSCTL)
N  @{
N*/
Ntypedef struct {
N  __IO uint32_t REBOOT_CTL;                                                      /*!< Reboot Control Register */
X  volatile uint32_t REBOOT_CTL;                                                       
N  __IO uint32_t NMI_CTLSTAT;                                                     /*!< NMI Control and Status Register */
X  volatile uint32_t NMI_CTLSTAT;                                                      
N  __IO uint32_t WDTRESET_CTL;                                                    /*!< Watchdog Reset Control Register */
X  volatile uint32_t WDTRESET_CTL;                                                     
N  __IO uint32_t PERIHALT_CTL;                                                    /*!< Peripheral Halt Control Register */
X  volatile uint32_t PERIHALT_CTL;                                                     
N  __I  uint32_t SRAM_SIZE;                                                       /*!< SRAM Size Register */
X  volatile  uint32_t SRAM_SIZE;                                                        
N  __IO uint32_t SRAM_BANKEN;                                                     /*!< SRAM Bank Enable Register */
X  volatile uint32_t SRAM_BANKEN;                                                      
N  __IO uint32_t SRAM_BANKRET;                                                    /*!< SRAM Bank Retention Control Register */
X  volatile uint32_t SRAM_BANKRET;                                                     
N       uint32_t RESERVED0;
N  __I  uint32_t FLASH_SIZE;                                                      /*!< Flash Size Register */
X  volatile  uint32_t FLASH_SIZE;                                                       
N       uint32_t RESERVED1[3];
N  __IO uint32_t DIO_GLTFLT_CTL;                                                  /*!< Digital I/O Glitch Filter Control Register */
X  volatile uint32_t DIO_GLTFLT_CTL;                                                   
N       uint32_t RESERVED2[3];
N  __IO uint32_t SECDATA_UNLOCK;                                                  /*!< IP Protected Secure Zone Data Access Unlock Register */
X  volatile uint32_t SECDATA_UNLOCK;                                                   
N} SYSCTL_Type;
N
Ntypedef struct {
N  __IO uint32_t MASTER_UNLOCK;                                                   /*!< Master Unlock Register */
X  volatile uint32_t MASTER_UNLOCK;                                                    
N  __IO uint32_t BOOTOVER_REQ[2];                                                 /*!< Boot Override Request Register */
X  volatile uint32_t BOOTOVER_REQ[2];                                                  
N  __IO uint32_t BOOTOVER_ACK;                                                    /*!< Boot Override Acknowledge Register */
X  volatile uint32_t BOOTOVER_ACK;                                                     
N  __IO uint32_t RESET_REQ;                                                       /*!< Reset Request Register */
X  volatile uint32_t RESET_REQ;                                                        
N  __IO uint32_t RESET_STATOVER;                                                  /*!< Reset Status and Override Register */
X  volatile uint32_t RESET_STATOVER;                                                   
N       uint32_t RESERVED7[2];
N  __I  uint32_t SYSTEM_STAT;                                                     /*!< System Status Register */
X  volatile  uint32_t SYSTEM_STAT;                                                      
N} SYSCTL_Boot_Type;
N
N/*@}*/ /* end of group SYSCTL */
N
N
N/******************************************************************************
N* Timer32 Registers
N******************************************************************************/
N/** @addtogroup Timer32 MSP432P401R (Timer32)
N  @{
N*/
Ntypedef struct {
N  __IO uint32_t LOAD;                                                            /*!< Timer Load Register */
X  volatile uint32_t LOAD;                                                             
N  __I  uint32_t VALUE;                                                           /*!< Timer Current Value Register */
X  volatile  uint32_t VALUE;                                                            
N  __IO uint32_t CONTROL;                                                         /*!< Timer Control Register */
X  volatile uint32_t CONTROL;                                                          
N  __O  uint32_t INTCLR;                                                          /*!< Timer Interrupt Clear Register */
X  volatile  uint32_t INTCLR;                                                           
N  __I  uint32_t RIS;                                                             /*!< Timer Raw Interrupt Status Register */
X  volatile  uint32_t RIS;                                                              
N  __I  uint32_t MIS;                                                             /*!< Timer Interrupt Status Register */
X  volatile  uint32_t MIS;                                                              
N  __IO uint32_t BGLOAD;                                                          /*!< Timer Background Load Register */
X  volatile uint32_t BGLOAD;                                                           
N} Timer32_Type;
N
N/*@}*/ /* end of group Timer32 */
N
N
N/******************************************************************************
N* Timer_A Registers
N******************************************************************************/
N/** @addtogroup Timer_A MSP432P401R (Timer_A)
N  @{
N*/
Ntypedef struct {
N  __IO uint16_t CTL;                                                             /*!< TimerAx Control Register */
X  volatile uint16_t CTL;                                                              
N  __IO uint16_t CCTL[5];                                                         /*!< Timer_A Capture/Compare Control Register */
X  volatile uint16_t CCTL[5];                                                          
N       uint16_t RESERVED0[2];
N  __IO uint16_t R;                                                               /*!< TimerA register */
X  volatile uint16_t R;                                                                
N  __IO uint16_t CCR[5];                                                          /*!< Timer_A Capture/Compare  Register */
X  volatile uint16_t CCR[5];                                                           
N       uint16_t RESERVED1[2];
N  __IO uint16_t EX0;                                                             /*!< TimerAx Expansion 0 Register */
X  volatile uint16_t EX0;                                                              
N       uint16_t RESERVED2[6];
N  __I  uint16_t IV;                                                              /*!< TimerAx Interrupt Vector Register */
X  volatile  uint16_t IV;                                                               
N} Timer_A_Type;
N
N/*@}*/ /* end of group Timer_A */
N
N
N/******************************************************************************
N* TLV Registers
N******************************************************************************/
N/** @addtogroup TLV MSP432P401R (TLV)
N  @{
N*/
Ntypedef struct {
N  __I  uint32_t TLV_CHECKSUM;                                                    /*!< TLV Checksum */
X  volatile  uint32_t TLV_CHECKSUM;                                                     
N  __I  uint32_t DEVICE_INFO_TAG;                                                 /*!< Device Info Tag */
X  volatile  uint32_t DEVICE_INFO_TAG;                                                  
N  __I  uint32_t DEVICE_INFO_LEN;                                                 /*!< Device Info Length */
X  volatile  uint32_t DEVICE_INFO_LEN;                                                  
N  __I  uint32_t DEVICE_ID;                                                       /*!< Device ID */
X  volatile  uint32_t DEVICE_ID;                                                        
N  __I  uint32_t HWREV;                                                           /*!< HW Revision */
X  volatile  uint32_t HWREV;                                                            
N  __I  uint32_t BCREV;                                                           /*!< Boot Code Revision */
X  volatile  uint32_t BCREV;                                                            
N  __I  uint32_t ROM_DRVLIB_REV;                                                  /*!< ROM Driver Library Revision */
X  volatile  uint32_t ROM_DRVLIB_REV;                                                   
N  __I  uint32_t DIE_REC_TAG;                                                     /*!< Die Record Tag */
X  volatile  uint32_t DIE_REC_TAG;                                                      
N  __I  uint32_t DIE_REC_LEN;                                                     /*!< Die Record Length */
X  volatile  uint32_t DIE_REC_LEN;                                                      
N  __I  uint32_t DIE_XPOS;                                                        /*!< Die X-Position */
X  volatile  uint32_t DIE_XPOS;                                                         
N  __I  uint32_t DIE_YPOS;                                                        /*!< Die Y-Position */
X  volatile  uint32_t DIE_YPOS;                                                         
N  __I  uint32_t WAFER_ID;                                                        /*!< Wafer ID */
X  volatile  uint32_t WAFER_ID;                                                         
N  __I  uint32_t LOT_ID;                                                          /*!< Lot ID */
X  volatile  uint32_t LOT_ID;                                                           
N  __I  uint32_t RESERVED0;                                                       /*!< Reserved */
X  volatile  uint32_t RESERVED0;                                                        
N  __I  uint32_t RESERVED1;                                                       /*!< Reserved */
X  volatile  uint32_t RESERVED1;                                                        
N  __I  uint32_t RESERVED2;                                                       /*!< Reserved */
X  volatile  uint32_t RESERVED2;                                                        
N  __I  uint32_t TEST_RESULTS;                                                    /*!< Test Results */
X  volatile  uint32_t TEST_RESULTS;                                                     
N  __I  uint32_t CS_CAL_TAG;                                                      /*!< Clock System Calibration Tag */
X  volatile  uint32_t CS_CAL_TAG;                                                       
N  __I  uint32_t CS_CAL_LEN;                                                      /*!< Clock System Calibration Length */
X  volatile  uint32_t CS_CAL_LEN;                                                       
N  __I  uint32_t DCOIR_FCAL_RSEL04;                                               /*!< DCO IR mode: Frequency calibration for DCORSEL 0 to 4 */
X  volatile  uint32_t DCOIR_FCAL_RSEL04;                                                
N  __I  uint32_t DCOIR_FCAL_RSEL5;                                                /*!< DCO IR mode: Frequency calibration for DCORSEL 5 */
X  volatile  uint32_t DCOIR_FCAL_RSEL5;                                                 
N  __I  uint32_t RESERVED3;                                                       /*!< Reserved */
X  volatile  uint32_t RESERVED3;                                                        
N  __I  uint32_t RESERVED4;                                                       /*!< Reserved */
X  volatile  uint32_t RESERVED4;                                                        
N  __I  uint32_t RESERVED5;                                                       /*!< Reserved */
X  volatile  uint32_t RESERVED5;                                                        
N  __I  uint32_t RESERVED6;                                                       /*!< Reserved */
X  volatile  uint32_t RESERVED6;                                                        
N  __I  uint32_t DCOIR_CONSTK_RSEL04;                                             /*!< DCO IR mode: DCO Constant (K) for DCORSEL 0 to 4 */
X  volatile  uint32_t DCOIR_CONSTK_RSEL04;                                              
N  __I  uint32_t DCOIR_CONSTK_RSEL5;                                              /*!< DCO IR mode: DCO Constant (K) for DCORSEL 5 */
X  volatile  uint32_t DCOIR_CONSTK_RSEL5;                                               
N  __I  uint32_t DCOER_FCAL_RSEL04;                                               /*!< DCO ER mode: Frequency calibration for DCORSEL 0 to 4 */
X  volatile  uint32_t DCOER_FCAL_RSEL04;                                                
N  __I  uint32_t DCOER_FCAL_RSEL5;                                                /*!< DCO ER mode: Frequency calibration for DCORSEL 5 */
X  volatile  uint32_t DCOER_FCAL_RSEL5;                                                 
N  __I  uint32_t RESERVED7;                                                       /*!< Reserved */
X  volatile  uint32_t RESERVED7;                                                        
N  __I  uint32_t RESERVED8;                                                       /*!< Reserved */
X  volatile  uint32_t RESERVED8;                                                        
N  __I  uint32_t RESERVED9;                                                       /*!< Reserved */
X  volatile  uint32_t RESERVED9;                                                        
N  __I  uint32_t RESERVED10;                                                      /*!< Reserved */
X  volatile  uint32_t RESERVED10;                                                       
N  __I  uint32_t DCOER_CONSTK_RSEL04;                                             /*!< DCO ER mode: DCO Constant (K) for DCORSEL 0 to 4 */
X  volatile  uint32_t DCOER_CONSTK_RSEL04;                                              
N  __I  uint32_t DCOER_CONSTK_RSEL5;                                              /*!< DCO ER mode: DCO Constant (K) for DCORSEL 5 */
X  volatile  uint32_t DCOER_CONSTK_RSEL5;                                               
N  __I  uint32_t ADC14_CAL_TAG;                                                   /*!< ADC14 Calibration Tag */
X  volatile  uint32_t ADC14_CAL_TAG;                                                    
N  __I  uint32_t ADC14_CAL_LEN;                                                   /*!< ADC14 Calibration Length */
X  volatile  uint32_t ADC14_CAL_LEN;                                                    
N  __I  uint32_t ADC_GAIN_FACTOR;                                                 /*!< ADC Gain Factor */
X  volatile  uint32_t ADC_GAIN_FACTOR;                                                  
N  __I  uint32_t ADC_OFFSET;                                                      /*!< ADC Offset */
X  volatile  uint32_t ADC_OFFSET;                                                       
N  __I  uint32_t RESERVED11;                                                      /*!< Reserved */
X  volatile  uint32_t RESERVED11;                                                       
N  __I  uint32_t RESERVED12;                                                      /*!< Reserved */
X  volatile  uint32_t RESERVED12;                                                       
N  __I  uint32_t RESERVED13;                                                      /*!< Reserved */
X  volatile  uint32_t RESERVED13;                                                       
N  __I  uint32_t RESERVED14;                                                      /*!< Reserved */
X  volatile  uint32_t RESERVED14;                                                       
N  __I  uint32_t RESERVED15;                                                      /*!< Reserved */
X  volatile  uint32_t RESERVED15;                                                       
N  __I  uint32_t RESERVED16;                                                      /*!< Reserved */
X  volatile  uint32_t RESERVED16;                                                       
N  __I  uint32_t RESERVED17;                                                      /*!< Reserved */
X  volatile  uint32_t RESERVED17;                                                       
N  __I  uint32_t RESERVED18;                                                      /*!< Reserved */
X  volatile  uint32_t RESERVED18;                                                       
N  __I  uint32_t RESERVED19;                                                      /*!< Reserved */
X  volatile  uint32_t RESERVED19;                                                       
N  __I  uint32_t RESERVED20;                                                      /*!< Reserved */
X  volatile  uint32_t RESERVED20;                                                       
N  __I  uint32_t RESERVED21;                                                      /*!< Reserved */
X  volatile  uint32_t RESERVED21;                                                       
N  __I  uint32_t RESERVED22;                                                      /*!< Reserved */
X  volatile  uint32_t RESERVED22;                                                       
N  __I  uint32_t RESERVED23;                                                      /*!< Reserved */
X  volatile  uint32_t RESERVED23;                                                       
N  __I  uint32_t RESERVED24;                                                      /*!< Reserved */
X  volatile  uint32_t RESERVED24;                                                       
N  __I  uint32_t RESERVED25;                                                      /*!< Reserved */
X  volatile  uint32_t RESERVED25;                                                       
N  __I  uint32_t RESERVED26;                                                      /*!< Reserved */
X  volatile  uint32_t RESERVED26;                                                       
N  __I  uint32_t ADC14_REF1P2V_TS30C;                                             /*!< ADC14 1.2V Reference Temp. Sensor 30C */
X  volatile  uint32_t ADC14_REF1P2V_TS30C;                                              
N  __I  uint32_t ADC14_REF1P2V_TS85C;                                             /*!< ADC14 1.2V Reference Temp. Sensor 85C */
X  volatile  uint32_t ADC14_REF1P2V_TS85C;                                              
N  __I  uint32_t ADC14_REF1P45V_TS30C;                                            /*!< ADC14 1.45V Reference Temp. Sensor 30C */
X  volatile  uint32_t ADC14_REF1P45V_TS30C;                                             
N  __I  uint32_t ADC14_REF1P45V_TS85C;                                            /*!< ADC14 1.45V Reference Temp. Sensor 85C */
X  volatile  uint32_t ADC14_REF1P45V_TS85C;                                             
N  __I  uint32_t ADC14_REF2P5V_TS30C;                                             /*!< ADC14 2.5V Reference Temp. Sensor 30C */
X  volatile  uint32_t ADC14_REF2P5V_TS30C;                                              
N  __I  uint32_t ADC14_REF2P5V_TS85C;                                             /*!< ADC14 2.5V Reference Temp. Sensor 85C */
X  volatile  uint32_t ADC14_REF2P5V_TS85C;                                              
N  __I  uint32_t REF_CAL_TAG;                                                     /*!< REF Calibration Tag */
X  volatile  uint32_t REF_CAL_TAG;                                                      
N  __I  uint32_t REF_CAL_LEN;                                                     /*!< REF Calibration Length */
X  volatile  uint32_t REF_CAL_LEN;                                                      
N  __I  uint32_t REF_1P2V;                                                        /*!< REF 1.2V Reference */
X  volatile  uint32_t REF_1P2V;                                                         
N  __I  uint32_t REF_1P45V;                                                       /*!< REF 1.45V Reference */
X  volatile  uint32_t REF_1P45V;                                                        
N  __I  uint32_t REF_2P5V;                                                        /*!< REF 2.5V Reference */
X  volatile  uint32_t REF_2P5V;                                                         
N  __I  uint32_t FLASH_INFO_TAG;                                                  /*!< Flash Info Tag */
X  volatile  uint32_t FLASH_INFO_TAG;                                                   
N  __I  uint32_t FLASH_INFO_LEN;                                                  /*!< Flash Info Length */
X  volatile  uint32_t FLASH_INFO_LEN;                                                   
N  __I  uint32_t FLASH_MAX_PROG_PULSES;                                           /*!< Flash Maximum Programming Pulses */
X  volatile  uint32_t FLASH_MAX_PROG_PULSES;                                            
N  __I  uint32_t FLASH_MAX_ERASE_PULSES;                                          /*!< Flash Maximum Erase Pulses */
X  volatile  uint32_t FLASH_MAX_ERASE_PULSES;                                           
N  __I  uint32_t RANDOM_NUM_TAG;                                                  /*!< 128-bit Random Number Tag */
X  volatile  uint32_t RANDOM_NUM_TAG;                                                   
N  __I  uint32_t RANDOM_NUM_LEN;                                                  /*!< 128-bit Random Number Length */
X  volatile  uint32_t RANDOM_NUM_LEN;                                                   
N  __I  uint32_t RANDOM_NUM_1;                                                    /*!< 32-bit Random Number 1 */
X  volatile  uint32_t RANDOM_NUM_1;                                                     
N  __I  uint32_t RANDOM_NUM_2;                                                    /*!< 32-bit Random Number 2 */
X  volatile  uint32_t RANDOM_NUM_2;                                                     
N  __I  uint32_t RANDOM_NUM_3;                                                    /*!< 32-bit Random Number 3 */
X  volatile  uint32_t RANDOM_NUM_3;                                                     
N  __I  uint32_t RANDOM_NUM_4;                                                    /*!< 32-bit Random Number 4 */
X  volatile  uint32_t RANDOM_NUM_4;                                                     
N  __I  uint32_t BSL_CFG_TAG;                                                     /*!< BSL Configuration Tag */
X  volatile  uint32_t BSL_CFG_TAG;                                                      
N  __I  uint32_t BSL_CFG_LEN;                                                     /*!< BSL Configuration Length */
X  volatile  uint32_t BSL_CFG_LEN;                                                      
N  __I  uint32_t BSL_PERIPHIF_SEL;                                                /*!< BSL Peripheral Interface Selection */
X  volatile  uint32_t BSL_PERIPHIF_SEL;                                                 
N  __I  uint32_t BSL_PORTIF_CFG_UART;                                             /*!< BSL Port Interface Configuration for UART */
X  volatile  uint32_t BSL_PORTIF_CFG_UART;                                              
N  __I  uint32_t BSL_PORTIF_CFG_SPI;                                              /*!< BSL Port Interface Configuration for SPI */
X  volatile  uint32_t BSL_PORTIF_CFG_SPI;                                               
N  __I  uint32_t BSL_PORTIF_CFG_I2C;                                              /*!< BSL Port Interface Configuration for I2C */
X  volatile  uint32_t BSL_PORTIF_CFG_I2C;                                               
N  __I  uint32_t TLV_END;                                                         /*!< TLV End Word */
X  volatile  uint32_t TLV_END;                                                          
N} TLV_Type;
N
N/*@}*/ /* end of group TLV */
N
N
N/******************************************************************************
N* WDT_A Registers
N******************************************************************************/
N/** @addtogroup WDT_A MSP432P401R (WDT_A)
N  @{
N*/
Ntypedef struct {
N       uint16_t RESERVED0[6];
N  __IO uint16_t CTL;                                                             /*!< Watchdog Timer Control Register */
X  volatile uint16_t CTL;                                                              
N} WDT_A_Type;
N
N/*@}*/ /* end of group WDT_A */
N
N
N/* --------------------  End of section using anonymous unions  ------------------- */
N#if defined(__CC_ARM)
X#if 0L
S  #pragma pop
S#elif defined(__ICCARM__)
X#elif 0L
S  /* leave anonymous unions enabled */
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 0L && (__ARMCC_VERSION >= 6010050)
S  #pragma clang diagnostic pop
S#elif defined(__GNUC__)
X#elif 0L
S  /* anonymous unions are enabled by default */
N#elif defined(__TI_ARM__)
X#elif 1L
N  /* anonymous unions are enabled by default */
N#else
S  #warning Not supported compiler type
N#endif
N
N/*@}*/ /* end of group MSP432P401R_Peripherals */
N
N/******************************************************************************
N* Peripheral declaration                                                      *
N******************************************************************************/
N/** @addtogroup MSP432P401R_PeripheralDecl MSP432P401R Peripheral Declaration
N  @{
N*/
N
N#define ADC14                            ((ADC14_Type *) ADC14_BASE)   
N#define AES256                           ((AES256_Type *) AES256_BASE) 
N#define CAPTIO0                          ((CAPTIO_Type *) CAPTIO0_BASE)
N#define CAPTIO1                          ((CAPTIO_Type *) CAPTIO1_BASE)
N#define COMP_E0                          ((COMP_E_Type *) COMP_E0_BASE)
N#define COMP_E1                          ((COMP_E_Type *) COMP_E1_BASE)
N#define CRC32                            ((CRC32_Type *) CRC32_BASE)   
N#define CS                               ((CS_Type *) CS_BASE)         
N#define PA                               ((DIO_PORT_Interruptable_Type*) (DIO_BASE + 0x0000))
N#define PB                               ((DIO_PORT_Interruptable_Type*) (DIO_BASE + 0x0020))
N#define PC                               ((DIO_PORT_Interruptable_Type*) (DIO_BASE + 0x0040))
N#define PD                               ((DIO_PORT_Interruptable_Type*) (DIO_BASE + 0x0060))
N#define PE                               ((DIO_PORT_Interruptable_Type*) (DIO_BASE + 0x0080))
N#define PJ                               ((DIO_PORT_Not_Interruptable_Type*) (DIO_BASE + 0x0120))
N#define P1                               ((DIO_PORT_Odd_Interruptable_Type*)  (DIO_BASE + 0x0000))
N#define P2                               ((DIO_PORT_Even_Interruptable_Type*) (DIO_BASE + 0x0000))
N#define P3                               ((DIO_PORT_Odd_Interruptable_Type*)  (DIO_BASE + 0x0020))
N#define P4                               ((DIO_PORT_Even_Interruptable_Type*) (DIO_BASE + 0x0020))
N#define P5                               ((DIO_PORT_Odd_Interruptable_Type*)  (DIO_BASE + 0x0040))
N#define P6                               ((DIO_PORT_Even_Interruptable_Type*) (DIO_BASE + 0x0040))
N#define P7                               ((DIO_PORT_Odd_Interruptable_Type*)  (DIO_BASE + 0x0060))
N#define P8                               ((DIO_PORT_Even_Interruptable_Type*) (DIO_BASE + 0x0060))
N#define P9                               ((DIO_PORT_Odd_Interruptable_Type*)  (DIO_BASE + 0x0080))
N#define P10                              ((DIO_PORT_Even_Interruptable_Type*) (DIO_BASE + 0x0080))
N#define DMA_Channel                      ((DMA_Channel_Type *) DMA_BASE)
N#define DMA_Control                      ((DMA_Control_Type *) (DMA_BASE + 0x1000))
N#define EUSCI_A0                         ((EUSCI_A_Type *) EUSCI_A0_BASE)
N#define EUSCI_A0_SPI                     ((EUSCI_A_SPI_Type *) EUSCI_A0_SPI_BASE)
N#define EUSCI_A1                         ((EUSCI_A_Type *) EUSCI_A1_BASE)
N#define EUSCI_A1_SPI                     ((EUSCI_A_SPI_Type *) EUSCI_A1_SPI_BASE)
N#define EUSCI_A2                         ((EUSCI_A_Type *) EUSCI_A2_BASE)
N#define EUSCI_A2_SPI                     ((EUSCI_A_SPI_Type *) EUSCI_A2_SPI_BASE)
N#define EUSCI_A3                         ((EUSCI_A_Type *) EUSCI_A3_BASE)
N#define EUSCI_A3_SPI                     ((EUSCI_A_SPI_Type *) EUSCI_A3_SPI_BASE)
N#define EUSCI_B0                         ((EUSCI_B_Type *) EUSCI_B0_BASE)
N#define EUSCI_B0_SPI                     ((EUSCI_B_SPI_Type *) EUSCI_B0_SPI_BASE)
N#define EUSCI_B1                         ((EUSCI_B_Type *) EUSCI_B1_BASE)
N#define EUSCI_B1_SPI                     ((EUSCI_B_SPI_Type *) EUSCI_B1_SPI_BASE)
N#define EUSCI_B2                         ((EUSCI_B_Type *) EUSCI_B2_BASE)
N#define EUSCI_B2_SPI                     ((EUSCI_B_SPI_Type *) EUSCI_B2_SPI_BASE)
N#define EUSCI_B3                         ((EUSCI_B_Type *) EUSCI_B3_BASE)
N#define EUSCI_B3_SPI                     ((EUSCI_B_SPI_Type *) EUSCI_B3_SPI_BASE)
N#define FLCTL                            ((FLCTL_Type *) FLCTL_BASE)   
N#define FL_BOOTOVER_MAILBOX              ((FL_BOOTOVER_MAILBOX_Type *) FL_BOOTOVER_MAILBOX_BASE)
N#define PCM                              ((PCM_Type *) PCM_BASE)       
N#define PMAP                             ((PMAP_COMMON_Type*) PMAP_BASE)
N#define P1MAP                            ((PMAP_REGISTER_Type*) (PMAP_BASE + 0x0008))
N#define P2MAP                            ((PMAP_REGISTER_Type*) (PMAP_BASE + 0x0010))
N#define P3MAP                            ((PMAP_REGISTER_Type*) (PMAP_BASE + 0x0018))
N#define P4MAP                            ((PMAP_REGISTER_Type*) (PMAP_BASE + 0x0020))
N#define P5MAP                            ((PMAP_REGISTER_Type*) (PMAP_BASE + 0x0028))
N#define P6MAP                            ((PMAP_REGISTER_Type*) (PMAP_BASE + 0x0030))
N#define P7MAP                            ((PMAP_REGISTER_Type*) (PMAP_BASE + 0x0038))
N#define PSS                              ((PSS_Type *) PSS_BASE)       
N#define REF_A                            ((REF_A_Type *) REF_A_BASE)   
N#define RSTCTL                           ((RSTCTL_Type *) RSTCTL_BASE) 
N#define RTC_C                            ((RTC_C_Type *) RTC_C_BASE)   
N#define RTC_C_BCD                        ((RTC_C_BCD_Type *) RTC_C_BCD_BASE)
N#define SYSCTL                           ((SYSCTL_Type *) SYSCTL_BASE)
N#define SYSCTL_Boot                      ((SYSCTL_Boot_Type *) (SYSCTL_BASE + 0x1000))
N#define TIMER32_1                        ((Timer32_Type *) TIMER32_BASE)
N#define TIMER32_2                        ((Timer32_Type *) (TIMER32_BASE + 0x00020))
N#define TIMER_A0                         ((Timer_A_Type *) TIMER_A0_BASE)
N#define TIMER_A1                         ((Timer_A_Type *) TIMER_A1_BASE)
N#define TIMER_A2                         ((Timer_A_Type *) TIMER_A2_BASE)
N#define TIMER_A3                         ((Timer_A_Type *) TIMER_A3_BASE)
N#define TLV                              ((TLV_Type *) TLV_BASE)       
N#define WDT_A                            ((WDT_A_Type *) WDT_A_BASE)   
N
N
N/*@}*/ /* end of group MSP432P401R_PeripheralDecl */
N
N/*@}*/ /* end of group MSP432P401R_Definitions */
N
N#endif /* __CMSIS_CONFIG__ */
N
N/******************************************************************************
N* Peripheral register control bits                                            *
N******************************************************************************/
N
N/******************************************************************************
N* ADC14 Bits
N******************************************************************************/
N/* ADC14_CTL0[SC] Bits */
N#define ADC14_CTL0_SC_OFS                        ( 0)                            /*!< ADC14SC Bit Offset */
N#define ADC14_CTL0_SC                            ((uint32_t)0x00000001)          /*!< ADC14 start conversion */
N/* ADC14_CTL0[ENC] Bits */
N#define ADC14_CTL0_ENC_OFS                       ( 1)                            /*!< ADC14ENC Bit Offset */
N#define ADC14_CTL0_ENC                           ((uint32_t)0x00000002)          /*!< ADC14 enable conversion */
N/* ADC14_CTL0[ON] Bits */
N#define ADC14_CTL0_ON_OFS                        ( 4)                            /*!< ADC14ON Bit Offset */
N#define ADC14_CTL0_ON                            ((uint32_t)0x00000010)          /*!< ADC14 on */
N/* ADC14_CTL0[MSC] Bits */
N#define ADC14_CTL0_MSC_OFS                       ( 7)                            /*!< ADC14MSC Bit Offset */
N#define ADC14_CTL0_MSC                           ((uint32_t)0x00000080)          /*!< ADC14 multiple sample and conversion */
N/* ADC14_CTL0[SHT0] Bits */
N#define ADC14_CTL0_SHT0_OFS                      ( 8)                            /*!< ADC14SHT0 Bit Offset */
N#define ADC14_CTL0_SHT0_MASK                     ((uint32_t)0x00000F00)          /*!< ADC14SHT0 Bit Mask */
N#define ADC14_CTL0_SHT00                         ((uint32_t)0x00000100)          /*!< SHT0 Bit 0 */
N#define ADC14_CTL0_SHT01                         ((uint32_t)0x00000200)          /*!< SHT0 Bit 1 */
N#define ADC14_CTL0_SHT02                         ((uint32_t)0x00000400)          /*!< SHT0 Bit 2 */
N#define ADC14_CTL0_SHT03                         ((uint32_t)0x00000800)          /*!< SHT0 Bit 3 */
N#define ADC14_CTL0_SHT0_0                        ((uint32_t)0x00000000)          /*!< 4 */
N#define ADC14_CTL0_SHT0_1                        ((uint32_t)0x00000100)          /*!< 8 */
N#define ADC14_CTL0_SHT0_2                        ((uint32_t)0x00000200)          /*!< 16 */
N#define ADC14_CTL0_SHT0_3                        ((uint32_t)0x00000300)          /*!< 32 */
N#define ADC14_CTL0_SHT0_4                        ((uint32_t)0x00000400)          /*!< 64 */
N#define ADC14_CTL0_SHT0_5                        ((uint32_t)0x00000500)          /*!< 96 */
N#define ADC14_CTL0_SHT0_6                        ((uint32_t)0x00000600)          /*!< 128 */
N#define ADC14_CTL0_SHT0_7                        ((uint32_t)0x00000700)          /*!< 192 */
N#define ADC14_CTL0_SHT0__4                       ((uint32_t)0x00000000)          /*!< 4 */
N#define ADC14_CTL0_SHT0__8                       ((uint32_t)0x00000100)          /*!< 8 */
N#define ADC14_CTL0_SHT0__16                      ((uint32_t)0x00000200)          /*!< 16 */
N#define ADC14_CTL0_SHT0__32                      ((uint32_t)0x00000300)          /*!< 32 */
N#define ADC14_CTL0_SHT0__64                      ((uint32_t)0x00000400)          /*!< 64 */
N#define ADC14_CTL0_SHT0__96                      ((uint32_t)0x00000500)          /*!< 96 */
N#define ADC14_CTL0_SHT0__128                     ((uint32_t)0x00000600)          /*!< 128 */
N#define ADC14_CTL0_SHT0__192                     ((uint32_t)0x00000700)          /*!< 192 */
N/* ADC14_CTL0[SHT1] Bits */
N#define ADC14_CTL0_SHT1_OFS                      (12)                            /*!< ADC14SHT1 Bit Offset */
N#define ADC14_CTL0_SHT1_MASK                     ((uint32_t)0x0000F000)          /*!< ADC14SHT1 Bit Mask */
N#define ADC14_CTL0_SHT10                         ((uint32_t)0x00001000)          /*!< SHT1 Bit 0 */
N#define ADC14_CTL0_SHT11                         ((uint32_t)0x00002000)          /*!< SHT1 Bit 1 */
N#define ADC14_CTL0_SHT12                         ((uint32_t)0x00004000)          /*!< SHT1 Bit 2 */
N#define ADC14_CTL0_SHT13                         ((uint32_t)0x00008000)          /*!< SHT1 Bit 3 */
N#define ADC14_CTL0_SHT1_0                        ((uint32_t)0x00000000)          /*!< 4 */
N#define ADC14_CTL0_SHT1_1                        ((uint32_t)0x00001000)          /*!< 8 */
N#define ADC14_CTL0_SHT1_2                        ((uint32_t)0x00002000)          /*!< 16 */
N#define ADC14_CTL0_SHT1_3                        ((uint32_t)0x00003000)          /*!< 32 */
N#define ADC14_CTL0_SHT1_4                        ((uint32_t)0x00004000)          /*!< 64 */
N#define ADC14_CTL0_SHT1_5                        ((uint32_t)0x00005000)          /*!< 96 */
N#define ADC14_CTL0_SHT1_6                        ((uint32_t)0x00006000)          /*!< 128 */
N#define ADC14_CTL0_SHT1_7                        ((uint32_t)0x00007000)          /*!< 192 */
N#define ADC14_CTL0_SHT1__4                       ((uint32_t)0x00000000)          /*!< 4 */
N#define ADC14_CTL0_SHT1__8                       ((uint32_t)0x00001000)          /*!< 8 */
N#define ADC14_CTL0_SHT1__16                      ((uint32_t)0x00002000)          /*!< 16 */
N#define ADC14_CTL0_SHT1__32                      ((uint32_t)0x00003000)          /*!< 32 */
N#define ADC14_CTL0_SHT1__64                      ((uint32_t)0x00004000)          /*!< 64 */
N#define ADC14_CTL0_SHT1__96                      ((uint32_t)0x00005000)          /*!< 96 */
N#define ADC14_CTL0_SHT1__128                     ((uint32_t)0x00006000)          /*!< 128 */
N#define ADC14_CTL0_SHT1__192                     ((uint32_t)0x00007000)          /*!< 192 */
N/* ADC14_CTL0[BUSY] Bits */
N#define ADC14_CTL0_BUSY_OFS                      (16)                            /*!< ADC14BUSY Bit Offset */
N#define ADC14_CTL0_BUSY                          ((uint32_t)0x00010000)          /*!< ADC14 busy */
N/* ADC14_CTL0[CONSEQ] Bits */
N#define ADC14_CTL0_CONSEQ_OFS                    (17)                            /*!< ADC14CONSEQ Bit Offset */
N#define ADC14_CTL0_CONSEQ_MASK                   ((uint32_t)0x00060000)          /*!< ADC14CONSEQ Bit Mask */
N#define ADC14_CTL0_CONSEQ0                       ((uint32_t)0x00020000)          /*!< CONSEQ Bit 0 */
N#define ADC14_CTL0_CONSEQ1                       ((uint32_t)0x00040000)          /*!< CONSEQ Bit 1 */
N#define ADC14_CTL0_CONSEQ_0                      ((uint32_t)0x00000000)          /*!< Single-channel, single-conversion */
N#define ADC14_CTL0_CONSEQ_1                      ((uint32_t)0x00020000)          /*!< Sequence-of-channels */
N#define ADC14_CTL0_CONSEQ_2                      ((uint32_t)0x00040000)          /*!< Repeat-single-channel */
N#define ADC14_CTL0_CONSEQ_3                      ((uint32_t)0x00060000)          /*!< Repeat-sequence-of-channels */
N/* ADC14_CTL0[SSEL] Bits */
N#define ADC14_CTL0_SSEL_OFS                      (19)                            /*!< ADC14SSEL Bit Offset */
N#define ADC14_CTL0_SSEL_MASK                     ((uint32_t)0x00380000)          /*!< ADC14SSEL Bit Mask */
N#define ADC14_CTL0_SSEL0                         ((uint32_t)0x00080000)          /*!< SSEL Bit 0 */
N#define ADC14_CTL0_SSEL1                         ((uint32_t)0x00100000)          /*!< SSEL Bit 1 */
N#define ADC14_CTL0_SSEL2                         ((uint32_t)0x00200000)          /*!< SSEL Bit 2 */
N#define ADC14_CTL0_SSEL_0                        ((uint32_t)0x00000000)          /*!< MODCLK */
N#define ADC14_CTL0_SSEL_1                        ((uint32_t)0x00080000)          /*!< SYSCLK */
N#define ADC14_CTL0_SSEL_2                        ((uint32_t)0x00100000)          /*!< ACLK */
N#define ADC14_CTL0_SSEL_3                        ((uint32_t)0x00180000)          /*!< MCLK */
N#define ADC14_CTL0_SSEL_4                        ((uint32_t)0x00200000)          /*!< SMCLK */
N#define ADC14_CTL0_SSEL_5                        ((uint32_t)0x00280000)          /*!< HSMCLK */
N#define ADC14_CTL0_SSEL__MODCLK                  ((uint32_t)0x00000000)          /*!< MODCLK */
N#define ADC14_CTL0_SSEL__SYSCLK                  ((uint32_t)0x00080000)          /*!< SYSCLK */
N#define ADC14_CTL0_SSEL__ACLK                    ((uint32_t)0x00100000)          /*!< ACLK */
N#define ADC14_CTL0_SSEL__MCLK                    ((uint32_t)0x00180000)          /*!< MCLK */
N#define ADC14_CTL0_SSEL__SMCLK                   ((uint32_t)0x00200000)          /*!< SMCLK */
N#define ADC14_CTL0_SSEL__HSMCLK                  ((uint32_t)0x00280000)          /*!< HSMCLK */
N/* ADC14_CTL0[DIV] Bits */
N#define ADC14_CTL0_DIV_OFS                       (22)                            /*!< ADC14DIV Bit Offset */
N#define ADC14_CTL0_DIV_MASK                      ((uint32_t)0x01C00000)          /*!< ADC14DIV Bit Mask */
N#define ADC14_CTL0_DIV0                          ((uint32_t)0x00400000)          /*!< DIV Bit 0 */
N#define ADC14_CTL0_DIV1                          ((uint32_t)0x00800000)          /*!< DIV Bit 1 */
N#define ADC14_CTL0_DIV2                          ((uint32_t)0x01000000)          /*!< DIV Bit 2 */
N#define ADC14_CTL0_DIV_0                         ((uint32_t)0x00000000)          /*!< /1 */
N#define ADC14_CTL0_DIV_1                         ((uint32_t)0x00400000)          /*!< /2 */
N#define ADC14_CTL0_DIV_2                         ((uint32_t)0x00800000)          /*!< /3 */
N#define ADC14_CTL0_DIV_3                         ((uint32_t)0x00C00000)          /*!< /4 */
N#define ADC14_CTL0_DIV_4                         ((uint32_t)0x01000000)          /*!< /5 */
N#define ADC14_CTL0_DIV_5                         ((uint32_t)0x01400000)          /*!< /6 */
N#define ADC14_CTL0_DIV_6                         ((uint32_t)0x01800000)          /*!< /7 */
N#define ADC14_CTL0_DIV_7                         ((uint32_t)0x01C00000)          /*!< /8 */
N#define ADC14_CTL0_DIV__1                        ((uint32_t)0x00000000)          /*!< /1 */
N#define ADC14_CTL0_DIV__2                        ((uint32_t)0x00400000)          /*!< /2 */
N#define ADC14_CTL0_DIV__3                        ((uint32_t)0x00800000)          /*!< /3 */
N#define ADC14_CTL0_DIV__4                        ((uint32_t)0x00C00000)          /*!< /4 */
N#define ADC14_CTL0_DIV__5                        ((uint32_t)0x01000000)          /*!< /5 */
N#define ADC14_CTL0_DIV__6                        ((uint32_t)0x01400000)          /*!< /6 */
N#define ADC14_CTL0_DIV__7                        ((uint32_t)0x01800000)          /*!< /7 */
N#define ADC14_CTL0_DIV__8                        ((uint32_t)0x01C00000)          /*!< /8 */
N/* ADC14_CTL0[ISSH] Bits */
N#define ADC14_CTL0_ISSH_OFS                      (25)                            /*!< ADC14ISSH Bit Offset */
N#define ADC14_CTL0_ISSH                          ((uint32_t)0x02000000)          /*!< ADC14 invert signal sample-and-hold */
N/* ADC14_CTL0[SHP] Bits */
N#define ADC14_CTL0_SHP_OFS                       (26)                            /*!< ADC14SHP Bit Offset */
N#define ADC14_CTL0_SHP                           ((uint32_t)0x04000000)          /*!< ADC14 sample-and-hold pulse-mode select */
N/* ADC14_CTL0[SHS] Bits */
N#define ADC14_CTL0_SHS_OFS                       (27)                            /*!< ADC14SHS Bit Offset */
N#define ADC14_CTL0_SHS_MASK                      ((uint32_t)0x38000000)          /*!< ADC14SHS Bit Mask */
N#define ADC14_CTL0_SHS0                          ((uint32_t)0x08000000)          /*!< SHS Bit 0 */
N#define ADC14_CTL0_SHS1                          ((uint32_t)0x10000000)          /*!< SHS Bit 1 */
N#define ADC14_CTL0_SHS2                          ((uint32_t)0x20000000)          /*!< SHS Bit 2 */
N#define ADC14_CTL0_SHS_0                         ((uint32_t)0x00000000)          /*!< ADC14SC bit */
N#define ADC14_CTL0_SHS_1                         ((uint32_t)0x08000000)          /*!< See device-specific data sheet for source */
N#define ADC14_CTL0_SHS_2                         ((uint32_t)0x10000000)          /*!< See device-specific data sheet for source */
N#define ADC14_CTL0_SHS_3                         ((uint32_t)0x18000000)          /*!< See device-specific data sheet for source */
N#define ADC14_CTL0_SHS_4                         ((uint32_t)0x20000000)          /*!< See device-specific data sheet for source */
N#define ADC14_CTL0_SHS_5                         ((uint32_t)0x28000000)          /*!< See device-specific data sheet for source */
N#define ADC14_CTL0_SHS_6                         ((uint32_t)0x30000000)          /*!< See device-specific data sheet for source */
N#define ADC14_CTL0_SHS_7                         ((uint32_t)0x38000000)          /*!< See device-specific data sheet for source */
N/* ADC14_CTL0[PDIV] Bits */
N#define ADC14_CTL0_PDIV_OFS                      (30)                            /*!< ADC14PDIV Bit Offset */
N#define ADC14_CTL0_PDIV_MASK                     ((uint32_t)0xC0000000)          /*!< ADC14PDIV Bit Mask */
N#define ADC14_CTL0_PDIV0                         ((uint32_t)0x40000000)          /*!< PDIV Bit 0 */
N#define ADC14_CTL0_PDIV1                         ((uint32_t)0x80000000)          /*!< PDIV Bit 1 */
N#define ADC14_CTL0_PDIV_0                        ((uint32_t)0x00000000)          /*!< Predivide by 1 */
N#define ADC14_CTL0_PDIV_1                        ((uint32_t)0x40000000)          /*!< Predivide by 4 */
N#define ADC14_CTL0_PDIV_2                        ((uint32_t)0x80000000)          /*!< Predivide by 32 */
N#define ADC14_CTL0_PDIV_3                        ((uint32_t)0xC0000000)          /*!< Predivide by 64 */
N#define ADC14_CTL0_PDIV__1                       ((uint32_t)0x00000000)          /*!< Predivide by 1 */
N#define ADC14_CTL0_PDIV__4                       ((uint32_t)0x40000000)          /*!< Predivide by 4 */
N#define ADC14_CTL0_PDIV__32                      ((uint32_t)0x80000000)          /*!< Predivide by 32 */
N#define ADC14_CTL0_PDIV__64                      ((uint32_t)0xC0000000)          /*!< Predivide by 64 */
N/* ADC14_CTL1[PWRMD] Bits */
N#define ADC14_CTL1_PWRMD_OFS                     ( 0)                            /*!< ADC14PWRMD Bit Offset */
N#define ADC14_CTL1_PWRMD_MASK                    ((uint32_t)0x00000003)          /*!< ADC14PWRMD Bit Mask */
N#define ADC14_CTL1_PWRMD0                        ((uint32_t)0x00000001)          /*!< PWRMD Bit 0 */
N#define ADC14_CTL1_PWRMD1                        ((uint32_t)0x00000002)          /*!< PWRMD Bit 1 */
N#define ADC14_CTL1_PWRMD_0                       ((uint32_t)0x00000000)          /*!< Regular power mode for use with any resolution setting. Sample rate can be  */
N                                                                                 /* up to 1 Msps. */
N#define ADC14_CTL1_PWRMD_2                       ((uint32_t)0x00000002)          /*!< Low-power mode for 12-bit, 10-bit, and 8-bit resolution settings. Sample  */
N                                                                                 /* rate must not exceed 200 ksps. */
N/* ADC14_CTL1[REFBURST] Bits */
N#define ADC14_CTL1_REFBURST_OFS                  ( 2)                            /*!< ADC14REFBURST Bit Offset */
N#define ADC14_CTL1_REFBURST                      ((uint32_t)0x00000004)          /*!< ADC14 reference buffer burst */
N/* ADC14_CTL1[DF] Bits */
N#define ADC14_CTL1_DF_OFS                        ( 3)                            /*!< ADC14DF Bit Offset */
N#define ADC14_CTL1_DF                            ((uint32_t)0x00000008)          /*!< ADC14 data read-back format */
N/* ADC14_CTL1[RES] Bits */
N#define ADC14_CTL1_RES_OFS                       ( 4)                            /*!< ADC14RES Bit Offset */
N#define ADC14_CTL1_RES_MASK                      ((uint32_t)0x00000030)          /*!< ADC14RES Bit Mask */
N#define ADC14_CTL1_RES0                          ((uint32_t)0x00000010)          /*!< RES Bit 0 */
N#define ADC14_CTL1_RES1                          ((uint32_t)0x00000020)          /*!< RES Bit 1 */
N#define ADC14_CTL1_RES_0                         ((uint32_t)0x00000000)          /*!< 8 bit (9 clock cycle conversion time) */
N#define ADC14_CTL1_RES_1                         ((uint32_t)0x00000010)          /*!< 10 bit (11 clock cycle conversion time) */
N#define ADC14_CTL1_RES_2                         ((uint32_t)0x00000020)          /*!< 12 bit (14 clock cycle conversion time) */
N#define ADC14_CTL1_RES_3                         ((uint32_t)0x00000030)          /*!< 14 bit (16 clock cycle conversion time) */
N#define ADC14_CTL1_RES__8BIT                     ((uint32_t)0x00000000)          /*!< 8 bit (9 clock cycle conversion time) */
N#define ADC14_CTL1_RES__10BIT                    ((uint32_t)0x00000010)          /*!< 10 bit (11 clock cycle conversion time) */
N#define ADC14_CTL1_RES__12BIT                    ((uint32_t)0x00000020)          /*!< 12 bit (14 clock cycle conversion time) */
N#define ADC14_CTL1_RES__14BIT                    ((uint32_t)0x00000030)          /*!< 14 bit (16 clock cycle conversion time) */
N/* ADC14_CTL1[CSTARTADD] Bits */
N#define ADC14_CTL1_CSTARTADD_OFS                 (16)                            /*!< ADC14CSTARTADD Bit Offset */
N#define ADC14_CTL1_CSTARTADD_MASK                ((uint32_t)0x001F0000)          /*!< ADC14CSTARTADD Bit Mask */
N/* ADC14_CTL1[BATMAP] Bits */
N#define ADC14_CTL1_BATMAP_OFS                    (22)                            /*!< ADC14BATMAP Bit Offset */
N#define ADC14_CTL1_BATMAP                        ((uint32_t)0x00400000)          /*!< Controls 1/2 AVCC ADC input channel selection */
N/* ADC14_CTL1[TCMAP] Bits */
N#define ADC14_CTL1_TCMAP_OFS                     (23)                            /*!< ADC14TCMAP Bit Offset */
N#define ADC14_CTL1_TCMAP                         ((uint32_t)0x00800000)          /*!< Controls temperature sensor ADC input channel selection */
N/* ADC14_CTL1[CH0MAP] Bits */
N#define ADC14_CTL1_CH0MAP_OFS                    (24)                            /*!< ADC14CH0MAP Bit Offset */
N#define ADC14_CTL1_CH0MAP                        ((uint32_t)0x01000000)          /*!< Controls internal channel 0 selection to ADC input channel MAX-2 */
N/* ADC14_CTL1[CH1MAP] Bits */
N#define ADC14_CTL1_CH1MAP_OFS                    (25)                            /*!< ADC14CH1MAP Bit Offset */
N#define ADC14_CTL1_CH1MAP                        ((uint32_t)0x02000000)          /*!< Controls internal channel 1 selection to ADC input channel MAX-3 */
N/* ADC14_CTL1[CH2MAP] Bits */
N#define ADC14_CTL1_CH2MAP_OFS                    (26)                            /*!< ADC14CH2MAP Bit Offset */
N#define ADC14_CTL1_CH2MAP                        ((uint32_t)0x04000000)          /*!< Controls internal channel 2 selection to ADC input channel MAX-4 */
N/* ADC14_CTL1[CH3MAP] Bits */
N#define ADC14_CTL1_CH3MAP_OFS                    (27)                            /*!< ADC14CH3MAP Bit Offset */
N#define ADC14_CTL1_CH3MAP                        ((uint32_t)0x08000000)          /*!< Controls internal channel 3 selection to ADC input channel MAX-5 */
N/* ADC14_LO0[LO0] Bits */
N#define ADC14_LO0_LO0_OFS                        ( 0)                            /*!< ADC14LO0 Bit Offset */
N#define ADC14_LO0_LO0_MASK                       ((uint32_t)0x0000FFFF)          /*!< ADC14LO0 Bit Mask */
N/* ADC14_HI0[HI0] Bits */
N#define ADC14_HI0_HI0_OFS                        ( 0)                            /*!< ADC14HI0 Bit Offset */
N#define ADC14_HI0_HI0_MASK                       ((uint32_t)0x0000FFFF)          /*!< ADC14HI0 Bit Mask */
N/* ADC14_LO1[LO1] Bits */
N#define ADC14_LO1_LO1_OFS                        ( 0)                            /*!< ADC14LO1 Bit Offset */
N#define ADC14_LO1_LO1_MASK                       ((uint32_t)0x0000FFFF)          /*!< ADC14LO1 Bit Mask */
N/* ADC14_HI1[HI1] Bits */
N#define ADC14_HI1_HI1_OFS                        ( 0)                            /*!< ADC14HI1 Bit Offset */
N#define ADC14_HI1_HI1_MASK                       ((uint32_t)0x0000FFFF)          /*!< ADC14HI1 Bit Mask */
N/* ADC14_MCTLN[INCH] Bits */
N#define ADC14_MCTLN_INCH_OFS                     ( 0)                            /*!< ADC14INCH Bit Offset */
N#define ADC14_MCTLN_INCH_MASK                    ((uint32_t)0x0000001F)          /*!< ADC14INCH Bit Mask */
N#define ADC14_MCTLN_INCH0                        ((uint32_t)0x00000001)          /*!< INCH Bit 0 */
N#define ADC14_MCTLN_INCH1                        ((uint32_t)0x00000002)          /*!< INCH Bit 1 */
N#define ADC14_MCTLN_INCH2                        ((uint32_t)0x00000004)          /*!< INCH Bit 2 */
N#define ADC14_MCTLN_INCH3                        ((uint32_t)0x00000008)          /*!< INCH Bit 3 */
N#define ADC14_MCTLN_INCH4                        ((uint32_t)0x00000010)          /*!< INCH Bit 4 */
N#define ADC14_MCTLN_INCH_0                       ((uint32_t)0x00000000)          /*!< If ADC14DIF = 0: A0; If ADC14DIF = 1: Ain+ = A0, Ain- = A1 */
N#define ADC14_MCTLN_INCH_1                       ((uint32_t)0x00000001)          /*!< If ADC14DIF = 0: A1; If ADC14DIF = 1: Ain+ = A0, Ain- = A1 */
N#define ADC14_MCTLN_INCH_2                       ((uint32_t)0x00000002)          /*!< If ADC14DIF = 0: A2; If ADC14DIF = 1: Ain+ = A2, Ain- = A3 */
N#define ADC14_MCTLN_INCH_3                       ((uint32_t)0x00000003)          /*!< If ADC14DIF = 0: A3; If ADC14DIF = 1: Ain+ = A2, Ain- = A3 */
N#define ADC14_MCTLN_INCH_4                       ((uint32_t)0x00000004)          /*!< If ADC14DIF = 0: A4; If ADC14DIF = 1: Ain+ = A4, Ain- = A5 */
N#define ADC14_MCTLN_INCH_5                       ((uint32_t)0x00000005)          /*!< If ADC14DIF = 0: A5; If ADC14DIF = 1: Ain+ = A4, Ain- = A5 */
N#define ADC14_MCTLN_INCH_6                       ((uint32_t)0x00000006)          /*!< If ADC14DIF = 0: A6; If ADC14DIF = 1: Ain+ = A6, Ain- = A7 */
N#define ADC14_MCTLN_INCH_7                       ((uint32_t)0x00000007)          /*!< If ADC14DIF = 0: A7; If ADC14DIF = 1: Ain+ = A6, Ain- = A7 */
N#define ADC14_MCTLN_INCH_8                       ((uint32_t)0x00000008)          /*!< If ADC14DIF = 0: A8; If ADC14DIF = 1: Ain+ = A8, Ain- = A9 */
N#define ADC14_MCTLN_INCH_9                       ((uint32_t)0x00000009)          /*!< If ADC14DIF = 0: A9; If ADC14DIF = 1: Ain+ = A8, Ain- = A9 */
N#define ADC14_MCTLN_INCH_10                      ((uint32_t)0x0000000A)          /*!< If ADC14DIF = 0: A10; If ADC14DIF = 1: Ain+ = A10, Ain- = A11 */
N#define ADC14_MCTLN_INCH_11                      ((uint32_t)0x0000000B)          /*!< If ADC14DIF = 0: A11; If ADC14DIF = 1: Ain+ = A10, Ain- = A11 */
N#define ADC14_MCTLN_INCH_12                      ((uint32_t)0x0000000C)          /*!< If ADC14DIF = 0: A12; If ADC14DIF = 1: Ain+ = A12, Ain- = A13 */
N#define ADC14_MCTLN_INCH_13                      ((uint32_t)0x0000000D)          /*!< If ADC14DIF = 0: A13; If ADC14DIF = 1: Ain+ = A12, Ain- = A13 */
N#define ADC14_MCTLN_INCH_14                      ((uint32_t)0x0000000E)          /*!< If ADC14DIF = 0: A14; If ADC14DIF = 1: Ain+ = A14, Ain- = A15 */
N#define ADC14_MCTLN_INCH_15                      ((uint32_t)0x0000000F)          /*!< If ADC14DIF = 0: A15; If ADC14DIF = 1: Ain+ = A14, Ain- = A15 */
N#define ADC14_MCTLN_INCH_16                      ((uint32_t)0x00000010)          /*!< If ADC14DIF = 0: A16; If ADC14DIF = 1: Ain+ = A16, Ain- = A17 */
N#define ADC14_MCTLN_INCH_17                      ((uint32_t)0x00000011)          /*!< If ADC14DIF = 0: A17; If ADC14DIF = 1: Ain+ = A16, Ain- = A17 */
N#define ADC14_MCTLN_INCH_18                      ((uint32_t)0x00000012)          /*!< If ADC14DIF = 0: A18; If ADC14DIF = 1: Ain+ = A18, Ain- = A19 */
N#define ADC14_MCTLN_INCH_19                      ((uint32_t)0x00000013)          /*!< If ADC14DIF = 0: A19; If ADC14DIF = 1: Ain+ = A18, Ain- = A19 */
N#define ADC14_MCTLN_INCH_20                      ((uint32_t)0x00000014)          /*!< If ADC14DIF = 0: A20; If ADC14DIF = 1: Ain+ = A20, Ain- = A21 */
N#define ADC14_MCTLN_INCH_21                      ((uint32_t)0x00000015)          /*!< If ADC14DIF = 0: A21; If ADC14DIF = 1: Ain+ = A20, Ain- = A21 */
N#define ADC14_MCTLN_INCH_22                      ((uint32_t)0x00000016)          /*!< If ADC14DIF = 0: A22; If ADC14DIF = 1: Ain+ = A22, Ain- = A23 */
N#define ADC14_MCTLN_INCH_23                      ((uint32_t)0x00000017)          /*!< If ADC14DIF = 0: A23; If ADC14DIF = 1: Ain+ = A22, Ain- = A23 */
N#define ADC14_MCTLN_INCH_24                      ((uint32_t)0x00000018)          /*!< If ADC14DIF = 0: A24; If ADC14DIF = 1: Ain+ = A24, Ain- = A25 */
N#define ADC14_MCTLN_INCH_25                      ((uint32_t)0x00000019)          /*!< If ADC14DIF = 0: A25; If ADC14DIF = 1: Ain+ = A24, Ain- = A25 */
N#define ADC14_MCTLN_INCH_26                      ((uint32_t)0x0000001A)          /*!< If ADC14DIF = 0: A26; If ADC14DIF = 1: Ain+ = A26, Ain- = A27 */
N#define ADC14_MCTLN_INCH_27                      ((uint32_t)0x0000001B)          /*!< If ADC14DIF = 0: A27; If ADC14DIF = 1: Ain+ = A26, Ain- = A27 */
N#define ADC14_MCTLN_INCH_28                      ((uint32_t)0x0000001C)          /*!< If ADC14DIF = 0: A28; If ADC14DIF = 1: Ain+ = A28, Ain- = A29 */
N#define ADC14_MCTLN_INCH_29                      ((uint32_t)0x0000001D)          /*!< If ADC14DIF = 0: A29; If ADC14DIF = 1: Ain+ = A28, Ain- = A29 */
N#define ADC14_MCTLN_INCH_30                      ((uint32_t)0x0000001E)          /*!< If ADC14DIF = 0: A30; If ADC14DIF = 1: Ain+ = A30, Ain- = A31 */
N#define ADC14_MCTLN_INCH_31                      ((uint32_t)0x0000001F)          /*!< If ADC14DIF = 0: A31; If ADC14DIF = 1: Ain+ = A30, Ain- = A31 */
N/* ADC14_MCTLN[EOS] Bits */
N#define ADC14_MCTLN_EOS_OFS                      ( 7)                            /*!< ADC14EOS Bit Offset */
N#define ADC14_MCTLN_EOS                          ((uint32_t)0x00000080)          /*!< End of sequence */
N/* ADC14_MCTLN[VRSEL] Bits */
N#define ADC14_MCTLN_VRSEL_OFS                    ( 8)                            /*!< ADC14VRSEL Bit Offset */
N#define ADC14_MCTLN_VRSEL_MASK                   ((uint32_t)0x00000F00)          /*!< ADC14VRSEL Bit Mask */
N#define ADC14_MCTLN_VRSEL0                       ((uint32_t)0x00000100)          /*!< VRSEL Bit 0 */
N#define ADC14_MCTLN_VRSEL1                       ((uint32_t)0x00000200)          /*!< VRSEL Bit 1 */
N#define ADC14_MCTLN_VRSEL2                       ((uint32_t)0x00000400)          /*!< VRSEL Bit 2 */
N#define ADC14_MCTLN_VRSEL3                       ((uint32_t)0x00000800)          /*!< VRSEL Bit 3 */
N#define ADC14_MCTLN_VRSEL_0                      ((uint32_t)0x00000000)          /*!< V(R+) = AVCC, V(R-) = AVSS */
N#define ADC14_MCTLN_VRSEL_1                      ((uint32_t)0x00000100)          /*!< V(R+) = VREF buffered, V(R-) = AVSS */
N#define ADC14_MCTLN_VRSEL_14                     ((uint32_t)0x00000E00)          /*!< V(R+) = VeREF+, V(R-) = VeREF- */
N#define ADC14_MCTLN_VRSEL_15                     ((uint32_t)0x00000F00)          /*!< V(R+) = VeREF+ buffered, V(R-) = VeREF */
N/* ADC14_MCTLN[DIF] Bits */
N#define ADC14_MCTLN_DIF_OFS                      (13)                            /*!< ADC14DIF Bit Offset */
N#define ADC14_MCTLN_DIF                          ((uint32_t)0x00002000)          /*!< Differential mode */
N/* ADC14_MCTLN[WINC] Bits */
N#define ADC14_MCTLN_WINC_OFS                     (14)                            /*!< ADC14WINC Bit Offset */
N#define ADC14_MCTLN_WINC                         ((uint32_t)0x00004000)          /*!< Comparator window enable */
N/* ADC14_MCTLN[WINCTH] Bits */
N#define ADC14_MCTLN_WINCTH_OFS                   (15)                            /*!< ADC14WINCTH Bit Offset */
N#define ADC14_MCTLN_WINCTH                       ((uint32_t)0x00008000)          /*!< Window comparator threshold register selection */
N/* ADC14_MEMN[CONVRES] Bits */
N#define ADC14_MEMN_CONVRES_OFS                   ( 0)                            /*!< Conversion_Results Bit Offset */
N#define ADC14_MEMN_CONVRES_MASK                  ((uint32_t)0x0000FFFF)          /*!< Conversion_Results Bit Mask */
N/* ADC14_IER0[IE0] Bits */
N#define ADC14_IER0_IE0_OFS                       ( 0)                            /*!< ADC14IE0 Bit Offset */
N#define ADC14_IER0_IE0                           ((uint32_t)0x00000001)          /*!< Interrupt enable */
N/* ADC14_IER0[IE1] Bits */
N#define ADC14_IER0_IE1_OFS                       ( 1)                            /*!< ADC14IE1 Bit Offset */
N#define ADC14_IER0_IE1                           ((uint32_t)0x00000002)          /*!< Interrupt enable */
N/* ADC14_IER0[IE2] Bits */
N#define ADC14_IER0_IE2_OFS                       ( 2)                            /*!< ADC14IE2 Bit Offset */
N#define ADC14_IER0_IE2                           ((uint32_t)0x00000004)          /*!< Interrupt enable */
N/* ADC14_IER0[IE3] Bits */
N#define ADC14_IER0_IE3_OFS                       ( 3)                            /*!< ADC14IE3 Bit Offset */
N#define ADC14_IER0_IE3                           ((uint32_t)0x00000008)          /*!< Interrupt enable */
N/* ADC14_IER0[IE4] Bits */
N#define ADC14_IER0_IE4_OFS                       ( 4)                            /*!< ADC14IE4 Bit Offset */
N#define ADC14_IER0_IE4                           ((uint32_t)0x00000010)          /*!< Interrupt enable */
N/* ADC14_IER0[IE5] Bits */
N#define ADC14_IER0_IE5_OFS                       ( 5)                            /*!< ADC14IE5 Bit Offset */
N#define ADC14_IER0_IE5                           ((uint32_t)0x00000020)          /*!< Interrupt enable */
N/* ADC14_IER0[IE6] Bits */
N#define ADC14_IER0_IE6_OFS                       ( 6)                            /*!< ADC14IE6 Bit Offset */
N#define ADC14_IER0_IE6                           ((uint32_t)0x00000040)          /*!< Interrupt enable */
N/* ADC14_IER0[IE7] Bits */
N#define ADC14_IER0_IE7_OFS                       ( 7)                            /*!< ADC14IE7 Bit Offset */
N#define ADC14_IER0_IE7                           ((uint32_t)0x00000080)          /*!< Interrupt enable */
N/* ADC14_IER0[IE8] Bits */
N#define ADC14_IER0_IE8_OFS                       ( 8)                            /*!< ADC14IE8 Bit Offset */
N#define ADC14_IER0_IE8                           ((uint32_t)0x00000100)          /*!< Interrupt enable */
N/* ADC14_IER0[IE9] Bits */
N#define ADC14_IER0_IE9_OFS                       ( 9)                            /*!< ADC14IE9 Bit Offset */
N#define ADC14_IER0_IE9                           ((uint32_t)0x00000200)          /*!< Interrupt enable */
N/* ADC14_IER0[IE10] Bits */
N#define ADC14_IER0_IE10_OFS                      (10)                            /*!< ADC14IE10 Bit Offset */
N#define ADC14_IER0_IE10                          ((uint32_t)0x00000400)          /*!< Interrupt enable */
N/* ADC14_IER0[IE11] Bits */
N#define ADC14_IER0_IE11_OFS                      (11)                            /*!< ADC14IE11 Bit Offset */
N#define ADC14_IER0_IE11                          ((uint32_t)0x00000800)          /*!< Interrupt enable */
N/* ADC14_IER0[IE12] Bits */
N#define ADC14_IER0_IE12_OFS                      (12)                            /*!< ADC14IE12 Bit Offset */
N#define ADC14_IER0_IE12                          ((uint32_t)0x00001000)          /*!< Interrupt enable */
N/* ADC14_IER0[IE13] Bits */
N#define ADC14_IER0_IE13_OFS                      (13)                            /*!< ADC14IE13 Bit Offset */
N#define ADC14_IER0_IE13                          ((uint32_t)0x00002000)          /*!< Interrupt enable */
N/* ADC14_IER0[IE14] Bits */
N#define ADC14_IER0_IE14_OFS                      (14)                            /*!< ADC14IE14 Bit Offset */
N#define ADC14_IER0_IE14                          ((uint32_t)0x00004000)          /*!< Interrupt enable */
N/* ADC14_IER0[IE15] Bits */
N#define ADC14_IER0_IE15_OFS                      (15)                            /*!< ADC14IE15 Bit Offset */
N#define ADC14_IER0_IE15                          ((uint32_t)0x00008000)          /*!< Interrupt enable */
N/* ADC14_IER0[IE16] Bits */
N#define ADC14_IER0_IE16_OFS                      (16)                            /*!< ADC14IE16 Bit Offset */
N#define ADC14_IER0_IE16                          ((uint32_t)0x00010000)          /*!< Interrupt enable */
N/* ADC14_IER0[IE17] Bits */
N#define ADC14_IER0_IE17_OFS                      (17)                            /*!< ADC14IE17 Bit Offset */
N#define ADC14_IER0_IE17                          ((uint32_t)0x00020000)          /*!< Interrupt enable */
N/* ADC14_IER0[IE19] Bits */
N#define ADC14_IER0_IE19_OFS                      (19)                            /*!< ADC14IE19 Bit Offset */
N#define ADC14_IER0_IE19                          ((uint32_t)0x00080000)          /*!< Interrupt enable */
N/* ADC14_IER0[IE18] Bits */
N#define ADC14_IER0_IE18_OFS                      (18)                            /*!< ADC14IE18 Bit Offset */
N#define ADC14_IER0_IE18                          ((uint32_t)0x00040000)          /*!< Interrupt enable */
N/* ADC14_IER0[IE20] Bits */
N#define ADC14_IER0_IE20_OFS                      (20)                            /*!< ADC14IE20 Bit Offset */
N#define ADC14_IER0_IE20                          ((uint32_t)0x00100000)          /*!< Interrupt enable */
N/* ADC14_IER0[IE21] Bits */
N#define ADC14_IER0_IE21_OFS                      (21)                            /*!< ADC14IE21 Bit Offset */
N#define ADC14_IER0_IE21                          ((uint32_t)0x00200000)          /*!< Interrupt enable */
N/* ADC14_IER0[IE22] Bits */
N#define ADC14_IER0_IE22_OFS                      (22)                            /*!< ADC14IE22 Bit Offset */
N#define ADC14_IER0_IE22                          ((uint32_t)0x00400000)          /*!< Interrupt enable */
N/* ADC14_IER0[IE23] Bits */
N#define ADC14_IER0_IE23_OFS                      (23)                            /*!< ADC14IE23 Bit Offset */
N#define ADC14_IER0_IE23                          ((uint32_t)0x00800000)          /*!< Interrupt enable */
N/* ADC14_IER0[IE24] Bits */
N#define ADC14_IER0_IE24_OFS                      (24)                            /*!< ADC14IE24 Bit Offset */
N#define ADC14_IER0_IE24                          ((uint32_t)0x01000000)          /*!< Interrupt enable */
N/* ADC14_IER0[IE25] Bits */
N#define ADC14_IER0_IE25_OFS                      (25)                            /*!< ADC14IE25 Bit Offset */
N#define ADC14_IER0_IE25                          ((uint32_t)0x02000000)          /*!< Interrupt enable */
N/* ADC14_IER0[IE26] Bits */
N#define ADC14_IER0_IE26_OFS                      (26)                            /*!< ADC14IE26 Bit Offset */
N#define ADC14_IER0_IE26                          ((uint32_t)0x04000000)          /*!< Interrupt enable */
N/* ADC14_IER0[IE27] Bits */
N#define ADC14_IER0_IE27_OFS                      (27)                            /*!< ADC14IE27 Bit Offset */
N#define ADC14_IER0_IE27                          ((uint32_t)0x08000000)          /*!< Interrupt enable */
N/* ADC14_IER0[IE28] Bits */
N#define ADC14_IER0_IE28_OFS                      (28)                            /*!< ADC14IE28 Bit Offset */
N#define ADC14_IER0_IE28                          ((uint32_t)0x10000000)          /*!< Interrupt enable */
N/* ADC14_IER0[IE29] Bits */
N#define ADC14_IER0_IE29_OFS                      (29)                            /*!< ADC14IE29 Bit Offset */
N#define ADC14_IER0_IE29                          ((uint32_t)0x20000000)          /*!< Interrupt enable */
N/* ADC14_IER0[IE30] Bits */
N#define ADC14_IER0_IE30_OFS                      (30)                            /*!< ADC14IE30 Bit Offset */
N#define ADC14_IER0_IE30                          ((uint32_t)0x40000000)          /*!< Interrupt enable */
N/* ADC14_IER0[IE31] Bits */
N#define ADC14_IER0_IE31_OFS                      (31)                            /*!< ADC14IE31 Bit Offset */
N#define ADC14_IER0_IE31                          ((uint32_t)0x80000000)          /*!< Interrupt enable */
N/* ADC14_IER1[INIE] Bits */
N#define ADC14_IER1_INIE_OFS                      ( 1)                            /*!< ADC14INIE Bit Offset */
N#define ADC14_IER1_INIE                          ((uint32_t)0x00000002)          /*!< Interrupt enable for ADC14MEMx within comparator window */
N/* ADC14_IER1[LOIE] Bits */
N#define ADC14_IER1_LOIE_OFS                      ( 2)                            /*!< ADC14LOIE Bit Offset */
N#define ADC14_IER1_LOIE                          ((uint32_t)0x00000004)          /*!< Interrupt enable for ADC14MEMx below comparator window */
N/* ADC14_IER1[HIIE] Bits */
N#define ADC14_IER1_HIIE_OFS                      ( 3)                            /*!< ADC14HIIE Bit Offset */
N#define ADC14_IER1_HIIE                          ((uint32_t)0x00000008)          /*!< Interrupt enable for ADC14MEMx above comparator window */
N/* ADC14_IER1[OVIE] Bits */
N#define ADC14_IER1_OVIE_OFS                      ( 4)                            /*!< ADC14OVIE Bit Offset */
N#define ADC14_IER1_OVIE                          ((uint32_t)0x00000010)          /*!< ADC14MEMx overflow-interrupt enable */
N/* ADC14_IER1[TOVIE] Bits */
N#define ADC14_IER1_TOVIE_OFS                     ( 5)                            /*!< ADC14TOVIE Bit Offset */
N#define ADC14_IER1_TOVIE                         ((uint32_t)0x00000020)          /*!< ADC14 conversion-time-overflow interrupt enable */
N/* ADC14_IER1[RDYIE] Bits */
N#define ADC14_IER1_RDYIE_OFS                     ( 6)                            /*!< ADC14RDYIE Bit Offset */
N#define ADC14_IER1_RDYIE                         ((uint32_t)0x00000040)          /*!< ADC14 local buffered reference ready interrupt enable */
N/* ADC14_IFGR0[IFG0] Bits */
N#define ADC14_IFGR0_IFG0_OFS                     ( 0)                            /*!< ADC14IFG0 Bit Offset */
N#define ADC14_IFGR0_IFG0                         ((uint32_t)0x00000001)          /*!< ADC14MEM0 interrupt flag */
N/* ADC14_IFGR0[IFG1] Bits */
N#define ADC14_IFGR0_IFG1_OFS                     ( 1)                            /*!< ADC14IFG1 Bit Offset */
N#define ADC14_IFGR0_IFG1                         ((uint32_t)0x00000002)          /*!< ADC14MEM1 interrupt flag */
N/* ADC14_IFGR0[IFG2] Bits */
N#define ADC14_IFGR0_IFG2_OFS                     ( 2)                            /*!< ADC14IFG2 Bit Offset */
N#define ADC14_IFGR0_IFG2                         ((uint32_t)0x00000004)          /*!< ADC14MEM2 interrupt flag */
N/* ADC14_IFGR0[IFG3] Bits */
N#define ADC14_IFGR0_IFG3_OFS                     ( 3)                            /*!< ADC14IFG3 Bit Offset */
N#define ADC14_IFGR0_IFG3                         ((uint32_t)0x00000008)          /*!< ADC14MEM3 interrupt flag */
N/* ADC14_IFGR0[IFG4] Bits */
N#define ADC14_IFGR0_IFG4_OFS                     ( 4)                            /*!< ADC14IFG4 Bit Offset */
N#define ADC14_IFGR0_IFG4                         ((uint32_t)0x00000010)          /*!< ADC14MEM4 interrupt flag */
N/* ADC14_IFGR0[IFG5] Bits */
N#define ADC14_IFGR0_IFG5_OFS                     ( 5)                            /*!< ADC14IFG5 Bit Offset */
N#define ADC14_IFGR0_IFG5                         ((uint32_t)0x00000020)          /*!< ADC14MEM5 interrupt flag */
N/* ADC14_IFGR0[IFG6] Bits */
N#define ADC14_IFGR0_IFG6_OFS                     ( 6)                            /*!< ADC14IFG6 Bit Offset */
N#define ADC14_IFGR0_IFG6                         ((uint32_t)0x00000040)          /*!< ADC14MEM6 interrupt flag */
N/* ADC14_IFGR0[IFG7] Bits */
N#define ADC14_IFGR0_IFG7_OFS                     ( 7)                            /*!< ADC14IFG7 Bit Offset */
N#define ADC14_IFGR0_IFG7                         ((uint32_t)0x00000080)          /*!< ADC14MEM7 interrupt flag */
N/* ADC14_IFGR0[IFG8] Bits */
N#define ADC14_IFGR0_IFG8_OFS                     ( 8)                            /*!< ADC14IFG8 Bit Offset */
N#define ADC14_IFGR0_IFG8                         ((uint32_t)0x00000100)          /*!< ADC14MEM8 interrupt flag */
N/* ADC14_IFGR0[IFG9] Bits */
N#define ADC14_IFGR0_IFG9_OFS                     ( 9)                            /*!< ADC14IFG9 Bit Offset */
N#define ADC14_IFGR0_IFG9                         ((uint32_t)0x00000200)          /*!< ADC14MEM9 interrupt flag */
N/* ADC14_IFGR0[IFG10] Bits */
N#define ADC14_IFGR0_IFG10_OFS                    (10)                            /*!< ADC14IFG10 Bit Offset */
N#define ADC14_IFGR0_IFG10                        ((uint32_t)0x00000400)          /*!< ADC14MEM10 interrupt flag */
N/* ADC14_IFGR0[IFG11] Bits */
N#define ADC14_IFGR0_IFG11_OFS                    (11)                            /*!< ADC14IFG11 Bit Offset */
N#define ADC14_IFGR0_IFG11                        ((uint32_t)0x00000800)          /*!< ADC14MEM11 interrupt flag */
N/* ADC14_IFGR0[IFG12] Bits */
N#define ADC14_IFGR0_IFG12_OFS                    (12)                            /*!< ADC14IFG12 Bit Offset */
N#define ADC14_IFGR0_IFG12                        ((uint32_t)0x00001000)          /*!< ADC14MEM12 interrupt flag */
N/* ADC14_IFGR0[IFG13] Bits */
N#define ADC14_IFGR0_IFG13_OFS                    (13)                            /*!< ADC14IFG13 Bit Offset */
N#define ADC14_IFGR0_IFG13                        ((uint32_t)0x00002000)          /*!< ADC14MEM13 interrupt flag */
N/* ADC14_IFGR0[IFG14] Bits */
N#define ADC14_IFGR0_IFG14_OFS                    (14)                            /*!< ADC14IFG14 Bit Offset */
N#define ADC14_IFGR0_IFG14                        ((uint32_t)0x00004000)          /*!< ADC14MEM14 interrupt flag */
N/* ADC14_IFGR0[IFG15] Bits */
N#define ADC14_IFGR0_IFG15_OFS                    (15)                            /*!< ADC14IFG15 Bit Offset */
N#define ADC14_IFGR0_IFG15                        ((uint32_t)0x00008000)          /*!< ADC14MEM15 interrupt flag */
N/* ADC14_IFGR0[IFG16] Bits */
N#define ADC14_IFGR0_IFG16_OFS                    (16)                            /*!< ADC14IFG16 Bit Offset */
N#define ADC14_IFGR0_IFG16                        ((uint32_t)0x00010000)          /*!< ADC14MEM16 interrupt flag */
N/* ADC14_IFGR0[IFG17] Bits */
N#define ADC14_IFGR0_IFG17_OFS                    (17)                            /*!< ADC14IFG17 Bit Offset */
N#define ADC14_IFGR0_IFG17                        ((uint32_t)0x00020000)          /*!< ADC14MEM17 interrupt flag */
N/* ADC14_IFGR0[IFG18] Bits */
N#define ADC14_IFGR0_IFG18_OFS                    (18)                            /*!< ADC14IFG18 Bit Offset */
N#define ADC14_IFGR0_IFG18                        ((uint32_t)0x00040000)          /*!< ADC14MEM18 interrupt flag */
N/* ADC14_IFGR0[IFG19] Bits */
N#define ADC14_IFGR0_IFG19_OFS                    (19)                            /*!< ADC14IFG19 Bit Offset */
N#define ADC14_IFGR0_IFG19                        ((uint32_t)0x00080000)          /*!< ADC14MEM19 interrupt flag */
N/* ADC14_IFGR0[IFG20] Bits */
N#define ADC14_IFGR0_IFG20_OFS                    (20)                            /*!< ADC14IFG20 Bit Offset */
N#define ADC14_IFGR0_IFG20                        ((uint32_t)0x00100000)          /*!< ADC14MEM20 interrupt flag */
N/* ADC14_IFGR0[IFG21] Bits */
N#define ADC14_IFGR0_IFG21_OFS                    (21)                            /*!< ADC14IFG21 Bit Offset */
N#define ADC14_IFGR0_IFG21                        ((uint32_t)0x00200000)          /*!< ADC14MEM21 interrupt flag */
N/* ADC14_IFGR0[IFG22] Bits */
N#define ADC14_IFGR0_IFG22_OFS                    (22)                            /*!< ADC14IFG22 Bit Offset */
N#define ADC14_IFGR0_IFG22                        ((uint32_t)0x00400000)          /*!< ADC14MEM22 interrupt flag */
N/* ADC14_IFGR0[IFG23] Bits */
N#define ADC14_IFGR0_IFG23_OFS                    (23)                            /*!< ADC14IFG23 Bit Offset */
N#define ADC14_IFGR0_IFG23                        ((uint32_t)0x00800000)          /*!< ADC14MEM23 interrupt flag */
N/* ADC14_IFGR0[IFG24] Bits */
N#define ADC14_IFGR0_IFG24_OFS                    (24)                            /*!< ADC14IFG24 Bit Offset */
N#define ADC14_IFGR0_IFG24                        ((uint32_t)0x01000000)          /*!< ADC14MEM24 interrupt flag */
N/* ADC14_IFGR0[IFG25] Bits */
N#define ADC14_IFGR0_IFG25_OFS                    (25)                            /*!< ADC14IFG25 Bit Offset */
N#define ADC14_IFGR0_IFG25                        ((uint32_t)0x02000000)          /*!< ADC14MEM25 interrupt flag */
N/* ADC14_IFGR0[IFG26] Bits */
N#define ADC14_IFGR0_IFG26_OFS                    (26)                            /*!< ADC14IFG26 Bit Offset */
N#define ADC14_IFGR0_IFG26                        ((uint32_t)0x04000000)          /*!< ADC14MEM26 interrupt flag */
N/* ADC14_IFGR0[IFG27] Bits */
N#define ADC14_IFGR0_IFG27_OFS                    (27)                            /*!< ADC14IFG27 Bit Offset */
N#define ADC14_IFGR0_IFG27                        ((uint32_t)0x08000000)          /*!< ADC14MEM27 interrupt flag */
N/* ADC14_IFGR0[IFG28] Bits */
N#define ADC14_IFGR0_IFG28_OFS                    (28)                            /*!< ADC14IFG28 Bit Offset */
N#define ADC14_IFGR0_IFG28                        ((uint32_t)0x10000000)          /*!< ADC14MEM28 interrupt flag */
N/* ADC14_IFGR0[IFG29] Bits */
N#define ADC14_IFGR0_IFG29_OFS                    (29)                            /*!< ADC14IFG29 Bit Offset */
N#define ADC14_IFGR0_IFG29                        ((uint32_t)0x20000000)          /*!< ADC14MEM29 interrupt flag */
N/* ADC14_IFGR0[IFG30] Bits */
N#define ADC14_IFGR0_IFG30_OFS                    (30)                            /*!< ADC14IFG30 Bit Offset */
N#define ADC14_IFGR0_IFG30                        ((uint32_t)0x40000000)          /*!< ADC14MEM30 interrupt flag */
N/* ADC14_IFGR0[IFG31] Bits */
N#define ADC14_IFGR0_IFG31_OFS                    (31)                            /*!< ADC14IFG31 Bit Offset */
N#define ADC14_IFGR0_IFG31                        ((uint32_t)0x80000000)          /*!< ADC14MEM31 interrupt flag */
N/* ADC14_IFGR1[INIFG] Bits */
N#define ADC14_IFGR1_INIFG_OFS                    ( 1)                            /*!< ADC14INIFG Bit Offset */
N#define ADC14_IFGR1_INIFG                        ((uint32_t)0x00000002)          /*!< Interrupt flag for ADC14MEMx within comparator window */
N/* ADC14_IFGR1[LOIFG] Bits */
N#define ADC14_IFGR1_LOIFG_OFS                    ( 2)                            /*!< ADC14LOIFG Bit Offset */
N#define ADC14_IFGR1_LOIFG                        ((uint32_t)0x00000004)          /*!< Interrupt flag for ADC14MEMx below comparator window */
N/* ADC14_IFGR1[HIIFG] Bits */
N#define ADC14_IFGR1_HIIFG_OFS                    ( 3)                            /*!< ADC14HIIFG Bit Offset */
N#define ADC14_IFGR1_HIIFG                        ((uint32_t)0x00000008)          /*!< Interrupt flag for ADC14MEMx above comparator window */
N/* ADC14_IFGR1[OVIFG] Bits */
N#define ADC14_IFGR1_OVIFG_OFS                    ( 4)                            /*!< ADC14OVIFG Bit Offset */
N#define ADC14_IFGR1_OVIFG                        ((uint32_t)0x00000010)          /*!< ADC14MEMx overflow interrupt flag */
N/* ADC14_IFGR1[TOVIFG] Bits */
N#define ADC14_IFGR1_TOVIFG_OFS                   ( 5)                            /*!< ADC14TOVIFG Bit Offset */
N#define ADC14_IFGR1_TOVIFG                       ((uint32_t)0x00000020)          /*!< ADC14 conversion time overflow interrupt flag */
N/* ADC14_IFGR1[RDYIFG] Bits */
N#define ADC14_IFGR1_RDYIFG_OFS                   ( 6)                            /*!< ADC14RDYIFG Bit Offset */
N#define ADC14_IFGR1_RDYIFG                       ((uint32_t)0x00000040)          /*!< ADC14 local buffered reference ready interrupt flag */
N/* ADC14_CLRIFGR0[CLRIFG0] Bits */
N#define ADC14_CLRIFGR0_CLRIFG0_OFS               ( 0)                            /*!< CLRADC14IFG0 Bit Offset */
N#define ADC14_CLRIFGR0_CLRIFG0                   ((uint32_t)0x00000001)          /*!< clear ADC14IFG0 */
N/* ADC14_CLRIFGR0[CLRIFG1] Bits */
N#define ADC14_CLRIFGR0_CLRIFG1_OFS               ( 1)                            /*!< CLRADC14IFG1 Bit Offset */
N#define ADC14_CLRIFGR0_CLRIFG1                   ((uint32_t)0x00000002)          /*!< clear ADC14IFG1 */
N/* ADC14_CLRIFGR0[CLRIFG2] Bits */
N#define ADC14_CLRIFGR0_CLRIFG2_OFS               ( 2)                            /*!< CLRADC14IFG2 Bit Offset */
N#define ADC14_CLRIFGR0_CLRIFG2                   ((uint32_t)0x00000004)          /*!< clear ADC14IFG2 */
N/* ADC14_CLRIFGR0[CLRIFG3] Bits */
N#define ADC14_CLRIFGR0_CLRIFG3_OFS               ( 3)                            /*!< CLRADC14IFG3 Bit Offset */
N#define ADC14_CLRIFGR0_CLRIFG3                   ((uint32_t)0x00000008)          /*!< clear ADC14IFG3 */
N/* ADC14_CLRIFGR0[CLRIFG4] Bits */
N#define ADC14_CLRIFGR0_CLRIFG4_OFS               ( 4)                            /*!< CLRADC14IFG4 Bit Offset */
N#define ADC14_CLRIFGR0_CLRIFG4                   ((uint32_t)0x00000010)          /*!< clear ADC14IFG4 */
N/* ADC14_CLRIFGR0[CLRIFG5] Bits */
N#define ADC14_CLRIFGR0_CLRIFG5_OFS               ( 5)                            /*!< CLRADC14IFG5 Bit Offset */
N#define ADC14_CLRIFGR0_CLRIFG5                   ((uint32_t)0x00000020)          /*!< clear ADC14IFG5 */
N/* ADC14_CLRIFGR0[CLRIFG6] Bits */
N#define ADC14_CLRIFGR0_CLRIFG6_OFS               ( 6)                            /*!< CLRADC14IFG6 Bit Offset */
N#define ADC14_CLRIFGR0_CLRIFG6                   ((uint32_t)0x00000040)          /*!< clear ADC14IFG6 */
N/* ADC14_CLRIFGR0[CLRIFG7] Bits */
N#define ADC14_CLRIFGR0_CLRIFG7_OFS               ( 7)                            /*!< CLRADC14IFG7 Bit Offset */
N#define ADC14_CLRIFGR0_CLRIFG7                   ((uint32_t)0x00000080)          /*!< clear ADC14IFG7 */
N/* ADC14_CLRIFGR0[CLRIFG8] Bits */
N#define ADC14_CLRIFGR0_CLRIFG8_OFS               ( 8)                            /*!< CLRADC14IFG8 Bit Offset */
N#define ADC14_CLRIFGR0_CLRIFG8                   ((uint32_t)0x00000100)          /*!< clear ADC14IFG8 */
N/* ADC14_CLRIFGR0[CLRIFG9] Bits */
N#define ADC14_CLRIFGR0_CLRIFG9_OFS               ( 9)                            /*!< CLRADC14IFG9 Bit Offset */
N#define ADC14_CLRIFGR0_CLRIFG9                   ((uint32_t)0x00000200)          /*!< clear ADC14IFG9 */
N/* ADC14_CLRIFGR0[CLRIFG10] Bits */
N#define ADC14_CLRIFGR0_CLRIFG10_OFS              (10)                            /*!< CLRADC14IFG10 Bit Offset */
N#define ADC14_CLRIFGR0_CLRIFG10                  ((uint32_t)0x00000400)          /*!< clear ADC14IFG10 */
N/* ADC14_CLRIFGR0[CLRIFG11] Bits */
N#define ADC14_CLRIFGR0_CLRIFG11_OFS              (11)                            /*!< CLRADC14IFG11 Bit Offset */
N#define ADC14_CLRIFGR0_CLRIFG11                  ((uint32_t)0x00000800)          /*!< clear ADC14IFG11 */
N/* ADC14_CLRIFGR0[CLRIFG12] Bits */
N#define ADC14_CLRIFGR0_CLRIFG12_OFS              (12)                            /*!< CLRADC14IFG12 Bit Offset */
N#define ADC14_CLRIFGR0_CLRIFG12                  ((uint32_t)0x00001000)          /*!< clear ADC14IFG12 */
N/* ADC14_CLRIFGR0[CLRIFG13] Bits */
N#define ADC14_CLRIFGR0_CLRIFG13_OFS              (13)                            /*!< CLRADC14IFG13 Bit Offset */
N#define ADC14_CLRIFGR0_CLRIFG13                  ((uint32_t)0x00002000)          /*!< clear ADC14IFG13 */
N/* ADC14_CLRIFGR0[CLRIFG14] Bits */
N#define ADC14_CLRIFGR0_CLRIFG14_OFS              (14)                            /*!< CLRADC14IFG14 Bit Offset */
N#define ADC14_CLRIFGR0_CLRIFG14                  ((uint32_t)0x00004000)          /*!< clear ADC14IFG14 */
N/* ADC14_CLRIFGR0[CLRIFG15] Bits */
N#define ADC14_CLRIFGR0_CLRIFG15_OFS              (15)                            /*!< CLRADC14IFG15 Bit Offset */
N#define ADC14_CLRIFGR0_CLRIFG15                  ((uint32_t)0x00008000)          /*!< clear ADC14IFG15 */
N/* ADC14_CLRIFGR0[CLRIFG16] Bits */
N#define ADC14_CLRIFGR0_CLRIFG16_OFS              (16)                            /*!< CLRADC14IFG16 Bit Offset */
N#define ADC14_CLRIFGR0_CLRIFG16                  ((uint32_t)0x00010000)          /*!< clear ADC14IFG16 */
N/* ADC14_CLRIFGR0[CLRIFG17] Bits */
N#define ADC14_CLRIFGR0_CLRIFG17_OFS              (17)                            /*!< CLRADC14IFG17 Bit Offset */
N#define ADC14_CLRIFGR0_CLRIFG17                  ((uint32_t)0x00020000)          /*!< clear ADC14IFG17 */
N/* ADC14_CLRIFGR0[CLRIFG18] Bits */
N#define ADC14_CLRIFGR0_CLRIFG18_OFS              (18)                            /*!< CLRADC14IFG18 Bit Offset */
N#define ADC14_CLRIFGR0_CLRIFG18                  ((uint32_t)0x00040000)          /*!< clear ADC14IFG18 */
N/* ADC14_CLRIFGR0[CLRIFG19] Bits */
N#define ADC14_CLRIFGR0_CLRIFG19_OFS              (19)                            /*!< CLRADC14IFG19 Bit Offset */
N#define ADC14_CLRIFGR0_CLRIFG19                  ((uint32_t)0x00080000)          /*!< clear ADC14IFG19 */
N/* ADC14_CLRIFGR0[CLRIFG20] Bits */
N#define ADC14_CLRIFGR0_CLRIFG20_OFS              (20)                            /*!< CLRADC14IFG20 Bit Offset */
N#define ADC14_CLRIFGR0_CLRIFG20                  ((uint32_t)0x00100000)          /*!< clear ADC14IFG20 */
N/* ADC14_CLRIFGR0[CLRIFG21] Bits */
N#define ADC14_CLRIFGR0_CLRIFG21_OFS              (21)                            /*!< CLRADC14IFG21 Bit Offset */
N#define ADC14_CLRIFGR0_CLRIFG21                  ((uint32_t)0x00200000)          /*!< clear ADC14IFG21 */
N/* ADC14_CLRIFGR0[CLRIFG22] Bits */
N#define ADC14_CLRIFGR0_CLRIFG22_OFS              (22)                            /*!< CLRADC14IFG22 Bit Offset */
N#define ADC14_CLRIFGR0_CLRIFG22                  ((uint32_t)0x00400000)          /*!< clear ADC14IFG22 */
N/* ADC14_CLRIFGR0[CLRIFG23] Bits */
N#define ADC14_CLRIFGR0_CLRIFG23_OFS              (23)                            /*!< CLRADC14IFG23 Bit Offset */
N#define ADC14_CLRIFGR0_CLRIFG23                  ((uint32_t)0x00800000)          /*!< clear ADC14IFG23 */
N/* ADC14_CLRIFGR0[CLRIFG24] Bits */
N#define ADC14_CLRIFGR0_CLRIFG24_OFS              (24)                            /*!< CLRADC14IFG24 Bit Offset */
N#define ADC14_CLRIFGR0_CLRIFG24                  ((uint32_t)0x01000000)          /*!< clear ADC14IFG24 */
N/* ADC14_CLRIFGR0[CLRIFG25] Bits */
N#define ADC14_CLRIFGR0_CLRIFG25_OFS              (25)                            /*!< CLRADC14IFG25 Bit Offset */
N#define ADC14_CLRIFGR0_CLRIFG25                  ((uint32_t)0x02000000)          /*!< clear ADC14IFG25 */
N/* ADC14_CLRIFGR0[CLRIFG26] Bits */
N#define ADC14_CLRIFGR0_CLRIFG26_OFS              (26)                            /*!< CLRADC14IFG26 Bit Offset */
N#define ADC14_CLRIFGR0_CLRIFG26                  ((uint32_t)0x04000000)          /*!< clear ADC14IFG26 */
N/* ADC14_CLRIFGR0[CLRIFG27] Bits */
N#define ADC14_CLRIFGR0_CLRIFG27_OFS              (27)                            /*!< CLRADC14IFG27 Bit Offset */
N#define ADC14_CLRIFGR0_CLRIFG27                  ((uint32_t)0x08000000)          /*!< clear ADC14IFG27 */
N/* ADC14_CLRIFGR0[CLRIFG28] Bits */
N#define ADC14_CLRIFGR0_CLRIFG28_OFS              (28)                            /*!< CLRADC14IFG28 Bit Offset */
N#define ADC14_CLRIFGR0_CLRIFG28                  ((uint32_t)0x10000000)          /*!< clear ADC14IFG28 */
N/* ADC14_CLRIFGR0[CLRIFG29] Bits */
N#define ADC14_CLRIFGR0_CLRIFG29_OFS              (29)                            /*!< CLRADC14IFG29 Bit Offset */
N#define ADC14_CLRIFGR0_CLRIFG29                  ((uint32_t)0x20000000)          /*!< clear ADC14IFG29 */
N/* ADC14_CLRIFGR0[CLRIFG30] Bits */
N#define ADC14_CLRIFGR0_CLRIFG30_OFS              (30)                            /*!< CLRADC14IFG30 Bit Offset */
N#define ADC14_CLRIFGR0_CLRIFG30                  ((uint32_t)0x40000000)          /*!< clear ADC14IFG30 */
N/* ADC14_CLRIFGR0[CLRIFG31] Bits */
N#define ADC14_CLRIFGR0_CLRIFG31_OFS              (31)                            /*!< CLRADC14IFG31 Bit Offset */
N#define ADC14_CLRIFGR0_CLRIFG31                  ((uint32_t)0x80000000)          /*!< clear ADC14IFG31 */
N/* ADC14_CLRIFGR1[CLRINIFG] Bits */
N#define ADC14_CLRIFGR1_CLRINIFG_OFS              ( 1)                            /*!< CLRADC14INIFG Bit Offset */
N#define ADC14_CLRIFGR1_CLRINIFG                  ((uint32_t)0x00000002)          /*!< clear ADC14INIFG */
N/* ADC14_CLRIFGR1[CLRLOIFG] Bits */
N#define ADC14_CLRIFGR1_CLRLOIFG_OFS              ( 2)                            /*!< CLRADC14LOIFG Bit Offset */
N#define ADC14_CLRIFGR1_CLRLOIFG                  ((uint32_t)0x00000004)          /*!< clear ADC14LOIFG */
N/* ADC14_CLRIFGR1[CLRHIIFG] Bits */
N#define ADC14_CLRIFGR1_CLRHIIFG_OFS              ( 3)                            /*!< CLRADC14HIIFG Bit Offset */
N#define ADC14_CLRIFGR1_CLRHIIFG                  ((uint32_t)0x00000008)          /*!< clear ADC14HIIFG */
N/* ADC14_CLRIFGR1[CLROVIFG] Bits */
N#define ADC14_CLRIFGR1_CLROVIFG_OFS              ( 4)                            /*!< CLRADC14OVIFG Bit Offset */
N#define ADC14_CLRIFGR1_CLROVIFG                  ((uint32_t)0x00000010)          /*!< clear ADC14OVIFG */
N/* ADC14_CLRIFGR1[CLRTOVIFG] Bits */
N#define ADC14_CLRIFGR1_CLRTOVIFG_OFS             ( 5)                            /*!< CLRADC14TOVIFG Bit Offset */
N#define ADC14_CLRIFGR1_CLRTOVIFG                 ((uint32_t)0x00000020)          /*!< clear ADC14TOVIFG */
N/* ADC14_CLRIFGR1[CLRRDYIFG] Bits */
N#define ADC14_CLRIFGR1_CLRRDYIFG_OFS             ( 6)                            /*!< CLRADC14RDYIFG Bit Offset */
N#define ADC14_CLRIFGR1_CLRRDYIFG                 ((uint32_t)0x00000040)          /*!< clear ADC14RDYIFG */
N
N/******************************************************************************
N* AES256 Bits
N******************************************************************************/
N/* AES256_CTL0[OP] Bits */
N#define AES256_CTL0_OP_OFS                       ( 0)                            /*!< AESOPx Bit Offset */
N#define AES256_CTL0_OP_MASK                      ((uint16_t)0x0003)              /*!< AESOPx Bit Mask */
N#define AES256_CTL0_OP0                          ((uint16_t)0x0001)              /*!< OP Bit 0 */
N#define AES256_CTL0_OP1                          ((uint16_t)0x0002)              /*!< OP Bit 1 */
N#define AES256_CTL0_OP_0                         ((uint16_t)0x0000)              /*!< Encryption */
N#define AES256_CTL0_OP_1                         ((uint16_t)0x0001)              /*!< Decryption. The provided key is the same key used for encryption */
N#define AES256_CTL0_OP_2                         ((uint16_t)0x0002)              /*!< Generate first round key required for decryption */
N#define AES256_CTL0_OP_3                         ((uint16_t)0x0003)              /*!< Decryption. The provided key is the first round key required for decryption */
N/* AES256_CTL0[KL] Bits */
N#define AES256_CTL0_KL_OFS                       ( 2)                            /*!< AESKLx Bit Offset */
N#define AES256_CTL0_KL_MASK                      ((uint16_t)0x000C)              /*!< AESKLx Bit Mask */
N#define AES256_CTL0_KL0                          ((uint16_t)0x0004)              /*!< KL Bit 0 */
N#define AES256_CTL0_KL1                          ((uint16_t)0x0008)              /*!< KL Bit 1 */
N#define AES256_CTL0_KL_0                         ((uint16_t)0x0000)              /*!< AES128. The key size is 128 bit */
N#define AES256_CTL0_KL_1                         ((uint16_t)0x0004)              /*!< AES192. The key size is 192 bit. */
N#define AES256_CTL0_KL_2                         ((uint16_t)0x0008)              /*!< AES256. The key size is 256 bit */
N#define AES256_CTL0_KL__128BIT                   ((uint16_t)0x0000)              /*!< AES128. The key size is 128 bit */
N#define AES256_CTL0_KL__192BIT                   ((uint16_t)0x0004)              /*!< AES192. The key size is 192 bit. */
N#define AES256_CTL0_KL__256BIT                   ((uint16_t)0x0008)              /*!< AES256. The key size is 256 bit */
N/* AES256_CTL0[CM] Bits */
N#define AES256_CTL0_CM_OFS                       ( 5)                            /*!< AESCMx Bit Offset */
N#define AES256_CTL0_CM_MASK                      ((uint16_t)0x0060)              /*!< AESCMx Bit Mask */
N#define AES256_CTL0_CM0                          ((uint16_t)0x0020)              /*!< CM Bit 0 */
N#define AES256_CTL0_CM1                          ((uint16_t)0x0040)              /*!< CM Bit 1 */
N#define AES256_CTL0_CM_0                         ((uint16_t)0x0000)              /*!< ECB */
N#define AES256_CTL0_CM_1                         ((uint16_t)0x0020)              /*!< CBC */
N#define AES256_CTL0_CM_2                         ((uint16_t)0x0040)              /*!< OFB */
N#define AES256_CTL0_CM_3                         ((uint16_t)0x0060)              /*!< CFB */
N#define AES256_CTL0_CM__ECB                      ((uint16_t)0x0000)              /*!< ECB */
N#define AES256_CTL0_CM__CBC                      ((uint16_t)0x0020)              /*!< CBC */
N#define AES256_CTL0_CM__OFB                      ((uint16_t)0x0040)              /*!< OFB */
N#define AES256_CTL0_CM__CFB                      ((uint16_t)0x0060)              /*!< CFB */
N/* AES256_CTL0[SWRST] Bits */
N#define AES256_CTL0_SWRST_OFS                    ( 7)                            /*!< AESSWRST Bit Offset */
N#define AES256_CTL0_SWRST                        ((uint16_t)0x0080)              /*!< AES software reset */
N/* AES256_CTL0[RDYIFG] Bits */
N#define AES256_CTL0_RDYIFG_OFS                   ( 8)                            /*!< AESRDYIFG Bit Offset */
N#define AES256_CTL0_RDYIFG                       ((uint16_t)0x0100)              /*!< AES ready interrupt flag */
N/* AES256_CTL0[ERRFG] Bits */
N#define AES256_CTL0_ERRFG_OFS                    (11)                            /*!< AESERRFG Bit Offset */
N#define AES256_CTL0_ERRFG                        ((uint16_t)0x0800)              /*!< AES error flag */
N/* AES256_CTL0[RDYIE] Bits */
N#define AES256_CTL0_RDYIE_OFS                    (12)                            /*!< AESRDYIE Bit Offset */
N#define AES256_CTL0_RDYIE                        ((uint16_t)0x1000)              /*!< AES ready interrupt enable */
N/* AES256_CTL0[CMEN] Bits */
N#define AES256_CTL0_CMEN_OFS                     (15)                            /*!< AESCMEN Bit Offset */
N#define AES256_CTL0_CMEN                         ((uint16_t)0x8000)              /*!< AES cipher mode enable */
N/* AES256_CTL1[BLKCNT] Bits */
N#define AES256_CTL1_BLKCNT_OFS                   ( 0)                            /*!< AESBLKCNTx Bit Offset */
N#define AES256_CTL1_BLKCNT_MASK                  ((uint16_t)0x00FF)              /*!< AESBLKCNTx Bit Mask */
N#define AES256_CTL1_BLKCNT0                      ((uint16_t)0x0001)              /*!< BLKCNT Bit 0 */
N#define AES256_CTL1_BLKCNT1                      ((uint16_t)0x0002)              /*!< BLKCNT Bit 1 */
N#define AES256_CTL1_BLKCNT2                      ((uint16_t)0x0004)              /*!< BLKCNT Bit 2 */
N#define AES256_CTL1_BLKCNT3                      ((uint16_t)0x0008)              /*!< BLKCNT Bit 3 */
N#define AES256_CTL1_BLKCNT4                      ((uint16_t)0x0010)              /*!< BLKCNT Bit 4 */
N#define AES256_CTL1_BLKCNT5                      ((uint16_t)0x0020)              /*!< BLKCNT Bit 5 */
N#define AES256_CTL1_BLKCNT6                      ((uint16_t)0x0040)              /*!< BLKCNT Bit 6 */
N#define AES256_CTL1_BLKCNT7                      ((uint16_t)0x0080)              /*!< BLKCNT Bit 7 */
N/* AES256_STAT[BUSY] Bits */
N#define AES256_STAT_BUSY_OFS                     ( 0)                            /*!< AESBUSY Bit Offset */
N#define AES256_STAT_BUSY                         ((uint16_t)0x0001)              /*!< AES accelerator module busy */
N/* AES256_STAT[KEYWR] Bits */
N#define AES256_STAT_KEYWR_OFS                    ( 1)                            /*!< AESKEYWR Bit Offset */
N#define AES256_STAT_KEYWR                        ((uint16_t)0x0002)              /*!< All 16 bytes written to AESAKEY */
N/* AES256_STAT[DINWR] Bits */
N#define AES256_STAT_DINWR_OFS                    ( 2)                            /*!< AESDINWR Bit Offset */
N#define AES256_STAT_DINWR                        ((uint16_t)0x0004)              /*!< All 16 bytes written to AESADIN, AESAXDIN or AESAXIN */
N/* AES256_STAT[DOUTRD] Bits */
N#define AES256_STAT_DOUTRD_OFS                   ( 3)                            /*!< AESDOUTRD Bit Offset */
N#define AES256_STAT_DOUTRD                       ((uint16_t)0x0008)              /*!< All 16 bytes read from AESADOUT */
N/* AES256_STAT[KEYCNT] Bits */
N#define AES256_STAT_KEYCNT_OFS                   ( 4)                            /*!< AESKEYCNTx Bit Offset */
N#define AES256_STAT_KEYCNT_MASK                  ((uint16_t)0x00F0)              /*!< AESKEYCNTx Bit Mask */
N#define AES256_STAT_KEYCNT0                      ((uint16_t)0x0010)              /*!< KEYCNT Bit 0 */
N#define AES256_STAT_KEYCNT1                      ((uint16_t)0x0020)              /*!< KEYCNT Bit 1 */
N#define AES256_STAT_KEYCNT2                      ((uint16_t)0x0040)              /*!< KEYCNT Bit 2 */
N#define AES256_STAT_KEYCNT3                      ((uint16_t)0x0080)              /*!< KEYCNT Bit 3 */
N/* AES256_STAT[DINCNT] Bits */
N#define AES256_STAT_DINCNT_OFS                   ( 8)                            /*!< AESDINCNTx Bit Offset */
N#define AES256_STAT_DINCNT_MASK                  ((uint16_t)0x0F00)              /*!< AESDINCNTx Bit Mask */
N#define AES256_STAT_DINCNT0                      ((uint16_t)0x0100)              /*!< DINCNT Bit 0 */
N#define AES256_STAT_DINCNT1                      ((uint16_t)0x0200)              /*!< DINCNT Bit 1 */
N#define AES256_STAT_DINCNT2                      ((uint16_t)0x0400)              /*!< DINCNT Bit 2 */
N#define AES256_STAT_DINCNT3                      ((uint16_t)0x0800)              /*!< DINCNT Bit 3 */
N/* AES256_STAT[DOUTCNT] Bits */
N#define AES256_STAT_DOUTCNT_OFS                  (12)                            /*!< AESDOUTCNTx Bit Offset */
N#define AES256_STAT_DOUTCNT_MASK                 ((uint16_t)0xF000)              /*!< AESDOUTCNTx Bit Mask */
N#define AES256_STAT_DOUTCNT0                     ((uint16_t)0x1000)              /*!< DOUTCNT Bit 0 */
N#define AES256_STAT_DOUTCNT1                     ((uint16_t)0x2000)              /*!< DOUTCNT Bit 1 */
N#define AES256_STAT_DOUTCNT2                     ((uint16_t)0x4000)              /*!< DOUTCNT Bit 2 */
N#define AES256_STAT_DOUTCNT3                     ((uint16_t)0x8000)              /*!< DOUTCNT Bit 3 */
N/* AES256_KEY[KEY0] Bits */
N#define AES256_KEY_KEY0_OFS                      ( 0)                            /*!< AESKEY0x Bit Offset */
N#define AES256_KEY_KEY0_MASK                     ((uint16_t)0x00FF)              /*!< AESKEY0x Bit Mask */
N#define AES256_KEY_KEY00                         ((uint16_t)0x0001)              /*!< KEY0 Bit 0 */
N#define AES256_KEY_KEY01                         ((uint16_t)0x0002)              /*!< KEY0 Bit 1 */
N#define AES256_KEY_KEY02                         ((uint16_t)0x0004)              /*!< KEY0 Bit 2 */
N#define AES256_KEY_KEY03                         ((uint16_t)0x0008)              /*!< KEY0 Bit 3 */
N#define AES256_KEY_KEY04                         ((uint16_t)0x0010)              /*!< KEY0 Bit 4 */
N#define AES256_KEY_KEY05                         ((uint16_t)0x0020)              /*!< KEY0 Bit 5 */
N#define AES256_KEY_KEY06                         ((uint16_t)0x0040)              /*!< KEY0 Bit 6 */
N#define AES256_KEY_KEY07                         ((uint16_t)0x0080)              /*!< KEY0 Bit 7 */
N/* AES256_KEY[KEY1] Bits */
N#define AES256_KEY_KEY1_OFS                      ( 8)                            /*!< AESKEY1x Bit Offset */
N#define AES256_KEY_KEY1_MASK                     ((uint16_t)0xFF00)              /*!< AESKEY1x Bit Mask */
N#define AES256_KEY_KEY10                         ((uint16_t)0x0100)              /*!< KEY1 Bit 0 */
N#define AES256_KEY_KEY11                         ((uint16_t)0x0200)              /*!< KEY1 Bit 1 */
N#define AES256_KEY_KEY12                         ((uint16_t)0x0400)              /*!< KEY1 Bit 2 */
N#define AES256_KEY_KEY13                         ((uint16_t)0x0800)              /*!< KEY1 Bit 3 */
N#define AES256_KEY_KEY14                         ((uint16_t)0x1000)              /*!< KEY1 Bit 4 */
N#define AES256_KEY_KEY15                         ((uint16_t)0x2000)              /*!< KEY1 Bit 5 */
N#define AES256_KEY_KEY16                         ((uint16_t)0x4000)              /*!< KEY1 Bit 6 */
N#define AES256_KEY_KEY17                         ((uint16_t)0x8000)              /*!< KEY1 Bit 7 */
N/* AES256_DIN[DIN0] Bits */
N#define AES256_DIN_DIN0_OFS                      ( 0)                            /*!< AESDIN0x Bit Offset */
N#define AES256_DIN_DIN0_MASK                     ((uint16_t)0x00FF)              /*!< AESDIN0x Bit Mask */
N#define AES256_DIN_DIN00                         ((uint16_t)0x0001)              /*!< DIN0 Bit 0 */
N#define AES256_DIN_DIN01                         ((uint16_t)0x0002)              /*!< DIN0 Bit 1 */
N#define AES256_DIN_DIN02                         ((uint16_t)0x0004)              /*!< DIN0 Bit 2 */
N#define AES256_DIN_DIN03                         ((uint16_t)0x0008)              /*!< DIN0 Bit 3 */
N#define AES256_DIN_DIN04                         ((uint16_t)0x0010)              /*!< DIN0 Bit 4 */
N#define AES256_DIN_DIN05                         ((uint16_t)0x0020)              /*!< DIN0 Bit 5 */
N#define AES256_DIN_DIN06                         ((uint16_t)0x0040)              /*!< DIN0 Bit 6 */
N#define AES256_DIN_DIN07                         ((uint16_t)0x0080)              /*!< DIN0 Bit 7 */
N/* AES256_DIN[DIN1] Bits */
N#define AES256_DIN_DIN1_OFS                      ( 8)                            /*!< AESDIN1x Bit Offset */
N#define AES256_DIN_DIN1_MASK                     ((uint16_t)0xFF00)              /*!< AESDIN1x Bit Mask */
N#define AES256_DIN_DIN10                         ((uint16_t)0x0100)              /*!< DIN1 Bit 0 */
N#define AES256_DIN_DIN11                         ((uint16_t)0x0200)              /*!< DIN1 Bit 1 */
N#define AES256_DIN_DIN12                         ((uint16_t)0x0400)              /*!< DIN1 Bit 2 */
N#define AES256_DIN_DIN13                         ((uint16_t)0x0800)              /*!< DIN1 Bit 3 */
N#define AES256_DIN_DIN14                         ((uint16_t)0x1000)              /*!< DIN1 Bit 4 */
N#define AES256_DIN_DIN15                         ((uint16_t)0x2000)              /*!< DIN1 Bit 5 */
N#define AES256_DIN_DIN16                         ((uint16_t)0x4000)              /*!< DIN1 Bit 6 */
N#define AES256_DIN_DIN17                         ((uint16_t)0x8000)              /*!< DIN1 Bit 7 */
N/* AES256_DOUT[DOUT0] Bits */
N#define AES256_DOUT_DOUT0_OFS                    ( 0)                            /*!< AESDOUT0x Bit Offset */
N#define AES256_DOUT_DOUT0_MASK                   ((uint16_t)0x00FF)              /*!< AESDOUT0x Bit Mask */
N#define AES256_DOUT_DOUT00                       ((uint16_t)0x0001)              /*!< DOUT0 Bit 0 */
N#define AES256_DOUT_DOUT01                       ((uint16_t)0x0002)              /*!< DOUT0 Bit 1 */
N#define AES256_DOUT_DOUT02                       ((uint16_t)0x0004)              /*!< DOUT0 Bit 2 */
N#define AES256_DOUT_DOUT03                       ((uint16_t)0x0008)              /*!< DOUT0 Bit 3 */
N#define AES256_DOUT_DOUT04                       ((uint16_t)0x0010)              /*!< DOUT0 Bit 4 */
N#define AES256_DOUT_DOUT05                       ((uint16_t)0x0020)              /*!< DOUT0 Bit 5 */
N#define AES256_DOUT_DOUT06                       ((uint16_t)0x0040)              /*!< DOUT0 Bit 6 */
N#define AES256_DOUT_DOUT07                       ((uint16_t)0x0080)              /*!< DOUT0 Bit 7 */
N/* AES256_DOUT[DOUT1] Bits */
N#define AES256_DOUT_DOUT1_OFS                    ( 8)                            /*!< AESDOUT1x Bit Offset */
N#define AES256_DOUT_DOUT1_MASK                   ((uint16_t)0xFF00)              /*!< AESDOUT1x Bit Mask */
N#define AES256_DOUT_DOUT10                       ((uint16_t)0x0100)              /*!< DOUT1 Bit 0 */
N#define AES256_DOUT_DOUT11                       ((uint16_t)0x0200)              /*!< DOUT1 Bit 1 */
N#define AES256_DOUT_DOUT12                       ((uint16_t)0x0400)              /*!< DOUT1 Bit 2 */
N#define AES256_DOUT_DOUT13                       ((uint16_t)0x0800)              /*!< DOUT1 Bit 3 */
N#define AES256_DOUT_DOUT14                       ((uint16_t)0x1000)              /*!< DOUT1 Bit 4 */
N#define AES256_DOUT_DOUT15                       ((uint16_t)0x2000)              /*!< DOUT1 Bit 5 */
N#define AES256_DOUT_DOUT16                       ((uint16_t)0x4000)              /*!< DOUT1 Bit 6 */
N#define AES256_DOUT_DOUT17                       ((uint16_t)0x8000)              /*!< DOUT1 Bit 7 */
N/* AES256_XDIN[XDIN0] Bits */
N#define AES256_XDIN_XDIN0_OFS                    ( 0)                            /*!< AESXDIN0x Bit Offset */
N#define AES256_XDIN_XDIN0_MASK                   ((uint16_t)0x00FF)              /*!< AESXDIN0x Bit Mask */
N#define AES256_XDIN_XDIN00                       ((uint16_t)0x0001)              /*!< XDIN0 Bit 0 */
N#define AES256_XDIN_XDIN01                       ((uint16_t)0x0002)              /*!< XDIN0 Bit 1 */
N#define AES256_XDIN_XDIN02                       ((uint16_t)0x0004)              /*!< XDIN0 Bit 2 */
N#define AES256_XDIN_XDIN03                       ((uint16_t)0x0008)              /*!< XDIN0 Bit 3 */
N#define AES256_XDIN_XDIN04                       ((uint16_t)0x0010)              /*!< XDIN0 Bit 4 */
N#define AES256_XDIN_XDIN05                       ((uint16_t)0x0020)              /*!< XDIN0 Bit 5 */
N#define AES256_XDIN_XDIN06                       ((uint16_t)0x0040)              /*!< XDIN0 Bit 6 */
N#define AES256_XDIN_XDIN07                       ((uint16_t)0x0080)              /*!< XDIN0 Bit 7 */
N/* AES256_XDIN[XDIN1] Bits */
N#define AES256_XDIN_XDIN1_OFS                    ( 8)                            /*!< AESXDIN1x Bit Offset */
N#define AES256_XDIN_XDIN1_MASK                   ((uint16_t)0xFF00)              /*!< AESXDIN1x Bit Mask */
N#define AES256_XDIN_XDIN10                       ((uint16_t)0x0100)              /*!< XDIN1 Bit 0 */
N#define AES256_XDIN_XDIN11                       ((uint16_t)0x0200)              /*!< XDIN1 Bit 1 */
N#define AES256_XDIN_XDIN12                       ((uint16_t)0x0400)              /*!< XDIN1 Bit 2 */
N#define AES256_XDIN_XDIN13                       ((uint16_t)0x0800)              /*!< XDIN1 Bit 3 */
N#define AES256_XDIN_XDIN14                       ((uint16_t)0x1000)              /*!< XDIN1 Bit 4 */
N#define AES256_XDIN_XDIN15                       ((uint16_t)0x2000)              /*!< XDIN1 Bit 5 */
N#define AES256_XDIN_XDIN16                       ((uint16_t)0x4000)              /*!< XDIN1 Bit 6 */
N#define AES256_XDIN_XDIN17                       ((uint16_t)0x8000)              /*!< XDIN1 Bit 7 */
N/* AES256_XIN[XIN0] Bits */
N#define AES256_XIN_XIN0_OFS                      ( 0)                            /*!< AESXIN0x Bit Offset */
N#define AES256_XIN_XIN0_MASK                     ((uint16_t)0x00FF)              /*!< AESXIN0x Bit Mask */
N#define AES256_XIN_XIN00                         ((uint16_t)0x0001)              /*!< XIN0 Bit 0 */
N#define AES256_XIN_XIN01                         ((uint16_t)0x0002)              /*!< XIN0 Bit 1 */
N#define AES256_XIN_XIN02                         ((uint16_t)0x0004)              /*!< XIN0 Bit 2 */
N#define AES256_XIN_XIN03                         ((uint16_t)0x0008)              /*!< XIN0 Bit 3 */
N#define AES256_XIN_XIN04                         ((uint16_t)0x0010)              /*!< XIN0 Bit 4 */
N#define AES256_XIN_XIN05                         ((uint16_t)0x0020)              /*!< XIN0 Bit 5 */
N#define AES256_XIN_XIN06                         ((uint16_t)0x0040)              /*!< XIN0 Bit 6 */
N#define AES256_XIN_XIN07                         ((uint16_t)0x0080)              /*!< XIN0 Bit 7 */
N/* AES256_XIN[XIN1] Bits */
N#define AES256_XIN_XIN1_OFS                      ( 8)                            /*!< AESXIN1x Bit Offset */
N#define AES256_XIN_XIN1_MASK                     ((uint16_t)0xFF00)              /*!< AESXIN1x Bit Mask */
N#define AES256_XIN_XIN10                         ((uint16_t)0x0100)              /*!< XIN1 Bit 0 */
N#define AES256_XIN_XIN11                         ((uint16_t)0x0200)              /*!< XIN1 Bit 1 */
N#define AES256_XIN_XIN12                         ((uint16_t)0x0400)              /*!< XIN1 Bit 2 */
N#define AES256_XIN_XIN13                         ((uint16_t)0x0800)              /*!< XIN1 Bit 3 */
N#define AES256_XIN_XIN14                         ((uint16_t)0x1000)              /*!< XIN1 Bit 4 */
N#define AES256_XIN_XIN15                         ((uint16_t)0x2000)              /*!< XIN1 Bit 5 */
N#define AES256_XIN_XIN16                         ((uint16_t)0x4000)              /*!< XIN1 Bit 6 */
N#define AES256_XIN_XIN17                         ((uint16_t)0x8000)              /*!< XIN1 Bit 7 */
N
N/******************************************************************************
N* CAPTIO Bits
N******************************************************************************/
N/* CAPTIO_CTL[PISEL] Bits */
N#define CAPTIO_CTL_PISEL_OFS                     ( 1)                            /*!< CAPTIOPISELx Bit Offset */
N#define CAPTIO_CTL_PISEL_MASK                    ((uint16_t)0x000E)              /*!< CAPTIOPISELx Bit Mask */
N#define CAPTIO_CTL_PISEL0                        ((uint16_t)0x0002)              /*!< PISEL Bit 0 */
N#define CAPTIO_CTL_PISEL1                        ((uint16_t)0x0004)              /*!< PISEL Bit 1 */
N#define CAPTIO_CTL_PISEL2                        ((uint16_t)0x0008)              /*!< PISEL Bit 2 */
N#define CAPTIO_CTL_PISEL_0                       ((uint16_t)0x0000)              /*!< Px.0 */
N#define CAPTIO_CTL_PISEL_1                       ((uint16_t)0x0002)              /*!< Px.1 */
N#define CAPTIO_CTL_PISEL_2                       ((uint16_t)0x0004)              /*!< Px.2 */
N#define CAPTIO_CTL_PISEL_3                       ((uint16_t)0x0006)              /*!< Px.3 */
N#define CAPTIO_CTL_PISEL_4                       ((uint16_t)0x0008)              /*!< Px.4 */
N#define CAPTIO_CTL_PISEL_5                       ((uint16_t)0x000A)              /*!< Px.5 */
N#define CAPTIO_CTL_PISEL_6                       ((uint16_t)0x000C)              /*!< Px.6 */
N#define CAPTIO_CTL_PISEL_7                       ((uint16_t)0x000E)              /*!< Px.7 */
N/* CAPTIO_CTL[POSEL] Bits */
N#define CAPTIO_CTL_POSEL_OFS                     ( 4)                            /*!< CAPTIOPOSELx Bit Offset */
N#define CAPTIO_CTL_POSEL_MASK                    ((uint16_t)0x00F0)              /*!< CAPTIOPOSELx Bit Mask */
N#define CAPTIO_CTL_POSEL0                        ((uint16_t)0x0010)              /*!< POSEL Bit 0 */
N#define CAPTIO_CTL_POSEL1                        ((uint16_t)0x0020)              /*!< POSEL Bit 1 */
N#define CAPTIO_CTL_POSEL2                        ((uint16_t)0x0040)              /*!< POSEL Bit 2 */
N#define CAPTIO_CTL_POSEL3                        ((uint16_t)0x0080)              /*!< POSEL Bit 3 */
N#define CAPTIO_CTL_POSEL_0                       ((uint16_t)0x0000)              /*!< Px = PJ */
N#define CAPTIO_CTL_POSEL_1                       ((uint16_t)0x0010)              /*!< Px = P1 */
N#define CAPTIO_CTL_POSEL_2                       ((uint16_t)0x0020)              /*!< Px = P2 */
N#define CAPTIO_CTL_POSEL_3                       ((uint16_t)0x0030)              /*!< Px = P3 */
N#define CAPTIO_CTL_POSEL_4                       ((uint16_t)0x0040)              /*!< Px = P4 */
N#define CAPTIO_CTL_POSEL_5                       ((uint16_t)0x0050)              /*!< Px = P5 */
N#define CAPTIO_CTL_POSEL_6                       ((uint16_t)0x0060)              /*!< Px = P6 */
N#define CAPTIO_CTL_POSEL_7                       ((uint16_t)0x0070)              /*!< Px = P7 */
N#define CAPTIO_CTL_POSEL_8                       ((uint16_t)0x0080)              /*!< Px = P8 */
N#define CAPTIO_CTL_POSEL_9                       ((uint16_t)0x0090)              /*!< Px = P9 */
N#define CAPTIO_CTL_POSEL_10                      ((uint16_t)0x00A0)              /*!< Px = P10 */
N#define CAPTIO_CTL_POSEL_11                      ((uint16_t)0x00B0)              /*!< Px = P11 */
N#define CAPTIO_CTL_POSEL_12                      ((uint16_t)0x00C0)              /*!< Px = P12 */
N#define CAPTIO_CTL_POSEL_13                      ((uint16_t)0x00D0)              /*!< Px = P13 */
N#define CAPTIO_CTL_POSEL_14                      ((uint16_t)0x00E0)              /*!< Px = P14 */
N#define CAPTIO_CTL_POSEL_15                      ((uint16_t)0x00F0)              /*!< Px = P15 */
N#define CAPTIO_CTL_POSEL__PJ                     ((uint16_t)0x0000)              /*!< Px = PJ */
N#define CAPTIO_CTL_POSEL__P1                     ((uint16_t)0x0010)              /*!< Px = P1 */
N#define CAPTIO_CTL_POSEL__P2                     ((uint16_t)0x0020)              /*!< Px = P2 */
N#define CAPTIO_CTL_POSEL__P3                     ((uint16_t)0x0030)              /*!< Px = P3 */
N#define CAPTIO_CTL_POSEL__P4                     ((uint16_t)0x0040)              /*!< Px = P4 */
N#define CAPTIO_CTL_POSEL__P5                     ((uint16_t)0x0050)              /*!< Px = P5 */
N#define CAPTIO_CTL_POSEL__P6                     ((uint16_t)0x0060)              /*!< Px = P6 */
N#define CAPTIO_CTL_POSEL__P7                     ((uint16_t)0x0070)              /*!< Px = P7 */
N#define CAPTIO_CTL_POSEL__P8                     ((uint16_t)0x0080)              /*!< Px = P8 */
N#define CAPTIO_CTL_POSEL__P9                     ((uint16_t)0x0090)              /*!< Px = P9 */
N#define CAPTIO_CTL_POSEL__P10                    ((uint16_t)0x00A0)              /*!< Px = P10 */
N#define CAPTIO_CTL_POSEL__P11                    ((uint16_t)0x00B0)              /*!< Px = P11 */
N#define CAPTIO_CTL_POSEL__P12                    ((uint16_t)0x00C0)              /*!< Px = P12 */
N#define CAPTIO_CTL_POSEL__P13                    ((uint16_t)0x00D0)              /*!< Px = P13 */
N#define CAPTIO_CTL_POSEL__P14                    ((uint16_t)0x00E0)              /*!< Px = P14 */
N#define CAPTIO_CTL_POSEL__P15                    ((uint16_t)0x00F0)              /*!< Px = P15 */
N/* CAPTIO_CTL[EN] Bits */
N#define CAPTIO_CTL_EN_OFS                        ( 8)                            /*!< CAPTIOEN Bit Offset */
N#define CAPTIO_CTL_EN                            ((uint16_t)0x0100)              /*!< Capacitive Touch IO enable */
N/* CAPTIO_CTL[STATE] Bits */
N#define CAPTIO_CTL_STATE_OFS                     ( 9)                            /*!< CAPTIOSTATE Bit Offset */
N#define CAPTIO_CTL_STATE                         ((uint16_t)0x0200)              /*!< Capacitive Touch IO state */
N
N/******************************************************************************
N* COMP_E Bits
N******************************************************************************/
N/* COMP_E_CTL0[IPSEL] Bits */
N#define COMP_E_CTL0_IPSEL_OFS                    ( 0)                            /*!< CEIPSEL Bit Offset */
N#define COMP_E_CTL0_IPSEL_MASK                   ((uint16_t)0x000F)              /*!< CEIPSEL Bit Mask */
N#define COMP_E_CTL0_IPSEL0                       ((uint16_t)0x0001)              /*!< IPSEL Bit 0 */
N#define COMP_E_CTL0_IPSEL1                       ((uint16_t)0x0002)              /*!< IPSEL Bit 1 */
N#define COMP_E_CTL0_IPSEL2                       ((uint16_t)0x0004)              /*!< IPSEL Bit 2 */
N#define COMP_E_CTL0_IPSEL3                       ((uint16_t)0x0008)              /*!< IPSEL Bit 3 */
N#define COMP_E_CTL0_IPSEL_0                      ((uint16_t)0x0000)              /*!< Channel 0 selected */
N#define COMP_E_CTL0_IPSEL_1                      ((uint16_t)0x0001)              /*!< Channel 1 selected */
N#define COMP_E_CTL0_IPSEL_2                      ((uint16_t)0x0002)              /*!< Channel 2 selected */
N#define COMP_E_CTL0_IPSEL_3                      ((uint16_t)0x0003)              /*!< Channel 3 selected */
N#define COMP_E_CTL0_IPSEL_4                      ((uint16_t)0x0004)              /*!< Channel 4 selected */
N#define COMP_E_CTL0_IPSEL_5                      ((uint16_t)0x0005)              /*!< Channel 5 selected */
N#define COMP_E_CTL0_IPSEL_6                      ((uint16_t)0x0006)              /*!< Channel 6 selected */
N#define COMP_E_CTL0_IPSEL_7                      ((uint16_t)0x0007)              /*!< Channel 7 selected */
N#define COMP_E_CTL0_IPSEL_8                      ((uint16_t)0x0008)              /*!< Channel 8 selected */
N#define COMP_E_CTL0_IPSEL_9                      ((uint16_t)0x0009)              /*!< Channel 9 selected */
N#define COMP_E_CTL0_IPSEL_10                     ((uint16_t)0x000A)              /*!< Channel 10 selected */
N#define COMP_E_CTL0_IPSEL_11                     ((uint16_t)0x000B)              /*!< Channel 11 selected */
N#define COMP_E_CTL0_IPSEL_12                     ((uint16_t)0x000C)              /*!< Channel 12 selected */
N#define COMP_E_CTL0_IPSEL_13                     ((uint16_t)0x000D)              /*!< Channel 13 selected */
N#define COMP_E_CTL0_IPSEL_14                     ((uint16_t)0x000E)              /*!< Channel 14 selected */
N#define COMP_E_CTL0_IPSEL_15                     ((uint16_t)0x000F)              /*!< Channel 15 selected */
N/* COMP_E_CTL0[IPEN] Bits */
N#define COMP_E_CTL0_IPEN_OFS                     ( 7)                            /*!< CEIPEN Bit Offset */
N#define COMP_E_CTL0_IPEN                         ((uint16_t)0x0080)              /*!< Channel input enable for the V+ terminal */
N/* COMP_E_CTL0[IMSEL] Bits */
N#define COMP_E_CTL0_IMSEL_OFS                    ( 8)                            /*!< CEIMSEL Bit Offset */
N#define COMP_E_CTL0_IMSEL_MASK                   ((uint16_t)0x0F00)              /*!< CEIMSEL Bit Mask */
N#define COMP_E_CTL0_IMSEL0                       ((uint16_t)0x0100)              /*!< IMSEL Bit 0 */
N#define COMP_E_CTL0_IMSEL1                       ((uint16_t)0x0200)              /*!< IMSEL Bit 1 */
N#define COMP_E_CTL0_IMSEL2                       ((uint16_t)0x0400)              /*!< IMSEL Bit 2 */
N#define COMP_E_CTL0_IMSEL3                       ((uint16_t)0x0800)              /*!< IMSEL Bit 3 */
N#define COMP_E_CTL0_IMSEL_0                      ((uint16_t)0x0000)              /*!< Channel 0 selected */
N#define COMP_E_CTL0_IMSEL_1                      ((uint16_t)0x0100)              /*!< Channel 1 selected */
N#define COMP_E_CTL0_IMSEL_2                      ((uint16_t)0x0200)              /*!< Channel 2 selected */
N#define COMP_E_CTL0_IMSEL_3                      ((uint16_t)0x0300)              /*!< Channel 3 selected */
N#define COMP_E_CTL0_IMSEL_4                      ((uint16_t)0x0400)              /*!< Channel 4 selected */
N#define COMP_E_CTL0_IMSEL_5                      ((uint16_t)0x0500)              /*!< Channel 5 selected */
N#define COMP_E_CTL0_IMSEL_6                      ((uint16_t)0x0600)              /*!< Channel 6 selected */
N#define COMP_E_CTL0_IMSEL_7                      ((uint16_t)0x0700)              /*!< Channel 7 selected */
N#define COMP_E_CTL0_IMSEL_8                      ((uint16_t)0x0800)              /*!< Channel 8 selected */
N#define COMP_E_CTL0_IMSEL_9                      ((uint16_t)0x0900)              /*!< Channel 9 selected */
N#define COMP_E_CTL0_IMSEL_10                     ((uint16_t)0x0A00)              /*!< Channel 10 selected */
N#define COMP_E_CTL0_IMSEL_11                     ((uint16_t)0x0B00)              /*!< Channel 11 selected */
N#define COMP_E_CTL0_IMSEL_12                     ((uint16_t)0x0C00)              /*!< Channel 12 selected */
N#define COMP_E_CTL0_IMSEL_13                     ((uint16_t)0x0D00)              /*!< Channel 13 selected */
N#define COMP_E_CTL0_IMSEL_14                     ((uint16_t)0x0E00)              /*!< Channel 14 selected */
N#define COMP_E_CTL0_IMSEL_15                     ((uint16_t)0x0F00)              /*!< Channel 15 selected */
N/* COMP_E_CTL0[IMEN] Bits */
N#define COMP_E_CTL0_IMEN_OFS                     (15)                            /*!< CEIMEN Bit Offset */
N#define COMP_E_CTL0_IMEN                         ((uint16_t)0x8000)              /*!< Channel input enable for the - terminal */
N/* COMP_E_CTL1[OUT] Bits */
N#define COMP_E_CTL1_OUT_OFS                      ( 0)                            /*!< CEOUT Bit Offset */
N#define COMP_E_CTL1_OUT                          ((uint16_t)0x0001)              /*!< Comparator output value */
N/* COMP_E_CTL1[OUTPOL] Bits */
N#define COMP_E_CTL1_OUTPOL_OFS                   ( 1)                            /*!< CEOUTPOL Bit Offset */
N#define COMP_E_CTL1_OUTPOL                       ((uint16_t)0x0002)              /*!< Comparator output polarity */
N/* COMP_E_CTL1[F] Bits */
N#define COMP_E_CTL1_F_OFS                        ( 2)                            /*!< CEF Bit Offset */
N#define COMP_E_CTL1_F                            ((uint16_t)0x0004)              /*!< Comparator output filter */
N/* COMP_E_CTL1[IES] Bits */
N#define COMP_E_CTL1_IES_OFS                      ( 3)                            /*!< CEIES Bit Offset */
N#define COMP_E_CTL1_IES                          ((uint16_t)0x0008)              /*!< Interrupt edge select for CEIIFG and CEIFG */
N/* COMP_E_CTL1[SHORT] Bits */
N#define COMP_E_CTL1_SHORT_OFS                    ( 4)                            /*!< CESHORT Bit Offset */
N#define COMP_E_CTL1_SHORT                        ((uint16_t)0x0010)              /*!< Input short */
N/* COMP_E_CTL1[EX] Bits */
N#define COMP_E_CTL1_EX_OFS                       ( 5)                            /*!< CEEX Bit Offset */
N#define COMP_E_CTL1_EX                           ((uint16_t)0x0020)              /*!< Exchange */
N/* COMP_E_CTL1[FDLY] Bits */
N#define COMP_E_CTL1_FDLY_OFS                     ( 6)                            /*!< CEFDLY Bit Offset */
N#define COMP_E_CTL1_FDLY_MASK                    ((uint16_t)0x00C0)              /*!< CEFDLY Bit Mask */
N#define COMP_E_CTL1_FDLY0                        ((uint16_t)0x0040)              /*!< FDLY Bit 0 */
N#define COMP_E_CTL1_FDLY1                        ((uint16_t)0x0080)              /*!< FDLY Bit 1 */
N#define COMP_E_CTL1_FDLY_0                       ((uint16_t)0x0000)              /*!< Typical filter delay of TBD (450) ns */
N#define COMP_E_CTL1_FDLY_1                       ((uint16_t)0x0040)              /*!< Typical filter delay of TBD (900) ns */
N#define COMP_E_CTL1_FDLY_2                       ((uint16_t)0x0080)              /*!< Typical filter delay of TBD (1800) ns */
N#define COMP_E_CTL1_FDLY_3                       ((uint16_t)0x00C0)              /*!< Typical filter delay of TBD (3600) ns */
N/* COMP_E_CTL1[PWRMD] Bits */
N#define COMP_E_CTL1_PWRMD_OFS                    ( 8)                            /*!< CEPWRMD Bit Offset */
N#define COMP_E_CTL1_PWRMD_MASK                   ((uint16_t)0x0300)              /*!< CEPWRMD Bit Mask */
N#define COMP_E_CTL1_PWRMD0                       ((uint16_t)0x0100)              /*!< PWRMD Bit 0 */
N#define COMP_E_CTL1_PWRMD1                       ((uint16_t)0x0200)              /*!< PWRMD Bit 1 */
N#define COMP_E_CTL1_PWRMD_0                      ((uint16_t)0x0000)              /*!< High-speed mode */
N#define COMP_E_CTL1_PWRMD_1                      ((uint16_t)0x0100)              /*!< Normal mode */
N#define COMP_E_CTL1_PWRMD_2                      ((uint16_t)0x0200)              /*!< Ultra-low power mode */
N/* COMP_E_CTL1[ON] Bits */
N#define COMP_E_CTL1_ON_OFS                       (10)                            /*!< CEON Bit Offset */
N#define COMP_E_CTL1_ON                           ((uint16_t)0x0400)              /*!< Comparator On */
N/* COMP_E_CTL1[MRVL] Bits */
N#define COMP_E_CTL1_MRVL_OFS                     (11)                            /*!< CEMRVL Bit Offset */
N#define COMP_E_CTL1_MRVL                         ((uint16_t)0x0800)              /*!< This bit is valid of CEMRVS is set to 1 */
N/* COMP_E_CTL1[MRVS] Bits */
N#define COMP_E_CTL1_MRVS_OFS                     (12)                            /*!< CEMRVS Bit Offset */
N#define COMP_E_CTL1_MRVS                         ((uint16_t)0x1000)              
N/* COMP_E_CTL2[REF0] Bits */
N#define COMP_E_CTL2_REF0_OFS                     ( 0)                            /*!< CEREF0 Bit Offset */
N#define COMP_E_CTL2_REF0_MASK                    ((uint16_t)0x001F)              /*!< CEREF0 Bit Mask */
N#define COMP_E_CTL2_REF00                        ((uint16_t)0x0001)              /*!< REF0 Bit 0 */
N#define COMP_E_CTL2_REF01                        ((uint16_t)0x0002)              /*!< REF0 Bit 1 */
N#define COMP_E_CTL2_REF02                        ((uint16_t)0x0004)              /*!< REF0 Bit 2 */
N#define COMP_E_CTL2_REF03                        ((uint16_t)0x0008)              /*!< REF0 Bit 3 */
N#define COMP_E_CTL2_REF04                        ((uint16_t)0x0010)              /*!< REF0 Bit 4 */
N#define COMP_E_CTL2_REF0_0                       ((uint16_t)0x0000)              /*!< Reference resistor tap for setting 0. */
N#define COMP_E_CTL2_REF0_1                       ((uint16_t)0x0001)              /*!< Reference resistor tap for setting 1. */
N#define COMP_E_CTL2_REF0_2                       ((uint16_t)0x0002)              /*!< Reference resistor tap for setting 2. */
N#define COMP_E_CTL2_REF0_3                       ((uint16_t)0x0003)              /*!< Reference resistor tap for setting 3. */
N#define COMP_E_CTL2_REF0_4                       ((uint16_t)0x0004)              /*!< Reference resistor tap for setting 4. */
N#define COMP_E_CTL2_REF0_5                       ((uint16_t)0x0005)              /*!< Reference resistor tap for setting 5. */
N#define COMP_E_CTL2_REF0_6                       ((uint16_t)0x0006)              /*!< Reference resistor tap for setting 6. */
N#define COMP_E_CTL2_REF0_7                       ((uint16_t)0x0007)              /*!< Reference resistor tap for setting 7. */
N#define COMP_E_CTL2_REF0_8                       ((uint16_t)0x0008)              /*!< Reference resistor tap for setting 8. */
N#define COMP_E_CTL2_REF0_9                       ((uint16_t)0x0009)              /*!< Reference resistor tap for setting 9. */
N#define COMP_E_CTL2_REF0_10                      ((uint16_t)0x000A)              /*!< Reference resistor tap for setting 10. */
N#define COMP_E_CTL2_REF0_11                      ((uint16_t)0x000B)              /*!< Reference resistor tap for setting 11. */
N#define COMP_E_CTL2_REF0_12                      ((uint16_t)0x000C)              /*!< Reference resistor tap for setting 12. */
N#define COMP_E_CTL2_REF0_13                      ((uint16_t)0x000D)              /*!< Reference resistor tap for setting 13. */
N#define COMP_E_CTL2_REF0_14                      ((uint16_t)0x000E)              /*!< Reference resistor tap for setting 14. */
N#define COMP_E_CTL2_REF0_15                      ((uint16_t)0x000F)              /*!< Reference resistor tap for setting 15. */
N#define COMP_E_CTL2_REF0_16                      ((uint16_t)0x0010)              /*!< Reference resistor tap for setting 16. */
N#define COMP_E_CTL2_REF0_17                      ((uint16_t)0x0011)              /*!< Reference resistor tap for setting 17. */
N#define COMP_E_CTL2_REF0_18                      ((uint16_t)0x0012)              /*!< Reference resistor tap for setting 18. */
N#define COMP_E_CTL2_REF0_19                      ((uint16_t)0x0013)              /*!< Reference resistor tap for setting 19. */
N#define COMP_E_CTL2_REF0_20                      ((uint16_t)0x0014)              /*!< Reference resistor tap for setting 20. */
N#define COMP_E_CTL2_REF0_21                      ((uint16_t)0x0015)              /*!< Reference resistor tap for setting 21. */
N#define COMP_E_CTL2_REF0_22                      ((uint16_t)0x0016)              /*!< Reference resistor tap for setting 22. */
N#define COMP_E_CTL2_REF0_23                      ((uint16_t)0x0017)              /*!< Reference resistor tap for setting 23. */
N#define COMP_E_CTL2_REF0_24                      ((uint16_t)0x0018)              /*!< Reference resistor tap for setting 24. */
N#define COMP_E_CTL2_REF0_25                      ((uint16_t)0x0019)              /*!< Reference resistor tap for setting 25. */
N#define COMP_E_CTL2_REF0_26                      ((uint16_t)0x001A)              /*!< Reference resistor tap for setting 26. */
N#define COMP_E_CTL2_REF0_27                      ((uint16_t)0x001B)              /*!< Reference resistor tap for setting 27. */
N#define COMP_E_CTL2_REF0_28                      ((uint16_t)0x001C)              /*!< Reference resistor tap for setting 28. */
N#define COMP_E_CTL2_REF0_29                      ((uint16_t)0x001D)              /*!< Reference resistor tap for setting 29. */
N#define COMP_E_CTL2_REF0_30                      ((uint16_t)0x001E)              /*!< Reference resistor tap for setting 30. */
N#define COMP_E_CTL2_REF0_31                      ((uint16_t)0x001F)              /*!< Reference resistor tap for setting 31. */
N/* COMP_E_CTL2[RSEL] Bits */
N#define COMP_E_CTL2_RSEL_OFS                     ( 5)                            /*!< CERSEL Bit Offset */
N#define COMP_E_CTL2_RSEL                         ((uint16_t)0x0020)              /*!< Reference select */
N/* COMP_E_CTL2[RS] Bits */
N#define COMP_E_CTL2_RS_OFS                       ( 6)                            /*!< CERS Bit Offset */
N#define COMP_E_CTL2_RS_MASK                      ((uint16_t)0x00C0)              /*!< CERS Bit Mask */
N#define COMP_E_CTL2_RS0                          ((uint16_t)0x0040)              /*!< RS Bit 0 */
N#define COMP_E_CTL2_RS1                          ((uint16_t)0x0080)              /*!< RS Bit 1 */
N#define COMP_E_CTL2_RS_0                         ((uint16_t)0x0000)              /*!< No current is drawn by the reference circuitry */
N#define COMP_E_CTL2_RS_1                         ((uint16_t)0x0040)              /*!< VCC applied to the resistor ladder */
N#define COMP_E_CTL2_RS_2                         ((uint16_t)0x0080)              /*!< Shared reference voltage applied to the resistor ladder */
N#define COMP_E_CTL2_RS_3                         ((uint16_t)0x00C0)              /*!< Shared reference voltage supplied to V(CREF). Resistor ladder is off */
N/* COMP_E_CTL2[REF1] Bits */
N#define COMP_E_CTL2_REF1_OFS                     ( 8)                            /*!< CEREF1 Bit Offset */
N#define COMP_E_CTL2_REF1_MASK                    ((uint16_t)0x1F00)              /*!< CEREF1 Bit Mask */
N#define COMP_E_CTL2_REF10                        ((uint16_t)0x0100)              /*!< REF1 Bit 0 */
N#define COMP_E_CTL2_REF11                        ((uint16_t)0x0200)              /*!< REF1 Bit 1 */
N#define COMP_E_CTL2_REF12                        ((uint16_t)0x0400)              /*!< REF1 Bit 2 */
N#define COMP_E_CTL2_REF13                        ((uint16_t)0x0800)              /*!< REF1 Bit 3 */
N#define COMP_E_CTL2_REF14                        ((uint16_t)0x1000)              /*!< REF1 Bit 4 */
N#define COMP_E_CTL2_REF1_0                       ((uint16_t)0x0000)              /*!< Reference resistor tap for setting 0. */
N#define COMP_E_CTL2_REF1_1                       ((uint16_t)0x0100)              /*!< Reference resistor tap for setting 1. */
N#define COMP_E_CTL2_REF1_2                       ((uint16_t)0x0200)              /*!< Reference resistor tap for setting 2. */
N#define COMP_E_CTL2_REF1_3                       ((uint16_t)0x0300)              /*!< Reference resistor tap for setting 3. */
N#define COMP_E_CTL2_REF1_4                       ((uint16_t)0x0400)              /*!< Reference resistor tap for setting 4. */
N#define COMP_E_CTL2_REF1_5                       ((uint16_t)0x0500)              /*!< Reference resistor tap for setting 5. */
N#define COMP_E_CTL2_REF1_6                       ((uint16_t)0x0600)              /*!< Reference resistor tap for setting 6. */
N#define COMP_E_CTL2_REF1_7                       ((uint16_t)0x0700)              /*!< Reference resistor tap for setting 7. */
N#define COMP_E_CTL2_REF1_8                       ((uint16_t)0x0800)              /*!< Reference resistor tap for setting 8. */
N#define COMP_E_CTL2_REF1_9                       ((uint16_t)0x0900)              /*!< Reference resistor tap for setting 9. */
N#define COMP_E_CTL2_REF1_10                      ((uint16_t)0x0A00)              /*!< Reference resistor tap for setting 10. */
N#define COMP_E_CTL2_REF1_11                      ((uint16_t)0x0B00)              /*!< Reference resistor tap for setting 11. */
N#define COMP_E_CTL2_REF1_12                      ((uint16_t)0x0C00)              /*!< Reference resistor tap for setting 12. */
N#define COMP_E_CTL2_REF1_13                      ((uint16_t)0x0D00)              /*!< Reference resistor tap for setting 13. */
N#define COMP_E_CTL2_REF1_14                      ((uint16_t)0x0E00)              /*!< Reference resistor tap for setting 14. */
N#define COMP_E_CTL2_REF1_15                      ((uint16_t)0x0F00)              /*!< Reference resistor tap for setting 15. */
N#define COMP_E_CTL2_REF1_16                      ((uint16_t)0x1000)              /*!< Reference resistor tap for setting 16. */
N#define COMP_E_CTL2_REF1_17                      ((uint16_t)0x1100)              /*!< Reference resistor tap for setting 17. */
N#define COMP_E_CTL2_REF1_18                      ((uint16_t)0x1200)              /*!< Reference resistor tap for setting 18. */
N#define COMP_E_CTL2_REF1_19                      ((uint16_t)0x1300)              /*!< Reference resistor tap for setting 19. */
N#define COMP_E_CTL2_REF1_20                      ((uint16_t)0x1400)              /*!< Reference resistor tap for setting 20. */
N#define COMP_E_CTL2_REF1_21                      ((uint16_t)0x1500)              /*!< Reference resistor tap for setting 21. */
N#define COMP_E_CTL2_REF1_22                      ((uint16_t)0x1600)              /*!< Reference resistor tap for setting 22. */
N#define COMP_E_CTL2_REF1_23                      ((uint16_t)0x1700)              /*!< Reference resistor tap for setting 23. */
N#define COMP_E_CTL2_REF1_24                      ((uint16_t)0x1800)              /*!< Reference resistor tap for setting 24. */
N#define COMP_E_CTL2_REF1_25                      ((uint16_t)0x1900)              /*!< Reference resistor tap for setting 25. */
N#define COMP_E_CTL2_REF1_26                      ((uint16_t)0x1A00)              /*!< Reference resistor tap for setting 26. */
N#define COMP_E_CTL2_REF1_27                      ((uint16_t)0x1B00)              /*!< Reference resistor tap for setting 27. */
N#define COMP_E_CTL2_REF1_28                      ((uint16_t)0x1C00)              /*!< Reference resistor tap for setting 28. */
N#define COMP_E_CTL2_REF1_29                      ((uint16_t)0x1D00)              /*!< Reference resistor tap for setting 29. */
N#define COMP_E_CTL2_REF1_30                      ((uint16_t)0x1E00)              /*!< Reference resistor tap for setting 30. */
N#define COMP_E_CTL2_REF1_31                      ((uint16_t)0x1F00)              /*!< Reference resistor tap for setting 31. */
N/* COMP_E_CTL2[REFL] Bits */
N#define COMP_E_CTL2_REFL_OFS                     (13)                            /*!< CEREFL Bit Offset */
N#define COMP_E_CTL2_REFL_MASK                    ((uint16_t)0x6000)              /*!< CEREFL Bit Mask */
N#define COMP_E_CTL2_REFL0                        ((uint16_t)0x2000)              /*!< REFL Bit 0 */
N#define COMP_E_CTL2_REFL1                        ((uint16_t)0x4000)              /*!< REFL Bit 1 */
N#define COMP_E_CTL2_CEREFL_0                     ((uint16_t)0x0000)              /*!< Reference amplifier is disabled. No reference voltage is requested */
N#define COMP_E_CTL2_CEREFL_1                     ((uint16_t)0x2000)              /*!< 1.2 V is selected as shared reference voltage input */
N#define COMP_E_CTL2_CEREFL_2                     ((uint16_t)0x4000)              /*!< 2.0 V is selected as shared reference voltage input */
N#define COMP_E_CTL2_CEREFL_3                     ((uint16_t)0x6000)              /*!< 2.5 V is selected as shared reference voltage input */
N#define COMP_E_CTL2_REFL__OFF                    ((uint16_t)0x0000)              /*!< Reference amplifier is disabled. No reference voltage is requested */
N#define COMP_E_CTL2_REFL__1P2V                   ((uint16_t)0x2000)              /*!< 1.2 V is selected as shared reference voltage input */
N#define COMP_E_CTL2_REFL__2P0V                   ((uint16_t)0x4000)              /*!< 2.0 V is selected as shared reference voltage input */
N#define COMP_E_CTL2_REFL__2P5V                   ((uint16_t)0x6000)              /*!< 2.5 V is selected as shared reference voltage input */
N/* COMP_E_CTL2[REFACC] Bits */
N#define COMP_E_CTL2_REFACC_OFS                   (15)                            /*!< CEREFACC Bit Offset */
N#define COMP_E_CTL2_REFACC                       ((uint16_t)0x8000)              /*!< Reference accuracy */
N/* COMP_E_CTL3[PD0] Bits */
N#define COMP_E_CTL3_PD0_OFS                      ( 0)                            /*!< CEPD0 Bit Offset */
N#define COMP_E_CTL3_PD0                          ((uint16_t)0x0001)              /*!< Port disable */
N/* COMP_E_CTL3[PD1] Bits */
N#define COMP_E_CTL3_PD1_OFS                      ( 1)                            /*!< CEPD1 Bit Offset */
N#define COMP_E_CTL3_PD1                          ((uint16_t)0x0002)              /*!< Port disable */
N/* COMP_E_CTL3[PD2] Bits */
N#define COMP_E_CTL3_PD2_OFS                      ( 2)                            /*!< CEPD2 Bit Offset */
N#define COMP_E_CTL3_PD2                          ((uint16_t)0x0004)              /*!< Port disable */
N/* COMP_E_CTL3[PD3] Bits */
N#define COMP_E_CTL3_PD3_OFS                      ( 3)                            /*!< CEPD3 Bit Offset */
N#define COMP_E_CTL3_PD3                          ((uint16_t)0x0008)              /*!< Port disable */
N/* COMP_E_CTL3[PD4] Bits */
N#define COMP_E_CTL3_PD4_OFS                      ( 4)                            /*!< CEPD4 Bit Offset */
N#define COMP_E_CTL3_PD4                          ((uint16_t)0x0010)              /*!< Port disable */
N/* COMP_E_CTL3[PD5] Bits */
N#define COMP_E_CTL3_PD5_OFS                      ( 5)                            /*!< CEPD5 Bit Offset */
N#define COMP_E_CTL3_PD5                          ((uint16_t)0x0020)              /*!< Port disable */
N/* COMP_E_CTL3[PD6] Bits */
N#define COMP_E_CTL3_PD6_OFS                      ( 6)                            /*!< CEPD6 Bit Offset */
N#define COMP_E_CTL3_PD6                          ((uint16_t)0x0040)              /*!< Port disable */
N/* COMP_E_CTL3[PD7] Bits */
N#define COMP_E_CTL3_PD7_OFS                      ( 7)                            /*!< CEPD7 Bit Offset */
N#define COMP_E_CTL3_PD7                          ((uint16_t)0x0080)              /*!< Port disable */
N/* COMP_E_CTL3[PD8] Bits */
N#define COMP_E_CTL3_PD8_OFS                      ( 8)                            /*!< CEPD8 Bit Offset */
N#define COMP_E_CTL3_PD8                          ((uint16_t)0x0100)              /*!< Port disable */
N/* COMP_E_CTL3[PD9] Bits */
N#define COMP_E_CTL3_PD9_OFS                      ( 9)                            /*!< CEPD9 Bit Offset */
N#define COMP_E_CTL3_PD9                          ((uint16_t)0x0200)              /*!< Port disable */
N/* COMP_E_CTL3[PD10] Bits */
N#define COMP_E_CTL3_PD10_OFS                     (10)                            /*!< CEPD10 Bit Offset */
N#define COMP_E_CTL3_PD10                         ((uint16_t)0x0400)              /*!< Port disable */
N/* COMP_E_CTL3[PD11] Bits */
N#define COMP_E_CTL3_PD11_OFS                     (11)                            /*!< CEPD11 Bit Offset */
N#define COMP_E_CTL3_PD11                         ((uint16_t)0x0800)              /*!< Port disable */
N/* COMP_E_CTL3[PD12] Bits */
N#define COMP_E_CTL3_PD12_OFS                     (12)                            /*!< CEPD12 Bit Offset */
N#define COMP_E_CTL3_PD12                         ((uint16_t)0x1000)              /*!< Port disable */
N/* COMP_E_CTL3[PD13] Bits */
N#define COMP_E_CTL3_PD13_OFS                     (13)                            /*!< CEPD13 Bit Offset */
N#define COMP_E_CTL3_PD13                         ((uint16_t)0x2000)              /*!< Port disable */
N/* COMP_E_CTL3[PD14] Bits */
N#define COMP_E_CTL3_PD14_OFS                     (14)                            /*!< CEPD14 Bit Offset */
N#define COMP_E_CTL3_PD14                         ((uint16_t)0x4000)              /*!< Port disable */
N/* COMP_E_CTL3[PD15] Bits */
N#define COMP_E_CTL3_PD15_OFS                     (15)                            /*!< CEPD15 Bit Offset */
N#define COMP_E_CTL3_PD15                         ((uint16_t)0x8000)              /*!< Port disable */
N/* COMP_E_INT[IFG] Bits */
N#define COMP_E_INT_IFG_OFS                       ( 0)                            /*!< CEIFG Bit Offset */
N#define COMP_E_INT_IFG                           ((uint16_t)0x0001)              /*!< Comparator output interrupt flag */
N/* COMP_E_INT[IIFG] Bits */
N#define COMP_E_INT_IIFG_OFS                      ( 1)                            /*!< CEIIFG Bit Offset */
N#define COMP_E_INT_IIFG                          ((uint16_t)0x0002)              /*!< Comparator output inverted interrupt flag */
N/* COMP_E_INT[RDYIFG] Bits */
N#define COMP_E_INT_RDYIFG_OFS                    ( 4)                            /*!< CERDYIFG Bit Offset */
N#define COMP_E_INT_RDYIFG                        ((uint16_t)0x0010)              /*!< Comparator ready interrupt flag */
N/* COMP_E_INT[IE] Bits */
N#define COMP_E_INT_IE_OFS                        ( 8)                            /*!< CEIE Bit Offset */
N#define COMP_E_INT_IE                            ((uint16_t)0x0100)              /*!< Comparator output interrupt enable */
N/* COMP_E_INT[IIE] Bits */
N#define COMP_E_INT_IIE_OFS                       ( 9)                            /*!< CEIIE Bit Offset */
N#define COMP_E_INT_IIE                           ((uint16_t)0x0200)              /*!< Comparator output interrupt enable inverted polarity */
N/* COMP_E_INT[RDYIE] Bits */
N#define COMP_E_INT_RDYIE_OFS                     (12)                            /*!< CERDYIE Bit Offset */
N#define COMP_E_INT_RDYIE                         ((uint16_t)0x1000)              /*!< Comparator ready interrupt enable */
N
N/******************************************************************************
N* COREDEBUG Bits
N******************************************************************************/
N
N
N/******************************************************************************
N* CRC32 Bits
N******************************************************************************/
N
N/******************************************************************************
N* CS Bits
N******************************************************************************/
N/* CS_KEY[KEY] Bits */
N#define CS_KEY_KEY_OFS                           ( 0)                            /*!< CSKEY Bit Offset */
N#define CS_KEY_KEY_MASK                          ((uint32_t)0x0000FFFF)          /*!< CSKEY Bit Mask */
N/* CS_CTL0[DCOTUNE] Bits */
N#define CS_CTL0_DCOTUNE_OFS                      ( 0)                            /*!< DCOTUNE Bit Offset */
N#define CS_CTL0_DCOTUNE_MASK                     ((uint32_t)0x000003FF)          /*!< DCOTUNE Bit Mask */
N/* CS_CTL0[DCORSEL] Bits */
N#define CS_CTL0_DCORSEL_OFS                      (16)                            /*!< DCORSEL Bit Offset */
N#define CS_CTL0_DCORSEL_MASK                     ((uint32_t)0x00070000)          /*!< DCORSEL Bit Mask */
N#define CS_CTL0_DCORSEL0                         ((uint32_t)0x00010000)          /*!< DCORSEL Bit 0 */
N#define CS_CTL0_DCORSEL1                         ((uint32_t)0x00020000)          /*!< DCORSEL Bit 1 */
N#define CS_CTL0_DCORSEL2                         ((uint32_t)0x00040000)          /*!< DCORSEL Bit 2 */
N#define CS_CTL0_DCORSEL_0                        ((uint32_t)0x00000000)          /*!< Nominal DCO Frequency Range (MHz): 1 to 2 */
N#define CS_CTL0_DCORSEL_1                        ((uint32_t)0x00010000)          /*!< Nominal DCO Frequency Range (MHz): 2 to 4 */
N#define CS_CTL0_DCORSEL_2                        ((uint32_t)0x00020000)          /*!< Nominal DCO Frequency Range (MHz): 4 to 8 */
N#define CS_CTL0_DCORSEL_3                        ((uint32_t)0x00030000)          /*!< Nominal DCO Frequency Range (MHz): 8 to 16 */
N#define CS_CTL0_DCORSEL_4                        ((uint32_t)0x00040000)          /*!< Nominal DCO Frequency Range (MHz): 16 to 32 */
N#define CS_CTL0_DCORSEL_5                        ((uint32_t)0x00050000)          /*!< Nominal DCO Frequency Range (MHz): 32 to 64 */
N/* CS_CTL0[DCORES] Bits */
N#define CS_CTL0_DCORES_OFS                       (22)                            /*!< DCORES Bit Offset */
N#define CS_CTL0_DCORES                           ((uint32_t)0x00400000)          /*!< Enables the DCO external resistor mode */
N/* CS_CTL0[DCOEN] Bits */
N#define CS_CTL0_DCOEN_OFS                        (23)                            /*!< DCOEN Bit Offset */
N#define CS_CTL0_DCOEN                            ((uint32_t)0x00800000)          /*!< Enables the DCO oscillator */
N/* CS_CTL1[SELM] Bits */
N#define CS_CTL1_SELM_OFS                         ( 0)                            /*!< SELM Bit Offset */
N#define CS_CTL1_SELM_MASK                        ((uint32_t)0x00000007)          /*!< SELM Bit Mask */
N#define CS_CTL1_SELM0                            ((uint32_t)0x00000001)          /*!< SELM Bit 0 */
N#define CS_CTL1_SELM1                            ((uint32_t)0x00000002)          /*!< SELM Bit 1 */
N#define CS_CTL1_SELM2                            ((uint32_t)0x00000004)          /*!< SELM Bit 2 */
N#define CS_CTL1_SELM_0                           ((uint32_t)0x00000000)          /*!< when LFXT available, otherwise REFOCLK */
N#define CS_CTL1_SELM_1                           ((uint32_t)0x00000001)          
N#define CS_CTL1_SELM_2                           ((uint32_t)0x00000002)          
N#define CS_CTL1_SELM_3                           ((uint32_t)0x00000003)          
N#define CS_CTL1_SELM_4                           ((uint32_t)0x00000004)          
N#define CS_CTL1_SELM_5                           ((uint32_t)0x00000005)          /*!< when HFXT available, otherwise DCOCLK */
N#define CS_CTL1_SELM_6                           ((uint32_t)0x00000006)          /*!< when HFXT2 available, otherwise DCOCLK */
N#define CS_CTL1_SELM__LFXTCLK                    ((uint32_t)0x00000000)          /*!< when LFXT available, otherwise REFOCLK */
N#define CS_CTL1_SELM__VLOCLK                     ((uint32_t)0x00000001)          
N#define CS_CTL1_SELM__REFOCLK                    ((uint32_t)0x00000002)          
N#define CS_CTL1_SELM__DCOCLK                     ((uint32_t)0x00000003)          
N#define CS_CTL1_SELM__MODOSC                     ((uint32_t)0x00000004)          
N#define CS_CTL1_SELM__HFXTCLK                    ((uint32_t)0x00000005)          /*!< when HFXT available, otherwise DCOCLK */
N#define CS_CTL1_SELM__HFXT2CLK                   ((uint32_t)0x00000006)          /*!< when HFXT2 available, otherwise DCOCLK */
N/* CS_CTL1[SELS] Bits */
N#define CS_CTL1_SELS_OFS                         ( 4)                            /*!< SELS Bit Offset */
N#define CS_CTL1_SELS_MASK                        ((uint32_t)0x00000070)          /*!< SELS Bit Mask */
N#define CS_CTL1_SELS0                            ((uint32_t)0x00000010)          /*!< SELS Bit 0 */
N#define CS_CTL1_SELS1                            ((uint32_t)0x00000020)          /*!< SELS Bit 1 */
N#define CS_CTL1_SELS2                            ((uint32_t)0x00000040)          /*!< SELS Bit 2 */
N#define CS_CTL1_SELS_0                           ((uint32_t)0x00000000)          /*!< when LFXT available, otherwise REFOCLK */
N#define CS_CTL1_SELS_1                           ((uint32_t)0x00000010)          
N#define CS_CTL1_SELS_2                           ((uint32_t)0x00000020)          
N#define CS_CTL1_SELS_3                           ((uint32_t)0x00000030)          
N#define CS_CTL1_SELS_4                           ((uint32_t)0x00000040)          
N#define CS_CTL1_SELS_5                           ((uint32_t)0x00000050)          /*!< when HFXT available, otherwise DCOCLK */
N#define CS_CTL1_SELS_6                           ((uint32_t)0x00000060)          /*!< when HFXT2 available, otherwise DCOCLK */
N#define CS_CTL1_SELS__LFXTCLK                    ((uint32_t)0x00000000)          /*!< when LFXT available, otherwise REFOCLK */
N#define CS_CTL1_SELS__VLOCLK                     ((uint32_t)0x00000010)          
N#define CS_CTL1_SELS__REFOCLK                    ((uint32_t)0x00000020)          
N#define CS_CTL1_SELS__DCOCLK                     ((uint32_t)0x00000030)          
N#define CS_CTL1_SELS__MODOSC                     ((uint32_t)0x00000040)          
N#define CS_CTL1_SELS__HFXTCLK                    ((uint32_t)0x00000050)          /*!< when HFXT available, otherwise DCOCLK */
N#define CS_CTL1_SELS__HFXT2CLK                   ((uint32_t)0x00000060)          /*!< when HFXT2 available, otherwise DCOCLK */
N/* CS_CTL1[SELA] Bits */
N#define CS_CTL1_SELA_OFS                         ( 8)                            /*!< SELA Bit Offset */
N#define CS_CTL1_SELA_MASK                        ((uint32_t)0x00000700)          /*!< SELA Bit Mask */
N#define CS_CTL1_SELA0                            ((uint32_t)0x00000100)          /*!< SELA Bit 0 */
N#define CS_CTL1_SELA1                            ((uint32_t)0x00000200)          /*!< SELA Bit 1 */
N#define CS_CTL1_SELA2                            ((uint32_t)0x00000400)          /*!< SELA Bit 2 */
N#define CS_CTL1_SELA_0                           ((uint32_t)0x00000000)          /*!< when LFXT available, otherwise REFOCLK */
N#define CS_CTL1_SELA_1                           ((uint32_t)0x00000100)          
N#define CS_CTL1_SELA_2                           ((uint32_t)0x00000200)          
N#define CS_CTL1_SELA__LFXTCLK                    ((uint32_t)0x00000000)          /*!< when LFXT available, otherwise REFOCLK */
N#define CS_CTL1_SELA__VLOCLK                     ((uint32_t)0x00000100)          
N#define CS_CTL1_SELA__REFOCLK                    ((uint32_t)0x00000200)          
N/* CS_CTL1[SELB] Bits */
N#define CS_CTL1_SELB_OFS                         (12)                            /*!< SELB Bit Offset */
N#define CS_CTL1_SELB                             ((uint32_t)0x00001000)          /*!< Selects the BCLK source */
N/* CS_CTL1[DIVM] Bits */
N#define CS_CTL1_DIVM_OFS                         (16)                            /*!< DIVM Bit Offset */
N#define CS_CTL1_DIVM_MASK                        ((uint32_t)0x00070000)          /*!< DIVM Bit Mask */
N#define CS_CTL1_DIVM0                            ((uint32_t)0x00010000)          /*!< DIVM Bit 0 */
N#define CS_CTL1_DIVM1                            ((uint32_t)0x00020000)          /*!< DIVM Bit 1 */
N#define CS_CTL1_DIVM2                            ((uint32_t)0x00040000)          /*!< DIVM Bit 2 */
N#define CS_CTL1_DIVM_0                           ((uint32_t)0x00000000)          /*!< f(MCLK)/1 */
N#define CS_CTL1_DIVM_1                           ((uint32_t)0x00010000)          /*!< f(MCLK)/2 */
N#define CS_CTL1_DIVM_2                           ((uint32_t)0x00020000)          /*!< f(MCLK)/4 */
N#define CS_CTL1_DIVM_3                           ((uint32_t)0x00030000)          /*!< f(MCLK)/8 */
N#define CS_CTL1_DIVM_4                           ((uint32_t)0x00040000)          /*!< f(MCLK)/16 */
N#define CS_CTL1_DIVM_5                           ((uint32_t)0x00050000)          /*!< f(MCLK)/32 */
N#define CS_CTL1_DIVM_6                           ((uint32_t)0x00060000)          /*!< f(MCLK)/64 */
N#define CS_CTL1_DIVM_7                           ((uint32_t)0x00070000)          /*!< f(MCLK)/128 */
N#define CS_CTL1_DIVM__1                          ((uint32_t)0x00000000)          /*!< f(MCLK)/1 */
N#define CS_CTL1_DIVM__2                          ((uint32_t)0x00010000)          /*!< f(MCLK)/2 */
N#define CS_CTL1_DIVM__4                          ((uint32_t)0x00020000)          /*!< f(MCLK)/4 */
N#define CS_CTL1_DIVM__8                          ((uint32_t)0x00030000)          /*!< f(MCLK)/8 */
N#define CS_CTL1_DIVM__16                         ((uint32_t)0x00040000)          /*!< f(MCLK)/16 */
N#define CS_CTL1_DIVM__32                         ((uint32_t)0x00050000)          /*!< f(MCLK)/32 */
N#define CS_CTL1_DIVM__64                         ((uint32_t)0x00060000)          /*!< f(MCLK)/64 */
N#define CS_CTL1_DIVM__128                        ((uint32_t)0x00070000)          /*!< f(MCLK)/128 */
N/* CS_CTL1[DIVHS] Bits */
N#define CS_CTL1_DIVHS_OFS                        (20)                            /*!< DIVHS Bit Offset */
N#define CS_CTL1_DIVHS_MASK                       ((uint32_t)0x00700000)          /*!< DIVHS Bit Mask */
N#define CS_CTL1_DIVHS0                           ((uint32_t)0x00100000)          /*!< DIVHS Bit 0 */
N#define CS_CTL1_DIVHS1                           ((uint32_t)0x00200000)          /*!< DIVHS Bit 1 */
N#define CS_CTL1_DIVHS2                           ((uint32_t)0x00400000)          /*!< DIVHS Bit 2 */
N#define CS_CTL1_DIVHS_0                          ((uint32_t)0x00000000)          /*!< f(HSMCLK)/1 */
N#define CS_CTL1_DIVHS_1                          ((uint32_t)0x00100000)          /*!< f(HSMCLK)/2 */
N#define CS_CTL1_DIVHS_2                          ((uint32_t)0x00200000)          /*!< f(HSMCLK)/4 */
N#define CS_CTL1_DIVHS_3                          ((uint32_t)0x00300000)          /*!< f(HSMCLK)/8 */
N#define CS_CTL1_DIVHS_4                          ((uint32_t)0x00400000)          /*!< f(HSMCLK)/16 */
N#define CS_CTL1_DIVHS_5                          ((uint32_t)0x00500000)          /*!< f(HSMCLK)/32 */
N#define CS_CTL1_DIVHS_6                          ((uint32_t)0x00600000)          /*!< f(HSMCLK)/64 */
N#define CS_CTL1_DIVHS_7                          ((uint32_t)0x00700000)          /*!< f(HSMCLK)/128 */
N#define CS_CTL1_DIVHS__1                         ((uint32_t)0x00000000)          /*!< f(HSMCLK)/1 */
N#define CS_CTL1_DIVHS__2                         ((uint32_t)0x00100000)          /*!< f(HSMCLK)/2 */
N#define CS_CTL1_DIVHS__4                         ((uint32_t)0x00200000)          /*!< f(HSMCLK)/4 */
N#define CS_CTL1_DIVHS__8                         ((uint32_t)0x00300000)          /*!< f(HSMCLK)/8 */
N#define CS_CTL1_DIVHS__16                        ((uint32_t)0x00400000)          /*!< f(HSMCLK)/16 */
N#define CS_CTL1_DIVHS__32                        ((uint32_t)0x00500000)          /*!< f(HSMCLK)/32 */
N#define CS_CTL1_DIVHS__64                        ((uint32_t)0x00600000)          /*!< f(HSMCLK)/64 */
N#define CS_CTL1_DIVHS__128                       ((uint32_t)0x00700000)          /*!< f(HSMCLK)/128 */
N/* CS_CTL1[DIVA] Bits */
N#define CS_CTL1_DIVA_OFS                         (24)                            /*!< DIVA Bit Offset */
N#define CS_CTL1_DIVA_MASK                        ((uint32_t)0x07000000)          /*!< DIVA Bit Mask */
N#define CS_CTL1_DIVA0                            ((uint32_t)0x01000000)          /*!< DIVA Bit 0 */
N#define CS_CTL1_DIVA1                            ((uint32_t)0x02000000)          /*!< DIVA Bit 1 */
N#define CS_CTL1_DIVA2                            ((uint32_t)0x04000000)          /*!< DIVA Bit 2 */
N#define CS_CTL1_DIVA_0                           ((uint32_t)0x00000000)          /*!< f(ACLK)/1 */
N#define CS_CTL1_DIVA_1                           ((uint32_t)0x01000000)          /*!< f(ACLK)/2 */
N#define CS_CTL1_DIVA_2                           ((uint32_t)0x02000000)          /*!< f(ACLK)/4 */
N#define CS_CTL1_DIVA_3                           ((uint32_t)0x03000000)          /*!< f(ACLK)/8 */
N#define CS_CTL1_DIVA_4                           ((uint32_t)0x04000000)          /*!< f(ACLK)/16 */
N#define CS_CTL1_DIVA_5                           ((uint32_t)0x05000000)          /*!< f(ACLK)/32 */
N#define CS_CTL1_DIVA_6                           ((uint32_t)0x06000000)          /*!< f(ACLK)/64 */
N#define CS_CTL1_DIVA_7                           ((uint32_t)0x07000000)          /*!< f(ACLK)/128 */
N#define CS_CTL1_DIVA__1                          ((uint32_t)0x00000000)          /*!< f(ACLK)/1 */
N#define CS_CTL1_DIVA__2                          ((uint32_t)0x01000000)          /*!< f(ACLK)/2 */
N#define CS_CTL1_DIVA__4                          ((uint32_t)0x02000000)          /*!< f(ACLK)/4 */
N#define CS_CTL1_DIVA__8                          ((uint32_t)0x03000000)          /*!< f(ACLK)/8 */
N#define CS_CTL1_DIVA__16                         ((uint32_t)0x04000000)          /*!< f(ACLK)/16 */
N#define CS_CTL1_DIVA__32                         ((uint32_t)0x05000000)          /*!< f(ACLK)/32 */
N#define CS_CTL1_DIVA__64                         ((uint32_t)0x06000000)          /*!< f(ACLK)/64 */
N#define CS_CTL1_DIVA__128                        ((uint32_t)0x07000000)          /*!< f(ACLK)/128 */
N/* CS_CTL1[DIVS] Bits */
N#define CS_CTL1_DIVS_OFS                         (28)                            /*!< DIVS Bit Offset */
N#define CS_CTL1_DIVS_MASK                        ((uint32_t)0x70000000)          /*!< DIVS Bit Mask */
N#define CS_CTL1_DIVS0                            ((uint32_t)0x10000000)          /*!< DIVS Bit 0 */
N#define CS_CTL1_DIVS1                            ((uint32_t)0x20000000)          /*!< DIVS Bit 1 */
N#define CS_CTL1_DIVS2                            ((uint32_t)0x40000000)          /*!< DIVS Bit 2 */
N#define CS_CTL1_DIVS_0                           ((uint32_t)0x00000000)          /*!< f(SMCLK)/1 */
N#define CS_CTL1_DIVS_1                           ((uint32_t)0x10000000)          /*!< f(SMCLK)/2 */
N#define CS_CTL1_DIVS_2                           ((uint32_t)0x20000000)          /*!< f(SMCLK)/4 */
N#define CS_CTL1_DIVS_3                           ((uint32_t)0x30000000)          /*!< f(SMCLK)/8 */
N#define CS_CTL1_DIVS_4                           ((uint32_t)0x40000000)          /*!< f(SMCLK)/16 */
N#define CS_CTL1_DIVS_5                           ((uint32_t)0x50000000)          /*!< f(SMCLK)/32 */
N#define CS_CTL1_DIVS_6                           ((uint32_t)0x60000000)          /*!< f(SMCLK)/64 */
N#define CS_CTL1_DIVS_7                           ((uint32_t)0x70000000)          /*!< f(SMCLK)/128 */
N#define CS_CTL1_DIVS__1                          ((uint32_t)0x00000000)          /*!< f(SMCLK)/1 */
N#define CS_CTL1_DIVS__2                          ((uint32_t)0x10000000)          /*!< f(SMCLK)/2 */
N#define CS_CTL1_DIVS__4                          ((uint32_t)0x20000000)          /*!< f(SMCLK)/4 */
N#define CS_CTL1_DIVS__8                          ((uint32_t)0x30000000)          /*!< f(SMCLK)/8 */
N#define CS_CTL1_DIVS__16                         ((uint32_t)0x40000000)          /*!< f(SMCLK)/16 */
N#define CS_CTL1_DIVS__32                         ((uint32_t)0x50000000)          /*!< f(SMCLK)/32 */
N#define CS_CTL1_DIVS__64                         ((uint32_t)0x60000000)          /*!< f(SMCLK)/64 */
N#define CS_CTL1_DIVS__128                        ((uint32_t)0x70000000)          /*!< f(SMCLK)/128 */
N/* CS_CTL2[LFXTDRIVE] Bits */
N#define CS_CTL2_LFXTDRIVE_OFS                    ( 0)                            /*!< LFXTDRIVE Bit Offset */
N#define CS_CTL2_LFXTDRIVE_MASK                   ((uint32_t)0x00000003)          /*!< LFXTDRIVE Bit Mask */
N#define CS_CTL2_LFXTDRIVE0                       ((uint32_t)0x00000001)          /*!< LFXTDRIVE Bit 0 */
N#define CS_CTL2_LFXTDRIVE1                       ((uint32_t)0x00000002)          /*!< LFXTDRIVE Bit 1 */
N#define CS_CTL2_LFXTDRIVE_0                      ((uint32_t)0x00000000)          /*!< Lowest drive strength and current consumption LFXT oscillator. */
N#define CS_CTL2_LFXTDRIVE_1                      ((uint32_t)0x00000001)          /*!< Increased drive strength LFXT oscillator. */
N#define CS_CTL2_LFXTDRIVE_2                      ((uint32_t)0x00000002)          /*!< Increased drive strength LFXT oscillator. */
N#define CS_CTL2_LFXTDRIVE_3                      ((uint32_t)0x00000003)          /*!< Maximum drive strength and maximum current consumption LFXT oscillator. */
N/* CS_CTL2[LFXT_EN] Bits */
N#define CS_CTL2_LFXT_EN_OFS                      ( 8)                            /*!< LFXT_EN Bit Offset */
N#define CS_CTL2_LFXT_EN                          ((uint32_t)0x00000100)          /*!< Turns on the LFXT oscillator regardless if used as a clock resource */
N/* CS_CTL2[LFXTBYPASS] Bits */
N#define CS_CTL2_LFXTBYPASS_OFS                   ( 9)                            /*!< LFXTBYPASS Bit Offset */
N#define CS_CTL2_LFXTBYPASS                       ((uint32_t)0x00000200)          /*!< LFXT bypass select */
N/* CS_CTL2[HFXTDRIVE] Bits */
N#define CS_CTL2_HFXTDRIVE_OFS                    (16)                            /*!< HFXTDRIVE Bit Offset */
N#define CS_CTL2_HFXTDRIVE                        ((uint32_t)0x00010000)          /*!< HFXT oscillator drive selection */
N/* CS_CTL2[HFXTFREQ] Bits */
N#define CS_CTL2_HFXTFREQ_OFS                     (20)                            /*!< HFXTFREQ Bit Offset */
N#define CS_CTL2_HFXTFREQ_MASK                    ((uint32_t)0x00700000)          /*!< HFXTFREQ Bit Mask */
N#define CS_CTL2_HFXTFREQ0                        ((uint32_t)0x00100000)          /*!< HFXTFREQ Bit 0 */
N#define CS_CTL2_HFXTFREQ1                        ((uint32_t)0x00200000)          /*!< HFXTFREQ Bit 1 */
N#define CS_CTL2_HFXTFREQ2                        ((uint32_t)0x00400000)          /*!< HFXTFREQ Bit 2 */
N#define CS_CTL2_HFXTFREQ_0                       ((uint32_t)0x00000000)          /*!< 1 MHz to 4 MHz */
N#define CS_CTL2_HFXTFREQ_1                       ((uint32_t)0x00100000)          /*!< >4 MHz to 8 MHz */
N#define CS_CTL2_HFXTFREQ_2                       ((uint32_t)0x00200000)          /*!< >8 MHz to 16 MHz */
N#define CS_CTL2_HFXTFREQ_3                       ((uint32_t)0x00300000)          /*!< >16 MHz to 24 MHz */
N#define CS_CTL2_HFXTFREQ_4                       ((uint32_t)0x00400000)          /*!< >24 MHz to 32 MHz */
N#define CS_CTL2_HFXTFREQ_5                       ((uint32_t)0x00500000)          /*!< >32 MHz to 40 MHz */
N#define CS_CTL2_HFXTFREQ_6                       ((uint32_t)0x00600000)          /*!< >40 MHz to 48 MHz */
N#define CS_CTL2_HFXTFREQ_7                       ((uint32_t)0x00700000)          /*!< Reserved for future use. */
N/* CS_CTL2[HFXT_EN] Bits */
N#define CS_CTL2_HFXT_EN_OFS                      (24)                            /*!< HFXT_EN Bit Offset */
N#define CS_CTL2_HFXT_EN                          ((uint32_t)0x01000000)          /*!< Turns on the HFXT oscillator regardless if used as a clock resource */
N/* CS_CTL2[HFXTBYPASS] Bits */
N#define CS_CTL2_HFXTBYPASS_OFS                   (25)                            /*!< HFXTBYPASS Bit Offset */
N#define CS_CTL2_HFXTBYPASS                       ((uint32_t)0x02000000)          /*!< HFXT bypass select */
N/* CS_CTL3[FCNTLF] Bits */
N#define CS_CTL3_FCNTLF_OFS                       ( 0)                            /*!< FCNTLF Bit Offset */
N#define CS_CTL3_FCNTLF_MASK                      ((uint32_t)0x00000003)          /*!< FCNTLF Bit Mask */
N#define CS_CTL3_FCNTLF0                          ((uint32_t)0x00000001)          /*!< FCNTLF Bit 0 */
N#define CS_CTL3_FCNTLF1                          ((uint32_t)0x00000002)          /*!< FCNTLF Bit 1 */
N#define CS_CTL3_FCNTLF_0                         ((uint32_t)0x00000000)          /*!< 4096 cycles */
N#define CS_CTL3_FCNTLF_1                         ((uint32_t)0x00000001)          /*!< 8192 cycles */
N#define CS_CTL3_FCNTLF_2                         ((uint32_t)0x00000002)          /*!< 16384 cycles */
N#define CS_CTL3_FCNTLF_3                         ((uint32_t)0x00000003)          /*!< 32768 cycles */
N#define CS_CTL3_FCNTLF__4096                     ((uint32_t)0x00000000)          /*!< 4096 cycles */
N#define CS_CTL3_FCNTLF__8192                     ((uint32_t)0x00000001)          /*!< 8192 cycles */
N#define CS_CTL3_FCNTLF__16384                    ((uint32_t)0x00000002)          /*!< 16384 cycles */
N#define CS_CTL3_FCNTLF__32768                    ((uint32_t)0x00000003)          /*!< 32768 cycles */
N/* CS_CTL3[RFCNTLF] Bits */
N#define CS_CTL3_RFCNTLF_OFS                      ( 2)                            /*!< RFCNTLF Bit Offset */
N#define CS_CTL3_RFCNTLF                          ((uint32_t)0x00000004)          /*!< Reset start fault counter for LFXT */
N/* CS_CTL3[FCNTLF_EN] Bits */
N#define CS_CTL3_FCNTLF_EN_OFS                    ( 3)                            /*!< FCNTLF_EN Bit Offset */
N#define CS_CTL3_FCNTLF_EN                        ((uint32_t)0x00000008)          /*!< Enable start fault counter for LFXT */
N/* CS_CTL3[FCNTHF] Bits */
N#define CS_CTL3_FCNTHF_OFS                       ( 4)                            /*!< FCNTHF Bit Offset */
N#define CS_CTL3_FCNTHF_MASK                      ((uint32_t)0x00000030)          /*!< FCNTHF Bit Mask */
N#define CS_CTL3_FCNTHF0                          ((uint32_t)0x00000010)          /*!< FCNTHF Bit 0 */
N#define CS_CTL3_FCNTHF1                          ((uint32_t)0x00000020)          /*!< FCNTHF Bit 1 */
N#define CS_CTL3_FCNTHF_0                         ((uint32_t)0x00000000)          /*!< 2048 cycles */
N#define CS_CTL3_FCNTHF_1                         ((uint32_t)0x00000010)          /*!< 4096 cycles */
N#define CS_CTL3_FCNTHF_2                         ((uint32_t)0x00000020)          /*!< 8192 cycles */
N#define CS_CTL3_FCNTHF_3                         ((uint32_t)0x00000030)          /*!< 16384 cycles */
N#define CS_CTL3_FCNTHF__2048                     ((uint32_t)0x00000000)          /*!< 2048 cycles */
N#define CS_CTL3_FCNTHF__4096                     ((uint32_t)0x00000010)          /*!< 4096 cycles */
N#define CS_CTL3_FCNTHF__8192                     ((uint32_t)0x00000020)          /*!< 8192 cycles */
N#define CS_CTL3_FCNTHF__16384                    ((uint32_t)0x00000030)          /*!< 16384 cycles */
N/* CS_CTL3[RFCNTHF] Bits */
N#define CS_CTL3_RFCNTHF_OFS                      ( 6)                            /*!< RFCNTHF Bit Offset */
N#define CS_CTL3_RFCNTHF                          ((uint32_t)0x00000040)          /*!< Reset start fault counter for HFXT */
N/* CS_CTL3[FCNTHF_EN] Bits */
N#define CS_CTL3_FCNTHF_EN_OFS                    ( 7)                            /*!< FCNTHF_EN Bit Offset */
N#define CS_CTL3_FCNTHF_EN                        ((uint32_t)0x00000080)          /*!< Enable start fault counter for HFXT */
N/* CS_CLKEN[ACLK_EN] Bits */
N#define CS_CLKEN_ACLK_EN_OFS                     ( 0)                            /*!< ACLK_EN Bit Offset */
N#define CS_CLKEN_ACLK_EN                         ((uint32_t)0x00000001)          /*!< ACLK system clock conditional request enable */
N/* CS_CLKEN[MCLK_EN] Bits */
N#define CS_CLKEN_MCLK_EN_OFS                     ( 1)                            /*!< MCLK_EN Bit Offset */
N#define CS_CLKEN_MCLK_EN                         ((uint32_t)0x00000002)          /*!< MCLK system clock conditional request enable */
N/* CS_CLKEN[HSMCLK_EN] Bits */
N#define CS_CLKEN_HSMCLK_EN_OFS                   ( 2)                            /*!< HSMCLK_EN Bit Offset */
N#define CS_CLKEN_HSMCLK_EN                       ((uint32_t)0x00000004)          /*!< HSMCLK system clock conditional request enable */
N/* CS_CLKEN[SMCLK_EN] Bits */
N#define CS_CLKEN_SMCLK_EN_OFS                    ( 3)                            /*!< SMCLK_EN Bit Offset */
N#define CS_CLKEN_SMCLK_EN                        ((uint32_t)0x00000008)          /*!< SMCLK system clock conditional request enable */
N/* CS_CLKEN[VLO_EN] Bits */
N#define CS_CLKEN_VLO_EN_OFS                      ( 8)                            /*!< VLO_EN Bit Offset */
N#define CS_CLKEN_VLO_EN                          ((uint32_t)0x00000100)          /*!< Turns on the VLO oscillator */
N/* CS_CLKEN[REFO_EN] Bits */
N#define CS_CLKEN_REFO_EN_OFS                     ( 9)                            /*!< REFO_EN Bit Offset */
N#define CS_CLKEN_REFO_EN                         ((uint32_t)0x00000200)          /*!< Turns on the REFO oscillator */
N/* CS_CLKEN[MODOSC_EN] Bits */
N#define CS_CLKEN_MODOSC_EN_OFS                   (10)                            /*!< MODOSC_EN Bit Offset */
N#define CS_CLKEN_MODOSC_EN                       ((uint32_t)0x00000400)          /*!< Turns on the MODOSC oscillator */
N/* CS_CLKEN[REFOFSEL] Bits */
N#define CS_CLKEN_REFOFSEL_OFS                    (15)                            /*!< REFOFSEL Bit Offset */
N#define CS_CLKEN_REFOFSEL                        ((uint32_t)0x00008000)          /*!< Selects REFO nominal frequency */
N/* CS_STAT[DCO_ON] Bits */
N#define CS_STAT_DCO_ON_OFS                       ( 0)                            /*!< DCO_ON Bit Offset */
N#define CS_STAT_DCO_ON                           ((uint32_t)0x00000001)          /*!< DCO status */
N/* CS_STAT[DCOBIAS_ON] Bits */
N#define CS_STAT_DCOBIAS_ON_OFS                   ( 1)                            /*!< DCOBIAS_ON Bit Offset */
N#define CS_STAT_DCOBIAS_ON                       ((uint32_t)0x00000002)          /*!< DCO bias status */
N/* CS_STAT[HFXT_ON] Bits */
N#define CS_STAT_HFXT_ON_OFS                      ( 2)                            /*!< HFXT_ON Bit Offset */
N#define CS_STAT_HFXT_ON                          ((uint32_t)0x00000004)          /*!< HFXT status */
N/* CS_STAT[MODOSC_ON] Bits */
N#define CS_STAT_MODOSC_ON_OFS                    ( 4)                            /*!< MODOSC_ON Bit Offset */
N#define CS_STAT_MODOSC_ON                        ((uint32_t)0x00000010)          /*!< MODOSC status */
N/* CS_STAT[VLO_ON] Bits */
N#define CS_STAT_VLO_ON_OFS                       ( 5)                            /*!< VLO_ON Bit Offset */
N#define CS_STAT_VLO_ON                           ((uint32_t)0x00000020)          /*!< VLO status */
N/* CS_STAT[LFXT_ON] Bits */
N#define CS_STAT_LFXT_ON_OFS                      ( 6)                            /*!< LFXT_ON Bit Offset */
N#define CS_STAT_LFXT_ON                          ((uint32_t)0x00000040)          /*!< LFXT status */
N/* CS_STAT[REFO_ON] Bits */
N#define CS_STAT_REFO_ON_OFS                      ( 7)                            /*!< REFO_ON Bit Offset */
N#define CS_STAT_REFO_ON                          ((uint32_t)0x00000080)          /*!< REFO status */
N/* CS_STAT[ACLK_ON] Bits */
N#define CS_STAT_ACLK_ON_OFS                      (16)                            /*!< ACLK_ON Bit Offset */
N#define CS_STAT_ACLK_ON                          ((uint32_t)0x00010000)          /*!< ACLK system clock status */
N/* CS_STAT[MCLK_ON] Bits */
N#define CS_STAT_MCLK_ON_OFS                      (17)                            /*!< MCLK_ON Bit Offset */
N#define CS_STAT_MCLK_ON                          ((uint32_t)0x00020000)          /*!< MCLK system clock status */
N/* CS_STAT[HSMCLK_ON] Bits */
N#define CS_STAT_HSMCLK_ON_OFS                    (18)                            /*!< HSMCLK_ON Bit Offset */
N#define CS_STAT_HSMCLK_ON                        ((uint32_t)0x00040000)          /*!< HSMCLK system clock status */
N/* CS_STAT[SMCLK_ON] Bits */
N#define CS_STAT_SMCLK_ON_OFS                     (19)                            /*!< SMCLK_ON Bit Offset */
N#define CS_STAT_SMCLK_ON                         ((uint32_t)0x00080000)          /*!< SMCLK system clock status */
N/* CS_STAT[MODCLK_ON] Bits */
N#define CS_STAT_MODCLK_ON_OFS                    (20)                            /*!< MODCLK_ON Bit Offset */
N#define CS_STAT_MODCLK_ON                        ((uint32_t)0x00100000)          /*!< MODCLK system clock status */
N/* CS_STAT[VLOCLK_ON] Bits */
N#define CS_STAT_VLOCLK_ON_OFS                    (21)                            /*!< VLOCLK_ON Bit Offset */
N#define CS_STAT_VLOCLK_ON                        ((uint32_t)0x00200000)          /*!< VLOCLK system clock status */
N/* CS_STAT[LFXTCLK_ON] Bits */
N#define CS_STAT_LFXTCLK_ON_OFS                   (22)                            /*!< LFXTCLK_ON Bit Offset */
N#define CS_STAT_LFXTCLK_ON                       ((uint32_t)0x00400000)          /*!< LFXTCLK system clock status */
N/* CS_STAT[REFOCLK_ON] Bits */
N#define CS_STAT_REFOCLK_ON_OFS                   (23)                            /*!< REFOCLK_ON Bit Offset */
N#define CS_STAT_REFOCLK_ON                       ((uint32_t)0x00800000)          /*!< REFOCLK system clock status */
N/* CS_STAT[ACLK_READY] Bits */
N#define CS_STAT_ACLK_READY_OFS                   (24)                            /*!< ACLK_READY Bit Offset */
N#define CS_STAT_ACLK_READY                       ((uint32_t)0x01000000)          /*!< ACLK Ready status */
N/* CS_STAT[MCLK_READY] Bits */
N#define CS_STAT_MCLK_READY_OFS                   (25)                            /*!< MCLK_READY Bit Offset */
N#define CS_STAT_MCLK_READY                       ((uint32_t)0x02000000)          /*!< MCLK Ready status */
N/* CS_STAT[HSMCLK_READY] Bits */
N#define CS_STAT_HSMCLK_READY_OFS                 (26)                            /*!< HSMCLK_READY Bit Offset */
N#define CS_STAT_HSMCLK_READY                     ((uint32_t)0x04000000)          /*!< HSMCLK Ready status */
N/* CS_STAT[SMCLK_READY] Bits */
N#define CS_STAT_SMCLK_READY_OFS                  (27)                            /*!< SMCLK_READY Bit Offset */
N#define CS_STAT_SMCLK_READY                      ((uint32_t)0x08000000)          /*!< SMCLK Ready status */
N/* CS_STAT[BCLK_READY] Bits */
N#define CS_STAT_BCLK_READY_OFS                   (28)                            /*!< BCLK_READY Bit Offset */
N#define CS_STAT_BCLK_READY                       ((uint32_t)0x10000000)          /*!< BCLK Ready status */
N/* CS_IE[LFXTIE] Bits */
N#define CS_IE_LFXTIE_OFS                         ( 0)                            /*!< LFXTIE Bit Offset */
N#define CS_IE_LFXTIE                             ((uint32_t)0x00000001)          /*!< LFXT oscillator fault flag interrupt enable */
N/* CS_IE[HFXTIE] Bits */
N#define CS_IE_HFXTIE_OFS                         ( 1)                            /*!< HFXTIE Bit Offset */
N#define CS_IE_HFXTIE                             ((uint32_t)0x00000002)          /*!< HFXT oscillator fault flag interrupt enable */
N/* CS_IE[DCOR_OPNIE] Bits */
N#define CS_IE_DCOR_OPNIE_OFS                     ( 6)                            /*!< DCOR_OPNIE Bit Offset */
N#define CS_IE_DCOR_OPNIE                         ((uint32_t)0x00000040)          /*!< DCO external resistor open circuit fault flag interrupt enable. */
N/* CS_IE[FCNTLFIE] Bits */
N#define CS_IE_FCNTLFIE_OFS                       ( 8)                            /*!< FCNTLFIE Bit Offset */
N#define CS_IE_FCNTLFIE                           ((uint32_t)0x00000100)          /*!< Start fault counter interrupt enable LFXT */
N/* CS_IE[FCNTHFIE] Bits */
N#define CS_IE_FCNTHFIE_OFS                       ( 9)                            /*!< FCNTHFIE Bit Offset */
N#define CS_IE_FCNTHFIE                           ((uint32_t)0x00000200)          /*!< Start fault counter interrupt enable HFXT */
N/* CS_IFG[LFXTIFG] Bits */
N#define CS_IFG_LFXTIFG_OFS                       ( 0)                            /*!< LFXTIFG Bit Offset */
N#define CS_IFG_LFXTIFG                           ((uint32_t)0x00000001)          /*!< LFXT oscillator fault flag */
N/* CS_IFG[HFXTIFG] Bits */
N#define CS_IFG_HFXTIFG_OFS                       ( 1)                            /*!< HFXTIFG Bit Offset */
N#define CS_IFG_HFXTIFG                           ((uint32_t)0x00000002)          /*!< HFXT oscillator fault flag */
N/* CS_IFG[DCOR_SHTIFG] Bits */
N#define CS_IFG_DCOR_SHTIFG_OFS                   ( 5)                            /*!< DCOR_SHTIFG Bit Offset */
N#define CS_IFG_DCOR_SHTIFG                       ((uint32_t)0x00000020)          /*!< DCO external resistor short circuit fault flag. */
N/* CS_IFG[DCOR_OPNIFG] Bits */
N#define CS_IFG_DCOR_OPNIFG_OFS                   ( 6)                            /*!< DCOR_OPNIFG Bit Offset */
N#define CS_IFG_DCOR_OPNIFG                       ((uint32_t)0x00000040)          /*!< DCO external resistor open circuit fault flag. */
N/* CS_IFG[FCNTLFIFG] Bits */
N#define CS_IFG_FCNTLFIFG_OFS                     ( 8)                            /*!< FCNTLFIFG Bit Offset */
N#define CS_IFG_FCNTLFIFG                         ((uint32_t)0x00000100)          /*!< Start fault counter interrupt flag LFXT */
N/* CS_IFG[FCNTHFIFG] Bits */
N#define CS_IFG_FCNTHFIFG_OFS                     ( 9)                            /*!< FCNTHFIFG Bit Offset */
N#define CS_IFG_FCNTHFIFG                         ((uint32_t)0x00000200)          /*!< Start fault counter interrupt flag HFXT */
N/* CS_CLRIFG[CLR_LFXTIFG] Bits */
N#define CS_CLRIFG_CLR_LFXTIFG_OFS                ( 0)                            /*!< CLR_LFXTIFG Bit Offset */
N#define CS_CLRIFG_CLR_LFXTIFG                    ((uint32_t)0x00000001)          /*!< Clear LFXT oscillator fault interrupt flag */
N/* CS_CLRIFG[CLR_HFXTIFG] Bits */
N#define CS_CLRIFG_CLR_HFXTIFG_OFS                ( 1)                            /*!< CLR_HFXTIFG Bit Offset */
N#define CS_CLRIFG_CLR_HFXTIFG                    ((uint32_t)0x00000002)          /*!< Clear HFXT oscillator fault interrupt flag */
N/* CS_CLRIFG[CLR_DCOR_OPNIFG] Bits */
N#define CS_CLRIFG_CLR_DCOR_OPNIFG_OFS            ( 6)                            /*!< CLR_DCOR_OPNIFG Bit Offset */
N#define CS_CLRIFG_CLR_DCOR_OPNIFG                ((uint32_t)0x00000040)          /*!< Clear DCO external resistor open circuit fault interrupt flag. */
N/* CS_CLRIFG[CLR_FCNTLFIFG] Bits */
N#define CS_CLRIFG_CLR_FCNTLFIFG_OFS              ( 8)                            /*!< CLR_FCNTLFIFG Bit Offset */
N#define CS_CLRIFG_CLR_FCNTLFIFG                  ((uint32_t)0x00000100)          /*!< Start fault counter clear interrupt flag LFXT */
N/* CS_CLRIFG[CLR_FCNTHFIFG] Bits */
N#define CS_CLRIFG_CLR_FCNTHFIFG_OFS              ( 9)                            /*!< CLR_FCNTHFIFG Bit Offset */
N#define CS_CLRIFG_CLR_FCNTHFIFG                  ((uint32_t)0x00000200)          /*!< Start fault counter clear interrupt flag HFXT */
N/* CS_SETIFG[SET_LFXTIFG] Bits */
N#define CS_SETIFG_SET_LFXTIFG_OFS                ( 0)                            /*!< SET_LFXTIFG Bit Offset */
N#define CS_SETIFG_SET_LFXTIFG                    ((uint32_t)0x00000001)          /*!< Set LFXT oscillator fault interrupt flag */
N/* CS_SETIFG[SET_HFXTIFG] Bits */
N#define CS_SETIFG_SET_HFXTIFG_OFS                ( 1)                            /*!< SET_HFXTIFG Bit Offset */
N#define CS_SETIFG_SET_HFXTIFG                    ((uint32_t)0x00000002)          /*!< Set HFXT oscillator fault interrupt flag */
N/* CS_SETIFG[SET_DCOR_OPNIFG] Bits */
N#define CS_SETIFG_SET_DCOR_OPNIFG_OFS            ( 6)                            /*!< SET_DCOR_OPNIFG Bit Offset */
N#define CS_SETIFG_SET_DCOR_OPNIFG                ((uint32_t)0x00000040)          /*!< Set DCO external resistor open circuit fault interrupt flag. */
N/* CS_SETIFG[SET_FCNTHFIFG] Bits */
N#define CS_SETIFG_SET_FCNTHFIFG_OFS              ( 9)                            /*!< SET_FCNTHFIFG Bit Offset */
N#define CS_SETIFG_SET_FCNTHFIFG                  ((uint32_t)0x00000200)          /*!< Start fault counter set interrupt flag HFXT */
N/* CS_SETIFG[SET_FCNTLFIFG] Bits */
N#define CS_SETIFG_SET_FCNTLFIFG_OFS              ( 8)                            /*!< SET_FCNTLFIFG Bit Offset */
N#define CS_SETIFG_SET_FCNTLFIFG                  ((uint32_t)0x00000100)          /*!< Start fault counter set interrupt flag LFXT */
N/* CS_DCOERCAL0[DCO_TCCAL] Bits */
N#define CS_DCOERCAL0_DCO_TCCAL_OFS               ( 0)                            /*!< DCO_TCCAL Bit Offset */
N#define CS_DCOERCAL0_DCO_TCCAL_MASK              ((uint32_t)0x00000003)          /*!< DCO_TCCAL Bit Mask */
N/* CS_DCOERCAL0[DCO_FCAL_RSEL04] Bits */
N#define CS_DCOERCAL0_DCO_FCAL_RSEL04_OFS         (16)                            /*!< DCO_FCAL_RSEL04 Bit Offset */
N#define CS_DCOERCAL0_DCO_FCAL_RSEL04_MASK        ((uint32_t)0x03FF0000)          /*!< DCO_FCAL_RSEL04 Bit Mask */
N/* CS_DCOERCAL1[DCO_FCAL_RSEL5] Bits */
N#define CS_DCOERCAL1_DCO_FCAL_RSEL5_OFS          ( 0)                            /*!< DCO_FCAL_RSEL5 Bit Offset */
N#define CS_DCOERCAL1_DCO_FCAL_RSEL5_MASK         ((uint32_t)0x000003FF)          /*!< DCO_FCAL_RSEL5 Bit Mask */
N/* Pre-defined bitfield values */
N#define CS_KEY_VAL                               ((uint32_t)0x0000695A)          /*!< CS control key value */
N
N/******************************************************************************
N* DIO Bits
N******************************************************************************/
N/* DIO_IV[IV] Bits */
N#define DIO_PORT_IV_OFS                          ( 0)                            /*!< DIO Port IV Bit Offset */
N#define DIO_PORT_IV_MASK                         ((uint16_t)0x001F)              /*!< DIO Port IV Bit Mask */
N#define DIO_PORT_IV0                             ((uint16_t)0x0001)              /*!< DIO Port IV Bit 0 */
N#define DIO_PORT_IV1                             ((uint16_t)0x0002)              /*!< DIO Port IV Bit 1 */
N#define DIO_PORT_IV2                             ((uint16_t)0x0004)              /*!< DIO Port IV Bit 2 */
N#define DIO_PORT_IV3                             ((uint16_t)0x0008)              /*!< DIO Port IV Bit 3 */
N#define DIO_PORT_IV4                             ((uint16_t)0x0010)              /*!< DIO Port IV Bit 4 */
N#define DIO_PORT_IV_0                            ((uint16_t)0x0000)              /*!< No interrupt pending */
N#define DIO_PORT_IV_2                            ((uint16_t)0x0002)              /*!< Interrupt Source: Port x.0 interrupt; Interrupt Flag: IFG0; Interrupt  */
N                                                                                 /* Priority: Highest */
N#define DIO_PORT_IV_4                            ((uint16_t)0x0004)              /*!< Interrupt Source: Port x.1 interrupt; Interrupt Flag: IFG1 */
N#define DIO_PORT_IV_6                            ((uint16_t)0x0006)              /*!< Interrupt Source: Port x.2 interrupt; Interrupt Flag: IFG2 */
N#define DIO_PORT_IV_8                            ((uint16_t)0x0008)              /*!< Interrupt Source: Port x.3 interrupt; Interrupt Flag: IFG3 */
N#define DIO_PORT_IV_10                           ((uint16_t)0x000A)              /*!< Interrupt Source: Port x.4 interrupt; Interrupt Flag: IFG4 */
N#define DIO_PORT_IV_12                           ((uint16_t)0x000C)              /*!< Interrupt Source: Port x.5 interrupt; Interrupt Flag: IFG5 */
N#define DIO_PORT_IV_14                           ((uint16_t)0x000E)              /*!< Interrupt Source: Port x.6 interrupt; Interrupt Flag: IFG6 */
N#define DIO_PORT_IV_16                           ((uint16_t)0x0010)              /*!< Interrupt Source: Port x.7 interrupt; Interrupt Flag: IFG7; Interrupt  */
N                                                                                 /* Priority: Lowest */
N#define DIO_PORT_IV__NONE                        ((uint16_t)0x0000)              /*!< No interrupt pending */
N#define DIO_PORT_IV__IFG0                        ((uint16_t)0x0002)              /*!< Interrupt Source: Port x.0 interrupt; Interrupt Flag: IFG0; Interrupt  */
N                                                                                 /* Priority: Highest */
N#define DIO_PORT_IV__IFG1                        ((uint16_t)0x0004)              /*!< Interrupt Source: Port x.1 interrupt; Interrupt Flag: IFG1 */
N#define DIO_PORT_IV__IFG2                        ((uint16_t)0x0006)              /*!< Interrupt Source: Port x.2 interrupt; Interrupt Flag: IFG2 */
N#define DIO_PORT_IV__IFG3                        ((uint16_t)0x0008)              /*!< Interrupt Source: Port x.3 interrupt; Interrupt Flag: IFG3 */
N#define DIO_PORT_IV__IFG4                        ((uint16_t)0x000A)              /*!< Interrupt Source: Port x.4 interrupt; Interrupt Flag: IFG4 */
N#define DIO_PORT_IV__IFG5                        ((uint16_t)0x000C)              /*!< Interrupt Source: Port x.5 interrupt; Interrupt Flag: IFG5 */
N#define DIO_PORT_IV__IFG6                        ((uint16_t)0x000E)              /*!< Interrupt Source: Port x.6 interrupt; Interrupt Flag: IFG6 */
N#define DIO_PORT_IV__IFG7                        ((uint16_t)0x0010)              /*!< Interrupt Source: Port x.7 interrupt; Interrupt Flag: IFG7; Interrupt  */
N                                                                                 /* Priority: Lowest */
N
N
N/******************************************************************************
N* DMA Bits
N******************************************************************************/
N/* DMA_DEVICE_CFG[NUM_DMA_CHANNELS] Bits */
N#define DMA_DEVICE_CFG_NUM_DMA_CHANNELS_OFS      ( 0)                            /*!< NUM_DMA_CHANNELS Bit Offset */
N#define DMA_DEVICE_CFG_NUM_DMA_CHANNELS_MASK     ((uint32_t)0x000000FF)          /*!< NUM_DMA_CHANNELS Bit Mask */
N/* DMA_DEVICE_CFG[NUM_SRC_PER_CHANNEL] Bits */
N#define DMA_DEVICE_CFG_NUM_SRC_PER_CHANNEL_OFS   ( 8)                            /*!< NUM_SRC_PER_CHANNEL Bit Offset */
N#define DMA_DEVICE_CFG_NUM_SRC_PER_CHANNEL_MASK  ((uint32_t)0x0000FF00)          /*!< NUM_SRC_PER_CHANNEL Bit Mask */
N/* DMA_SW_CHTRIG[CH0] Bits */
N#define DMA_SW_CHTRIG_CH0_OFS                    ( 0)                            /*!< CH0 Bit Offset */
N#define DMA_SW_CHTRIG_CH0                        ((uint32_t)0x00000001)          /*!< Write 1, triggers DMA_CHANNEL0 */
N/* DMA_SW_CHTRIG[CH1] Bits */
N#define DMA_SW_CHTRIG_CH1_OFS                    ( 1)                            /*!< CH1 Bit Offset */
N#define DMA_SW_CHTRIG_CH1                        ((uint32_t)0x00000002)          /*!< Write 1, triggers DMA_CHANNEL1 */
N/* DMA_SW_CHTRIG[CH2] Bits */
N#define DMA_SW_CHTRIG_CH2_OFS                    ( 2)                            /*!< CH2 Bit Offset */
N#define DMA_SW_CHTRIG_CH2                        ((uint32_t)0x00000004)          /*!< Write 1, triggers DMA_CHANNEL2 */
N/* DMA_SW_CHTRIG[CH3] Bits */
N#define DMA_SW_CHTRIG_CH3_OFS                    ( 3)                            /*!< CH3 Bit Offset */
N#define DMA_SW_CHTRIG_CH3                        ((uint32_t)0x00000008)          /*!< Write 1, triggers DMA_CHANNEL3 */
N/* DMA_SW_CHTRIG[CH4] Bits */
N#define DMA_SW_CHTRIG_CH4_OFS                    ( 4)                            /*!< CH4 Bit Offset */
N#define DMA_SW_CHTRIG_CH4                        ((uint32_t)0x00000010)          /*!< Write 1, triggers DMA_CHANNEL4 */
N/* DMA_SW_CHTRIG[CH5] Bits */
N#define DMA_SW_CHTRIG_CH5_OFS                    ( 5)                            /*!< CH5 Bit Offset */
N#define DMA_SW_CHTRIG_CH5                        ((uint32_t)0x00000020)          /*!< Write 1, triggers DMA_CHANNEL5 */
N/* DMA_SW_CHTRIG[CH6] Bits */
N#define DMA_SW_CHTRIG_CH6_OFS                    ( 6)                            /*!< CH6 Bit Offset */
N#define DMA_SW_CHTRIG_CH6                        ((uint32_t)0x00000040)          /*!< Write 1, triggers DMA_CHANNEL6 */
N/* DMA_SW_CHTRIG[CH7] Bits */
N#define DMA_SW_CHTRIG_CH7_OFS                    ( 7)                            /*!< CH7 Bit Offset */
N#define DMA_SW_CHTRIG_CH7                        ((uint32_t)0x00000080)          /*!< Write 1, triggers DMA_CHANNEL7 */
N/* DMA_SW_CHTRIG[CH8] Bits */
N#define DMA_SW_CHTRIG_CH8_OFS                    ( 8)                            /*!< CH8 Bit Offset */
N#define DMA_SW_CHTRIG_CH8                        ((uint32_t)0x00000100)          /*!< Write 1, triggers DMA_CHANNEL8 */
N/* DMA_SW_CHTRIG[CH9] Bits */
N#define DMA_SW_CHTRIG_CH9_OFS                    ( 9)                            /*!< CH9 Bit Offset */
N#define DMA_SW_CHTRIG_CH9                        ((uint32_t)0x00000200)          /*!< Write 1, triggers DMA_CHANNEL9 */
N/* DMA_SW_CHTRIG[CH10] Bits */
N#define DMA_SW_CHTRIG_CH10_OFS                   (10)                            /*!< CH10 Bit Offset */
N#define DMA_SW_CHTRIG_CH10                       ((uint32_t)0x00000400)          /*!< Write 1, triggers DMA_CHANNEL10 */
N/* DMA_SW_CHTRIG[CH11] Bits */
N#define DMA_SW_CHTRIG_CH11_OFS                   (11)                            /*!< CH11 Bit Offset */
N#define DMA_SW_CHTRIG_CH11                       ((uint32_t)0x00000800)          /*!< Write 1, triggers DMA_CHANNEL11 */
N/* DMA_SW_CHTRIG[CH12] Bits */
N#define DMA_SW_CHTRIG_CH12_OFS                   (12)                            /*!< CH12 Bit Offset */
N#define DMA_SW_CHTRIG_CH12                       ((uint32_t)0x00001000)          /*!< Write 1, triggers DMA_CHANNEL12 */
N/* DMA_SW_CHTRIG[CH13] Bits */
N#define DMA_SW_CHTRIG_CH13_OFS                   (13)                            /*!< CH13 Bit Offset */
N#define DMA_SW_CHTRIG_CH13                       ((uint32_t)0x00002000)          /*!< Write 1, triggers DMA_CHANNEL13 */
N/* DMA_SW_CHTRIG[CH14] Bits */
N#define DMA_SW_CHTRIG_CH14_OFS                   (14)                            /*!< CH14 Bit Offset */
N#define DMA_SW_CHTRIG_CH14                       ((uint32_t)0x00004000)          /*!< Write 1, triggers DMA_CHANNEL14 */
N/* DMA_SW_CHTRIG[CH15] Bits */
N#define DMA_SW_CHTRIG_CH15_OFS                   (15)                            /*!< CH15 Bit Offset */
N#define DMA_SW_CHTRIG_CH15                       ((uint32_t)0x00008000)          /*!< Write 1, triggers DMA_CHANNEL15 */
N/* DMA_SW_CHTRIG[CH16] Bits */
N#define DMA_SW_CHTRIG_CH16_OFS                   (16)                            /*!< CH16 Bit Offset */
N#define DMA_SW_CHTRIG_CH16                       ((uint32_t)0x00010000)          /*!< Write 1, triggers DMA_CHANNEL16 */
N/* DMA_SW_CHTRIG[CH17] Bits */
N#define DMA_SW_CHTRIG_CH17_OFS                   (17)                            /*!< CH17 Bit Offset */
N#define DMA_SW_CHTRIG_CH17                       ((uint32_t)0x00020000)          /*!< Write 1, triggers DMA_CHANNEL17 */
N/* DMA_SW_CHTRIG[CH18] Bits */
N#define DMA_SW_CHTRIG_CH18_OFS                   (18)                            /*!< CH18 Bit Offset */
N#define DMA_SW_CHTRIG_CH18                       ((uint32_t)0x00040000)          /*!< Write 1, triggers DMA_CHANNEL18 */
N/* DMA_SW_CHTRIG[CH19] Bits */
N#define DMA_SW_CHTRIG_CH19_OFS                   (19)                            /*!< CH19 Bit Offset */
N#define DMA_SW_CHTRIG_CH19                       ((uint32_t)0x00080000)          /*!< Write 1, triggers DMA_CHANNEL19 */
N/* DMA_SW_CHTRIG[CH20] Bits */
N#define DMA_SW_CHTRIG_CH20_OFS                   (20)                            /*!< CH20 Bit Offset */
N#define DMA_SW_CHTRIG_CH20                       ((uint32_t)0x00100000)          /*!< Write 1, triggers DMA_CHANNEL20 */
N/* DMA_SW_CHTRIG[CH21] Bits */
N#define DMA_SW_CHTRIG_CH21_OFS                   (21)                            /*!< CH21 Bit Offset */
N#define DMA_SW_CHTRIG_CH21                       ((uint32_t)0x00200000)          /*!< Write 1, triggers DMA_CHANNEL21 */
N/* DMA_SW_CHTRIG[CH22] Bits */
N#define DMA_SW_CHTRIG_CH22_OFS                   (22)                            /*!< CH22 Bit Offset */
N#define DMA_SW_CHTRIG_CH22                       ((uint32_t)0x00400000)          /*!< Write 1, triggers DMA_CHANNEL22 */
N/* DMA_SW_CHTRIG[CH23] Bits */
N#define DMA_SW_CHTRIG_CH23_OFS                   (23)                            /*!< CH23 Bit Offset */
N#define DMA_SW_CHTRIG_CH23                       ((uint32_t)0x00800000)          /*!< Write 1, triggers DMA_CHANNEL23 */
N/* DMA_SW_CHTRIG[CH24] Bits */
N#define DMA_SW_CHTRIG_CH24_OFS                   (24)                            /*!< CH24 Bit Offset */
N#define DMA_SW_CHTRIG_CH24                       ((uint32_t)0x01000000)          /*!< Write 1, triggers DMA_CHANNEL24 */
N/* DMA_SW_CHTRIG[CH25] Bits */
N#define DMA_SW_CHTRIG_CH25_OFS                   (25)                            /*!< CH25 Bit Offset */
N#define DMA_SW_CHTRIG_CH25                       ((uint32_t)0x02000000)          /*!< Write 1, triggers DMA_CHANNEL25 */
N/* DMA_SW_CHTRIG[CH26] Bits */
N#define DMA_SW_CHTRIG_CH26_OFS                   (26)                            /*!< CH26 Bit Offset */
N#define DMA_SW_CHTRIG_CH26                       ((uint32_t)0x04000000)          /*!< Write 1, triggers DMA_CHANNEL26 */
N/* DMA_SW_CHTRIG[CH27] Bits */
N#define DMA_SW_CHTRIG_CH27_OFS                   (27)                            /*!< CH27 Bit Offset */
N#define DMA_SW_CHTRIG_CH27                       ((uint32_t)0x08000000)          /*!< Write 1, triggers DMA_CHANNEL27 */
N/* DMA_SW_CHTRIG[CH28] Bits */
N#define DMA_SW_CHTRIG_CH28_OFS                   (28)                            /*!< CH28 Bit Offset */
N#define DMA_SW_CHTRIG_CH28                       ((uint32_t)0x10000000)          /*!< Write 1, triggers DMA_CHANNEL28 */
N/* DMA_SW_CHTRIG[CH29] Bits */
N#define DMA_SW_CHTRIG_CH29_OFS                   (29)                            /*!< CH29 Bit Offset */
N#define DMA_SW_CHTRIG_CH29                       ((uint32_t)0x20000000)          /*!< Write 1, triggers DMA_CHANNEL29 */
N/* DMA_SW_CHTRIG[CH30] Bits */
N#define DMA_SW_CHTRIG_CH30_OFS                   (30)                            /*!< CH30 Bit Offset */
N#define DMA_SW_CHTRIG_CH30                       ((uint32_t)0x40000000)          /*!< Write 1, triggers DMA_CHANNEL30 */
N/* DMA_SW_CHTRIG[CH31] Bits */
N#define DMA_SW_CHTRIG_CH31_OFS                   (31)                            /*!< CH31 Bit Offset */
N#define DMA_SW_CHTRIG_CH31                       ((uint32_t)0x80000000)          /*!< Write 1, triggers DMA_CHANNEL31 */
N/* DMA_CHN_SRCCFG[DMA_SRC] Bits */
N#define DMA_CHN_SRCCFG_DMA_SRC_OFS               ( 0)                            /*!< DMA_SRC Bit Offset */
N#define DMA_CHN_SRCCFG_DMA_SRC_MASK              ((uint32_t)0x000000FF)          /*!< DMA_SRC Bit Mask */
N/* DMA_INT1_SRCCFG[INT_SRC] Bits */
N#define DMA_INT1_SRCCFG_INT_SRC_OFS              ( 0)                            /*!< INT_SRC Bit Offset */
N#define DMA_INT1_SRCCFG_INT_SRC_MASK             ((uint32_t)0x0000001F)          /*!< INT_SRC Bit Mask */
N/* DMA_INT1_SRCCFG[EN] Bits */
N#define DMA_INT1_SRCCFG_EN_OFS                   ( 5)                            /*!< EN Bit Offset */
N#define DMA_INT1_SRCCFG_EN                       ((uint32_t)0x00000020)          /*!< Enables DMA_INT1 mapping */
N/* DMA_INT2_SRCCFG[INT_SRC] Bits */
N#define DMA_INT2_SRCCFG_INT_SRC_OFS              ( 0)                            /*!< INT_SRC Bit Offset */
N#define DMA_INT2_SRCCFG_INT_SRC_MASK             ((uint32_t)0x0000001F)          /*!< INT_SRC Bit Mask */
N/* DMA_INT2_SRCCFG[EN] Bits */
N#define DMA_INT2_SRCCFG_EN_OFS                   ( 5)                            /*!< EN Bit Offset */
N#define DMA_INT2_SRCCFG_EN                       ((uint32_t)0x00000020)          /*!< Enables DMA_INT2 mapping */
N/* DMA_INT3_SRCCFG[INT_SRC] Bits */
N#define DMA_INT3_SRCCFG_INT_SRC_OFS              ( 0)                            /*!< INT_SRC Bit Offset */
N#define DMA_INT3_SRCCFG_INT_SRC_MASK             ((uint32_t)0x0000001F)          /*!< INT_SRC Bit Mask */
N/* DMA_INT3_SRCCFG[EN] Bits */
N#define DMA_INT3_SRCCFG_EN_OFS                   ( 5)                            /*!< EN Bit Offset */
N#define DMA_INT3_SRCCFG_EN                       ((uint32_t)0x00000020)          /*!< Enables DMA_INT3 mapping */
N/* DMA_INT0_SRCFLG[CH0] Bits */
N#define DMA_INT0_SRCFLG_CH0_OFS                  ( 0)                            /*!< CH0 Bit Offset */
N#define DMA_INT0_SRCFLG_CH0                      ((uint32_t)0x00000001)          /*!< Channel 0 was the source of DMA_INT0 */
N/* DMA_INT0_SRCFLG[CH1] Bits */
N#define DMA_INT0_SRCFLG_CH1_OFS                  ( 1)                            /*!< CH1 Bit Offset */
N#define DMA_INT0_SRCFLG_CH1                      ((uint32_t)0x00000002)          /*!< Channel 1 was the source of DMA_INT0 */
N/* DMA_INT0_SRCFLG[CH2] Bits */
N#define DMA_INT0_SRCFLG_CH2_OFS                  ( 2)                            /*!< CH2 Bit Offset */
N#define DMA_INT0_SRCFLG_CH2                      ((uint32_t)0x00000004)          /*!< Channel 2 was the source of DMA_INT0 */
N/* DMA_INT0_SRCFLG[CH3] Bits */
N#define DMA_INT0_SRCFLG_CH3_OFS                  ( 3)                            /*!< CH3 Bit Offset */
N#define DMA_INT0_SRCFLG_CH3                      ((uint32_t)0x00000008)          /*!< Channel 3 was the source of DMA_INT0 */
N/* DMA_INT0_SRCFLG[CH4] Bits */
N#define DMA_INT0_SRCFLG_CH4_OFS                  ( 4)                            /*!< CH4 Bit Offset */
N#define DMA_INT0_SRCFLG_CH4                      ((uint32_t)0x00000010)          /*!< Channel 4 was the source of DMA_INT0 */
N/* DMA_INT0_SRCFLG[CH5] Bits */
N#define DMA_INT0_SRCFLG_CH5_OFS                  ( 5)                            /*!< CH5 Bit Offset */
N#define DMA_INT0_SRCFLG_CH5                      ((uint32_t)0x00000020)          /*!< Channel 5 was the source of DMA_INT0 */
N/* DMA_INT0_SRCFLG[CH6] Bits */
N#define DMA_INT0_SRCFLG_CH6_OFS                  ( 6)                            /*!< CH6 Bit Offset */
N#define DMA_INT0_SRCFLG_CH6                      ((uint32_t)0x00000040)          /*!< Channel 6 was the source of DMA_INT0 */
N/* DMA_INT0_SRCFLG[CH7] Bits */
N#define DMA_INT0_SRCFLG_CH7_OFS                  ( 7)                            /*!< CH7 Bit Offset */
N#define DMA_INT0_SRCFLG_CH7                      ((uint32_t)0x00000080)          /*!< Channel 7 was the source of DMA_INT0 */
N/* DMA_INT0_SRCFLG[CH8] Bits */
N#define DMA_INT0_SRCFLG_CH8_OFS                  ( 8)                            /*!< CH8 Bit Offset */
N#define DMA_INT0_SRCFLG_CH8                      ((uint32_t)0x00000100)          /*!< Channel 8 was the source of DMA_INT0 */
N/* DMA_INT0_SRCFLG[CH9] Bits */
N#define DMA_INT0_SRCFLG_CH9_OFS                  ( 9)                            /*!< CH9 Bit Offset */
N#define DMA_INT0_SRCFLG_CH9                      ((uint32_t)0x00000200)          /*!< Channel 9 was the source of DMA_INT0 */
N/* DMA_INT0_SRCFLG[CH10] Bits */
N#define DMA_INT0_SRCFLG_CH10_OFS                 (10)                            /*!< CH10 Bit Offset */
N#define DMA_INT0_SRCFLG_CH10                     ((uint32_t)0x00000400)          /*!< Channel 10 was the source of DMA_INT0 */
N/* DMA_INT0_SRCFLG[CH11] Bits */
N#define DMA_INT0_SRCFLG_CH11_OFS                 (11)                            /*!< CH11 Bit Offset */
N#define DMA_INT0_SRCFLG_CH11                     ((uint32_t)0x00000800)          /*!< Channel 11 was the source of DMA_INT0 */
N/* DMA_INT0_SRCFLG[CH12] Bits */
N#define DMA_INT0_SRCFLG_CH12_OFS                 (12)                            /*!< CH12 Bit Offset */
N#define DMA_INT0_SRCFLG_CH12                     ((uint32_t)0x00001000)          /*!< Channel 12 was the source of DMA_INT0 */
N/* DMA_INT0_SRCFLG[CH13] Bits */
N#define DMA_INT0_SRCFLG_CH13_OFS                 (13)                            /*!< CH13 Bit Offset */
N#define DMA_INT0_SRCFLG_CH13                     ((uint32_t)0x00002000)          /*!< Channel 13 was the source of DMA_INT0 */
N/* DMA_INT0_SRCFLG[CH14] Bits */
N#define DMA_INT0_SRCFLG_CH14_OFS                 (14)                            /*!< CH14 Bit Offset */
N#define DMA_INT0_SRCFLG_CH14                     ((uint32_t)0x00004000)          /*!< Channel 14 was the source of DMA_INT0 */
N/* DMA_INT0_SRCFLG[CH15] Bits */
N#define DMA_INT0_SRCFLG_CH15_OFS                 (15)                            /*!< CH15 Bit Offset */
N#define DMA_INT0_SRCFLG_CH15                     ((uint32_t)0x00008000)          /*!< Channel 15 was the source of DMA_INT0 */
N/* DMA_INT0_SRCFLG[CH16] Bits */
N#define DMA_INT0_SRCFLG_CH16_OFS                 (16)                            /*!< CH16 Bit Offset */
N#define DMA_INT0_SRCFLG_CH16                     ((uint32_t)0x00010000)          /*!< Channel 16 was the source of DMA_INT0 */
N/* DMA_INT0_SRCFLG[CH17] Bits */
N#define DMA_INT0_SRCFLG_CH17_OFS                 (17)                            /*!< CH17 Bit Offset */
N#define DMA_INT0_SRCFLG_CH17                     ((uint32_t)0x00020000)          /*!< Channel 17 was the source of DMA_INT0 */
N/* DMA_INT0_SRCFLG[CH18] Bits */
N#define DMA_INT0_SRCFLG_CH18_OFS                 (18)                            /*!< CH18 Bit Offset */
N#define DMA_INT0_SRCFLG_CH18                     ((uint32_t)0x00040000)          /*!< Channel 18 was the source of DMA_INT0 */
N/* DMA_INT0_SRCFLG[CH19] Bits */
N#define DMA_INT0_SRCFLG_CH19_OFS                 (19)                            /*!< CH19 Bit Offset */
N#define DMA_INT0_SRCFLG_CH19                     ((uint32_t)0x00080000)          /*!< Channel 19 was the source of DMA_INT0 */
N/* DMA_INT0_SRCFLG[CH20] Bits */
N#define DMA_INT0_SRCFLG_CH20_OFS                 (20)                            /*!< CH20 Bit Offset */
N#define DMA_INT0_SRCFLG_CH20                     ((uint32_t)0x00100000)          /*!< Channel 20 was the source of DMA_INT0 */
N/* DMA_INT0_SRCFLG[CH21] Bits */
N#define DMA_INT0_SRCFLG_CH21_OFS                 (21)                            /*!< CH21 Bit Offset */
N#define DMA_INT0_SRCFLG_CH21                     ((uint32_t)0x00200000)          /*!< Channel 21 was the source of DMA_INT0 */
N/* DMA_INT0_SRCFLG[CH22] Bits */
N#define DMA_INT0_SRCFLG_CH22_OFS                 (22)                            /*!< CH22 Bit Offset */
N#define DMA_INT0_SRCFLG_CH22                     ((uint32_t)0x00400000)          /*!< Channel 22 was the source of DMA_INT0 */
N/* DMA_INT0_SRCFLG[CH23] Bits */
N#define DMA_INT0_SRCFLG_CH23_OFS                 (23)                            /*!< CH23 Bit Offset */
N#define DMA_INT0_SRCFLG_CH23                     ((uint32_t)0x00800000)          /*!< Channel 23 was the source of DMA_INT0 */
N/* DMA_INT0_SRCFLG[CH24] Bits */
N#define DMA_INT0_SRCFLG_CH24_OFS                 (24)                            /*!< CH24 Bit Offset */
N#define DMA_INT0_SRCFLG_CH24                     ((uint32_t)0x01000000)          /*!< Channel 24 was the source of DMA_INT0 */
N/* DMA_INT0_SRCFLG[CH25] Bits */
N#define DMA_INT0_SRCFLG_CH25_OFS                 (25)                            /*!< CH25 Bit Offset */
N#define DMA_INT0_SRCFLG_CH25                     ((uint32_t)0x02000000)          /*!< Channel 25 was the source of DMA_INT0 */
N/* DMA_INT0_SRCFLG[CH26] Bits */
N#define DMA_INT0_SRCFLG_CH26_OFS                 (26)                            /*!< CH26 Bit Offset */
N#define DMA_INT0_SRCFLG_CH26                     ((uint32_t)0x04000000)          /*!< Channel 26 was the source of DMA_INT0 */
N/* DMA_INT0_SRCFLG[CH27] Bits */
N#define DMA_INT0_SRCFLG_CH27_OFS                 (27)                            /*!< CH27 Bit Offset */
N#define DMA_INT0_SRCFLG_CH27                     ((uint32_t)0x08000000)          /*!< Channel 27 was the source of DMA_INT0 */
N/* DMA_INT0_SRCFLG[CH28] Bits */
N#define DMA_INT0_SRCFLG_CH28_OFS                 (28)                            /*!< CH28 Bit Offset */
N#define DMA_INT0_SRCFLG_CH28                     ((uint32_t)0x10000000)          /*!< Channel 28 was the source of DMA_INT0 */
N/* DMA_INT0_SRCFLG[CH29] Bits */
N#define DMA_INT0_SRCFLG_CH29_OFS                 (29)                            /*!< CH29 Bit Offset */
N#define DMA_INT0_SRCFLG_CH29                     ((uint32_t)0x20000000)          /*!< Channel 29 was the source of DMA_INT0 */
N/* DMA_INT0_SRCFLG[CH30] Bits */
N#define DMA_INT0_SRCFLG_CH30_OFS                 (30)                            /*!< CH30 Bit Offset */
N#define DMA_INT0_SRCFLG_CH30                     ((uint32_t)0x40000000)          /*!< Channel 30 was the source of DMA_INT0 */
N/* DMA_INT0_SRCFLG[CH31] Bits */
N#define DMA_INT0_SRCFLG_CH31_OFS                 (31)                            /*!< CH31 Bit Offset */
N#define DMA_INT0_SRCFLG_CH31                     ((uint32_t)0x80000000)          /*!< Channel 31 was the source of DMA_INT0 */
N/* DMA_INT0_CLRFLG[CH0] Bits */
N#define DMA_INT0_CLRFLG_CH0_OFS                  ( 0)                            /*!< CH0 Bit Offset */
N#define DMA_INT0_CLRFLG_CH0                      ((uint32_t)0x00000001)          /*!< Clear corresponding DMA_INT0_SRCFLG_REG */
N/* DMA_INT0_CLRFLG[CH1] Bits */
N#define DMA_INT0_CLRFLG_CH1_OFS                  ( 1)                            /*!< CH1 Bit Offset */
N#define DMA_INT0_CLRFLG_CH1                      ((uint32_t)0x00000002)          /*!< Clear corresponding DMA_INT0_SRCFLG_REG */
N/* DMA_INT0_CLRFLG[CH2] Bits */
N#define DMA_INT0_CLRFLG_CH2_OFS                  ( 2)                            /*!< CH2 Bit Offset */
N#define DMA_INT0_CLRFLG_CH2                      ((uint32_t)0x00000004)          /*!< Clear corresponding DMA_INT0_SRCFLG_REG */
N/* DMA_INT0_CLRFLG[CH3] Bits */
N#define DMA_INT0_CLRFLG_CH3_OFS                  ( 3)                            /*!< CH3 Bit Offset */
N#define DMA_INT0_CLRFLG_CH3                      ((uint32_t)0x00000008)          /*!< Clear corresponding DMA_INT0_SRCFLG_REG */
N/* DMA_INT0_CLRFLG[CH4] Bits */
N#define DMA_INT0_CLRFLG_CH4_OFS                  ( 4)                            /*!< CH4 Bit Offset */
N#define DMA_INT0_CLRFLG_CH4                      ((uint32_t)0x00000010)          /*!< Clear corresponding DMA_INT0_SRCFLG_REG */
N/* DMA_INT0_CLRFLG[CH5] Bits */
N#define DMA_INT0_CLRFLG_CH5_OFS                  ( 5)                            /*!< CH5 Bit Offset */
N#define DMA_INT0_CLRFLG_CH5                      ((uint32_t)0x00000020)          /*!< Clear corresponding DMA_INT0_SRCFLG_REG */
N/* DMA_INT0_CLRFLG[CH6] Bits */
N#define DMA_INT0_CLRFLG_CH6_OFS                  ( 6)                            /*!< CH6 Bit Offset */
N#define DMA_INT0_CLRFLG_CH6                      ((uint32_t)0x00000040)          /*!< Clear corresponding DMA_INT0_SRCFLG_REG */
N/* DMA_INT0_CLRFLG[CH7] Bits */
N#define DMA_INT0_CLRFLG_CH7_OFS                  ( 7)                            /*!< CH7 Bit Offset */
N#define DMA_INT0_CLRFLG_CH7                      ((uint32_t)0x00000080)          /*!< Clear corresponding DMA_INT0_SRCFLG_REG */
N/* DMA_INT0_CLRFLG[CH8] Bits */
N#define DMA_INT0_CLRFLG_CH8_OFS                  ( 8)                            /*!< CH8 Bit Offset */
N#define DMA_INT0_CLRFLG_CH8                      ((uint32_t)0x00000100)          /*!< Clear corresponding DMA_INT0_SRCFLG_REG */
N/* DMA_INT0_CLRFLG[CH9] Bits */
N#define DMA_INT0_CLRFLG_CH9_OFS                  ( 9)                            /*!< CH9 Bit Offset */
N#define DMA_INT0_CLRFLG_CH9                      ((uint32_t)0x00000200)          /*!< Clear corresponding DMA_INT0_SRCFLG_REG */
N/* DMA_INT0_CLRFLG[CH10] Bits */
N#define DMA_INT0_CLRFLG_CH10_OFS                 (10)                            /*!< CH10 Bit Offset */
N#define DMA_INT0_CLRFLG_CH10                     ((uint32_t)0x00000400)          /*!< Clear corresponding DMA_INT0_SRCFLG_REG */
N/* DMA_INT0_CLRFLG[CH11] Bits */
N#define DMA_INT0_CLRFLG_CH11_OFS                 (11)                            /*!< CH11 Bit Offset */
N#define DMA_INT0_CLRFLG_CH11                     ((uint32_t)0x00000800)          /*!< Clear corresponding DMA_INT0_SRCFLG_REG */
N/* DMA_INT0_CLRFLG[CH12] Bits */
N#define DMA_INT0_CLRFLG_CH12_OFS                 (12)                            /*!< CH12 Bit Offset */
N#define DMA_INT0_CLRFLG_CH12                     ((uint32_t)0x00001000)          /*!< Clear corresponding DMA_INT0_SRCFLG_REG */
N/* DMA_INT0_CLRFLG[CH13] Bits */
N#define DMA_INT0_CLRFLG_CH13_OFS                 (13)                            /*!< CH13 Bit Offset */
N#define DMA_INT0_CLRFLG_CH13                     ((uint32_t)0x00002000)          /*!< Clear corresponding DMA_INT0_SRCFLG_REG */
N/* DMA_INT0_CLRFLG[CH14] Bits */
N#define DMA_INT0_CLRFLG_CH14_OFS                 (14)                            /*!< CH14 Bit Offset */
N#define DMA_INT0_CLRFLG_CH14                     ((uint32_t)0x00004000)          /*!< Clear corresponding DMA_INT0_SRCFLG_REG */
N/* DMA_INT0_CLRFLG[CH15] Bits */
N#define DMA_INT0_CLRFLG_CH15_OFS                 (15)                            /*!< CH15 Bit Offset */
N#define DMA_INT0_CLRFLG_CH15                     ((uint32_t)0x00008000)          /*!< Clear corresponding DMA_INT0_SRCFLG_REG */
N/* DMA_INT0_CLRFLG[CH16] Bits */
N#define DMA_INT0_CLRFLG_CH16_OFS                 (16)                            /*!< CH16 Bit Offset */
N#define DMA_INT0_CLRFLG_CH16                     ((uint32_t)0x00010000)          /*!< Clear corresponding DMA_INT0_SRCFLG_REG */
N/* DMA_INT0_CLRFLG[CH17] Bits */
N#define DMA_INT0_CLRFLG_CH17_OFS                 (17)                            /*!< CH17 Bit Offset */
N#define DMA_INT0_CLRFLG_CH17                     ((uint32_t)0x00020000)          /*!< Clear corresponding DMA_INT0_SRCFLG_REG */
N/* DMA_INT0_CLRFLG[CH18] Bits */
N#define DMA_INT0_CLRFLG_CH18_OFS                 (18)                            /*!< CH18 Bit Offset */
N#define DMA_INT0_CLRFLG_CH18                     ((uint32_t)0x00040000)          /*!< Clear corresponding DMA_INT0_SRCFLG_REG */
N/* DMA_INT0_CLRFLG[CH19] Bits */
N#define DMA_INT0_CLRFLG_CH19_OFS                 (19)                            /*!< CH19 Bit Offset */
N#define DMA_INT0_CLRFLG_CH19                     ((uint32_t)0x00080000)          /*!< Clear corresponding DMA_INT0_SRCFLG_REG */
N/* DMA_INT0_CLRFLG[CH20] Bits */
N#define DMA_INT0_CLRFLG_CH20_OFS                 (20)                            /*!< CH20 Bit Offset */
N#define DMA_INT0_CLRFLG_CH20                     ((uint32_t)0x00100000)          /*!< Clear corresponding DMA_INT0_SRCFLG_REG */
N/* DMA_INT0_CLRFLG[CH21] Bits */
N#define DMA_INT0_CLRFLG_CH21_OFS                 (21)                            /*!< CH21 Bit Offset */
N#define DMA_INT0_CLRFLG_CH21                     ((uint32_t)0x00200000)          /*!< Clear corresponding DMA_INT0_SRCFLG_REG */
N/* DMA_INT0_CLRFLG[CH22] Bits */
N#define DMA_INT0_CLRFLG_CH22_OFS                 (22)                            /*!< CH22 Bit Offset */
N#define DMA_INT0_CLRFLG_CH22                     ((uint32_t)0x00400000)          /*!< Clear corresponding DMA_INT0_SRCFLG_REG */
N/* DMA_INT0_CLRFLG[CH23] Bits */
N#define DMA_INT0_CLRFLG_CH23_OFS                 (23)                            /*!< CH23 Bit Offset */
N#define DMA_INT0_CLRFLG_CH23                     ((uint32_t)0x00800000)          /*!< Clear corresponding DMA_INT0_SRCFLG_REG */
N/* DMA_INT0_CLRFLG[CH24] Bits */
N#define DMA_INT0_CLRFLG_CH24_OFS                 (24)                            /*!< CH24 Bit Offset */
N#define DMA_INT0_CLRFLG_CH24                     ((uint32_t)0x01000000)          /*!< Clear corresponding DMA_INT0_SRCFLG_REG */
N/* DMA_INT0_CLRFLG[CH25] Bits */
N#define DMA_INT0_CLRFLG_CH25_OFS                 (25)                            /*!< CH25 Bit Offset */
N#define DMA_INT0_CLRFLG_CH25                     ((uint32_t)0x02000000)          /*!< Clear corresponding DMA_INT0_SRCFLG_REG */
N/* DMA_INT0_CLRFLG[CH26] Bits */
N#define DMA_INT0_CLRFLG_CH26_OFS                 (26)                            /*!< CH26 Bit Offset */
N#define DMA_INT0_CLRFLG_CH26                     ((uint32_t)0x04000000)          /*!< Clear corresponding DMA_INT0_SRCFLG_REG */
N/* DMA_INT0_CLRFLG[CH27] Bits */
N#define DMA_INT0_CLRFLG_CH27_OFS                 (27)                            /*!< CH27 Bit Offset */
N#define DMA_INT0_CLRFLG_CH27                     ((uint32_t)0x08000000)          /*!< Clear corresponding DMA_INT0_SRCFLG_REG */
N/* DMA_INT0_CLRFLG[CH28] Bits */
N#define DMA_INT0_CLRFLG_CH28_OFS                 (28)                            /*!< CH28 Bit Offset */
N#define DMA_INT0_CLRFLG_CH28                     ((uint32_t)0x10000000)          /*!< Clear corresponding DMA_INT0_SRCFLG_REG */
N/* DMA_INT0_CLRFLG[CH29] Bits */
N#define DMA_INT0_CLRFLG_CH29_OFS                 (29)                            /*!< CH29 Bit Offset */
N#define DMA_INT0_CLRFLG_CH29                     ((uint32_t)0x20000000)          /*!< Clear corresponding DMA_INT0_SRCFLG_REG */
N/* DMA_INT0_CLRFLG[CH30] Bits */
N#define DMA_INT0_CLRFLG_CH30_OFS                 (30)                            /*!< CH30 Bit Offset */
N#define DMA_INT0_CLRFLG_CH30                     ((uint32_t)0x40000000)          /*!< Clear corresponding DMA_INT0_SRCFLG_REG */
N/* DMA_INT0_CLRFLG[CH31] Bits */
N#define DMA_INT0_CLRFLG_CH31_OFS                 (31)                            /*!< CH31 Bit Offset */
N#define DMA_INT0_CLRFLG_CH31                     ((uint32_t)0x80000000)          /*!< Clear corresponding DMA_INT0_SRCFLG_REG */
N/* DMA_STAT[MASTEN] Bits */
N#define DMA_STAT_MASTEN_OFS                      ( 0)                            /*!< MASTEN Bit Offset */
N#define DMA_STAT_MASTEN                          ((uint32_t)0x00000001)          
N/* DMA_STAT[STATE] Bits */
N#define DMA_STAT_STATE_OFS                       ( 4)                            /*!< STATE Bit Offset */
N#define DMA_STAT_STATE_MASK                      ((uint32_t)0x000000F0)          /*!< STATE Bit Mask */
N#define DMA_STAT_STATE0                          ((uint32_t)0x00000010)          /*!< STATE Bit 0 */
N#define DMA_STAT_STATE1                          ((uint32_t)0x00000020)          /*!< STATE Bit 1 */
N#define DMA_STAT_STATE2                          ((uint32_t)0x00000040)          /*!< STATE Bit 2 */
N#define DMA_STAT_STATE3                          ((uint32_t)0x00000080)          /*!< STATE Bit 3 */
N#define DMA_STAT_STATE_0                         ((uint32_t)0x00000000)          /*!< idle */
N#define DMA_STAT_STATE_1                         ((uint32_t)0x00000010)          /*!< reading channel controller data */
N#define DMA_STAT_STATE_2                         ((uint32_t)0x00000020)          /*!< reading source data end pointer */
N#define DMA_STAT_STATE_3                         ((uint32_t)0x00000030)          /*!< reading destination data end pointer */
N#define DMA_STAT_STATE_4                         ((uint32_t)0x00000040)          /*!< reading source data */
N#define DMA_STAT_STATE_5                         ((uint32_t)0x00000050)          /*!< writing destination data */
N#define DMA_STAT_STATE_6                         ((uint32_t)0x00000060)          /*!< waiting for DMA request to clear */
N#define DMA_STAT_STATE_7                         ((uint32_t)0x00000070)          /*!< writing channel controller data */
N#define DMA_STAT_STATE_8                         ((uint32_t)0x00000080)          /*!< stalled */
N#define DMA_STAT_STATE_9                         ((uint32_t)0x00000090)          /*!< done */
N#define DMA_STAT_STATE_10                        ((uint32_t)0x000000A0)          /*!< peripheral scatter-gather transition */
N#define DMA_STAT_STATE_11                        ((uint32_t)0x000000B0)          /*!< Reserved */
N#define DMA_STAT_STATE_12                        ((uint32_t)0x000000C0)          /*!< Reserved */
N#define DMA_STAT_STATE_13                        ((uint32_t)0x000000D0)          /*!< Reserved */
N#define DMA_STAT_STATE_14                        ((uint32_t)0x000000E0)          /*!< Reserved */
N#define DMA_STAT_STATE_15                        ((uint32_t)0x000000F0)          /*!< Reserved */
N/* DMA_STAT[DMACHANS] Bits */
N#define DMA_STAT_DMACHANS_OFS                    (16)                            /*!< DMACHANS Bit Offset */
N#define DMA_STAT_DMACHANS_MASK                   ((uint32_t)0x001F0000)          /*!< DMACHANS Bit Mask */
N#define DMA_STAT_DMACHANS0                       ((uint32_t)0x00010000)          /*!< DMACHANS Bit 0 */
N#define DMA_STAT_DMACHANS1                       ((uint32_t)0x00020000)          /*!< DMACHANS Bit 1 */
N#define DMA_STAT_DMACHANS2                       ((uint32_t)0x00040000)          /*!< DMACHANS Bit 2 */
N#define DMA_STAT_DMACHANS3                       ((uint32_t)0x00080000)          /*!< DMACHANS Bit 3 */
N#define DMA_STAT_DMACHANS4                       ((uint32_t)0x00100000)          /*!< DMACHANS Bit 4 */
N#define DMA_STAT_DMACHANS_0                      ((uint32_t)0x00000000)          /*!< Controller configured to use 1 DMA channel */
N#define DMA_STAT_DMACHANS_1                      ((uint32_t)0x00010000)          /*!< Controller configured to use 2 DMA channels */
N#define DMA_STAT_DMACHANS_30                     ((uint32_t)0x001E0000)          /*!< Controller configured to use 31 DMA channels */
N#define DMA_STAT_DMACHANS_31                     ((uint32_t)0x001F0000)          /*!< Controller configured to use 32 DMA channels */
N/* DMA_STAT[TESTSTAT] Bits */
N#define DMA_STAT_TESTSTAT_OFS                    (28)                            /*!< TESTSTAT Bit Offset */
N#define DMA_STAT_TESTSTAT_MASK                   ((uint32_t)0xF0000000)          /*!< TESTSTAT Bit Mask */
N#define DMA_STAT_TESTSTAT0                       ((uint32_t)0x10000000)          /*!< TESTSTAT Bit 0 */
N#define DMA_STAT_TESTSTAT1                       ((uint32_t)0x20000000)          /*!< TESTSTAT Bit 1 */
N#define DMA_STAT_TESTSTAT2                       ((uint32_t)0x40000000)          /*!< TESTSTAT Bit 2 */
N#define DMA_STAT_TESTSTAT3                       ((uint32_t)0x80000000)          /*!< TESTSTAT Bit 3 */
N#define DMA_STAT_TESTSTAT_0                      ((uint32_t)0x00000000)          /*!< Controller does not include the integration test logic */
N#define DMA_STAT_TESTSTAT_1                      ((uint32_t)0x10000000)          /*!< Controller includes the integration test logic */
N/* DMA_CFG[MASTEN] Bits */
N#define DMA_CFG_MASTEN_OFS                       ( 0)                            /*!< MASTEN Bit Offset */
N#define DMA_CFG_MASTEN                           ((uint32_t)0x00000001)          
N/* DMA_CFG[CHPROTCTRL] Bits */
N#define DMA_CFG_CHPROTCTRL_OFS                   ( 5)                            /*!< CHPROTCTRL Bit Offset */
N#define DMA_CFG_CHPROTCTRL_MASK                  ((uint32_t)0x000000E0)          /*!< CHPROTCTRL Bit Mask */
N/* DMA_CTLBASE[ADDR] Bits */
N#define DMA_CTLBASE_ADDR_OFS                     ( 5)                            /*!< ADDR Bit Offset */
N#define DMA_CTLBASE_ADDR_MASK                    ((uint32_t)0xFFFFFFE0)          /*!< ADDR Bit Mask */
N/* DMA_ERRCLR[ERRCLR] Bits */
N#define DMA_ERRCLR_ERRCLR_OFS                    ( 0)                            /*!< ERRCLR Bit Offset */
N#define DMA_ERRCLR_ERRCLR                        ((uint32_t)0x00000001)          
N/* DMA channel definitions and memory structure alignment */
N#define __MCU_NUM_DMA_CHANNELS__                8
N#define DMA_CHANNEL_CONTROL_STRUCT_SIZE         0x10
N#define DMA_CONTROL_MEMORY_ALIGNMENT            (__MCU_NUM_DMA_CHANNELS__ * DMA_CHANNEL_CONTROL_STRUCT_SIZE)
N
N/* UDMA_STAT Control Bits */
N#define UDMA_STAT_DMACHANS_M                    ((uint32_t)0x001F0000)           /*!< Available uDMA Channels Minus 1 */
N#define UDMA_STAT_STATE_M                       ((uint32_t)0x000000F0)           /*!< Control State Machine Status */
N#define UDMA_STAT_STATE_IDLE                    ((uint32_t)0x00000000)           /*!< Idle */
N#define UDMA_STAT_STATE_RD_CTRL                 ((uint32_t)0x00000010)           /*!< Reading channel controller data */
N#define UDMA_STAT_STATE_RD_SRCENDP              ((uint32_t)0x00000020)           /*!< Reading source end pointer */
N#define UDMA_STAT_STATE_RD_DSTENDP              ((uint32_t)0x00000030)           /*!< Reading destination end pointer */
N#define UDMA_STAT_STATE_RD_SRCDAT               ((uint32_t)0x00000040)           /*!< Reading source data */
N#define UDMA_STAT_STATE_WR_DSTDAT               ((uint32_t)0x00000050)           /*!< Writing destination data */
N#define UDMA_STAT_STATE_WAIT                    ((uint32_t)0x00000060)           /*!< Waiting for uDMA request to clear */
N#define UDMA_STAT_STATE_WR_CTRL                 ((uint32_t)0x00000070)           /*!< Writing channel controller data */
N#define UDMA_STAT_STATE_STALL                   ((uint32_t)0x00000080)           /*!< Stalled */
N#define UDMA_STAT_STATE_DONE                    ((uint32_t)0x00000090)           /*!< Done */
N#define UDMA_STAT_STATE_UNDEF                   ((uint32_t)0x000000A0)           /*!< Undefined */
N#define UDMA_STAT_MASTEN                        ((uint32_t)0x00000001)           /*!< Master Enable Status */
N#define UDMA_STAT_DMACHANS_S                    (16)
N
N/* UDMA_CFG Control Bits */
N#define UDMA_CFG_MASTEN                         ((uint32_t)0x00000001)           /*!< Controller Master Enable */
N
N/* UDMA_CTLBASE Control Bits */
N#define UDMA_CTLBASE_ADDR_M                     ((uint32_t)0xFFFFFC00)           /*!< Channel Control Base Address */
N#define UDMA_CTLBASE_ADDR_S                     (10)
N
N/* UDMA_ALTBASE Control Bits */
N#define UDMA_ALTBASE_ADDR_M                     ((uint32_t)0xFFFFFFFF)           /*!< Alternate Channel Address Pointer */
N#define UDMA_ALTBASE_ADDR_S                     ( 0)
N
N/* UDMA_WAITSTAT Control Bits */
N#define UDMA_WAITSTAT_WAITREQ_M                 ((uint32_t)0xFFFFFFFF)           /*!< Channel [n] Wait Status */
N
N/* UDMA_SWREQ Control Bits */
N#define UDMA_SWREQ_M                            ((uint32_t)0xFFFFFFFF)           /*!< Channel [n] Software Request */
N
N/* UDMA_USEBURSTSET Control Bits */
N#define UDMA_USEBURSTSET_SET_M                  ((uint32_t)0xFFFFFFFF)           /*!< Channel [n] Useburst Set */
N
N/* UDMA_USEBURSTCLR Control Bits */
N#define UDMA_USEBURSTCLR_CLR_M                  ((uint32_t)0xFFFFFFFF)           /*!< Channel [n] Useburst Clear */
N
N/* UDMA_REQMASKSET Control Bits */
N#define UDMA_REQMASKSET_SET_M                   ((uint32_t)0xFFFFFFFF)           /*!< Channel [n] Request Mask Set */
N
N/* UDMA_REQMASKCLR Control Bits */
N#define UDMA_REQMASKCLR_CLR_M                   ((uint32_t)0xFFFFFFFF)           /*!< Channel [n] Request Mask Clear */
N
N/* UDMA_ENASET Control Bits */
N#define UDMA_ENASET_SET_M                       ((uint32_t)0xFFFFFFFF)           /*!< Channel [n] Enable Set */
N
N/* UDMA_ENACLR Control Bits */
N#define UDMA_ENACLR_CLR_M                       ((uint32_t)0xFFFFFFFF)           /*!< Clear Channel [n] Enable Clear */
N
N/* UDMA_ALTSET Control Bits */
N#define UDMA_ALTSET_SET_M                       ((uint32_t)0xFFFFFFFF)           /*!< Channel [n] Alternate Set */
N
N/* UDMA_ALTCLR Control Bits */
N#define UDMA_ALTCLR_CLR_M                       ((uint32_t)0xFFFFFFFF)           /*!< Channel [n] Alternate Clear */
N
N/* UDMA_PRIOSET Control Bits */
N#define UDMA_PRIOSET_SET_M                      ((uint32_t)0xFFFFFFFF)           /*!< Channel [n] Priority Set */
N
N/* UDMA_PRIOCLR Control Bits */
N#define UDMA_PRIOCLR_CLR_M                      ((uint32_t)0xFFFFFFFF)           /*!< Channel [n] Priority Clear */
N
N/* UDMA_ERRCLR Control Bits */
N#define UDMA_ERRCLR_ERRCLR                      ((uint32_t)0x00000001)           /*!< uDMA Bus Error Status */
N
N/* UDMA_CHASGN Control Bits */
N#define UDMA_CHASGN_M                           ((uint32_t)0xFFFFFFFF)           /*!< Channel [n] Assignment Select */
N#define UDMA_CHASGN_PRIMARY                     ((uint32_t)0x00000000)           /*!< Use the primary channel assignment */
N#define UDMA_CHASGN_SECONDARY                   ((uint32_t)0x00000001)           /*!< Use the secondary channel assignment */
N
N/* Micro Direct Memory Access (uDMA) offsets */
N#define UDMA_O_SRCENDP                          ((uint32_t)0x00000000)           /*!< DMA Channel Source Address End Pointer */
N#define UDMA_O_DSTENDP                          ((uint32_t)0x00000004)           /*!< DMA Channel Destination Address End Pointer */
N#define UDMA_O_CHCTL                            ((uint32_t)0x00000008)           /*!< DMA Channel Control Word */
N
N/* UDMA_O_SRCENDP Control Bits */
N#define UDMA_SRCENDP_ADDR_M                     ((uint32_t)0xFFFFFFFF)           /*!< Source Address End Pointer */
N#define UDMA_SRCENDP_ADDR_S                     ( 0)
N
N/* UDMA_O_DSTENDP Control Bits */
N#define UDMA_DSTENDP_ADDR_M                     ((uint32_t)0xFFFFFFFF)           /*!< Destination Address End Pointer */
N#define UDMA_DSTENDP_ADDR_S                     ( 0)
N
N/* UDMA_O_CHCTL Control Bits */
N#define UDMA_CHCTL_DSTINC_M                     ((uint32_t)0xC0000000)           /*!< Destination Address Increment */
N#define UDMA_CHCTL_DSTINC_8                     ((uint32_t)0x00000000)           /*!< Byte */
N#define UDMA_CHCTL_DSTINC_16                    ((uint32_t)0x40000000)           /*!< Half-word */
N#define UDMA_CHCTL_DSTINC_32                    ((uint32_t)0x80000000)           /*!< Word */
N#define UDMA_CHCTL_DSTINC_NONE                  ((uint32_t)0xC0000000)           /*!< No increment */
N#define UDMA_CHCTL_DSTSIZE_M                    ((uint32_t)0x30000000)           /*!< Destination Data Size */
N#define UDMA_CHCTL_DSTSIZE_8                    ((uint32_t)0x00000000)           /*!< Byte */
N#define UDMA_CHCTL_DSTSIZE_16                   ((uint32_t)0x10000000)           /*!< Half-word */
N#define UDMA_CHCTL_DSTSIZE_32                   ((uint32_t)0x20000000)           /*!< Word */
N#define UDMA_CHCTL_SRCINC_M                     ((uint32_t)0x0C000000)           /*!< Source Address Increment */
N#define UDMA_CHCTL_SRCINC_8                     ((uint32_t)0x00000000)           /*!< Byte */
N#define UDMA_CHCTL_SRCINC_16                    ((uint32_t)0x04000000)           /*!< Half-word */
N#define UDMA_CHCTL_SRCINC_32                    ((uint32_t)0x08000000)           /*!< Word */
N#define UDMA_CHCTL_SRCINC_NONE                  ((uint32_t)0x0C000000)           /*!< No increment */
N#define UDMA_CHCTL_SRCSIZE_M                    ((uint32_t)0x03000000)           /*!< Source Data Size */
N#define UDMA_CHCTL_SRCSIZE_8                    ((uint32_t)0x00000000)           /*!< Byte */
N#define UDMA_CHCTL_SRCSIZE_16                   ((uint32_t)0x01000000)           /*!< Half-word */
N#define UDMA_CHCTL_SRCSIZE_32                   ((uint32_t)0x02000000)           /*!< Word */
N#define UDMA_CHCTL_ARBSIZE_M                    ((uint32_t)0x0003C000)           /*!< Arbitration Size */
N#define UDMA_CHCTL_ARBSIZE_1                    ((uint32_t)0x00000000)           /*!< 1 Transfer */
N#define UDMA_CHCTL_ARBSIZE_2                    ((uint32_t)0x00004000)           /*!< 2 Transfers */
N#define UDMA_CHCTL_ARBSIZE_4                    ((uint32_t)0x00008000)           /*!< 4 Transfers */
N#define UDMA_CHCTL_ARBSIZE_8                    ((uint32_t)0x0000C000)           /*!< 8 Transfers */
N#define UDMA_CHCTL_ARBSIZE_16                   ((uint32_t)0x00010000)           /*!< 16 Transfers */
N#define UDMA_CHCTL_ARBSIZE_32                   ((uint32_t)0x00014000)           /*!< 32 Transfers */
N#define UDMA_CHCTL_ARBSIZE_64                   ((uint32_t)0x00018000)           /*!< 64 Transfers */
N#define UDMA_CHCTL_ARBSIZE_128                  ((uint32_t)0x0001C000)           /*!< 128 Transfers */
N#define UDMA_CHCTL_ARBSIZE_256                  ((uint32_t)0x00020000)           /*!< 256 Transfers */
N#define UDMA_CHCTL_ARBSIZE_512                  ((uint32_t)0x00024000)           /*!< 512 Transfers */
N#define UDMA_CHCTL_ARBSIZE_1024                 ((uint32_t)0x00028000)           /*!< 1024 Transfers */
N#define UDMA_CHCTL_XFERSIZE_M                   ((uint32_t)0x00003FF0)           /*!< Transfer Size (minus 1) */
N#define UDMA_CHCTL_NXTUSEBURST                  ((uint32_t)0x00000008)           /*!< Next Useburst */
N#define UDMA_CHCTL_XFERMODE_M                   ((uint32_t)0x00000007)           /*!< uDMA Transfer Mode */
N#define UDMA_CHCTL_XFERMODE_STOP                ((uint32_t)0x00000000)           /*!< Stop */
N#define UDMA_CHCTL_XFERMODE_BASIC               ((uint32_t)0x00000001)           /*!< Basic */
N#define UDMA_CHCTL_XFERMODE_AUTO                ((uint32_t)0x00000002)           /*!< Auto-Request */
N#define UDMA_CHCTL_XFERMODE_PINGPONG            ((uint32_t)0x00000003)           /*!< Ping-Pong */
N#define UDMA_CHCTL_XFERMODE_MEM_SG              ((uint32_t)0x00000004)           /*!< Memory Scatter-Gather */
N#define UDMA_CHCTL_XFERMODE_MEM_SGA             ((uint32_t)0x00000005)           /*!< Alternate Memory Scatter-Gather */
N#define UDMA_CHCTL_XFERMODE_PER_SG              ((uint32_t)0x00000006)           /*!< Peripheral Scatter-Gather */
N#define UDMA_CHCTL_XFERMODE_PER_SGA             ((uint32_t)0x00000007)           /*!< Alternate Peripheral Scatter-Gather */
N
N#define UDMA_CHCTL_XFERSIZE_S                   ( 4)
N
N
N/******************************************************************************
N* DWT Bits
N******************************************************************************/
N
N
N/******************************************************************************
N* EUSCI_A Bits
N******************************************************************************/
N/* EUSCI_A_CTLW0[SWRST] Bits */
N#define EUSCI_A_CTLW0_SWRST_OFS                  ( 0)                            /*!< UCSWRST Bit Offset */
N#define EUSCI_A_CTLW0_SWRST                      ((uint16_t)0x0001)              /*!< Software reset enable */
N/* EUSCI_A_CTLW0[TXBRK] Bits */
N#define EUSCI_A_CTLW0_TXBRK_OFS                  ( 1)                            /*!< UCTXBRK Bit Offset */
N#define EUSCI_A_CTLW0_TXBRK                      ((uint16_t)0x0002)              /*!< Transmit break */
N/* EUSCI_A_CTLW0[TXADDR] Bits */
N#define EUSCI_A_CTLW0_TXADDR_OFS                 ( 2)                            /*!< UCTXADDR Bit Offset */
N#define EUSCI_A_CTLW0_TXADDR                     ((uint16_t)0x0004)              /*!< Transmit address */
N/* EUSCI_A_CTLW0[DORM] Bits */
N#define EUSCI_A_CTLW0_DORM_OFS                   ( 3)                            /*!< UCDORM Bit Offset */
N#define EUSCI_A_CTLW0_DORM                       ((uint16_t)0x0008)              /*!< Dormant */
N/* EUSCI_A_CTLW0[BRKIE] Bits */
N#define EUSCI_A_CTLW0_BRKIE_OFS                  ( 4)                            /*!< UCBRKIE Bit Offset */
N#define EUSCI_A_CTLW0_BRKIE                      ((uint16_t)0x0010)              /*!< Receive break character interrupt enable */
N/* EUSCI_A_CTLW0[RXEIE] Bits */
N#define EUSCI_A_CTLW0_RXEIE_OFS                  ( 5)                            /*!< UCRXEIE Bit Offset */
N#define EUSCI_A_CTLW0_RXEIE                      ((uint16_t)0x0020)              /*!< Receive erroneous-character interrupt enable */
N/* EUSCI_A_CTLW0[SSEL] Bits */
N#define EUSCI_A_CTLW0_SSEL_OFS                   ( 6)                            /*!< UCSSEL Bit Offset */
N#define EUSCI_A_CTLW0_SSEL_MASK                  ((uint16_t)0x00C0)              /*!< UCSSEL Bit Mask */
N#define EUSCI_A_CTLW0_SSEL0                      ((uint16_t)0x0040)              /*!< SSEL Bit 0 */
N#define EUSCI_A_CTLW0_SSEL1                      ((uint16_t)0x0080)              /*!< SSEL Bit 1 */
N#define EUSCI_A_CTLW0_UCSSEL_0                   ((uint16_t)0x0000)              /*!< UCLK */
N#define EUSCI_A_CTLW0_UCSSEL_1                   ((uint16_t)0x0040)              /*!< ACLK */
N#define EUSCI_A_CTLW0_UCSSEL_2                   ((uint16_t)0x0080)              /*!< SMCLK */
N#define EUSCI_A_CTLW0_SSEL__UCLK                 ((uint16_t)0x0000)              /*!< UCLK */
N#define EUSCI_A_CTLW0_SSEL__ACLK                 ((uint16_t)0x0040)              /*!< ACLK */
N#define EUSCI_A_CTLW0_SSEL__SMCLK                ((uint16_t)0x0080)              /*!< SMCLK */
N/* EUSCI_A_CTLW0[SYNC] Bits */
N#define EUSCI_A_CTLW0_SYNC_OFS                   ( 8)                            /*!< UCSYNC Bit Offset */
N#define EUSCI_A_CTLW0_SYNC                       ((uint16_t)0x0100)              /*!< Synchronous mode enable */
N/* EUSCI_A_CTLW0[MODE] Bits */
N#define EUSCI_A_CTLW0_MODE_OFS                   ( 9)                            /*!< UCMODE Bit Offset */
N#define EUSCI_A_CTLW0_MODE_MASK                  ((uint16_t)0x0600)              /*!< UCMODE Bit Mask */
N#define EUSCI_A_CTLW0_MODE0                      ((uint16_t)0x0200)              /*!< MODE Bit 0 */
N#define EUSCI_A_CTLW0_MODE1                      ((uint16_t)0x0400)              /*!< MODE Bit 1 */
N#define EUSCI_A_CTLW0_MODE_0                     ((uint16_t)0x0000)              /*!< UART mode */
N#define EUSCI_A_CTLW0_MODE_1                     ((uint16_t)0x0200)              /*!< Idle-line multiprocessor mode */
N#define EUSCI_A_CTLW0_MODE_2                     ((uint16_t)0x0400)              /*!< Address-bit multiprocessor mode */
N#define EUSCI_A_CTLW0_MODE_3                     ((uint16_t)0x0600)              /*!< UART mode with automatic baud-rate detection */
N/* EUSCI_A_CTLW0[SPB] Bits */
N#define EUSCI_A_CTLW0_SPB_OFS                    (11)                            /*!< UCSPB Bit Offset */
N#define EUSCI_A_CTLW0_SPB                        ((uint16_t)0x0800)              /*!< Stop bit select */
N/* EUSCI_A_CTLW0[SEVENBIT] Bits */
N#define EUSCI_A_CTLW0_SEVENBIT_OFS               (12)                            /*!< UC7BIT Bit Offset */
N#define EUSCI_A_CTLW0_SEVENBIT                   ((uint16_t)0x1000)              /*!< Character length */
N/* EUSCI_A_CTLW0[MSB] Bits */
N#define EUSCI_A_CTLW0_MSB_OFS                    (13)                            /*!< UCMSB Bit Offset */
N#define EUSCI_A_CTLW0_MSB                        ((uint16_t)0x2000)              /*!< MSB first select */
N/* EUSCI_A_CTLW0[PAR] Bits */
N#define EUSCI_A_CTLW0_PAR_OFS                    (14)                            /*!< UCPAR Bit Offset */
N#define EUSCI_A_CTLW0_PAR                        ((uint16_t)0x4000)              /*!< Parity select */
N/* EUSCI_A_CTLW0[PEN] Bits */
N#define EUSCI_A_CTLW0_PEN_OFS                    (15)                            /*!< UCPEN Bit Offset */
N#define EUSCI_A_CTLW0_PEN                        ((uint16_t)0x8000)              /*!< Parity enable */
N/* EUSCI_A_CTLW0[STEM] Bits */
N#define EUSCI_A_CTLW0_STEM_OFS                   ( 1)                            /*!< UCSTEM Bit Offset */
N#define EUSCI_A_CTLW0_STEM                       ((uint16_t)0x0002)              /*!< STE mode select in master mode. */
N/* EUSCI_A_CTLW0[MST] Bits */
N#define EUSCI_A_CTLW0_MST_OFS                    (11)                            /*!< UCMST Bit Offset */
N#define EUSCI_A_CTLW0_MST                        ((uint16_t)0x0800)              /*!< Master mode select */
N/* EUSCI_A_CTLW0[CKPL] Bits */
N#define EUSCI_A_CTLW0_CKPL_OFS                   (14)                            /*!< UCCKPL Bit Offset */
N#define EUSCI_A_CTLW0_CKPL                       ((uint16_t)0x4000)              /*!< Clock polarity select */
N/* EUSCI_A_CTLW0[CKPH] Bits */
N#define EUSCI_A_CTLW0_CKPH_OFS                   (15)                            /*!< UCCKPH Bit Offset */
N#define EUSCI_A_CTLW0_CKPH                       ((uint16_t)0x8000)              /*!< Clock phase select */
N/* EUSCI_A_CTLW1[GLIT] Bits */
N#define EUSCI_A_CTLW1_GLIT_OFS                   ( 0)                            /*!< UCGLIT Bit Offset */
N#define EUSCI_A_CTLW1_GLIT_MASK                  ((uint16_t)0x0003)              /*!< UCGLIT Bit Mask */
N#define EUSCI_A_CTLW1_GLIT0                      ((uint16_t)0x0001)              /*!< GLIT Bit 0 */
N#define EUSCI_A_CTLW1_GLIT1                      ((uint16_t)0x0002)              /*!< GLIT Bit 1 */
N#define EUSCI_A_CTLW1_GLIT_0                     ((uint16_t)0x0000)              /*!< Approximately 2 ns (equivalent of 1 delay element) */
N#define EUSCI_A_CTLW1_GLIT_1                     ((uint16_t)0x0001)              /*!< Approximately 50 ns */
N#define EUSCI_A_CTLW1_GLIT_2                     ((uint16_t)0x0002)              /*!< Approximately 100 ns */
N#define EUSCI_A_CTLW1_GLIT_3                     ((uint16_t)0x0003)              /*!< Approximately 200 ns */
N/* EUSCI_A_MCTLW[OS16] Bits */
N#define EUSCI_A_MCTLW_OS16_OFS                   ( 0)                            /*!< UCOS16 Bit Offset */
N#define EUSCI_A_MCTLW_OS16                       ((uint16_t)0x0001)              /*!< Oversampling mode enabled */
N/* EUSCI_A_MCTLW[BRF] Bits */
N#define EUSCI_A_MCTLW_BRF_OFS                    ( 4)                            /*!< UCBRF Bit Offset */
N#define EUSCI_A_MCTLW_BRF_MASK                   ((uint16_t)0x00F0)              /*!< UCBRF Bit Mask */
N/* EUSCI_A_MCTLW[BRS] Bits */
N#define EUSCI_A_MCTLW_BRS_OFS                    ( 8)                            /*!< UCBRS Bit Offset */
N#define EUSCI_A_MCTLW_BRS_MASK                   ((uint16_t)0xFF00)              /*!< UCBRS Bit Mask */
N/* EUSCI_A_STATW[BUSY] Bits */
N#define EUSCI_A_STATW_BUSY_OFS                   ( 0)                            /*!< UCBUSY Bit Offset */
N#define EUSCI_A_STATW_BUSY                       ((uint16_t)0x0001)              /*!< eUSCI_A busy */
N/* EUSCI_A_STATW[ADDR_IDLE] Bits */
N#define EUSCI_A_STATW_ADDR_IDLE_OFS              ( 1)                            /*!< UCADDR_UCIDLE Bit Offset */
N#define EUSCI_A_STATW_ADDR_IDLE                  ((uint16_t)0x0002)              /*!< Address received / Idle line detected */
N/* EUSCI_A_STATW[RXERR] Bits */
N#define EUSCI_A_STATW_RXERR_OFS                  ( 2)                            /*!< UCRXERR Bit Offset */
N#define EUSCI_A_STATW_RXERR                      ((uint16_t)0x0004)              /*!< Receive error flag */
N/* EUSCI_A_STATW[BRK] Bits */
N#define EUSCI_A_STATW_BRK_OFS                    ( 3)                            /*!< UCBRK Bit Offset */
N#define EUSCI_A_STATW_BRK                        ((uint16_t)0x0008)              /*!< Break detect flag */
N/* EUSCI_A_STATW[PE] Bits */
N#define EUSCI_A_STATW_PE_OFS                     ( 4)                            /*!< UCPE Bit Offset */
N#define EUSCI_A_STATW_PE                         ((uint16_t)0x0010)              
N/* EUSCI_A_STATW[OE] Bits */
N#define EUSCI_A_STATW_OE_OFS                     ( 5)                            /*!< UCOE Bit Offset */
N#define EUSCI_A_STATW_OE                         ((uint16_t)0x0020)              /*!< Overrun error flag */
N/* EUSCI_A_STATW[FE] Bits */
N#define EUSCI_A_STATW_FE_OFS                     ( 6)                            /*!< UCFE Bit Offset */
N#define EUSCI_A_STATW_FE                         ((uint16_t)0x0040)              /*!< Framing error flag */
N/* EUSCI_A_STATW[LISTEN] Bits */
N#define EUSCI_A_STATW_LISTEN_OFS                 ( 7)                            /*!< UCLISTEN Bit Offset */
N#define EUSCI_A_STATW_LISTEN                     ((uint16_t)0x0080)              /*!< Listen enable */
N/* EUSCI_A_STATW[SPI_BUSY] Bits */
N#define EUSCI_A_STATW_SPI_BUSY_OFS               ( 0)                            /*!< UCBUSY Bit Offset */
N#define EUSCI_A_STATW_SPI_BUSY                   ((uint16_t)0x0001)              /*!< eUSCI_A busy */
N/* EUSCI_A_RXBUF[RXBUF] Bits */
N#define EUSCI_A_RXBUF_RXBUF_OFS                  ( 0)                            /*!< UCRXBUF Bit Offset */
N#define EUSCI_A_RXBUF_RXBUF_MASK                 ((uint16_t)0x00FF)              /*!< UCRXBUF Bit Mask */
N/* EUSCI_A_TXBUF[TXBUF] Bits */
N#define EUSCI_A_TXBUF_TXBUF_OFS                  ( 0)                            /*!< UCTXBUF Bit Offset */
N#define EUSCI_A_TXBUF_TXBUF_MASK                 ((uint16_t)0x00FF)              /*!< UCTXBUF Bit Mask */
N/* EUSCI_A_ABCTL[ABDEN] Bits */
N#define EUSCI_A_ABCTL_ABDEN_OFS                  ( 0)                            /*!< UCABDEN Bit Offset */
N#define EUSCI_A_ABCTL_ABDEN                      ((uint16_t)0x0001)              /*!< Automatic baud-rate detect enable */
N/* EUSCI_A_ABCTL[BTOE] Bits */
N#define EUSCI_A_ABCTL_BTOE_OFS                   ( 2)                            /*!< UCBTOE Bit Offset */
N#define EUSCI_A_ABCTL_BTOE                       ((uint16_t)0x0004)              /*!< Break time out error */
N/* EUSCI_A_ABCTL[STOE] Bits */
N#define EUSCI_A_ABCTL_STOE_OFS                   ( 3)                            /*!< UCSTOE Bit Offset */
N#define EUSCI_A_ABCTL_STOE                       ((uint16_t)0x0008)              /*!< Synch field time out error */
N/* EUSCI_A_ABCTL[DELIM] Bits */
N#define EUSCI_A_ABCTL_DELIM_OFS                  ( 4)                            /*!< UCDELIM Bit Offset */
N#define EUSCI_A_ABCTL_DELIM_MASK                 ((uint16_t)0x0030)              /*!< UCDELIM Bit Mask */
N#define EUSCI_A_ABCTL_DELIM0                     ((uint16_t)0x0010)              /*!< DELIM Bit 0 */
N#define EUSCI_A_ABCTL_DELIM1                     ((uint16_t)0x0020)              /*!< DELIM Bit 1 */
N#define EUSCI_A_ABCTL_DELIM_0                    ((uint16_t)0x0000)              /*!< 1 bit time */
N#define EUSCI_A_ABCTL_DELIM_1                    ((uint16_t)0x0010)              /*!< 2 bit times */
N#define EUSCI_A_ABCTL_DELIM_2                    ((uint16_t)0x0020)              /*!< 3 bit times */
N#define EUSCI_A_ABCTL_DELIM_3                    ((uint16_t)0x0030)              /*!< 4 bit times */
N/* EUSCI_A_IRCTL[IREN] Bits */
N#define EUSCI_A_IRCTL_IREN_OFS                   ( 0)                            /*!< UCIREN Bit Offset */
N#define EUSCI_A_IRCTL_IREN                       ((uint16_t)0x0001)              /*!< IrDA encoder/decoder enable */
N/* EUSCI_A_IRCTL[IRTXCLK] Bits */
N#define EUSCI_A_IRCTL_IRTXCLK_OFS                ( 1)                            /*!< UCIRTXCLK Bit Offset */
N#define EUSCI_A_IRCTL_IRTXCLK                    ((uint16_t)0x0002)              /*!< IrDA transmit pulse clock select */
N/* EUSCI_A_IRCTL[IRTXPL] Bits */
N#define EUSCI_A_IRCTL_IRTXPL_OFS                 ( 2)                            /*!< UCIRTXPL Bit Offset */
N#define EUSCI_A_IRCTL_IRTXPL_MASK                ((uint16_t)0x00FC)              /*!< UCIRTXPL Bit Mask */
N/* EUSCI_A_IRCTL[IRRXFE] Bits */
N#define EUSCI_A_IRCTL_IRRXFE_OFS                 ( 8)                            /*!< UCIRRXFE Bit Offset */
N#define EUSCI_A_IRCTL_IRRXFE                     ((uint16_t)0x0100)              /*!< IrDA receive filter enabled */
N/* EUSCI_A_IRCTL[IRRXPL] Bits */
N#define EUSCI_A_IRCTL_IRRXPL_OFS                 ( 9)                            /*!< UCIRRXPL Bit Offset */
N#define EUSCI_A_IRCTL_IRRXPL                     ((uint16_t)0x0200)              /*!< IrDA receive input UCAxRXD polarity */
N/* EUSCI_A_IRCTL[IRRXFL] Bits */
N#define EUSCI_A_IRCTL_IRRXFL_OFS                 (10)                            /*!< UCIRRXFL Bit Offset */
N#define EUSCI_A_IRCTL_IRRXFL_MASK                ((uint16_t)0x3C00)              /*!< UCIRRXFL Bit Mask */
N/* EUSCI_A_IE[RXIE] Bits */
N#define EUSCI_A_IE_RXIE_OFS                      ( 0)                            /*!< UCRXIE Bit Offset */
N#define EUSCI_A_IE_RXIE                          ((uint16_t)0x0001)              /*!< Receive interrupt enable */
N/* EUSCI_A_IE[TXIE] Bits */
N#define EUSCI_A_IE_TXIE_OFS                      ( 1)                            /*!< UCTXIE Bit Offset */
N#define EUSCI_A_IE_TXIE                          ((uint16_t)0x0002)              /*!< Transmit interrupt enable */
N/* EUSCI_A_IE[STTIE] Bits */
N#define EUSCI_A_IE_STTIE_OFS                     ( 2)                            /*!< UCSTTIE Bit Offset */
N#define EUSCI_A_IE_STTIE                         ((uint16_t)0x0004)              /*!< Start bit interrupt enable */
N/* EUSCI_A_IE[TXCPTIE] Bits */
N#define EUSCI_A_IE_TXCPTIE_OFS                   ( 3)                            /*!< UCTXCPTIE Bit Offset */
N#define EUSCI_A_IE_TXCPTIE                       ((uint16_t)0x0008)              /*!< Transmit complete interrupt enable */
N/* EUSCI_A_IFG[RXIFG] Bits */
N#define EUSCI_A_IFG_RXIFG_OFS                    ( 0)                            /*!< UCRXIFG Bit Offset */
N#define EUSCI_A_IFG_RXIFG                        ((uint16_t)0x0001)              /*!< Receive interrupt flag */
N/* EUSCI_A_IFG[TXIFG] Bits */
N#define EUSCI_A_IFG_TXIFG_OFS                    ( 1)                            /*!< UCTXIFG Bit Offset */
N#define EUSCI_A_IFG_TXIFG                        ((uint16_t)0x0002)              /*!< Transmit interrupt flag */
N/* EUSCI_A_IFG[STTIFG] Bits */
N#define EUSCI_A_IFG_STTIFG_OFS                   ( 2)                            /*!< UCSTTIFG Bit Offset */
N#define EUSCI_A_IFG_STTIFG                       ((uint16_t)0x0004)              /*!< Start bit interrupt flag */
N/* EUSCI_A_IFG[TXCPTIFG] Bits */
N#define EUSCI_A_IFG_TXCPTIFG_OFS                 ( 3)                            /*!< UCTXCPTIFG Bit Offset */
N#define EUSCI_A_IFG_TXCPTIFG                     ((uint16_t)0x0008)              /*!< Transmit ready interrupt enable */
N/* legacy definitions for backward compatibility to version 2100 */
N#define EUSCI_A__RXIE_OFS                        EUSCI_A_IE_RXIE_OFS             /*!< UCRXIE Bit Offset */
N#define EUSCI_A__RXIE                            EUSCI_A_IE_RXIE                 /*!< Receive interrupt enable */
N#define EUSCI_A__TXIE_OFS                        EUSCI_A_IE_TXIE_OFS             /*!< UCTXIE Bit Offset */
N#define EUSCI_A__TXIE                            EUSCI_A_IE_TXIE                 /*!< Transmit interrupt enable */
N
N
N/******************************************************************************
N* EUSCI_B Bits
N******************************************************************************/
N/* EUSCI_B_CTLW0[SWRST] Bits */
N#define EUSCI_B_CTLW0_SWRST_OFS                  ( 0)                            /*!< UCSWRST Bit Offset */
N#define EUSCI_B_CTLW0_SWRST                      ((uint16_t)0x0001)              /*!< Software reset enable */
N/* EUSCI_B_CTLW0[TXSTT] Bits */
N#define EUSCI_B_CTLW0_TXSTT_OFS                  ( 1)                            /*!< UCTXSTT Bit Offset */
N#define EUSCI_B_CTLW0_TXSTT                      ((uint16_t)0x0002)              /*!< Transmit START condition in master mode */
N/* EUSCI_B_CTLW0[TXSTP] Bits */
N#define EUSCI_B_CTLW0_TXSTP_OFS                  ( 2)                            /*!< UCTXSTP Bit Offset */
N#define EUSCI_B_CTLW0_TXSTP                      ((uint16_t)0x0004)              /*!< Transmit STOP condition in master mode */
N/* EUSCI_B_CTLW0[TXNACK] Bits */
N#define EUSCI_B_CTLW0_TXNACK_OFS                 ( 3)                            /*!< UCTXNACK Bit Offset */
N#define EUSCI_B_CTLW0_TXNACK                     ((uint16_t)0x0008)              /*!< Transmit a NACK */
N/* EUSCI_B_CTLW0[TR] Bits */
N#define EUSCI_B_CTLW0_TR_OFS                     ( 4)                            /*!< UCTR Bit Offset */
N#define EUSCI_B_CTLW0_TR                         ((uint16_t)0x0010)              /*!< Transmitter/receiver */
N/* EUSCI_B_CTLW0[TXACK] Bits */
N#define EUSCI_B_CTLW0_TXACK_OFS                  ( 5)                            /*!< UCTXACK Bit Offset */
N#define EUSCI_B_CTLW0_TXACK                      ((uint16_t)0x0020)              /*!< Transmit ACK condition in slave mode */
N/* EUSCI_B_CTLW0[SSEL] Bits */
N#define EUSCI_B_CTLW0_SSEL_OFS                   ( 6)                            /*!< UCSSEL Bit Offset */
N#define EUSCI_B_CTLW0_SSEL_MASK                  ((uint16_t)0x00C0)              /*!< UCSSEL Bit Mask */
N#define EUSCI_B_CTLW0_SSEL0                      ((uint16_t)0x0040)              /*!< SSEL Bit 0 */
N#define EUSCI_B_CTLW0_SSEL1                      ((uint16_t)0x0080)              /*!< SSEL Bit 1 */
N#define EUSCI_B_CTLW0_UCSSEL_0                   ((uint16_t)0x0000)              /*!< UCLKI */
N#define EUSCI_B_CTLW0_UCSSEL_1                   ((uint16_t)0x0040)              /*!< ACLK */
N#define EUSCI_B_CTLW0_UCSSEL_2                   ((uint16_t)0x0080)              /*!< SMCLK */
N#define EUSCI_B_CTLW0_UCSSEL_3                   ((uint16_t)0x00C0)              /*!< SMCLK */
N#define EUSCI_B_CTLW0_SSEL__UCLKI                ((uint16_t)0x0000)              /*!< UCLKI */
N#define EUSCI_B_CTLW0_SSEL__ACLK                 ((uint16_t)0x0040)              /*!< ACLK */
N#define EUSCI_B_CTLW0_SSEL__SMCLK                ((uint16_t)0x0080)              /*!< SMCLK */
N/* EUSCI_B_CTLW0[SYNC] Bits */
N#define EUSCI_B_CTLW0_SYNC_OFS                   ( 8)                            /*!< UCSYNC Bit Offset */
N#define EUSCI_B_CTLW0_SYNC                       ((uint16_t)0x0100)              /*!< Synchronous mode enable */
N/* EUSCI_B_CTLW0[MODE] Bits */
N#define EUSCI_B_CTLW0_MODE_OFS                   ( 9)                            /*!< UCMODE Bit Offset */
N#define EUSCI_B_CTLW0_MODE_MASK                  ((uint16_t)0x0600)              /*!< UCMODE Bit Mask */
N#define EUSCI_B_CTLW0_MODE0                      ((uint16_t)0x0200)              /*!< MODE Bit 0 */
N#define EUSCI_B_CTLW0_MODE1                      ((uint16_t)0x0400)              /*!< MODE Bit 1 */
N#define EUSCI_B_CTLW0_MODE_0                     ((uint16_t)0x0000)              /*!< 3-pin SPI */
N#define EUSCI_B_CTLW0_MODE_1                     ((uint16_t)0x0200)              /*!< 4-pin SPI (master or slave enabled if STE = 1) */
N#define EUSCI_B_CTLW0_MODE_2                     ((uint16_t)0x0400)              /*!< 4-pin SPI (master or slave enabled if STE = 0) */
N#define EUSCI_B_CTLW0_MODE_3                     ((uint16_t)0x0600)              /*!< I2C mode */
N/* EUSCI_B_CTLW0[MST] Bits */
N#define EUSCI_B_CTLW0_MST_OFS                    (11)                            /*!< UCMST Bit Offset */
N#define EUSCI_B_CTLW0_MST                        ((uint16_t)0x0800)              /*!< Master mode select */
N/* EUSCI_B_CTLW0[MM] Bits */
N#define EUSCI_B_CTLW0_MM_OFS                     (13)                            /*!< UCMM Bit Offset */
N#define EUSCI_B_CTLW0_MM                         ((uint16_t)0x2000)              /*!< Multi-master environment select */
N/* EUSCI_B_CTLW0[SLA10] Bits */
N#define EUSCI_B_CTLW0_SLA10_OFS                  (14)                            /*!< UCSLA10 Bit Offset */
N#define EUSCI_B_CTLW0_SLA10                      ((uint16_t)0x4000)              /*!< Slave addressing mode select */
N/* EUSCI_B_CTLW0[A10] Bits */
N#define EUSCI_B_CTLW0_A10_OFS                    (15)                            /*!< UCA10 Bit Offset */
N#define EUSCI_B_CTLW0_A10                        ((uint16_t)0x8000)              /*!< Own addressing mode select */
N/* EUSCI_B_CTLW0[STEM] Bits */
N#define EUSCI_B_CTLW0_STEM_OFS                   ( 1)                            /*!< UCSTEM Bit Offset */
N#define EUSCI_B_CTLW0_STEM                       ((uint16_t)0x0002)              /*!< STE mode select in master mode. */
N/* EUSCI_B_CTLW0[SEVENBIT] Bits */
N#define EUSCI_B_CTLW0_SEVENBIT_OFS               (12)                            /*!< UC7BIT Bit Offset */
N#define EUSCI_B_CTLW0_SEVENBIT                   ((uint16_t)0x1000)              /*!< Character length */
N/* EUSCI_B_CTLW0[MSB] Bits */
N#define EUSCI_B_CTLW0_MSB_OFS                    (13)                            /*!< UCMSB Bit Offset */
N#define EUSCI_B_CTLW0_MSB                        ((uint16_t)0x2000)              /*!< MSB first select */
N/* EUSCI_B_CTLW0[CKPL] Bits */
N#define EUSCI_B_CTLW0_CKPL_OFS                   (14)                            /*!< UCCKPL Bit Offset */
N#define EUSCI_B_CTLW0_CKPL                       ((uint16_t)0x4000)              /*!< Clock polarity select */
N/* EUSCI_B_CTLW0[CKPH] Bits */
N#define EUSCI_B_CTLW0_CKPH_OFS                   (15)                            /*!< UCCKPH Bit Offset */
N#define EUSCI_B_CTLW0_CKPH                       ((uint16_t)0x8000)              /*!< Clock phase select */
N/* EUSCI_B_CTLW1[GLIT] Bits */
N#define EUSCI_B_CTLW1_GLIT_OFS                   ( 0)                            /*!< UCGLIT Bit Offset */
N#define EUSCI_B_CTLW1_GLIT_MASK                  ((uint16_t)0x0003)              /*!< UCGLIT Bit Mask */
N#define EUSCI_B_CTLW1_GLIT0                      ((uint16_t)0x0001)              /*!< GLIT Bit 0 */
N#define EUSCI_B_CTLW1_GLIT1                      ((uint16_t)0x0002)              /*!< GLIT Bit 1 */
N#define EUSCI_B_CTLW1_GLIT_0                     ((uint16_t)0x0000)              /*!< 50 ns */
N#define EUSCI_B_CTLW1_GLIT_1                     ((uint16_t)0x0001)              /*!< 25 ns */
N#define EUSCI_B_CTLW1_GLIT_2                     ((uint16_t)0x0002)              /*!< 12.5 ns */
N#define EUSCI_B_CTLW1_GLIT_3                     ((uint16_t)0x0003)              /*!< 6.25 ns */
N/* EUSCI_B_CTLW1[ASTP] Bits */
N#define EUSCI_B_CTLW1_ASTP_OFS                   ( 2)                            /*!< UCASTP Bit Offset */
N#define EUSCI_B_CTLW1_ASTP_MASK                  ((uint16_t)0x000C)              /*!< UCASTP Bit Mask */
N#define EUSCI_B_CTLW1_ASTP0                      ((uint16_t)0x0004)              /*!< ASTP Bit 0 */
N#define EUSCI_B_CTLW1_ASTP1                      ((uint16_t)0x0008)              /*!< ASTP Bit 1 */
N#define EUSCI_B_CTLW1_ASTP_0                     ((uint16_t)0x0000)              /*!< No automatic STOP generation. The STOP condition is generated after the user  */
N                                                                                 /* sets the UCTXSTP bit. The value in UCBxTBCNT is a don't care. */
N#define EUSCI_B_CTLW1_ASTP_1                     ((uint16_t)0x0004)              /*!< UCBCNTIFG is set with the byte counter reaches the threshold defined in  */
N                                                                                 /* UCBxTBCNT */
N#define EUSCI_B_CTLW1_ASTP_2                     ((uint16_t)0x0008)              /*!< A STOP condition is generated automatically after the byte counter value  */
N                                                                                 /* reached UCBxTBCNT. UCBCNTIFG is set with the byte counter reaching the */
N                                                                                 /* threshold */
N/* EUSCI_B_CTLW1[SWACK] Bits */
N#define EUSCI_B_CTLW1_SWACK_OFS                  ( 4)                            /*!< UCSWACK Bit Offset */
N#define EUSCI_B_CTLW1_SWACK                      ((uint16_t)0x0010)              /*!< SW or HW ACK control */
N/* EUSCI_B_CTLW1[STPNACK] Bits */
N#define EUSCI_B_CTLW1_STPNACK_OFS                ( 5)                            /*!< UCSTPNACK Bit Offset */
N#define EUSCI_B_CTLW1_STPNACK                    ((uint16_t)0x0020)              /*!< ACK all master bytes */
N/* EUSCI_B_CTLW1[CLTO] Bits */
N#define EUSCI_B_CTLW1_CLTO_OFS                   ( 6)                            /*!< UCCLTO Bit Offset */
N#define EUSCI_B_CTLW1_CLTO_MASK                  ((uint16_t)0x00C0)              /*!< UCCLTO Bit Mask */
N#define EUSCI_B_CTLW1_CLTO0                      ((uint16_t)0x0040)              /*!< CLTO Bit 0 */
N#define EUSCI_B_CTLW1_CLTO1                      ((uint16_t)0x0080)              /*!< CLTO Bit 1 */
N#define EUSCI_B_CTLW1_CLTO_0                     ((uint16_t)0x0000)              /*!< Disable clock low timeout counter */
N#define EUSCI_B_CTLW1_CLTO_1                     ((uint16_t)0x0040)              /*!< 135 000 SYSCLK cycles (approximately 28 ms) */
N#define EUSCI_B_CTLW1_CLTO_2                     ((uint16_t)0x0080)              /*!< 150 000 SYSCLK cycles (approximately 31 ms) */
N#define EUSCI_B_CTLW1_CLTO_3                     ((uint16_t)0x00C0)              /*!< 165 000 SYSCLK cycles (approximately 34 ms) */
N/* EUSCI_B_CTLW1[ETXINT] Bits */
N#define EUSCI_B_CTLW1_ETXINT_OFS                 ( 8)                            /*!< UCETXINT Bit Offset */
N#define EUSCI_B_CTLW1_ETXINT                     ((uint16_t)0x0100)              /*!< Early UCTXIFG0 */
N/* EUSCI_B_STATW[BBUSY] Bits */
N#define EUSCI_B_STATW_BBUSY_OFS                  ( 4)                            /*!< UCBBUSY Bit Offset */
N#define EUSCI_B_STATW_BBUSY                      ((uint16_t)0x0010)              /*!< Bus busy */
N/* EUSCI_B_STATW[GC] Bits */
N#define EUSCI_B_STATW_GC_OFS                     ( 5)                            /*!< UCGC Bit Offset */
N#define EUSCI_B_STATW_GC                         ((uint16_t)0x0020)              /*!< General call address received */
N/* EUSCI_B_STATW[SCLLOW] Bits */
N#define EUSCI_B_STATW_SCLLOW_OFS                 ( 6)                            /*!< UCSCLLOW Bit Offset */
N#define EUSCI_B_STATW_SCLLOW                     ((uint16_t)0x0040)              /*!< SCL low */
N/* EUSCI_B_STATW[BCNT] Bits */
N#define EUSCI_B_STATW_BCNT_OFS                   ( 8)                            /*!< UCBCNT Bit Offset */
N#define EUSCI_B_STATW_BCNT_MASK                  ((uint16_t)0xFF00)              /*!< UCBCNT Bit Mask */
N/* EUSCI_B_STATW[SPI_BUSY] Bits */
N#define EUSCI_B_STATW_SPI_BUSY_OFS               ( 0)                            /*!< UCBUSY Bit Offset */
N#define EUSCI_B_STATW_SPI_BUSY                   ((uint16_t)0x0001)              /*!< eUSCI_B busy */
N/* EUSCI_B_STATW[OE] Bits */
N#define EUSCI_B_STATW_OE_OFS                     ( 5)                            /*!< UCOE Bit Offset */
N#define EUSCI_B_STATW_OE                         ((uint16_t)0x0020)              /*!< Overrun error flag */
N/* EUSCI_B_STATW[FE] Bits */
N#define EUSCI_B_STATW_FE_OFS                     ( 6)                            /*!< UCFE Bit Offset */
N#define EUSCI_B_STATW_FE                         ((uint16_t)0x0040)              /*!< Framing error flag */
N/* EUSCI_B_STATW[LISTEN] Bits */
N#define EUSCI_B_STATW_LISTEN_OFS                 ( 7)                            /*!< UCLISTEN Bit Offset */
N#define EUSCI_B_STATW_LISTEN                     ((uint16_t)0x0080)              /*!< Listen enable */
N/* EUSCI_B_TBCNT[TBCNT] Bits */
N#define EUSCI_B_TBCNT_TBCNT_OFS                  ( 0)                            /*!< UCTBCNT Bit Offset */
N#define EUSCI_B_TBCNT_TBCNT_MASK                 ((uint16_t)0x00FF)              /*!< UCTBCNT Bit Mask */
N/* EUSCI_B_RXBUF[RXBUF] Bits */
N#define EUSCI_B_RXBUF_RXBUF_OFS                  ( 0)                            /*!< UCRXBUF Bit Offset */
N#define EUSCI_B_RXBUF_RXBUF_MASK                 ((uint16_t)0x00FF)              /*!< UCRXBUF Bit Mask */
N/* EUSCI_B_TXBUF[TXBUF] Bits */
N#define EUSCI_B_TXBUF_TXBUF_OFS                  ( 0)                            /*!< UCTXBUF Bit Offset */
N#define EUSCI_B_TXBUF_TXBUF_MASK                 ((uint16_t)0x00FF)              /*!< UCTXBUF Bit Mask */
N/* EUSCI_B_I2COA0[I2COA0] Bits */
N#define EUSCI_B_I2COA0_I2COA0_OFS                ( 0)                            /*!< I2COA0 Bit Offset */
N#define EUSCI_B_I2COA0_I2COA0_MASK               ((uint16_t)0x03FF)              /*!< I2COA0 Bit Mask */
N/* EUSCI_B_I2COA0[OAEN] Bits */
N#define EUSCI_B_I2COA0_OAEN_OFS                  (10)                            /*!< UCOAEN Bit Offset */
N#define EUSCI_B_I2COA0_OAEN                      ((uint16_t)0x0400)              /*!< Own Address enable register */
N/* EUSCI_B_I2COA0[GCEN] Bits */
N#define EUSCI_B_I2COA0_GCEN_OFS                  (15)                            /*!< UCGCEN Bit Offset */
N#define EUSCI_B_I2COA0_GCEN                      ((uint16_t)0x8000)              /*!< General call response enable */
N/* EUSCI_B_I2COA1[I2COA1] Bits */
N#define EUSCI_B_I2COA1_I2COA1_OFS                ( 0)                            /*!< I2COA1 Bit Offset */
N#define EUSCI_B_I2COA1_I2COA1_MASK               ((uint16_t)0x03FF)              /*!< I2COA1 Bit Mask */
N/* EUSCI_B_I2COA1[OAEN] Bits */
N#define EUSCI_B_I2COA1_OAEN_OFS                  (10)                            /*!< UCOAEN Bit Offset */
N#define EUSCI_B_I2COA1_OAEN                      ((uint16_t)0x0400)              /*!< Own Address enable register */
N/* EUSCI_B_I2COA2[I2COA2] Bits */
N#define EUSCI_B_I2COA2_I2COA2_OFS                ( 0)                            /*!< I2COA2 Bit Offset */
N#define EUSCI_B_I2COA2_I2COA2_MASK               ((uint16_t)0x03FF)              /*!< I2COA2 Bit Mask */
N/* EUSCI_B_I2COA2[OAEN] Bits */
N#define EUSCI_B_I2COA2_OAEN_OFS                  (10)                            /*!< UCOAEN Bit Offset */
N#define EUSCI_B_I2COA2_OAEN                      ((uint16_t)0x0400)              /*!< Own Address enable register */
N/* EUSCI_B_I2COA3[I2COA3] Bits */
N#define EUSCI_B_I2COA3_I2COA3_OFS                ( 0)                            /*!< I2COA3 Bit Offset */
N#define EUSCI_B_I2COA3_I2COA3_MASK               ((uint16_t)0x03FF)              /*!< I2COA3 Bit Mask */
N/* EUSCI_B_I2COA3[OAEN] Bits */
N#define EUSCI_B_I2COA3_OAEN_OFS                  (10)                            /*!< UCOAEN Bit Offset */
N#define EUSCI_B_I2COA3_OAEN                      ((uint16_t)0x0400)              /*!< Own Address enable register */
N/* EUSCI_B_ADDRX[ADDRX] Bits */
N#define EUSCI_B_ADDRX_ADDRX_OFS                  ( 0)                            /*!< ADDRX Bit Offset */
N#define EUSCI_B_ADDRX_ADDRX_MASK                 ((uint16_t)0x03FF)              /*!< ADDRX Bit Mask */
N#define EUSCI_B_ADDRX_ADDRX0                     ((uint16_t)0x0001)              /*!< ADDRX Bit 0 */
N#define EUSCI_B_ADDRX_ADDRX1                     ((uint16_t)0x0002)              /*!< ADDRX Bit 1 */
N#define EUSCI_B_ADDRX_ADDRX2                     ((uint16_t)0x0004)              /*!< ADDRX Bit 2 */
N#define EUSCI_B_ADDRX_ADDRX3                     ((uint16_t)0x0008)              /*!< ADDRX Bit 3 */
N#define EUSCI_B_ADDRX_ADDRX4                     ((uint16_t)0x0010)              /*!< ADDRX Bit 4 */
N#define EUSCI_B_ADDRX_ADDRX5                     ((uint16_t)0x0020)              /*!< ADDRX Bit 5 */
N#define EUSCI_B_ADDRX_ADDRX6                     ((uint16_t)0x0040)              /*!< ADDRX Bit 6 */
N#define EUSCI_B_ADDRX_ADDRX7                     ((uint16_t)0x0080)              /*!< ADDRX Bit 7 */
N#define EUSCI_B_ADDRX_ADDRX8                     ((uint16_t)0x0100)              /*!< ADDRX Bit 8 */
N#define EUSCI_B_ADDRX_ADDRX9                     ((uint16_t)0x0200)              /*!< ADDRX Bit 9 */
N/* EUSCI_B_ADDMASK[ADDMASK] Bits */
N#define EUSCI_B_ADDMASK_ADDMASK_OFS              ( 0)                            /*!< ADDMASK Bit Offset */
N#define EUSCI_B_ADDMASK_ADDMASK_MASK             ((uint16_t)0x03FF)              /*!< ADDMASK Bit Mask */
N/* EUSCI_B_I2CSA[I2CSA] Bits */
N#define EUSCI_B_I2CSA_I2CSA_OFS                  ( 0)                            /*!< I2CSA Bit Offset */
N#define EUSCI_B_I2CSA_I2CSA_MASK                 ((uint16_t)0x03FF)              /*!< I2CSA Bit Mask */
N/* EUSCI_B_IE[RXIE0] Bits */
N#define EUSCI_B_IE_RXIE0_OFS                     ( 0)                            /*!< UCRXIE0 Bit Offset */
N#define EUSCI_B_IE_RXIE0                         ((uint16_t)0x0001)              /*!< Receive interrupt enable 0 */
N/* EUSCI_B_IE[TXIE0] Bits */
N#define EUSCI_B_IE_TXIE0_OFS                     ( 1)                            /*!< UCTXIE0 Bit Offset */
N#define EUSCI_B_IE_TXIE0                         ((uint16_t)0x0002)              /*!< Transmit interrupt enable 0 */
N/* EUSCI_B_IE[STTIE] Bits */
N#define EUSCI_B_IE_STTIE_OFS                     ( 2)                            /*!< UCSTTIE Bit Offset */
N#define EUSCI_B_IE_STTIE                         ((uint16_t)0x0004)              /*!< START condition interrupt enable */
N/* EUSCI_B_IE[STPIE] Bits */
N#define EUSCI_B_IE_STPIE_OFS                     ( 3)                            /*!< UCSTPIE Bit Offset */
N#define EUSCI_B_IE_STPIE                         ((uint16_t)0x0008)              /*!< STOP condition interrupt enable */
N/* EUSCI_B_IE[ALIE] Bits */
N#define EUSCI_B_IE_ALIE_OFS                      ( 4)                            /*!< UCALIE Bit Offset */
N#define EUSCI_B_IE_ALIE                          ((uint16_t)0x0010)              /*!< Arbitration lost interrupt enable */
N/* EUSCI_B_IE[NACKIE] Bits */
N#define EUSCI_B_IE_NACKIE_OFS                    ( 5)                            /*!< UCNACKIE Bit Offset */
N#define EUSCI_B_IE_NACKIE                        ((uint16_t)0x0020)              /*!< Not-acknowledge interrupt enable */
N/* EUSCI_B_IE[BCNTIE] Bits */
N#define EUSCI_B_IE_BCNTIE_OFS                    ( 6)                            /*!< UCBCNTIE Bit Offset */
N#define EUSCI_B_IE_BCNTIE                        ((uint16_t)0x0040)              /*!< Byte counter interrupt enable */
N/* EUSCI_B_IE[CLTOIE] Bits */
N#define EUSCI_B_IE_CLTOIE_OFS                    ( 7)                            /*!< UCCLTOIE Bit Offset */
N#define EUSCI_B_IE_CLTOIE                        ((uint16_t)0x0080)              /*!< Clock low timeout interrupt enable */
N/* EUSCI_B_IE[RXIE1] Bits */
N#define EUSCI_B_IE_RXIE1_OFS                     ( 8)                            /*!< UCRXIE1 Bit Offset */
N#define EUSCI_B_IE_RXIE1                         ((uint16_t)0x0100)              /*!< Receive interrupt enable 1 */
N/* EUSCI_B_IE[TXIE1] Bits */
N#define EUSCI_B_IE_TXIE1_OFS                     ( 9)                            /*!< UCTXIE1 Bit Offset */
N#define EUSCI_B_IE_TXIE1                         ((uint16_t)0x0200)              /*!< Transmit interrupt enable 1 */
N/* EUSCI_B_IE[RXIE2] Bits */
N#define EUSCI_B_IE_RXIE2_OFS                     (10)                            /*!< UCRXIE2 Bit Offset */
N#define EUSCI_B_IE_RXIE2                         ((uint16_t)0x0400)              /*!< Receive interrupt enable 2 */
N/* EUSCI_B_IE[TXIE2] Bits */
N#define EUSCI_B_IE_TXIE2_OFS                     (11)                            /*!< UCTXIE2 Bit Offset */
N#define EUSCI_B_IE_TXIE2                         ((uint16_t)0x0800)              /*!< Transmit interrupt enable 2 */
N/* EUSCI_B_IE[RXIE3] Bits */
N#define EUSCI_B_IE_RXIE3_OFS                     (12)                            /*!< UCRXIE3 Bit Offset */
N#define EUSCI_B_IE_RXIE3                         ((uint16_t)0x1000)              /*!< Receive interrupt enable 3 */
N/* EUSCI_B_IE[TXIE3] Bits */
N#define EUSCI_B_IE_TXIE3_OFS                     (13)                            /*!< UCTXIE3 Bit Offset */
N#define EUSCI_B_IE_TXIE3                         ((uint16_t)0x2000)              /*!< Transmit interrupt enable 3 */
N/* EUSCI_B_IE[BIT9IE] Bits */
N#define EUSCI_B_IE_BIT9IE_OFS                    (14)                            /*!< UCBIT9IE Bit Offset */
N#define EUSCI_B_IE_BIT9IE                        ((uint16_t)0x4000)              /*!< Bit position 9 interrupt enable */
N/* EUSCI_B_IE[RXIE] Bits */
N#define EUSCI_B_IE_RXIE_OFS                      ( 0)                            /*!< UCRXIE Bit Offset */
N#define EUSCI_B_IE_RXIE                          ((uint16_t)0x0001)              /*!< Receive interrupt enable */
N/* EUSCI_B_IE[TXIE] Bits */
N#define EUSCI_B_IE_TXIE_OFS                      ( 1)                            /*!< UCTXIE Bit Offset */
N#define EUSCI_B_IE_TXIE                          ((uint16_t)0x0002)              /*!< Transmit interrupt enable */
N/* EUSCI_B_IFG[RXIFG0] Bits */
N#define EUSCI_B_IFG_RXIFG0_OFS                   ( 0)                            /*!< UCRXIFG0 Bit Offset */
N#define EUSCI_B_IFG_RXIFG0                       ((uint16_t)0x0001)              /*!< eUSCI_B receive interrupt flag 0 */
N/* EUSCI_B_IFG[TXIFG0] Bits */
N#define EUSCI_B_IFG_TXIFG0_OFS                   ( 1)                            /*!< UCTXIFG0 Bit Offset */
N#define EUSCI_B_IFG_TXIFG0                       ((uint16_t)0x0002)              /*!< eUSCI_B transmit interrupt flag 0 */
N/* EUSCI_B_IFG[STTIFG] Bits */
N#define EUSCI_B_IFG_STTIFG_OFS                   ( 2)                            /*!< UCSTTIFG Bit Offset */
N#define EUSCI_B_IFG_STTIFG                       ((uint16_t)0x0004)              /*!< START condition interrupt flag */
N/* EUSCI_B_IFG[STPIFG] Bits */
N#define EUSCI_B_IFG_STPIFG_OFS                   ( 3)                            /*!< UCSTPIFG Bit Offset */
N#define EUSCI_B_IFG_STPIFG                       ((uint16_t)0x0008)              /*!< STOP condition interrupt flag */
N/* EUSCI_B_IFG[ALIFG] Bits */
N#define EUSCI_B_IFG_ALIFG_OFS                    ( 4)                            /*!< UCALIFG Bit Offset */
N#define EUSCI_B_IFG_ALIFG                        ((uint16_t)0x0010)              /*!< Arbitration lost interrupt flag */
N/* EUSCI_B_IFG[NACKIFG] Bits */
N#define EUSCI_B_IFG_NACKIFG_OFS                  ( 5)                            /*!< UCNACKIFG Bit Offset */
N#define EUSCI_B_IFG_NACKIFG                      ((uint16_t)0x0020)              /*!< Not-acknowledge received interrupt flag */
N/* EUSCI_B_IFG[BCNTIFG] Bits */
N#define EUSCI_B_IFG_BCNTIFG_OFS                  ( 6)                            /*!< UCBCNTIFG Bit Offset */
N#define EUSCI_B_IFG_BCNTIFG                      ((uint16_t)0x0040)              /*!< Byte counter interrupt flag */
N/* EUSCI_B_IFG[CLTOIFG] Bits */
N#define EUSCI_B_IFG_CLTOIFG_OFS                  ( 7)                            /*!< UCCLTOIFG Bit Offset */
N#define EUSCI_B_IFG_CLTOIFG                      ((uint16_t)0x0080)              /*!< Clock low timeout interrupt flag */
N/* EUSCI_B_IFG[RXIFG1] Bits */
N#define EUSCI_B_IFG_RXIFG1_OFS                   ( 8)                            /*!< UCRXIFG1 Bit Offset */
N#define EUSCI_B_IFG_RXIFG1                       ((uint16_t)0x0100)              /*!< eUSCI_B receive interrupt flag 1 */
N/* EUSCI_B_IFG[TXIFG1] Bits */
N#define EUSCI_B_IFG_TXIFG1_OFS                   ( 9)                            /*!< UCTXIFG1 Bit Offset */
N#define EUSCI_B_IFG_TXIFG1                       ((uint16_t)0x0200)              /*!< eUSCI_B transmit interrupt flag 1 */
N/* EUSCI_B_IFG[RXIFG2] Bits */
N#define EUSCI_B_IFG_RXIFG2_OFS                   (10)                            /*!< UCRXIFG2 Bit Offset */
N#define EUSCI_B_IFG_RXIFG2                       ((uint16_t)0x0400)              /*!< eUSCI_B receive interrupt flag 2 */
N/* EUSCI_B_IFG[TXIFG2] Bits */
N#define EUSCI_B_IFG_TXIFG2_OFS                   (11)                            /*!< UCTXIFG2 Bit Offset */
N#define EUSCI_B_IFG_TXIFG2                       ((uint16_t)0x0800)              /*!< eUSCI_B transmit interrupt flag 2 */
N/* EUSCI_B_IFG[RXIFG3] Bits */
N#define EUSCI_B_IFG_RXIFG3_OFS                   (12)                            /*!< UCRXIFG3 Bit Offset */
N#define EUSCI_B_IFG_RXIFG3                       ((uint16_t)0x1000)              /*!< eUSCI_B receive interrupt flag 3 */
N/* EUSCI_B_IFG[TXIFG3] Bits */
N#define EUSCI_B_IFG_TXIFG3_OFS                   (13)                            /*!< UCTXIFG3 Bit Offset */
N#define EUSCI_B_IFG_TXIFG3                       ((uint16_t)0x2000)              /*!< eUSCI_B transmit interrupt flag 3 */
N/* EUSCI_B_IFG[BIT9IFG] Bits */
N#define EUSCI_B_IFG_BIT9IFG_OFS                  (14)                            /*!< UCBIT9IFG Bit Offset */
N#define EUSCI_B_IFG_BIT9IFG                      ((uint16_t)0x4000)              /*!< Bit position 9 interrupt flag */
N/* EUSCI_B_IFG[RXIFG] Bits */
N#define EUSCI_B_IFG_RXIFG_OFS                    ( 0)                            /*!< UCRXIFG Bit Offset */
N#define EUSCI_B_IFG_RXIFG                        ((uint16_t)0x0001)              /*!< Receive interrupt flag */
N/* EUSCI_B_IFG[TXIFG] Bits */
N#define EUSCI_B_IFG_TXIFG_OFS                    ( 1)                            /*!< UCTXIFG Bit Offset */
N#define EUSCI_B_IFG_TXIFG                        ((uint16_t)0x0002)              /*!< Transmit interrupt flag */
N/* legacy definitions for backward compatibility to version 2100 */
N#define EUSCI_B__RXIE_OFS                        EUSCI_B_IE_RXIE_OFS             /*!< UCRXIE Bit Offset */
N#define EUSCI_B__RXIE                            EUSCI_B_IE_RXIE                 /*!< Receive interrupt enable */
N#define EUSCI_B__TXIE_OFS                        EUSCI_B_IE_TXIE_OFS             /*!< UCTXIE Bit Offset */
N#define EUSCI_B__TXIE                            EUSCI_B_IE_TXIE                 /*!< Transmit interrupt enable */
N
N
N/******************************************************************************
N* FLCTL Bits
N******************************************************************************/
N/* FLCTL_POWER_STAT[PSTAT] Bits */
N#define FLCTL_POWER_STAT_PSTAT_OFS               ( 0)                            /*!< PSTAT Bit Offset */
N#define FLCTL_POWER_STAT_PSTAT_MASK              ((uint32_t)0x00000007)          /*!< PSTAT Bit Mask */
N#define FLCTL_POWER_STAT_PSTAT0                  ((uint32_t)0x00000001)          /*!< PSTAT Bit 0 */
N#define FLCTL_POWER_STAT_PSTAT1                  ((uint32_t)0x00000002)          /*!< PSTAT Bit 1 */
N#define FLCTL_POWER_STAT_PSTAT2                  ((uint32_t)0x00000004)          /*!< PSTAT Bit 2 */
N#define FLCTL_POWER_STAT_PSTAT_0                 ((uint32_t)0x00000000)          /*!< Flash IP in power-down mode */
N#define FLCTL_POWER_STAT_PSTAT_1                 ((uint32_t)0x00000001)          /*!< Flash IP Vdd domain power-up in progress */
N#define FLCTL_POWER_STAT_PSTAT_2                 ((uint32_t)0x00000002)          /*!< PSS LDO_GOOD, IREF_OK and VREF_OK check in progress */
N#define FLCTL_POWER_STAT_PSTAT_3                 ((uint32_t)0x00000003)          /*!< Flash IP SAFE_LV check in progress */
N#define FLCTL_POWER_STAT_PSTAT_4                 ((uint32_t)0x00000004)          /*!< Flash IP Active */
N#define FLCTL_POWER_STAT_PSTAT_5                 ((uint32_t)0x00000005)          /*!< Flash IP Active in Low-Frequency Active and Low-Frequency LPM0 modes. */
N#define FLCTL_POWER_STAT_PSTAT_6                 ((uint32_t)0x00000006)          /*!< Flash IP in Standby mode */
N#define FLCTL_POWER_STAT_PSTAT_7                 ((uint32_t)0x00000007)          /*!< Flash IP in Current mirror boost state */
N/* FLCTL_POWER_STAT[LDOSTAT] Bits */
N#define FLCTL_POWER_STAT_LDOSTAT_OFS             ( 3)                            /*!< LDOSTAT Bit Offset */
N#define FLCTL_POWER_STAT_LDOSTAT                 ((uint32_t)0x00000008)          /*!< PSS FLDO GOOD status */
N/* FLCTL_POWER_STAT[VREFSTAT] Bits */
N#define FLCTL_POWER_STAT_VREFSTAT_OFS            ( 4)                            /*!< VREFSTAT Bit Offset */
N#define FLCTL_POWER_STAT_VREFSTAT                ((uint32_t)0x00000010)          /*!< PSS VREF stable status */
N/* FLCTL_POWER_STAT[IREFSTAT] Bits */
N#define FLCTL_POWER_STAT_IREFSTAT_OFS            ( 5)                            /*!< IREFSTAT Bit Offset */
N#define FLCTL_POWER_STAT_IREFSTAT                ((uint32_t)0x00000020)          /*!< PSS IREF stable status */
N/* FLCTL_POWER_STAT[TRIMSTAT] Bits */
N#define FLCTL_POWER_STAT_TRIMSTAT_OFS            ( 6)                            /*!< TRIMSTAT Bit Offset */
N#define FLCTL_POWER_STAT_TRIMSTAT                ((uint32_t)0x00000040)          /*!< PSS trim done status */
N/* FLCTL_POWER_STAT[RD_2T] Bits */
N#define FLCTL_POWER_STAT_RD_2T_OFS               ( 7)                            /*!< RD_2T Bit Offset */
N#define FLCTL_POWER_STAT_RD_2T                   ((uint32_t)0x00000080)          /*!< Indicates if Flash is being accessed in 2T mode */
N/* FLCTL_BANK0_RDCTL[RD_MODE] Bits */
N#define FLCTL_BANK0_RDCTL_RD_MODE_OFS            ( 0)                            /*!< RD_MODE Bit Offset */
N#define FLCTL_BANK0_RDCTL_RD_MODE_MASK           ((uint32_t)0x0000000F)          /*!< RD_MODE Bit Mask */
N#define FLCTL_BANK0_RDCTL_RD_MODE0               ((uint32_t)0x00000001)          /*!< RD_MODE Bit 0 */
N#define FLCTL_BANK0_RDCTL_RD_MODE1               ((uint32_t)0x00000002)          /*!< RD_MODE Bit 1 */
N#define FLCTL_BANK0_RDCTL_RD_MODE2               ((uint32_t)0x00000004)          /*!< RD_MODE Bit 2 */
N#define FLCTL_BANK0_RDCTL_RD_MODE3               ((uint32_t)0x00000008)          /*!< RD_MODE Bit 3 */
N#define FLCTL_BANK0_RDCTL_RD_MODE_0              ((uint32_t)0x00000000)          /*!< Normal read mode */
N#define FLCTL_BANK0_RDCTL_RD_MODE_1              ((uint32_t)0x00000001)          /*!< Read Margin 0 */
N#define FLCTL_BANK0_RDCTL_RD_MODE_2              ((uint32_t)0x00000002)          /*!< Read Margin 1 */
N#define FLCTL_BANK0_RDCTL_RD_MODE_3              ((uint32_t)0x00000003)          /*!< Program Verify */
N#define FLCTL_BANK0_RDCTL_RD_MODE_4              ((uint32_t)0x00000004)          /*!< Erase Verify */
N#define FLCTL_BANK0_RDCTL_RD_MODE_5              ((uint32_t)0x00000005)          /*!< Leakage Verify */
N#define FLCTL_BANK0_RDCTL_RD_MODE_9              ((uint32_t)0x00000009)          /*!< Read Margin 0B */
N#define FLCTL_BANK0_RDCTL_RD_MODE_10             ((uint32_t)0x0000000A)          /*!< Read Margin 1B */
N/* FLCTL_BANK0_RDCTL[BUFI] Bits */
N#define FLCTL_BANK0_RDCTL_BUFI_OFS               ( 4)                            /*!< BUFI Bit Offset */
N#define FLCTL_BANK0_RDCTL_BUFI                   ((uint32_t)0x00000010)          /*!< Enables read buffering feature for instruction fetches to this Bank */
N/* FLCTL_BANK0_RDCTL[BUFD] Bits */
N#define FLCTL_BANK0_RDCTL_BUFD_OFS               ( 5)                            /*!< BUFD Bit Offset */
N#define FLCTL_BANK0_RDCTL_BUFD                   ((uint32_t)0x00000020)          /*!< Enables read buffering feature for data reads to this Bank */
N/* FLCTL_BANK0_RDCTL[WAIT] Bits */
N#define FLCTL_BANK0_RDCTL_WAIT_OFS               (12)                            /*!< WAIT Bit Offset */
N#define FLCTL_BANK0_RDCTL_WAIT_MASK              ((uint32_t)0x0000F000)          /*!< WAIT Bit Mask */
N#define FLCTL_BANK0_RDCTL_WAIT0                  ((uint32_t)0x00001000)          /*!< WAIT Bit 0 */
N#define FLCTL_BANK0_RDCTL_WAIT1                  ((uint32_t)0x00002000)          /*!< WAIT Bit 1 */
N#define FLCTL_BANK0_RDCTL_WAIT2                  ((uint32_t)0x00004000)          /*!< WAIT Bit 2 */
N#define FLCTL_BANK0_RDCTL_WAIT3                  ((uint32_t)0x00008000)          /*!< WAIT Bit 3 */
N#define FLCTL_BANK0_RDCTL_WAIT_0                 ((uint32_t)0x00000000)          /*!< 0 wait states */
N#define FLCTL_BANK0_RDCTL_WAIT_1                 ((uint32_t)0x00001000)          /*!< 1 wait states */
N#define FLCTL_BANK0_RDCTL_WAIT_2                 ((uint32_t)0x00002000)          /*!< 2 wait states */
N#define FLCTL_BANK0_RDCTL_WAIT_3                 ((uint32_t)0x00003000)          /*!< 3 wait states */
N#define FLCTL_BANK0_RDCTL_WAIT_4                 ((uint32_t)0x00004000)          /*!< 4 wait states */
N#define FLCTL_BANK0_RDCTL_WAIT_5                 ((uint32_t)0x00005000)          /*!< 5 wait states */
N#define FLCTL_BANK0_RDCTL_WAIT_6                 ((uint32_t)0x00006000)          /*!< 6 wait states */
N#define FLCTL_BANK0_RDCTL_WAIT_7                 ((uint32_t)0x00007000)          /*!< 7 wait states */
N#define FLCTL_BANK0_RDCTL_WAIT_8                 ((uint32_t)0x00008000)          /*!< 8 wait states */
N#define FLCTL_BANK0_RDCTL_WAIT_9                 ((uint32_t)0x00009000)          /*!< 9 wait states */
N#define FLCTL_BANK0_RDCTL_WAIT_10                ((uint32_t)0x0000A000)          /*!< 10 wait states */
N#define FLCTL_BANK0_RDCTL_WAIT_11                ((uint32_t)0x0000B000)          /*!< 11 wait states */
N#define FLCTL_BANK0_RDCTL_WAIT_12                ((uint32_t)0x0000C000)          /*!< 12 wait states */
N#define FLCTL_BANK0_RDCTL_WAIT_13                ((uint32_t)0x0000D000)          /*!< 13 wait states */
N#define FLCTL_BANK0_RDCTL_WAIT_14                ((uint32_t)0x0000E000)          /*!< 14 wait states */
N#define FLCTL_BANK0_RDCTL_WAIT_15                ((uint32_t)0x0000F000)          /*!< 15 wait states */
N/* FLCTL_BANK0_RDCTL[RD_MODE_STATUS] Bits */
N#define FLCTL_BANK0_RDCTL_RD_MODE_STATUS_OFS     (16)                            /*!< RD_MODE_STATUS Bit Offset */
N#define FLCTL_BANK0_RDCTL_RD_MODE_STATUS_MASK    ((uint32_t)0x000F0000)          /*!< RD_MODE_STATUS Bit Mask */
N#define FLCTL_BANK0_RDCTL_RD_MODE_STATUS0        ((uint32_t)0x00010000)          /*!< RD_MODE_STATUS Bit 0 */
N#define FLCTL_BANK0_RDCTL_RD_MODE_STATUS1        ((uint32_t)0x00020000)          /*!< RD_MODE_STATUS Bit 1 */
N#define FLCTL_BANK0_RDCTL_RD_MODE_STATUS2        ((uint32_t)0x00040000)          /*!< RD_MODE_STATUS Bit 2 */
N#define FLCTL_BANK0_RDCTL_RD_MODE_STATUS3        ((uint32_t)0x00080000)          /*!< RD_MODE_STATUS Bit 3 */
N#define FLCTL_BANK0_RDCTL_RD_MODE_STATUS_0       ((uint32_t)0x00000000)          /*!< Normal read mode */
N#define FLCTL_BANK0_RDCTL_RD_MODE_STATUS_1       ((uint32_t)0x00010000)          /*!< Read Margin 0 */
N#define FLCTL_BANK0_RDCTL_RD_MODE_STATUS_2       ((uint32_t)0x00020000)          /*!< Read Margin 1 */
N#define FLCTL_BANK0_RDCTL_RD_MODE_STATUS_3       ((uint32_t)0x00030000)          /*!< Program Verify */
N#define FLCTL_BANK0_RDCTL_RD_MODE_STATUS_4       ((uint32_t)0x00040000)          /*!< Erase Verify */
N#define FLCTL_BANK0_RDCTL_RD_MODE_STATUS_5       ((uint32_t)0x00050000)          /*!< Leakage Verify */
N#define FLCTL_BANK0_RDCTL_RD_MODE_STATUS_9       ((uint32_t)0x00090000)          /*!< Read Margin 0B */
N#define FLCTL_BANK0_RDCTL_RD_MODE_STATUS_10      ((uint32_t)0x000A0000)          /*!< Read Margin 1B */
N/* FLCTL_BANK1_RDCTL[RD_MODE] Bits */
N#define FLCTL_BANK1_RDCTL_RD_MODE_OFS            ( 0)                            /*!< RD_MODE Bit Offset */
N#define FLCTL_BANK1_RDCTL_RD_MODE_MASK           ((uint32_t)0x0000000F)          /*!< RD_MODE Bit Mask */
N#define FLCTL_BANK1_RDCTL_RD_MODE0               ((uint32_t)0x00000001)          /*!< RD_MODE Bit 0 */
N#define FLCTL_BANK1_RDCTL_RD_MODE1               ((uint32_t)0x00000002)          /*!< RD_MODE Bit 1 */
N#define FLCTL_BANK1_RDCTL_RD_MODE2               ((uint32_t)0x00000004)          /*!< RD_MODE Bit 2 */
N#define FLCTL_BANK1_RDCTL_RD_MODE3               ((uint32_t)0x00000008)          /*!< RD_MODE Bit 3 */
N#define FLCTL_BANK1_RDCTL_RD_MODE_0              ((uint32_t)0x00000000)          /*!< Normal read mode */
N#define FLCTL_BANK1_RDCTL_RD_MODE_1              ((uint32_t)0x00000001)          /*!< Read Margin 0 */
N#define FLCTL_BANK1_RDCTL_RD_MODE_2              ((uint32_t)0x00000002)          /*!< Read Margin 1 */
N#define FLCTL_BANK1_RDCTL_RD_MODE_3              ((uint32_t)0x00000003)          /*!< Program Verify */
N#define FLCTL_BANK1_RDCTL_RD_MODE_4              ((uint32_t)0x00000004)          /*!< Erase Verify */
N#define FLCTL_BANK1_RDCTL_RD_MODE_5              ((uint32_t)0x00000005)          /*!< Leakage Verify */
N#define FLCTL_BANK1_RDCTL_RD_MODE_9              ((uint32_t)0x00000009)          /*!< Read Margin 0B */
N#define FLCTL_BANK1_RDCTL_RD_MODE_10             ((uint32_t)0x0000000A)          /*!< Read Margin 1B */
N/* FLCTL_BANK1_RDCTL[BUFI] Bits */
N#define FLCTL_BANK1_RDCTL_BUFI_OFS               ( 4)                            /*!< BUFI Bit Offset */
N#define FLCTL_BANK1_RDCTL_BUFI                   ((uint32_t)0x00000010)          /*!< Enables read buffering feature for instruction fetches to this Bank */
N/* FLCTL_BANK1_RDCTL[BUFD] Bits */
N#define FLCTL_BANK1_RDCTL_BUFD_OFS               ( 5)                            /*!< BUFD Bit Offset */
N#define FLCTL_BANK1_RDCTL_BUFD                   ((uint32_t)0x00000020)          /*!< Enables read buffering feature for data reads to this Bank */
N/* FLCTL_BANK1_RDCTL[RD_MODE_STATUS] Bits */
N#define FLCTL_BANK1_RDCTL_RD_MODE_STATUS_OFS     (16)                            /*!< RD_MODE_STATUS Bit Offset */
N#define FLCTL_BANK1_RDCTL_RD_MODE_STATUS_MASK    ((uint32_t)0x000F0000)          /*!< RD_MODE_STATUS Bit Mask */
N#define FLCTL_BANK1_RDCTL_RD_MODE_STATUS0        ((uint32_t)0x00010000)          /*!< RD_MODE_STATUS Bit 0 */
N#define FLCTL_BANK1_RDCTL_RD_MODE_STATUS1        ((uint32_t)0x00020000)          /*!< RD_MODE_STATUS Bit 1 */
N#define FLCTL_BANK1_RDCTL_RD_MODE_STATUS2        ((uint32_t)0x00040000)          /*!< RD_MODE_STATUS Bit 2 */
N#define FLCTL_BANK1_RDCTL_RD_MODE_STATUS3        ((uint32_t)0x00080000)          /*!< RD_MODE_STATUS Bit 3 */
N#define FLCTL_BANK1_RDCTL_RD_MODE_STATUS_0       ((uint32_t)0x00000000)          /*!< Normal read mode */
N#define FLCTL_BANK1_RDCTL_RD_MODE_STATUS_1       ((uint32_t)0x00010000)          /*!< Read Margin 0 */
N#define FLCTL_BANK1_RDCTL_RD_MODE_STATUS_2       ((uint32_t)0x00020000)          /*!< Read Margin 1 */
N#define FLCTL_BANK1_RDCTL_RD_MODE_STATUS_3       ((uint32_t)0x00030000)          /*!< Program Verify */
N#define FLCTL_BANK1_RDCTL_RD_MODE_STATUS_4       ((uint32_t)0x00040000)          /*!< Erase Verify */
N#define FLCTL_BANK1_RDCTL_RD_MODE_STATUS_5       ((uint32_t)0x00050000)          /*!< Leakage Verify */
N#define FLCTL_BANK1_RDCTL_RD_MODE_STATUS_9       ((uint32_t)0x00090000)          /*!< Read Margin 0B */
N#define FLCTL_BANK1_RDCTL_RD_MODE_STATUS_10      ((uint32_t)0x000A0000)          /*!< Read Margin 1B */
N/* FLCTL_BANK1_RDCTL[WAIT] Bits */
N#define FLCTL_BANK1_RDCTL_WAIT_OFS               (12)                            /*!< WAIT Bit Offset */
N#define FLCTL_BANK1_RDCTL_WAIT_MASK              ((uint32_t)0x0000F000)          /*!< WAIT Bit Mask */
N#define FLCTL_BANK1_RDCTL_WAIT0                  ((uint32_t)0x00001000)          /*!< WAIT Bit 0 */
N#define FLCTL_BANK1_RDCTL_WAIT1                  ((uint32_t)0x00002000)          /*!< WAIT Bit 1 */
N#define FLCTL_BANK1_RDCTL_WAIT2                  ((uint32_t)0x00004000)          /*!< WAIT Bit 2 */
N#define FLCTL_BANK1_RDCTL_WAIT3                  ((uint32_t)0x00008000)          /*!< WAIT Bit 3 */
N#define FLCTL_BANK1_RDCTL_WAIT_0                 ((uint32_t)0x00000000)          /*!< 0 wait states */
N#define FLCTL_BANK1_RDCTL_WAIT_1                 ((uint32_t)0x00001000)          /*!< 1 wait states */
N#define FLCTL_BANK1_RDCTL_WAIT_2                 ((uint32_t)0x00002000)          /*!< 2 wait states */
N#define FLCTL_BANK1_RDCTL_WAIT_3                 ((uint32_t)0x00003000)          /*!< 3 wait states */
N#define FLCTL_BANK1_RDCTL_WAIT_4                 ((uint32_t)0x00004000)          /*!< 4 wait states */
N#define FLCTL_BANK1_RDCTL_WAIT_5                 ((uint32_t)0x00005000)          /*!< 5 wait states */
N#define FLCTL_BANK1_RDCTL_WAIT_6                 ((uint32_t)0x00006000)          /*!< 6 wait states */
N#define FLCTL_BANK1_RDCTL_WAIT_7                 ((uint32_t)0x00007000)          /*!< 7 wait states */
N#define FLCTL_BANK1_RDCTL_WAIT_8                 ((uint32_t)0x00008000)          /*!< 8 wait states */
N#define FLCTL_BANK1_RDCTL_WAIT_9                 ((uint32_t)0x00009000)          /*!< 9 wait states */
N#define FLCTL_BANK1_RDCTL_WAIT_10                ((uint32_t)0x0000A000)          /*!< 10 wait states */
N#define FLCTL_BANK1_RDCTL_WAIT_11                ((uint32_t)0x0000B000)          /*!< 11 wait states */
N#define FLCTL_BANK1_RDCTL_WAIT_12                ((uint32_t)0x0000C000)          /*!< 12 wait states */
N#define FLCTL_BANK1_RDCTL_WAIT_13                ((uint32_t)0x0000D000)          /*!< 13 wait states */
N#define FLCTL_BANK1_RDCTL_WAIT_14                ((uint32_t)0x0000E000)          /*!< 14 wait states */
N#define FLCTL_BANK1_RDCTL_WAIT_15                ((uint32_t)0x0000F000)          /*!< 15 wait states */
N/* FLCTL_RDBRST_CTLSTAT[START] Bits */
N#define FLCTL_RDBRST_CTLSTAT_START_OFS           ( 0)                            /*!< START Bit Offset */
N#define FLCTL_RDBRST_CTLSTAT_START               ((uint32_t)0x00000001)          /*!< Start of burst/compare operation */
N/* FLCTL_RDBRST_CTLSTAT[MEM_TYPE] Bits */
N#define FLCTL_RDBRST_CTLSTAT_MEM_TYPE_OFS        ( 1)                            /*!< MEM_TYPE Bit Offset */
N#define FLCTL_RDBRST_CTLSTAT_MEM_TYPE_MASK       ((uint32_t)0x00000006)          /*!< MEM_TYPE Bit Mask */
N#define FLCTL_RDBRST_CTLSTAT_MEM_TYPE0           ((uint32_t)0x00000002)          /*!< MEM_TYPE Bit 0 */
N#define FLCTL_RDBRST_CTLSTAT_MEM_TYPE1           ((uint32_t)0x00000004)          /*!< MEM_TYPE Bit 1 */
N#define FLCTL_RDBRST_CTLSTAT_MEM_TYPE_0          ((uint32_t)0x00000000)          /*!< Main Memory */
N#define FLCTL_RDBRST_CTLSTAT_MEM_TYPE_1          ((uint32_t)0x00000002)          /*!< Information Memory */
N#define FLCTL_RDBRST_CTLSTAT_MEM_TYPE_2          ((uint32_t)0x00000004)          /*!< Reserved */
N#define FLCTL_RDBRST_CTLSTAT_MEM_TYPE_3          ((uint32_t)0x00000006)          /*!< Engineering Memory */
N/* FLCTL_RDBRST_CTLSTAT[STOP_FAIL] Bits */
N#define FLCTL_RDBRST_CTLSTAT_STOP_FAIL_OFS       ( 3)                            /*!< STOP_FAIL Bit Offset */
N#define FLCTL_RDBRST_CTLSTAT_STOP_FAIL           ((uint32_t)0x00000008)          /*!< Terminate burst/compare operation */
N/* FLCTL_RDBRST_CTLSTAT[DATA_CMP] Bits */
N#define FLCTL_RDBRST_CTLSTAT_DATA_CMP_OFS        ( 4)                            /*!< DATA_CMP Bit Offset */
N#define FLCTL_RDBRST_CTLSTAT_DATA_CMP            ((uint32_t)0x00000010)          /*!< Data pattern used for comparison against memory read data */
N/* FLCTL_RDBRST_CTLSTAT[TEST_EN] Bits */
N#define FLCTL_RDBRST_CTLSTAT_TEST_EN_OFS         ( 6)                            /*!< TEST_EN Bit Offset */
N#define FLCTL_RDBRST_CTLSTAT_TEST_EN             ((uint32_t)0x00000040)          /*!< Enable comparison against test data compare registers */
N/* FLCTL_RDBRST_CTLSTAT[BRST_STAT] Bits */
N#define FLCTL_RDBRST_CTLSTAT_BRST_STAT_OFS       (16)                            /*!< BRST_STAT Bit Offset */
N#define FLCTL_RDBRST_CTLSTAT_BRST_STAT_MASK      ((uint32_t)0x00030000)          /*!< BRST_STAT Bit Mask */
N#define FLCTL_RDBRST_CTLSTAT_BRST_STAT0          ((uint32_t)0x00010000)          /*!< BRST_STAT Bit 0 */
N#define FLCTL_RDBRST_CTLSTAT_BRST_STAT1          ((uint32_t)0x00020000)          /*!< BRST_STAT Bit 1 */
N#define FLCTL_RDBRST_CTLSTAT_BRST_STAT_0         ((uint32_t)0x00000000)          /*!< Idle */
N#define FLCTL_RDBRST_CTLSTAT_BRST_STAT_1         ((uint32_t)0x00010000)          /*!< Burst/Compare START bit written, but operation pending */
N#define FLCTL_RDBRST_CTLSTAT_BRST_STAT_2         ((uint32_t)0x00020000)          /*!< Burst/Compare in progress */
N#define FLCTL_RDBRST_CTLSTAT_BRST_STAT_3         ((uint32_t)0x00030000)          /*!< Burst complete (status of completed burst remains in this state unless  */
N                                                                                 /* explicitly cleared by SW) */
N/* FLCTL_RDBRST_CTLSTAT[CMP_ERR] Bits */
N#define FLCTL_RDBRST_CTLSTAT_CMP_ERR_OFS         (18)                            /*!< CMP_ERR Bit Offset */
N#define FLCTL_RDBRST_CTLSTAT_CMP_ERR             ((uint32_t)0x00040000)          /*!< Burst/Compare Operation encountered atleast one data */
N/* FLCTL_RDBRST_CTLSTAT[ADDR_ERR] Bits */
N#define FLCTL_RDBRST_CTLSTAT_ADDR_ERR_OFS        (19)                            /*!< ADDR_ERR Bit Offset */
N#define FLCTL_RDBRST_CTLSTAT_ADDR_ERR            ((uint32_t)0x00080000)          /*!< Burst/Compare Operation was terminated due to access to */
N/* FLCTL_RDBRST_CTLSTAT[CLR_STAT] Bits */
N#define FLCTL_RDBRST_CTLSTAT_CLR_STAT_OFS        (23)                            /*!< CLR_STAT Bit Offset */
N#define FLCTL_RDBRST_CTLSTAT_CLR_STAT            ((uint32_t)0x00800000)          /*!< Clear status bits 19-16 of this register */
N/* FLCTL_RDBRST_STARTADDR[START_ADDRESS] Bits */
N#define FLCTL_RDBRST_STARTADDR_START_ADDRESS_OFS ( 0)                            /*!< START_ADDRESS Bit Offset */
N#define FLCTL_RDBRST_STARTADDR_START_ADDRESS_MASK ((uint32_t)0x001FFFFF)          /*!< START_ADDRESS Bit Mask */
N/* FLCTL_RDBRST_LEN[BURST_LENGTH] Bits */
N#define FLCTL_RDBRST_LEN_BURST_LENGTH_OFS        ( 0)                            /*!< BURST_LENGTH Bit Offset */
N#define FLCTL_RDBRST_LEN_BURST_LENGTH_MASK       ((uint32_t)0x001FFFFF)          /*!< BURST_LENGTH Bit Mask */
N/* FLCTL_RDBRST_FAILADDR[FAIL_ADDRESS] Bits */
N#define FLCTL_RDBRST_FAILADDR_FAIL_ADDRESS_OFS   ( 0)                            /*!< FAIL_ADDRESS Bit Offset */
N#define FLCTL_RDBRST_FAILADDR_FAIL_ADDRESS_MASK  ((uint32_t)0x001FFFFF)          /*!< FAIL_ADDRESS Bit Mask */
N/* FLCTL_RDBRST_FAILCNT[FAIL_COUNT] Bits */
N#define FLCTL_RDBRST_FAILCNT_FAIL_COUNT_OFS      ( 0)                            /*!< FAIL_COUNT Bit Offset */
N#define FLCTL_RDBRST_FAILCNT_FAIL_COUNT_MASK     ((uint32_t)0x0001FFFF)          /*!< FAIL_COUNT Bit Mask */
N/* FLCTL_PRG_CTLSTAT[ENABLE] Bits */
N#define FLCTL_PRG_CTLSTAT_ENABLE_OFS             ( 0)                            /*!< ENABLE Bit Offset */
N#define FLCTL_PRG_CTLSTAT_ENABLE                 ((uint32_t)0x00000001)          /*!< Master control for all word program operations */
N/* FLCTL_PRG_CTLSTAT[MODE] Bits */
N#define FLCTL_PRG_CTLSTAT_MODE_OFS               ( 1)                            /*!< MODE Bit Offset */
N#define FLCTL_PRG_CTLSTAT_MODE                   ((uint32_t)0x00000002)          /*!< Write mode */
N/* FLCTL_PRG_CTLSTAT[VER_PRE] Bits */
N#define FLCTL_PRG_CTLSTAT_VER_PRE_OFS            ( 2)                            /*!< VER_PRE Bit Offset */
N#define FLCTL_PRG_CTLSTAT_VER_PRE                ((uint32_t)0x00000004)          /*!< Controls automatic pre program verify operations */
N/* FLCTL_PRG_CTLSTAT[VER_PST] Bits */
N#define FLCTL_PRG_CTLSTAT_VER_PST_OFS            ( 3)                            /*!< VER_PST Bit Offset */
N#define FLCTL_PRG_CTLSTAT_VER_PST                ((uint32_t)0x00000008)          /*!< Controls automatic post program verify operations */
N/* FLCTL_PRG_CTLSTAT[STATUS] Bits */
N#define FLCTL_PRG_CTLSTAT_STATUS_OFS             (16)                            /*!< STATUS Bit Offset */
N#define FLCTL_PRG_CTLSTAT_STATUS_MASK            ((uint32_t)0x00030000)          /*!< STATUS Bit Mask */
N#define FLCTL_PRG_CTLSTAT_STATUS0                ((uint32_t)0x00010000)          /*!< STATUS Bit 0 */
N#define FLCTL_PRG_CTLSTAT_STATUS1                ((uint32_t)0x00020000)          /*!< STATUS Bit 1 */
N#define FLCTL_PRG_CTLSTAT_STATUS_0               ((uint32_t)0x00000000)          /*!< Idle (no program operation currently active) */
N#define FLCTL_PRG_CTLSTAT_STATUS_1               ((uint32_t)0x00010000)          /*!< Single word program operation triggered, but pending */
N#define FLCTL_PRG_CTLSTAT_STATUS_2               ((uint32_t)0x00020000)          /*!< Single word program in progress */
N#define FLCTL_PRG_CTLSTAT_STATUS_3               ((uint32_t)0x00030000)          /*!< Reserved (Idle) */
N/* FLCTL_PRG_CTLSTAT[BNK_ACT] Bits */
N#define FLCTL_PRG_CTLSTAT_BNK_ACT_OFS            (18)                            /*!< BNK_ACT Bit Offset */
N#define FLCTL_PRG_CTLSTAT_BNK_ACT                ((uint32_t)0x00040000)          /*!< Bank active */
N/* FLCTL_PRGBRST_CTLSTAT[START] Bits */
N#define FLCTL_PRGBRST_CTLSTAT_START_OFS          ( 0)                            /*!< START Bit Offset */
N#define FLCTL_PRGBRST_CTLSTAT_START              ((uint32_t)0x00000001)          /*!< Trigger start of burst program operation */
N/* FLCTL_PRGBRST_CTLSTAT[TYPE] Bits */
N#define FLCTL_PRGBRST_CTLSTAT_TYPE_OFS           ( 1)                            /*!< TYPE Bit Offset */
N#define FLCTL_PRGBRST_CTLSTAT_TYPE_MASK          ((uint32_t)0x00000006)          /*!< TYPE Bit Mask */
N#define FLCTL_PRGBRST_CTLSTAT_TYPE0              ((uint32_t)0x00000002)          /*!< TYPE Bit 0 */
N#define FLCTL_PRGBRST_CTLSTAT_TYPE1              ((uint32_t)0x00000004)          /*!< TYPE Bit 1 */
N#define FLCTL_PRGBRST_CTLSTAT_TYPE_0             ((uint32_t)0x00000000)          /*!< Main Memory */
N#define FLCTL_PRGBRST_CTLSTAT_TYPE_1             ((uint32_t)0x00000002)          /*!< Information Memory */
N#define FLCTL_PRGBRST_CTLSTAT_TYPE_2             ((uint32_t)0x00000004)          /*!< Reserved */
N#define FLCTL_PRGBRST_CTLSTAT_TYPE_3             ((uint32_t)0x00000006)          /*!< Engineering Memory */
N/* FLCTL_PRGBRST_CTLSTAT[LEN] Bits */
N#define FLCTL_PRGBRST_CTLSTAT_LEN_OFS            ( 3)                            /*!< LEN Bit Offset */
N#define FLCTL_PRGBRST_CTLSTAT_LEN_MASK           ((uint32_t)0x00000038)          /*!< LEN Bit Mask */
N#define FLCTL_PRGBRST_CTLSTAT_LEN0               ((uint32_t)0x00000008)          /*!< LEN Bit 0 */
N#define FLCTL_PRGBRST_CTLSTAT_LEN1               ((uint32_t)0x00000010)          /*!< LEN Bit 1 */
N#define FLCTL_PRGBRST_CTLSTAT_LEN2               ((uint32_t)0x00000020)          /*!< LEN Bit 2 */
N#define FLCTL_PRGBRST_CTLSTAT_LEN_0              ((uint32_t)0x00000000)          /*!< No burst operation */
N#define FLCTL_PRGBRST_CTLSTAT_LEN_1              ((uint32_t)0x00000008)          /*!< 1 word burst of 128 bits, starting with address in the  */
N                                                                                 /* FLCTL_PRGBRST_STARTADDR Register */
N#define FLCTL_PRGBRST_CTLSTAT_LEN_2              ((uint32_t)0x00000010)          /*!< 2*128 bits burst write, starting with address in the FLCTL_PRGBRST_STARTADDR  */
N                                                                                 /* Register */
N#define FLCTL_PRGBRST_CTLSTAT_LEN_3              ((uint32_t)0x00000018)          /*!< 3*128 bits burst write, starting with address in the FLCTL_PRGBRST_STARTADDR  */
N                                                                                 /* Register */
N#define FLCTL_PRGBRST_CTLSTAT_LEN_4              ((uint32_t)0x00000020)          /*!< 4*128 bits burst write, starting with address in the FLCTL_PRGBRST_STARTADDR  */
N                                                                                 /* Register */
N/* FLCTL_PRGBRST_CTLSTAT[AUTO_PRE] Bits */
N#define FLCTL_PRGBRST_CTLSTAT_AUTO_PRE_OFS       ( 6)                            /*!< AUTO_PRE Bit Offset */
N#define FLCTL_PRGBRST_CTLSTAT_AUTO_PRE           ((uint32_t)0x00000040)          /*!< Auto-Verify operation before the Burst Program */
N/* FLCTL_PRGBRST_CTLSTAT[AUTO_PST] Bits */
N#define FLCTL_PRGBRST_CTLSTAT_AUTO_PST_OFS       ( 7)                            /*!< AUTO_PST Bit Offset */
N#define FLCTL_PRGBRST_CTLSTAT_AUTO_PST           ((uint32_t)0x00000080)          /*!< Auto-Verify operation after the Burst Program */
N/* FLCTL_PRGBRST_CTLSTAT[BURST_STATUS] Bits */
N#define FLCTL_PRGBRST_CTLSTAT_BURST_STATUS_OFS   (16)                            /*!< BURST_STATUS Bit Offset */
N#define FLCTL_PRGBRST_CTLSTAT_BURST_STATUS_MASK  ((uint32_t)0x00070000)          /*!< BURST_STATUS Bit Mask */
N#define FLCTL_PRGBRST_CTLSTAT_BURST_STATUS0      ((uint32_t)0x00010000)          /*!< BURST_STATUS Bit 0 */
N#define FLCTL_PRGBRST_CTLSTAT_BURST_STATUS1      ((uint32_t)0x00020000)          /*!< BURST_STATUS Bit 1 */
N#define FLCTL_PRGBRST_CTLSTAT_BURST_STATUS2      ((uint32_t)0x00040000)          /*!< BURST_STATUS Bit 2 */
N#define FLCTL_PRGBRST_CTLSTAT_BURST_STATUS_0     ((uint32_t)0x00000000)          /*!< Idle (Burst not active) */
N#define FLCTL_PRGBRST_CTLSTAT_BURST_STATUS_1     ((uint32_t)0x00010000)          /*!< Burst program started but pending */
N#define FLCTL_PRGBRST_CTLSTAT_BURST_STATUS_2     ((uint32_t)0x00020000)          /*!< Burst active, with 1st 128 bit word being written into Flash */
N#define FLCTL_PRGBRST_CTLSTAT_BURST_STATUS_3     ((uint32_t)0x00030000)          /*!< Burst active, with 2nd 128 bit word being written into Flash */
N#define FLCTL_PRGBRST_CTLSTAT_BURST_STATUS_4     ((uint32_t)0x00040000)          /*!< Burst active, with 3rd 128 bit word being written into Flash */
N#define FLCTL_PRGBRST_CTLSTAT_BURST_STATUS_5     ((uint32_t)0x00050000)          /*!< Burst active, with 4th 128 bit word being written into Flash */
N#define FLCTL_PRGBRST_CTLSTAT_BURST_STATUS_6     ((uint32_t)0x00060000)          /*!< Reserved (Idle) */
N#define FLCTL_PRGBRST_CTLSTAT_BURST_STATUS_7     ((uint32_t)0x00070000)          /*!< Burst Complete (status of completed burst remains in this state unless  */
N                                                                                 /* explicitly cleared by SW) */
N/* FLCTL_PRGBRST_CTLSTAT[PRE_ERR] Bits */
N#define FLCTL_PRGBRST_CTLSTAT_PRE_ERR_OFS        (19)                            /*!< PRE_ERR Bit Offset */
N#define FLCTL_PRGBRST_CTLSTAT_PRE_ERR            ((uint32_t)0x00080000)          /*!< Burst Operation encountered preprogram auto-verify errors */
N/* FLCTL_PRGBRST_CTLSTAT[PST_ERR] Bits */
N#define FLCTL_PRGBRST_CTLSTAT_PST_ERR_OFS        (20)                            /*!< PST_ERR Bit Offset */
N#define FLCTL_PRGBRST_CTLSTAT_PST_ERR            ((uint32_t)0x00100000)          /*!< Burst Operation encountered postprogram auto-verify errors */
N/* FLCTL_PRGBRST_CTLSTAT[ADDR_ERR] Bits */
N#define FLCTL_PRGBRST_CTLSTAT_ADDR_ERR_OFS       (21)                            /*!< ADDR_ERR Bit Offset */
N#define FLCTL_PRGBRST_CTLSTAT_ADDR_ERR           ((uint32_t)0x00200000)          /*!< Burst Operation was terminated due to attempted program of reserved memory */
N/* FLCTL_PRGBRST_CTLSTAT[CLR_STAT] Bits */
N#define FLCTL_PRGBRST_CTLSTAT_CLR_STAT_OFS       (23)                            /*!< CLR_STAT Bit Offset */
N#define FLCTL_PRGBRST_CTLSTAT_CLR_STAT           ((uint32_t)0x00800000)          /*!< Clear status bits 21-16 of this register */
N/* FLCTL_PRGBRST_STARTADDR[START_ADDRESS] Bits */
N#define FLCTL_PRGBRST_STARTADDR_START_ADDRESS_OFS ( 0)                            /*!< START_ADDRESS Bit Offset */
N#define FLCTL_PRGBRST_STARTADDR_START_ADDRESS_MASK ((uint32_t)0x003FFFFF)          /*!< START_ADDRESS Bit Mask */
N/* FLCTL_ERASE_CTLSTAT[START] Bits */
N#define FLCTL_ERASE_CTLSTAT_START_OFS            ( 0)                            /*!< START Bit Offset */
N#define FLCTL_ERASE_CTLSTAT_START                ((uint32_t)0x00000001)          /*!< Start of Erase operation */
N/* FLCTL_ERASE_CTLSTAT[MODE] Bits */
N#define FLCTL_ERASE_CTLSTAT_MODE_OFS             ( 1)                            /*!< MODE Bit Offset */
N#define FLCTL_ERASE_CTLSTAT_MODE                 ((uint32_t)0x00000002)          /*!< Erase mode selected by application */
N/* FLCTL_ERASE_CTLSTAT[TYPE] Bits */
N#define FLCTL_ERASE_CTLSTAT_TYPE_OFS             ( 2)                            /*!< TYPE Bit Offset */
N#define FLCTL_ERASE_CTLSTAT_TYPE_MASK            ((uint32_t)0x0000000C)          /*!< TYPE Bit Mask */
N#define FLCTL_ERASE_CTLSTAT_TYPE0                ((uint32_t)0x00000004)          /*!< TYPE Bit 0 */
N#define FLCTL_ERASE_CTLSTAT_TYPE1                ((uint32_t)0x00000008)          /*!< TYPE Bit 1 */
N#define FLCTL_ERASE_CTLSTAT_TYPE_0               ((uint32_t)0x00000000)          /*!< Main Memory */
N#define FLCTL_ERASE_CTLSTAT_TYPE_1               ((uint32_t)0x00000004)          /*!< Information Memory */
N#define FLCTL_ERASE_CTLSTAT_TYPE_2               ((uint32_t)0x00000008)          /*!< Reserved */
N#define FLCTL_ERASE_CTLSTAT_TYPE_3               ((uint32_t)0x0000000C)          /*!< Engineering Memory */
N/* FLCTL_ERASE_CTLSTAT[STATUS] Bits */
N#define FLCTL_ERASE_CTLSTAT_STATUS_OFS           (16)                            /*!< STATUS Bit Offset */
N#define FLCTL_ERASE_CTLSTAT_STATUS_MASK          ((uint32_t)0x00030000)          /*!< STATUS Bit Mask */
N#define FLCTL_ERASE_CTLSTAT_STATUS0              ((uint32_t)0x00010000)          /*!< STATUS Bit 0 */
N#define FLCTL_ERASE_CTLSTAT_STATUS1              ((uint32_t)0x00020000)          /*!< STATUS Bit 1 */
N#define FLCTL_ERASE_CTLSTAT_STATUS_0             ((uint32_t)0x00000000)          /*!< Idle (no program operation currently active) */
N#define FLCTL_ERASE_CTLSTAT_STATUS_1             ((uint32_t)0x00010000)          /*!< Erase operation triggered to START but pending */
N#define FLCTL_ERASE_CTLSTAT_STATUS_2             ((uint32_t)0x00020000)          /*!< Erase operation in progress */
N#define FLCTL_ERASE_CTLSTAT_STATUS_3             ((uint32_t)0x00030000)          /*!< Erase operation completed (status of completed erase remains in this state  */
N                                                                                 /* unless explicitly cleared by SW) */
N/* FLCTL_ERASE_CTLSTAT[ADDR_ERR] Bits */
N#define FLCTL_ERASE_CTLSTAT_ADDR_ERR_OFS         (18)                            /*!< ADDR_ERR Bit Offset */
N#define FLCTL_ERASE_CTLSTAT_ADDR_ERR             ((uint32_t)0x00040000)          /*!< Erase Operation was terminated due to attempted erase of reserved memory  */
N                                                                                 /* address */
N/* FLCTL_ERASE_CTLSTAT[CLR_STAT] Bits */
N#define FLCTL_ERASE_CTLSTAT_CLR_STAT_OFS         (19)                            /*!< CLR_STAT Bit Offset */
N#define FLCTL_ERASE_CTLSTAT_CLR_STAT             ((uint32_t)0x00080000)          /*!< Clear status bits 18-16 of this register */
N/* FLCTL_ERASE_SECTADDR[SECT_ADDRESS] Bits */
N#define FLCTL_ERASE_SECTADDR_SECT_ADDRESS_OFS    ( 0)                            /*!< SECT_ADDRESS Bit Offset */
N#define FLCTL_ERASE_SECTADDR_SECT_ADDRESS_MASK   ((uint32_t)0x003FFFFF)          /*!< SECT_ADDRESS Bit Mask */
N/* FLCTL_BANK0_INFO_WEPROT[PROT0] Bits */
N#define FLCTL_BANK0_INFO_WEPROT_PROT0_OFS        ( 0)                            /*!< PROT0 Bit Offset */
N#define FLCTL_BANK0_INFO_WEPROT_PROT0            ((uint32_t)0x00000001)          /*!< Protects Sector 0 from program or erase */
N/* FLCTL_BANK0_INFO_WEPROT[PROT1] Bits */
N#define FLCTL_BANK0_INFO_WEPROT_PROT1_OFS        ( 1)                            /*!< PROT1 Bit Offset */
N#define FLCTL_BANK0_INFO_WEPROT_PROT1            ((uint32_t)0x00000002)          /*!< Protects Sector 1 from program or erase */
N/* FLCTL_BANK0_MAIN_WEPROT[PROT0] Bits */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT0_OFS        ( 0)                            /*!< PROT0 Bit Offset */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT0            ((uint32_t)0x00000001)          /*!< Protects Sector 0 from program or erase */
N/* FLCTL_BANK0_MAIN_WEPROT[PROT1] Bits */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT1_OFS        ( 1)                            /*!< PROT1 Bit Offset */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT1            ((uint32_t)0x00000002)          /*!< Protects Sector 1 from program or erase */
N/* FLCTL_BANK0_MAIN_WEPROT[PROT2] Bits */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT2_OFS        ( 2)                            /*!< PROT2 Bit Offset */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT2            ((uint32_t)0x00000004)          /*!< Protects Sector 2 from program or erase */
N/* FLCTL_BANK0_MAIN_WEPROT[PROT3] Bits */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT3_OFS        ( 3)                            /*!< PROT3 Bit Offset */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT3            ((uint32_t)0x00000008)          /*!< Protects Sector 3 from program or erase */
N/* FLCTL_BANK0_MAIN_WEPROT[PROT4] Bits */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT4_OFS        ( 4)                            /*!< PROT4 Bit Offset */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT4            ((uint32_t)0x00000010)          /*!< Protects Sector 4 from program or erase */
N/* FLCTL_BANK0_MAIN_WEPROT[PROT5] Bits */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT5_OFS        ( 5)                            /*!< PROT5 Bit Offset */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT5            ((uint32_t)0x00000020)          /*!< Protects Sector 5 from program or erase */
N/* FLCTL_BANK0_MAIN_WEPROT[PROT6] Bits */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT6_OFS        ( 6)                            /*!< PROT6 Bit Offset */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT6            ((uint32_t)0x00000040)          /*!< Protects Sector 6 from program or erase */
N/* FLCTL_BANK0_MAIN_WEPROT[PROT7] Bits */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT7_OFS        ( 7)                            /*!< PROT7 Bit Offset */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT7            ((uint32_t)0x00000080)          /*!< Protects Sector 7 from program or erase */
N/* FLCTL_BANK0_MAIN_WEPROT[PROT8] Bits */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT8_OFS        ( 8)                            /*!< PROT8 Bit Offset */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT8            ((uint32_t)0x00000100)          /*!< Protects Sector 8 from program or erase */
N/* FLCTL_BANK0_MAIN_WEPROT[PROT9] Bits */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT9_OFS        ( 9)                            /*!< PROT9 Bit Offset */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT9            ((uint32_t)0x00000200)          /*!< Protects Sector 9 from program or erase */
N/* FLCTL_BANK0_MAIN_WEPROT[PROT10] Bits */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT10_OFS       (10)                            /*!< PROT10 Bit Offset */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT10           ((uint32_t)0x00000400)          /*!< Protects Sector 10 from program or erase */
N/* FLCTL_BANK0_MAIN_WEPROT[PROT11] Bits */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT11_OFS       (11)                            /*!< PROT11 Bit Offset */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT11           ((uint32_t)0x00000800)          /*!< Protects Sector 11 from program or erase */
N/* FLCTL_BANK0_MAIN_WEPROT[PROT12] Bits */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT12_OFS       (12)                            /*!< PROT12 Bit Offset */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT12           ((uint32_t)0x00001000)          /*!< Protects Sector 12 from program or erase */
N/* FLCTL_BANK0_MAIN_WEPROT[PROT13] Bits */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT13_OFS       (13)                            /*!< PROT13 Bit Offset */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT13           ((uint32_t)0x00002000)          /*!< Protects Sector 13 from program or erase */
N/* FLCTL_BANK0_MAIN_WEPROT[PROT14] Bits */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT14_OFS       (14)                            /*!< PROT14 Bit Offset */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT14           ((uint32_t)0x00004000)          /*!< Protects Sector 14 from program or erase */
N/* FLCTL_BANK0_MAIN_WEPROT[PROT15] Bits */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT15_OFS       (15)                            /*!< PROT15 Bit Offset */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT15           ((uint32_t)0x00008000)          /*!< Protects Sector 15 from program or erase */
N/* FLCTL_BANK0_MAIN_WEPROT[PROT16] Bits */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT16_OFS       (16)                            /*!< PROT16 Bit Offset */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT16           ((uint32_t)0x00010000)          /*!< Protects Sector 16 from program or erase */
N/* FLCTL_BANK0_MAIN_WEPROT[PROT17] Bits */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT17_OFS       (17)                            /*!< PROT17 Bit Offset */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT17           ((uint32_t)0x00020000)          /*!< Protects Sector 17 from program or erase */
N/* FLCTL_BANK0_MAIN_WEPROT[PROT18] Bits */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT18_OFS       (18)                            /*!< PROT18 Bit Offset */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT18           ((uint32_t)0x00040000)          /*!< Protects Sector 18 from program or erase */
N/* FLCTL_BANK0_MAIN_WEPROT[PROT19] Bits */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT19_OFS       (19)                            /*!< PROT19 Bit Offset */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT19           ((uint32_t)0x00080000)          /*!< Protects Sector 19 from program or erase */
N/* FLCTL_BANK0_MAIN_WEPROT[PROT20] Bits */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT20_OFS       (20)                            /*!< PROT20 Bit Offset */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT20           ((uint32_t)0x00100000)          /*!< Protects Sector 20 from program or erase */
N/* FLCTL_BANK0_MAIN_WEPROT[PROT21] Bits */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT21_OFS       (21)                            /*!< PROT21 Bit Offset */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT21           ((uint32_t)0x00200000)          /*!< Protects Sector 21 from program or erase */
N/* FLCTL_BANK0_MAIN_WEPROT[PROT22] Bits */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT22_OFS       (22)                            /*!< PROT22 Bit Offset */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT22           ((uint32_t)0x00400000)          /*!< Protects Sector 22 from program or erase */
N/* FLCTL_BANK0_MAIN_WEPROT[PROT23] Bits */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT23_OFS       (23)                            /*!< PROT23 Bit Offset */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT23           ((uint32_t)0x00800000)          /*!< Protects Sector 23 from program or erase */
N/* FLCTL_BANK0_MAIN_WEPROT[PROT24] Bits */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT24_OFS       (24)                            /*!< PROT24 Bit Offset */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT24           ((uint32_t)0x01000000)          /*!< Protects Sector 24 from program or erase */
N/* FLCTL_BANK0_MAIN_WEPROT[PROT25] Bits */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT25_OFS       (25)                            /*!< PROT25 Bit Offset */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT25           ((uint32_t)0x02000000)          /*!< Protects Sector 25 from program or erase */
N/* FLCTL_BANK0_MAIN_WEPROT[PROT26] Bits */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT26_OFS       (26)                            /*!< PROT26 Bit Offset */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT26           ((uint32_t)0x04000000)          /*!< Protects Sector 26 from program or erase */
N/* FLCTL_BANK0_MAIN_WEPROT[PROT27] Bits */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT27_OFS       (27)                            /*!< PROT27 Bit Offset */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT27           ((uint32_t)0x08000000)          /*!< Protects Sector 27 from program or erase */
N/* FLCTL_BANK0_MAIN_WEPROT[PROT28] Bits */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT28_OFS       (28)                            /*!< PROT28 Bit Offset */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT28           ((uint32_t)0x10000000)          /*!< Protects Sector 28 from program or erase */
N/* FLCTL_BANK0_MAIN_WEPROT[PROT29] Bits */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT29_OFS       (29)                            /*!< PROT29 Bit Offset */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT29           ((uint32_t)0x20000000)          /*!< Protects Sector 29 from program or erase */
N/* FLCTL_BANK0_MAIN_WEPROT[PROT30] Bits */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT30_OFS       (30)                            /*!< PROT30 Bit Offset */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT30           ((uint32_t)0x40000000)          /*!< Protects Sector 30 from program or erase */
N/* FLCTL_BANK0_MAIN_WEPROT[PROT31] Bits */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT31_OFS       (31)                            /*!< PROT31 Bit Offset */
N#define FLCTL_BANK0_MAIN_WEPROT_PROT31           ((uint32_t)0x80000000)          /*!< Protects Sector 31 from program or erase */
N/* FLCTL_BANK1_INFO_WEPROT[PROT0] Bits */
N#define FLCTL_BANK1_INFO_WEPROT_PROT0_OFS        ( 0)                            /*!< PROT0 Bit Offset */
N#define FLCTL_BANK1_INFO_WEPROT_PROT0            ((uint32_t)0x00000001)          /*!< Protects Sector 0 from program or erase operations */
N/* FLCTL_BANK1_INFO_WEPROT[PROT1] Bits */
N#define FLCTL_BANK1_INFO_WEPROT_PROT1_OFS        ( 1)                            /*!< PROT1 Bit Offset */
N#define FLCTL_BANK1_INFO_WEPROT_PROT1            ((uint32_t)0x00000002)          /*!< Protects Sector 1 from program or erase operations */
N/* FLCTL_BANK1_MAIN_WEPROT[PROT0] Bits */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT0_OFS        ( 0)                            /*!< PROT0 Bit Offset */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT0            ((uint32_t)0x00000001)          /*!< Protects Sector 0 from program or erase operations */
N/* FLCTL_BANK1_MAIN_WEPROT[PROT1] Bits */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT1_OFS        ( 1)                            /*!< PROT1 Bit Offset */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT1            ((uint32_t)0x00000002)          /*!< Protects Sector 1 from program or erase operations */
N/* FLCTL_BANK1_MAIN_WEPROT[PROT2] Bits */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT2_OFS        ( 2)                            /*!< PROT2 Bit Offset */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT2            ((uint32_t)0x00000004)          /*!< Protects Sector 2 from program or erase operations */
N/* FLCTL_BANK1_MAIN_WEPROT[PROT3] Bits */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT3_OFS        ( 3)                            /*!< PROT3 Bit Offset */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT3            ((uint32_t)0x00000008)          /*!< Protects Sector 3 from program or erase operations */
N/* FLCTL_BANK1_MAIN_WEPROT[PROT4] Bits */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT4_OFS        ( 4)                            /*!< PROT4 Bit Offset */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT4            ((uint32_t)0x00000010)          /*!< Protects Sector 4 from program or erase operations */
N/* FLCTL_BANK1_MAIN_WEPROT[PROT5] Bits */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT5_OFS        ( 5)                            /*!< PROT5 Bit Offset */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT5            ((uint32_t)0x00000020)          /*!< Protects Sector 5 from program or erase operations */
N/* FLCTL_BANK1_MAIN_WEPROT[PROT6] Bits */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT6_OFS        ( 6)                            /*!< PROT6 Bit Offset */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT6            ((uint32_t)0x00000040)          /*!< Protects Sector 6 from program or erase operations */
N/* FLCTL_BANK1_MAIN_WEPROT[PROT7] Bits */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT7_OFS        ( 7)                            /*!< PROT7 Bit Offset */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT7            ((uint32_t)0x00000080)          /*!< Protects Sector 7 from program or erase operations */
N/* FLCTL_BANK1_MAIN_WEPROT[PROT8] Bits */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT8_OFS        ( 8)                            /*!< PROT8 Bit Offset */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT8            ((uint32_t)0x00000100)          /*!< Protects Sector 8 from program or erase operations */
N/* FLCTL_BANK1_MAIN_WEPROT[PROT9] Bits */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT9_OFS        ( 9)                            /*!< PROT9 Bit Offset */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT9            ((uint32_t)0x00000200)          /*!< Protects Sector 9 from program or erase operations */
N/* FLCTL_BANK1_MAIN_WEPROT[PROT10] Bits */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT10_OFS       (10)                            /*!< PROT10 Bit Offset */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT10           ((uint32_t)0x00000400)          /*!< Protects Sector 10 from program or erase operations */
N/* FLCTL_BANK1_MAIN_WEPROT[PROT11] Bits */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT11_OFS       (11)                            /*!< PROT11 Bit Offset */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT11           ((uint32_t)0x00000800)          /*!< Protects Sector 11 from program or erase operations */
N/* FLCTL_BANK1_MAIN_WEPROT[PROT12] Bits */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT12_OFS       (12)                            /*!< PROT12 Bit Offset */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT12           ((uint32_t)0x00001000)          /*!< Protects Sector 12 from program or erase operations */
N/* FLCTL_BANK1_MAIN_WEPROT[PROT13] Bits */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT13_OFS       (13)                            /*!< PROT13 Bit Offset */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT13           ((uint32_t)0x00002000)          /*!< Protects Sector 13 from program or erase operations */
N/* FLCTL_BANK1_MAIN_WEPROT[PROT14] Bits */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT14_OFS       (14)                            /*!< PROT14 Bit Offset */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT14           ((uint32_t)0x00004000)          /*!< Protects Sector 14 from program or erase operations */
N/* FLCTL_BANK1_MAIN_WEPROT[PROT15] Bits */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT15_OFS       (15)                            /*!< PROT15 Bit Offset */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT15           ((uint32_t)0x00008000)          /*!< Protects Sector 15 from program or erase operations */
N/* FLCTL_BANK1_MAIN_WEPROT[PROT16] Bits */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT16_OFS       (16)                            /*!< PROT16 Bit Offset */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT16           ((uint32_t)0x00010000)          /*!< Protects Sector 16 from program or erase operations */
N/* FLCTL_BANK1_MAIN_WEPROT[PROT17] Bits */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT17_OFS       (17)                            /*!< PROT17 Bit Offset */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT17           ((uint32_t)0x00020000)          /*!< Protects Sector 17 from program or erase operations */
N/* FLCTL_BANK1_MAIN_WEPROT[PROT18] Bits */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT18_OFS       (18)                            /*!< PROT18 Bit Offset */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT18           ((uint32_t)0x00040000)          /*!< Protects Sector 18 from program or erase operations */
N/* FLCTL_BANK1_MAIN_WEPROT[PROT19] Bits */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT19_OFS       (19)                            /*!< PROT19 Bit Offset */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT19           ((uint32_t)0x00080000)          /*!< Protects Sector 19 from program or erase operations */
N/* FLCTL_BANK1_MAIN_WEPROT[PROT20] Bits */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT20_OFS       (20)                            /*!< PROT20 Bit Offset */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT20           ((uint32_t)0x00100000)          /*!< Protects Sector 20 from program or erase operations */
N/* FLCTL_BANK1_MAIN_WEPROT[PROT21] Bits */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT21_OFS       (21)                            /*!< PROT21 Bit Offset */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT21           ((uint32_t)0x00200000)          /*!< Protects Sector 21 from program or erase operations */
N/* FLCTL_BANK1_MAIN_WEPROT[PROT22] Bits */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT22_OFS       (22)                            /*!< PROT22 Bit Offset */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT22           ((uint32_t)0x00400000)          /*!< Protects Sector 22 from program or erase operations */
N/* FLCTL_BANK1_MAIN_WEPROT[PROT23] Bits */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT23_OFS       (23)                            /*!< PROT23 Bit Offset */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT23           ((uint32_t)0x00800000)          /*!< Protects Sector 23 from program or erase operations */
N/* FLCTL_BANK1_MAIN_WEPROT[PROT24] Bits */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT24_OFS       (24)                            /*!< PROT24 Bit Offset */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT24           ((uint32_t)0x01000000)          /*!< Protects Sector 24 from program or erase operations */
N/* FLCTL_BANK1_MAIN_WEPROT[PROT25] Bits */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT25_OFS       (25)                            /*!< PROT25 Bit Offset */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT25           ((uint32_t)0x02000000)          /*!< Protects Sector 25 from program or erase operations */
N/* FLCTL_BANK1_MAIN_WEPROT[PROT26] Bits */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT26_OFS       (26)                            /*!< PROT26 Bit Offset */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT26           ((uint32_t)0x04000000)          /*!< Protects Sector 26 from program or erase operations */
N/* FLCTL_BANK1_MAIN_WEPROT[PROT27] Bits */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT27_OFS       (27)                            /*!< PROT27 Bit Offset */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT27           ((uint32_t)0x08000000)          /*!< Protects Sector 27 from program or erase operations */
N/* FLCTL_BANK1_MAIN_WEPROT[PROT28] Bits */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT28_OFS       (28)                            /*!< PROT28 Bit Offset */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT28           ((uint32_t)0x10000000)          /*!< Protects Sector 28 from program or erase operations */
N/* FLCTL_BANK1_MAIN_WEPROT[PROT29] Bits */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT29_OFS       (29)                            /*!< PROT29 Bit Offset */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT29           ((uint32_t)0x20000000)          /*!< Protects Sector 29 from program or erase operations */
N/* FLCTL_BANK1_MAIN_WEPROT[PROT30] Bits */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT30_OFS       (30)                            /*!< PROT30 Bit Offset */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT30           ((uint32_t)0x40000000)          /*!< Protects Sector 30 from program or erase operations */
N/* FLCTL_BANK1_MAIN_WEPROT[PROT31] Bits */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT31_OFS       (31)                            /*!< PROT31 Bit Offset */
N#define FLCTL_BANK1_MAIN_WEPROT_PROT31           ((uint32_t)0x80000000)          /*!< Protects Sector 31 from program or erase operations */
N/* FLCTL_BMRK_CTLSTAT[I_BMRK] Bits */
N#define FLCTL_BMRK_CTLSTAT_I_BMRK_OFS            ( 0)                            /*!< I_BMRK Bit Offset */
N#define FLCTL_BMRK_CTLSTAT_I_BMRK                ((uint32_t)0x00000001)          
N/* FLCTL_BMRK_CTLSTAT[D_BMRK] Bits */
N#define FLCTL_BMRK_CTLSTAT_D_BMRK_OFS            ( 1)                            /*!< D_BMRK Bit Offset */
N#define FLCTL_BMRK_CTLSTAT_D_BMRK                ((uint32_t)0x00000002)          
N/* FLCTL_BMRK_CTLSTAT[CMP_EN] Bits */
N#define FLCTL_BMRK_CTLSTAT_CMP_EN_OFS            ( 2)                            /*!< CMP_EN Bit Offset */
N#define FLCTL_BMRK_CTLSTAT_CMP_EN                ((uint32_t)0x00000004)          
N/* FLCTL_BMRK_CTLSTAT[CMP_SEL] Bits */
N#define FLCTL_BMRK_CTLSTAT_CMP_SEL_OFS           ( 3)                            /*!< CMP_SEL Bit Offset */
N#define FLCTL_BMRK_CTLSTAT_CMP_SEL               ((uint32_t)0x00000008)          
N/* FLCTL_IFG[RDBRST] Bits */
N#define FLCTL_IFG_RDBRST_OFS                     ( 0)                            /*!< RDBRST Bit Offset */
N#define FLCTL_IFG_RDBRST                         ((uint32_t)0x00000001)          
N/* FLCTL_IFG[AVPRE] Bits */
N#define FLCTL_IFG_AVPRE_OFS                      ( 1)                            /*!< AVPRE Bit Offset */
N#define FLCTL_IFG_AVPRE                          ((uint32_t)0x00000002)          
N/* FLCTL_IFG[AVPST] Bits */
N#define FLCTL_IFG_AVPST_OFS                      ( 2)                            /*!< AVPST Bit Offset */
N#define FLCTL_IFG_AVPST                          ((uint32_t)0x00000004)          
N/* FLCTL_IFG[PRG] Bits */
N#define FLCTL_IFG_PRG_OFS                        ( 3)                            /*!< PRG Bit Offset */
N#define FLCTL_IFG_PRG                            ((uint32_t)0x00000008)          
N/* FLCTL_IFG[PRGB] Bits */
N#define FLCTL_IFG_PRGB_OFS                       ( 4)                            /*!< PRGB Bit Offset */
N#define FLCTL_IFG_PRGB                           ((uint32_t)0x00000010)          
N/* FLCTL_IFG[ERASE] Bits */
N#define FLCTL_IFG_ERASE_OFS                      ( 5)                            /*!< ERASE Bit Offset */
N#define FLCTL_IFG_ERASE                          ((uint32_t)0x00000020)          
N/* FLCTL_IFG[BMRK] Bits */
N#define FLCTL_IFG_BMRK_OFS                       ( 8)                            /*!< BMRK Bit Offset */
N#define FLCTL_IFG_BMRK                           ((uint32_t)0x00000100)          
N/* FLCTL_IFG[PRG_ERR] Bits */
N#define FLCTL_IFG_PRG_ERR_OFS                    ( 9)                            /*!< PRG_ERR Bit Offset */
N#define FLCTL_IFG_PRG_ERR                        ((uint32_t)0x00000200)          
N/* FLCTL_IE[RDBRST] Bits */
N#define FLCTL_IE_RDBRST_OFS                      ( 0)                            /*!< RDBRST Bit Offset */
N#define FLCTL_IE_RDBRST                          ((uint32_t)0x00000001)          
N/* FLCTL_IE[AVPRE] Bits */
N#define FLCTL_IE_AVPRE_OFS                       ( 1)                            /*!< AVPRE Bit Offset */
N#define FLCTL_IE_AVPRE                           ((uint32_t)0x00000002)          
N/* FLCTL_IE[AVPST] Bits */
N#define FLCTL_IE_AVPST_OFS                       ( 2)                            /*!< AVPST Bit Offset */
N#define FLCTL_IE_AVPST                           ((uint32_t)0x00000004)          
N/* FLCTL_IE[PRG] Bits */
N#define FLCTL_IE_PRG_OFS                         ( 3)                            /*!< PRG Bit Offset */
N#define FLCTL_IE_PRG                             ((uint32_t)0x00000008)          
N/* FLCTL_IE[PRGB] Bits */
N#define FLCTL_IE_PRGB_OFS                        ( 4)                            /*!< PRGB Bit Offset */
N#define FLCTL_IE_PRGB                            ((uint32_t)0x00000010)          
N/* FLCTL_IE[ERASE] Bits */
N#define FLCTL_IE_ERASE_OFS                       ( 5)                            /*!< ERASE Bit Offset */
N#define FLCTL_IE_ERASE                           ((uint32_t)0x00000020)          
N/* FLCTL_IE[BMRK] Bits */
N#define FLCTL_IE_BMRK_OFS                        ( 8)                            /*!< BMRK Bit Offset */
N#define FLCTL_IE_BMRK                            ((uint32_t)0x00000100)          
N/* FLCTL_IE[PRG_ERR] Bits */
N#define FLCTL_IE_PRG_ERR_OFS                     ( 9)                            /*!< PRG_ERR Bit Offset */
N#define FLCTL_IE_PRG_ERR                         ((uint32_t)0x00000200)          
N/* FLCTL_CLRIFG[RDBRST] Bits */
N#define FLCTL_CLRIFG_RDBRST_OFS                  ( 0)                            /*!< RDBRST Bit Offset */
N#define FLCTL_CLRIFG_RDBRST                      ((uint32_t)0x00000001)          
N/* FLCTL_CLRIFG[AVPRE] Bits */
N#define FLCTL_CLRIFG_AVPRE_OFS                   ( 1)                            /*!< AVPRE Bit Offset */
N#define FLCTL_CLRIFG_AVPRE                       ((uint32_t)0x00000002)          
N/* FLCTL_CLRIFG[AVPST] Bits */
N#define FLCTL_CLRIFG_AVPST_OFS                   ( 2)                            /*!< AVPST Bit Offset */
N#define FLCTL_CLRIFG_AVPST                       ((uint32_t)0x00000004)          
N/* FLCTL_CLRIFG[PRG] Bits */
N#define FLCTL_CLRIFG_PRG_OFS                     ( 3)                            /*!< PRG Bit Offset */
N#define FLCTL_CLRIFG_PRG                         ((uint32_t)0x00000008)          
N/* FLCTL_CLRIFG[PRGB] Bits */
N#define FLCTL_CLRIFG_PRGB_OFS                    ( 4)                            /*!< PRGB Bit Offset */
N#define FLCTL_CLRIFG_PRGB                        ((uint32_t)0x00000010)          
N/* FLCTL_CLRIFG[ERASE] Bits */
N#define FLCTL_CLRIFG_ERASE_OFS                   ( 5)                            /*!< ERASE Bit Offset */
N#define FLCTL_CLRIFG_ERASE                       ((uint32_t)0x00000020)          
N/* FLCTL_CLRIFG[BMRK] Bits */
N#define FLCTL_CLRIFG_BMRK_OFS                    ( 8)                            /*!< BMRK Bit Offset */
N#define FLCTL_CLRIFG_BMRK                        ((uint32_t)0x00000100)          
N/* FLCTL_CLRIFG[PRG_ERR] Bits */
N#define FLCTL_CLRIFG_PRG_ERR_OFS                 ( 9)                            /*!< PRG_ERR Bit Offset */
N#define FLCTL_CLRIFG_PRG_ERR                     ((uint32_t)0x00000200)          
N/* FLCTL_SETIFG[RDBRST] Bits */
N#define FLCTL_SETIFG_RDBRST_OFS                  ( 0)                            /*!< RDBRST Bit Offset */
N#define FLCTL_SETIFG_RDBRST                      ((uint32_t)0x00000001)          
N/* FLCTL_SETIFG[AVPRE] Bits */
N#define FLCTL_SETIFG_AVPRE_OFS                   ( 1)                            /*!< AVPRE Bit Offset */
N#define FLCTL_SETIFG_AVPRE                       ((uint32_t)0x00000002)          
N/* FLCTL_SETIFG[AVPST] Bits */
N#define FLCTL_SETIFG_AVPST_OFS                   ( 2)                            /*!< AVPST Bit Offset */
N#define FLCTL_SETIFG_AVPST                       ((uint32_t)0x00000004)          
N/* FLCTL_SETIFG[PRG] Bits */
N#define FLCTL_SETIFG_PRG_OFS                     ( 3)                            /*!< PRG Bit Offset */
N#define FLCTL_SETIFG_PRG                         ((uint32_t)0x00000008)          
N/* FLCTL_SETIFG[PRGB] Bits */
N#define FLCTL_SETIFG_PRGB_OFS                    ( 4)                            /*!< PRGB Bit Offset */
N#define FLCTL_SETIFG_PRGB                        ((uint32_t)0x00000010)          
N/* FLCTL_SETIFG[ERASE] Bits */
N#define FLCTL_SETIFG_ERASE_OFS                   ( 5)                            /*!< ERASE Bit Offset */
N#define FLCTL_SETIFG_ERASE                       ((uint32_t)0x00000020)          
N/* FLCTL_SETIFG[BMRK] Bits */
N#define FLCTL_SETIFG_BMRK_OFS                    ( 8)                            /*!< BMRK Bit Offset */
N#define FLCTL_SETIFG_BMRK                        ((uint32_t)0x00000100)          
N/* FLCTL_SETIFG[PRG_ERR] Bits */
N#define FLCTL_SETIFG_PRG_ERR_OFS                 ( 9)                            /*!< PRG_ERR Bit Offset */
N#define FLCTL_SETIFG_PRG_ERR                     ((uint32_t)0x00000200)          
N/* FLCTL_READ_TIMCTL[SETUP] Bits */
N#define FLCTL_READ_TIMCTL_SETUP_OFS              ( 0)                            /*!< SETUP Bit Offset */
N#define FLCTL_READ_TIMCTL_SETUP_MASK             ((uint32_t)0x000000FF)          /*!< SETUP Bit Mask */
N/* FLCTL_READ_TIMCTL[IREF_BOOST1] Bits */
N#define FLCTL_READ_TIMCTL_IREF_BOOST1_OFS        (12)                            /*!< IREF_BOOST1 Bit Offset */
N#define FLCTL_READ_TIMCTL_IREF_BOOST1_MASK       ((uint32_t)0x0000F000)          /*!< IREF_BOOST1 Bit Mask */
N/* FLCTL_READ_TIMCTL[SETUP_LONG] Bits */
N#define FLCTL_READ_TIMCTL_SETUP_LONG_OFS         (16)                            /*!< SETUP_LONG Bit Offset */
N#define FLCTL_READ_TIMCTL_SETUP_LONG_MASK        ((uint32_t)0x00FF0000)          /*!< SETUP_LONG Bit Mask */
N/* FLCTL_READMARGIN_TIMCTL[SETUP] Bits */
N#define FLCTL_READMARGIN_TIMCTL_SETUP_OFS        ( 0)                            /*!< SETUP Bit Offset */
N#define FLCTL_READMARGIN_TIMCTL_SETUP_MASK       ((uint32_t)0x000000FF)          /*!< SETUP Bit Mask */
N/* FLCTL_PRGVER_TIMCTL[SETUP] Bits */
N#define FLCTL_PRGVER_TIMCTL_SETUP_OFS            ( 0)                            /*!< SETUP Bit Offset */
N#define FLCTL_PRGVER_TIMCTL_SETUP_MASK           ((uint32_t)0x000000FF)          /*!< SETUP Bit Mask */
N/* FLCTL_PRGVER_TIMCTL[ACTIVE] Bits */
N#define FLCTL_PRGVER_TIMCTL_ACTIVE_OFS           ( 8)                            /*!< ACTIVE Bit Offset */
N#define FLCTL_PRGVER_TIMCTL_ACTIVE_MASK          ((uint32_t)0x00000F00)          /*!< ACTIVE Bit Mask */
N/* FLCTL_PRGVER_TIMCTL[HOLD] Bits */
N#define FLCTL_PRGVER_TIMCTL_HOLD_OFS             (12)                            /*!< HOLD Bit Offset */
N#define FLCTL_PRGVER_TIMCTL_HOLD_MASK            ((uint32_t)0x0000F000)          /*!< HOLD Bit Mask */
N/* FLCTL_ERSVER_TIMCTL[SETUP] Bits */
N#define FLCTL_ERSVER_TIMCTL_SETUP_OFS            ( 0)                            /*!< SETUP Bit Offset */
N#define FLCTL_ERSVER_TIMCTL_SETUP_MASK           ((uint32_t)0x000000FF)          /*!< SETUP Bit Mask */
N/* FLCTL_LKGVER_TIMCTL[SETUP] Bits */
N#define FLCTL_LKGVER_TIMCTL_SETUP_OFS            ( 0)                            /*!< SETUP Bit Offset */
N#define FLCTL_LKGVER_TIMCTL_SETUP_MASK           ((uint32_t)0x000000FF)          /*!< SETUP Bit Mask */
N/* FLCTL_PROGRAM_TIMCTL[SETUP] Bits */
N#define FLCTL_PROGRAM_TIMCTL_SETUP_OFS           ( 0)                            /*!< SETUP Bit Offset */
N#define FLCTL_PROGRAM_TIMCTL_SETUP_MASK          ((uint32_t)0x000000FF)          /*!< SETUP Bit Mask */
N/* FLCTL_PROGRAM_TIMCTL[ACTIVE] Bits */
N#define FLCTL_PROGRAM_TIMCTL_ACTIVE_OFS          ( 8)                            /*!< ACTIVE Bit Offset */
N#define FLCTL_PROGRAM_TIMCTL_ACTIVE_MASK         ((uint32_t)0x0FFFFF00)          /*!< ACTIVE Bit Mask */
N/* FLCTL_PROGRAM_TIMCTL[HOLD] Bits */
N#define FLCTL_PROGRAM_TIMCTL_HOLD_OFS            (28)                            /*!< HOLD Bit Offset */
N#define FLCTL_PROGRAM_TIMCTL_HOLD_MASK           ((uint32_t)0xF0000000)          /*!< HOLD Bit Mask */
N/* FLCTL_ERASE_TIMCTL[SETUP] Bits */
N#define FLCTL_ERASE_TIMCTL_SETUP_OFS             ( 0)                            /*!< SETUP Bit Offset */
N#define FLCTL_ERASE_TIMCTL_SETUP_MASK            ((uint32_t)0x000000FF)          /*!< SETUP Bit Mask */
N/* FLCTL_ERASE_TIMCTL[ACTIVE] Bits */
N#define FLCTL_ERASE_TIMCTL_ACTIVE_OFS            ( 8)                            /*!< ACTIVE Bit Offset */
N#define FLCTL_ERASE_TIMCTL_ACTIVE_MASK           ((uint32_t)0x0FFFFF00)          /*!< ACTIVE Bit Mask */
N/* FLCTL_ERASE_TIMCTL[HOLD] Bits */
N#define FLCTL_ERASE_TIMCTL_HOLD_OFS              (28)                            /*!< HOLD Bit Offset */
N#define FLCTL_ERASE_TIMCTL_HOLD_MASK             ((uint32_t)0xF0000000)          /*!< HOLD Bit Mask */
N/* FLCTL_MASSERASE_TIMCTL[BOOST_ACTIVE] Bits */
N#define FLCTL_MASSERASE_TIMCTL_BOOST_ACTIVE_OFS  ( 0)                            /*!< BOOST_ACTIVE Bit Offset */
N#define FLCTL_MASSERASE_TIMCTL_BOOST_ACTIVE_MASK ((uint32_t)0x000000FF)          /*!< BOOST_ACTIVE Bit Mask */
N/* FLCTL_MASSERASE_TIMCTL[BOOST_HOLD] Bits */
N#define FLCTL_MASSERASE_TIMCTL_BOOST_HOLD_OFS    ( 8)                            /*!< BOOST_HOLD Bit Offset */
N#define FLCTL_MASSERASE_TIMCTL_BOOST_HOLD_MASK   ((uint32_t)0x0000FF00)          /*!< BOOST_HOLD Bit Mask */
N/* FLCTL_BURSTPRG_TIMCTL[ACTIVE] Bits */
N#define FLCTL_BURSTPRG_TIMCTL_ACTIVE_OFS         ( 8)                            /*!< ACTIVE Bit Offset */
N#define FLCTL_BURSTPRG_TIMCTL_ACTIVE_MASK        ((uint32_t)0x0FFFFF00)          /*!< ACTIVE Bit Mask */
N
N/******************************************************************************
N* FL_BOOTOVER_MAILBOX Bits
N******************************************************************************/
N
N/******************************************************************************
N* FPB Bits
N******************************************************************************/
N
N
N/******************************************************************************
N* FPU Bits
N******************************************************************************/
N
N
N/******************************************************************************
N* ITM Bits
N******************************************************************************/
N
N
N/******************************************************************************
N* MPU Bits
N******************************************************************************/
N
N/* Pre-defined bitfield values */
N
N/*  MPU_RASR_SIZE Bitfield Bits */
N#define MPU_RASR_SIZE__32B                       ((uint32_t)0x00000008)          /*!< 32B */
N#define MPU_RASR_SIZE__64B                       ((uint32_t)0x0000000A)          /*!< 64B */
N#define MPU_RASR_SIZE__128B                      ((uint32_t)0x0000000C)          /*!< 128B */
N#define MPU_RASR_SIZE__256B                      ((uint32_t)0x0000000E)          /*!< 256B */
N#define MPU_RASR_SIZE__512B                      ((uint32_t)0x00000010)          /*!< 512B */
N#define MPU_RASR_SIZE__1K                        ((uint32_t)0x00000012)          /*!< 1KB */
N#define MPU_RASR_SIZE__2K                        ((uint32_t)0x00000014)          /*!< 2KB */
N#define MPU_RASR_SIZE__4K                        ((uint32_t)0x00000016)          /*!< 4KB */
N#define MPU_RASR_SIZE__8K                        ((uint32_t)0x00000018)          /*!< 8KB */
N#define MPU_RASR_SIZE__16K                       ((uint32_t)0x0000001A)          /*!< 16KB */
N#define MPU_RASR_SIZE__32K                       ((uint32_t)0x0000001C)          /*!< 32KB */
N#define MPU_RASR_SIZE__64K                       ((uint32_t)0x0000001E)          /*!< 64KB */
N#define MPU_RASR_SIZE__128K                      ((uint32_t)0x00000020)          /*!< 128KB */
N#define MPU_RASR_SIZE__256K                      ((uint32_t)0x00000022)          /*!< 256KB */
N#define MPU_RASR_SIZE__512K                      ((uint32_t)0x00000024)          /*!< 512KB */
N#define MPU_RASR_SIZE__1M                        ((uint32_t)0x00000026)          /*!< 1MB */
N#define MPU_RASR_SIZE__2M                        ((uint32_t)0x00000028)          /*!< 2MB */
N#define MPU_RASR_SIZE__4M                        ((uint32_t)0x0000002A)          /*!< 4MB */
N#define MPU_RASR_SIZE__8M                        ((uint32_t)0x0000002C)          /*!< 8MB */
N#define MPU_RASR_SIZE__16M                       ((uint32_t)0x0000002E)          /*!< 16MB */
N#define MPU_RASR_SIZE__32M                       ((uint32_t)0x00000030)          /*!< 32MB */
N#define MPU_RASR_SIZE__64M                       ((uint32_t)0x00000032)          /*!< 64MB */
N#define MPU_RASR_SIZE__128M                      ((uint32_t)0x00000034)          /*!< 128MB */
N#define MPU_RASR_SIZE__256M                      ((uint32_t)0x00000036)          /*!< 256MB */
N#define MPU_RASR_SIZE__512M                      ((uint32_t)0x00000038)          /*!< 512MB */
N#define MPU_RASR_SIZE__1G                        ((uint32_t)0x0000003A)          /*!< 1GB */
N#define MPU_RASR_SIZE__2G                        ((uint32_t)0x0000003C)          /*!< 2GB */
N#define MPU_RASR_SIZE__4G                        ((uint32_t)0x0000003E)          /*!< 4GB */
N
N/*  MPU_RASR_AP Bitfield Bits */
N#define MPU_RASR_AP_PRV_NO_USR_NO                ((uint32_t)0x00000000)          /*!< Privileged permissions: No access. User permissions: No access. */
N#define MPU_RASR_AP_PRV_RW_USR_NO                ((uint32_t)0x01000000)          /*!< Privileged permissions: Read-write. User permissions: No access. */
N#define MPU_RASR_AP_PRV_RW_USR_RO                ((uint32_t)0x02000000)          /*!< Privileged permissions: Read-write. User permissions: Read-only. */
N#define MPU_RASR_AP_PRV_RW_USR_RW                ((uint32_t)0x03000000)          /*!< Privileged permissions: Read-write. User permissions: Read-write. */
N#define MPU_RASR_AP_PRV_RO_USR_NO                ((uint32_t)0x05000000)          /*!< Privileged permissions: Read-only. User permissions: No access. */
N#define MPU_RASR_AP_PRV_RO_USR_RO                ((uint32_t)0x06000000)          /*!< Privileged permissions: Read-only. User permissions: Read-only. */
N
N/* MPU_RASR_XN Bitfield Bits */
N#define MPU_RASR_AP_EXEC                         ((uint32_t)0x00000000)          /*!< Instruction access enabled */
N#define MPU_RASR_AP_NOEXEC                       ((uint32_t)0x10000000)          /*!< Instruction access disabled */
N
N
N/******************************************************************************
N* NVIC Bits
N******************************************************************************/
N
N/* NVIC_IPR0[NVIC_IPR0_PRI_0] Bits */
N#define NVIC_IPR0_PRI_0_OFS                      ( 0)                            /*!< PRI_0 Offset */
N#define NVIC_IPR0_PRI_0_M                        ((uint32_t)0x000000ff)          /*  */
N/* NVIC_IPR0[NVIC_IPR0_PRI_1] Bits */
N#define NVIC_IPR0_PRI_1_OFS                      ( 8)                            /*!< PRI_1 Offset */
N#define NVIC_IPR0_PRI_1_M                        ((uint32_t)0x0000ff00)          /*  */
N/* NVIC_IPR0[NVIC_IPR0_PRI_2] Bits */
N#define NVIC_IPR0_PRI_2_OFS                      (16)                            /*!< PRI_2 Offset */
N#define NVIC_IPR0_PRI_2_M                        ((uint32_t)0x00ff0000)          /*  */
N/* NVIC_IPR0[NVIC_IPR0_PRI_3] Bits */
N#define NVIC_IPR0_PRI_3_OFS                      (24)                            /*!< PRI_3 Offset */
N#define NVIC_IPR0_PRI_3_M                        ((uint32_t)0xff000000)          /*  */
N/* NVIC_IPR1[NVIC_IPR1_PRI_4] Bits */
N#define NVIC_IPR1_PRI_4_OFS                      ( 0)                            /*!< PRI_4 Offset */
N#define NVIC_IPR1_PRI_4_M                        ((uint32_t)0x000000ff)          /*  */
N/* NVIC_IPR1[NVIC_IPR1_PRI_5] Bits */
N#define NVIC_IPR1_PRI_5_OFS                      ( 8)                            /*!< PRI_5 Offset */
N#define NVIC_IPR1_PRI_5_M                        ((uint32_t)0x0000ff00)          /*  */
N/* NVIC_IPR1[NVIC_IPR1_PRI_6] Bits */
N#define NVIC_IPR1_PRI_6_OFS                      (16)                            /*!< PRI_6 Offset */
N#define NVIC_IPR1_PRI_6_M                        ((uint32_t)0x00ff0000)          /*  */
N/* NVIC_IPR1[NVIC_IPR1_PRI_7] Bits */
N#define NVIC_IPR1_PRI_7_OFS                      (24)                            /*!< PRI_7 Offset */
N#define NVIC_IPR1_PRI_7_M                        ((uint32_t)0xff000000)          /*  */
N/* NVIC_IPR2[NVIC_IPR2_PRI_8] Bits */
N#define NVIC_IPR2_PRI_8_OFS                      ( 0)                            /*!< PRI_8 Offset */
N#define NVIC_IPR2_PRI_8_M                        ((uint32_t)0x000000ff)          /*  */
N/* NVIC_IPR2[NVIC_IPR2_PRI_9] Bits */
N#define NVIC_IPR2_PRI_9_OFS                      ( 8)                            /*!< PRI_9 Offset */
N#define NVIC_IPR2_PRI_9_M                        ((uint32_t)0x0000ff00)          /*  */
N/* NVIC_IPR2[NVIC_IPR2_PRI_10] Bits */
N#define NVIC_IPR2_PRI_10_OFS                     (16)                            /*!< PRI_10 Offset */
N#define NVIC_IPR2_PRI_10_M                       ((uint32_t)0x00ff0000)          /*  */
N/* NVIC_IPR2[NVIC_IPR2_PRI_11] Bits */
N#define NVIC_IPR2_PRI_11_OFS                     (24)                            /*!< PRI_11 Offset */
N#define NVIC_IPR2_PRI_11_M                       ((uint32_t)0xff000000)          /*  */
N/* NVIC_IPR3[NVIC_IPR3_PRI_12] Bits */
N#define NVIC_IPR3_PRI_12_OFS                     ( 0)                            /*!< PRI_12 Offset */
N#define NVIC_IPR3_PRI_12_M                       ((uint32_t)0x000000ff)          /*  */
N/* NVIC_IPR3[NVIC_IPR3_PRI_13] Bits */
N#define NVIC_IPR3_PRI_13_OFS                     ( 8)                            /*!< PRI_13 Offset */
N#define NVIC_IPR3_PRI_13_M                       ((uint32_t)0x0000ff00)          /*  */
N/* NVIC_IPR3[NVIC_IPR3_PRI_14] Bits */
N#define NVIC_IPR3_PRI_14_OFS                     (16)                            /*!< PRI_14 Offset */
N#define NVIC_IPR3_PRI_14_M                       ((uint32_t)0x00ff0000)          /*  */
N/* NVIC_IPR3[NVIC_IPR3_PRI_15] Bits */
N#define NVIC_IPR3_PRI_15_OFS                     (24)                            /*!< PRI_15 Offset */
N#define NVIC_IPR3_PRI_15_M                       ((uint32_t)0xff000000)          /*  */
N/* NVIC_IPR4[NVIC_IPR4_PRI_16] Bits */
N#define NVIC_IPR4_PRI_16_OFS                     ( 0)                            /*!< PRI_16 Offset */
N#define NVIC_IPR4_PRI_16_M                       ((uint32_t)0x000000ff)          /*  */
N/* NVIC_IPR4[NVIC_IPR4_PRI_17] Bits */
N#define NVIC_IPR4_PRI_17_OFS                     ( 8)                            /*!< PRI_17 Offset */
N#define NVIC_IPR4_PRI_17_M                       ((uint32_t)0x0000ff00)          /*  */
N/* NVIC_IPR4[NVIC_IPR4_PRI_18] Bits */
N#define NVIC_IPR4_PRI_18_OFS                     (16)                            /*!< PRI_18 Offset */
N#define NVIC_IPR4_PRI_18_M                       ((uint32_t)0x00ff0000)          /*  */
N/* NVIC_IPR4[NVIC_IPR4_PRI_19] Bits */
N#define NVIC_IPR4_PRI_19_OFS                     (24)                            /*!< PRI_19 Offset */
N#define NVIC_IPR4_PRI_19_M                       ((uint32_t)0xff000000)          /*  */
N/* NVIC_IPR5[NVIC_IPR5_PRI_20] Bits */
N#define NVIC_IPR5_PRI_20_OFS                     ( 0)                            /*!< PRI_20 Offset */
N#define NVIC_IPR5_PRI_20_M                       ((uint32_t)0x000000ff)          /*  */
N/* NVIC_IPR5[NVIC_IPR5_PRI_21] Bits */
N#define NVIC_IPR5_PRI_21_OFS                     ( 8)                            /*!< PRI_21 Offset */
N#define NVIC_IPR5_PRI_21_M                       ((uint32_t)0x0000ff00)          /*  */
N/* NVIC_IPR5[NVIC_IPR5_PRI_22] Bits */
N#define NVIC_IPR5_PRI_22_OFS                     (16)                            /*!< PRI_22 Offset */
N#define NVIC_IPR5_PRI_22_M                       ((uint32_t)0x00ff0000)          /*  */
N/* NVIC_IPR5[NVIC_IPR5_PRI_23] Bits */
N#define NVIC_IPR5_PRI_23_OFS                     (24)                            /*!< PRI_23 Offset */
N#define NVIC_IPR5_PRI_23_M                       ((uint32_t)0xff000000)          /*  */
N/* NVIC_IPR6[NVIC_IPR6_PRI_24] Bits */
N#define NVIC_IPR6_PRI_24_OFS                     ( 0)                            /*!< PRI_24 Offset */
N#define NVIC_IPR6_PRI_24_M                       ((uint32_t)0x000000ff)          /*  */
N/* NVIC_IPR6[NVIC_IPR6_PRI_25] Bits */
N#define NVIC_IPR6_PRI_25_OFS                     ( 8)                            /*!< PRI_25 Offset */
N#define NVIC_IPR6_PRI_25_M                       ((uint32_t)0x0000ff00)          /*  */
N/* NVIC_IPR6[NVIC_IPR6_PRI_26] Bits */
N#define NVIC_IPR6_PRI_26_OFS                     (16)                            /*!< PRI_26 Offset */
N#define NVIC_IPR6_PRI_26_M                       ((uint32_t)0x00ff0000)          /*  */
N/* NVIC_IPR6[NVIC_IPR6_PRI_27] Bits */
N#define NVIC_IPR6_PRI_27_OFS                     (24)                            /*!< PRI_27 Offset */
N#define NVIC_IPR6_PRI_27_M                       ((uint32_t)0xff000000)          /*  */
N/* NVIC_IPR7[NVIC_IPR7_PRI_28] Bits */
N#define NVIC_IPR7_PRI_28_OFS                     ( 0)                            /*!< PRI_28 Offset */
N#define NVIC_IPR7_PRI_28_M                       ((uint32_t)0x000000ff)          /*  */
N/* NVIC_IPR7[NVIC_IPR7_PRI_29] Bits */
N#define NVIC_IPR7_PRI_29_OFS                     ( 8)                            /*!< PRI_29 Offset */
N#define NVIC_IPR7_PRI_29_M                       ((uint32_t)0x0000ff00)          /*  */
N/* NVIC_IPR7[NVIC_IPR7_PRI_30] Bits */
N#define NVIC_IPR7_PRI_30_OFS                     (16)                            /*!< PRI_30 Offset */
N#define NVIC_IPR7_PRI_30_M                       ((uint32_t)0x00ff0000)          /*  */
N/* NVIC_IPR7[NVIC_IPR7_PRI_31] Bits */
N#define NVIC_IPR7_PRI_31_OFS                     (24)                            /*!< PRI_31 Offset */
N#define NVIC_IPR7_PRI_31_M                       ((uint32_t)0xff000000)          /*  */
N/* NVIC_IPR8[NVIC_IPR8_PRI_32] Bits */
N#define NVIC_IPR8_PRI_32_OFS                     ( 0)                            /*!< PRI_32 Offset */
N#define NVIC_IPR8_PRI_32_M                       ((uint32_t)0x000000ff)          /*  */
N/* NVIC_IPR8[NVIC_IPR8_PRI_33] Bits */
N#define NVIC_IPR8_PRI_33_OFS                     ( 8)                            /*!< PRI_33 Offset */
N#define NVIC_IPR8_PRI_33_M                       ((uint32_t)0x0000ff00)          /*  */
N/* NVIC_IPR8[NVIC_IPR8_PRI_34] Bits */
N#define NVIC_IPR8_PRI_34_OFS                     (16)                            /*!< PRI_34 Offset */
N#define NVIC_IPR8_PRI_34_M                       ((uint32_t)0x00ff0000)          /*  */
N/* NVIC_IPR8[NVIC_IPR8_PRI_35] Bits */
N#define NVIC_IPR8_PRI_35_OFS                     (24)                            /*!< PRI_35 Offset */
N#define NVIC_IPR8_PRI_35_M                       ((uint32_t)0xff000000)          /*  */
N/* NVIC_IPR9[NVIC_IPR9_PRI_36] Bits */
N#define NVIC_IPR9_PRI_36_OFS                     ( 0)                            /*!< PRI_36 Offset */
N#define NVIC_IPR9_PRI_36_M                       ((uint32_t)0x000000ff)          /*  */
N/* NVIC_IPR9[NVIC_IPR9_PRI_37] Bits */
N#define NVIC_IPR9_PRI_37_OFS                     ( 8)                            /*!< PRI_37 Offset */
N#define NVIC_IPR9_PRI_37_M                       ((uint32_t)0x0000ff00)          /*  */
N/* NVIC_IPR9[NVIC_IPR9_PRI_38] Bits */
N#define NVIC_IPR9_PRI_38_OFS                     (16)                            /*!< PRI_38 Offset */
N#define NVIC_IPR9_PRI_38_M                       ((uint32_t)0x00ff0000)          /*  */
N/* NVIC_IPR9[NVIC_IPR9_PRI_39] Bits */
N#define NVIC_IPR9_PRI_39_OFS                     (24)                            /*!< PRI_39 Offset */
N#define NVIC_IPR9_PRI_39_M                       ((uint32_t)0xff000000)          /*  */
N/* NVIC_IPR10[NVIC_IPR10_PRI_40] Bits */
N#define NVIC_IPR10_PRI_40_OFS                    ( 0)                            /*!< PRI_40 Offset */
N#define NVIC_IPR10_PRI_40_M                      ((uint32_t)0x000000ff)          /*  */
N/* NVIC_IPR10[NVIC_IPR10_PRI_41] Bits */
N#define NVIC_IPR10_PRI_41_OFS                    ( 8)                            /*!< PRI_41 Offset */
N#define NVIC_IPR10_PRI_41_M                      ((uint32_t)0x0000ff00)          /*  */
N/* NVIC_IPR10[NVIC_IPR10_PRI_42] Bits */
N#define NVIC_IPR10_PRI_42_OFS                    (16)                            /*!< PRI_42 Offset */
N#define NVIC_IPR10_PRI_42_M                      ((uint32_t)0x00ff0000)          /*  */
N/* NVIC_IPR10[NVIC_IPR10_PRI_43] Bits */
N#define NVIC_IPR10_PRI_43_OFS                    (24)                            /*!< PRI_43 Offset */
N#define NVIC_IPR10_PRI_43_M                      ((uint32_t)0xff000000)          /*  */
N/* NVIC_IPR11[NVIC_IPR11_PRI_44] Bits */
N#define NVIC_IPR11_PRI_44_OFS                    ( 0)                            /*!< PRI_44 Offset */
N#define NVIC_IPR11_PRI_44_M                      ((uint32_t)0x000000ff)          /*  */
N/* NVIC_IPR11[NVIC_IPR11_PRI_45] Bits */
N#define NVIC_IPR11_PRI_45_OFS                    ( 8)                            /*!< PRI_45 Offset */
N#define NVIC_IPR11_PRI_45_M                      ((uint32_t)0x0000ff00)          /*  */
N/* NVIC_IPR11[NVIC_IPR11_PRI_46] Bits */
N#define NVIC_IPR11_PRI_46_OFS                    (16)                            /*!< PRI_46 Offset */
N#define NVIC_IPR11_PRI_46_M                      ((uint32_t)0x00ff0000)          /*  */
N/* NVIC_IPR11[NVIC_IPR11_PRI_47] Bits */
N#define NVIC_IPR11_PRI_47_OFS                    (24)                            /*!< PRI_47 Offset */
N#define NVIC_IPR11_PRI_47_M                      ((uint32_t)0xff000000)          /*  */
N/* NVIC_IPR12[NVIC_IPR12_PRI_48] Bits */
N#define NVIC_IPR12_PRI_48_OFS                    ( 0)                            /*!< PRI_48 Offset */
N#define NVIC_IPR12_PRI_48_M                      ((uint32_t)0x000000ff)          /*  */
N/* NVIC_IPR12[NVIC_IPR12_PRI_49] Bits */
N#define NVIC_IPR12_PRI_49_OFS                    ( 8)                            /*!< PRI_49 Offset */
N#define NVIC_IPR12_PRI_49_M                      ((uint32_t)0x0000ff00)          /*  */
N/* NVIC_IPR12[NVIC_IPR12_PRI_50] Bits */
N#define NVIC_IPR12_PRI_50_OFS                    (16)                            /*!< PRI_50 Offset */
N#define NVIC_IPR12_PRI_50_M                      ((uint32_t)0x00ff0000)          /*  */
N/* NVIC_IPR12[NVIC_IPR12_PRI_51] Bits */
N#define NVIC_IPR12_PRI_51_OFS                    (24)                            /*!< PRI_51 Offset */
N#define NVIC_IPR12_PRI_51_M                      ((uint32_t)0xff000000)          /*  */
N/* NVIC_IPR13[NVIC_IPR13_PRI_52] Bits */
N#define NVIC_IPR13_PRI_52_OFS                    ( 0)                            /*!< PRI_52 Offset */
N#define NVIC_IPR13_PRI_52_M                      ((uint32_t)0x000000ff)          /*  */
N/* NVIC_IPR13[NVIC_IPR13_PRI_53] Bits */
N#define NVIC_IPR13_PRI_53_OFS                    ( 8)                            /*!< PRI_53 Offset */
N#define NVIC_IPR13_PRI_53_M                      ((uint32_t)0x0000ff00)          /*  */
N/* NVIC_IPR13[NVIC_IPR13_PRI_54] Bits */
N#define NVIC_IPR13_PRI_54_OFS                    (16)                            /*!< PRI_54 Offset */
N#define NVIC_IPR13_PRI_54_M                      ((uint32_t)0x00ff0000)          /*  */
N/* NVIC_IPR13[NVIC_IPR13_PRI_55] Bits */
N#define NVIC_IPR13_PRI_55_OFS                    (24)                            /*!< PRI_55 Offset */
N#define NVIC_IPR13_PRI_55_M                      ((uint32_t)0xff000000)          /*  */
N/* NVIC_IPR14[NVIC_IPR14_PRI_56] Bits */
N#define NVIC_IPR14_PRI_56_OFS                    ( 0)                            /*!< PRI_56 Offset */
N#define NVIC_IPR14_PRI_56_M                      ((uint32_t)0x000000ff)          /*  */
N/* NVIC_IPR14[NVIC_IPR14_PRI_57] Bits */
N#define NVIC_IPR14_PRI_57_OFS                    ( 8)                            /*!< PRI_57 Offset */
N#define NVIC_IPR14_PRI_57_M                      ((uint32_t)0x0000ff00)          /*  */
N/* NVIC_IPR14[NVIC_IPR14_PRI_58] Bits */
N#define NVIC_IPR14_PRI_58_OFS                    (16)                            /*!< PRI_58 Offset */
N#define NVIC_IPR14_PRI_58_M                      ((uint32_t)0x00ff0000)          /*  */
N/* NVIC_IPR14[NVIC_IPR14_PRI_59] Bits */
N#define NVIC_IPR14_PRI_59_OFS                    (24)                            /*!< PRI_59 Offset */
N#define NVIC_IPR14_PRI_59_M                      ((uint32_t)0xff000000)          /*  */
N/* NVIC_IPR15[NVIC_IPR15_PRI_60] Bits */
N#define NVIC_IPR15_PRI_60_OFS                    ( 0)                            /*!< PRI_60 Offset */
N#define NVIC_IPR15_PRI_60_M                      ((uint32_t)0x000000ff)          /*  */
N/* NVIC_IPR15[NVIC_IPR15_PRI_61] Bits */
N#define NVIC_IPR15_PRI_61_OFS                    ( 8)                            /*!< PRI_61 Offset */
N#define NVIC_IPR15_PRI_61_M                      ((uint32_t)0x0000ff00)          /*  */
N/* NVIC_IPR15[NVIC_IPR15_PRI_62] Bits */
N#define NVIC_IPR15_PRI_62_OFS                    (16)                            /*!< PRI_62 Offset */
N#define NVIC_IPR15_PRI_62_M                      ((uint32_t)0x00ff0000)          /*  */
N/* NVIC_IPR15[NVIC_IPR15_PRI_63] Bits */
N#define NVIC_IPR15_PRI_63_OFS                    (24)                            /*!< PRI_63 Offset */
N#define NVIC_IPR15_PRI_63_M                      ((uint32_t)0xff000000)          /*  */
N
N
N/******************************************************************************
N* PCM Bits
N******************************************************************************/
N/* PCM_CTL0[AMR] Bits */
N#define PCM_CTL0_AMR_OFS                         ( 0)                            /*!< AMR Bit Offset */
N#define PCM_CTL0_AMR_MASK                        ((uint32_t)0x0000000F)          /*!< AMR Bit Mask */
N#define PCM_CTL0_AMR0                            ((uint32_t)0x00000001)          /*!< AMR Bit 0 */
N#define PCM_CTL0_AMR1                            ((uint32_t)0x00000002)          /*!< AMR Bit 1 */
N#define PCM_CTL0_AMR2                            ((uint32_t)0x00000004)          /*!< AMR Bit 2 */
N#define PCM_CTL0_AMR3                            ((uint32_t)0x00000008)          /*!< AMR Bit 3 */
N#define PCM_CTL0_AMR_0                           ((uint32_t)0x00000000)          /*!< LDO based Active Mode at Core voltage setting 0. */
N#define PCM_CTL0_AMR_1                           ((uint32_t)0x00000001)          /*!< LDO based Active Mode at Core voltage setting 1. */
N#define PCM_CTL0_AMR_4                           ((uint32_t)0x00000004)          /*!< DC-DC based Active Mode at Core voltage setting 0. */
N#define PCM_CTL0_AMR_5                           ((uint32_t)0x00000005)          /*!< DC-DC based Active Mode at Core voltage setting 1. */
N#define PCM_CTL0_AMR_8                           ((uint32_t)0x00000008)          /*!< Low-Frequency Active Mode at Core voltage setting 0. */
N#define PCM_CTL0_AMR_9                           ((uint32_t)0x00000009)          /*!< Low-Frequency Active Mode at Core voltage setting 1. */
N#define PCM_CTL0_AMR__AM_LDO_VCORE0              ((uint32_t)0x00000000)          /*!< LDO based Active Mode at Core voltage setting 0. */
N#define PCM_CTL0_AMR__AM_LDO_VCORE1              ((uint32_t)0x00000001)          /*!< LDO based Active Mode at Core voltage setting 1. */
N#define PCM_CTL0_AMR__AM_DCDC_VCORE0             ((uint32_t)0x00000004)          /*!< DC-DC based Active Mode at Core voltage setting 0. */
N#define PCM_CTL0_AMR__AM_DCDC_VCORE1             ((uint32_t)0x00000005)          /*!< DC-DC based Active Mode at Core voltage setting 1. */
N#define PCM_CTL0_AMR__AM_LF_VCORE0               ((uint32_t)0x00000008)          /*!< Low-Frequency Active Mode at Core voltage setting 0. */
N#define PCM_CTL0_AMR__AM_LF_VCORE1               ((uint32_t)0x00000009)          /*!< Low-Frequency Active Mode at Core voltage setting 1. */
N/* PCM_CTL0[LPMR] Bits */
N#define PCM_CTL0_LPMR_OFS                        ( 4)                            /*!< LPMR Bit Offset */
N#define PCM_CTL0_LPMR_MASK                       ((uint32_t)0x000000F0)          /*!< LPMR Bit Mask */
N#define PCM_CTL0_LPMR0                           ((uint32_t)0x00000010)          /*!< LPMR Bit 0 */
N#define PCM_CTL0_LPMR1                           ((uint32_t)0x00000020)          /*!< LPMR Bit 1 */
N#define PCM_CTL0_LPMR2                           ((uint32_t)0x00000040)          /*!< LPMR Bit 2 */
N#define PCM_CTL0_LPMR3                           ((uint32_t)0x00000080)          /*!< LPMR Bit 3 */
N#define PCM_CTL0_LPMR_0                          ((uint32_t)0x00000000)          /*!< LPM3. Core voltage setting is similar to the mode from which LPM3 is  */
N                                                                                 /* entered. */
N#define PCM_CTL0_LPMR_10                         ((uint32_t)0x000000A0)          /*!< LPM3.5. Core voltage setting 0. */
N#define PCM_CTL0_LPMR_12                         ((uint32_t)0x000000C0)          /*!< LPM4.5 */
N#define PCM_CTL0_LPMR__LPM3                      ((uint32_t)0x00000000)          /*!< LPM3. Core voltage setting is similar to the mode from which LPM3 is  */
N                                                                                 /* entered. */
N#define PCM_CTL0_LPMR__LPM35                     ((uint32_t)0x000000A0)          /*!< LPM3.5. Core voltage setting 0. */
N#define PCM_CTL0_LPMR__LPM45                     ((uint32_t)0x000000C0)          /*!< LPM4.5 */
N/* PCM_CTL0[CPM] Bits */
N#define PCM_CTL0_CPM_OFS                         ( 8)                            /*!< CPM Bit Offset */
N#define PCM_CTL0_CPM_MASK                        ((uint32_t)0x00003F00)          /*!< CPM Bit Mask */
N#define PCM_CTL0_CPM0                            ((uint32_t)0x00000100)          /*!< CPM Bit 0 */
N#define PCM_CTL0_CPM1                            ((uint32_t)0x00000200)          /*!< CPM Bit 1 */
N#define PCM_CTL0_CPM2                            ((uint32_t)0x00000400)          /*!< CPM Bit 2 */
N#define PCM_CTL0_CPM3                            ((uint32_t)0x00000800)          /*!< CPM Bit 3 */
N#define PCM_CTL0_CPM4                            ((uint32_t)0x00001000)          /*!< CPM Bit 4 */
N#define PCM_CTL0_CPM5                            ((uint32_t)0x00002000)          /*!< CPM Bit 5 */
N#define PCM_CTL0_CPM_0                           ((uint32_t)0x00000000)          /*!< LDO based Active Mode at Core voltage setting 0. */
N#define PCM_CTL0_CPM_1                           ((uint32_t)0x00000100)          /*!< LDO based Active Mode at Core voltage setting 1. */
N#define PCM_CTL0_CPM_4                           ((uint32_t)0x00000400)          /*!< DC-DC based Active Mode at Core voltage setting 0. */
N#define PCM_CTL0_CPM_5                           ((uint32_t)0x00000500)          /*!< DC-DC based Active Mode at Core voltage setting 1. */
N#define PCM_CTL0_CPM_8                           ((uint32_t)0x00000800)          /*!< Low-Frequency Active Mode at Core voltage setting 0. */
N#define PCM_CTL0_CPM_9                           ((uint32_t)0x00000900)          /*!< Low-Frequency Active Mode at Core voltage setting 1. */
N#define PCM_CTL0_CPM_16                          ((uint32_t)0x00001000)          /*!< LDO based LPM0 at Core voltage setting 0. */
N#define PCM_CTL0_CPM_17                          ((uint32_t)0x00001100)          /*!< LDO based LPM0 at Core voltage setting 1. */
N#define PCM_CTL0_CPM_20                          ((uint32_t)0x00001400)          /*!< DC-DC based LPM0 at Core voltage setting 0. */
N#define PCM_CTL0_CPM_21                          ((uint32_t)0x00001500)          /*!< DC-DC based LPM0 at Core voltage setting 1. */
N#define PCM_CTL0_CPM_24                          ((uint32_t)0x00001800)          /*!< Low-Frequency LPM0 at Core voltage setting 0. */
N#define PCM_CTL0_CPM_25                          ((uint32_t)0x00001900)          /*!< Low-Frequency LPM0 at Core voltage setting 1. */
N#define PCM_CTL0_CPM_32                          ((uint32_t)0x00002000)          /*!< LPM3 */
N#define PCM_CTL0_CPM__AM_LDO_VCORE0              ((uint32_t)0x00000000)          /*!< LDO based Active Mode at Core voltage setting 0. */
N#define PCM_CTL0_CPM__AM_LDO_VCORE1              ((uint32_t)0x00000100)          /*!< LDO based Active Mode at Core voltage setting 1. */
N#define PCM_CTL0_CPM__AM_DCDC_VCORE0             ((uint32_t)0x00000400)          /*!< DC-DC based Active Mode at Core voltage setting 0. */
N#define PCM_CTL0_CPM__AM_DCDC_VCORE1             ((uint32_t)0x00000500)          /*!< DC-DC based Active Mode at Core voltage setting 1. */
N#define PCM_CTL0_CPM__AM_LF_VCORE0               ((uint32_t)0x00000800)          /*!< Low-Frequency Active Mode at Core voltage setting 0. */
N#define PCM_CTL0_CPM__AM_LF_VCORE1               ((uint32_t)0x00000900)          /*!< Low-Frequency Active Mode at Core voltage setting 1. */
N#define PCM_CTL0_CPM__LPM0_LDO_VCORE0            ((uint32_t)0x00001000)          /*!< LDO based LPM0 at Core voltage setting 0. */
N#define PCM_CTL0_CPM__LPM0_LDO_VCORE1            ((uint32_t)0x00001100)          /*!< LDO based LPM0 at Core voltage setting 1. */
N#define PCM_CTL0_CPM__LPM0_DCDC_VCORE0           ((uint32_t)0x00001400)          /*!< DC-DC based LPM0 at Core voltage setting 0. */
N#define PCM_CTL0_CPM__LPM0_DCDC_VCORE1           ((uint32_t)0x00001500)          /*!< DC-DC based LPM0 at Core voltage setting 1. */
N#define PCM_CTL0_CPM__LPM0_LF_VCORE0             ((uint32_t)0x00001800)          /*!< Low-Frequency LPM0 at Core voltage setting 0. */
N#define PCM_CTL0_CPM__LPM0_LF_VCORE1             ((uint32_t)0x00001900)          /*!< Low-Frequency LPM0 at Core voltage setting 1. */
N#define PCM_CTL0_CPM__LPM3                       ((uint32_t)0x00002000)          /*!< LPM3 */
N/* PCM_CTL0[KEY] Bits */
N#define PCM_CTL0_KEY_OFS                         (16)                            /*!< PCMKEY Bit Offset */
N#define PCM_CTL0_KEY_MASK                        ((uint32_t)0xFFFF0000)          /*!< PCMKEY Bit Mask */
N/* PCM_CTL1[LOCKLPM5] Bits */
N#define PCM_CTL1_LOCKLPM5_OFS                    ( 0)                            /*!< LOCKLPM5 Bit Offset */
N#define PCM_CTL1_LOCKLPM5                        ((uint32_t)0x00000001)          /*!< Lock LPM5 */
N/* PCM_CTL1[LOCKBKUP] Bits */
N#define PCM_CTL1_LOCKBKUP_OFS                    ( 1)                            /*!< LOCKBKUP Bit Offset */
N#define PCM_CTL1_LOCKBKUP                        ((uint32_t)0x00000002)          /*!< Lock Backup */
N/* PCM_CTL1[FORCE_LPM_ENTRY] Bits */
N#define PCM_CTL1_FORCE_LPM_ENTRY_OFS             ( 2)                            /*!< FORCE_LPM_ENTRY Bit Offset */
N#define PCM_CTL1_FORCE_LPM_ENTRY                 ((uint32_t)0x00000004)          /*!< Force LPM entry */
N/* PCM_CTL1[PMR_BUSY] Bits */
N#define PCM_CTL1_PMR_BUSY_OFS                    ( 8)                            /*!< PMR_BUSY Bit Offset */
N#define PCM_CTL1_PMR_BUSY                        ((uint32_t)0x00000100)          /*!< Power mode request busy flag */
N/* PCM_CTL1[KEY] Bits */
N#define PCM_CTL1_KEY_OFS                         (16)                            /*!< PCMKEY Bit Offset */
N#define PCM_CTL1_KEY_MASK                        ((uint32_t)0xFFFF0000)          /*!< PCMKEY Bit Mask */
N/* PCM_IE[LPM_INVALID_TR_IE] Bits */
N#define PCM_IE_LPM_INVALID_TR_IE_OFS             ( 0)                            /*!< LPM_INVALID_TR_IE Bit Offset */
N#define PCM_IE_LPM_INVALID_TR_IE                 ((uint32_t)0x00000001)          /*!< LPM invalid transition interrupt enable */
N/* PCM_IE[LPM_INVALID_CLK_IE] Bits */
N#define PCM_IE_LPM_INVALID_CLK_IE_OFS            ( 1)                            /*!< LPM_INVALID_CLK_IE Bit Offset */
N#define PCM_IE_LPM_INVALID_CLK_IE                ((uint32_t)0x00000002)          /*!< LPM invalid clock interrupt enable */
N/* PCM_IE[AM_INVALID_TR_IE] Bits */
N#define PCM_IE_AM_INVALID_TR_IE_OFS              ( 2)                            /*!< AM_INVALID_TR_IE Bit Offset */
N#define PCM_IE_AM_INVALID_TR_IE                  ((uint32_t)0x00000004)          /*!< Active mode invalid transition interrupt enable */
N/* PCM_IE[DCDC_ERROR_IE] Bits */
N#define PCM_IE_DCDC_ERROR_IE_OFS                 ( 6)                            /*!< DCDC_ERROR_IE Bit Offset */
N#define PCM_IE_DCDC_ERROR_IE                     ((uint32_t)0x00000040)          /*!< DC-DC error interrupt enable */
N/* PCM_IFG[LPM_INVALID_TR_IFG] Bits */
N#define PCM_IFG_LPM_INVALID_TR_IFG_OFS           ( 0)                            /*!< LPM_INVALID_TR_IFG Bit Offset */
N#define PCM_IFG_LPM_INVALID_TR_IFG               ((uint32_t)0x00000001)          /*!< LPM invalid transition flag */
N/* PCM_IFG[LPM_INVALID_CLK_IFG] Bits */
N#define PCM_IFG_LPM_INVALID_CLK_IFG_OFS          ( 1)                            /*!< LPM_INVALID_CLK_IFG Bit Offset */
N#define PCM_IFG_LPM_INVALID_CLK_IFG              ((uint32_t)0x00000002)          /*!< LPM invalid clock flag */
N/* PCM_IFG[AM_INVALID_TR_IFG] Bits */
N#define PCM_IFG_AM_INVALID_TR_IFG_OFS            ( 2)                            /*!< AM_INVALID_TR_IFG Bit Offset */
N#define PCM_IFG_AM_INVALID_TR_IFG                ((uint32_t)0x00000004)          /*!< Active mode invalid transition flag */
N/* PCM_IFG[DCDC_ERROR_IFG] Bits */
N#define PCM_IFG_DCDC_ERROR_IFG_OFS               ( 6)                            /*!< DCDC_ERROR_IFG Bit Offset */
N#define PCM_IFG_DCDC_ERROR_IFG                   ((uint32_t)0x00000040)          /*!< DC-DC error flag */
N/* PCM_CLRIFG[CLR_LPM_INVALID_TR_IFG] Bits */
N#define PCM_CLRIFG_CLR_LPM_INVALID_TR_IFG_OFS    ( 0)                            /*!< CLR_LPM_INVALID_TR_IFG Bit Offset */
N#define PCM_CLRIFG_CLR_LPM_INVALID_TR_IFG        ((uint32_t)0x00000001)          /*!< Clear LPM invalid transition flag */
N/* PCM_CLRIFG[CLR_LPM_INVALID_CLK_IFG] Bits */
N#define PCM_CLRIFG_CLR_LPM_INVALID_CLK_IFG_OFS   ( 1)                            /*!< CLR_LPM_INVALID_CLK_IFG Bit Offset */
N#define PCM_CLRIFG_CLR_LPM_INVALID_CLK_IFG       ((uint32_t)0x00000002)          /*!< Clear LPM invalid clock flag */
N/* PCM_CLRIFG[CLR_AM_INVALID_TR_IFG] Bits */
N#define PCM_CLRIFG_CLR_AM_INVALID_TR_IFG_OFS     ( 2)                            /*!< CLR_AM_INVALID_TR_IFG Bit Offset */
N#define PCM_CLRIFG_CLR_AM_INVALID_TR_IFG         ((uint32_t)0x00000004)          /*!< Clear active mode invalid transition flag */
N/* PCM_CLRIFG[CLR_DCDC_ERROR_IFG] Bits */
N#define PCM_CLRIFG_CLR_DCDC_ERROR_IFG_OFS        ( 6)                            /*!< CLR_DCDC_ERROR_IFG Bit Offset */
N#define PCM_CLRIFG_CLR_DCDC_ERROR_IFG            ((uint32_t)0x00000040)          /*!< Clear DC-DC error flag */
N/* Pre-defined bitfield values */
N#define PCM_CTL0_KEY_VAL                         ((uint32_t)0x695A0000)          /*!< PCM key value */
N#define PCM_CTL1_KEY_VAL                         ((uint32_t)0x695A0000)          /*!< PCM key value */
N
N
N/******************************************************************************
N* PMAP Bits
N******************************************************************************/
N/* PMAP_CTL[LOCKED] Bits */
N#define PMAP_CTL_LOCKED_OFS                      ( 0)                            /*!< PMAPLOCKED Bit Offset */
N#define PMAP_CTL_LOCKED                          ((uint16_t)0x0001)              /*!< Port mapping lock bit */
N/* PMAP_CTL[PRECFG] Bits */
N#define PMAP_CTL_PRECFG_OFS                      ( 1)                            /*!< PMAPRECFG Bit Offset */
N#define PMAP_CTL_PRECFG                          ((uint16_t)0x0002)              /*!< Port mapping reconfiguration control bit */
N/* Pre-defined bitfield values */
N#define PMAP_NONE                                            0
N#define PMAP_UCA0CLK                                         1
N#define PMAP_UCA0RXD                                         2
N#define PMAP_UCA0SOMI                                        2
N#define PMAP_UCA0TXD                                         3
N#define PMAP_UCA0SIMO                                        3
N#define PMAP_UCB0CLK                                         4
N#define PMAP_UCB0SDA                                         5
N#define PMAP_UCB0SIMO                                        5
N#define PMAP_UCB0SCL                                         6
N#define PMAP_UCB0SOMI                                        6
N#define PMAP_UCA1STE                                         7
N#define PMAP_UCA1CLK                                         8
N#define PMAP_UCA1RXD                                         9
N#define PMAP_UCA1SOMI                                        9
N#define PMAP_UCA1TXD                                         10
N#define PMAP_UCA1SIMO                                        10
N#define PMAP_UCA2STE                                         11
N#define PMAP_UCA2CLK                                         12
N#define PMAP_UCA2RXD                                         13
N#define PMAP_UCA2SOMI                                        13
N#define PMAP_UCA2TXD                                         14
N#define PMAP_UCA2SIMO                                        14
N#define PMAP_UCB2STE                                         15
N#define PMAP_UCB2CLK                                         16
N#define PMAP_UCB2SDA                                         17
N#define PMAP_UCB2SIMO                                        17
N#define PMAP_UCB2SCL                                         18
N#define PMAP_UCB2SOMI                                        18
N#define PMAP_TA0CCR0A                                        19
N#define PMAP_TA0CCR1A                                        20
N#define PMAP_TA0CCR2A                                        21
N#define PMAP_TA0CCR3A                                        22
N#define PMAP_TA0CCR4A                                        23
N#define PMAP_TA1CCR1A                                        24
N#define PMAP_TA1CCR2A                                        25
N#define PMAP_TA1CCR3A                                        26
N#define PMAP_TA1CCR4A                                        27
N#define PMAP_TA0CLK                                          28
N#define PMAP_CE0OUT                                          28
N#define PMAP_TA1CLK                                          29
N#define PMAP_CE1OUT                                          29
N#define PMAP_DMAE0                                           30
N#define PMAP_SMCLK                                           30
N#define PMAP_ANALOG                                          31
N
N#define PMAP_KEYID_VAL                           ((uint16_t)0x2D52)              /*!< Port Mapping Key */
N
N
N/******************************************************************************
N* PSS Bits
N******************************************************************************/
N/* PSS_KEY[KEY] Bits */
N#define PSS_KEY_KEY_OFS                          ( 0)                            /*!< PSSKEY Bit Offset */
N#define PSS_KEY_KEY_MASK                         ((uint32_t)0x0000FFFF)          /*!< PSSKEY Bit Mask */
N/* PSS_CTL0[SVSMHOFF] Bits */
N#define PSS_CTL0_SVSMHOFF_OFS                    ( 0)                            /*!< SVSMHOFF Bit Offset */
N#define PSS_CTL0_SVSMHOFF                        ((uint32_t)0x00000001)          /*!< SVSM high-side off */
N/* PSS_CTL0[SVSMHLP] Bits */
N#define PSS_CTL0_SVSMHLP_OFS                     ( 1)                            /*!< SVSMHLP Bit Offset */
N#define PSS_CTL0_SVSMHLP                         ((uint32_t)0x00000002)          /*!< SVSM high-side low power normal performance mode */
N/* PSS_CTL0[SVSMHS] Bits */
N#define PSS_CTL0_SVSMHS_OFS                      ( 2)                            /*!< SVSMHS Bit Offset */
N#define PSS_CTL0_SVSMHS                          ((uint32_t)0x00000004)          /*!< Supply supervisor or monitor selection for the high-side */
N/* PSS_CTL0[SVSMHTH] Bits */
N#define PSS_CTL0_SVSMHTH_OFS                     ( 3)                            /*!< SVSMHTH Bit Offset */
N#define PSS_CTL0_SVSMHTH_MASK                    ((uint32_t)0x00000038)          /*!< SVSMHTH Bit Mask */
N/* PSS_CTL0[SVMHOE] Bits */
N#define PSS_CTL0_SVMHOE_OFS                      ( 6)                            /*!< SVMHOE Bit Offset */
N#define PSS_CTL0_SVMHOE                          ((uint32_t)0x00000040)          /*!< SVSM high-side output enable */
N/* PSS_CTL0[SVMHOUTPOLAL] Bits */
N#define PSS_CTL0_SVMHOUTPOLAL_OFS                ( 7)                            /*!< SVMHOUTPOLAL Bit Offset */
N#define PSS_CTL0_SVMHOUTPOLAL                    ((uint32_t)0x00000080)          /*!< SVMHOUT pin polarity active low */
N/* PSS_CTL0[DCDC_FORCE] Bits */
N#define PSS_CTL0_DCDC_FORCE_OFS                  (10)                            /*!< DCDC_FORCE Bit Offset */
N#define PSS_CTL0_DCDC_FORCE                      ((uint32_t)0x00000400)          /*!< Force DC-DC regulator operation */
N/* PSS_CTL0[VCORETRAN] Bits */
N#define PSS_CTL0_VCORETRAN_OFS                   (12)                            /*!< VCORETRAN Bit Offset */
N#define PSS_CTL0_VCORETRAN_MASK                  ((uint32_t)0x00003000)          /*!< VCORETRAN Bit Mask */
N#define PSS_CTL0_VCORETRAN0                      ((uint32_t)0x00001000)          /*!< VCORETRAN Bit 0 */
N#define PSS_CTL0_VCORETRAN1                      ((uint32_t)0x00002000)          /*!< VCORETRAN Bit 1 */
N#define PSS_CTL0_VCORETRAN_0                     ((uint32_t)0x00000000)          /*!< 32 s / 100 mV */
N#define PSS_CTL0_VCORETRAN_1                     ((uint32_t)0x00001000)          /*!< 64 s / 100 mV */
N#define PSS_CTL0_VCORETRAN_2                     ((uint32_t)0x00002000)          /*!< 128 s / 100 mV (default) */
N#define PSS_CTL0_VCORETRAN_3                     ((uint32_t)0x00003000)          /*!< 256 s / 100 mV */
N#define PSS_CTL0_VCORETRAN__32                   ((uint32_t)0x00000000)          /*!< 32 s / 100 mV */
N#define PSS_CTL0_VCORETRAN__64                   ((uint32_t)0x00001000)          /*!< 64 s / 100 mV */
N#define PSS_CTL0_VCORETRAN__128                  ((uint32_t)0x00002000)          /*!< 128 s / 100 mV (default) */
N#define PSS_CTL0_VCORETRAN__256                  ((uint32_t)0x00003000)          /*!< 256 s / 100 mV */
N/* PSS_IE[SVSMHIE] Bits */
N#define PSS_IE_SVSMHIE_OFS                       ( 1)                            /*!< SVSMHIE Bit Offset */
N#define PSS_IE_SVSMHIE                           ((uint32_t)0x00000002)          /*!< High-side SVSM interrupt enable */
N/* PSS_IFG[SVSMHIFG] Bits */
N#define PSS_IFG_SVSMHIFG_OFS                     ( 1)                            /*!< SVSMHIFG Bit Offset */
N#define PSS_IFG_SVSMHIFG                         ((uint32_t)0x00000002)          /*!< High-side SVSM interrupt flag */
N/* PSS_CLRIFG[CLRSVSMHIFG] Bits */
N#define PSS_CLRIFG_CLRSVSMHIFG_OFS               ( 1)                            /*!< CLRSVSMHIFG Bit Offset */
N#define PSS_CLRIFG_CLRSVSMHIFG                   ((uint32_t)0x00000002)          /*!< SVSMH clear interrupt flag */
N/* Pre-defined bitfield values */
N#define PSS_KEY_KEY_VAL                           ((uint32_t)0x0000695A)          /*!< PSS control key value */
N
N
N/******************************************************************************
N* REF_A Bits
N******************************************************************************/
N/* REF_A_CTL0[ON] Bits */
N#define REF_A_CTL0_ON_OFS                        ( 0)                            /*!< REFON Bit Offset */
N#define REF_A_CTL0_ON                            ((uint16_t)0x0001)              /*!< Reference enable */
N/* REF_A_CTL0[OUT] Bits */
N#define REF_A_CTL0_OUT_OFS                       ( 1)                            /*!< REFOUT Bit Offset */
N#define REF_A_CTL0_OUT                           ((uint16_t)0x0002)              /*!< Reference output buffer */
N/* REF_A_CTL0[TCOFF] Bits */
N#define REF_A_CTL0_TCOFF_OFS                     ( 3)                            /*!< REFTCOFF Bit Offset */
N#define REF_A_CTL0_TCOFF                         ((uint16_t)0x0008)              /*!< Temperature sensor disabled */
N/* REF_A_CTL0[VSEL] Bits */
N#define REF_A_CTL0_VSEL_OFS                      ( 4)                            /*!< REFVSEL Bit Offset */
N#define REF_A_CTL0_VSEL_MASK                     ((uint16_t)0x0030)              /*!< REFVSEL Bit Mask */
N#define REF_A_CTL0_VSEL0                         ((uint16_t)0x0010)              /*!< VSEL Bit 0 */
N#define REF_A_CTL0_VSEL1                         ((uint16_t)0x0020)              /*!< VSEL Bit 1 */
N#define REF_A_CTL0_VSEL_0                        ((uint16_t)0x0000)              /*!< 1.2 V available when reference requested or REFON = 1 */
N#define REF_A_CTL0_VSEL_1                        ((uint16_t)0x0010)              /*!< 1.45 V available when reference requested or REFON = 1 */
N#define REF_A_CTL0_VSEL_3                        ((uint16_t)0x0030)              /*!< 2.5 V available when reference requested or REFON = 1 */
N/* REF_A_CTL0[GENOT] Bits */
N#define REF_A_CTL0_GENOT_OFS                     ( 6)                            /*!< REFGENOT Bit Offset */
N#define REF_A_CTL0_GENOT                         ((uint16_t)0x0040)              /*!< Reference generator one-time trigger */
N/* REF_A_CTL0[BGOT] Bits */
N#define REF_A_CTL0_BGOT_OFS                      ( 7)                            /*!< REFBGOT Bit Offset */
N#define REF_A_CTL0_BGOT                          ((uint16_t)0x0080)              /*!< Bandgap and bandgap buffer one-time trigger */
N/* REF_A_CTL0[GENACT] Bits */
N#define REF_A_CTL0_GENACT_OFS                    ( 8)                            /*!< REFGENACT Bit Offset */
N#define REF_A_CTL0_GENACT                        ((uint16_t)0x0100)              /*!< Reference generator active */
N/* REF_A_CTL0[BGACT] Bits */
N#define REF_A_CTL0_BGACT_OFS                     ( 9)                            /*!< REFBGACT Bit Offset */
N#define REF_A_CTL0_BGACT                         ((uint16_t)0x0200)              /*!< Reference bandgap active */
N/* REF_A_CTL0[GENBUSY] Bits */
N#define REF_A_CTL0_GENBUSY_OFS                   (10)                            /*!< REFGENBUSY Bit Offset */
N#define REF_A_CTL0_GENBUSY                       ((uint16_t)0x0400)              /*!< Reference generator busy */
N/* REF_A_CTL0[BGMODE] Bits */
N#define REF_A_CTL0_BGMODE_OFS                    (11)                            /*!< BGMODE Bit Offset */
N#define REF_A_CTL0_BGMODE                        ((uint16_t)0x0800)              /*!< Bandgap mode */
N/* REF_A_CTL0[GENRDY] Bits */
N#define REF_A_CTL0_GENRDY_OFS                    (12)                            /*!< REFGENRDY Bit Offset */
N#define REF_A_CTL0_GENRDY                        ((uint16_t)0x1000)              /*!< Variable reference voltage ready status */
N/* REF_A_CTL0[BGRDY] Bits */
N#define REF_A_CTL0_BGRDY_OFS                     (13)                            /*!< REFBGRDY Bit Offset */
N#define REF_A_CTL0_BGRDY                         ((uint16_t)0x2000)              /*!< Buffered bandgap voltage ready status */
N
N/******************************************************************************
N* RSTCTL Bits
N******************************************************************************/
N/* RSTCTL_RESET_REQ[SOFT_REQ] Bits */
N#define RSTCTL_RESET_REQ_SOFT_REQ_OFS            ( 0)                            /*!< SOFT_REQ Bit Offset */
N#define RSTCTL_RESET_REQ_SOFT_REQ                ((uint32_t)0x00000001)          /*!< Soft Reset request */
N/* RSTCTL_RESET_REQ[HARD_REQ] Bits */
N#define RSTCTL_RESET_REQ_HARD_REQ_OFS            ( 1)                            /*!< HARD_REQ Bit Offset */
N#define RSTCTL_RESET_REQ_HARD_REQ                ((uint32_t)0x00000002)          /*!< Hard Reset request */
N/* RSTCTL_RESET_REQ[RSTKEY] Bits */
N#define RSTCTL_RESET_REQ_RSTKEY_OFS              ( 8)                            /*!< RSTKEY Bit Offset */
N#define RSTCTL_RESET_REQ_RSTKEY_MASK             ((uint32_t)0x0000FF00)          /*!< RSTKEY Bit Mask */
N/* RSTCTL_HARDRESET_STAT[SRC0] Bits */
N#define RSTCTL_HARDRESET_STAT_SRC0_OFS           ( 0)                            /*!< SRC0 Bit Offset */
N#define RSTCTL_HARDRESET_STAT_SRC0               ((uint32_t)0x00000001)          /*!< Indicates that SRC0 was the source of the Hard Reset */
N/* RSTCTL_HARDRESET_STAT[SRC1] Bits */
N#define RSTCTL_HARDRESET_STAT_SRC1_OFS           ( 1)                            /*!< SRC1 Bit Offset */
N#define RSTCTL_HARDRESET_STAT_SRC1               ((uint32_t)0x00000002)          /*!< Indicates that SRC1 was the source of the Hard Reset */
N/* RSTCTL_HARDRESET_STAT[SRC2] Bits */
N#define RSTCTL_HARDRESET_STAT_SRC2_OFS           ( 2)                            /*!< SRC2 Bit Offset */
N#define RSTCTL_HARDRESET_STAT_SRC2               ((uint32_t)0x00000004)          /*!< Indicates that SRC2 was the source of the Hard Reset */
N/* RSTCTL_HARDRESET_STAT[SRC3] Bits */
N#define RSTCTL_HARDRESET_STAT_SRC3_OFS           ( 3)                            /*!< SRC3 Bit Offset */
N#define RSTCTL_HARDRESET_STAT_SRC3               ((uint32_t)0x00000008)          /*!< Indicates that SRC3 was the source of the Hard Reset */
N/* RSTCTL_HARDRESET_STAT[SRC4] Bits */
N#define RSTCTL_HARDRESET_STAT_SRC4_OFS           ( 4)                            /*!< SRC4 Bit Offset */
N#define RSTCTL_HARDRESET_STAT_SRC4               ((uint32_t)0x00000010)          /*!< Indicates that SRC4 was the source of the Hard Reset */
N/* RSTCTL_HARDRESET_STAT[SRC5] Bits */
N#define RSTCTL_HARDRESET_STAT_SRC5_OFS           ( 5)                            /*!< SRC5 Bit Offset */
N#define RSTCTL_HARDRESET_STAT_SRC5               ((uint32_t)0x00000020)          /*!< Indicates that SRC5 was the source of the Hard Reset */
N/* RSTCTL_HARDRESET_STAT[SRC6] Bits */
N#define RSTCTL_HARDRESET_STAT_SRC6_OFS           ( 6)                            /*!< SRC6 Bit Offset */
N#define RSTCTL_HARDRESET_STAT_SRC6               ((uint32_t)0x00000040)          /*!< Indicates that SRC6 was the source of the Hard Reset */
N/* RSTCTL_HARDRESET_STAT[SRC7] Bits */
N#define RSTCTL_HARDRESET_STAT_SRC7_OFS           ( 7)                            /*!< SRC7 Bit Offset */
N#define RSTCTL_HARDRESET_STAT_SRC7               ((uint32_t)0x00000080)          /*!< Indicates that SRC7 was the source of the Hard Reset */
N/* RSTCTL_HARDRESET_STAT[SRC8] Bits */
N#define RSTCTL_HARDRESET_STAT_SRC8_OFS           ( 8)                            /*!< SRC8 Bit Offset */
N#define RSTCTL_HARDRESET_STAT_SRC8               ((uint32_t)0x00000100)          /*!< Indicates that SRC8 was the source of the Hard Reset */
N/* RSTCTL_HARDRESET_STAT[SRC9] Bits */
N#define RSTCTL_HARDRESET_STAT_SRC9_OFS           ( 9)                            /*!< SRC9 Bit Offset */
N#define RSTCTL_HARDRESET_STAT_SRC9               ((uint32_t)0x00000200)          /*!< Indicates that SRC9 was the source of the Hard Reset */
N/* RSTCTL_HARDRESET_STAT[SRC10] Bits */
N#define RSTCTL_HARDRESET_STAT_SRC10_OFS          (10)                            /*!< SRC10 Bit Offset */
N#define RSTCTL_HARDRESET_STAT_SRC10              ((uint32_t)0x00000400)          /*!< Indicates that SRC10 was the source of the Hard Reset */
N/* RSTCTL_HARDRESET_STAT[SRC11] Bits */
N#define RSTCTL_HARDRESET_STAT_SRC11_OFS          (11)                            /*!< SRC11 Bit Offset */
N#define RSTCTL_HARDRESET_STAT_SRC11              ((uint32_t)0x00000800)          /*!< Indicates that SRC11 was the source of the Hard Reset */
N/* RSTCTL_HARDRESET_STAT[SRC12] Bits */
N#define RSTCTL_HARDRESET_STAT_SRC12_OFS          (12)                            /*!< SRC12 Bit Offset */
N#define RSTCTL_HARDRESET_STAT_SRC12              ((uint32_t)0x00001000)          /*!< Indicates that SRC12 was the source of the Hard Reset */
N/* RSTCTL_HARDRESET_STAT[SRC13] Bits */
N#define RSTCTL_HARDRESET_STAT_SRC13_OFS          (13)                            /*!< SRC13 Bit Offset */
N#define RSTCTL_HARDRESET_STAT_SRC13              ((uint32_t)0x00002000)          /*!< Indicates that SRC13 was the source of the Hard Reset */
N/* RSTCTL_HARDRESET_STAT[SRC14] Bits */
N#define RSTCTL_HARDRESET_STAT_SRC14_OFS          (14)                            /*!< SRC14 Bit Offset */
N#define RSTCTL_HARDRESET_STAT_SRC14              ((uint32_t)0x00004000)          /*!< Indicates that SRC14 was the source of the Hard Reset */
N/* RSTCTL_HARDRESET_STAT[SRC15] Bits */
N#define RSTCTL_HARDRESET_STAT_SRC15_OFS          (15)                            /*!< SRC15 Bit Offset */
N#define RSTCTL_HARDRESET_STAT_SRC15              ((uint32_t)0x00008000)          /*!< Indicates that SRC15 was the source of the Hard Reset */
N/* RSTCTL_HARDRESET_CLR[SRC0] Bits */
N#define RSTCTL_HARDRESET_CLR_SRC0_OFS            ( 0)                            /*!< SRC0 Bit Offset */
N#define RSTCTL_HARDRESET_CLR_SRC0                ((uint32_t)0x00000001)          /*!< Write 1 clears the corresponding bit in the RSTCTL_HARDRESET_STAT */
N/* RSTCTL_HARDRESET_CLR[SRC1] Bits */
N#define RSTCTL_HARDRESET_CLR_SRC1_OFS            ( 1)                            /*!< SRC1 Bit Offset */
N#define RSTCTL_HARDRESET_CLR_SRC1                ((uint32_t)0x00000002)          /*!< Write 1 clears the corresponding bit in the RSTCTL_HARDRESET_STAT */
N/* RSTCTL_HARDRESET_CLR[SRC2] Bits */
N#define RSTCTL_HARDRESET_CLR_SRC2_OFS            ( 2)                            /*!< SRC2 Bit Offset */
N#define RSTCTL_HARDRESET_CLR_SRC2                ((uint32_t)0x00000004)          /*!< Write 1 clears the corresponding bit in the RSTCTL_HARDRESET_STAT */
N/* RSTCTL_HARDRESET_CLR[SRC3] Bits */
N#define RSTCTL_HARDRESET_CLR_SRC3_OFS            ( 3)                            /*!< SRC3 Bit Offset */
N#define RSTCTL_HARDRESET_CLR_SRC3                ((uint32_t)0x00000008)          /*!< Write 1 clears the corresponding bit in the RSTCTL_HARDRESET_STAT */
N/* RSTCTL_HARDRESET_CLR[SRC4] Bits */
N#define RSTCTL_HARDRESET_CLR_SRC4_OFS            ( 4)                            /*!< SRC4 Bit Offset */
N#define RSTCTL_HARDRESET_CLR_SRC4                ((uint32_t)0x00000010)          /*!< Write 1 clears the corresponding bit in the RSTCTL_HARDRESET_STAT */
N/* RSTCTL_HARDRESET_CLR[SRC5] Bits */
N#define RSTCTL_HARDRESET_CLR_SRC5_OFS            ( 5)                            /*!< SRC5 Bit Offset */
N#define RSTCTL_HARDRESET_CLR_SRC5                ((uint32_t)0x00000020)          /*!< Write 1 clears the corresponding bit in the RSTCTL_HARDRESET_STAT */
N/* RSTCTL_HARDRESET_CLR[SRC6] Bits */
N#define RSTCTL_HARDRESET_CLR_SRC6_OFS            ( 6)                            /*!< SRC6 Bit Offset */
N#define RSTCTL_HARDRESET_CLR_SRC6                ((uint32_t)0x00000040)          /*!< Write 1 clears the corresponding bit in the RSTCTL_HARDRESET_STAT */
N/* RSTCTL_HARDRESET_CLR[SRC7] Bits */
N#define RSTCTL_HARDRESET_CLR_SRC7_OFS            ( 7)                            /*!< SRC7 Bit Offset */
N#define RSTCTL_HARDRESET_CLR_SRC7                ((uint32_t)0x00000080)          /*!< Write 1 clears the corresponding bit in the RSTCTL_HARDRESET_STAT */
N/* RSTCTL_HARDRESET_CLR[SRC8] Bits */
N#define RSTCTL_HARDRESET_CLR_SRC8_OFS            ( 8)                            /*!< SRC8 Bit Offset */
N#define RSTCTL_HARDRESET_CLR_SRC8                ((uint32_t)0x00000100)          /*!< Write 1 clears the corresponding bit in the RSTCTL_HARDRESET_STAT */
N/* RSTCTL_HARDRESET_CLR[SRC9] Bits */
N#define RSTCTL_HARDRESET_CLR_SRC9_OFS            ( 9)                            /*!< SRC9 Bit Offset */
N#define RSTCTL_HARDRESET_CLR_SRC9                ((uint32_t)0x00000200)          /*!< Write 1 clears the corresponding bit in the RSTCTL_HARDRESET_STAT */
N/* RSTCTL_HARDRESET_CLR[SRC10] Bits */
N#define RSTCTL_HARDRESET_CLR_SRC10_OFS           (10)                            /*!< SRC10 Bit Offset */
N#define RSTCTL_HARDRESET_CLR_SRC10               ((uint32_t)0x00000400)          /*!< Write 1 clears the corresponding bit in the RSTCTL_HARDRESET_STAT */
N/* RSTCTL_HARDRESET_CLR[SRC11] Bits */
N#define RSTCTL_HARDRESET_CLR_SRC11_OFS           (11)                            /*!< SRC11 Bit Offset */
N#define RSTCTL_HARDRESET_CLR_SRC11               ((uint32_t)0x00000800)          /*!< Write 1 clears the corresponding bit in the RSTCTL_HARDRESET_STAT */
N/* RSTCTL_HARDRESET_CLR[SRC12] Bits */
N#define RSTCTL_HARDRESET_CLR_SRC12_OFS           (12)                            /*!< SRC12 Bit Offset */
N#define RSTCTL_HARDRESET_CLR_SRC12               ((uint32_t)0x00001000)          /*!< Write 1 clears the corresponding bit in the RSTCTL_HARDRESET_STAT */
N/* RSTCTL_HARDRESET_CLR[SRC13] Bits */
N#define RSTCTL_HARDRESET_CLR_SRC13_OFS           (13)                            /*!< SRC13 Bit Offset */
N#define RSTCTL_HARDRESET_CLR_SRC13               ((uint32_t)0x00002000)          /*!< Write 1 clears the corresponding bit in the RSTCTL_HARDRESET_STAT */
N/* RSTCTL_HARDRESET_CLR[SRC14] Bits */
N#define RSTCTL_HARDRESET_CLR_SRC14_OFS           (14)                            /*!< SRC14 Bit Offset */
N#define RSTCTL_HARDRESET_CLR_SRC14               ((uint32_t)0x00004000)          /*!< Write 1 clears the corresponding bit in the RSTCTL_HARDRESET_STAT */
N/* RSTCTL_HARDRESET_CLR[SRC15] Bits */
N#define RSTCTL_HARDRESET_CLR_SRC15_OFS           (15)                            /*!< SRC15 Bit Offset */
N#define RSTCTL_HARDRESET_CLR_SRC15               ((uint32_t)0x00008000)          /*!< Write 1 clears the corresponding bit in the RSTCTL_HRDRESETSTAT_REG */
N/* RSTCTL_HARDRESET_SET[SRC0] Bits */
N#define RSTCTL_HARDRESET_SET_SRC0_OFS            ( 0)                            /*!< SRC0 Bit Offset */
N#define RSTCTL_HARDRESET_SET_SRC0                ((uint32_t)0x00000001)          /*!< Write 1 sets the corresponding bit in the RSTCTL_HARDRESET_STAT (and  */
N                                                                                 /* initiates a Hard Reset) */
N/* RSTCTL_HARDRESET_SET[SRC1] Bits */
N#define RSTCTL_HARDRESET_SET_SRC1_OFS            ( 1)                            /*!< SRC1 Bit Offset */
N#define RSTCTL_HARDRESET_SET_SRC1                ((uint32_t)0x00000002)          /*!< Write 1 sets the corresponding bit in the RSTCTL_HARDRESET_STAT (and  */
N                                                                                 /* initiates a Hard Reset) */
N/* RSTCTL_HARDRESET_SET[SRC2] Bits */
N#define RSTCTL_HARDRESET_SET_SRC2_OFS            ( 2)                            /*!< SRC2 Bit Offset */
N#define RSTCTL_HARDRESET_SET_SRC2                ((uint32_t)0x00000004)          /*!< Write 1 sets the corresponding bit in the RSTCTL_HARDRESET_STAT (and  */
N                                                                                 /* initiates a Hard Reset) */
N/* RSTCTL_HARDRESET_SET[SRC3] Bits */
N#define RSTCTL_HARDRESET_SET_SRC3_OFS            ( 3)                            /*!< SRC3 Bit Offset */
N#define RSTCTL_HARDRESET_SET_SRC3                ((uint32_t)0x00000008)          /*!< Write 1 sets the corresponding bit in the RSTCTL_HARDRESET_STAT (and  */
N                                                                                 /* initiates a Hard Reset) */
N/* RSTCTL_HARDRESET_SET[SRC4] Bits */
N#define RSTCTL_HARDRESET_SET_SRC4_OFS            ( 4)                            /*!< SRC4 Bit Offset */
N#define RSTCTL_HARDRESET_SET_SRC4                ((uint32_t)0x00000010)          /*!< Write 1 sets the corresponding bit in the RSTCTL_HARDRESET_STAT (and  */
N                                                                                 /* initiates a Hard Reset) */
N/* RSTCTL_HARDRESET_SET[SRC5] Bits */
N#define RSTCTL_HARDRESET_SET_SRC5_OFS            ( 5)                            /*!< SRC5 Bit Offset */
N#define RSTCTL_HARDRESET_SET_SRC5                ((uint32_t)0x00000020)          /*!< Write 1 sets the corresponding bit in the RSTCTL_HARDRESET_STAT (and  */
N                                                                                 /* initiates a Hard Reset) */
N/* RSTCTL_HARDRESET_SET[SRC6] Bits */
N#define RSTCTL_HARDRESET_SET_SRC6_OFS            ( 6)                            /*!< SRC6 Bit Offset */
N#define RSTCTL_HARDRESET_SET_SRC6                ((uint32_t)0x00000040)          /*!< Write 1 sets the corresponding bit in the RSTCTL_HARDRESET_STAT (and  */
N                                                                                 /* initiates a Hard Reset) */
N/* RSTCTL_HARDRESET_SET[SRC7] Bits */
N#define RSTCTL_HARDRESET_SET_SRC7_OFS            ( 7)                            /*!< SRC7 Bit Offset */
N#define RSTCTL_HARDRESET_SET_SRC7                ((uint32_t)0x00000080)          /*!< Write 1 sets the corresponding bit in the RSTCTL_HARDRESET_STAT (and  */
N                                                                                 /* initiates a Hard Reset) */
N/* RSTCTL_HARDRESET_SET[SRC8] Bits */
N#define RSTCTL_HARDRESET_SET_SRC8_OFS            ( 8)                            /*!< SRC8 Bit Offset */
N#define RSTCTL_HARDRESET_SET_SRC8                ((uint32_t)0x00000100)          /*!< Write 1 sets the corresponding bit in the RSTCTL_HARDRESET_STAT (and  */
N                                                                                 /* initiates a Hard Reset) */
N/* RSTCTL_HARDRESET_SET[SRC9] Bits */
N#define RSTCTL_HARDRESET_SET_SRC9_OFS            ( 9)                            /*!< SRC9 Bit Offset */
N#define RSTCTL_HARDRESET_SET_SRC9                ((uint32_t)0x00000200)          /*!< Write 1 sets the corresponding bit in the RSTCTL_HARDRESET_STAT (and  */
N                                                                                 /* initiates a Hard Reset) */
N/* RSTCTL_HARDRESET_SET[SRC10] Bits */
N#define RSTCTL_HARDRESET_SET_SRC10_OFS           (10)                            /*!< SRC10 Bit Offset */
N#define RSTCTL_HARDRESET_SET_SRC10               ((uint32_t)0x00000400)          /*!< Write 1 sets the corresponding bit in the RSTCTL_HARDRESET_STAT (and  */
N                                                                                 /* initiates a Hard Reset) */
N/* RSTCTL_HARDRESET_SET[SRC11] Bits */
N#define RSTCTL_HARDRESET_SET_SRC11_OFS           (11)                            /*!< SRC11 Bit Offset */
N#define RSTCTL_HARDRESET_SET_SRC11               ((uint32_t)0x00000800)          /*!< Write 1 sets the corresponding bit in the RSTCTL_HARDRESET_STAT (and  */
N                                                                                 /* initiates a Hard Reset) */
N/* RSTCTL_HARDRESET_SET[SRC12] Bits */
N#define RSTCTL_HARDRESET_SET_SRC12_OFS           (12)                            /*!< SRC12 Bit Offset */
N#define RSTCTL_HARDRESET_SET_SRC12               ((uint32_t)0x00001000)          /*!< Write 1 sets the corresponding bit in the RSTCTL_HARDRESET_STAT (and  */
N                                                                                 /* initiates a Hard Reset) */
N/* RSTCTL_HARDRESET_SET[SRC13] Bits */
N#define RSTCTL_HARDRESET_SET_SRC13_OFS           (13)                            /*!< SRC13 Bit Offset */
N#define RSTCTL_HARDRESET_SET_SRC13               ((uint32_t)0x00002000)          /*!< Write 1 sets the corresponding bit in the RSTCTL_HARDRESET_STAT (and  */
N                                                                                 /* initiates a Hard Reset) */
N/* RSTCTL_HARDRESET_SET[SRC14] Bits */
N#define RSTCTL_HARDRESET_SET_SRC14_OFS           (14)                            /*!< SRC14 Bit Offset */
N#define RSTCTL_HARDRESET_SET_SRC14               ((uint32_t)0x00004000)          /*!< Write 1 sets the corresponding bit in the RSTCTL_HARDRESET_STAT (and  */
N                                                                                 /* initiates a Hard Reset) */
N/* RSTCTL_HARDRESET_SET[SRC15] Bits */
N#define RSTCTL_HARDRESET_SET_SRC15_OFS           (15)                            /*!< SRC15 Bit Offset */
N#define RSTCTL_HARDRESET_SET_SRC15               ((uint32_t)0x00008000)          /*!< Write 1 sets the corresponding bit in the RSTCTL_HARDRESET_STAT (and  */
N                                                                                 /* initiates a Hard Reset) */
N/* RSTCTL_SOFTRESET_STAT[SRC0] Bits */
N#define RSTCTL_SOFTRESET_STAT_SRC0_OFS           ( 0)                            /*!< SRC0 Bit Offset */
N#define RSTCTL_SOFTRESET_STAT_SRC0               ((uint32_t)0x00000001)          /*!< If 1, indicates that SRC0 was the source of the Soft Reset */
N/* RSTCTL_SOFTRESET_STAT[SRC1] Bits */
N#define RSTCTL_SOFTRESET_STAT_SRC1_OFS           ( 1)                            /*!< SRC1 Bit Offset */
N#define RSTCTL_SOFTRESET_STAT_SRC1               ((uint32_t)0x00000002)          /*!< If 1, indicates that SRC1 was the source of the Soft Reset */
N/* RSTCTL_SOFTRESET_STAT[SRC2] Bits */
N#define RSTCTL_SOFTRESET_STAT_SRC2_OFS           ( 2)                            /*!< SRC2 Bit Offset */
N#define RSTCTL_SOFTRESET_STAT_SRC2               ((uint32_t)0x00000004)          /*!< If 1, indicates that SRC2 was the source of the Soft Reset */
N/* RSTCTL_SOFTRESET_STAT[SRC3] Bits */
N#define RSTCTL_SOFTRESET_STAT_SRC3_OFS           ( 3)                            /*!< SRC3 Bit Offset */
N#define RSTCTL_SOFTRESET_STAT_SRC3               ((uint32_t)0x00000008)          /*!< If 1, indicates that SRC3 was the source of the Soft Reset */
N/* RSTCTL_SOFTRESET_STAT[SRC4] Bits */
N#define RSTCTL_SOFTRESET_STAT_SRC4_OFS           ( 4)                            /*!< SRC4 Bit Offset */
N#define RSTCTL_SOFTRESET_STAT_SRC4               ((uint32_t)0x00000010)          /*!< If 1, indicates that SRC4 was the source of the Soft Reset */
N/* RSTCTL_SOFTRESET_STAT[SRC5] Bits */
N#define RSTCTL_SOFTRESET_STAT_SRC5_OFS           ( 5)                            /*!< SRC5 Bit Offset */
N#define RSTCTL_SOFTRESET_STAT_SRC5               ((uint32_t)0x00000020)          /*!< If 1, indicates that SRC5 was the source of the Soft Reset */
N/* RSTCTL_SOFTRESET_STAT[SRC6] Bits */
N#define RSTCTL_SOFTRESET_STAT_SRC6_OFS           ( 6)                            /*!< SRC6 Bit Offset */
N#define RSTCTL_SOFTRESET_STAT_SRC6               ((uint32_t)0x00000040)          /*!< If 1, indicates that SRC6 was the source of the Soft Reset */
N/* RSTCTL_SOFTRESET_STAT[SRC7] Bits */
N#define RSTCTL_SOFTRESET_STAT_SRC7_OFS           ( 7)                            /*!< SRC7 Bit Offset */
N#define RSTCTL_SOFTRESET_STAT_SRC7               ((uint32_t)0x00000080)          /*!< If 1, indicates that SRC7 was the source of the Soft Reset */
N/* RSTCTL_SOFTRESET_STAT[SRC8] Bits */
N#define RSTCTL_SOFTRESET_STAT_SRC8_OFS           ( 8)                            /*!< SRC8 Bit Offset */
N#define RSTCTL_SOFTRESET_STAT_SRC8               ((uint32_t)0x00000100)          /*!< If 1, indicates that SRC8 was the source of the Soft Reset */
N/* RSTCTL_SOFTRESET_STAT[SRC9] Bits */
N#define RSTCTL_SOFTRESET_STAT_SRC9_OFS           ( 9)                            /*!< SRC9 Bit Offset */
N#define RSTCTL_SOFTRESET_STAT_SRC9               ((uint32_t)0x00000200)          /*!< If 1, indicates that SRC9 was the source of the Soft Reset */
N/* RSTCTL_SOFTRESET_STAT[SRC10] Bits */
N#define RSTCTL_SOFTRESET_STAT_SRC10_OFS          (10)                            /*!< SRC10 Bit Offset */
N#define RSTCTL_SOFTRESET_STAT_SRC10              ((uint32_t)0x00000400)          /*!< If 1, indicates that SRC10 was the source of the Soft Reset */
N/* RSTCTL_SOFTRESET_STAT[SRC11] Bits */
N#define RSTCTL_SOFTRESET_STAT_SRC11_OFS          (11)                            /*!< SRC11 Bit Offset */
N#define RSTCTL_SOFTRESET_STAT_SRC11              ((uint32_t)0x00000800)          /*!< If 1, indicates that SRC11 was the source of the Soft Reset */
N/* RSTCTL_SOFTRESET_STAT[SRC12] Bits */
N#define RSTCTL_SOFTRESET_STAT_SRC12_OFS          (12)                            /*!< SRC12 Bit Offset */
N#define RSTCTL_SOFTRESET_STAT_SRC12              ((uint32_t)0x00001000)          /*!< If 1, indicates that SRC12 was the source of the Soft Reset */
N/* RSTCTL_SOFTRESET_STAT[SRC13] Bits */
N#define RSTCTL_SOFTRESET_STAT_SRC13_OFS          (13)                            /*!< SRC13 Bit Offset */
N#define RSTCTL_SOFTRESET_STAT_SRC13              ((uint32_t)0x00002000)          /*!< If 1, indicates that SRC13 was the source of the Soft Reset */
N/* RSTCTL_SOFTRESET_STAT[SRC14] Bits */
N#define RSTCTL_SOFTRESET_STAT_SRC14_OFS          (14)                            /*!< SRC14 Bit Offset */
N#define RSTCTL_SOFTRESET_STAT_SRC14              ((uint32_t)0x00004000)          /*!< If 1, indicates that SRC14 was the source of the Soft Reset */
N/* RSTCTL_SOFTRESET_STAT[SRC15] Bits */
N#define RSTCTL_SOFTRESET_STAT_SRC15_OFS          (15)                            /*!< SRC15 Bit Offset */
N#define RSTCTL_SOFTRESET_STAT_SRC15              ((uint32_t)0x00008000)          /*!< If 1, indicates that SRC15 was the source of the Soft Reset */
N/* RSTCTL_SOFTRESET_CLR[SRC0] Bits */
N#define RSTCTL_SOFTRESET_CLR_SRC0_OFS            ( 0)                            /*!< SRC0 Bit Offset */
N#define RSTCTL_SOFTRESET_CLR_SRC0                ((uint32_t)0x00000001)          /*!< Write 1 clears the corresponding bit in the RSTCTL_SOFTRESET_STAT */
N/* RSTCTL_SOFTRESET_CLR[SRC1] Bits */
N#define RSTCTL_SOFTRESET_CLR_SRC1_OFS            ( 1)                            /*!< SRC1 Bit Offset */
N#define RSTCTL_SOFTRESET_CLR_SRC1                ((uint32_t)0x00000002)          /*!< Write 1 clears the corresponding bit in the RSTCTL_SOFTRESET_STAT */
N/* RSTCTL_SOFTRESET_CLR[SRC2] Bits */
N#define RSTCTL_SOFTRESET_CLR_SRC2_OFS            ( 2)                            /*!< SRC2 Bit Offset */
N#define RSTCTL_SOFTRESET_CLR_SRC2                ((uint32_t)0x00000004)          /*!< Write 1 clears the corresponding bit in the RSTCTL_SOFTRESET_STAT */
N/* RSTCTL_SOFTRESET_CLR[SRC3] Bits */
N#define RSTCTL_SOFTRESET_CLR_SRC3_OFS            ( 3)                            /*!< SRC3 Bit Offset */
N#define RSTCTL_SOFTRESET_CLR_SRC3                ((uint32_t)0x00000008)          /*!< Write 1 clears the corresponding bit in the RSTCTL_SOFTRESET_STAT */
N/* RSTCTL_SOFTRESET_CLR[SRC4] Bits */
N#define RSTCTL_SOFTRESET_CLR_SRC4_OFS            ( 4)                            /*!< SRC4 Bit Offset */
N#define RSTCTL_SOFTRESET_CLR_SRC4                ((uint32_t)0x00000010)          /*!< Write 1 clears the corresponding bit in the RSTCTL_SOFTRESET_STAT */
N/* RSTCTL_SOFTRESET_CLR[SRC5] Bits */
N#define RSTCTL_SOFTRESET_CLR_SRC5_OFS            ( 5)                            /*!< SRC5 Bit Offset */
N#define RSTCTL_SOFTRESET_CLR_SRC5                ((uint32_t)0x00000020)          /*!< Write 1 clears the corresponding bit in the RSTCTL_SOFTRESET_STAT */
N/* RSTCTL_SOFTRESET_CLR[SRC6] Bits */
N#define RSTCTL_SOFTRESET_CLR_SRC6_OFS            ( 6)                            /*!< SRC6 Bit Offset */
N#define RSTCTL_SOFTRESET_CLR_SRC6                ((uint32_t)0x00000040)          /*!< Write 1 clears the corresponding bit in the RSTCTL_SOFTRESET_STAT */
N/* RSTCTL_SOFTRESET_CLR[SRC7] Bits */
N#define RSTCTL_SOFTRESET_CLR_SRC7_OFS            ( 7)                            /*!< SRC7 Bit Offset */
N#define RSTCTL_SOFTRESET_CLR_SRC7                ((uint32_t)0x00000080)          /*!< Write 1 clears the corresponding bit in the RSTCTL_SOFTRESET_STAT */
N/* RSTCTL_SOFTRESET_CLR[SRC8] Bits */
N#define RSTCTL_SOFTRESET_CLR_SRC8_OFS            ( 8)                            /*!< SRC8 Bit Offset */
N#define RSTCTL_SOFTRESET_CLR_SRC8                ((uint32_t)0x00000100)          /*!< Write 1 clears the corresponding bit in the RSTCTL_SOFTRESET_STAT */
N/* RSTCTL_SOFTRESET_CLR[SRC9] Bits */
N#define RSTCTL_SOFTRESET_CLR_SRC9_OFS            ( 9)                            /*!< SRC9 Bit Offset */
N#define RSTCTL_SOFTRESET_CLR_SRC9                ((uint32_t)0x00000200)          /*!< Write 1 clears the corresponding bit in the RSTCTL_SOFTRESET_STAT */
N/* RSTCTL_SOFTRESET_CLR[SRC10] Bits */
N#define RSTCTL_SOFTRESET_CLR_SRC10_OFS           (10)                            /*!< SRC10 Bit Offset */
N#define RSTCTL_SOFTRESET_CLR_SRC10               ((uint32_t)0x00000400)          /*!< Write 1 clears the corresponding bit in the RSTCTL_SOFTRESET_STAT */
N/* RSTCTL_SOFTRESET_CLR[SRC11] Bits */
N#define RSTCTL_SOFTRESET_CLR_SRC11_OFS           (11)                            /*!< SRC11 Bit Offset */
N#define RSTCTL_SOFTRESET_CLR_SRC11               ((uint32_t)0x00000800)          /*!< Write 1 clears the corresponding bit in the RSTCTL_SOFTRESET_STAT */
N/* RSTCTL_SOFTRESET_CLR[SRC12] Bits */
N#define RSTCTL_SOFTRESET_CLR_SRC12_OFS           (12)                            /*!< SRC12 Bit Offset */
N#define RSTCTL_SOFTRESET_CLR_SRC12               ((uint32_t)0x00001000)          /*!< Write 1 clears the corresponding bit in the RSTCTL_SOFTRESET_STAT */
N/* RSTCTL_SOFTRESET_CLR[SRC13] Bits */
N#define RSTCTL_SOFTRESET_CLR_SRC13_OFS           (13)                            /*!< SRC13 Bit Offset */
N#define RSTCTL_SOFTRESET_CLR_SRC13               ((uint32_t)0x00002000)          /*!< Write 1 clears the corresponding bit in the RSTCTL_SOFTRESET_STAT */
N/* RSTCTL_SOFTRESET_CLR[SRC14] Bits */
N#define RSTCTL_SOFTRESET_CLR_SRC14_OFS           (14)                            /*!< SRC14 Bit Offset */
N#define RSTCTL_SOFTRESET_CLR_SRC14               ((uint32_t)0x00004000)          /*!< Write 1 clears the corresponding bit in the RSTCTL_SOFTRESET_STAT */
N/* RSTCTL_SOFTRESET_CLR[SRC15] Bits */
N#define RSTCTL_SOFTRESET_CLR_SRC15_OFS           (15)                            /*!< SRC15 Bit Offset */
N#define RSTCTL_SOFTRESET_CLR_SRC15               ((uint32_t)0x00008000)          /*!< Write 1 clears the corresponding bit in the RSTCTL_SOFTRESET_STAT */
N/* RSTCTL_SOFTRESET_SET[SRC0] Bits */
N#define RSTCTL_SOFTRESET_SET_SRC0_OFS            ( 0)                            /*!< SRC0 Bit Offset */
N#define RSTCTL_SOFTRESET_SET_SRC0                ((uint32_t)0x00000001)          /*!< Write 1 sets the corresponding bit in the RSTCTL_SOFTRESET_STAT (and  */
N                                                                                 /* initiates a Soft Reset) */
N/* RSTCTL_SOFTRESET_SET[SRC1] Bits */
N#define RSTCTL_SOFTRESET_SET_SRC1_OFS            ( 1)                            /*!< SRC1 Bit Offset */
N#define RSTCTL_SOFTRESET_SET_SRC1                ((uint32_t)0x00000002)          /*!< Write 1 sets the corresponding bit in the RSTCTL_SOFTRESET_STAT (and  */
N                                                                                 /* initiates a Soft Reset) */
N/* RSTCTL_SOFTRESET_SET[SRC2] Bits */
N#define RSTCTL_SOFTRESET_SET_SRC2_OFS            ( 2)                            /*!< SRC2 Bit Offset */
N#define RSTCTL_SOFTRESET_SET_SRC2                ((uint32_t)0x00000004)          /*!< Write 1 sets the corresponding bit in the RSTCTL_SOFTRESET_STAT (and  */
N                                                                                 /* initiates a Soft Reset) */
N/* RSTCTL_SOFTRESET_SET[SRC3] Bits */
N#define RSTCTL_SOFTRESET_SET_SRC3_OFS            ( 3)                            /*!< SRC3 Bit Offset */
N#define RSTCTL_SOFTRESET_SET_SRC3                ((uint32_t)0x00000008)          /*!< Write 1 sets the corresponding bit in the RSTCTL_SOFTRESET_STAT (and  */
N                                                                                 /* initiates a Soft Reset) */
N/* RSTCTL_SOFTRESET_SET[SRC4] Bits */
N#define RSTCTL_SOFTRESET_SET_SRC4_OFS            ( 4)                            /*!< SRC4 Bit Offset */
N#define RSTCTL_SOFTRESET_SET_SRC4                ((uint32_t)0x00000010)          /*!< Write 1 sets the corresponding bit in the RSTCTL_SOFTRESET_STAT (and  */
N                                                                                 /* initiates a Soft Reset) */
N/* RSTCTL_SOFTRESET_SET[SRC5] Bits */
N#define RSTCTL_SOFTRESET_SET_SRC5_OFS            ( 5)                            /*!< SRC5 Bit Offset */
N#define RSTCTL_SOFTRESET_SET_SRC5                ((uint32_t)0x00000020)          /*!< Write 1 sets the corresponding bit in the RSTCTL_SOFTRESET_STAT (and  */
N                                                                                 /* initiates a Soft Reset) */
N/* RSTCTL_SOFTRESET_SET[SRC6] Bits */
N#define RSTCTL_SOFTRESET_SET_SRC6_OFS            ( 6)                            /*!< SRC6 Bit Offset */
N#define RSTCTL_SOFTRESET_SET_SRC6                ((uint32_t)0x00000040)          /*!< Write 1 sets the corresponding bit in the RSTCTL_SOFTRESET_STAT (and  */
N                                                                                 /* initiates a Soft Reset) */
N/* RSTCTL_SOFTRESET_SET[SRC7] Bits */
N#define RSTCTL_SOFTRESET_SET_SRC7_OFS            ( 7)                            /*!< SRC7 Bit Offset */
N#define RSTCTL_SOFTRESET_SET_SRC7                ((uint32_t)0x00000080)          /*!< Write 1 sets the corresponding bit in the RSTCTL_SOFTRESET_STAT (and  */
N                                                                                 /* initiates a Soft Reset) */
N/* RSTCTL_SOFTRESET_SET[SRC8] Bits */
N#define RSTCTL_SOFTRESET_SET_SRC8_OFS            ( 8)                            /*!< SRC8 Bit Offset */
N#define RSTCTL_SOFTRESET_SET_SRC8                ((uint32_t)0x00000100)          /*!< Write 1 sets the corresponding bit in the RSTCTL_SOFTRESET_STAT (and  */
N                                                                                 /* initiates a Soft Reset) */
N/* RSTCTL_SOFTRESET_SET[SRC9] Bits */
N#define RSTCTL_SOFTRESET_SET_SRC9_OFS            ( 9)                            /*!< SRC9 Bit Offset */
N#define RSTCTL_SOFTRESET_SET_SRC9                ((uint32_t)0x00000200)          /*!< Write 1 sets the corresponding bit in the RSTCTL_SOFTRESET_STAT (and  */
N                                                                                 /* initiates a Soft Reset) */
N/* RSTCTL_SOFTRESET_SET[SRC10] Bits */
N#define RSTCTL_SOFTRESET_SET_SRC10_OFS           (10)                            /*!< SRC10 Bit Offset */
N#define RSTCTL_SOFTRESET_SET_SRC10               ((uint32_t)0x00000400)          /*!< Write 1 sets the corresponding bit in the RSTCTL_SOFTRESET_STAT (and  */
N                                                                                 /* initiates a Soft Reset) */
N/* RSTCTL_SOFTRESET_SET[SRC11] Bits */
N#define RSTCTL_SOFTRESET_SET_SRC11_OFS           (11)                            /*!< SRC11 Bit Offset */
N#define RSTCTL_SOFTRESET_SET_SRC11               ((uint32_t)0x00000800)          /*!< Write 1 sets the corresponding bit in the RSTCTL_SOFTRESET_STAT (and  */
N                                                                                 /* initiates a Soft Reset) */
N/* RSTCTL_SOFTRESET_SET[SRC12] Bits */
N#define RSTCTL_SOFTRESET_SET_SRC12_OFS           (12)                            /*!< SRC12 Bit Offset */
N#define RSTCTL_SOFTRESET_SET_SRC12               ((uint32_t)0x00001000)          /*!< Write 1 sets the corresponding bit in the RSTCTL_SOFTRESET_STAT (and  */
N                                                                                 /* initiates a Soft Reset) */
N/* RSTCTL_SOFTRESET_SET[SRC13] Bits */
N#define RSTCTL_SOFTRESET_SET_SRC13_OFS           (13)                            /*!< SRC13 Bit Offset */
N#define RSTCTL_SOFTRESET_SET_SRC13               ((uint32_t)0x00002000)          /*!< Write 1 sets the corresponding bit in the RSTCTL_SOFTRESET_STAT (and  */
N                                                                                 /* initiates a Soft Reset) */
N/* RSTCTL_SOFTRESET_SET[SRC14] Bits */
N#define RSTCTL_SOFTRESET_SET_SRC14_OFS           (14)                            /*!< SRC14 Bit Offset */
N#define RSTCTL_SOFTRESET_SET_SRC14               ((uint32_t)0x00004000)          /*!< Write 1 sets the corresponding bit in the RSTCTL_SOFTRESET_STAT (and  */
N                                                                                 /* initiates a Soft Reset) */
N/* RSTCTL_SOFTRESET_SET[SRC15] Bits */
N#define RSTCTL_SOFTRESET_SET_SRC15_OFS           (15)                            /*!< SRC15 Bit Offset */
N#define RSTCTL_SOFTRESET_SET_SRC15               ((uint32_t)0x00008000)          /*!< Write 1 sets the corresponding bit in the RSTCTL_SOFTRESET_STAT (and  */
N                                                                                 /* initiates a Soft Reset) */
N/* RSTCTL_PSSRESET_STAT[SVSMH] Bits */
N#define RSTCTL_PSSRESET_STAT_SVSMH_OFS           ( 1)                            /*!< SVSMH Bit Offset */
N#define RSTCTL_PSSRESET_STAT_SVSMH               ((uint32_t)0x00000002)          /*!< Indicates if POR was caused by an SVSMH trip condition int the PSS */
N/* RSTCTL_PSSRESET_STAT[BGREF] Bits */
N#define RSTCTL_PSSRESET_STAT_BGREF_OFS           ( 2)                            /*!< BGREF Bit Offset */
N#define RSTCTL_PSSRESET_STAT_BGREF               ((uint32_t)0x00000004)          /*!< Indicates if POR was caused by a BGREF not okay condition in the PSS */
N/* RSTCTL_PSSRESET_STAT[VCCDET] Bits */
N#define RSTCTL_PSSRESET_STAT_VCCDET_OFS          ( 3)                            /*!< VCCDET Bit Offset */
N#define RSTCTL_PSSRESET_STAT_VCCDET              ((uint32_t)0x00000008)          /*!< Indicates if POR was caused by a VCCDET trip condition in the PSS */
N/* RSTCTL_PSSRESET_CLR[CLR] Bits */
N#define RSTCTL_PSSRESET_CLR_CLR_OFS              ( 0)                            /*!< CLR Bit Offset */
N#define RSTCTL_PSSRESET_CLR_CLR                  ((uint32_t)0x00000001)          /*!< Write 1 clears all PSS Reset Flags in the RSTCTL_PSSRESET_STAT */
N/* RSTCTL_PCMRESET_STAT[LPM35] Bits */
N#define RSTCTL_PCMRESET_STAT_LPM35_OFS           ( 0)                            /*!< LPM35 Bit Offset */
N#define RSTCTL_PCMRESET_STAT_LPM35               ((uint32_t)0x00000001)          /*!< Indicates if POR was caused by PCM due to an exit from LPM3.5 */
N/* RSTCTL_PCMRESET_STAT[LPM45] Bits */
N#define RSTCTL_PCMRESET_STAT_LPM45_OFS           ( 1)                            /*!< LPM45 Bit Offset */
N#define RSTCTL_PCMRESET_STAT_LPM45               ((uint32_t)0x00000002)          /*!< Indicates if POR was caused by PCM due to an exit from LPM4.5 */
N/* RSTCTL_PCMRESET_CLR[CLR] Bits */
N#define RSTCTL_PCMRESET_CLR_CLR_OFS              ( 0)                            /*!< CLR Bit Offset */
N#define RSTCTL_PCMRESET_CLR_CLR                  ((uint32_t)0x00000001)          /*!< Write 1 clears all PCM Reset Flags in the RSTCTL_PCMRESET_STAT */
N/* RSTCTL_PINRESET_STAT[RSTNMI] Bits */
N#define RSTCTL_PINRESET_STAT_RSTNMI_OFS          ( 0)                            /*!< RSTNMI Bit Offset */
N#define RSTCTL_PINRESET_STAT_RSTNMI              ((uint32_t)0x00000001)          /*!< POR was caused by RSTn/NMI pin based reset event */
N/* RSTCTL_PINRESET_CLR[CLR] Bits */
N#define RSTCTL_PINRESET_CLR_CLR_OFS              ( 0)                            /*!< CLR Bit Offset */
N#define RSTCTL_PINRESET_CLR_CLR                  ((uint32_t)0x00000001)          /*!< Write 1 clears the RSTn/NMI Pin Reset Flag in RSTCTL_PINRESET_STAT */
N/* RSTCTL_REBOOTRESET_STAT[REBOOT] Bits */
N#define RSTCTL_REBOOTRESET_STAT_REBOOT_OFS       ( 0)                            /*!< REBOOT Bit Offset */
N#define RSTCTL_REBOOTRESET_STAT_REBOOT           ((uint32_t)0x00000001)          /*!< Indicates if Reboot reset was caused by the SYSCTL module. */
N/* RSTCTL_REBOOTRESET_CLR[CLR] Bits */
N#define RSTCTL_REBOOTRESET_CLR_CLR_OFS           ( 0)                            /*!< CLR Bit Offset */
N#define RSTCTL_REBOOTRESET_CLR_CLR               ((uint32_t)0x00000001)          /*!< Write 1 clears the Reboot Reset Flag in RSTCTL_REBOOTRESET_STAT */
N/* RSTCTL_CSRESET_STAT[DCOR_SHT] Bits */
N#define RSTCTL_CSRESET_STAT_DCOR_SHT_OFS         ( 0)                            /*!< DCOR_SHT Bit Offset */
N#define RSTCTL_CSRESET_STAT_DCOR_SHT             ((uint32_t)0x00000001)          /*!< Indicates if POR was caused by DCO short circuit fault in the external  */
N                                                                                 /* resistor mode */
N/* RSTCTL_CSRESET_CLR[CLR] Bits */
N#define RSTCTL_CSRESET_CLR_CLR_OFS               ( 0)                            /*!< CLR Bit Offset */
N#define RSTCTL_CSRESET_CLR_CLR                   ((uint32_t)0x00000001)          /*!< Write 1 clears the DCOR_SHT Flag in RSTCTL_CSRESET_STAT as well as  */
N                                                                                 /* DCOR_SHTIFG flag in CSIFG register of clock system */
N/* Pre-defined bitfield values */
N#define RSTCTL_RESETREQ_RSTKEY_VAL                 ((uint32_t)0x00006900)          /*!< Key value to enable writes to bits 1-0 */
N
N
N/******************************************************************************
N* RTC_C Bits
N******************************************************************************/
N/* RTC_C_CTL0[RDYIFG] Bits */
N#define RTC_C_CTL0_RDYIFG_OFS                    ( 0)                            /*!< RTCRDYIFG Bit Offset */
N#define RTC_C_CTL0_RDYIFG                        ((uint16_t)0x0001)              /*!< Real-time clock ready interrupt flag */
N/* RTC_C_CTL0[AIFG] Bits */
N#define RTC_C_CTL0_AIFG_OFS                      ( 1)                            /*!< RTCAIFG Bit Offset */
N#define RTC_C_CTL0_AIFG                          ((uint16_t)0x0002)              /*!< Real-time clock alarm interrupt flag */
N/* RTC_C_CTL0[TEVIFG] Bits */
N#define RTC_C_CTL0_TEVIFG_OFS                    ( 2)                            /*!< RTCTEVIFG Bit Offset */
N#define RTC_C_CTL0_TEVIFG                        ((uint16_t)0x0004)              /*!< Real-time clock time event interrupt flag */
N/* RTC_C_CTL0[OFIFG] Bits */
N#define RTC_C_CTL0_OFIFG_OFS                     ( 3)                            /*!< RTCOFIFG Bit Offset */
N#define RTC_C_CTL0_OFIFG                         ((uint16_t)0x0008)              /*!< 32-kHz crystal oscillator fault interrupt flag */
N/* RTC_C_CTL0[RDYIE] Bits */
N#define RTC_C_CTL0_RDYIE_OFS                     ( 4)                            /*!< RTCRDYIE Bit Offset */
N#define RTC_C_CTL0_RDYIE                         ((uint16_t)0x0010)              /*!< Real-time clock ready interrupt enable */
N/* RTC_C_CTL0[AIE] Bits */
N#define RTC_C_CTL0_AIE_OFS                       ( 5)                            /*!< RTCAIE Bit Offset */
N#define RTC_C_CTL0_AIE                           ((uint16_t)0x0020)              /*!< Real-time clock alarm interrupt enable */
N/* RTC_C_CTL0[TEVIE] Bits */
N#define RTC_C_CTL0_TEVIE_OFS                     ( 6)                            /*!< RTCTEVIE Bit Offset */
N#define RTC_C_CTL0_TEVIE                         ((uint16_t)0x0040)              /*!< Real-time clock time event interrupt enable */
N/* RTC_C_CTL0[OFIE] Bits */
N#define RTC_C_CTL0_OFIE_OFS                      ( 7)                            /*!< RTCOFIE Bit Offset */
N#define RTC_C_CTL0_OFIE                          ((uint16_t)0x0080)              /*!< 32-kHz crystal oscillator fault interrupt enable */
N/* RTC_C_CTL0[KEY] Bits */
N#define RTC_C_CTL0_KEY_OFS                       ( 8)                            /*!< RTCKEY Bit Offset */
N#define RTC_C_CTL0_KEY_MASK                      ((uint16_t)0xFF00)              /*!< RTCKEY Bit Mask */
N/* RTC_C_CTL13[TEV] Bits */
N#define RTC_C_CTL13_TEV_OFS                      ( 0)                            /*!< RTCTEV Bit Offset */
N#define RTC_C_CTL13_TEV_MASK                     ((uint16_t)0x0003)              /*!< RTCTEV Bit Mask */
N#define RTC_C_CTL13_TEV0                         ((uint16_t)0x0001)              /*!< TEV Bit 0 */
N#define RTC_C_CTL13_TEV1                         ((uint16_t)0x0002)              /*!< TEV Bit 1 */
N#define RTC_C_CTL13_TEV_0                        ((uint16_t)0x0000)              /*!< Minute changed */
N#define RTC_C_CTL13_TEV_1                        ((uint16_t)0x0001)              /*!< Hour changed */
N#define RTC_C_CTL13_TEV_2                        ((uint16_t)0x0002)              /*!< Every day at midnight (00:00) */
N#define RTC_C_CTL13_TEV_3                        ((uint16_t)0x0003)              /*!< Every day at noon (12:00) */
N/* RTC_C_CTL13[SSEL] Bits */
N#define RTC_C_CTL13_SSEL_OFS                     ( 2)                            /*!< RTCSSEL Bit Offset */
N#define RTC_C_CTL13_SSEL_MASK                    ((uint16_t)0x000C)              /*!< RTCSSEL Bit Mask */
N#define RTC_C_CTL13_SSEL0                        ((uint16_t)0x0004)              /*!< SSEL Bit 0 */
N#define RTC_C_CTL13_SSEL1                        ((uint16_t)0x0008)              /*!< SSEL Bit 1 */
N#define RTC_C_CTL13_SSEL_0                       ((uint16_t)0x0000)              /*!< BCLK */
N#define RTC_C_CTL13_SSEL__BCLK                   ((uint16_t)0x0000)              /*!< BCLK */
N/* RTC_C_CTL13[RDY] Bits */
N#define RTC_C_CTL13_RDY_OFS                      ( 4)                            /*!< RTCRDY Bit Offset */
N#define RTC_C_CTL13_RDY                          ((uint16_t)0x0010)              /*!< Real-time clock ready */
N/* RTC_C_CTL13[MODE] Bits */
N#define RTC_C_CTL13_MODE_OFS                     ( 5)                            /*!< RTCMODE Bit Offset */
N#define RTC_C_CTL13_MODE                         ((uint16_t)0x0020)              
N/* RTC_C_CTL13[HOLD] Bits */
N#define RTC_C_CTL13_HOLD_OFS                     ( 6)                            /*!< RTCHOLD Bit Offset */
N#define RTC_C_CTL13_HOLD                         ((uint16_t)0x0040)              /*!< Real-time clock hold */
N/* RTC_C_CTL13[BCD] Bits */
N#define RTC_C_CTL13_BCD_OFS                      ( 7)                            /*!< RTCBCD Bit Offset */
N#define RTC_C_CTL13_BCD                          ((uint16_t)0x0080)              /*!< Real-time clock BCD select */
N/* RTC_C_CTL13[CALF] Bits */
N#define RTC_C_CTL13_CALF_OFS                     ( 8)                            /*!< RTCCALF Bit Offset */
N#define RTC_C_CTL13_CALF_MASK                    ((uint16_t)0x0300)              /*!< RTCCALF Bit Mask */
N#define RTC_C_CTL13_CALF0                        ((uint16_t)0x0100)              /*!< CALF Bit 0 */
N#define RTC_C_CTL13_CALF1                        ((uint16_t)0x0200)              /*!< CALF Bit 1 */
N#define RTC_C_CTL13_CALF_0                       ((uint16_t)0x0000)              /*!< No frequency output to RTCCLK pin */
N#define RTC_C_CTL13_CALF_1                       ((uint16_t)0x0100)              /*!< 512 Hz */
N#define RTC_C_CTL13_CALF_2                       ((uint16_t)0x0200)              /*!< 256 Hz */
N#define RTC_C_CTL13_CALF_3                       ((uint16_t)0x0300)              /*!< 1 Hz */
N#define RTC_C_CTL13_CALF__NONE                   ((uint16_t)0x0000)              /*!< No frequency output to RTCCLK pin */
N#define RTC_C_CTL13_CALF__512                    ((uint16_t)0x0100)              /*!< 512 Hz */
N#define RTC_C_CTL13_CALF__256                    ((uint16_t)0x0200)              /*!< 256 Hz */
N#define RTC_C_CTL13_CALF__1                      ((uint16_t)0x0300)              /*!< 1 Hz */
N/* RTC_C_OCAL[OCAL] Bits */
N#define RTC_C_OCAL_OCAL_OFS                      ( 0)                            /*!< RTCOCAL Bit Offset */
N#define RTC_C_OCAL_OCAL_MASK                     ((uint16_t)0x00FF)              /*!< RTCOCAL Bit Mask */
N/* RTC_C_OCAL[OCALS] Bits */
N#define RTC_C_OCAL_OCALS_OFS                     (15)                            /*!< RTCOCALS Bit Offset */
N#define RTC_C_OCAL_OCALS                         ((uint16_t)0x8000)              /*!< Real-time clock offset error calibration sign */
N/* RTC_C_TCMP[TCMPx] Bits */
N#define RTC_C_TCMP_TCMPX_OFS                     ( 0)                            /*!< RTCTCMP Bit Offset */
N#define RTC_C_TCMP_TCMPX_MASK                    ((uint16_t)0x00FF)              /*!< RTCTCMP Bit Mask */
N/* RTC_C_TCMP[TCOK] Bits */
N#define RTC_C_TCMP_TCOK_OFS                      (13)                            /*!< RTCTCOK Bit Offset */
N#define RTC_C_TCMP_TCOK                          ((uint16_t)0x2000)              /*!< Real-time clock temperature compensation write OK */
N/* RTC_C_TCMP[TCRDY] Bits */
N#define RTC_C_TCMP_TCRDY_OFS                     (14)                            /*!< RTCTCRDY Bit Offset */
N#define RTC_C_TCMP_TCRDY                         ((uint16_t)0x4000)              /*!< Real-time clock temperature compensation ready */
N/* RTC_C_TCMP[TCMPS] Bits */
N#define RTC_C_TCMP_TCMPS_OFS                     (15)                            /*!< RTCTCMPS Bit Offset */
N#define RTC_C_TCMP_TCMPS                         ((uint16_t)0x8000)              /*!< Real-time clock temperature compensation sign */
N/* RTC_C_PS0CTL[RT0PSIFG] Bits */
N#define RTC_C_PS0CTL_RT0PSIFG_OFS                ( 0)                            /*!< RT0PSIFG Bit Offset */
N#define RTC_C_PS0CTL_RT0PSIFG                    ((uint16_t)0x0001)              /*!< Prescale timer 0 interrupt flag */
N/* RTC_C_PS0CTL[RT0PSIE] Bits */
N#define RTC_C_PS0CTL_RT0PSIE_OFS                 ( 1)                            /*!< RT0PSIE Bit Offset */
N#define RTC_C_PS0CTL_RT0PSIE                     ((uint16_t)0x0002)              /*!< Prescale timer 0 interrupt enable */
N/* RTC_C_PS0CTL[RT0IP] Bits */
N#define RTC_C_PS0CTL_RT0IP_OFS                   ( 2)                            /*!< RT0IP Bit Offset */
N#define RTC_C_PS0CTL_RT0IP_MASK                  ((uint16_t)0x001C)              /*!< RT0IP Bit Mask */
N#define RTC_C_PS0CTL_RT0IP0                      ((uint16_t)0x0004)              /*!< RT0IP Bit 0 */
N#define RTC_C_PS0CTL_RT0IP1                      ((uint16_t)0x0008)              /*!< RT0IP Bit 1 */
N#define RTC_C_PS0CTL_RT0IP2                      ((uint16_t)0x0010)              /*!< RT0IP Bit 2 */
N#define RTC_C_PS0CTL_RT0IP_0                     ((uint16_t)0x0000)              /*!< Divide by 2 */
N#define RTC_C_PS0CTL_RT0IP_1                     ((uint16_t)0x0004)              /*!< Divide by 4 */
N#define RTC_C_PS0CTL_RT0IP_2                     ((uint16_t)0x0008)              /*!< Divide by 8 */
N#define RTC_C_PS0CTL_RT0IP_3                     ((uint16_t)0x000C)              /*!< Divide by 16 */
N#define RTC_C_PS0CTL_RT0IP_4                     ((uint16_t)0x0010)              /*!< Divide by 32 */
N#define RTC_C_PS0CTL_RT0IP_5                     ((uint16_t)0x0014)              /*!< Divide by 64 */
N#define RTC_C_PS0CTL_RT0IP_6                     ((uint16_t)0x0018)              /*!< Divide by 128 */
N#define RTC_C_PS0CTL_RT0IP_7                     ((uint16_t)0x001C)              /*!< Divide by 256 */
N#define RTC_C_PS0CTL_RT0IP__2                    ((uint16_t)0x0000)              /*!< Divide by 2 */
N#define RTC_C_PS0CTL_RT0IP__4                    ((uint16_t)0x0004)              /*!< Divide by 4 */
N#define RTC_C_PS0CTL_RT0IP__8                    ((uint16_t)0x0008)              /*!< Divide by 8 */
N#define RTC_C_PS0CTL_RT0IP__16                   ((uint16_t)0x000C)              /*!< Divide by 16 */
N#define RTC_C_PS0CTL_RT0IP__32                   ((uint16_t)0x0010)              /*!< Divide by 32 */
N#define RTC_C_PS0CTL_RT0IP__64                   ((uint16_t)0x0014)              /*!< Divide by 64 */
N#define RTC_C_PS0CTL_RT0IP__128                  ((uint16_t)0x0018)              /*!< Divide by 128 */
N#define RTC_C_PS0CTL_RT0IP__256                  ((uint16_t)0x001C)              /*!< Divide by 256 */
N/* RTC_C_PS1CTL[RT1PSIFG] Bits */
N#define RTC_C_PS1CTL_RT1PSIFG_OFS                ( 0)                            /*!< RT1PSIFG Bit Offset */
N#define RTC_C_PS1CTL_RT1PSIFG                    ((uint16_t)0x0001)              /*!< Prescale timer 1 interrupt flag */
N/* RTC_C_PS1CTL[RT1PSIE] Bits */
N#define RTC_C_PS1CTL_RT1PSIE_OFS                 ( 1)                            /*!< RT1PSIE Bit Offset */
N#define RTC_C_PS1CTL_RT1PSIE                     ((uint16_t)0x0002)              /*!< Prescale timer 1 interrupt enable */
N/* RTC_C_PS1CTL[RT1IP] Bits */
N#define RTC_C_PS1CTL_RT1IP_OFS                   ( 2)                            /*!< RT1IP Bit Offset */
N#define RTC_C_PS1CTL_RT1IP_MASK                  ((uint16_t)0x001C)              /*!< RT1IP Bit Mask */
N#define RTC_C_PS1CTL_RT1IP0                      ((uint16_t)0x0004)              /*!< RT1IP Bit 0 */
N#define RTC_C_PS1CTL_RT1IP1                      ((uint16_t)0x0008)              /*!< RT1IP Bit 1 */
N#define RTC_C_PS1CTL_RT1IP2                      ((uint16_t)0x0010)              /*!< RT1IP Bit 2 */
N#define RTC_C_PS1CTL_RT1IP_0                     ((uint16_t)0x0000)              /*!< Divide by 2 */
N#define RTC_C_PS1CTL_RT1IP_1                     ((uint16_t)0x0004)              /*!< Divide by 4 */
N#define RTC_C_PS1CTL_RT1IP_2                     ((uint16_t)0x0008)              /*!< Divide by 8 */
N#define RTC_C_PS1CTL_RT1IP_3                     ((uint16_t)0x000C)              /*!< Divide by 16 */
N#define RTC_C_PS1CTL_RT1IP_4                     ((uint16_t)0x0010)              /*!< Divide by 32 */
N#define RTC_C_PS1CTL_RT1IP_5                     ((uint16_t)0x0014)              /*!< Divide by 64 */
N#define RTC_C_PS1CTL_RT1IP_6                     ((uint16_t)0x0018)              /*!< Divide by 128 */
N#define RTC_C_PS1CTL_RT1IP_7                     ((uint16_t)0x001C)              /*!< Divide by 256 */
N#define RTC_C_PS1CTL_RT1IP__2                    ((uint16_t)0x0000)              /*!< Divide by 2 */
N#define RTC_C_PS1CTL_RT1IP__4                    ((uint16_t)0x0004)              /*!< Divide by 4 */
N#define RTC_C_PS1CTL_RT1IP__8                    ((uint16_t)0x0008)              /*!< Divide by 8 */
N#define RTC_C_PS1CTL_RT1IP__16                   ((uint16_t)0x000C)              /*!< Divide by 16 */
N#define RTC_C_PS1CTL_RT1IP__32                   ((uint16_t)0x0010)              /*!< Divide by 32 */
N#define RTC_C_PS1CTL_RT1IP__64                   ((uint16_t)0x0014)              /*!< Divide by 64 */
N#define RTC_C_PS1CTL_RT1IP__128                  ((uint16_t)0x0018)              /*!< Divide by 128 */
N#define RTC_C_PS1CTL_RT1IP__256                  ((uint16_t)0x001C)              /*!< Divide by 256 */
N/* RTC_C_PS[RT0PS] Bits */
N#define RTC_C_PS_RT0PS_OFS                       ( 0)                            /*!< RT0PS Bit Offset */
N#define RTC_C_PS_RT0PS_MASK                      ((uint16_t)0x00FF)              /*!< RT0PS Bit Mask */
N/* RTC_C_PS[RT1PS] Bits */
N#define RTC_C_PS_RT1PS_OFS                       ( 8)                            /*!< RT1PS Bit Offset */
N#define RTC_C_PS_RT1PS_MASK                      ((uint16_t)0xFF00)              /*!< RT1PS Bit Mask */
N/* RTC_C_TIM0[SEC] Bits */
N#define RTC_C_TIM0_SEC_OFS                       ( 0)                            /*!< Seconds Bit Offset */
N#define RTC_C_TIM0_SEC_MASK                      ((uint16_t)0x003F)              /*!< Seconds Bit Mask */
N/* RTC_C_TIM0[MIN] Bits */
N#define RTC_C_TIM0_MIN_OFS                       ( 8)                            /*!< Minutes Bit Offset */
N#define RTC_C_TIM0_MIN_MASK                      ((uint16_t)0x3F00)              /*!< Minutes Bit Mask */
N/* RTC_C_TIM0[SEC_LD] Bits */
N#define RTC_C_TIM0_SEC_LD_OFS                    ( 0)                            /*!< SecondsLowDigit Bit Offset */
N#define RTC_C_TIM0_SEC_LD_MASK                   ((uint16_t)0x000F)              /*!< SecondsLowDigit Bit Mask */
N/* RTC_C_TIM0[SEC_HD] Bits */
N#define RTC_C_TIM0_SEC_HD_OFS                    ( 4)                            /*!< SecondsHighDigit Bit Offset */
N#define RTC_C_TIM0_SEC_HD_MASK                   ((uint16_t)0x0070)              /*!< SecondsHighDigit Bit Mask */
N/* RTC_C_TIM0[MIN_LD] Bits */
N#define RTC_C_TIM0_MIN_LD_OFS                    ( 8)                            /*!< MinutesLowDigit Bit Offset */
N#define RTC_C_TIM0_MIN_LD_MASK                   ((uint16_t)0x0F00)              /*!< MinutesLowDigit Bit Mask */
N/* RTC_C_TIM0[MIN_HD] Bits */
N#define RTC_C_TIM0_MIN_HD_OFS                    (12)                            /*!< MinutesHighDigit Bit Offset */
N#define RTC_C_TIM0_MIN_HD_MASK                   ((uint16_t)0x7000)              /*!< MinutesHighDigit Bit Mask */
N/* RTC_C_TIM1[HOUR] Bits */
N#define RTC_C_TIM1_HOUR_OFS                      ( 0)                            /*!< Hours Bit Offset */
N#define RTC_C_TIM1_HOUR_MASK                     ((uint16_t)0x001F)              /*!< Hours Bit Mask */
N/* RTC_C_TIM1[DOW] Bits */
N#define RTC_C_TIM1_DOW_OFS                       ( 8)                            /*!< DayofWeek Bit Offset */
N#define RTC_C_TIM1_DOW_MASK                      ((uint16_t)0x0700)              /*!< DayofWeek Bit Mask */
N/* RTC_C_TIM1[HOUR_LD] Bits */
N#define RTC_C_TIM1_HOUR_LD_OFS                   ( 0)                            /*!< HoursLowDigit Bit Offset */
N#define RTC_C_TIM1_HOUR_LD_MASK                  ((uint16_t)0x000F)              /*!< HoursLowDigit Bit Mask */
N/* RTC_C_TIM1[HOUR_HD] Bits */
N#define RTC_C_TIM1_HOUR_HD_OFS                   ( 4)                            /*!< HoursHighDigit Bit Offset */
N#define RTC_C_TIM1_HOUR_HD_MASK                  ((uint16_t)0x0030)              /*!< HoursHighDigit Bit Mask */
N/* RTC_C_DATE[DAY] Bits */
N#define RTC_C_DATE_DAY_OFS                       ( 0)                            /*!< Day Bit Offset */
N#define RTC_C_DATE_DAY_MASK                      ((uint16_t)0x001F)              /*!< Day Bit Mask */
N/* RTC_C_DATE[MON] Bits */
N#define RTC_C_DATE_MON_OFS                       ( 8)                            /*!< Month Bit Offset */
N#define RTC_C_DATE_MON_MASK                      ((uint16_t)0x0F00)              /*!< Month Bit Mask */
N/* RTC_C_DATE[DAY_LD] Bits */
N#define RTC_C_DATE_DAY_LD_OFS                    ( 0)                            /*!< DayLowDigit Bit Offset */
N#define RTC_C_DATE_DAY_LD_MASK                   ((uint16_t)0x000F)              /*!< DayLowDigit Bit Mask */
N/* RTC_C_DATE[DAY_HD] Bits */
N#define RTC_C_DATE_DAY_HD_OFS                    ( 4)                            /*!< DayHighDigit Bit Offset */
N#define RTC_C_DATE_DAY_HD_MASK                   ((uint16_t)0x0030)              /*!< DayHighDigit Bit Mask */
N/* RTC_C_DATE[MON_LD] Bits */
N#define RTC_C_DATE_MON_LD_OFS                    ( 8)                            /*!< MonthLowDigit Bit Offset */
N#define RTC_C_DATE_MON_LD_MASK                   ((uint16_t)0x0F00)              /*!< MonthLowDigit Bit Mask */
N/* RTC_C_DATE[MON_HD] Bits */
N#define RTC_C_DATE_MON_HD_OFS                    (12)                            /*!< MonthHighDigit Bit Offset */
N#define RTC_C_DATE_MON_HD                        ((uint16_t)0x1000)              /*!< Month  high digit (0 or 1) */
N/* RTC_C_YEAR[YEAR_LB] Bits */
N#define RTC_C_YEAR_YEAR_LB_OFS                   ( 0)                            /*!< YearLowByte Bit Offset */
N#define RTC_C_YEAR_YEAR_LB_MASK                  ((uint16_t)0x00FF)              /*!< YearLowByte Bit Mask */
N/* RTC_C_YEAR[YEAR_HB] Bits */
N#define RTC_C_YEAR_YEAR_HB_OFS                   ( 8)                            /*!< YearHighByte Bit Offset */
N#define RTC_C_YEAR_YEAR_HB_MASK                  ((uint16_t)0x0F00)              /*!< YearHighByte Bit Mask */
N/* RTC_C_YEAR[YEAR] Bits */
N#define RTC_C_YEAR_YEAR_OFS                      ( 0)                            /*!< Year Bit Offset */
N#define RTC_C_YEAR_YEAR_MASK                     ((uint16_t)0x000F)              /*!< Year Bit Mask */
N/* RTC_C_YEAR[DEC] Bits */
N#define RTC_C_YEAR_DEC_OFS                       ( 4)                            /*!< Decade Bit Offset */
N#define RTC_C_YEAR_DEC_MASK                      ((uint16_t)0x00F0)              /*!< Decade Bit Mask */
N/* RTC_C_YEAR[CENT_LD] Bits */
N#define RTC_C_YEAR_CENT_LD_OFS                   ( 8)                            /*!< CenturyLowDigit Bit Offset */
N#define RTC_C_YEAR_CENT_LD_MASK                  ((uint16_t)0x0F00)              /*!< CenturyLowDigit Bit Mask */
N/* RTC_C_YEAR[CENT_HD] Bits */
N#define RTC_C_YEAR_CENT_HD_OFS                   (12)                            /*!< CenturyHighDigit Bit Offset */
N#define RTC_C_YEAR_CENT_HD_MASK                  ((uint16_t)0x7000)              /*!< CenturyHighDigit Bit Mask */
N/* RTC_C_AMINHR[MIN] Bits */
N#define RTC_C_AMINHR_MIN_OFS                     ( 0)                            /*!< Minutes Bit Offset */
N#define RTC_C_AMINHR_MIN_MASK                    ((uint16_t)0x003F)              /*!< Minutes Bit Mask */
N/* RTC_C_AMINHR[MINAE] Bits */
N#define RTC_C_AMINHR_MINAE_OFS                   ( 7)                            /*!< MINAE Bit Offset */
N#define RTC_C_AMINHR_MINAE                       ((uint16_t)0x0080)              /*!< Alarm enable */
N/* RTC_C_AMINHR[HOUR] Bits */
N#define RTC_C_AMINHR_HOUR_OFS                    ( 8)                            /*!< Hours Bit Offset */
N#define RTC_C_AMINHR_HOUR_MASK                   ((uint16_t)0x1F00)              /*!< Hours Bit Mask */
N/* RTC_C_AMINHR[HOURAE] Bits */
N#define RTC_C_AMINHR_HOURAE_OFS                  (15)                            /*!< HOURAE Bit Offset */
N#define RTC_C_AMINHR_HOURAE                      ((uint16_t)0x8000)              /*!< Alarm enable */
N/* RTC_C_AMINHR[MIN_LD] Bits */
N#define RTC_C_AMINHR_MIN_LD_OFS                  ( 0)                            /*!< MinutesLowDigit Bit Offset */
N#define RTC_C_AMINHR_MIN_LD_MASK                 ((uint16_t)0x000F)              /*!< MinutesLowDigit Bit Mask */
N/* RTC_C_AMINHR[MIN_HD] Bits */
N#define RTC_C_AMINHR_MIN_HD_OFS                  ( 4)                            /*!< MinutesHighDigit Bit Offset */
N#define RTC_C_AMINHR_MIN_HD_MASK                 ((uint16_t)0x0070)              /*!< MinutesHighDigit Bit Mask */
N/* RTC_C_AMINHR[HOUR_LD] Bits */
N#define RTC_C_AMINHR_HOUR_LD_OFS                 ( 8)                            /*!< HoursLowDigit Bit Offset */
N#define RTC_C_AMINHR_HOUR_LD_MASK                ((uint16_t)0x0F00)              /*!< HoursLowDigit Bit Mask */
N/* RTC_C_AMINHR[HOUR_HD] Bits */
N#define RTC_C_AMINHR_HOUR_HD_OFS                 (12)                            /*!< HoursHighDigit Bit Offset */
N#define RTC_C_AMINHR_HOUR_HD_MASK                ((uint16_t)0x3000)              /*!< HoursHighDigit Bit Mask */
N/* RTC_C_ADOWDAY[DOW] Bits */
N#define RTC_C_ADOWDAY_DOW_OFS                    ( 0)                            /*!< DayofWeek Bit Offset */
N#define RTC_C_ADOWDAY_DOW_MASK                   ((uint16_t)0x0007)              /*!< DayofWeek Bit Mask */
N/* RTC_C_ADOWDAY[DOWAE] Bits */
N#define RTC_C_ADOWDAY_DOWAE_OFS                  ( 7)                            /*!< DOWAE Bit Offset */
N#define RTC_C_ADOWDAY_DOWAE                      ((uint16_t)0x0080)              /*!< Alarm enable */
N/* RTC_C_ADOWDAY[DAY] Bits */
N#define RTC_C_ADOWDAY_DAY_OFS                    ( 8)                            /*!< DayofMonth Bit Offset */
N#define RTC_C_ADOWDAY_DAY_MASK                   ((uint16_t)0x1F00)              /*!< DayofMonth Bit Mask */
N/* RTC_C_ADOWDAY[DAYAE] Bits */
N#define RTC_C_ADOWDAY_DAYAE_OFS                  (15)                            /*!< DAYAE Bit Offset */
N#define RTC_C_ADOWDAY_DAYAE                      ((uint16_t)0x8000)              /*!< Alarm enable */
N/* RTC_C_ADOWDAY[DAY_LD] Bits */
N#define RTC_C_ADOWDAY_DAY_LD_OFS                 ( 8)                            /*!< DayLowDigit Bit Offset */
N#define RTC_C_ADOWDAY_DAY_LD_MASK                ((uint16_t)0x0F00)              /*!< DayLowDigit Bit Mask */
N/* RTC_C_ADOWDAY[DAY_HD] Bits */
N#define RTC_C_ADOWDAY_DAY_HD_OFS                 (12)                            /*!< DayHighDigit Bit Offset */
N#define RTC_C_ADOWDAY_DAY_HD_MASK                ((uint16_t)0x3000)              /*!< DayHighDigit Bit Mask */
N/* Pre-defined bitfield values */
N#define RTC_C_KEY                                 ((uint16_t)0xA500)              /*!< RTC_C Key Value for RTC_C write access */
N#define RTC_C_KEY_H                               ((uint16_t)0x00A5)              /*!< RTC_C Key Value for RTC_C write access */
N#define RTC_C_KEY_VAL                             ((uint16_t)0xA500)              /*!< RTC_C Key Value for RTC_C write access */
N
N
N/******************************************************************************
N* SCB Bits
N******************************************************************************/
N/* SCB_PFR0[STATE0] Bits */
N#define SCB_PFR0_STATE0_OFS                      ( 0)                            /*!< STATE0 Bit Offset */
N#define SCB_PFR0_STATE0_MASK                     ((uint32_t)0x0000000F)          /*!< STATE0 Bit Mask */
N#define SCB_PFR0_STATE00                         ((uint32_t)0x00000001)          /*!< STATE0 Bit 0 */
N#define SCB_PFR0_STATE01                         ((uint32_t)0x00000002)          /*!< STATE0 Bit 1 */
N#define SCB_PFR0_STATE02                         ((uint32_t)0x00000004)          /*!< STATE0 Bit 2 */
N#define SCB_PFR0_STATE03                         ((uint32_t)0x00000008)          /*!< STATE0 Bit 3 */
N#define SCB_PFR0_STATE0_0                        ((uint32_t)0x00000000)          /*!< no ARM encoding */
N#define SCB_PFR0_STATE0_1                        ((uint32_t)0x00000001)          /*!< N/A */
N/* SCB_PFR0[STATE1] Bits */
N#define SCB_PFR0_STATE1_OFS                      ( 4)                            /*!< STATE1 Bit Offset */
N#define SCB_PFR0_STATE1_MASK                     ((uint32_t)0x000000F0)          /*!< STATE1 Bit Mask */
N#define SCB_PFR0_STATE10                         ((uint32_t)0x00000010)          /*!< STATE1 Bit 0 */
N#define SCB_PFR0_STATE11                         ((uint32_t)0x00000020)          /*!< STATE1 Bit 1 */
N#define SCB_PFR0_STATE12                         ((uint32_t)0x00000040)          /*!< STATE1 Bit 2 */
N#define SCB_PFR0_STATE13                         ((uint32_t)0x00000080)          /*!< STATE1 Bit 3 */
N#define SCB_PFR0_STATE1_0                        ((uint32_t)0x00000000)          /*!< N/A */
N#define SCB_PFR0_STATE1_1                        ((uint32_t)0x00000010)          /*!< N/A */
N#define SCB_PFR0_STATE1_2                        ((uint32_t)0x00000020)          /*!< Thumb-2 encoding with the 16-bit basic instructions plus 32-bit Buncond/BL  */
N                                                                                 /* but no other 32-bit basic instructions (Note non-basic 32-bit instructions */
N                                                                                 /* can be added using the appropriate instruction attribute, but other 32-bit */
N                                                                                 /* basic instructions cannot.) */
N#define SCB_PFR0_STATE1_3                        ((uint32_t)0x00000030)          /*!< Thumb-2 encoding with all Thumb-2 basic instructions */
N/* SCB_PFR1[MICROCONTROLLER_PROGRAMMERS_MODEL] Bits */
N#define SCB_PFR1_MICROCONTROLLER_PROGRAMMERS_MODEL_OFS ( 8)                            /*!< MICROCONTROLLER_PROGRAMMERS_MODEL Bit Offset */
N#define SCB_PFR1_MICROCONTROLLER_PROGRAMMERS_MODEL_MASK ((uint32_t)0x00000F00)          /*!< MICROCONTROLLER_PROGRAMMERS_MODEL Bit Mask */
N#define SCB_PFR1_MICROCONTROLLER_PROGRAMMERS_MODEL0 ((uint32_t)0x00000100)          /*!< MICROCONTROLLER_PROGRAMMERS_MODEL Bit 0 */
N#define SCB_PFR1_MICROCONTROLLER_PROGRAMMERS_MODEL1 ((uint32_t)0x00000200)          /*!< MICROCONTROLLER_PROGRAMMERS_MODEL Bit 1 */
N#define SCB_PFR1_MICROCONTROLLER_PROGRAMMERS_MODEL2 ((uint32_t)0x00000400)          /*!< MICROCONTROLLER_PROGRAMMERS_MODEL Bit 2 */
N#define SCB_PFR1_MICROCONTROLLER_PROGRAMMERS_MODEL3 ((uint32_t)0x00000800)          /*!< MICROCONTROLLER_PROGRAMMERS_MODEL Bit 3 */
N#define SCB_PFR1_MICROCONTROLLER_PROGRAMMERS_MODEL_0 ((uint32_t)0x00000000)          /*!< not supported */
N#define SCB_PFR1_MICROCONTROLLER_PROGRAMMERS_MODEL_2 ((uint32_t)0x00000200)          /*!< two-stack support */
N/* SCB_DFR0[MICROCONTROLLER_DEBUG_MODEL] Bits */
N#define SCB_DFR0_MICROCONTROLLER_DEBUG_MODEL_OFS (20)                            /*!< MICROCONTROLLER_DEBUG_MODEL Bit Offset */
N#define SCB_DFR0_MICROCONTROLLER_DEBUG_MODEL_MASK ((uint32_t)0x00F00000)          /*!< MICROCONTROLLER_DEBUG_MODEL Bit Mask */
N#define SCB_DFR0_MICROCONTROLLER_DEBUG_MODEL0    ((uint32_t)0x00100000)          /*!< MICROCONTROLLER_DEBUG_MODEL Bit 0 */
N#define SCB_DFR0_MICROCONTROLLER_DEBUG_MODEL1    ((uint32_t)0x00200000)          /*!< MICROCONTROLLER_DEBUG_MODEL Bit 1 */
N#define SCB_DFR0_MICROCONTROLLER_DEBUG_MODEL2    ((uint32_t)0x00400000)          /*!< MICROCONTROLLER_DEBUG_MODEL Bit 2 */
N#define SCB_DFR0_MICROCONTROLLER_DEBUG_MODEL3    ((uint32_t)0x00800000)          /*!< MICROCONTROLLER_DEBUG_MODEL Bit 3 */
N#define SCB_DFR0_MICROCONTROLLER_DEBUG_MODEL_0   ((uint32_t)0x00000000)          /*!< not supported */
N#define SCB_DFR0_MICROCONTROLLER_DEBUG_MODEL_1   ((uint32_t)0x00100000)          /*!< Microcontroller debug v1 (ITMv1, DWTv1, optional ETM) */
N/* SCB_MMFR0[PMSA_SUPPORT] Bits */
N#define SCB_MMFR0_PMSA_SUPPORT_OFS               ( 4)                            /*!< PMSA_SUPPORT Bit Offset */
N#define SCB_MMFR0_PMSA_SUPPORT_MASK              ((uint32_t)0x000000F0)          /*!< PMSA_SUPPORT Bit Mask */
N#define SCB_MMFR0_PMSA_SUPPORT0                  ((uint32_t)0x00000010)          /*!< PMSA_SUPPORT Bit 0 */
N#define SCB_MMFR0_PMSA_SUPPORT1                  ((uint32_t)0x00000020)          /*!< PMSA_SUPPORT Bit 1 */
N#define SCB_MMFR0_PMSA_SUPPORT2                  ((uint32_t)0x00000040)          /*!< PMSA_SUPPORT Bit 2 */
N#define SCB_MMFR0_PMSA_SUPPORT3                  ((uint32_t)0x00000080)          /*!< PMSA_SUPPORT Bit 3 */
N#define SCB_MMFR0_PMSA_SUPPORT_0                 ((uint32_t)0x00000000)          /*!< not supported */
N#define SCB_MMFR0_PMSA_SUPPORT_1                 ((uint32_t)0x00000010)          /*!< IMPLEMENTATION DEFINED (N/A) */
N#define SCB_MMFR0_PMSA_SUPPORT_2                 ((uint32_t)0x00000020)          /*!< PMSA base (features as defined for ARMv6) (N/A) */
N#define SCB_MMFR0_PMSA_SUPPORT_3                 ((uint32_t)0x00000030)          /*!< PMSAv7 (base plus subregion support) */
N/* SCB_MMFR0[CACHE_COHERENCE_SUPPORT] Bits */
N#define SCB_MMFR0_CACHE_COHERENCE_SUPPORT_OFS    ( 8)                            /*!< CACHE_COHERENCE_SUPPORT Bit Offset */
N#define SCB_MMFR0_CACHE_COHERENCE_SUPPORT_MASK   ((uint32_t)0x00000F00)          /*!< CACHE_COHERENCE_SUPPORT Bit Mask */
N#define SCB_MMFR0_CACHE_COHERENCE_SUPPORT0       ((uint32_t)0x00000100)          /*!< CACHE_COHERENCE_SUPPORT Bit 0 */
N#define SCB_MMFR0_CACHE_COHERENCE_SUPPORT1       ((uint32_t)0x00000200)          /*!< CACHE_COHERENCE_SUPPORT Bit 1 */
N#define SCB_MMFR0_CACHE_COHERENCE_SUPPORT2       ((uint32_t)0x00000400)          /*!< CACHE_COHERENCE_SUPPORT Bit 2 */
N#define SCB_MMFR0_CACHE_COHERENCE_SUPPORT3       ((uint32_t)0x00000800)          /*!< CACHE_COHERENCE_SUPPORT Bit 3 */
N#define SCB_MMFR0_CACHE_COHERENCE_SUPPORT_0      ((uint32_t)0x00000000)          /*!< no shared support */
N#define SCB_MMFR0_CACHE_COHERENCE_SUPPORT_1      ((uint32_t)0x00000100)          /*!< partial-inner-shared coherency (coherency amongst some - but not all - of  */
N                                                                                 /* the entities within an inner-coherent domain) */
N#define SCB_MMFR0_CACHE_COHERENCE_SUPPORT_2      ((uint32_t)0x00000200)          /*!< full-inner-shared coherency (coherency amongst all of the entities within an  */
N                                                                                 /* inner-coherent domain) */
N#define SCB_MMFR0_CACHE_COHERENCE_SUPPORT_3      ((uint32_t)0x00000300)          /*!< full coherency (coherency amongst all of the entities) */
N/* SCB_MMFR0[OUTER_NON_SHARABLE_SUPPORT] Bits */
N#define SCB_MMFR0_OUTER_NON_SHARABLE_SUPPORT_OFS (12)                            /*!< OUTER_NON_SHARABLE_SUPPORT Bit Offset */
N#define SCB_MMFR0_OUTER_NON_SHARABLE_SUPPORT_MASK ((uint32_t)0x0000F000)          /*!< OUTER_NON_SHARABLE_SUPPORT Bit Mask */
N#define SCB_MMFR0_OUTER_NON_SHARABLE_SUPPORT0    ((uint32_t)0x00001000)          /*!< OUTER_NON_SHARABLE_SUPPORT Bit 0 */
N#define SCB_MMFR0_OUTER_NON_SHARABLE_SUPPORT1    ((uint32_t)0x00002000)          /*!< OUTER_NON_SHARABLE_SUPPORT Bit 1 */
N#define SCB_MMFR0_OUTER_NON_SHARABLE_SUPPORT2    ((uint32_t)0x00004000)          /*!< OUTER_NON_SHARABLE_SUPPORT Bit 2 */
N#define SCB_MMFR0_OUTER_NON_SHARABLE_SUPPORT3    ((uint32_t)0x00008000)          /*!< OUTER_NON_SHARABLE_SUPPORT Bit 3 */
N#define SCB_MMFR0_OUTER_NON_SHARABLE_SUPPORT_0   ((uint32_t)0x00000000)          /*!< Outer non-sharable not supported */
N#define SCB_MMFR0_OUTER_NON_SHARABLE_SUPPORT_1   ((uint32_t)0x00001000)          /*!< Outer sharable supported */
N/* SCB_MMFR0[AUILIARY_REGISTER_SUPPORT] Bits */
N#define SCB_MMFR0_AUILIARY_REGISTER_SUPPORT_OFS  (20)                            /*!< AUXILIARY_REGISTER_SUPPORT Bit Offset */
N#define SCB_MMFR0_AUILIARY_REGISTER_SUPPORT_MASK ((uint32_t)0x00F00000)          /*!< AUXILIARY_REGISTER_SUPPORT Bit Mask */
N#define SCB_MMFR0_AUILIARY_REGISTER_SUPPORT0     ((uint32_t)0x00100000)          /*!< AUILIARY_REGISTER_SUPPORT Bit 0 */
N#define SCB_MMFR0_AUILIARY_REGISTER_SUPPORT1     ((uint32_t)0x00200000)          /*!< AUILIARY_REGISTER_SUPPORT Bit 1 */
N#define SCB_MMFR0_AUILIARY_REGISTER_SUPPORT2     ((uint32_t)0x00400000)          /*!< AUILIARY_REGISTER_SUPPORT Bit 2 */
N#define SCB_MMFR0_AUILIARY_REGISTER_SUPPORT3     ((uint32_t)0x00800000)          /*!< AUILIARY_REGISTER_SUPPORT Bit 3 */
N#define SCB_MMFR0_AUILIARY_REGISTER_SUPPORT_0    ((uint32_t)0x00000000)          /*!< not supported */
N#define SCB_MMFR0_AUILIARY_REGISTER_SUPPORT_1    ((uint32_t)0x00100000)          /*!< Auxiliary control register */
N/* SCB_MMFR2[WAIT_FOR_INTERRUPT_STALLING] Bits */
N#define SCB_MMFR2_WAIT_FOR_INTERRUPT_STALLING_OFS (24)                            /*!< WAIT_FOR_INTERRUPT_STALLING Bit Offset */
N#define SCB_MMFR2_WAIT_FOR_INTERRUPT_STALLING_MASK ((uint32_t)0x0F000000)          /*!< WAIT_FOR_INTERRUPT_STALLING Bit Mask */
N#define SCB_MMFR2_WAIT_FOR_INTERRUPT_STALLING0   ((uint32_t)0x01000000)          /*!< WAIT_FOR_INTERRUPT_STALLING Bit 0 */
N#define SCB_MMFR2_WAIT_FOR_INTERRUPT_STALLING1   ((uint32_t)0x02000000)          /*!< WAIT_FOR_INTERRUPT_STALLING Bit 1 */
N#define SCB_MMFR2_WAIT_FOR_INTERRUPT_STALLING2   ((uint32_t)0x04000000)          /*!< WAIT_FOR_INTERRUPT_STALLING Bit 2 */
N#define SCB_MMFR2_WAIT_FOR_INTERRUPT_STALLING3   ((uint32_t)0x08000000)          /*!< WAIT_FOR_INTERRUPT_STALLING Bit 3 */
N#define SCB_MMFR2_WAIT_FOR_INTERRUPT_STALLING_0  ((uint32_t)0x00000000)          /*!< not supported */
N#define SCB_MMFR2_WAIT_FOR_INTERRUPT_STALLING_1  ((uint32_t)0x01000000)          /*!< wait for interrupt supported */
N/* SCB_ISAR0[BITCOUNT_INSTRS] Bits */
N#define SCB_ISAR0_BITCOUNT_INSTRS_OFS            ( 4)                            /*!< BITCOUNT_INSTRS Bit Offset */
N#define SCB_ISAR0_BITCOUNT_INSTRS_MASK           ((uint32_t)0x000000F0)          /*!< BITCOUNT_INSTRS Bit Mask */
N#define SCB_ISAR0_BITCOUNT_INSTRS0               ((uint32_t)0x00000010)          /*!< BITCOUNT_INSTRS Bit 0 */
N#define SCB_ISAR0_BITCOUNT_INSTRS1               ((uint32_t)0x00000020)          /*!< BITCOUNT_INSTRS Bit 1 */
N#define SCB_ISAR0_BITCOUNT_INSTRS2               ((uint32_t)0x00000040)          /*!< BITCOUNT_INSTRS Bit 2 */
N#define SCB_ISAR0_BITCOUNT_INSTRS3               ((uint32_t)0x00000080)          /*!< BITCOUNT_INSTRS Bit 3 */
N#define SCB_ISAR0_BITCOUNT_INSTRS_0              ((uint32_t)0x00000000)          /*!< no bit-counting instructions present */
N#define SCB_ISAR0_BITCOUNT_INSTRS_1              ((uint32_t)0x00000010)          /*!< adds CLZ */
N/* SCB_ISAR0[BITFIELD_INSTRS] Bits */
N#define SCB_ISAR0_BITFIELD_INSTRS_OFS            ( 8)                            /*!< BITFIELD_INSTRS Bit Offset */
N#define SCB_ISAR0_BITFIELD_INSTRS_MASK           ((uint32_t)0x00000F00)          /*!< BITFIELD_INSTRS Bit Mask */
N#define SCB_ISAR0_BITFIELD_INSTRS0               ((uint32_t)0x00000100)          /*!< BITFIELD_INSTRS Bit 0 */
N#define SCB_ISAR0_BITFIELD_INSTRS1               ((uint32_t)0x00000200)          /*!< BITFIELD_INSTRS Bit 1 */
N#define SCB_ISAR0_BITFIELD_INSTRS2               ((uint32_t)0x00000400)          /*!< BITFIELD_INSTRS Bit 2 */
N#define SCB_ISAR0_BITFIELD_INSTRS3               ((uint32_t)0x00000800)          /*!< BITFIELD_INSTRS Bit 3 */
N#define SCB_ISAR0_BITFIELD_INSTRS_0              ((uint32_t)0x00000000)          /*!< no bitfield instructions present */
N#define SCB_ISAR0_BITFIELD_INSTRS_1              ((uint32_t)0x00000100)          /*!< adds BFC, BFI, SBFX, UBFX */
N/* SCB_ISAR0[CMPBRANCH_INSTRS] Bits */
N#define SCB_ISAR0_CMPBRANCH_INSTRS_OFS           (12)                            /*!< CMPBRANCH_INSTRS Bit Offset */
N#define SCB_ISAR0_CMPBRANCH_INSTRS_MASK          ((uint32_t)0x0000F000)          /*!< CMPBRANCH_INSTRS Bit Mask */
N#define SCB_ISAR0_CMPBRANCH_INSTRS0              ((uint32_t)0x00001000)          /*!< CMPBRANCH_INSTRS Bit 0 */
N#define SCB_ISAR0_CMPBRANCH_INSTRS1              ((uint32_t)0x00002000)          /*!< CMPBRANCH_INSTRS Bit 1 */
N#define SCB_ISAR0_CMPBRANCH_INSTRS2              ((uint32_t)0x00004000)          /*!< CMPBRANCH_INSTRS Bit 2 */
N#define SCB_ISAR0_CMPBRANCH_INSTRS3              ((uint32_t)0x00008000)          /*!< CMPBRANCH_INSTRS Bit 3 */
N#define SCB_ISAR0_CMPBRANCH_INSTRS_0             ((uint32_t)0x00000000)          /*!< no combined compare-and-branch instructions present */
N#define SCB_ISAR0_CMPBRANCH_INSTRS_1             ((uint32_t)0x00001000)          /*!< adds CB{N}Z */
N/* SCB_ISAR0[COPROC_INSTRS] Bits */
N#define SCB_ISAR0_COPROC_INSTRS_OFS              (16)                            /*!< COPROC_INSTRS Bit Offset */
N#define SCB_ISAR0_COPROC_INSTRS_MASK             ((uint32_t)0x000F0000)          /*!< COPROC_INSTRS Bit Mask */
N#define SCB_ISAR0_COPROC_INSTRS0                 ((uint32_t)0x00010000)          /*!< COPROC_INSTRS Bit 0 */
N#define SCB_ISAR0_COPROC_INSTRS1                 ((uint32_t)0x00020000)          /*!< COPROC_INSTRS Bit 1 */
N#define SCB_ISAR0_COPROC_INSTRS2                 ((uint32_t)0x00040000)          /*!< COPROC_INSTRS Bit 2 */
N#define SCB_ISAR0_COPROC_INSTRS3                 ((uint32_t)0x00080000)          /*!< COPROC_INSTRS Bit 3 */
N#define SCB_ISAR0_COPROC_INSTRS_0                ((uint32_t)0x00000000)          /*!< no coprocessor support, other than for separately attributed architectures  */
N                                                                                 /* such as CP15 or VFP */
N#define SCB_ISAR0_COPROC_INSTRS_1                ((uint32_t)0x00010000)          /*!< adds generic CDP, LDC, MCR, MRC, STC */
N#define SCB_ISAR0_COPROC_INSTRS_2                ((uint32_t)0x00020000)          /*!< adds generic CDP2, LDC2, MCR2, MRC2, STC2 */
N#define SCB_ISAR0_COPROC_INSTRS_3                ((uint32_t)0x00030000)          /*!< adds generic MCRR, MRRC */
N#define SCB_ISAR0_COPROC_INSTRS_4                ((uint32_t)0x00040000)          /*!< adds generic MCRR2, MRRC2 */
N/* SCB_ISAR0[DEBUG_INSTRS] Bits */
N#define SCB_ISAR0_DEBUG_INSTRS_OFS               (20)                            /*!< DEBUG_INSTRS Bit Offset */
N#define SCB_ISAR0_DEBUG_INSTRS_MASK              ((uint32_t)0x00F00000)          /*!< DEBUG_INSTRS Bit Mask */
N#define SCB_ISAR0_DEBUG_INSTRS0                  ((uint32_t)0x00100000)          /*!< DEBUG_INSTRS Bit 0 */
N#define SCB_ISAR0_DEBUG_INSTRS1                  ((uint32_t)0x00200000)          /*!< DEBUG_INSTRS Bit 1 */
N#define SCB_ISAR0_DEBUG_INSTRS2                  ((uint32_t)0x00400000)          /*!< DEBUG_INSTRS Bit 2 */
N#define SCB_ISAR0_DEBUG_INSTRS3                  ((uint32_t)0x00800000)          /*!< DEBUG_INSTRS Bit 3 */
N#define SCB_ISAR0_DEBUG_INSTRS_0                 ((uint32_t)0x00000000)          /*!< no debug instructions present */
N#define SCB_ISAR0_DEBUG_INSTRS_1                 ((uint32_t)0x00100000)          /*!< adds BKPT */
N/* SCB_ISAR0[DIVIDE_INSTRS] Bits */
N#define SCB_ISAR0_DIVIDE_INSTRS_OFS              (24)                            /*!< DIVIDE_INSTRS Bit Offset */
N#define SCB_ISAR0_DIVIDE_INSTRS_MASK             ((uint32_t)0x0F000000)          /*!< DIVIDE_INSTRS Bit Mask */
N#define SCB_ISAR0_DIVIDE_INSTRS0                 ((uint32_t)0x01000000)          /*!< DIVIDE_INSTRS Bit 0 */
N#define SCB_ISAR0_DIVIDE_INSTRS1                 ((uint32_t)0x02000000)          /*!< DIVIDE_INSTRS Bit 1 */
N#define SCB_ISAR0_DIVIDE_INSTRS2                 ((uint32_t)0x04000000)          /*!< DIVIDE_INSTRS Bit 2 */
N#define SCB_ISAR0_DIVIDE_INSTRS3                 ((uint32_t)0x08000000)          /*!< DIVIDE_INSTRS Bit 3 */
N#define SCB_ISAR0_DIVIDE_INSTRS_0                ((uint32_t)0x00000000)          /*!< no divide instructions present */
N#define SCB_ISAR0_DIVIDE_INSTRS_1                ((uint32_t)0x01000000)          /*!< adds SDIV, UDIV (v1 quotient only result) */
N/* SCB_ISAR1[ETEND_INSRS] Bits */
N#define SCB_ISAR1_ETEND_INSRS_OFS                (12)                            /*!< EXTEND_INSRS Bit Offset */
N#define SCB_ISAR1_ETEND_INSRS_MASK               ((uint32_t)0x0000F000)          /*!< EXTEND_INSRS Bit Mask */
N#define SCB_ISAR1_ETEND_INSRS0                   ((uint32_t)0x00001000)          /*!< ETEND_INSRS Bit 0 */
N#define SCB_ISAR1_ETEND_INSRS1                   ((uint32_t)0x00002000)          /*!< ETEND_INSRS Bit 1 */
N#define SCB_ISAR1_ETEND_INSRS2                   ((uint32_t)0x00004000)          /*!< ETEND_INSRS Bit 2 */
N#define SCB_ISAR1_ETEND_INSRS3                   ((uint32_t)0x00008000)          /*!< ETEND_INSRS Bit 3 */
N#define SCB_ISAR1_ETEND_INSRS_0                  ((uint32_t)0x00000000)          /*!< no scalar (i.e. non-SIMD) sign/zero-extend instructions present */
N#define SCB_ISAR1_ETEND_INSRS_1                  ((uint32_t)0x00001000)          /*!< adds SXTB, SXTH, UXTB, UXTH */
N#define SCB_ISAR1_ETEND_INSRS_2                  ((uint32_t)0x00002000)          /*!< N/A */
N/* SCB_ISAR1[IFTHEN_INSTRS] Bits */
N#define SCB_ISAR1_IFTHEN_INSTRS_OFS              (16)                            /*!< IFTHEN_INSTRS Bit Offset */
N#define SCB_ISAR1_IFTHEN_INSTRS_MASK             ((uint32_t)0x000F0000)          /*!< IFTHEN_INSTRS Bit Mask */
N#define SCB_ISAR1_IFTHEN_INSTRS0                 ((uint32_t)0x00010000)          /*!< IFTHEN_INSTRS Bit 0 */
N#define SCB_ISAR1_IFTHEN_INSTRS1                 ((uint32_t)0x00020000)          /*!< IFTHEN_INSTRS Bit 1 */
N#define SCB_ISAR1_IFTHEN_INSTRS2                 ((uint32_t)0x00040000)          /*!< IFTHEN_INSTRS Bit 2 */
N#define SCB_ISAR1_IFTHEN_INSTRS3                 ((uint32_t)0x00080000)          /*!< IFTHEN_INSTRS Bit 3 */
N#define SCB_ISAR1_IFTHEN_INSTRS_0                ((uint32_t)0x00000000)          /*!< IT instructions not present */
N#define SCB_ISAR1_IFTHEN_INSTRS_1                ((uint32_t)0x00010000)          /*!< adds IT instructions (and IT bits in PSRs) */
N/* SCB_ISAR1[IMMEDIATE_INSTRS] Bits */
N#define SCB_ISAR1_IMMEDIATE_INSTRS_OFS           (20)                            /*!< IMMEDIATE_INSTRS Bit Offset */
N#define SCB_ISAR1_IMMEDIATE_INSTRS_MASK          ((uint32_t)0x00F00000)          /*!< IMMEDIATE_INSTRS Bit Mask */
N#define SCB_ISAR1_IMMEDIATE_INSTRS0              ((uint32_t)0x00100000)          /*!< IMMEDIATE_INSTRS Bit 0 */
N#define SCB_ISAR1_IMMEDIATE_INSTRS1              ((uint32_t)0x00200000)          /*!< IMMEDIATE_INSTRS Bit 1 */
N#define SCB_ISAR1_IMMEDIATE_INSTRS2              ((uint32_t)0x00400000)          /*!< IMMEDIATE_INSTRS Bit 2 */
N#define SCB_ISAR1_IMMEDIATE_INSTRS3              ((uint32_t)0x00800000)          /*!< IMMEDIATE_INSTRS Bit 3 */
N#define SCB_ISAR1_IMMEDIATE_INSTRS_0             ((uint32_t)0x00000000)          /*!< no special immediate-generating instructions present */
N#define SCB_ISAR1_IMMEDIATE_INSTRS_1             ((uint32_t)0x00100000)          /*!< adds ADDW, MOVW, MOVT, SUBW */
N/* SCB_ISAR1[INTERWORK_INSTRS] Bits */
N#define SCB_ISAR1_INTERWORK_INSTRS_OFS           (24)                            /*!< INTERWORK_INSTRS Bit Offset */
N#define SCB_ISAR1_INTERWORK_INSTRS_MASK          ((uint32_t)0x0F000000)          /*!< INTERWORK_INSTRS Bit Mask */
N#define SCB_ISAR1_INTERWORK_INSTRS0              ((uint32_t)0x01000000)          /*!< INTERWORK_INSTRS Bit 0 */
N#define SCB_ISAR1_INTERWORK_INSTRS1              ((uint32_t)0x02000000)          /*!< INTERWORK_INSTRS Bit 1 */
N#define SCB_ISAR1_INTERWORK_INSTRS2              ((uint32_t)0x04000000)          /*!< INTERWORK_INSTRS Bit 2 */
N#define SCB_ISAR1_INTERWORK_INSTRS3              ((uint32_t)0x08000000)          /*!< INTERWORK_INSTRS Bit 3 */
N#define SCB_ISAR1_INTERWORK_INSTRS_0             ((uint32_t)0x00000000)          /*!< no interworking instructions supported */
N#define SCB_ISAR1_INTERWORK_INSTRS_1             ((uint32_t)0x01000000)          /*!< adds BX (and T bit in PSRs) */
N#define SCB_ISAR1_INTERWORK_INSTRS_2             ((uint32_t)0x02000000)          /*!< adds BLX, and PC loads have BX-like behavior */
N#define SCB_ISAR1_INTERWORK_INSTRS_3             ((uint32_t)0x03000000)          /*!< N/A */
N/* SCB_ISAR2[LOADSTORE_INSTRS] Bits */
N#define SCB_ISAR2_LOADSTORE_INSTRS_OFS           ( 0)                            /*!< LOADSTORE_INSTRS Bit Offset */
N#define SCB_ISAR2_LOADSTORE_INSTRS_MASK          ((uint32_t)0x0000000F)          /*!< LOADSTORE_INSTRS Bit Mask */
N#define SCB_ISAR2_LOADSTORE_INSTRS0              ((uint32_t)0x00000001)          /*!< LOADSTORE_INSTRS Bit 0 */
N#define SCB_ISAR2_LOADSTORE_INSTRS1              ((uint32_t)0x00000002)          /*!< LOADSTORE_INSTRS Bit 1 */
N#define SCB_ISAR2_LOADSTORE_INSTRS2              ((uint32_t)0x00000004)          /*!< LOADSTORE_INSTRS Bit 2 */
N#define SCB_ISAR2_LOADSTORE_INSTRS3              ((uint32_t)0x00000008)          /*!< LOADSTORE_INSTRS Bit 3 */
N#define SCB_ISAR2_LOADSTORE_INSTRS_0             ((uint32_t)0x00000000)          /*!< no additional normal load/store instructions present */
N#define SCB_ISAR2_LOADSTORE_INSTRS_1             ((uint32_t)0x00000001)          /*!< adds LDRD/STRD */
N/* SCB_ISAR2[MEMHINT_INSTRS] Bits */
N#define SCB_ISAR2_MEMHINT_INSTRS_OFS             ( 4)                            /*!< MEMHINT_INSTRS Bit Offset */
N#define SCB_ISAR2_MEMHINT_INSTRS_MASK            ((uint32_t)0x000000F0)          /*!< MEMHINT_INSTRS Bit Mask */
N#define SCB_ISAR2_MEMHINT_INSTRS0                ((uint32_t)0x00000010)          /*!< MEMHINT_INSTRS Bit 0 */
N#define SCB_ISAR2_MEMHINT_INSTRS1                ((uint32_t)0x00000020)          /*!< MEMHINT_INSTRS Bit 1 */
N#define SCB_ISAR2_MEMHINT_INSTRS2                ((uint32_t)0x00000040)          /*!< MEMHINT_INSTRS Bit 2 */
N#define SCB_ISAR2_MEMHINT_INSTRS3                ((uint32_t)0x00000080)          /*!< MEMHINT_INSTRS Bit 3 */
N#define SCB_ISAR2_MEMHINT_INSTRS_0               ((uint32_t)0x00000000)          /*!< no memory hint instructions presen */
N#define SCB_ISAR2_MEMHINT_INSTRS_1               ((uint32_t)0x00000010)          /*!< adds PLD */
N#define SCB_ISAR2_MEMHINT_INSTRS_2               ((uint32_t)0x00000020)          /*!< adds PLD (ie a repeat on value 1) */
N#define SCB_ISAR2_MEMHINT_INSTRS_3               ((uint32_t)0x00000030)          /*!< adds PLI */
N/* SCB_ISAR2[MULTIACCESSINT_INSTRS] Bits */
N#define SCB_ISAR2_MULTIACCESSINT_INSTRS_OFS      ( 8)                            /*!< MULTIACCESSINT_INSTRS Bit Offset */
N#define SCB_ISAR2_MULTIACCESSINT_INSTRS_MASK     ((uint32_t)0x00000F00)          /*!< MULTIACCESSINT_INSTRS Bit Mask */
N#define SCB_ISAR2_MULTIACCESSINT_INSTRS0         ((uint32_t)0x00000100)          /*!< MULTIACCESSINT_INSTRS Bit 0 */
N#define SCB_ISAR2_MULTIACCESSINT_INSTRS1         ((uint32_t)0x00000200)          /*!< MULTIACCESSINT_INSTRS Bit 1 */
N#define SCB_ISAR2_MULTIACCESSINT_INSTRS2         ((uint32_t)0x00000400)          /*!< MULTIACCESSINT_INSTRS Bit 2 */
N#define SCB_ISAR2_MULTIACCESSINT_INSTRS3         ((uint32_t)0x00000800)          /*!< MULTIACCESSINT_INSTRS Bit 3 */
N#define SCB_ISAR2_MULTIACCESSINT_INSTRS_0        ((uint32_t)0x00000000)          /*!< the (LDM/STM) instructions are non-interruptible */
N#define SCB_ISAR2_MULTIACCESSINT_INSTRS_1        ((uint32_t)0x00000100)          /*!< the (LDM/STM) instructions are restartable */
N#define SCB_ISAR2_MULTIACCESSINT_INSTRS_2        ((uint32_t)0x00000200)          /*!< the (LDM/STM) instructions are continuable */
N/* SCB_ISAR2[MULT_INSTRS] Bits */
N#define SCB_ISAR2_MULT_INSTRS_OFS                (12)                            /*!< MULT_INSTRS Bit Offset */
N#define SCB_ISAR2_MULT_INSTRS_MASK               ((uint32_t)0x0000F000)          /*!< MULT_INSTRS Bit Mask */
N#define SCB_ISAR2_MULT_INSTRS0                   ((uint32_t)0x00001000)          /*!< MULT_INSTRS Bit 0 */
N#define SCB_ISAR2_MULT_INSTRS1                   ((uint32_t)0x00002000)          /*!< MULT_INSTRS Bit 1 */
N#define SCB_ISAR2_MULT_INSTRS2                   ((uint32_t)0x00004000)          /*!< MULT_INSTRS Bit 2 */
N#define SCB_ISAR2_MULT_INSTRS3                   ((uint32_t)0x00008000)          /*!< MULT_INSTRS Bit 3 */
N#define SCB_ISAR2_MULT_INSTRS_0                  ((uint32_t)0x00000000)          /*!< only MUL present */
N#define SCB_ISAR2_MULT_INSTRS_1                  ((uint32_t)0x00001000)          /*!< adds MLA */
N#define SCB_ISAR2_MULT_INSTRS_2                  ((uint32_t)0x00002000)          /*!< adds MLS */
N/* SCB_ISAR2[MULTS_INSTRS] Bits */
N#define SCB_ISAR2_MULTS_INSTRS_OFS               (16)                            /*!< MULTS_INSTRS Bit Offset */
N#define SCB_ISAR2_MULTS_INSTRS_MASK              ((uint32_t)0x000F0000)          /*!< MULTS_INSTRS Bit Mask */
N#define SCB_ISAR2_MULTS_INSTRS0                  ((uint32_t)0x00010000)          /*!< MULTS_INSTRS Bit 0 */
N#define SCB_ISAR2_MULTS_INSTRS1                  ((uint32_t)0x00020000)          /*!< MULTS_INSTRS Bit 1 */
N#define SCB_ISAR2_MULTS_INSTRS2                  ((uint32_t)0x00040000)          /*!< MULTS_INSTRS Bit 2 */
N#define SCB_ISAR2_MULTS_INSTRS3                  ((uint32_t)0x00080000)          /*!< MULTS_INSTRS Bit 3 */
N#define SCB_ISAR2_MULTS_INSTRS_0                 ((uint32_t)0x00000000)          /*!< no signed multiply instructions present */
N#define SCB_ISAR2_MULTS_INSTRS_1                 ((uint32_t)0x00010000)          /*!< adds SMULL, SMLAL */
N#define SCB_ISAR2_MULTS_INSTRS_2                 ((uint32_t)0x00020000)          /*!< N/A */
N#define SCB_ISAR2_MULTS_INSTRS_3                 ((uint32_t)0x00030000)          /*!< N/A */
N/* SCB_ISAR2[MULTU_INSTRS] Bits */
N#define SCB_ISAR2_MULTU_INSTRS_OFS               (20)                            /*!< MULTU_INSTRS Bit Offset */
N#define SCB_ISAR2_MULTU_INSTRS_MASK              ((uint32_t)0x00F00000)          /*!< MULTU_INSTRS Bit Mask */
N#define SCB_ISAR2_MULTU_INSTRS0                  ((uint32_t)0x00100000)          /*!< MULTU_INSTRS Bit 0 */
N#define SCB_ISAR2_MULTU_INSTRS1                  ((uint32_t)0x00200000)          /*!< MULTU_INSTRS Bit 1 */
N#define SCB_ISAR2_MULTU_INSTRS2                  ((uint32_t)0x00400000)          /*!< MULTU_INSTRS Bit 2 */
N#define SCB_ISAR2_MULTU_INSTRS3                  ((uint32_t)0x00800000)          /*!< MULTU_INSTRS Bit 3 */
N#define SCB_ISAR2_MULTU_INSTRS_0                 ((uint32_t)0x00000000)          /*!< no unsigned multiply instructions present */
N#define SCB_ISAR2_MULTU_INSTRS_1                 ((uint32_t)0x00100000)          /*!< adds UMULL, UMLAL */
N#define SCB_ISAR2_MULTU_INSTRS_2                 ((uint32_t)0x00200000)          /*!< N/A */
N/* SCB_ISAR2[REVERSAL_INSTRS] Bits */
N#define SCB_ISAR2_REVERSAL_INSTRS_OFS            (28)                            /*!< REVERSAL_INSTRS Bit Offset */
N#define SCB_ISAR2_REVERSAL_INSTRS_MASK           ((uint32_t)0xF0000000)          /*!< REVERSAL_INSTRS Bit Mask */
N#define SCB_ISAR2_REVERSAL_INSTRS0               ((uint32_t)0x10000000)          /*!< REVERSAL_INSTRS Bit 0 */
N#define SCB_ISAR2_REVERSAL_INSTRS1               ((uint32_t)0x20000000)          /*!< REVERSAL_INSTRS Bit 1 */
N#define SCB_ISAR2_REVERSAL_INSTRS2               ((uint32_t)0x40000000)          /*!< REVERSAL_INSTRS Bit 2 */
N#define SCB_ISAR2_REVERSAL_INSTRS3               ((uint32_t)0x80000000)          /*!< REVERSAL_INSTRS Bit 3 */
N#define SCB_ISAR2_REVERSAL_INSTRS_0              ((uint32_t)0x00000000)          /*!< no reversal instructions present */
N#define SCB_ISAR2_REVERSAL_INSTRS_1              ((uint32_t)0x10000000)          /*!< adds REV, REV16, REVSH */
N#define SCB_ISAR2_REVERSAL_INSTRS_2              ((uint32_t)0x20000000)          /*!< adds RBIT */
N/* SCB_ISAR3[SATRUATE_INSTRS] Bits */
N#define SCB_ISAR3_SATRUATE_INSTRS_OFS            ( 0)                            /*!< SATRUATE_INSTRS Bit Offset */
N#define SCB_ISAR3_SATRUATE_INSTRS_MASK           ((uint32_t)0x0000000F)          /*!< SATRUATE_INSTRS Bit Mask */
N#define SCB_ISAR3_SATRUATE_INSTRS0               ((uint32_t)0x00000001)          /*!< SATRUATE_INSTRS Bit 0 */
N#define SCB_ISAR3_SATRUATE_INSTRS1               ((uint32_t)0x00000002)          /*!< SATRUATE_INSTRS Bit 1 */
N#define SCB_ISAR3_SATRUATE_INSTRS2               ((uint32_t)0x00000004)          /*!< SATRUATE_INSTRS Bit 2 */
N#define SCB_ISAR3_SATRUATE_INSTRS3               ((uint32_t)0x00000008)          /*!< SATRUATE_INSTRS Bit 3 */
N#define SCB_ISAR3_SATRUATE_INSTRS_0              ((uint32_t)0x00000000)          /*!< no non-SIMD saturate instructions present */
N#define SCB_ISAR3_SATRUATE_INSTRS_1              ((uint32_t)0x00000001)          /*!< N/A */
N/* SCB_ISAR3[SIMD_INSTRS] Bits */
N#define SCB_ISAR3_SIMD_INSTRS_OFS                ( 4)                            /*!< SIMD_INSTRS Bit Offset */
N#define SCB_ISAR3_SIMD_INSTRS_MASK               ((uint32_t)0x000000F0)          /*!< SIMD_INSTRS Bit Mask */
N#define SCB_ISAR3_SIMD_INSTRS0                   ((uint32_t)0x00000010)          /*!< SIMD_INSTRS Bit 0 */
N#define SCB_ISAR3_SIMD_INSTRS1                   ((uint32_t)0x00000020)          /*!< SIMD_INSTRS Bit 1 */
N#define SCB_ISAR3_SIMD_INSTRS2                   ((uint32_t)0x00000040)          /*!< SIMD_INSTRS Bit 2 */
N#define SCB_ISAR3_SIMD_INSTRS3                   ((uint32_t)0x00000080)          /*!< SIMD_INSTRS Bit 3 */
N#define SCB_ISAR3_SIMD_INSTRS_0                  ((uint32_t)0x00000000)          /*!< no SIMD instructions present */
N#define SCB_ISAR3_SIMD_INSTRS_1                  ((uint32_t)0x00000010)          /*!< adds SSAT, USAT (and the Q flag in the PSRs) */
N#define SCB_ISAR3_SIMD_INSTRS_3                  ((uint32_t)0x00000030)          /*!< N/A */
N/* SCB_ISAR3[SVC_INSTRS] Bits */
N#define SCB_ISAR3_SVC_INSTRS_OFS                 ( 8)                            /*!< SVC_INSTRS Bit Offset */
N#define SCB_ISAR3_SVC_INSTRS_MASK                ((uint32_t)0x00000F00)          /*!< SVC_INSTRS Bit Mask */
N#define SCB_ISAR3_SVC_INSTRS0                    ((uint32_t)0x00000100)          /*!< SVC_INSTRS Bit 0 */
N#define SCB_ISAR3_SVC_INSTRS1                    ((uint32_t)0x00000200)          /*!< SVC_INSTRS Bit 1 */
N#define SCB_ISAR3_SVC_INSTRS2                    ((uint32_t)0x00000400)          /*!< SVC_INSTRS Bit 2 */
N#define SCB_ISAR3_SVC_INSTRS3                    ((uint32_t)0x00000800)          /*!< SVC_INSTRS Bit 3 */
N#define SCB_ISAR3_SVC_INSTRS_0                   ((uint32_t)0x00000000)          /*!< no SVC (SWI) instructions present */
N#define SCB_ISAR3_SVC_INSTRS_1                   ((uint32_t)0x00000100)          /*!< adds SVC (SWI) */
N/* SCB_ISAR3[SYNCPRIM_INSTRS] Bits */
N#define SCB_ISAR3_SYNCPRIM_INSTRS_OFS            (12)                            /*!< SYNCPRIM_INSTRS Bit Offset */
N#define SCB_ISAR3_SYNCPRIM_INSTRS_MASK           ((uint32_t)0x0000F000)          /*!< SYNCPRIM_INSTRS Bit Mask */
N#define SCB_ISAR3_SYNCPRIM_INSTRS0               ((uint32_t)0x00001000)          /*!< SYNCPRIM_INSTRS Bit 0 */
N#define SCB_ISAR3_SYNCPRIM_INSTRS1               ((uint32_t)0x00002000)          /*!< SYNCPRIM_INSTRS Bit 1 */
N#define SCB_ISAR3_SYNCPRIM_INSTRS2               ((uint32_t)0x00004000)          /*!< SYNCPRIM_INSTRS Bit 2 */
N#define SCB_ISAR3_SYNCPRIM_INSTRS3               ((uint32_t)0x00008000)          /*!< SYNCPRIM_INSTRS Bit 3 */
N#define SCB_ISAR3_SYNCPRIM_INSTRS_0              ((uint32_t)0x00000000)          /*!< no synchronization primitives present */
N#define SCB_ISAR3_SYNCPRIM_INSTRS_1              ((uint32_t)0x00001000)          /*!< adds LDREX, STREX */
N#define SCB_ISAR3_SYNCPRIM_INSTRS_2              ((uint32_t)0x00002000)          /*!< adds LDREXB, LDREXH, LDREXD, STREXB, STREXH, STREXD, CLREX(N/A) */
N/* SCB_ISAR3[TABBRANCH_INSTRS] Bits */
N#define SCB_ISAR3_TABBRANCH_INSTRS_OFS           (16)                            /*!< TABBRANCH_INSTRS Bit Offset */
N#define SCB_ISAR3_TABBRANCH_INSTRS_MASK          ((uint32_t)0x000F0000)          /*!< TABBRANCH_INSTRS Bit Mask */
N#define SCB_ISAR3_TABBRANCH_INSTRS0              ((uint32_t)0x00010000)          /*!< TABBRANCH_INSTRS Bit 0 */
N#define SCB_ISAR3_TABBRANCH_INSTRS1              ((uint32_t)0x00020000)          /*!< TABBRANCH_INSTRS Bit 1 */
N#define SCB_ISAR3_TABBRANCH_INSTRS2              ((uint32_t)0x00040000)          /*!< TABBRANCH_INSTRS Bit 2 */
N#define SCB_ISAR3_TABBRANCH_INSTRS3              ((uint32_t)0x00080000)          /*!< TABBRANCH_INSTRS Bit 3 */
N#define SCB_ISAR3_TABBRANCH_INSTRS_0             ((uint32_t)0x00000000)          /*!< no table-branch instructions present */
N#define SCB_ISAR3_TABBRANCH_INSTRS_1             ((uint32_t)0x00010000)          /*!< adds TBB, TBH */
N/* SCB_ISAR3[THUMBCOPY_INSTRS] Bits */
N#define SCB_ISAR3_THUMBCOPY_INSTRS_OFS           (20)                            /*!< THUMBCOPY_INSTRS Bit Offset */
N#define SCB_ISAR3_THUMBCOPY_INSTRS_MASK          ((uint32_t)0x00F00000)          /*!< THUMBCOPY_INSTRS Bit Mask */
N#define SCB_ISAR3_THUMBCOPY_INSTRS0              ((uint32_t)0x00100000)          /*!< THUMBCOPY_INSTRS Bit 0 */
N#define SCB_ISAR3_THUMBCOPY_INSTRS1              ((uint32_t)0x00200000)          /*!< THUMBCOPY_INSTRS Bit 1 */
N#define SCB_ISAR3_THUMBCOPY_INSTRS2              ((uint32_t)0x00400000)          /*!< THUMBCOPY_INSTRS Bit 2 */
N#define SCB_ISAR3_THUMBCOPY_INSTRS3              ((uint32_t)0x00800000)          /*!< THUMBCOPY_INSTRS Bit 3 */
N#define SCB_ISAR3_THUMBCOPY_INSTRS_0             ((uint32_t)0x00000000)          /*!< Thumb MOV(register) instruction does not allow low reg -> low reg */
N#define SCB_ISAR3_THUMBCOPY_INSTRS_1             ((uint32_t)0x00100000)          /*!< adds Thumb MOV(register) low reg -> low reg and the CPY alias */
N/* SCB_ISAR3[TRUENOP_INSTRS] Bits */
N#define SCB_ISAR3_TRUENOP_INSTRS_OFS             (24)                            /*!< TRUENOP_INSTRS Bit Offset */
N#define SCB_ISAR3_TRUENOP_INSTRS_MASK            ((uint32_t)0x0F000000)          /*!< TRUENOP_INSTRS Bit Mask */
N#define SCB_ISAR3_TRUENOP_INSTRS0                ((uint32_t)0x01000000)          /*!< TRUENOP_INSTRS Bit 0 */
N#define SCB_ISAR3_TRUENOP_INSTRS1                ((uint32_t)0x02000000)          /*!< TRUENOP_INSTRS Bit 1 */
N#define SCB_ISAR3_TRUENOP_INSTRS2                ((uint32_t)0x04000000)          /*!< TRUENOP_INSTRS Bit 2 */
N#define SCB_ISAR3_TRUENOP_INSTRS3                ((uint32_t)0x08000000)          /*!< TRUENOP_INSTRS Bit 3 */
N#define SCB_ISAR3_TRUENOP_INSTRS_0               ((uint32_t)0x00000000)          /*!< true NOP instructions not present - that is, NOP instructions with no  */
N                                                                                 /* register dependencies */
N#define SCB_ISAR3_TRUENOP_INSTRS_1               ((uint32_t)0x01000000)          /*!< adds "true NOP", and the capability of additional "NOP compatible hints" */
N/* SCB_ISAR4[UNPRIV_INSTRS] Bits */
N#define SCB_ISAR4_UNPRIV_INSTRS_OFS              ( 0)                            /*!< UNPRIV_INSTRS Bit Offset */
N#define SCB_ISAR4_UNPRIV_INSTRS_MASK             ((uint32_t)0x0000000F)          /*!< UNPRIV_INSTRS Bit Mask */
N#define SCB_ISAR4_UNPRIV_INSTRS0                 ((uint32_t)0x00000001)          /*!< UNPRIV_INSTRS Bit 0 */
N#define SCB_ISAR4_UNPRIV_INSTRS1                 ((uint32_t)0x00000002)          /*!< UNPRIV_INSTRS Bit 1 */
N#define SCB_ISAR4_UNPRIV_INSTRS2                 ((uint32_t)0x00000004)          /*!< UNPRIV_INSTRS Bit 2 */
N#define SCB_ISAR4_UNPRIV_INSTRS3                 ((uint32_t)0x00000008)          /*!< UNPRIV_INSTRS Bit 3 */
N#define SCB_ISAR4_UNPRIV_INSTRS_0                ((uint32_t)0x00000000)          /*!< no "T variant" instructions exist */
N#define SCB_ISAR4_UNPRIV_INSTRS_1                ((uint32_t)0x00000001)          /*!< adds LDRBT, LDRT, STRBT, STRT */
N#define SCB_ISAR4_UNPRIV_INSTRS_2                ((uint32_t)0x00000002)          /*!< adds LDRHT, LDRSBT, LDRSHT, STRHT */
N/* SCB_ISAR4[WITHSHIFTS_INSTRS] Bits */
N#define SCB_ISAR4_WITHSHIFTS_INSTRS_OFS          ( 4)                            /*!< WITHSHIFTS_INSTRS Bit Offset */
N#define SCB_ISAR4_WITHSHIFTS_INSTRS_MASK         ((uint32_t)0x000000F0)          /*!< WITHSHIFTS_INSTRS Bit Mask */
N#define SCB_ISAR4_WITHSHIFTS_INSTRS0             ((uint32_t)0x00000010)          /*!< WITHSHIFTS_INSTRS Bit 0 */
N#define SCB_ISAR4_WITHSHIFTS_INSTRS1             ((uint32_t)0x00000020)          /*!< WITHSHIFTS_INSTRS Bit 1 */
N#define SCB_ISAR4_WITHSHIFTS_INSTRS2             ((uint32_t)0x00000040)          /*!< WITHSHIFTS_INSTRS Bit 2 */
N#define SCB_ISAR4_WITHSHIFTS_INSTRS3             ((uint32_t)0x00000080)          /*!< WITHSHIFTS_INSTRS Bit 3 */
N#define SCB_ISAR4_WITHSHIFTS_INSTRS_0            ((uint32_t)0x00000000)          /*!< non-zero shifts only support MOV and shift instructions (see notes) */
N#define SCB_ISAR4_WITHSHIFTS_INSTRS_1            ((uint32_t)0x00000010)          /*!< shifts of loads/stores over the range LSL 0-3 */
N#define SCB_ISAR4_WITHSHIFTS_INSTRS_3            ((uint32_t)0x00000030)          /*!< adds other constant shift options. */
N#define SCB_ISAR4_WITHSHIFTS_INSTRS_4            ((uint32_t)0x00000040)          /*!< adds register-controlled shift options. */
N/* SCB_ISAR4[WRITEBACK_INSTRS] Bits */
N#define SCB_ISAR4_WRITEBACK_INSTRS_OFS           ( 8)                            /*!< WRITEBACK_INSTRS Bit Offset */
N#define SCB_ISAR4_WRITEBACK_INSTRS_MASK          ((uint32_t)0x00000F00)          /*!< WRITEBACK_INSTRS Bit Mask */
N#define SCB_ISAR4_WRITEBACK_INSTRS0              ((uint32_t)0x00000100)          /*!< WRITEBACK_INSTRS Bit 0 */
N#define SCB_ISAR4_WRITEBACK_INSTRS1              ((uint32_t)0x00000200)          /*!< WRITEBACK_INSTRS Bit 1 */
N#define SCB_ISAR4_WRITEBACK_INSTRS2              ((uint32_t)0x00000400)          /*!< WRITEBACK_INSTRS Bit 2 */
N#define SCB_ISAR4_WRITEBACK_INSTRS3              ((uint32_t)0x00000800)          /*!< WRITEBACK_INSTRS Bit 3 */
N#define SCB_ISAR4_WRITEBACK_INSTRS_0             ((uint32_t)0x00000000)          /*!< only non-writeback addressing modes present, except that  */
N                                                                                 /* LDMIA/STMDB/PUSH/POP instructions support writeback addressing. */
N#define SCB_ISAR4_WRITEBACK_INSTRS_1             ((uint32_t)0x00000100)          /*!< adds all currently-defined writeback addressing modes (ARMv7, Thumb-2) */
N/* SCB_ISAR4[BARRIER_INSTRS] Bits */
N#define SCB_ISAR4_BARRIER_INSTRS_OFS             (16)                            /*!< BARRIER_INSTRS Bit Offset */
N#define SCB_ISAR4_BARRIER_INSTRS_MASK            ((uint32_t)0x000F0000)          /*!< BARRIER_INSTRS Bit Mask */
N#define SCB_ISAR4_BARRIER_INSTRS0                ((uint32_t)0x00010000)          /*!< BARRIER_INSTRS Bit 0 */
N#define SCB_ISAR4_BARRIER_INSTRS1                ((uint32_t)0x00020000)          /*!< BARRIER_INSTRS Bit 1 */
N#define SCB_ISAR4_BARRIER_INSTRS2                ((uint32_t)0x00040000)          /*!< BARRIER_INSTRS Bit 2 */
N#define SCB_ISAR4_BARRIER_INSTRS3                ((uint32_t)0x00080000)          /*!< BARRIER_INSTRS Bit 3 */
N#define SCB_ISAR4_BARRIER_INSTRS_0               ((uint32_t)0x00000000)          /*!< no barrier instructions supported */
N#define SCB_ISAR4_BARRIER_INSTRS_1               ((uint32_t)0x00010000)          /*!< adds DMB, DSB, ISB barrier instructions */
N/* SCB_ISAR4[SYNCPRIM_INSTRS_FRAC] Bits */
N#define SCB_ISAR4_SYNCPRIM_INSTRS_FRAC_OFS       (20)                            /*!< SYNCPRIM_INSTRS_FRAC Bit Offset */
N#define SCB_ISAR4_SYNCPRIM_INSTRS_FRAC_MASK      ((uint32_t)0x00F00000)          /*!< SYNCPRIM_INSTRS_FRAC Bit Mask */
N#define SCB_ISAR4_SYNCPRIM_INSTRS_FRAC0          ((uint32_t)0x00100000)          /*!< SYNCPRIM_INSTRS_FRAC Bit 0 */
N#define SCB_ISAR4_SYNCPRIM_INSTRS_FRAC1          ((uint32_t)0x00200000)          /*!< SYNCPRIM_INSTRS_FRAC Bit 1 */
N#define SCB_ISAR4_SYNCPRIM_INSTRS_FRAC2          ((uint32_t)0x00400000)          /*!< SYNCPRIM_INSTRS_FRAC Bit 2 */
N#define SCB_ISAR4_SYNCPRIM_INSTRS_FRAC3          ((uint32_t)0x00800000)          /*!< SYNCPRIM_INSTRS_FRAC Bit 3 */
N#define SCB_ISAR4_SYNCPRIM_INSTRS_FRAC_0         ((uint32_t)0x00000000)          /*!< no additional support */
N#define SCB_ISAR4_SYNCPRIM_INSTRS_FRAC_3         ((uint32_t)0x00300000)          /*!< adds CLREX, LDREXB, STREXB, LDREXH, STREXH */
N/* SCB_ISAR4[PSR_M_INSTRS] Bits */
N#define SCB_ISAR4_PSR_M_INSTRS_OFS               (24)                            /*!< PSR_M_INSTRS Bit Offset */
N#define SCB_ISAR4_PSR_M_INSTRS_MASK              ((uint32_t)0x0F000000)          /*!< PSR_M_INSTRS Bit Mask */
N#define SCB_ISAR4_PSR_M_INSTRS0                  ((uint32_t)0x01000000)          /*!< PSR_M_INSTRS Bit 0 */
N#define SCB_ISAR4_PSR_M_INSTRS1                  ((uint32_t)0x02000000)          /*!< PSR_M_INSTRS Bit 1 */
N#define SCB_ISAR4_PSR_M_INSTRS2                  ((uint32_t)0x04000000)          /*!< PSR_M_INSTRS Bit 2 */
N#define SCB_ISAR4_PSR_M_INSTRS3                  ((uint32_t)0x08000000)          /*!< PSR_M_INSTRS Bit 3 */
N#define SCB_ISAR4_PSR_M_INSTRS_0                 ((uint32_t)0x00000000)          /*!< instructions not present */
N#define SCB_ISAR4_PSR_M_INSTRS_1                 ((uint32_t)0x01000000)          /*!< adds CPS, MRS, and MSR instructions (M-profile forms) */
N/* SCB_CPACR[CP11] Bits */
N#define SCB_CPACR_CP11_OFS                       (22)                            /*!< CP11 Bit Offset */
N#define SCB_CPACR_CP11_MASK                      ((uint32_t)0x00C00000)          /*!< CP11 Bit Mask */
N/* SCB_CPACR[CP10] Bits */
N#define SCB_CPACR_CP10_OFS                       (20)                            /*!< CP10 Bit Offset */
N#define SCB_CPACR_CP10_MASK                      ((uint32_t)0x00300000)          /*!< CP10 Bit Mask */
N/* SCB_SHPR1[SCB_SHPR1_PRI_4] Bits */
N#define SCB_SHPR1_PRI_4_OFS                      ( 0)                            /*!< PRI_4 Offset */
N#define SCB_SHPR1_PRI_4_M                        ((uint32_t)0x000000ff)          /*  */
N/* SCB_SHPR1[SCB_SHPR1_PRI_5] Bits */
N#define SCB_SHPR1_PRI_5_OFS                      ( 8)                            /*!< PRI_5 Offset */
N#define SCB_SHPR1_PRI_5_M                        ((uint32_t)0x0000ff00)          /*  */
N/* SCB_SHPR1[SCB_SHPR1_PRI_6] Bits */
N#define SCB_SHPR1_PRI_6_OFS                      (16)                            /*!< PRI_6 Offset */
N#define SCB_SHPR1_PRI_6_M                        ((uint32_t)0x00ff0000)          /*  */
N/* SCB_SHPR1[SCB_SHPR1_PRI_7] Bits */
N#define SCB_SHPR1_PRI_7_OFS                      (24)                            /*!< PRI_7 Offset */
N#define SCB_SHPR1_PRI_7_M                        ((uint32_t)0xff000000)          /*  */
N/* SCB_SHPR2[SCB_SHPR2_PRI_8] Bits */
N#define SCB_SHPR2_PRI_8_OFS                      ( 0)                            /*!< PRI_8 Offset */
N#define SCB_SHPR2_PRI_8_M                        ((uint32_t)0x000000ff)          /*  */
N/* SCB_SHPR2[SCB_SHPR2_PRI_9] Bits */
N#define SCB_SHPR2_PRI_9_OFS                      ( 8)                            /*!< PRI_9 Offset */
N#define SCB_SHPR2_PRI_9_M                        ((uint32_t)0x0000ff00)          /*  */
N/* SCB_SHPR2[SCB_SHPR2_PRI_10] Bits */
N#define SCB_SHPR2_PRI_10_OFS                     (16)                            /*!< PRI_10 Offset */
N#define SCB_SHPR2_PRI_10_M                       ((uint32_t)0x00ff0000)          /*  */
N/* SCB_SHPR2[SCB_SHPR2_PRI_11] Bits */
N#define SCB_SHPR2_PRI_11_OFS                     (24)                            /*!< PRI_11 Offset */
N#define SCB_SHPR2_PRI_11_M                       ((uint32_t)0xff000000)          /*  */
N/* SCB_SHPR3[SCB_SHPR3_PRI_12] Bits */
N#define SCB_SHPR3_PRI_12_OFS                     ( 0)                            /*!< PRI_12 Offset */
N#define SCB_SHPR3_PRI_12_M                       ((uint32_t)0x000000ff)          /*  */
N/* SCB_SHPR3[SCB_SHPR3_PRI_13] Bits */
N#define SCB_SHPR3_PRI_13_OFS                     ( 8)                            /*!< PRI_13 Offset */
N#define SCB_SHPR3_PRI_13_M                       ((uint32_t)0x0000ff00)          /*  */
N/* SCB_SHPR3[SCB_SHPR3_PRI_14] Bits */
N#define SCB_SHPR3_PRI_14_OFS                     (16)                            /*!< PRI_14 Offset */
N#define SCB_SHPR3_PRI_14_M                       ((uint32_t)0x00ff0000)          /*  */
N/* SCB_SHPR3[SCB_SHPR3_PRI_15] Bits */
N#define SCB_SHPR3_PRI_15_OFS                     (24)                            /*!< PRI_15 Offset */
N#define SCB_SHPR3_PRI_15_M                       ((uint32_t)0xff000000)          /*  */
N
N/* SCB_CFSR[SCB_CFSR_IACCVIOL] Bits */
N#define SCB_CFSR_IACCVIOL_OFS                    ( 0)                            /*!< IACCVIOL Offset */
N#define SCB_CFSR_IACCVIOL                        ((uint32_t)0x00000001)          /*  */
N/* SCB_CFSR[SCB_CFSR_DACCVIOL] Bits */
N#define SCB_CFSR_DACCVIOL_OFS                    ( 1)                            /*!< DACCVIOL Offset */
N#define SCB_CFSR_DACCVIOL                        ((uint32_t)0x00000002)          /*  */
N/* SCB_CFSR[SCB_CFSR_MUNSTKERR] Bits */
N#define SCB_CFSR_MUNSTKERR_OFS                   ( 3)                            /*!< MUNSTKERR Offset */
N#define SCB_CFSR_MUNSTKERR                       ((uint32_t)0x00000008)          /*  */
N/* SCB_CFSR[SCB_CFSR_MSTKERR] Bits */
N#define SCB_CFSR_MSTKERR_OFS                     ( 4)                            /*!< MSTKERR Offset */
N#define SCB_CFSR_MSTKERR                         ((uint32_t)0x00000010)          /*  */
N/* SCB_CFSR[SCB_CFSR_MMARVALID] Bits */
N#define SCB_CFSR_MMARVALID_OFS                   ( 7)                            /*!< MMARVALID Offset */
N#define SCB_CFSR_MMARVALID                       ((uint32_t)0x00000080)          /*  */
N/* SCB_CFSR[SCB_CFSR_IBUSERR] Bits */
N#define SCB_CFSR_IBUSERR_OFS                     ( 8)                            /*!< IBUSERR Offset */
N#define SCB_CFSR_IBUSERR                         ((uint32_t)0x00000100)          /*  */
N/* SCB_CFSR[SCB_CFSR_PRECISERR] Bits */
N#define SCB_CFSR_PRECISERR_OFS                   ( 9)                            /*!< PRECISERR Offset */
N#define SCB_CFSR_PRECISERR                       ((uint32_t)0x00000200)          /*  */
N/* SCB_CFSR[SCB_CFSR_IMPRECISERR] Bits */
N#define SCB_CFSR_IMPRECISERR_OFS                 (10)                            /*!< IMPRECISERR Offset */
N#define SCB_CFSR_IMPRECISERR                     ((uint32_t)0x00000400)          /*  */
N/* SCB_CFSR[SCB_CFSR_UNSTKERR] Bits */
N#define SCB_CFSR_UNSTKERR_OFS                    (11)                            /*!< UNSTKERR Offset */
N#define SCB_CFSR_UNSTKERR                        ((uint32_t)0x00000800)          /*  */
N/* SCB_CFSR[SCB_CFSR_STKERR] Bits */
N#define SCB_CFSR_STKERR_OFS                      (12)                            /*!< STKERR Offset */
N#define SCB_CFSR_STKERR                          ((uint32_t)0x00001000)          /*  */
N/* SCB_CFSR[SCB_CFSR_BFARVALID] Bits */
N#define SCB_CFSR_BFARVALID_OFS                   (15)                            /*!< BFARVALID Offset */
N#define SCB_CFSR_BFARVALID                       ((uint32_t)0x00008000)          /*  */
N/* SCB_CFSR[SCB_CFSR_UNDEFINSTR] Bits */
N#define SCB_CFSR_UNDEFINSTR_OFS                  (16)                            /*!< UNDEFINSTR Offset */
N#define SCB_CFSR_UNDEFINSTR                      ((uint32_t)0x00010000)          /*  */
N/* SCB_CFSR[SCB_CFSR_INVSTATE] Bits */
N#define SCB_CFSR_INVSTATE_OFS                    (17)                            /*!< INVSTATE Offset */
N#define SCB_CFSR_INVSTATE                        ((uint32_t)0x00020000)          /*  */
N/* SCB_CFSR[SCB_CFSR_INVPC] Bits */
N#define SCB_CFSR_INVPC_OFS                       (18)                            /*!< INVPC Offset */
N#define SCB_CFSR_INVPC                           ((uint32_t)0x00040000)          /*  */
N/* SCB_CFSR[SCB_CFSR_NOCP] Bits */
N#define SCB_CFSR_NOCP_OFS                        (19)                            /*!< NOCP Offset */
N#define SCB_CFSR_NOCP                            ((uint32_t)0x00080000)          /*  */
N/* SCB_CFSR[SCB_CFSR_UNALIGNED] Bits */
N#define SCB_CFSR_UNALIGNED_OFS                   (24)                            /*!< UNALIGNED Offset */
N#define SCB_CFSR_UNALIGNED                       ((uint32_t)0x01000000)          /*  */
N/* SCB_CFSR[SCB_CFSR_DIVBYZERO] Bits */
N#define SCB_CFSR_DIVBYZERO_OFS                   (25)                            /*!< DIVBYZERO Offset */
N#define SCB_CFSR_DIVBYZERO                       ((uint32_t)0x02000000)          /*  */
N/* SCB_CFSR[SCB_CFSR_MLSPERR] Bits */
N#define SCB_CFSR_MLSPERR_OFS                     ( 5)                            /*!< MLSPERR Offset */
N#define SCB_CFSR_MLSPERR                         ((uint32_t)0x00000020)          /*  */
N/* SCB_CFSR[SCB_CFSR_LSPERR] Bits */
N#define SCB_CFSR_LSPERR_OFS                      (13)                            /*!< LSPERR Offset */
N#define SCB_CFSR_LSPERR                          ((uint32_t)0x00002000)          /*  */
N
N
N/******************************************************************************
N* SCNSCB Bits
N******************************************************************************/
N
N
N/******************************************************************************
N* SYSCTL Bits
N******************************************************************************/
N/* SYSCTL_REBOOT_CTL[REBOOT] Bits */
N#define SYSCTL_REBOOT_CTL_REBOOT_OFS             ( 0)                            /*!< REBOOT Bit Offset */
N#define SYSCTL_REBOOT_CTL_REBOOT                 ((uint32_t)0x00000001)          /*!< Write 1 initiates a Reboot of the device */
N/* SYSCTL_REBOOT_CTL[WKEY] Bits */
N#define SYSCTL_REBOOT_CTL_WKEY_OFS               ( 8)                            /*!< WKEY Bit Offset */
N#define SYSCTL_REBOOT_CTL_WKEY_MASK              ((uint32_t)0x0000FF00)          /*!< WKEY Bit Mask */
N/* SYSCTL_NMI_CTLSTAT[CS_SRC] Bits */
N#define SYSCTL_NMI_CTLSTAT_CS_SRC_OFS            ( 0)                            /*!< CS_SRC Bit Offset */
N#define SYSCTL_NMI_CTLSTAT_CS_SRC                ((uint32_t)0x00000001)          /*!< CS interrupt as a source of NMI */
N/* SYSCTL_NMI_CTLSTAT[PSS_SRC] Bits */
N#define SYSCTL_NMI_CTLSTAT_PSS_SRC_OFS           ( 1)                            /*!< PSS_SRC Bit Offset */
N#define SYSCTL_NMI_CTLSTAT_PSS_SRC               ((uint32_t)0x00000002)          /*!< PSS interrupt as a source of NMI */
N/* SYSCTL_NMI_CTLSTAT[PCM_SRC] Bits */
N#define SYSCTL_NMI_CTLSTAT_PCM_SRC_OFS           ( 2)                            /*!< PCM_SRC Bit Offset */
N#define SYSCTL_NMI_CTLSTAT_PCM_SRC               ((uint32_t)0x00000004)          /*!< PCM interrupt as a source of NMI */
N/* SYSCTL_NMI_CTLSTAT[PIN_SRC] Bits */
N#define SYSCTL_NMI_CTLSTAT_PIN_SRC_OFS           ( 3)                            /*!< PIN_SRC Bit Offset */
N#define SYSCTL_NMI_CTLSTAT_PIN_SRC               ((uint32_t)0x00000008)          
N/* SYSCTL_NMI_CTLSTAT[CS_FLG] Bits */
N#define SYSCTL_NMI_CTLSTAT_CS_FLG_OFS            (16)                            /*!< CS_FLG Bit Offset */
N#define SYSCTL_NMI_CTLSTAT_CS_FLG                ((uint32_t)0x00010000)          /*!< CS interrupt was the source of NMI */
N/* SYSCTL_NMI_CTLSTAT[PSS_FLG] Bits */
N#define SYSCTL_NMI_CTLSTAT_PSS_FLG_OFS           (17)                            /*!< PSS_FLG Bit Offset */
N#define SYSCTL_NMI_CTLSTAT_PSS_FLG               ((uint32_t)0x00020000)          /*!< PSS interrupt was the source of NMI */
N/* SYSCTL_NMI_CTLSTAT[PCM_FLG] Bits */
N#define SYSCTL_NMI_CTLSTAT_PCM_FLG_OFS           (18)                            /*!< PCM_FLG Bit Offset */
N#define SYSCTL_NMI_CTLSTAT_PCM_FLG               ((uint32_t)0x00040000)          /*!< PCM interrupt was the source of NMI */
N/* SYSCTL_NMI_CTLSTAT[PIN_FLG] Bits */
N#define SYSCTL_NMI_CTLSTAT_PIN_FLG_OFS           (19)                            /*!< PIN_FLG Bit Offset */
N#define SYSCTL_NMI_CTLSTAT_PIN_FLG               ((uint32_t)0x00080000)          /*!< RSTn/NMI pin was the source of NMI */
N/* SYSCTL_WDTRESET_CTL[TIMEOUT] Bits */
N#define SYSCTL_WDTRESET_CTL_TIMEOUT_OFS          ( 0)                            /*!< TIMEOUT Bit Offset */
N#define SYSCTL_WDTRESET_CTL_TIMEOUT              ((uint32_t)0x00000001)          /*!< WDT timeout reset type */
N/* SYSCTL_WDTRESET_CTL[VIOLATION] Bits */
N#define SYSCTL_WDTRESET_CTL_VIOLATION_OFS        ( 1)                            /*!< VIOLATION Bit Offset */
N#define SYSCTL_WDTRESET_CTL_VIOLATION            ((uint32_t)0x00000002)          /*!< WDT password violation reset type */
N/* SYSCTL_PERIHALT_CTL[HALT_T16_0] Bits */
N#define SYSCTL_PERIHALT_CTL_HALT_T16_0_OFS       ( 0)                            /*!< HALT_T16_0 Bit Offset */
N#define SYSCTL_PERIHALT_CTL_HALT_T16_0           ((uint32_t)0x00000001)          /*!< Freezes IP operation when CPU is halted */
N/* SYSCTL_PERIHALT_CTL[HALT_T16_1] Bits */
N#define SYSCTL_PERIHALT_CTL_HALT_T16_1_OFS       ( 1)                            /*!< HALT_T16_1 Bit Offset */
N#define SYSCTL_PERIHALT_CTL_HALT_T16_1           ((uint32_t)0x00000002)          /*!< Freezes IP operation when CPU is halted */
N/* SYSCTL_PERIHALT_CTL[HALT_T16_2] Bits */
N#define SYSCTL_PERIHALT_CTL_HALT_T16_2_OFS       ( 2)                            /*!< HALT_T16_2 Bit Offset */
N#define SYSCTL_PERIHALT_CTL_HALT_T16_2           ((uint32_t)0x00000004)          /*!< Freezes IP operation when CPU is halted */
N/* SYSCTL_PERIHALT_CTL[HALT_T16_3] Bits */
N#define SYSCTL_PERIHALT_CTL_HALT_T16_3_OFS       ( 3)                            /*!< HALT_T16_3 Bit Offset */
N#define SYSCTL_PERIHALT_CTL_HALT_T16_3           ((uint32_t)0x00000008)          /*!< Freezes IP operation when CPU is halted */
N/* SYSCTL_PERIHALT_CTL[HALT_T32_0] Bits */
N#define SYSCTL_PERIHALT_CTL_HALT_T32_0_OFS       ( 4)                            /*!< HALT_T32_0 Bit Offset */
N#define SYSCTL_PERIHALT_CTL_HALT_T32_0           ((uint32_t)0x00000010)          /*!< Freezes IP operation when CPU is halted */
N/* SYSCTL_PERIHALT_CTL[HALT_eUA0] Bits */
N#define SYSCTL_PERIHALT_CTL_HALT_EUA0_OFS        ( 5)                            /*!< HALT_eUA0 Bit Offset */
N#define SYSCTL_PERIHALT_CTL_HALT_EUA0            ((uint32_t)0x00000020)          /*!< Freezes IP operation when CPU is halted */
N/* SYSCTL_PERIHALT_CTL[HALT_eUA1] Bits */
N#define SYSCTL_PERIHALT_CTL_HALT_EUA1_OFS        ( 6)                            /*!< HALT_eUA1 Bit Offset */
N#define SYSCTL_PERIHALT_CTL_HALT_EUA1            ((uint32_t)0x00000040)          /*!< Freezes IP operation when CPU is halted */
N/* SYSCTL_PERIHALT_CTL[HALT_eUA2] Bits */
N#define SYSCTL_PERIHALT_CTL_HALT_EUA2_OFS        ( 7)                            /*!< HALT_eUA2 Bit Offset */
N#define SYSCTL_PERIHALT_CTL_HALT_EUA2            ((uint32_t)0x00000080)          /*!< Freezes IP operation when CPU is halted */
N/* SYSCTL_PERIHALT_CTL[HALT_eUA3] Bits */
N#define SYSCTL_PERIHALT_CTL_HALT_EUA3_OFS        ( 8)                            /*!< HALT_eUA3 Bit Offset */
N#define SYSCTL_PERIHALT_CTL_HALT_EUA3            ((uint32_t)0x00000100)          /*!< Freezes IP operation when CPU is halted */
N/* SYSCTL_PERIHALT_CTL[HALT_eUB0] Bits */
N#define SYSCTL_PERIHALT_CTL_HALT_EUB0_OFS        ( 9)                            /*!< HALT_eUB0 Bit Offset */
N#define SYSCTL_PERIHALT_CTL_HALT_EUB0            ((uint32_t)0x00000200)          /*!< Freezes IP operation when CPU is halted */
N/* SYSCTL_PERIHALT_CTL[HALT_eUB1] Bits */
N#define SYSCTL_PERIHALT_CTL_HALT_EUB1_OFS        (10)                            /*!< HALT_eUB1 Bit Offset */
N#define SYSCTL_PERIHALT_CTL_HALT_EUB1            ((uint32_t)0x00000400)          /*!< Freezes IP operation when CPU is halted */
N/* SYSCTL_PERIHALT_CTL[HALT_eUB2] Bits */
N#define SYSCTL_PERIHALT_CTL_HALT_EUB2_OFS        (11)                            /*!< HALT_eUB2 Bit Offset */
N#define SYSCTL_PERIHALT_CTL_HALT_EUB2            ((uint32_t)0x00000800)          /*!< Freezes IP operation when CPU is halted */
N/* SYSCTL_PERIHALT_CTL[HALT_eUB3] Bits */
N#define SYSCTL_PERIHALT_CTL_HALT_EUB3_OFS        (12)                            /*!< HALT_eUB3 Bit Offset */
N#define SYSCTL_PERIHALT_CTL_HALT_EUB3            ((uint32_t)0x00001000)          /*!< Freezes IP operation when CPU is halted */
N/* SYSCTL_PERIHALT_CTL[HALT_ADC] Bits */
N#define SYSCTL_PERIHALT_CTL_HALT_ADC_OFS         (13)                            /*!< HALT_ADC Bit Offset */
N#define SYSCTL_PERIHALT_CTL_HALT_ADC             ((uint32_t)0x00002000)          /*!< Freezes IP operation when CPU is halted */
N/* SYSCTL_PERIHALT_CTL[HALT_WDT] Bits */
N#define SYSCTL_PERIHALT_CTL_HALT_WDT_OFS         (14)                            /*!< HALT_WDT Bit Offset */
N#define SYSCTL_PERIHALT_CTL_HALT_WDT             ((uint32_t)0x00004000)          /*!< Freezes IP operation when CPU is halted */
N/* SYSCTL_PERIHALT_CTL[HALT_DMA] Bits */
N#define SYSCTL_PERIHALT_CTL_HALT_DMA_OFS         (15)                            /*!< HALT_DMA Bit Offset */
N#define SYSCTL_PERIHALT_CTL_HALT_DMA             ((uint32_t)0x00008000)          /*!< Freezes IP operation when CPU is halted */
N/* SYSCTL_SRAM_BANKEN[BNK0_EN] Bits */
N#define SYSCTL_SRAM_BANKEN_BNK0_EN_OFS           ( 0)                            /*!< BNK0_EN Bit Offset */
N#define SYSCTL_SRAM_BANKEN_BNK0_EN               ((uint32_t)0x00000001)          /*!< SRAM Bank0 enable */
N/* SYSCTL_SRAM_BANKEN[BNK1_EN] Bits */
N#define SYSCTL_SRAM_BANKEN_BNK1_EN_OFS           ( 1)                            /*!< BNK1_EN Bit Offset */
N#define SYSCTL_SRAM_BANKEN_BNK1_EN               ((uint32_t)0x00000002)          /*!< SRAM Bank1 enable */
N/* SYSCTL_SRAM_BANKEN[BNK2_EN] Bits */
N#define SYSCTL_SRAM_BANKEN_BNK2_EN_OFS           ( 2)                            /*!< BNK2_EN Bit Offset */
N#define SYSCTL_SRAM_BANKEN_BNK2_EN               ((uint32_t)0x00000004)          /*!< SRAM Bank1 enable */
N/* SYSCTL_SRAM_BANKEN[BNK3_EN] Bits */
N#define SYSCTL_SRAM_BANKEN_BNK3_EN_OFS           ( 3)                            /*!< BNK3_EN Bit Offset */
N#define SYSCTL_SRAM_BANKEN_BNK3_EN               ((uint32_t)0x00000008)          /*!< SRAM Bank1 enable */
N/* SYSCTL_SRAM_BANKEN[BNK4_EN] Bits */
N#define SYSCTL_SRAM_BANKEN_BNK4_EN_OFS           ( 4)                            /*!< BNK4_EN Bit Offset */
N#define SYSCTL_SRAM_BANKEN_BNK4_EN               ((uint32_t)0x00000010)          /*!< SRAM Bank1 enable */
N/* SYSCTL_SRAM_BANKEN[BNK5_EN] Bits */
N#define SYSCTL_SRAM_BANKEN_BNK5_EN_OFS           ( 5)                            /*!< BNK5_EN Bit Offset */
N#define SYSCTL_SRAM_BANKEN_BNK5_EN               ((uint32_t)0x00000020)          /*!< SRAM Bank1 enable */
N/* SYSCTL_SRAM_BANKEN[BNK6_EN] Bits */
N#define SYSCTL_SRAM_BANKEN_BNK6_EN_OFS           ( 6)                            /*!< BNK6_EN Bit Offset */
N#define SYSCTL_SRAM_BANKEN_BNK6_EN               ((uint32_t)0x00000040)          /*!< SRAM Bank1 enable */
N/* SYSCTL_SRAM_BANKEN[BNK7_EN] Bits */
N#define SYSCTL_SRAM_BANKEN_BNK7_EN_OFS           ( 7)                            /*!< BNK7_EN Bit Offset */
N#define SYSCTL_SRAM_BANKEN_BNK7_EN               ((uint32_t)0x00000080)          /*!< SRAM Bank1 enable */
N/* SYSCTL_SRAM_BANKEN[SRAM_RDY] Bits */
N#define SYSCTL_SRAM_BANKEN_SRAM_RDY_OFS          (16)                            /*!< SRAM_RDY Bit Offset */
N#define SYSCTL_SRAM_BANKEN_SRAM_RDY              ((uint32_t)0x00010000)          /*!< SRAM ready */
N/* SYSCTL_SRAM_BANKRET[BNK0_RET] Bits */
N#define SYSCTL_SRAM_BANKRET_BNK0_RET_OFS         ( 0)                            /*!< BNK0_RET Bit Offset */
N#define SYSCTL_SRAM_BANKRET_BNK0_RET             ((uint32_t)0x00000001)          /*!< Bank0 retention */
N/* SYSCTL_SRAM_BANKRET[BNK1_RET] Bits */
N#define SYSCTL_SRAM_BANKRET_BNK1_RET_OFS         ( 1)                            /*!< BNK1_RET Bit Offset */
N#define SYSCTL_SRAM_BANKRET_BNK1_RET             ((uint32_t)0x00000002)          /*!< Bank1 retention */
N/* SYSCTL_SRAM_BANKRET[BNK2_RET] Bits */
N#define SYSCTL_SRAM_BANKRET_BNK2_RET_OFS         ( 2)                            /*!< BNK2_RET Bit Offset */
N#define SYSCTL_SRAM_BANKRET_BNK2_RET             ((uint32_t)0x00000004)          /*!< Bank2 retention */
N/* SYSCTL_SRAM_BANKRET[BNK3_RET] Bits */
N#define SYSCTL_SRAM_BANKRET_BNK3_RET_OFS         ( 3)                            /*!< BNK3_RET Bit Offset */
N#define SYSCTL_SRAM_BANKRET_BNK3_RET             ((uint32_t)0x00000008)          /*!< Bank3 retention */
N/* SYSCTL_SRAM_BANKRET[BNK4_RET] Bits */
N#define SYSCTL_SRAM_BANKRET_BNK4_RET_OFS         ( 4)                            /*!< BNK4_RET Bit Offset */
N#define SYSCTL_SRAM_BANKRET_BNK4_RET             ((uint32_t)0x00000010)          /*!< Bank4 retention */
N/* SYSCTL_SRAM_BANKRET[BNK5_RET] Bits */
N#define SYSCTL_SRAM_BANKRET_BNK5_RET_OFS         ( 5)                            /*!< BNK5_RET Bit Offset */
N#define SYSCTL_SRAM_BANKRET_BNK5_RET             ((uint32_t)0x00000020)          /*!< Bank5 retention */
N/* SYSCTL_SRAM_BANKRET[BNK6_RET] Bits */
N#define SYSCTL_SRAM_BANKRET_BNK6_RET_OFS         ( 6)                            /*!< BNK6_RET Bit Offset */
N#define SYSCTL_SRAM_BANKRET_BNK6_RET             ((uint32_t)0x00000040)          /*!< Bank6 retention */
N/* SYSCTL_SRAM_BANKRET[BNK7_RET] Bits */
N#define SYSCTL_SRAM_BANKRET_BNK7_RET_OFS         ( 7)                            /*!< BNK7_RET Bit Offset */
N#define SYSCTL_SRAM_BANKRET_BNK7_RET             ((uint32_t)0x00000080)          /*!< Bank7 retention */
N/* SYSCTL_SRAM_BANKRET[SRAM_RDY] Bits */
N#define SYSCTL_SRAM_BANKRET_SRAM_RDY_OFS         (16)                            /*!< SRAM_RDY Bit Offset */
N#define SYSCTL_SRAM_BANKRET_SRAM_RDY             ((uint32_t)0x00010000)          /*!< SRAM ready */
N/* SYSCTL_DIO_GLTFLT_CTL[GLTCH_EN] Bits */
N#define SYSCTL_DIO_GLTFLT_CTL_GLTCH_EN_OFS       ( 0)                            /*!< GLTCH_EN Bit Offset */
N#define SYSCTL_DIO_GLTFLT_CTL_GLTCH_EN           ((uint32_t)0x00000001)          /*!< Glitch filter enable */
N/* SYSCTL_SECDATA_UNLOCK[UNLKEY] Bits */
N#define SYSCTL_SECDATA_UNLOCK_UNLKEY_OFS         ( 0)                            /*!< UNLKEY Bit Offset */
N#define SYSCTL_SECDATA_UNLOCK_UNLKEY_MASK        ((uint32_t)0x0000FFFF)          /*!< UNLKEY Bit Mask */
N/* SYSCTL_MASTER_UNLOCK[UNLKEY] Bits */
N#define SYSCTL_MASTER_UNLOCK_UNLKEY_OFS          ( 0)                            /*!< UNLKEY Bit Offset */
N#define SYSCTL_MASTER_UNLOCK_UNLKEY_MASK         ((uint32_t)0x0000FFFF)          /*!< UNLKEY Bit Mask */
N/* SYSCTL_RESET_REQ[POR] Bits */
N#define SYSCTL_RESET_REQ_POR_OFS                 ( 0)                            /*!< POR Bit Offset */
N#define SYSCTL_RESET_REQ_POR                     ((uint32_t)0x00000001)          /*!< Generate POR */
N/* SYSCTL_RESET_REQ[REBOOT] Bits */
N#define SYSCTL_RESET_REQ_REBOOT_OFS              ( 1)                            /*!< REBOOT Bit Offset */
N#define SYSCTL_RESET_REQ_REBOOT                  ((uint32_t)0x00000002)          /*!< Generate Reboot_Reset */
N/* SYSCTL_RESET_REQ[WKEY] Bits */
N#define SYSCTL_RESET_REQ_WKEY_OFS                ( 8)                            /*!< WKEY Bit Offset */
N#define SYSCTL_RESET_REQ_WKEY_MASK               ((uint32_t)0x0000FF00)          /*!< WKEY Bit Mask */
N/* SYSCTL_RESET_STATOVER[SOFT] Bits */
N#define SYSCTL_RESET_STATOVER_SOFT_OFS           ( 0)                            /*!< SOFT Bit Offset */
N#define SYSCTL_RESET_STATOVER_SOFT               ((uint32_t)0x00000001)          /*!< Indicates if SOFT Reset is active */
N/* SYSCTL_RESET_STATOVER[HARD] Bits */
N#define SYSCTL_RESET_STATOVER_HARD_OFS           ( 1)                            /*!< HARD Bit Offset */
N#define SYSCTL_RESET_STATOVER_HARD               ((uint32_t)0x00000002)          /*!< Indicates if HARD Reset is active */
N/* SYSCTL_RESET_STATOVER[REBOOT] Bits */
N#define SYSCTL_RESET_STATOVER_REBOOT_OFS         ( 2)                            /*!< REBOOT Bit Offset */
N#define SYSCTL_RESET_STATOVER_REBOOT             ((uint32_t)0x00000004)          /*!< Indicates if Reboot Reset is active */
N/* SYSCTL_RESET_STATOVER[SOFT_OVER] Bits */
N#define SYSCTL_RESET_STATOVER_SOFT_OVER_OFS      ( 8)                            /*!< SOFT_OVER Bit Offset */
N#define SYSCTL_RESET_STATOVER_SOFT_OVER          ((uint32_t)0x00000100)          /*!< SOFT_Reset overwrite request */
N/* SYSCTL_RESET_STATOVER[HARD_OVER] Bits */
N#define SYSCTL_RESET_STATOVER_HARD_OVER_OFS      ( 9)                            /*!< HARD_OVER Bit Offset */
N#define SYSCTL_RESET_STATOVER_HARD_OVER          ((uint32_t)0x00000200)          /*!< HARD_Reset overwrite request */
N/* SYSCTL_RESET_STATOVER[RBT_OVER] Bits */
N#define SYSCTL_RESET_STATOVER_RBT_OVER_OFS       (10)                            /*!< RBT_OVER Bit Offset */
N#define SYSCTL_RESET_STATOVER_RBT_OVER           ((uint32_t)0x00000400)          /*!< Reboot Reset overwrite request */
N/* Pre-defined bitfield values */
N#define SYSCTL_REBOOT_CTL_WKEY_VAL              ((uint32_t)0x00006900)          /*!< Key value to enable writes to bit 0 */
N                                                                                /* cleared */
N
N
N/******************************************************************************
N* SYSTICK Bits
N******************************************************************************/
N
N/******************************************************************************
N* Timer32 Bits
N******************************************************************************/
N/* TIMER32_CONTROL[ONESHOT] Bits */
N#define TIMER32_CONTROL_ONESHOT_OFS              ( 0)                            /*!< ONESHOT Bit Offset */
N#define TIMER32_CONTROL_ONESHOT                  ((uint32_t)0x00000001)          /*!< Selects one-shot or wrapping counter mode */
N/* TIMER32_CONTROL[SIZE] Bits */
N#define TIMER32_CONTROL_SIZE_OFS                 ( 1)                            /*!< SIZE Bit Offset */
N#define TIMER32_CONTROL_SIZE                     ((uint32_t)0x00000002)          /*!< Selects 16 or 32 bit counter operation */
N/* TIMER32_CONTROL[PRESCALE] Bits */
N#define TIMER32_CONTROL_PRESCALE_OFS             ( 2)                            /*!< PRESCALE Bit Offset */
N#define TIMER32_CONTROL_PRESCALE_MASK            ((uint32_t)0x0000000C)          /*!< PRESCALE Bit Mask */
N#define TIMER32_CONTROL_PRESCALE0                ((uint32_t)0x00000004)          /*!< PRESCALE Bit 0 */
N#define TIMER32_CONTROL_PRESCALE1                ((uint32_t)0x00000008)          /*!< PRESCALE Bit 1 */
N#define TIMER32_CONTROL_PRESCALE_0               ((uint32_t)0x00000000)          /*!< 0 stages of prescale, clock is divided by 1 */
N#define TIMER32_CONTROL_PRESCALE_1               ((uint32_t)0x00000004)          /*!< 4 stages of prescale, clock is divided by 16 */
N#define TIMER32_CONTROL_PRESCALE_2               ((uint32_t)0x00000008)          /*!< 8 stages of prescale, clock is divided by 256 */
N/* TIMER32_CONTROL[IE] Bits */
N#define TIMER32_CONTROL_IE_OFS                   ( 5)                            /*!< IE Bit Offset */
N#define TIMER32_CONTROL_IE                       ((uint32_t)0x00000020)          /*!< Interrupt enable bit */
N/* TIMER32_CONTROL[MODE] Bits */
N#define TIMER32_CONTROL_MODE_OFS                 ( 6)                            /*!< MODE Bit Offset */
N#define TIMER32_CONTROL_MODE                     ((uint32_t)0x00000040)          /*!< Mode bit */
N/* TIMER32_CONTROL[ENABLE] Bits */
N#define TIMER32_CONTROL_ENABLE_OFS               ( 7)                            /*!< ENABLE Bit Offset */
N#define TIMER32_CONTROL_ENABLE                   ((uint32_t)0x00000080)
N/* TIMER32_RIS[RAW_IFG] Bits */
N#define TIMER32_RIS_RAW_IFG_OFS                  ( 0)                            /*!< RAW_IFG Bit Offset */
N#define TIMER32_RIS_RAW_IFG                      ((uint32_t)0x00000001)          /*!< Raw interrupt status */
N/* TIMER32_MIS[IFG] Bits */
N#define TIMER32_MIS_IFG_OFS                      ( 0)                            /*!< IFG Bit Offset */
N#define TIMER32_MIS_IFG                          ((uint32_t)0x00000001)          /*!< Enabled interrupt status */
N
N
N
N/******************************************************************************
N* TIMER_A Bits
N******************************************************************************/
N/* TIMER_A_CTL[IFG] Bits */
N#define TIMER_A_CTL_IFG_OFS                      ( 0)                            /*!< TAIFG Bit Offset */
N#define TIMER_A_CTL_IFG                          ((uint16_t)0x0001)              /*!< TimerA interrupt flag */
N/* TIMER_A_CTL[IE] Bits */
N#define TIMER_A_CTL_IE_OFS                       ( 1)                            /*!< TAIE Bit Offset */
N#define TIMER_A_CTL_IE                           ((uint16_t)0x0002)              /*!< TimerA interrupt enable */
N/* TIMER_A_CTL[CLR] Bits */
N#define TIMER_A_CTL_CLR_OFS                      ( 2)                            /*!< TACLR Bit Offset */
N#define TIMER_A_CTL_CLR                          ((uint16_t)0x0004)              /*!< TimerA clear */
N/* TIMER_A_CTL[MC] Bits */
N#define TIMER_A_CTL_MC_OFS                       ( 4)                            /*!< MC Bit Offset */
N#define TIMER_A_CTL_MC_MASK                      ((uint16_t)0x0030)              /*!< MC Bit Mask */
N#define TIMER_A_CTL_MC0                          ((uint16_t)0x0010)              /*!< MC Bit 0 */
N#define TIMER_A_CTL_MC1                          ((uint16_t)0x0020)              /*!< MC Bit 1 */
N#define TIMER_A_CTL_MC_0                         ((uint16_t)0x0000)              /*!< Stop mode: Timer is halted */
N#define TIMER_A_CTL_MC_1                         ((uint16_t)0x0010)              /*!< Up mode: Timer counts up to TAxCCR0 */
N#define TIMER_A_CTL_MC_2                         ((uint16_t)0x0020)              /*!< Continuous mode: Timer counts up to 0FFFFh */
N#define TIMER_A_CTL_MC_3                         ((uint16_t)0x0030)              /*!< Up/down mode: Timer counts up to TAxCCR0 then down to 0000h */
N#define TIMER_A_CTL_MC__STOP                     ((uint16_t)0x0000)              /*!< Stop mode: Timer is halted */
N#define TIMER_A_CTL_MC__UP                       ((uint16_t)0x0010)              /*!< Up mode: Timer counts up to TAxCCR0 */
N#define TIMER_A_CTL_MC__CONTINUOUS               ((uint16_t)0x0020)              /*!< Continuous mode: Timer counts up to 0FFFFh */
N#define TIMER_A_CTL_MC__UPDOWN                   ((uint16_t)0x0030)              /*!< Up/down mode: Timer counts up to TAxCCR0 then down to 0000h */
N/* TIMER_A_CTL[ID] Bits */
N#define TIMER_A_CTL_ID_OFS                       ( 6)                            /*!< ID Bit Offset */
N#define TIMER_A_CTL_ID_MASK                      ((uint16_t)0x00C0)              /*!< ID Bit Mask */
N#define TIMER_A_CTL_ID0                          ((uint16_t)0x0040)              /*!< ID Bit 0 */
N#define TIMER_A_CTL_ID1                          ((uint16_t)0x0080)              /*!< ID Bit 1 */
N#define TIMER_A_CTL_ID_0                         ((uint16_t)0x0000)              /*!< /1 */
N#define TIMER_A_CTL_ID_1                         ((uint16_t)0x0040)              /*!< /2 */
N#define TIMER_A_CTL_ID_2                         ((uint16_t)0x0080)              /*!< /4 */
N#define TIMER_A_CTL_ID_3                         ((uint16_t)0x00C0)              /*!< /8 */
N#define TIMER_A_CTL_ID__1                        ((uint16_t)0x0000)              /*!< /1 */
N#define TIMER_A_CTL_ID__2                        ((uint16_t)0x0040)              /*!< /2 */
N#define TIMER_A_CTL_ID__4                        ((uint16_t)0x0080)              /*!< /4 */
N#define TIMER_A_CTL_ID__8                        ((uint16_t)0x00C0)              /*!< /8 */
N/* TIMER_A_CTL[SSEL] Bits */
N#define TIMER_A_CTL_SSEL_OFS                     ( 8)                            /*!< TASSEL Bit Offset */
N#define TIMER_A_CTL_SSEL_MASK                    ((uint16_t)0x0300)              /*!< TASSEL Bit Mask */
N#define TIMER_A_CTL_SSEL0                        ((uint16_t)0x0100)              /*!< SSEL Bit 0 */
N#define TIMER_A_CTL_SSEL1                        ((uint16_t)0x0200)              /*!< SSEL Bit 1 */
N#define TIMER_A_CTL_TASSEL_0                     ((uint16_t)0x0000)              /*!< TAxCLK */
N#define TIMER_A_CTL_TASSEL_1                     ((uint16_t)0x0100)              /*!< ACLK */
N#define TIMER_A_CTL_TASSEL_2                     ((uint16_t)0x0200)              /*!< SMCLK */
N#define TIMER_A_CTL_TASSEL_3                     ((uint16_t)0x0300)              /*!< INCLK */
N#define TIMER_A_CTL_SSEL__TACLK                  ((uint16_t)0x0000)              /*!< TAxCLK */
N#define TIMER_A_CTL_SSEL__ACLK                   ((uint16_t)0x0100)              /*!< ACLK */
N#define TIMER_A_CTL_SSEL__SMCLK                  ((uint16_t)0x0200)              /*!< SMCLK */
N#define TIMER_A_CTL_SSEL__INCLK                  ((uint16_t)0x0300)              /*!< INCLK */
N/* TIMER_A_CCTLN[CCIFG] Bits */
N#define TIMER_A_CCTLN_CCIFG_OFS                  ( 0)                            /*!< CCIFG Bit Offset */
N#define TIMER_A_CCTLN_CCIFG                      ((uint16_t)0x0001)              /*!< Capture/compare interrupt flag */
N/* TIMER_A_CCTLN[COV] Bits */
N#define TIMER_A_CCTLN_COV_OFS                    ( 1)                            /*!< COV Bit Offset */
N#define TIMER_A_CCTLN_COV                        ((uint16_t)0x0002)              /*!< Capture overflow */
N/* TIMER_A_CCTLN[OUT] Bits */
N#define TIMER_A_CCTLN_OUT_OFS                    ( 2)                            /*!< OUT Bit Offset */
N#define TIMER_A_CCTLN_OUT                        ((uint16_t)0x0004)              /*!< Output */
N/* TIMER_A_CCTLN[CCI] Bits */
N#define TIMER_A_CCTLN_CCI_OFS                    ( 3)                            /*!< CCI Bit Offset */
N#define TIMER_A_CCTLN_CCI                        ((uint16_t)0x0008)              /*!< Capture/compare input */
N/* TIMER_A_CCTLN[CCIE] Bits */
N#define TIMER_A_CCTLN_CCIE_OFS                   ( 4)                            /*!< CCIE Bit Offset */
N#define TIMER_A_CCTLN_CCIE                       ((uint16_t)0x0010)              /*!< Capture/compare interrupt enable */
N/* TIMER_A_CCTLN[OUTMOD] Bits */
N#define TIMER_A_CCTLN_OUTMOD_OFS                 ( 5)                            /*!< OUTMOD Bit Offset */
N#define TIMER_A_CCTLN_OUTMOD_MASK                ((uint16_t)0x00E0)              /*!< OUTMOD Bit Mask */
N#define TIMER_A_CCTLN_OUTMOD0                    ((uint16_t)0x0020)              /*!< OUTMOD Bit 0 */
N#define TIMER_A_CCTLN_OUTMOD1                    ((uint16_t)0x0040)              /*!< OUTMOD Bit 1 */
N#define TIMER_A_CCTLN_OUTMOD2                    ((uint16_t)0x0080)              /*!< OUTMOD Bit 2 */
N#define TIMER_A_CCTLN_OUTMOD_0                   ((uint16_t)0x0000)              /*!< OUT bit value */
N#define TIMER_A_CCTLN_OUTMOD_1                   ((uint16_t)0x0020)              /*!< Set */
N#define TIMER_A_CCTLN_OUTMOD_2                   ((uint16_t)0x0040)              /*!< Toggle/reset */
N#define TIMER_A_CCTLN_OUTMOD_3                   ((uint16_t)0x0060)              /*!< Set/reset */
N#define TIMER_A_CCTLN_OUTMOD_4                   ((uint16_t)0x0080)              /*!< Toggle */
N#define TIMER_A_CCTLN_OUTMOD_5                   ((uint16_t)0x00A0)              /*!< Reset */
N#define TIMER_A_CCTLN_OUTMOD_6                   ((uint16_t)0x00C0)              /*!< Toggle/set */
N#define TIMER_A_CCTLN_OUTMOD_7                   ((uint16_t)0x00E0)              /*!< Reset/set */
N/* TIMER_A_CCTLN[CAP] Bits */
N#define TIMER_A_CCTLN_CAP_OFS                    ( 8)                            /*!< CAP Bit Offset */
N#define TIMER_A_CCTLN_CAP                        ((uint16_t)0x0100)              /*!< Capture mode */
N/* TIMER_A_CCTLN[SCCI] Bits */
N#define TIMER_A_CCTLN_SCCI_OFS                   (10)                            /*!< SCCI Bit Offset */
N#define TIMER_A_CCTLN_SCCI                       ((uint16_t)0x0400)              /*!< Synchronized capture/compare input */
N/* TIMER_A_CCTLN[SCS] Bits */
N#define TIMER_A_CCTLN_SCS_OFS                    (11)                            /*!< SCS Bit Offset */
N#define TIMER_A_CCTLN_SCS                        ((uint16_t)0x0800)              /*!< Synchronize capture source */
N/* TIMER_A_CCTLN[CCIS] Bits */
N#define TIMER_A_CCTLN_CCIS_OFS                   (12)                            /*!< CCIS Bit Offset */
N#define TIMER_A_CCTLN_CCIS_MASK                  ((uint16_t)0x3000)              /*!< CCIS Bit Mask */
N#define TIMER_A_CCTLN_CCIS0                      ((uint16_t)0x1000)              /*!< CCIS Bit 0 */
N#define TIMER_A_CCTLN_CCIS1                      ((uint16_t)0x2000)              /*!< CCIS Bit 1 */
N#define TIMER_A_CCTLN_CCIS_0                     ((uint16_t)0x0000)              /*!< CCIxA */
N#define TIMER_A_CCTLN_CCIS_1                     ((uint16_t)0x1000)              /*!< CCIxB */
N#define TIMER_A_CCTLN_CCIS_2                     ((uint16_t)0x2000)              /*!< GND */
N#define TIMER_A_CCTLN_CCIS_3                     ((uint16_t)0x3000)              /*!< VCC */
N#define TIMER_A_CCTLN_CCIS__CCIA                 ((uint16_t)0x0000)              /*!< CCIxA */
N#define TIMER_A_CCTLN_CCIS__CCIB                 ((uint16_t)0x1000)              /*!< CCIxB */
N#define TIMER_A_CCTLN_CCIS__GND                  ((uint16_t)0x2000)              /*!< GND */
N#define TIMER_A_CCTLN_CCIS__VCC                  ((uint16_t)0x3000)              /*!< VCC */
N/* TIMER_A_CCTLN[CM] Bits */
N#define TIMER_A_CCTLN_CM_OFS                     (14)                            /*!< CM Bit Offset */
N#define TIMER_A_CCTLN_CM_MASK                    ((uint16_t)0xC000)              /*!< CM Bit Mask */
N#define TIMER_A_CCTLN_CM0                        ((uint16_t)0x4000)              /*!< CM Bit 0 */
N#define TIMER_A_CCTLN_CM1                        ((uint16_t)0x8000)              /*!< CM Bit 1 */
N#define TIMER_A_CCTLN_CM_0                       ((uint16_t)0x0000)              /*!< No capture */
N#define TIMER_A_CCTLN_CM_1                       ((uint16_t)0x4000)              /*!< Capture on rising edge */
N#define TIMER_A_CCTLN_CM_2                       ((uint16_t)0x8000)              /*!< Capture on falling edge */
N#define TIMER_A_CCTLN_CM_3                       ((uint16_t)0xC000)              /*!< Capture on both rising and falling edges */
N#define TIMER_A_CCTLN_CM__NONE                   ((uint16_t)0x0000)              /*!< No capture */
N#define TIMER_A_CCTLN_CM__RISING                 ((uint16_t)0x4000)              /*!< Capture on rising edge */
N#define TIMER_A_CCTLN_CM__FALLING                ((uint16_t)0x8000)              /*!< Capture on falling edge */
N#define TIMER_A_CCTLN_CM__BOTH                   ((uint16_t)0xC000)              /*!< Capture on both rising and falling edges */
N/* TIMER_A_EX0[IDEX] Bits */
N#define TIMER_A_EX0_IDEX_OFS                     ( 0)                            /*!< TAIDEX Bit Offset */
N#define TIMER_A_EX0_IDEX_MASK                    ((uint16_t)0x0007)              /*!< TAIDEX Bit Mask */
N#define TIMER_A_EX0_IDEX0                        ((uint16_t)0x0001)              /*!< IDEX Bit 0 */
N#define TIMER_A_EX0_IDEX1                        ((uint16_t)0x0002)              /*!< IDEX Bit 1 */
N#define TIMER_A_EX0_IDEX2                        ((uint16_t)0x0004)              /*!< IDEX Bit 2 */
N#define TIMER_A_EX0_TAIDEX_0                     ((uint16_t)0x0000)              /*!< Divide by 1 */
N#define TIMER_A_EX0_TAIDEX_1                     ((uint16_t)0x0001)              /*!< Divide by 2 */
N#define TIMER_A_EX0_TAIDEX_2                     ((uint16_t)0x0002)              /*!< Divide by 3 */
N#define TIMER_A_EX0_TAIDEX_3                     ((uint16_t)0x0003)              /*!< Divide by 4 */
N#define TIMER_A_EX0_TAIDEX_4                     ((uint16_t)0x0004)              /*!< Divide by 5 */
N#define TIMER_A_EX0_TAIDEX_5                     ((uint16_t)0x0005)              /*!< Divide by 6 */
N#define TIMER_A_EX0_TAIDEX_6                     ((uint16_t)0x0006)              /*!< Divide by 7 */
N#define TIMER_A_EX0_TAIDEX_7                     ((uint16_t)0x0007)              /*!< Divide by 8 */
N#define TIMER_A_EX0_IDEX__1                      ((uint16_t)0x0000)              /*!< Divide by 1 */
N#define TIMER_A_EX0_IDEX__2                      ((uint16_t)0x0001)              /*!< Divide by 2 */
N#define TIMER_A_EX0_IDEX__3                      ((uint16_t)0x0002)              /*!< Divide by 3 */
N#define TIMER_A_EX0_IDEX__4                      ((uint16_t)0x0003)              /*!< Divide by 4 */
N#define TIMER_A_EX0_IDEX__5                      ((uint16_t)0x0004)              /*!< Divide by 5 */
N#define TIMER_A_EX0_IDEX__6                      ((uint16_t)0x0005)              /*!< Divide by 6 */
N#define TIMER_A_EX0_IDEX__7                      ((uint16_t)0x0006)              /*!< Divide by 7 */
N#define TIMER_A_EX0_IDEX__8                      ((uint16_t)0x0007)              /*!< Divide by 8 */
N
N/******************************************************************************
N* TLV Bits
N******************************************************************************/
N/******************************************************************************
N* TLV table start and TLV tags                                                *
N******************************************************************************/
N#define TLV_START_ADDR                    (TLV_BASE + 0x0004)                    /*!< Start Address of the TLV structure */
N
N#define TLV_TAG_RESERVED1                                   1
N#define TLV_TAG_RESERVED2                                   2
N#define TLV_TAG_CS                                          3
N#define TLV_TAG_FLASHCTL                                    4
N#define TLV_TAG_ADC14                                       5
N#define TLV_TAG_RESERVED6                                   6
N#define TLV_TAG_RESERVED7                                   7
N#define TLV_TAG_REF                                         8
N#define TLV_TAG_RESERVED9                                   9
N#define TLV_TAG_RESERVED10                                 10
N#define TLV_TAG_DEVINFO                                    11
N#define TLV_TAG_DIEREC                                     12
N#define TLV_TAG_RANDNUM                                    13
N#define TLV_TAG_RESERVED14                                 14
N#define TLV_TAG_BSL                                        15
N#define TLV_TAG_END                                        (0x0BD0E11D)
N
N
N/******************************************************************************
N* TPIU Bits
N******************************************************************************/
N
N
N/******************************************************************************
N* WDT_A Bits
N******************************************************************************/
N/* WDT_A_CTL[IS] Bits */
N#define WDT_A_CTL_IS_OFS                         ( 0)                            /*!< WDTIS Bit Offset */
N#define WDT_A_CTL_IS_MASK                        ((uint16_t)0x0007)              /*!< WDTIS Bit Mask */
N#define WDT_A_CTL_IS0                            ((uint16_t)0x0001)              /*!< IS Bit 0 */
N#define WDT_A_CTL_IS1                            ((uint16_t)0x0002)              /*!< IS Bit 1 */
N#define WDT_A_CTL_IS2                            ((uint16_t)0x0004)              /*!< IS Bit 2 */
N#define WDT_A_CTL_IS_0                           ((uint16_t)0x0000)              /*!< Watchdog clock source / (2^(31)) (18:12:16 at 32.768 kHz) */
N#define WDT_A_CTL_IS_1                           ((uint16_t)0x0001)              /*!< Watchdog clock source /(2^(27)) (01:08:16 at 32.768 kHz) */
N#define WDT_A_CTL_IS_2                           ((uint16_t)0x0002)              /*!< Watchdog clock source /(2^(23)) (00:04:16 at 32.768 kHz) */
N#define WDT_A_CTL_IS_3                           ((uint16_t)0x0003)              /*!< Watchdog clock source /(2^(19)) (00:00:16 at 32.768 kHz) */
N#define WDT_A_CTL_IS_4                           ((uint16_t)0x0004)              /*!< Watchdog clock source /(2^(15)) (1 s at 32.768 kHz) */
N#define WDT_A_CTL_IS_5                           ((uint16_t)0x0005)              /*!< Watchdog clock source / (2^(13)) (250 ms at 32.768 kHz) */
N#define WDT_A_CTL_IS_6                           ((uint16_t)0x0006)              /*!< Watchdog clock source / (2^(9)) (15.625 ms at 32.768 kHz) */
N#define WDT_A_CTL_IS_7                           ((uint16_t)0x0007)              /*!< Watchdog clock source / (2^(6)) (1.95 ms at 32.768 kHz) */
N/* WDT_A_CTL[CNTCL] Bits */
N#define WDT_A_CTL_CNTCL_OFS                      ( 3)                            /*!< WDTCNTCL Bit Offset */
N#define WDT_A_CTL_CNTCL                          ((uint16_t)0x0008)              /*!< Watchdog timer counter clear */
N/* WDT_A_CTL[TMSEL] Bits */
N#define WDT_A_CTL_TMSEL_OFS                      ( 4)                            /*!< WDTTMSEL Bit Offset */
N#define WDT_A_CTL_TMSEL                          ((uint16_t)0x0010)              /*!< Watchdog timer mode select */
N/* WDT_A_CTL[SSEL] Bits */
N#define WDT_A_CTL_SSEL_OFS                       ( 5)                            /*!< WDTSSEL Bit Offset */
N#define WDT_A_CTL_SSEL_MASK                      ((uint16_t)0x0060)              /*!< WDTSSEL Bit Mask */
N#define WDT_A_CTL_SSEL0                          ((uint16_t)0x0020)              /*!< SSEL Bit 0 */
N#define WDT_A_CTL_SSEL1                          ((uint16_t)0x0040)              /*!< SSEL Bit 1 */
N#define WDT_A_CTL_SSEL_0                         ((uint16_t)0x0000)              /*!< SMCLK */
N#define WDT_A_CTL_SSEL_1                         ((uint16_t)0x0020)              /*!< ACLK */
N#define WDT_A_CTL_SSEL_2                         ((uint16_t)0x0040)              /*!< VLOCLK */
N#define WDT_A_CTL_SSEL_3                         ((uint16_t)0x0060)              /*!< BCLK */
N#define WDT_A_CTL_SSEL__SMCLK                    ((uint16_t)0x0000)              /*!< SMCLK */
N#define WDT_A_CTL_SSEL__ACLK                     ((uint16_t)0x0020)              /*!< ACLK */
N#define WDT_A_CTL_SSEL__VLOCLK                   ((uint16_t)0x0040)              /*!< VLOCLK */
N#define WDT_A_CTL_SSEL__BCLK                     ((uint16_t)0x0060)              /*!< BCLK */
N/* WDT_A_CTL[HOLD] Bits */
N#define WDT_A_CTL_HOLD_OFS                       ( 7)                            /*!< WDTHOLD Bit Offset */
N#define WDT_A_CTL_HOLD                           ((uint16_t)0x0080)              /*!< Watchdog timer hold */
N/* WDT_A_CTL[PW] Bits */
N#define WDT_A_CTL_PW_OFS                         ( 8)                            /*!< WDTPW Bit Offset */
N#define WDT_A_CTL_PW_MASK                        ((uint16_t)0xFF00)              /*!< WDTPW Bit Mask */
N/* Pre-defined bitfield values */
N#define WDT_A_CTL_PW                              ((uint16_t)0x5A00)              /*!< WDT Key Value for WDT write access */
N
N
N/******************************************************************************
N* BSL                                                                         *
N******************************************************************************/
N#define BSL_DEFAULT_PARAM                        ((uint32_t)0xFC48FFFF)          /*!< I2C slave address = 0x48, Interface selection = Auto */
N#define BSL_API_TABLE_ADDR                       ((uint32_t)0x00202000)          /*!< Address of BSL API table */
N#define BSL_ENTRY_FUNCTION                       (*((uint32_t *)BSL_API_TABLE_ADDR))
N
N#define BSL_AUTO_INTERFACE                       ((uint32_t)0x0000E0000)         /*!< Auto detect interface */
N#define BSL_UART_INTERFACE                       ((uint32_t)0x0000C0000)         /*!< UART interface */
N#define BSL_SPI_INTERFACE                        ((uint32_t)0x0000A0000)         /*!< SPI interface */
N#define BSL_I2C_INTERFACE                        ((uint32_t)0x000080000)         /*!< I2C interface */
N
N#define BSL_INVOKE(x)                            ((void (*)())BSL_ENTRY_FUNCTION)((uint32_t) x) /*!< Invoke the BSL with parameters */
N
N
N/******************************************************************************
N* Mailbox struct legacy definition                                            *
N******************************************************************************/
N#define FLASH_MAILBOX_Type                    FL_BOOTOVER_MAILBOX_Type
N
N/******************************************************************************
N* Device Unlock Support                                                       *
N******************************************************************************/
N/* unlock the device by:
N *   Load SYSCTL_SECDATA_UNLOCK register address into R0
N *   Load SYSCTL_SECDATA_UNLOCK unlock key into R1
N *   Write the unlock key to the SYSCTL_SECDATA_UNLOCK register
N */
N#define UNLOCK_DEVICE\
N    __asm("  MOVW.W          R0, #0x3040");\
N    __asm("  MOVT.W          R0, #0xE004");\
N    __asm("  MOVW.W          R1, #0x695A");\
N    __asm("  MOVT.W          R1, #0x0000");\
N    __asm("  STR             R1, [R0]");
X#define UNLOCK_DEVICE    __asm("  MOVW.W          R0, #0x3040");    __asm("  MOVT.W          R0, #0xE004");    __asm("  MOVW.W          R1, #0x695A");    __asm("  MOVT.W          R1, #0x0000");    __asm("  STR             R1, [R0]");
N
N/******************************************************************************
N*
N* The following are values that can be used to choose the command that will be
N* run by the boot code. Perform a logical OR of these settings to create your
N* general parameter command.
N*
N******************************************************************************/
N#define COMMAND_FACTORY_RESET                    ((uint32_t)0x00010000)
N#define COMMAND_BSL_CONFIG                       ((uint32_t)0x00020000)
N#define COMMAND_JTAG_SWD_LOCK_SECEN              ((uint32_t)0x00080000)
N#define COMMAND_SEC_ZONE0_EN                     ((uint32_t)0x00100000)
N#define COMMAND_SEC_ZONE1_EN                     ((uint32_t)0x00200000)
N#define COMMAND_SEC_ZONE2_EN                     ((uint32_t)0x00400000)
N#define COMMAND_SEC_ZONE3_EN                     ((uint32_t)0x00800000)
N#define COMMAND_SEC_ZONE0_UPDATE                 ((uint32_t)0x01000000)
N#define COMMAND_SEC_ZONE1_UPDATE                 ((uint32_t)0x02000000)
N#define COMMAND_SEC_ZONE2_UPDATE                 ((uint32_t)0x04000000)
N#define COMMAND_SEC_ZONE3_UPDATE                 ((uint32_t)0x08000000)
N#define COMMAND_JTAG_SWD_LOCK_ENC_UPDATE         ((uint32_t)0x10000000)
N#define COMMAND_NONE                             ((uint32_t)0xFFFFFFFF)
N
N/******************************************************************************
N*
N* The following are values that can be used to configure the BSL. Perform a
N* logical OR of these settings to create your BSL parameter.
N*
N******************************************************************************/
N#define BSL_CONFIG_HW_INVOKE                     ((uint32_t)0x70000000)
N
N#define BSL_CONFIG_HW_INVOKE_PORT1               ((uint32_t)0x00000000)
N#define BSL_CONFIG_HW_INVOKE_PORT2               ((uint32_t)0x00000001)
N#define BSL_CONFIG_HW_INVOKE_PORT3               ((uint32_t)0x00000002)
N
N#define BSL_CONFIG_HW_INVOKE_PIN0                ((uint32_t)0x00000000)
N#define BSL_CONFIG_HW_INVOKE_PIN1                ((uint32_t)0x00000010)
N#define BSL_CONFIG_HW_INVOKE_PIN2                ((uint32_t)0x00000020)
N#define BSL_CONFIG_HW_INVOKE_PIN3                ((uint32_t)0x00000030)
N#define BSL_CONFIG_HW_INVOKE_PIN4                ((uint32_t)0x00000040)
N#define BSL_CONFIG_HW_INVOKE_PIN5                ((uint32_t)0x00000050)
N#define BSL_CONFIG_HW_INVOKE_PIN6                ((uint32_t)0x00000060)
N#define BSL_CONFIG_HW_INVOKE_PIN7                ((uint32_t)0x00000070)
N
N#define BSL_CONFIG_HW_INVOKE_PIN_LOW             ((uint32_t)0x00000000)
N#define BSL_CONFIG_HW_INVOKE_PIN_HIGH            ((uint32_t)0x00001000)
N
N#define BSL_CONFIG_INTERFACE_I2C                 ((uint32_t)0x00008000)
N#define BSL_CONFIG_INTERFACE_SPI                 ((uint32_t)0x0000A000)
N#define BSL_CONFIG_INTERFACE_UART                ((uint32_t)0x0000C000)
N#define BSL_CONFIG_INTERFACE_AUTO                ((uint32_t)0x0000E000)
N
N#define BSL_CONFIG_I2C_ADD_OFFSET                (16)
N
N
N/******************************************************************************
N* ULP Advisor                                                                 *
N******************************************************************************/
N#ifdef __TI_ARM__
N#pragma ULP_PORT_CONFIG(1,DIR={0x40004C04,8},OUT={0x40004C02,8},SEL1={0x40004C0A,8},SEL2={0x40004C0C,8})
N#pragma ULP_PORT_CONFIG(2,DIR={0x40004C05,8},OUT={0x40004C03,8},SEL1={0x40004C0B,8},SEL2={0x40004C0D,8})
N#pragma ULP_PORT_CONFIG(3,DIR={0x40004C24,8},OUT={0x40004C22,8},SEL1={0x40004C2A,8},SEL2={0x40004C2C,8})
N#pragma ULP_PORT_CONFIG(4,DIR={0x40004C25,8},OUT={0x40004C23,8},SEL1={0x40004C2B,8},SEL2={0x40004C2D,8})
N#pragma ULP_PORT_CONFIG(5,DIR={0x40004C44,8},OUT={0x40004C42,8},SEL1={0x40004C4A,8},SEL2={0x40004C4C,8})
N#pragma ULP_PORT_CONFIG(6,DIR={0x40004C45,8},OUT={0x40004C43,8},SEL1={0x40004C4B,8},SEL2={0x40004C4D,8})
N#pragma ULP_PORT_CONFIG(7,DIR={0x40004C64,8},OUT={0x40004C62,8},SEL1={0x40004C6A,8},SEL2={0x40004C6C,8})
N#pragma ULP_PORT_CONFIG(8,DIR={0x40004C65,8},OUT={0x40004C63,8},SEL1={0x40004C6B,8},SEL2={0x40004C6D,8})
N#pragma ULP_PORT_CONFIG(9,DIR={0x40004C84,8},OUT={0x40004C82,8},SEL1={0x40004C8A,8},SEL2={0x40004C8C,8})
N#pragma ULP_PORT_CONFIG(10,DIR={0x40004C85,8},OUT={0x40004C83,8},SEL1={0x40004C8B,8},SEL2={0x40004C8D,8})
N#endif
N
N
N#ifdef __cplusplus
N}
N#endif
N
N#endif /* __MSP432P401R_H__ */
N
L 47 "C:/ti/ccs930/ccs/ccs_base/arm/include/msp.h" 2
N
N#elif defined (__MSP432P401M__)
S#include "msp432p401m.h"
S
S#elif defined (__MSP432P401Y__)
S#include "msp432p401y.h"
S
S#elif defined (__MSP432P401V__)
S#include "msp432p401v.h"
S
S#elif defined (__MSP432P411V__)
S#include "msp432p411v.h"
S
S#elif defined (__MSP432P4011__)
S#include "msp432p4011.h"
S
S#elif defined (__MSP432P4111__)
S#include "msp432p4111.h"
S
S#elif defined (__MSP432P411Y__)
S#include "msp432p411y.h"
S
S#elif defined (__MSP432E411Y__)
S#include "msp432e411y.h"
S
S#elif defined (__MSP432E401Y__)
S#include "msp432e401y.h"
S
S/******************************************************************************
S* Failed to match a default include file                                      *
S******************************************************************************/
S#else
S#error "Failed to match a default include file"
N#endif
N
N#endif /* __MSP432_H__ */
N
L 61 "C:\ti\msp432_driverlib_3_21_00_05\driverlib\MSP432P4xx\adc14.h" 2
N#include <stdbool.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/stdbool.h" 1
N/* -*- C++ -*- */
N/*===--------------------------- complex.h --------------------------------===*/
N/*                                                                            */
N/*                     The LLVM Compiler Infrastructure                       */
N/*                                                                            */
N/* This file is dual licensed under the MIT and the University of Illinois Open
N** Source Licenses. See LICENSE.TXT for details.
N*/
N/*===----------------------------------------------------------------------===*/
N#ifndef _LIBCPP_STDBOOL_H
N#define _LIBCPP_STDBOOL_H
N
N
N/*
N    stdbool.h synopsis
N
NMacros:
N
N    __bool_true_false_are_defined
N
N*/
N
N#include <__config>
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N#include_next <stdbool.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/stdbool.h" 1
N/*
N * Copyright (c) 2000 Jeroen Ruigrok van der Werven <asmodai@FreeBSD.org>
N * All rights reserved.
N *
N * Copyright (c) 2014-2014 Texas Instruments Incorporated
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N * 1. Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
N * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
N * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
N * SUCH DAMAGE.
N *
N * $FreeBSD: release/10.0.0/include/stdbool.h 228878 2011-12-25 20:15:41Z ed $
N */
N
N#ifndef __bool_true_false_are_defined
N#define	__bool_true_false_are_defined	1
N
N#ifndef __cplusplus
S
S#define	false	0
S#define	true	1
S
S#define	bool	_Bool
S#if __TI_STRICT_ANSI_MODE__ && 199901L > __STDC_VERSION__
Stypedef unsigned char _Bool;
S#endif
S
N#endif /* !__cplusplus */
N#endif /* __bool_true_false_are_defined */
L 30 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/stdbool.h" 2
N
N#ifdef __cplusplus
N#undef bool
N#undef true
N#undef false
N#undef __bool_true_false_are_defined
N#define __bool_true_false_are_defined 1
N#endif
N
N#endif  /* _LIBCPP_STDBOOL_H */
L 62 "C:\ti\msp432_driverlib_3_21_00_05\driverlib\MSP432P4xx\adc14.h" 2
N
N//*****************************************************************************
N//
N// Control specific variables
N//
N//*****************************************************************************
N
N//*****************************************************************************
N//
N//The following are values that can be passed to ADC14_initModule
N//
N//*****************************************************************************
N#define ADC_CLOCKSOURCE_ADCOSC   (ADC14_CTL0_SSEL_0)
N#define ADC_CLOCKSOURCE_SYSOSC   (ADC14_CTL0_SSEL_1)
N#define ADC_CLOCKSOURCE_ACLK     (ADC14_CTL0_SSEL_2)
N#define ADC_CLOCKSOURCE_MCLK     (ADC14_CTL0_SSEL_3)
N#define ADC_CLOCKSOURCE_SMCLK    (ADC14_CTL0_SSEL_4)
N#define ADC_CLOCKSOURCE_HSMCLK   (ADC14_CTL0_SSEL_5)
N
N#define ADC_PREDIVIDER_1         (ADC14_CTL0_PDIV_0)
N#define ADC_PREDIVIDER_4         (ADC14_CTL0_PDIV_1)
N#define ADC_PREDIVIDER_32        (ADC14_CTL0_PDIV_2)
N#define ADC_PREDIVIDER_64        (ADC14_CTL0_PDIV_3)
N
N#define ADC_DIVIDER_1            (ADC14_CTL0_DIV_0)
N#define ADC_DIVIDER_2            (ADC14_CTL0_DIV_1)
N#define ADC_DIVIDER_3            (ADC14_CTL0_DIV_2)
N#define ADC_DIVIDER_4            (ADC14_CTL0_DIV_3)
N#define ADC_DIVIDER_5            (ADC14_CTL0_DIV_4)
N#define ADC_DIVIDER_6            (ADC14_CTL0_DIV_5)
N#define ADC_DIVIDER_7            (ADC14_CTL0_DIV_6)
N#define ADC_DIVIDER_8            (ADC14_CTL0_DIV_7)
N
N#define ADC_MAPINTCH3            (ADC14_CTL1_CH3MAP)
N#define ADC_MAPINTCH2            (ADC14_CTL1_CH2MAP)
N#define ADC_MAPINTCH1            (ADC14_CTL1_CH1MAP)
N#define ADC_MAPINTCH0            (ADC14_CTL1_CH0MAP)
N#define ADC_TEMPSENSEMAP         (ADC14_CTL1_TCMAP)
N#define ADC_BATTMAP              (ADC14_CTL1_BATMAP)
N#define ADC_NOROUTE               0
N
N#define ADC_8BIT                 ADC14_CTL1_RES_0
N#define ADC_10BIT                ADC14_CTL1_RES_1
N#define ADC_12BIT                ADC14_CTL1_RES_2
N#define ADC_14BIT                ADC14_CTL1_RES_3
N
N#define ADC_TRIGGER_ADCSC        ADC14_CTL0_SHS_0
N#define ADC_TRIGGER_SOURCE1      ADC14_CTL0_SHS_1
N#define ADC_TRIGGER_SOURCE2      ADC14_CTL0_SHS_2
N#define ADC_TRIGGER_SOURCE3      ADC14_CTL0_SHS_3
N#define ADC_TRIGGER_SOURCE4      ADC14_CTL0_SHS_4
N#define ADC_TRIGGER_SOURCE5      ADC14_CTL0_SHS_5
N#define ADC_TRIGGER_SOURCE6      ADC14_CTL0_SHS_6
N#define ADC_TRIGGER_SOURCE7      ADC14_CTL0_SHS_7
N
N#define ADC_PULSE_WIDTH_4        ADC14_CTL0_SHT1_0
N#define ADC_PULSE_WIDTH_8        ADC14_CTL0_SHT1_1
N#define ADC_PULSE_WIDTH_16       ADC14_CTL0_SHT1_2
N#define ADC_PULSE_WIDTH_32       ADC14_CTL0_SHT1_3
N#define ADC_PULSE_WIDTH_64       ADC14_CTL0_SHT1_4
N#define ADC_PULSE_WIDTH_96       ADC14_CTL0_SHT1_5
N#define ADC_PULSE_WIDTH_128      ADC14_CTL0_SHT1_6
N#define ADC_PULSE_WIDTH_192      ADC14_CTL0_SHT1_7
N
N#define ADC_NONDIFFERENTIAL_INPUTS false
N#define ADC_DIFFERENTIAL_INPUTS true
N
N#define ADC_MEM0                 0x00000001
N#define ADC_MEM1                 0x00000002
N#define ADC_MEM2                 0x00000004
N#define ADC_MEM3                 0x00000008
N#define ADC_MEM4                 0x00000010
N#define ADC_MEM5                 0x00000020
N#define ADC_MEM6                 0x00000040
N#define ADC_MEM7                 0x00000080
N#define ADC_MEM8                 0x00000100
N#define ADC_MEM9                 0x00000200
N#define ADC_MEM10                0x00000400
N#define ADC_MEM11                0x00000800
N#define ADC_MEM12                0x00001000
N#define ADC_MEM13                0x00002000
N#define ADC_MEM14                0x00004000
N#define ADC_MEM15                0x00008000
N#define ADC_MEM16                0x00010000
N#define ADC_MEM17                0x00020000
N#define ADC_MEM18                0x00040000
N#define ADC_MEM19                0x00080000
N#define ADC_MEM20                0x00100000
N#define ADC_MEM21                0x00200000
N#define ADC_MEM22                0x00400000
N#define ADC_MEM23                0x00800000
N#define ADC_MEM24                0x01000000
N#define ADC_MEM25                0x02000000
N#define ADC_MEM26                0x04000000
N#define ADC_MEM27                0x08000000
N#define ADC_MEM28                0x10000000
N#define ADC_MEM29                0x20000000
N#define ADC_MEM30                0x40000000
N#define ADC_MEM31                0x80000000
N
N#define ADC_VREFPOS_AVCC_VREFNEG_VSS       (ADC14_MCTLN_VRSEL_0)
N#define ADC_VREFPOS_INTBUF_VREFNEG_VSS     (ADC14_MCTLN_VRSEL_1)
N#define ADC_VREFPOS_EXTPOS_VREFNEG_EXTNEG  (ADC14_MCTLN_VRSEL_14)
N#define ADC_VREFPOS_EXTBUF_VREFNEG_EXTNEG  (ADC14_MCTLN_VRSEL_15)
N
N#define ADC_INPUT_A0              (ADC14_MCTLN_INCH_0)
N#define ADC_INPUT_A1              (ADC14_MCTLN_INCH_1)
N#define ADC_INPUT_A2              (ADC14_MCTLN_INCH_2)
N#define ADC_INPUT_A3              (ADC14_MCTLN_INCH_3)
N#define ADC_INPUT_A4              (ADC14_MCTLN_INCH_4)
N#define ADC_INPUT_A5              (ADC14_MCTLN_INCH_5)
N#define ADC_INPUT_A6              (ADC14_MCTLN_INCH_6)
N#define ADC_INPUT_A7              (ADC14_MCTLN_INCH_7)
N#define ADC_INPUT_A8              (ADC14_MCTLN_INCH_8)
N#define ADC_INPUT_A9              (ADC14_MCTLN_INCH_9)
N#define ADC_INPUT_A10             (ADC14_MCTLN_INCH_10)
N#define ADC_INPUT_A11             (ADC14_MCTLN_INCH_11)
N#define ADC_INPUT_A12             (ADC14_MCTLN_INCH_12)
N#define ADC_INPUT_A13             (ADC14_MCTLN_INCH_13)
N#define ADC_INPUT_A14             (ADC14_MCTLN_INCH_14)
N#define ADC_INPUT_A15             (ADC14_MCTLN_INCH_15)
N#define ADC_INPUT_A16             (ADC14_MCTLN_INCH_16)
N#define ADC_INPUT_A17             (ADC14_MCTLN_INCH_17)
N#define ADC_INPUT_A18             (ADC14_MCTLN_INCH_18)
N#define ADC_INPUT_A19             (ADC14_MCTLN_INCH_19)
N#define ADC_INPUT_A20             (ADC14_MCTLN_INCH_20)
N#define ADC_INPUT_A21             (ADC14_MCTLN_INCH_21)
N#define ADC_INPUT_A22             (ADC14_MCTLN_INCH_22)
N#define ADC_INPUT_A23             (ADC14_MCTLN_INCH_23)
N#define ADC_INPUT_A24             (ADC14_MCTLN_INCH_24)
N#define ADC_INPUT_A25             (ADC14_MCTLN_INCH_25)
N#define ADC_INPUT_A26             (ADC14_MCTLN_INCH_26)
N#define ADC_INPUT_A27             (ADC14_MCTLN_INCH_27)
N#define ADC_INPUT_A28             (ADC14_MCTLN_INCH_28)
N#define ADC_INPUT_A29             (ADC14_MCTLN_INCH_29)
N#define ADC_INPUT_A30             (ADC14_MCTLN_INCH_30)
N#define ADC_INPUT_A31             (ADC14_MCTLN_INCH_31)
N
N#define ADC_COMP_WINDOW0          0x00
N#define ADC_COMP_WINDOW1          0x01
N
N#define ADC_SIGNED_BINARY         0x00
N#define ADC_UNSIGNED_BINARY       0x01
N
N#define ADC_MANUAL_ITERATION       0x00
N#define ADC_AUTOMATIC_ITERATION    ADC14_CTL0_MSC
N
N#define ADC_UNRESTRICTED_POWER_MODE   ADC14_CTL1_PWRMD_0
N#define ADC_ULTRA_LOW_POWER_MODE      ADC14_CTL1_PWRMD_2
N
N
N#define ADC_INT0 ADC14_IER0_IE0
N#define ADC_INT1 ADC14_IER0_IE1
N#define ADC_INT2 ADC14_IER0_IE2
N#define ADC_INT3 ADC14_IER0_IE3
N#define ADC_INT4 ADC14_IER0_IE4
N#define ADC_INT5 ADC14_IER0_IE5
N#define ADC_INT6 ADC14_IER0_IE6
N#define ADC_INT7 ADC14_IER0_IE7
N#define ADC_INT8 ADC14_IER0_IE8
N#define ADC_INT9 ADC14_IER0_IE9
N#define ADC_INT10 ADC14_IER0_IE10
N#define ADC_INT11 ADC14_IER0_IE11
N#define ADC_INT12 ADC14_IER0_IE12
N#define ADC_INT13 ADC14_IER0_IE13
N#define ADC_INT14 ADC14_IER0_IE14
N#define ADC_INT15 ADC14_IER0_IE15
N#define ADC_INT16 ADC14_IER0_IE16
N#define ADC_INT17 ADC14_IER0_IE17
N#define ADC_INT18 ADC14_IER0_IE18
N#define ADC_INT19 ADC14_IER0_IE19
N#define ADC_INT20 ADC14_IER0_IE20
N#define ADC_INT21 ADC14_IER0_IE21
N#define ADC_INT22 ADC14_IER0_IE22
N#define ADC_INT23 ADC14_IER0_IE23
N#define ADC_INT24 ADC14_IER0_IE24
N#define ADC_INT25 ADC14_IER0_IE25
N#define ADC_INT26 ADC14_IER0_IE26
N#define ADC_INT27 ADC14_IER0_IE27
N#define ADC_INT28 ADC14_IER0_IE28
N#define ADC_INT29 ADC14_IER0_IE29
N#define ADC_INT30 ADC14_IER0_IE30
N#define ADC_INT31 ADC14_IER0_IE31
N#define ADC_IN_INT 0x0000000200000000
N#define ADC_LO_INT 0x0000000400000000
N#define ADC_HI_INT 0x0000000800000000
N#define ADC_OV_INT 0x0000001000000000
N#define ADC_TOV_INT 0x0000002000000000
N#define ADC_RDY_INT 0x0000004000000000
N
N#define ADC_INVALID_MEM   32
N
N//*****************************************************************************
N//
N//Prototypes for the APIs.
N//
N//*****************************************************************************
N
N//*****************************************************************************
N//
N//!
N//! Enables the ADC block.
N//!
N//! This will enable operation of the ADC block.
N//!
N//! \return none.
N//
N//*****************************************************************************
Nextern void ADC14_enableModule(void);
N
N//*****************************************************************************
N//
N//!
N//! Disables the ADC block.
N//!
N//! This will disable operation of the ADC block.
N//!
N//! \return false if user is trying to disable during active conversion
N//
N//*****************************************************************************
Nextern bool ADC14_disableModule(void);
N
N//*****************************************************************************
N//
N//!
N//! Initializes the ADC module and sets up the clock system divider/pre-divider.
N//! This initialization function will also configure the internal/external
N//! signal mapping.
N//!
N//! \note A call to this function while active ADC conversion is happening
N//! is an invalid case and will result in a false value being returned.
N//!
N//! \param clockSource The clock source to use for the ADC module.
N//!                 - \b ADC_CLOCKSOURCE_ADCOSC [DEFAULT]
N//!                 - \b ADC_CLOCKSOURCE_SYSOSC
N//!                 - \b ADC_CLOCKSOURCE_ACLK
N//!                 - \b ADC_CLOCKSOURCE_MCLK
N//!                 - \b ADC_CLOCKSOURCE_SMCLK
N//!                 - \b ADC_CLOCKSOURCE_HSMCLK
N//!
N//! \param clockPredivider Divides the given clock source before feeding it
N//!         into the main clock divider.
N//!             Valid values are:
N//!                 - \b ADC_PREDIVIDER_1 [DEFAULT]
N//!                 - \b ADC_PREDIVIDER_4
N//!                 - \b ADC_PREDIVIDER_32
N//!                 - \b ADC_PREDIVIDER_64
N//!
N//! \param clockDivider Divides the pre-divided clock source
N//!         Valid values are
N//!             - \b ADC_DIVIDER_1 [Default value]
N//!             - \b ADC_DIVIDER_2
N//!             - \b ADC_DIVIDER_3
N//!             - \b ADC_DIVIDER_4
N//!             - \b ADC_DIVIDER_5
N//!             - \b ADC_DIVIDER_6
N//!             - \b ADC_DIVIDER_7
N//!             - \b ADC_DIVIDER_8
N//!
N//! \param internalChannelMask
N//!  Configures the internal/external pin mappings
N//!  for the ADC modules. This setting determines if the given ADC channel or
N//!  component is mapped to an external pin (default), or routed to an internal
N//!  component. This parameter is a bit mask where a logical high value will
N//!  switch the component to the internal routing. For a list of internal
N//!  routings, please refer to the device specific data sheet.
N//!  Valid values are a logical OR of the following values:
N//!         - \b ADC_MAPINTCH3
N//!         - \b ADC_MAPINTCH2
N//!         - \b ADC_MAPINTCH1
N//!         - \b ADC_MAPINTCH0
N//!         - \b ADC_TEMPSENSEMAP
N//!         - \b ADC_BATTMAP
N//!         - \n ADC_NOROUTE
N//! If internalChannelMask is not desired, pass ADC_NOROUTE in lieu of this
N//!  parameter.
N//!
N//! \return false if the initialization fails due to an in progress conversion
N//!
N//!
N//
N//*****************************************************************************
Nextern bool ADC14_initModule(uint32_t clockSource, uint32_t clockPredivider,
N        uint32_t clockDivider, uint32_t internalChannelMask);
N
N//*****************************************************************************
N//
N//!
N//! Sets the resolution of the ADC module. The default resolution is 12-bit,
N//! however for power consumption concerns this can be limited to a lower
N//! resolution
N//!
N//! \param resolution Resolution of the ADC module
N//!         - \b ADC_8BIT (10 clock cycle conversion time)
N//!         - \b ADC_10BIT (12 clock cycle conversion time)
N//!         - \b ADC_12BIT (14 clock cycle conversion time)
N//!         - \b ADC_14BIT (16 clock cycle conversion time)[DEFAULT]
N//!
N//! \return none
N//
N//*****************************************************************************
Nextern void ADC14_setResolution(uint32_t resolution);
N
N//*****************************************************************************
N//
N//!
N//! Gets the resolution of the ADC module.
N//!
N//! \return Resolution of the ADC module
N//!         - \b ADC_8BIT (10 clock cycle conversion time)
N//!         - \b ADC_10BIT (12 clock cycle conversion time)
N//!         - \b ADC_12BIT (14 clock cycle conversion time)
N//!         - \b ADC_14BIT (16 clock cycle conversion time)
N//
N//*****************************************************************************
Nextern uint_fast32_t ADC14_getResolution(void);
N
N//*****************************************************************************
N//
N//!
N//! Sets the source for the trigger of the ADC module. By default, this value
N//! is configured to a software source (the ADCSC bit), however depending on
N//! the specific device the trigger can be set to different sources (for
N//! example, a timer output). These sources vary from part to part and the
N//! user should refer to the device specific datasheet.
N//!
N//! \param source Trigger source for sampling. Possible values include:
N//!         - \b ADC_TRIGGER_ADCSC [DEFAULT]
N//!         - \b ADC_TRIGGER_SOURCE1
N//!         - \b ADC_TRIGGER_SOURCE2
N//!         - \b ADC_TRIGGER_SOURCE3
N//!         - \b ADC_TRIGGER_SOURCE4
N//!         - \b ADC_TRIGGER_SOURCE5
N//!         - \b ADC_TRIGGER_SOURCE6
N//!         - \b ADC_TRIGGER_SOURCE7
N//! \param invertSignal When set to true, will invert the trigger signal to a
N//!         falling edge. When false, will use a rising edge.
N//!
N//! \return false if setting fails due to an in progress conversion
N//
N//*****************************************************************************
Nextern bool ADC14_setSampleHoldTrigger(uint32_t source, bool invertSignal);
N
N//*****************************************************************************
N//
N//!
N//! Sets the sample/hold time for the specified memory register range. The
N//! duration of time required for a sample differs depending on the user's
N//! hardware configuration.
N//!
N//! There are two values in the ADCC module. The first value controls
N//! ADC memory locations ADC_MEMORY_0 through ADC_MEMORY_7 and
N//! ADC_MEMORY_24 through ADC_MEMORY_31, while the second value
N//! controls memory locations ADC_MEMORY_8 through ADC_MEMORY_23.
N//!
N//! \param firstPulseWidth Pulse width of the first pulse in ADCCLK cycles
N//!     Possible values must be one of the following:
N//!         - \b ADC_PULSE_WIDTH_4 [DEFAULT]
N//!         - \b ADC_PULSE_WIDTH_8
N//!         - \b ADC_PULSE_WIDTH_16
N//!         - \b ADC_PULSE_WIDTH_32
N//!         - \b ADC_PULSE_WIDTH_64
N//!         - \b ADC_PULSE_WIDTH_96
N//!         - \b ADC_PULSE_WIDTH_128
N//!         - \b ADC_PULSE_WIDTH_192
N//! \param secondPulseWidth Pulse width of the second pulse in ADCCLK
N//!     cycles. Possible values must be one of the following:
N//!         - \b ADC_PULSE_WIDTH_4 [DEFAULT]
N//!         - \b ADC_PULSE_WIDTH_8
N//!         - \b ADC_PULSE_WIDTH_16
N//!         - \b ADC_PULSE_WIDTH_32
N//!         - \b ADC_PULSE_WIDTH_64
N//!         - \b ADC_PULSE_WIDTH_96
N//!         - \b ADC_PULSE_WIDTH_128
N//!         - \b ADC_PULSE_WIDTH_192
N//!
N//! \return false if setting fails due to an in progress conversion
N//
N//*****************************************************************************
Nextern bool ADC14_setSampleHoldTime(uint32_t firstPulseWidth,
N        uint32_t secondPulseWidth);
N
N//*****************************************************************************
N//
N//!
N//! Configures the ADC module to use a multiple memory sample scheme. This
N//! means that multiple samples will consecutively take place and be stored in
N//! multiple memory locations. The first sample/conversion will be placed in
N//! memoryStart, while the last sample will be stored in memoryEnd.
N//! Each memory location should be configured individually using the
N//! ADC14_configureConversionMemory function.
N//!
N//! The ADC module can be started in "repeat" mode which will cause the
N//! ADC module to resume sampling once the initial sample/conversion set is
N//! executed.  For multi-sample mode, this means that the sampling of the
N//! entire memory provided.
N//!
N//! \param memoryStart Memory location to store first sample/conversion
N//!         value. Possible values include:
N//!         - \b ADC_MEM0 through \b ADC_MEM31
N//! \param memoryEnd Memory location to store last sample.
N//!     Possible values include:
N//!         - \b ADC_MEM0 through \b ADC_MEM31
N//! \param repeatMode Specifies whether or not to repeat the conversion/sample
N//!         cycle after the first round of sample/conversions. Valid values
N//!         are true or false.
N//!
N//! \return false if setting fails due to an in progress conversion
N//
N//*****************************************************************************
Nextern bool ADC14_configureMultiSequenceMode(uint32_t memoryStart,
N        uint32_t memoryEnd, bool repeatMode);
N
N//*****************************************************************************
N//
N//!
N//! Configures the ADC module to use a a single ADC memory location for
N//! sampling/conversion. This is used when only one channel might be needed for
N//! conversion, or where using a multiple sampling scheme is not important.
N//!
N//! The ADC module can be started in "repeat" mode which will cause the
N//! ADC module to resume sampling once the initial sample/conversion set is
N//! executed. In single sample mode, this will cause the ADC module to
N//! continuously sample into the memory destination provided.
N
N//! \param memoryDestination Memory location to store sample/conversion
N//!         value. Possible values include:
N//!         - \b ADC_MEM0 through \b ADC_MEM31
N//!
N//! \param repeatMode Specifies whether or not to repeat the conversion/sample
N//!         cycle after the first round of sample/conversions
N//!
N//! \return false if setting fails due to an in progress conversion
N//
N//*****************************************************************************
Nextern bool ADC14_configureSingleSampleMode(uint32_t memoryDestination,
N        bool repeatMode);
N
N//*****************************************************************************
N//
N//!
N//! Enables conversion of ADC data. Note that this only enables conversion.
N//! To trigger the conversion, you will have to call the
N//! ADC14_toggleConversionTrigger or use the source trigger configured in
N//! ADC14_setSampleHoldTrigger.
N//!
N//! \return false if setting fails due to an in progress conversion
N//
N//*****************************************************************************
Nextern bool ADC14_enableConversion(void);
N
N//*****************************************************************************
N//
N//!
N//! Halts conversion conversion of the ADC module. Note that the software bit
N//! for triggering conversions will also be cleared with this function.
N//!
N//! If multi-sequence conversion mode was enabled, the position of the last
N//! completed conversion can be retrieved using ADCLastConversionMemoryGet
N//!
N//! \return none
N//
N//*****************************************************************************
Nextern void ADC14_disableConversion(void);
N
N//*****************************************************************************
N//
N//!
N//! Toggles the trigger for conversion of the ADC module by toggling the
N//! trigger software bit. Note that this will cause the ADC to start
N//! conversion regardless if the software bit was set as the trigger using
N//! ADC14_setSampleHoldTrigger.
N//!
N//! \return false if setting fails due to an in progress conversion
N//
N//*****************************************************************************
Nextern bool ADC14_toggleConversionTrigger(void);
N
N//*****************************************************************************
N//
N//!
N//! Returns a boolean value that tells if a conversion/sample is in progress
N//!
N//! \return true if conversion is active, false otherwise
N//
N//*****************************************************************************
Nextern bool ADC14_isBusy(void);
N
N//*****************************************************************************
N//
N//!
N//! Configures an individual memory location for the ADC module.
N//!
N//! \param memorySelect is the individual ADC memory location to
N//!     configure. If multiple memory locations want to be configured with the
N//!     same configuration, this value can be logically ORed together with other
N//!     values.
N//!         - \b ADC_MEM0 through \b ADC_MEM31
N//! \param refSelect is the voltage reference to use for the selected
N//!         memory spot. Possible values include:
N//!         - \b ADC_VREFPOS_AVCC_VREFNEG_VSS [DEFAULT]
N//!         - \b ADC_VREFPOS_INTBUF_VREFNEG_VSS
N//!         - \b ADC_VREFPOS_EXTPOS_VREFNEG_EXTNEG
N//!         - \b ADC_VREFPOS_EXTBUF_VREFNEG_EXTNEG
N//! \param channelSelect selects the channel to be used for ADC sampling.
N//!         Note if differential mode is enabled, the value sampled will be
N//!         equal to the difference between the corresponding even/odd memory
N//!         locations. Possible values are:
N//!         - \b ADC_INPUT_A0 through \b ADC_INPUT_A31
N//!
N//! \param differntialMode selects if the channel selected by the
N//!     channelSelect will be configured in differential mode. If this
N//!     parameter is given as true, the configured channel will be paired
N//!     with its neighbor in differential mode. for example, if channel A0 or A1
N//!     is selected, the channel configured will be the difference between A0
N//!     and A1. If A2 or A3 are selected, the channel configured will be the
N//!     difference between A2 and A3 (and so on). Users can enter true or false,
N//!     or one of the following values:
N//!         - ADC_NONDIFFERENTIAL_INPUTS
N//!         - ADC_DIFFERENTIAL_INPUTS
N//!
N//!
N//! \return false if setting fails due to an in progress conversion
N//!
N//
N//*****************************************************************************
Nextern bool ADC14_configureConversionMemory(uint32_t memorySelect,
N        uint32_t refSelect, uint32_t channelSelect, bool differntialMode);
N
N//*****************************************************************************
N//
N//!
N//! Enables the specified mask of memory channels to use the specified
N//! comparator window. THe ADCC module has two different comparator windows
N//! that can be set with this function.
N//!
N//! \param memorySelect is the mask of memory locations to enable the
N//!         comparator window for. This can be a bitwise OR of the following
N//!         values:
N//!         - \b ADC_MEM0 through \b ADC_MEM31
N//! \param windowSelect Memory location to store sample/conversion
N//!         value. Possible values include:
N//!         \b ADCOMP_WINDOW0 [DEFAULT]
N//!         \b ADCOMP_WINDOW1
N//!
N//! \return false if setting fails due to an in progress conversion
N//
N//*****************************************************************************
Nextern bool ADC14_enableComparatorWindow(uint32_t memorySelect,
N        uint32_t windowSelect);
N
N//*****************************************************************************
N//
N//!
N//! Disables the comparator window on the specified memory channels
N//!
N//! \param memorySelect is the mask of memory locations to disable the
N//!         comparator window for. This can be a bitwise OR of the following
N//!         values:
N//!         - \b ADC_MEM0 through \b ADC_MEM31
N//!
N//! \return false if setting fails due to an in progress conversion
N//
N//*****************************************************************************
Nextern bool ADC14_disableComparatorWindow(uint32_t memorySelect);
N
N//*****************************************************************************
N//
N//!
N//! Sets the lower and upper limits of the specified window comparator. Note
N//! that this function will truncate values based of the resolution/data
N//! format configured. If the ADC is operating in 10-bit mode, and a 12-bit
N//! value is passed into this function the most significant 2 bits will be
N//! truncated.
N//!
N//! The parameters provided to this function for the upper and lower threshold
N//! depend on the current resolution for the ADC. For example, if configured
N//! in 12-bit mode, a 12-bit resolution is the maximum that can be provided
N//! for the window. If in 2's complement mode, Bit 15 is used as the MSB.
N//!
N//! \param window Memory location to store sample/conversion
N//!         value. Possible values include:
N//!         \b ADC_COMP_WINDOW0 [DEFAULT]
N//!         \b ADC_COMP_WINDOW1
N//! \param low is the lower limit of the window comparator
N//! \param high is the upper limit of the window comparator
N//!
N//! \return false if setting fails due to an in progress conversion
N//!
N//
N//*****************************************************************************
Nextern bool ADC14_setComparatorWindowValue(uint32_t window, int16_t low,
N        int16_t high);
N
N//*****************************************************************************
N//
N//!
N//! Switches between a binary unsigned data format and a signed 2's complement
N//! data format.
N//!
N//! \param resultFormat Format for result to conversion results.
N//!         Possible values include:
N//!         \b ADC_UNSIGNED_BINARY [DEFAULT]
N//!         \b ADC_SIGNED_BINARY
N//!
N//! \return false if setting fails due to an in progress conversion
N//!
N//
N//*****************************************************************************
Nextern bool ADC14_setResultFormat(uint32_t resultFormat);
N
N//*****************************************************************************
N//
N//!
N//! Returns the conversion result for the specified memory channel in the format
N//! assigned by the ADC14_setResultFormat (unsigned binary by default) function.
N//!
N//! \param memorySelect is the memory location to get the conversion result.
N//!     Valid values are:
N//!         - \b ADC_MEM0 through \b ADC_MEM31
N//! \return conversion result of specified memory channel
N//!
N//
N//*****************************************************************************
Nextern uint_fast16_t ADC14_getResult(uint32_t memorySelect);
N
N//*****************************************************************************
N//
N//!
N//! Returns the conversion results of the currently configured multi-sequence
N//! conversion. If a multi-sequence conversion has not happened, this value
N//! is unreliable. Note that it is up to the user to verify the integrity of
N//! and proper size of the array being passed. If there are 16 multi-sequence
N//! results, and an array with only 4 elements allocated is passed, invalid
N//! memory settings will occur
N//!
N//! \param res conversion result of the last multi-sequence sample
N//! in an array of unsigned 16-bit integers
N//!
N//! \return None
N//!
N//
N//*****************************************************************************
Nextern void ADC14_getMultiSequenceResult(uint16_t* res);
N
N//*****************************************************************************
N//
N//!
N//! Returns the conversion results of the specified ADC memory locations.
N//! Note that it is up to the user to verify the integrity of
N//! and proper size of the array being passed. If there are 16 multi-sequence
N//! results, and an array with only 4 elements allocated is passed, invalid
N//! memory settings will occur. This function is inclusive.
N//!
N//! \param memoryStart is the memory location to get the conversion result.
N//!     Valid values are:
N//!         - \b ADC_MEM0 through \b ADC_MEM31
N//!
N//! \param memoryEnd is the memory location to get the conversion result.
N//!     Valid values are:
N//!         - \b ADC_MEM0 through \b ADC_MEM31
N//! \param res conversion result of the last multi-sequence sample
N//! in an array of unsigned 16-bit integers
N//!
N//! \return None
N//!
N//
N//*****************************************************************************
Nextern void ADC14_getResultArray(uint32_t memoryStart, uint32_t memoryEnd,
N        uint16_t* res);
N
N//*****************************************************************************
N//
N//!
N//! Enables the "on-demand" activity of the voltage reference register. If this
N//! setting is enabled, the internal voltage reference buffer will only be
N//! updated during a sample or conversion cycle. This is used to optimize
N//! power consumption.
N//!
N//! \return false if setting fails due to an in progress conversion
N//!
N//
N//*****************************************************************************
Nextern bool ADC14_enableReferenceBurst(void);
N
N//*****************************************************************************
N//
N//!
N//! Disables the "on-demand" activity of the voltage reference register.
N//!
N//! \return false if setting fails due to an in progress conversion
N//!
N//
N//*****************************************************************************
Nextern bool ADC14_disableReferenceBurst(void);
N
N//*****************************************************************************
N//
N//!
N//! Sets the power mode of the ADC module. A more aggressive power mode will
N//! restrict the number of samples per second for sampling while optimizing
N//! power consumption. Ideally, if power consumption is a concern, this value
N//! should be set to the most restrictive setting that satisfies your sampling
N//! requirement.
N//!
N//! \param adcPowerMode is the power mode to set. Valid values are:
N//!         - \b ADC_UNRESTRICTED_POWER_MODE (no restriction)
N//!         - \b ADC_LOW_POWER_MODE (500ksps restriction)
N//!         - \b ADC_ULTRA_LOW_POWER_MODE (200ksps restriction)
N//!         - \b ADC_EXTREME_LOW_POWER_MODE (50ksps restriction)
N//!
N//! \return false if setting fails due to an in progress conversion
N//!
N//
N//*****************************************************************************
Nextern bool ADC14_setPowerMode(uint32_t powerMode);
N
N//*****************************************************************************
N//
N//!
N//! Enables SAMPCON to be sourced from the sampling timer and to configures
N//! multi sample and conversion mode.
N//! \param multiSampleConvert - Switches between manual and automatic
N//!         iteration when using the sample timer. Valid values are:
N//! - \b ADC_MANUAL_ITERATION The user will have to manually set the SHI signal
N//!         ( usually by  ADC14_toggleConversionTrigger ) at the end
N//!         of each sample/conversion cycle.
N//! - \b ADC_AUTOMATIC_ITERATION  After one sample/convert is finished, the ADC
N//!         module will automatically continue on to the next sample
N//!
N//! \return false if the initialization fails due to an in progress conversion
N//
N//*****************************************************************************
Nextern bool ADC14_enableSampleTimer(uint32_t multiSampleConvert);
N
N//*****************************************************************************
N//
N//!
N//! Disables SAMPCON from being sourced from the sample timer.
N//!
N//! \return false if the initialization fails due to an in progress conversion
N//
N//*****************************************************************************
Nextern bool ADC14_disableSampleTimer(void);
N
N//*****************************************************************************
N//
N//!
N//! Enables the indicated ADCC interrupt sources. The ADC_INT0
N//! through ADC_INT31 parameters correspond to a completion event of the
N//! corresponding memory location. For example, when the ADC_MEM0 location
N//! finishes a conversion cycle, the ADC_INT0 interrupt will be set.
N//!
N//! \param mask is the bit mask of interrupts to enable.
N//!        Valid values are a bitwise OR of the following values:
N//!        - \b ADC_INT0 through ADC_INT31
N//!        - \b ADC_IN_INT - Interrupt enable for a conversion in the result
N//!                          register is either greater than the ADCLO or
N//!                          lower than the ADCHI threshold.
N//!        - \b ADC_LO_INT - Interrupt enable for the falling short of the
N//!                          lower limit interrupt of the window comparator for
N//!                          the result register.
N//!        - \b ADC_HI_INT - Interrupt enable for the exceeding the upper
N//!                          limit of the window comparator for the result
N//!                          register.
N//!        - \b ADC_OV_INT - Interrupt enable for a conversion that is about
N//!                          to save to a memory buffer that has not been read
N//!                          out yet.
N//!        - \b ADC_TOV_INT -Interrupt enable for a conversion that is about
N//!                          to start before the previous conversion has been
N//!                          completed.
N//!        - \b ADC_RDY_INT -Interrupt enable for the local buffered reference
N//!                          ready signal.
N//!
N//!
N//! \return NONE
N//
N//*****************************************************************************
Nextern void ADC14_enableInterrupt(uint_fast64_t mask);
N
N//*****************************************************************************
N//
N//!
N//! Disables the indicated ADCC interrupt sources.  Only the sources that
N//! are enabled can be reflected to the processor interrupt; disabled sources
N//! have no effect on the processor. The ADC_INT0 through ADC_INT31
N//! parameters correspond to a completion event of the corresponding memory
N//! location. For example, when the ADC_MEM0 location finishes a conversion
N//! cycle, the ADC_INT0 interrupt will be set.
N//!
N//! \param mask is the bit mask of interrupts to disable.
N//!        Valid values are a bitwise OR of the following values:
N//!        - \b ADC_INT0 through ADC_INT31
N//!        - \b ADC_IN_INT - Interrupt enable for a conversion in the result
N//!                          register is either greater than the ADCLO or
N//!                          lower than the ADCHI threshold.
N//!        - \b ADC_LO_INT - Interrupt enable for the falling short of the
N//!                          lower limit interrupt of the window comparator for
N//!                          the result register.
N//!        - \b ADC_HI_INT - Interrupt enable for the exceeding the upper
N//!                          limit of the window comparator for the result
N//!                          register.
N//!        - \b ADC_OV_INT - Interrupt enable for a conversion that is about
N//!                          to save to a memory buffer that has not been read
N//!                          out yet.
N//!        - \b ADC_TOV_INT -Interrupt enable for a conversion that is about
N//!                          to start before the previous conversion has been
N//!                          completed.
N//!        - \b ADC_RDY_INT -Interrupt enable for the local buffered reference
N//!                          ready signal.
N//!
N//!
N//! \return NONE
N//
N//*****************************************************************************
Nextern void ADC14_disableInterrupt(uint_fast64_t mask);
N
N//*****************************************************************************
N//
N//!
N//! Returns the status of a the ADC interrupt register. The ADC_INT0
N//! through ADC_INT31 parameters correspond to a completion event of the
N//! corresponding memory location. For example, when the ADC_MEM0 location
N//! finishes a conversion cycle, the ADC_INT0 interrupt will be set.
N//!
N//! \return The interrupt status. Value is a bitwise OR of the following values:
N//!        - \b ADC_INT0 through ADC_INT31
N//!        - \b ADC_IN_INT - Interrupt enable for a conversion in the result
N//!                          register is either greater than the ADCLO or
N//!                          lower than the ADCHI threshold.
N//!        - \b ADC_LO_INT - Interrupt enable for the falling short of the
N//!                          lower limit interrupt of the window comparator for
N//!                          the result register.
N//!        - \b ADC_HI_INT - Interrupt enable for the exceeding the upper
N//!                          limit of the window comparator for the result
N//!                          register.
N//!        - \b ADC_OV_INT - Interrupt enable for a conversion that is about
N//!                          to save to a memory buffer that has not been read
N//!                          out yet.
N//!        - \b ADC_TOV_INT -Interrupt enable for a conversion that is about
N//!                          to start before the previous conversion has been
N//!                          completed.
N//!        - \b ADC_RDY_INT -Interrupt enable for the local buffered reference
N//!                          ready signal.
N//!
N//!
N//
N//*****************************************************************************
Nextern uint_fast64_t ADC14_getInterruptStatus(void);
N
N//*****************************************************************************
N//
N//!
N//! Returns the status of a the ADC interrupt register masked with the
N//! enabled interrupts. This function is useful to call in ISRs to get a list
N//! of pending interrupts that are actually enabled and could have caused the
N//! ISR. The ADC_INT0 through ADC_INT31 parameters correspond to a
N//! completion event of the corresponding memory location. For example,
N//! when the ADC_MEM0 location finishes a conversion cycle, the ADC_INT0
N// !interrupt will be set.
N//!
N//! \return The interrupt status. Value is a bitwise OR of the following values:
N//!        - \b ADC_INT0 through ADC_INT31
N//!        - \b ADC_IN_INT - Interrupt enable for a conversion in the result
N//!                          register is either greater than the ADCLO or
N//!                          lower than the ADCHI threshold.
N//!        - \b ADC_LO_INT - Interrupt enable for the falling short of the
N//!                          lower limit interrupt of the window comparator for
N//!                          the result register.
N//!        - \b ADC_HI_INT - Interrupt enable for the exceeding the upper
N//!                          limit of the window comparator for the result
N//!                          register.
N//!        - \b ADC_OV_INT - Interrupt enable for a conversion that is about
N//!                          to save to a memory buffer that has not been read
N//!                          out yet.
N//!        - \b ADC_TOV_INT -Interrupt enable for a conversion that is about
N//!                          to start before the previous conversion has been
N//!                          completed.
N//!        - \b ADC_RDY_INT -Interrupt enable for the local buffered reference
N//!                          ready signal.
N//!
N//!
N//
N//*****************************************************************************
Nextern uint_fast64_t ADC14_getEnabledInterruptStatus(void);
N
N//*****************************************************************************
N//
N//!
N//! Clears the indicated ADCC interrupt sources.
N//!
N//! \param mask is the bit mask of interrupts to clear. The ADC_INT0
N//! through ADC_INT31 parameters correspond to a completion event of the
N//! corresponding memory location. For example, when the ADC_MEM0 location
N//! finishes a conversion cycle, the ADC_INT0 interrupt will be set.
N//!        Valid values are a bitwise OR of the following values:
N//!        - \b ADC_INT0 through ADC_INT31
N//!        - \b ADC_IN_INT - Interrupt enable for a conversion in the result
N//!                          register is either greater than the ADCLO or
N//!                          lower than the ADCHI threshold.
N//!        - \b ADC_LO_INT - Interrupt enable for the falling short of the
N//!                          lower limit interrupt of the window comparator for
N//!                          the result register.
N//!        - \b ADC_HI_INT - Interrupt enable for the exceeding the upper
N//!                          limit of the window comparator for the result
N//!                          register.
N//!        - \b ADC_OV_INT - Interrupt enable for a conversion that is about
N//!                          to save to a memory buffer that has not been read
N//!                          out yet.
N//!        - \b ADC_TOV_INT -Interrupt enable for a conversion that is about
N//!                          to start before the previous conversion has been
N//!                          completed.
N//!        - \b ADC_RDY_INT -Interrupt enable for the local buffered reference
N//!                          ready signal.
N//!
N//!
N//! \return NONE
N//
N//*****************************************************************************
Nextern void ADC14_clearInterruptFlag(uint_fast64_t mask);
N
N//*****************************************************************************
N//
N//!
N//! Registers an interrupt handler for the ADC interrupt.
N//!
N//! \param intHandler is a pointer to the function to be called when the ADC
N//!  interrupt occurs.
N//!
N//! This function registers the handler to be called when an ADC
N//! interrupt occurs. This function enables the global interrupt in the
N//! interrupt controller; specific ADC14 interrupts must be enabled
N//! via ADC14_enableInterrupt().  It is the interrupt handler's responsibility
N//! to clear the interrupt source via ADC14_clearInterruptFlag().
N//!
N//! \sa Interrupt_registerInterrupt() for important information about
N//! registering interrupt handlers.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void ADC14_registerInterrupt(void (*intHandler)(void));
N
N//*****************************************************************************
N//
N//!
N//! Unregisters the interrupt handler for the ADCC module.
N//!
N//! This function unregisters the handler to be called when an ADCC
N//! interrupt occurs.  This function also masks off the interrupt in the
N//! interrupt controller so that the interrupt handler no longer is called.
N//!
N//! \sa Interrupt_registerInterrupt() for important information about
N//! registering interrupt handlers.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void ADC14_unregisterInterrupt(void);
N
N/* Defines for future devices that might have multiple instances */
N#define ADC14_enableModuleMultipleInstance(a) ADC14_enableModule()
N#define ADC14_disableModuleMultipleInstance(a) ADC14_disableModule()
N#define ADC14_initModuleMultipleInstance(a,b,c,d,e) ADC14_initModule(b,c,d,e)
N#define ADC14_setResolutionMultipleInstance(a,b) ADC14_setResolution(b)
N#define ADC14_getResolutionMultipleInstance(a) ADC14_getResolution()
N#define ADC14_setSampleHoldTriggerMultipleInstance(a,b,c) ADC14_setSampleHoldTrigger(b,c)
N#define ADC14_setSampleHoldTimeMultipleInstance(a,b,c) ADC14_setSampleHoldTime(b,c)
N#define ADC14_configureMultiSequenceModeMultipleInstance(a,b,c,d) ADC14_configureMultiSequenceMode(b,c,d)
N#define ADC14_configureSingleSampleModeMultipleInstance(a,b,c) ADC14_configureSingleSampleMode(b,c)
N#define ADC14_enableConversionMultipleInstance(a,b) ADC14_enableConversion(b)
N#define ADC14_disableConversionMultipleInstance(a) ADC14_disableConversion()
N#define ADC14_toggleConversionTriggerMultipleInstance(a) ADC14_toggleConversionTrigger()
N#define ADC14_isBusyMultipleInstance(a) ADC14_isBusy()
N#define ADC14_configureConversionMemoryMultipleInstance(a,b,c,d,e) ADC14_configureConversionMemory(b,c,d,e)
N#define ADC14_enableComparatorWindowMultipleInstance(a,b,c) ADC14_enableComparatorWindow(b,c)
N#define ADC14_disableComparatorWindowMultipleInstance(a,b) ADC14_disableComparatorWindow(b)
N#define ADC14_setComparatorWindowValueMultipleInstance(a,b,c,d) ADC14_setComparatorWindowValue(b,c,d)
N#define ADC14_setResultFormatMultipleInstance(a,b) ADC14_setResultFormat(b)
N#define ADC14_getResultMultipleInstance(a,b) ADC14_getResult(b)
N#define ADC14_getMultiSequenceResultMultipleInstance(a,b) ADC14_getMultiSequenceResult(b)
N#define ADC14_getResultArrayMultipleInstance(a,b,c,d) ADC14_getResultArray(b,c,d)
N#define ADC14_enableReferenceBurstMultipleInstance(a) ADC14_enableReferenceBurst()
N#define ADC14_disableReferenceBurstMultipleInstance(a) ADC14_disableReferenceBurst()
N#define ADC14_setPowerModeMultipleInstance(a,b) ADC14_setPowerMode(b)
N#define ADC14_enableSampleTimerMultipleInstance(a,b) ADC14_enableSampleTimer(b)
N#define ADC14_disableSampleTimerMultipleInstance(a) ADC14_disableSampleTimer()
N#define ADC14_enableInterruptMultipleInstance(a,b) ADC14_enableInterrupt(b)
N#define ADC14_disableInterruptMultipleInstance(a,b) ADC14_disableInterrupt(b)
N#define ADC14_getInterruptStatusMultipleInstance(a) ADC14_getInterruptStatus()
N#define ADC14_getEnabledInterruptStatusMultipleInstance(a) ADC14_getEnabledInterruptStatus()
N#define ADC14_clearInterruptFlagMultipleInstance(a,b) ADC14_clearInterruptFlag(b)
N#define ADC14_registerInterruptMultipleInstance(a,b) ADC14_registerInterrupt(b)
N#define ADC14_unregisterInterruptMultipleInstance(a) ADC14_unregisterInterrupt()
N
N//*****************************************************************************
N//
N// Mark the end of the C bindings section for C++ compilers.
N//
N//*****************************************************************************
N#ifdef __cplusplus
N}
N#endif
N
N//*****************************************************************************
N//
N// Close the Doxygen group.
N//! @}
N//
N//*****************************************************************************
N
N#endif /* ADC14_H_ */
L 41 "C:/ti/msp432_driverlib_3_21_00_05/driverlib/MSP432P4xx/driverlib.h" 2
N#include "aes256.h"
L 1 "C:\ti\msp432_driverlib_3_21_00_05\driverlib\MSP432P4xx\aes256.h" 1
N/*
N * -------------------------------------------
N *    MSP432 DriverLib - v3_21_00_05 
N * -------------------------------------------
N *
N * --COPYRIGHT--,BSD,BSD
N * Copyright (c) 2016, Texas Instruments Incorporated
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N *
N * *  Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N *
N * *  Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * *  Neither the name of Texas Instruments Incorporated nor the names of
N *    its contributors may be used to endorse or promote products derived
N *    from this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
N * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
N * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
N * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
N * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
N * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
N * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
N * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
N * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * --/COPYRIGHT--*/
N#ifndef AES256_H_
N#define AES256_H_
N
N//*****************************************************************************
N//
N//! \addtogroup aes256_api
N//! @{
N//
N//*****************************************************************************
N
N//*****************************************************************************
N//
N// If building with a C++ compiler, make all of the definitions in this header
N// have a C binding.
N//
N//*****************************************************************************
N#ifdef __cplusplus
Nextern "C"
N{
N#endif
N
N#include <stdint.h>
N#include <stdbool.h>
N#include <msp.h>
N
N/* Module Defines and macro for easy access */
N#define AES256_CMSIS(x) ((AES256_Type *) x)
N
N//*****************************************************************************
N//
N// The following are deprecated values. Please refer to documentation for the
N// correct values to use.
N//
N//*****************************************************************************
N#define Key_128BIT                                                          128
N#define Key_192BIT                                                          192
N#define Key_256BIT                                                          256
N
N//*****************************************************************************
N//
N// The following are values that can be passed to the keyLength parameter for
N// functions: AES256_setCipherKey(), AES256_setDecipherKey(), and
N// AES256_startSetDecipherKey().
N//
N//*****************************************************************************
N#define AES256_KEYLENGTH_128BIT                                             128
N#define AES256_KEYLENGTH_192BIT                                             192
N#define AES256_KEYLENGTH_256BIT                                             256
N
N//*****************************************************************************
N//
N// The following are values that can be passed toThe following are values that
N// can be returned by the AES256_getErrorFlagStatus() function.
N//
N//*****************************************************************************
N#define AES256_ERROR_OCCURRED                                 AES256_CTL0_ERRFG
N#define AES256_NO_ERROR                                                    0x00
N
N//*****************************************************************************
N//
N// The following are values that can be passed toThe following are values that
N// can be returned by the AES256_isBusy() function.
N//
N//*****************************************************************************
N#define AES256_BUSY                                            AES256_STAT_BUSY
N#define AES256_NOT_BUSY                                                    0x00
N
N//*****************************************************************************
N//
N// The following are values that can be passed toThe following are values that
N// can be returned by the AES256_getInterruptFlagStatus() function.
N//
N//*****************************************************************************
N#define AES256_READY_INTERRUPT                                             0x01
N#define AES256_NOTREADY_INTERRUPT                                          0x00
N
N//*****************************************************************************
N//
N// Prototypes for the APIs.
N//
N//*****************************************************************************
N
N//*****************************************************************************
N//
N//! \brief Loads a 128, 192 or 256 bit cipher key to AES256 module.
N//!
N//! \param moduleInstance is the base address of the AES256 module.
N//! \param cipherKey is a pointer to an uint8_t array with a length of 16 bytes
N//!        that contains a 128 bit cipher key.
N//! \param keyLength is the length of the key.
N//!        Valid values are:
N//!        - \b AES256_KEYLENGTH_128BIT
N//!        - \b AES256_KEYLENGTH_192BIT
N//!        - \b AES256_KEYLENGTH_256BIT
N//!
N//! \return true if set correctly, false otherwise
N//
N//*****************************************************************************
Nextern bool AES256_setCipherKey(uint32_t moduleInstance,
N        const uint8_t *cipherKey, uint_fast16_t keyLength);
N
N//*****************************************************************************
N//
N//! \brief Encrypts a block of data using the AES256 module.
N//!
N//! The cipher key that is used for encryption should be loaded in advance by
N//! using function AES256_setCipherKey()
N//!
N//! \param moduleInstance is the base address of the AES256 module.
N//! \param data is a pointer to an uint8_t array with a length of 16 bytes that
N//!        contains data to be encrypted.
N//! \param encryptedData is a pointer to an uint8_t array with a length of 16
N//!        bytes in that the encrypted data will be written.
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void AES256_encryptData(uint32_t moduleInstance, const uint8_t *data,
N        uint8_t *encryptedData);
N
N//*****************************************************************************
N//
N//! \brief Decrypts a block of data using the AES256 module.
N//!
N//! This function requires a pregenerated decryption key. A key can be loaded
N//! and pregenerated by using function AES256_setDecipherKey() or
N//! AES256_startSetDecipherKey(). The decryption takes 167 MCLK.
N//!
N//! \param moduleInstance is the base address of the AES256 module.
N//! \param data is a pointer to an uint8_t array with a length of 16 bytes that
N//!        contains encrypted data to be decrypted.
N//! \param decryptedData is a pointer to an uint8_t array with a length of 16
N//!        bytes in that the decrypted data will be written.
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void AES256_decryptData(uint32_t moduleInstance, const uint8_t *data,
N        uint8_t *decryptedData);
N
N//*****************************************************************************
N//
N//! \brief Sets the decipher key.
N//!
N//! The API AES256_startSetDecipherKey or AES256_setDecipherKey must be invoked
N//! before invoking AES256_startDecryptData.
N//!
N//! \param moduleInstance is the base address of the AES256 module.
N//! \param cipherKey is a pointer to an uint8_t array with a length of 16 bytes
N//!        that contains a 128 bit cipher key.
N//! \param keyLength is the length of the key.
N//!        Valid values are:
N//!        - \b AES256_KEYLENGTH_128BIT
N//!        - \b AES256_KEYLENGTH_192BIT
N//!        - \b AES256_KEYLENGTH_256BIT
N//!
N//! \return true if set, false otherwise
N//
N//*****************************************************************************
Nextern bool AES256_setDecipherKey(uint32_t moduleInstance,
N        const uint8_t *cipherKey, uint_fast16_t keyLength);
N
N//*****************************************************************************
N//
N//! \brief Clears the AES256 ready interrupt flag.
N//!
N//! \param moduleInstance is the base address of the AES256 module.
N//!
N//! Modified bits are \b AESRDYIFG of \b AESACTL0 register.
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void AES256_clearInterruptFlag(uint32_t moduleInstance);
N
N//*****************************************************************************
N//
N//! \brief Gets the AES256 ready interrupt flag status.
N//!
N//! \param moduleInstance is the base address of the AES256 module.
N//!
N//! \return One of the following:
N//!         - \b AES256_READY_INTERRUPT
N//!         - \b AES256_NOTREADY_INTERRUPT
N//!         \n indicating the status of the AES256 ready status
N//
N//*****************************************************************************
Nextern uint32_t AES256_getInterruptFlagStatus(uint32_t moduleInstance);
N
N//*****************************************************************************
N//
N//! \brief Enables AES256 ready interrupt.
N//!
N//! \param moduleInstance is the base address of the AES256 module.
N//!
N//! Modified bits are \b AESRDYIE of \b AESACTL0 register.
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void AES256_enableInterrupt(uint32_t moduleInstance);
N
N//*****************************************************************************
N//
N//! \brief Disables AES256 ready interrupt.
N//!
N//! \param moduleInstance is the base address of the AES256 module.
N//!
N//! Modified bits are \b AESRDYIE of \b AESACTL0 register.
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void AES256_disableInterrupt(uint32_t moduleInstance);
N
N//*****************************************************************************
N//
N//! \brief Resets AES256 Module immediately.
N//!
N//! \param moduleInstance is the base address of the AES256 module.
N//!
N//! Modified bits are \b AESSWRST of \b AESACTL0 register.
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void AES256_reset(uint32_t moduleInstance);
N
N//*****************************************************************************
N//
N//! \brief Starts an encryption process on the AES256 module.
N//!
N//! The cipher key that is used for decryption should be loaded in advance by
N//! using function AES256_setCipherKey(). This is a non-blocking equivalent pf
N//! AES256_encryptData(). It is recommended to use the interrupt functionality
N//! to check for procedure completion then use the AES256_getDataOut() API to
N//! retrieve the encrypted data.
N//!
N//! \param moduleInstance is the base address of the AES256 module.
N//! \param data is a pointer to an uint8_t array with a length of 16 bytes that
N//!        contains data to be encrypted.
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void AES256_startEncryptData(uint32_t moduleInstance,
N        const uint8_t *data);
N
N//*****************************************************************************
N//
N//! \brief Decypts a block of data using the AES256 module.
N//!
N//! This is the non-blocking equivalant of AES256_decryptData(). This function
N//! requires a pregenerated decryption key. A key can be loaded and
N//! pregenerated by using function AES256_setDecipherKey() or
N//! AES256_startSetDecipherKey(). The decryption takes 167 MCLK. It is
N//! recommended to use interrupt to check for procedure completion then use the
N//! AES256_getDataOut() API to retrieve the decrypted data.
N//!
N//! \param moduleInstance is the base address of the AES256 module.
N//! \param data is a pointer to an uint8_t array with a length of 16 bytes that
N//!        contains encrypted data to be decrypted.
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void AES256_startDecryptData(uint32_t moduleInstance,
N        const uint8_t *data);
N
N//*****************************************************************************
N//
N//! \brief Sets the decipher key
N//!
N//! The API AES256_startSetDecipherKey() or AES256_setDecipherKey() must be
N//! invoked before invoking AES256_startDecryptData.
N//!
N//! \param moduleInstance is the base address of the AES256 module.
N//! \param cipherKey is a pointer to an uint8_t array with a length of 16 bytes
N//!        that contains a 128 bit cipher key.
N//! \param keyLength is the length of the key.
N//!        Valid values are:
N//!        - \b AES256_KEYLENGTH_128BIT
N//!        - \b AES256_KEYLENGTH_192BIT
N//!        - \b AES256_KEYLENGTH_256BIT
N//!
N//! \return true if set correctly, false otherwise
N//
N//*****************************************************************************
Nextern bool AES256_startSetDecipherKey(uint32_t moduleInstance,
N        const uint8_t *cipherKey, uint_fast16_t keyLength);
N
N//*****************************************************************************
N//
N//! \brief Reads back the output data from AES256 module.
N//!
N//! This function is meant to use after an encryption or decryption process
N//! that was started and finished by initiating an interrupt by use of
N//! AES256_startEncryptData or AES256_startDecryptData functions.
N//!
N//! \param moduleInstance is the base address of the AES256 module.
N//! \param outputData is a pointer to an uint8_t array with a length of 16
N//!        bytes in that the data will be written.
N//!
N//! \return true if data is valid, otherwise false
N//
N//*****************************************************************************
Nextern bool AES256_getDataOut(uint32_t moduleInstance,
N        uint8_t *outputData);
N
N//*****************************************************************************
N//
N//! \brief Gets the AES256 module busy status.
N//!
N//! \param moduleInstance is the base address of the AES256 module.
N//!
N//! \return true if busy, false otherwise
N//
N//*****************************************************************************
Nextern bool AES256_isBusy(uint32_t moduleInstance);
N
N//*****************************************************************************
N//
N//! \brief Clears the AES256 error flag.
N//!
N//! \param moduleInstance is the base address of the AES256 module.
N//!
N//! Modified bits are \b AESERRFG of \b AESACTL0 register.
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void AES256_clearErrorFlag(uint32_t moduleInstance);
N
N//*****************************************************************************
N//
N//! \brief Gets the AES256 error flag status.
N//!
N//! \param moduleInstance is the base address of the AES256 module.
N//!
N//! \return One of the following:
N//!         - \b AES256_ERROR_OCCURRED
N//!         - \b AES256_NO_ERROR
N//!         \n indicating the error flag status
N//
N//*****************************************************************************
Nextern uint32_t AES256_getErrorFlagStatus(uint32_t moduleInstance);
N
N//*****************************************************************************
N//
N//! Registers an interrupt handler for the AES interrupt.
N//!
N//! \param moduleInstance Instance of the AES256 module
N//!
N//! \param intHandler is a pointer to the function to be called when the
N//! AES interrupt occurs.
N//!
N//! This function registers the handler to be called when a AES
N//! interrupt occurs. This function enables the global interrupt in the
N//! interrupt controller; specific AES interrupts must be enabled
N//! via AES256_enableInterrupt().  It is the interrupt handler's responsibility
N//! to clear the interrupt source via AES256_clearInterrupt().
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void AES256_registerInterrupt(uint32_t moduleInstance,
N        void (*intHandler)(void));
N
N//*****************************************************************************
N//
N//! Unregisters the interrupt handler for the AES interrupt
N//!
N//! \param moduleInstance Instance of the AES256 module
N//!
N//! This function unregisters the handler to be called when AES
N//! interrupt occurs.  This function also masks off the interrupt in the
N//! interrupt controller so that the interrupt handler no longer is called.
N//!
N//! \sa Interrupt_registerInterrupt() for important information about
N//! registering interrupt handlers.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void AES256_unregisterInterrupt(uint32_t moduleInstance);
N
N//*****************************************************************************
N//
N//! Returns the current interrupt flag for the peripheral.
N//!
N//! \param moduleInstance Instance of the AES256 module
N//!
N//! \return The currently triggered interrupt flag for the module.
N//
N//*****************************************************************************
Nextern uint32_t AES256_getInterruptStatus(uint32_t moduleInstance);
N
N//*****************************************************************************
N//
N// Mark the end of the C bindings section for C++ compilers.
N//
N//*****************************************************************************
N#ifdef __cplusplus
N}
N#endif
N
N//*****************************************************************************
N//
N// Close the Doxygen group.
N//! @}
N//
N//*****************************************************************************
N
N#endif /* AES256_H_ */
N
L 42 "C:/ti/msp432_driverlib_3_21_00_05/driverlib/MSP432P4xx/driverlib.h" 2
N#include "comp_e.h"
L 1 "C:\ti\msp432_driverlib_3_21_00_05\driverlib\MSP432P4xx\comp_e.h" 1
N/*
N * -------------------------------------------
N *    MSP432 DriverLib - v3_21_00_05 
N * -------------------------------------------
N *
N * --COPYRIGHT--,BSD,BSD
N * Copyright (c) 2016, Texas Instruments Incorporated
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N *
N * *  Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N *
N * *  Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * *  Neither the name of Texas Instruments Incorporated nor the names of
N *    its contributors may be used to endorse or promote products derived
N *    from this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
N * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
N * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
N * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
N * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
N * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
N * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
N * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
N * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * --/COPYRIGHT--*/
N#ifndef COMP_E_H_
N#define COMP_E_H_
N
N//*****************************************************************************
N//
N//! \addtogroup comp_api
N//! @{
N//
N//*****************************************************************************
N
N//*****************************************************************************
N//
N// If building with a C++ compiler, make all of the definitions in this header
N// have a C binding.
N//
N//*****************************************************************************
N#ifdef __cplusplus
Nextern "C"
N{
N#endif
N
N#include <stdint.h>
N#include <stdbool.h>
N#include <msp.h>
N
N/* Module defines for Comp */
N#define COMP_E_CMSIS(x) ((COMP_E_Type *) x)
N
N#define COMP_E_FILTEROUTPUT_OFF                                            0x00
N#define COMP_E_FILTEROUTPUT_DLYLVL1         (COMP_E_CTL1_F + COMP_E_CTL1_FDLY_0)
N#define COMP_E_FILTEROUTPUT_DLYLVL2         (COMP_E_CTL1_F + COMP_E_CTL1_FDLY_1)
N#define COMP_E_FILTEROUTPUT_DLYLVL3         (COMP_E_CTL1_F + COMP_E_CTL1_FDLY_2)
N#define COMP_E_FILTEROUTPUT_DLYLVL4         (COMP_E_CTL1_F + COMP_E_CTL1_FDLY_3)
N
N#define COMP_E_INPUT0                                                    (0x01)
N#define COMP_E_INPUT1                                                    (0x02)
N#define COMP_E_INPUT2                                                    (0x04)
N#define COMP_E_INPUT3                                                    (0x08)
N#define COMP_E_INPUT4                                                    (0x10)
N#define COMP_E_INPUT5                                                    (0x20)
N#define COMP_E_INPUT6                                                    (0x40)
N#define COMP_E_INPUT7                                                    (0x80)
N#define COMP_E_INPUT8                                                   (0x100)
N#define COMP_E_INPUT9                                                   (0x200)
N#define COMP_E_INPUT10                                                  (0x400)
N#define COMP_E_INPUT11                                                  (0x800)
N#define COMP_E_INPUT12                                                 (0x1000)
N#define COMP_E_INPUT13                                                 (0x2000)
N#define COMP_E_INPUT14                                                 (0x4000)
N#define COMP_E_INPUT15                                                 (0x8000)
N#define COMP_E_VREF                                                      (0x9F)
N
N#define COMP_E_NORMALOUTPUTPOLARITY                      (!(COMP_E_CTL1_OUTPOL))
N#define COMP_E_INVERTEDOUTPUTPOLARITY                       (COMP_E_CTL1_OUTPOL)
N
N#define COMP_E_REFERENCE_AMPLIFIER_DISABLED               (COMP_E_CTL2_CEREFL_0)
N#define COMP_E_VREFBASE1_2V                               (COMP_E_CTL2_CEREFL_1)
N#define COMP_E_VREFBASE2_0V                               (COMP_E_CTL2_CEREFL_2)
N#define COMP_E_VREFBASE2_5V                               (COMP_E_CTL2_CEREFL_3)
N
N#define COMP_E_ACCURACY_STATIC                             (!COMP_E_CTL2_REFACC)
N#define COMP_E_ACCURACY_CLOCKED                             (COMP_E_CTL2_REFACC)
N
N#define COMP_E_HIGH_SPEED_MODE                             (COMP_E_CTL1_PWRMD_0)
N#define COMP_E_NORMAL_MODE                                 (COMP_E_CTL1_PWRMD_1)
N#define COMP_E_ULTRA_LOW_POWER_MODE                        (COMP_E_CTL1_PWRMD_2)
N
N#define COMP_E_OUTPUT_INTERRUPT                                  (COMP_E_INT_IE)
N#define COMP_E_INVERTED_POLARITY_INTERRUPT                      (COMP_E_INT_IIE)
N#define COMP_E_READY_INTERRUPT                                (COMP_E_INT_RDYIE)
N
N#define COMP_E_OUTPUT_INTERRUPT_FLAG                            (COMP_E_INT_IFG)
N#define COMP_E_INTERRUPT_FLAG_INVERTED_POLARITY                (COMP_E_INT_IIFG)
N#define COMP_E_INTERRUPT_FLAG_READY                          (COMP_E_INT_RDYIFG)
N
N#define COMP_E_FALLINGEDGE                                  (!(COMP_E_CTL1_IES))
N#define COMP_E_RISINGEDGE                                      (COMP_E_CTL1_IES)
N
N#define COMP_E_LOW                                                         (0x0)
N#define COMP_E_HIGH                                            (COMP_E_CTL1_OUT)
N
N//*****************************************************************************
N//
N//!     ypedef COMP_E_Config
N//! \brief Type definition for \link _COMP_E_Config \endlink structure
N//!
N//! \struct _COMP_E_Config
N//! \brief Configuration structure for Comparator module. See 
N//!        \link COMP_E_initModule \endlink for parameter documentation.
N//
N//*****************************************************************************
Ntypedef struct _COMP_E_Config
N{
N    uint_fast16_t positiveTerminalInput;
N    uint_fast16_t negativeTerminalInput;
N    uint_fast8_t outputFilterEnableAndDelayLevel;
N    uint_fast8_t invertedOutputPolarity;
N    uint_fast16_t powerMode;
N} COMP_E_Config;
N
N//*****************************************************************************
N//
N//! Initializes the Comparator Module.
N//!
N//! \param comparator is the instance of the Comparator module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b COMP_E0_BASE
N//!         - \b COMP_E1_BASE
N//! \param config Configuration structure for the Comparator module
N//!
N//! <hr>
N//! <b>Configuration options for \link COMP_E_Config \endlink structure.</b>
N//! <hr>
N//!
N//! \param positiveTerminalInput selects the input to the positive terminal.
N//!        Valid values are
N//!        - \b COMP_E_INPUT0 [Default]
N//!        - \b COMP_E_INPUT1
N//!        - \b COMP_E_INPUT2
N//!        - \b COMP_E_INPUT3
N//!        - \b COMP_E_INPUT4
N//!        - \b COMP_E_INPUT5
N//!        - \b COMP_E_INPUT6
N//!        - \b COMP_E_INPUT7
N//!        - \b COMP_E_INPUT8
N//!        - \b COMP_E_INPUT9
N//!        - \b COMP_E_INPUT10
N//!        - \b COMP_E_INPUT11
N//!        - \b COMP_E_INPUT12
N//!        - \b COMP_E_INPUT13
N//!        - \b COMP_E_INPUT14
N//!        - \b COMP_E_INPUT15
N//!        - \b COMP_E_VREF
N//!        \n Modified bits are \b CEIPSEL and \b CEIPEN of \b CECTL0 register,
N//!        \b CERSEL of \b CECTL2 register, and CEPDx of \b CECTL3 register.
N//! \param negativeTerminalInput selects the input to the negative terminal.
N//!        \n Valid values are:
N//!        - \b COMP_E_INPUT0 [Default]
N//!        - \b COMP_E_INPUT1
N//!        - \b COMP_E_INPUT2
N//!        - \b COMP_E_INPUT3
N//!        - \b COMP_E_INPUT4
N//!        - \b COMP_E_INPUT5
N//!        - \b COMP_E_INPUT6
N//!        - \b COMP_E_INPUT7
N//!        - \b COMP_E_INPUT8
N//!        - \b COMP_E_INPUT9
N//!        - \b COMP_E_INPUT10
N//!        - \b COMP_E_INPUT11
N//!        - \b COMP_E_INPUT12
N//!        - \b COMP_E_INPUT13
N//!        - \b COMP_E_INPUT14
N//!        - \b COMP_E_INPUT15
N//!        - \b COMP_E_VREF
N//!        \n Modified bits are \b CEIMSEL and \b CEIMEN of \b CECTL0 register,
N//!        \b CERSEL of \b CECTL2 register, and CEPDx of \b CECTL3 register.
N//! \param outputFilterEnableAndDelayLevel controls the output filter delay
N//!       state, which is either off or enabled with a specified delay level.
N//!        \n Valid values are
N//!        - \b COMP_E_FILTEROUTPUT_OFF [Default]
N//!        - \b COMP_E_FILTEROUTPUT_DLYLVL1
N//!        - \b COMP_E_FILTEROUTPUT_DLYLVL2
N//!        - \b COMP_E_FILTEROUTPUT_DLYLVL3
N//!        - \b COMP_E_FILTEROUTPUT_DLYLVL4
N//!        \n This parameter is device specific and delay levels should be found
N//!        in the device's datasheet.
N//!        \n Modified bits are \b CEF and \b CEFDLY of \b CECTL1 register.
N//! \param invertedOutputPolarity controls if the output will be inverted or
N//!        not. Valid values are
N//!        - \b COMP_E_NORMALOUTPUTPOLARITY - indicates the output should be
N//!             normal. [Default]
N//!        - \b COMP_E_INVERTEDOUTPUTPOLARITY -  the output should be inverted.
N//!        \n Modified bits are \b CEOUTPOL of \b CECTL1 register.
N//! \param powerMode controls the power mode of the module
N//!        - \b COMP_E_HIGH_SPEED_MODE [default]
N//!        - \b COMP_E_NORMAL_MODE
N//!        - \b COMP_E_ULTRA_LOW_POWER_MODE
N//! Upon successful initialization of the Comparator module, this function will
N//! have reset all necessary register bits and set the given options in the
N//! registers. To actually use the comparator module, the COMP_E_enableModule()
N//! function must be explicitly called before use.
N//! If a Reference Voltage is set to a terminal, the Voltage should be set
N//! using the COMP_E_setReferenceVoltage() function.
N//!
N//! \return true or false of the initialization process.
N//
N//*****************************************************************************
Nextern bool COMP_E_initModule(uint32_t comparator, const COMP_E_Config *config);
N
N//*****************************************************************************
N//
N//! Generates a Reference Voltage to the terminal selected during
N//! initialization.
N//!
N//! \param comparator is the instance of the Comparator module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b COMP_E0_BASE
N//!         - \b COMP_E1_BASE
N//! \param supplyVoltageReferenceBase decides the source and max amount of
N//!       Voltage that can be used as a reference.
N//!        Valid values are
N//!        - \b COMP_E_REFERENCE_AMPLIFIER_DISABLED
N//!        - \b COMP_E_VREFBASE1_2V
N//!        - \b COMP_E_VREFBASE2_0V
N//!        - \b COMP_E_VREFBASE2_5V
N//! \param upperLimitSupplyVoltageFractionOf32 is the numerator of the
N//!       equation to generate the reference voltage for the upper limit
N//!       reference voltage. Valid values are between 0 and 32.
N//! \param lowerLimitSupplyVoltageFractionOf32 is the numerator of the
N//!       equation to generate the reference voltage for the lower limit
N//!       reference voltage. Valid values are between 0 and 32.
N//!  <br>Modified bits are \b CEREF0 of \b CECTL2 register.
N//!
N//! Use this function to generate a voltage to serve as a reference to the
N//! terminal selected at initialization. The voltage is determined by the
N//! equation: Vbase * (Numerator / 32). If the upper and lower limit voltage
N//! numerators are equal, then a static reference is defined, whereas they are
N//! different then a hysteresis effect is generated.
N//!
N//! \return NONE
N//
N//*****************************************************************************
Nextern void COMP_E_setReferenceVoltage(uint32_t comparator,
N        uint_fast16_t supplyVoltageReferenceBase,
N        uint_fast16_t lowerLimitSupplyVoltageFractionOf32,
N        uint_fast16_t upperLimitSupplyVoltageFractionOf32);
N
N//*****************************************************************************
N//
N//! Sets the reference accuracy
N//!
N//! \param comparator is the instance of the Comparator module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b COMP_E0_BASE
N//!         - \b COMP_E1_BASE
N//! \param referenceAccuracy is the reference accuracy setting of the
N//!      comparator. Clocked is for low power/low accuracy.
N//!      Valid values are
N//!      - \b COMP_E_ACCURACY_STATIC
N//!      - \b COMP_E_ACCURACY_CLOCKED
N//!      <br>Modified bits are \b CEREFACC of \b CECTL2 register.
N//!
N//! The reference accuracy is set to the desired setting. Clocked is better for
N//!  low power operations but has a lower accuracy.
N//!
N//! \return NONE
N//
N//*****************************************************************************
Nextern void COMP_E_setReferenceAccuracy(uint32_t comparator,
N        uint_fast16_t referenceAccuracy);
N
N//*****************************************************************************
N//
N//! Sets the power mode
N//!
N//! \param comparator is the instance of the Comparator module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b COMP_E0_BASE
N//!         - \b COMP_E1_BASE
N//! \param powerMode decides the power mode
N//!        Valid values are
N//!        - \b COMP_E_HIGH_SPEED_MODE
N//!        - \b COMP_E_NORMAL_MODE
N//!        - \b COMP_E_ULTRA_LOW_POWER_MODE
N//!        <br>Modified bits are \b CEPWRMD of \b CECTL1 register.
N//!
N//! \return NONE
N//
N//*****************************************************************************
Nextern void COMP_E_setPowerMode(uint32_t comparator, uint_fast16_t powerMode);
N
N//*****************************************************************************
N//
N//! Turns on the Comparator module.
N//!
N//! \param comparator is the instance of the Comparator module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b COMP_E0_BASE
N//!         - \b COMP_E1_BASE
N//!
N//! This function sets the bit that enables the operation of the
N//! Comparator module.
N//!
N//! \return NONE
N//
N//*****************************************************************************
Nextern void COMP_E_enableModule(uint32_t comparator);
N
N//*****************************************************************************
N//
N//! Turns off the Comparator module.
N//!
N//! \param comparator is the instance of the Comparator module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b COMP_E0_BASE
N//!         - \b COMP_E1_BASE
N//!
N//! This function clears the CEON bit disabling the operation of the Comparator
N//! module, saving from excess power consumption.
N//!
N//! Modified bits are \b CEON of \b CECTL1 register.
N//! \return NONE
N//
N//*****************************************************************************
Nextern void COMP_E_disableModule(uint32_t comparator);
N
N//*****************************************************************************
N//
N//! Shorts the two input pins chosen during initialization.
N//!
N//! \param comparator is the instance of the Comparator module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b COMP_E0_BASE
N//!         - \b COMP_E1_BASE
N//!
N//! This function sets the bit that shorts the devices attached to the input
N//! pins chosen from the initialization of the comparator.
N//!
N//! Modified bits are \b CESHORT of \b CECTL1 register.
N//! \return NONE
N//
N//*****************************************************************************
Nextern void COMP_E_shortInputs(uint32_t comparator);
N
N//*****************************************************************************
N//
N//! Disables the short of the two input pins chosen during initialization.
N//!
N//! \param comparator is the instance of the Comparator module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b COMP_E0_BASE
N//!         - \b COMP_E1_BASE
N//!
N//! This function clears the bit that shorts the devices attached to the input
N//! pins chosen from the initialization of the comparator.
N//!
N//! Modified bits are \b CESHORT of \b CECTL1 register.
N//! \return NONE
N//
N//*****************************************************************************
Nextern void COMP_E_unshortInputs(uint32_t comparator);
N
N//*****************************************************************************
N//
N//! Disables the input buffer of the selected input port to effectively allow
N//! for analog signals.
N//!
N//! \param comparator is the instance of the Comparator module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b COMP_E0_BASE
N//!         - \b COMP_E1_BASE
N//! \param inputPort is the port in which the input buffer will be disabled.
N//!        Valid values are a logical OR of the following:
N//!        - \b COMP_E_INPUT0 [Default]
N//!        - \b COMP_E_INPUT1
N//!        - \b COMP_E_INPUT2
N//!        - \b COMP_E_INPUT3
N//!        - \b COMP_E_INPUT4
N//!        - \b COMP_E_INPUT5
N//!        - \b COMP_E_INPUT6
N//!        - \b COMP_E_INPUT7
N//!        - \b COMP_E_INPUT8
N//!        - \b COMP_E_INPUT9
N//!        - \b COMP_E_INPUT10
N//!        - \b COMP_E_INPUT11
N//!        - \b COMP_E_INPUT12
N//!        - \b COMP_E_INPUT13
N//!        - \b COMP_E_INPUT14
N//!        - \b COMP_E_INPUT15
N//!       <br> Modified bits are \b CEPDx of \b CECTL3 register.
N//!
N//! This function sets the bit to disable the buffer for the specified input
N//! port to allow for analog signals from any of the comparator input pins. This
N//! bit is automatically set when the input is initialized to be used with the
N//! comparator module. This function should be used whenever an analog input is
N//! connected to one of these pins to prevent parasitic voltage from causing
N//! unexpected results.
N//!
N//! \return NONE
N//
N//*****************************************************************************
Nextern void COMP_E_disableInputBuffer(uint32_t comparator,
N        uint_fast16_t inputPort);
N
N//*****************************************************************************
N//
N//! Enables the input buffer of the selected input port to allow for digital
N//! signals.
N//!
N//! \param comparator is the instance of the Comparator module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b COMP_E0_BASE
N//!         - \b COMP_E1_BASE
N//! \param inputPort is the port in which the input buffer will be enabled.
N//!        Valid values are a logical OR of the following:
N//!        - \b COMP_E_INPUT0 [Default]
N//!        - \b COMP_E_INPUT1
N//!        - \b COMP_E_INPUT2
N//!        - \b COMP_E_INPUT3
N//!        - \b COMP_E_INPUT4
N//!        - \b COMP_E_INPUT5
N//!        - \b COMP_E_INPUT6
N//!        - \b COMP_E_INPUT7
N//!        - \b COMP_E_INPUT8
N//!        - \b COMP_E_INPUT9
N//!        - \b COMP_E_INPUT10
N//!        - \b COMP_E_INPUT11
N//!        - \b COMP_E_INPUT12
N//!        - \b COMP_E_INPUT13
N//!        - \b COMP_E_INPUT14
N//!        - \b COMP_E_INPUT15
N//!      <br> Modified bits are \b CEPDx of \b CECTL3 register.
N//!
N//! This function clears the bit to enable the buffer for the specified input
N//! port to allow for digital signals from any of the comparator input pins.
N//! This should not be reset if there is an analog signal connected to the
N//! specified input pin to prevent from unexpected results.
N//!
N//! \return NONE
N//
N//*****************************************************************************
Nextern void COMP_E_enableInputBuffer(uint32_t comparator,
N        uint_fast16_t inputPort);
N
N//*****************************************************************************
N//
N//! Toggles the bit that swaps which terminals the inputs go to, while also
N//! inverting the output of the comparator.
N//!
N//! \param comparator is the instance of the Comparator module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \ bCOMP_E0
N//!         - \ bCOMP_E1
N//!
N//! This function toggles the bit that controls which input goes to which
N//! terminal. After initialization, this bit is set to 0, after toggling it once
N//! the inputs are routed to the opposite terminal and the output is inverted.
N//!
N//! Modified bits are \b CEEX of \b CECTL1 register.
N//! \return NONE
N//
N//*****************************************************************************
Nextern void COMP_E_swapIO(uint32_t comparator);
N
N//*****************************************************************************
N//
N//! Returns the output value of the Comparator module.
N//!
N//! \param comparator is the instance of the Comparator module. Valid parameters
N//! vary from part to part, but can include:
N//!         - \b COMP_E0_BASE
N//!         - \b COMP_E1_BASE
N//!
N//! Returns the output value of the Comparator module.
N//!
N//! \return COMP_E_HIGH or COMP_E_LOW as the output value of the Comparator
N//!          module.
N//
N//*****************************************************************************
Nextern uint8_t COMP_E_outputValue(uint32_t comparator);
N
N//*****************************************************************************
N//
N//! Enables selected Comparator interrupt sources.
N//!
N//! \param comparator is the instance of the Comparator module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b COMP_E0_BASE
N//!         - \b COMP_E1_BASE
N//! \param mask is the bit mask of the interrupt sources to be enabled.
N//!        Mask value is the logical OR of any of the following
N//!        - \b COMP_E_OUTPUT_INTERRUPT - Output interrupt
N//!        - \b COMP_E_INVERTED_POLARITY_INTERRUPT - Output interrupt inverted
N//!                                                 polarity
N//!        - \b COMP_E_READY_INTERRUPT - Ready interrupt
N//!
N//! Enables the indicated Comparator interrupt sources.  Only the sources that
N//! are enabled can be reflected to the processor interrupt; disabled sources
N//! have no effect on the processor. The default trigger for the non-inverted
N//! interrupt is a rising edge of the output, this can be changed with the
N//! interruptSetEdgeDirection() function.
N//!
N//! \return NONE
N//
N//*****************************************************************************
Nextern void COMP_E_enableInterrupt(uint32_t comparator, uint_fast16_t mask);
N
N//*****************************************************************************
N//
N//! Disables selected Comparator interrupt sources.
N//!
N//! \param comparator is the instance of the Comparator module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b COMP_E0_BASE
N//!         - \b COMP_E1_BASE
N//! \param mask is the bit mask of the interrupt sources to be disabled.
N//!        Mask value is the logical OR of any of the following
N//!        - \b COMP_E_OUTPUT_INTERRUPT - Output interrupt
N//!        - \b COMP_E_INVERTED_POLARITY_INTERRUPT - Output interrupt inverted
N//!                                                 polarity
N//!        - \b COMP_E_READY_INTERRUPT - Ready interrupt
N//!
N//! Disables the indicated Comparator interrupt sources.  Only the sources that
N//! are enabled can be reflected to the processor interrupt; disabled sources
N//! have no effect on the processor.
N//!
N//! \return NONE
N//
N//*****************************************************************************
Nextern void COMP_E_disableInterrupt(uint32_t comparator, uint_fast16_t mask);
N
N//*****************************************************************************
N//
N//! Clears Comparator interrupt flags.
N//!
N//! \param comparator is the instance of the Comparator module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b COMP_E0_BASE
N//!         - \b COMP_E1_BASE
N//! \param mask is a bit mask of the interrupt sources to be cleared.
N//!        Mask value is the logical OR of any of the following
N//!        - \b COMP_E_INTERRUPT_FLAG - Output interrupt flag
N//!        - \b COMP_E_INTERRUPT_FLAG_INVERTED_POLARITY - Output interrupt flag
N//!                                                     inverted polarity
N//!        - \b COMP_E_INTERRUPT_FLAG_READY - Ready interrupt flag
N//!
N//! The Comparator interrupt source is cleared, so that it no longer asserts.
N//! The highest interrupt flag is automatically cleared when an interrupt vector
N//! generator is used.
N//!
N//! \return NONE
N//
N//*****************************************************************************
Nextern void COMP_E_clearInterruptFlag(uint32_t comparator, uint_fast16_t mask);
N
N//*****************************************************************************
N//
N//! Gets the current Comparator interrupt status.
N//!
N//! \param comparator is the instance of the Comparator module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b COMP_E0_BASE
N//!         - \b COMP_E1_BASE
N//!
N//! This returns the interrupt status for the Comparator module based on which
N//! flag is passed.
N//!
N//! \return The current interrupt flag status for the corresponding mask.
N//
N//*****************************************************************************
Nextern uint_fast16_t COMP_E_getInterruptStatus(uint32_t comparator);
N
N//*****************************************************************************
N//
N//! Enables selected Comparator interrupt sources masked with the enabled
N//! interrupts. This function is useful to call in ISRs to get a list
N//! of pending interrupts that are actually enabled and could have caused the
N//! ISR.
N//!
N//! \param comparator is the instance of the Comparator module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b COMP_E0_BASE
N//!         - \b COMP_E1_BASE
N//!
N//! Enables the indicated Comparator interrupt sources.  Only the sources that
N//! are enabled can be reflected to the processor interrupt; disabled sources
N//! have no effect on the processor. The default trigger for the non-inverted
N//! interrupt is a rising edge of the output, this can be changed with the
N//! COMP_E_setInterruptEdgeDirection() function.
N//!
N//! \return NONE
N//
N//*****************************************************************************
Nextern uint_fast16_t COMP_E_getEnabledInterruptStatus(uint32_t comparator);
N
N//*****************************************************************************
N//
N//! Explicitly sets the edge direction that would trigger an interrupt.
N//!
N//! \param comparator is the instance of the Comparator module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b COMP_E0_BASE
N//!         - \b COMP_E1_BASE
N//! \param edgeDirection determines which direction the edge would have to go
N//!       to generate an interrupt based on the non-inverted interrupt flag.
N//!        Valid values are
N//!        - \b COMP_E_FALLINGEDGE - sets the bit to generate an interrupt when
N//!             the output of the comparator falls from HIGH to LOW if the
N//!             normal interrupt bit is set(and LOW to HIGH if the inverted
N//!             interrupt enable bit is set). [Default]
N//!        - \b COMP_E_RISINGEDGE - sets the bit to generate an interrupt when the
N//!             output of the comparator rises from LOW to HIGH if the normal
N//!             interrupt bit is set(and HIGH to LOW if the inverted interrupt
N//!             enable bit is set).
N//!        <br>Modified bits are \b CEIES of \b CECTL1 register.
N//!
N//! This function will set which direction the output will have to go, whether
N//! rising or falling, to generate an interrupt based on a non-inverted
N//! interrupt.
N//!
N//! \return NONE
N//
N//*****************************************************************************
Nextern void COMP_E_setInterruptEdgeDirection(uint32_t comparator,
N        uint_fast8_t edgeDirection);
N
N//*****************************************************************************
N//
N//! Toggles the edge direction that would trigger an interrupt.
N//!
N//! \param comparator is the instance of the Comparator module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b COMP_E0_BASE
N//!         - \b COMP_E1_BASE
N//!
N//! This function will toggle which direction the output will have to go,
N//! whether rising or falling, to generate an interrupt based on a non-inverted
N//! interrupt. If the direction was rising, it is now falling, if it was
N//! falling, it is now rising.
N//!
N//! Modified bits are \b CEIES of \b CECTL1 register.
N//!
N//! \return NONE
N//
N//*****************************************************************************
Nextern void COMP_E_toggleInterruptEdgeDirection(uint32_t comparator);
N
N//*****************************************************************************
N//
N//! Registers an interrupt handler for the Comparator E interrupt.
N//!
N//! \param intHandler is a pointer to the function to be called when the
N//! Comparator interrupt occurs.
N//!
N//! \param comparator is the instance of the Comparator module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b COMP_E0_BASE
N//!         - \b COMP_E1_BASE
N//!
N//! This function registers the handler to be called when a Comparator
N//! interrupt occurs. This function enables the global interrupt in the
N//! interrupt controller; specific Comparator interrupts must be enabled
N//! via COMP_E_enableInterrupt().  It is the interrupt handler's responsibility to
N//! clear the interrupt source via COMP_E_clearInterruptFlag().
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void COMP_E_registerInterrupt(uint32_t comparator,
N        void (*intHandler)(void));
N
N//*****************************************************************************
N//
N//! Unregisters the interrupt handler for the Comparator E interrupt
N//!
N//! \param comparator is the instance of the Comparator module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b COMP_E0_BASE
N//!         - \b COMP_E1_BASE
N//!
N//! This function unregisters the handler to be called when Comparator E
N//! interrupt occurs.  This function also masks off the interrupt in the
N//! interrupt controller so that the interrupt handler no longer is called.
N//!
N//! \sa Interrupt_registerInterrupt() for important information about
N//! registering interrupt handlers.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void COMP_E_unregisterInterrupt(uint32_t comparator);
N
N/* Backwards Compatibility Layer */
N#define COMP_E_enable(a) COMP_E_enableModule(a)
N#define COMP_E_disable(a) COMP_E_disableModule(a)
N#define COMP_E_IOSwap(a) COMP_E_swapIO(a)
N#define COMP_E_interruptToggleEdgeDirection(a) COMP_E_toggleInterruptEdgeDirection(a)
N#define COMP_E_clearInterrupt(a,b) COMP_E_clearInterruptFlag(a,b)
N
N//*****************************************************************************
N//
N// Mark the end of the C bindings section for C++ compilers.
N//
N//*****************************************************************************
N#ifdef __cplusplus
N}
N#endif
N
N//*****************************************************************************
N//
N// Close the Doxygen group.
N//! @}
N//
N//*****************************************************************************
N
N
N#endif /* COMP_E_H_ */
L 43 "C:/ti/msp432_driverlib_3_21_00_05/driverlib/MSP432P4xx/driverlib.h" 2
N#include "cpu.h"
L 1 "C:\ti\msp432_driverlib_3_21_00_05\driverlib\MSP432P4xx\cpu.h" 1
N/*
N * -------------------------------------------
N *    MSP432 DriverLib - v3_21_00_05 
N * -------------------------------------------
N *
N * --COPYRIGHT--,BSD,BSD
N * Copyright (c) 2016, Texas Instruments Incorporated
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N *
N * *  Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N *
N * *  Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * *  Neither the name of Texas Instruments Incorporated nor the names of
N *    its contributors may be used to endorse or promote products derived
N *    from this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
N * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
N * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
N * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
N * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
N * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
N * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
N * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
N * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * --/COPYRIGHT--*/
N#ifndef __CPU_H__
N#define __CPU_H__
N
N#include <stdint.h>
N
N//*****************************************************************************
N//
N// If building with a C++ compiler, make all of the definitions in this header
N// have a C binding.
N//
N//*****************************************************************************
N#ifdef __cplusplus
Nextern "C"
N{
N#endif
N
N//*****************************************************************************
N//
N// Prototypes.
N//
N//*****************************************************************************
Nextern uint32_t CPU_cpsid(void);
Nextern uint32_t CPU_cpsie(void);
Nextern uint32_t CPU_primask(void);
Nextern void CPU_wfi(void);
Nextern uint32_t CPU_basepriGet(void);
Nextern void CPU_basepriSet(uint32_t newBasepri);
N
N
N//*****************************************************************************
N//
N// Mark the end of the C bindings section for C++ compilers.
N//
N//*****************************************************************************
N#ifdef __cplusplus
N}
N#endif
N
N#endif // __CPU_H__
N
L 44 "C:/ti/msp432_driverlib_3_21_00_05/driverlib/MSP432P4xx/driverlib.h" 2
N#include "crc32.h"
L 1 "C:\ti\msp432_driverlib_3_21_00_05\driverlib\MSP432P4xx\crc32.h" 1
N/*
N * -------------------------------------------
N *    MSP432 DriverLib - v3_21_00_05 
N * -------------------------------------------
N *
N * --COPYRIGHT--,BSD,BSD
N * Copyright (c) 2016, Texas Instruments Incorporated
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N *
N * *  Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N *
N * *  Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * *  Neither the name of Texas Instruments Incorporated nor the names of
N *    its contributors may be used to endorse or promote products derived
N *    from this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
N * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
N * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
N * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
N * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
N * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
N * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
N * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
N * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * --/COPYRIGHT--*/
N#ifndef _CRC_32_H
N
N//*****************************************************************************
N//
N//! \addtogroup crc32_api
N//! @{
N//
N//*****************************************************************************
N
N#include <stdint.h>
N
N#define CRC16_MODE 0x00
N#define CRC32_MODE 0x01
N
N//*****************************************************************************
N//
N//! Sets the seed for the CRC.
N//!
N//! \param seed is the seed for the CRC to start generating a signature from.
N//!        Modified bits are \b CRC16INIRESL0 of \b CRC16INIRESL0 register.
N//!            \b CRC32INIRESL0 of \b CRC32INIRESL0 register
N//! \param crcType selects between CRC32 and CRC16
N//!            Valid values are \b CRC16_MODE and \b CRC32_MODE
N//!
N//! This function sets the seed for the CRC to begin generating a signature with
N//! the given seed and all passed data. Using this function resets the CRC32
N//! signature.
N//!
N//! \return NONE
N//
N//*****************************************************************************
Nextern void CRC32_setSeed(uint32_t seed, uint_fast8_t crcType);
N
N//*****************************************************************************
N//
N//! Sets the 8 Bit data to add into the CRC module to generate a new signature.
N//!
N//! \param dataIn is the data to be added, through the CRC module, to the
N//!       signature.
N//!        Modified bits are \b CRC16DIB0 of \b CRC16DIB0 register.
N//!                            \b CRC32DIB0 of \b CRC32DIB0 register.
N//! \param crcType selects between CRC32 and CRC16
N//!            Valid values are \b CRC16_MODE and \b CRC32_MODE
N//!
N//! This function sets the given data into the CRC module to generate the new
N//! signature from the current signature and new data. Bit 0 is
N//!    treated as LSB.
N//!
N//! \return NONE
N//
N//*****************************************************************************
Nextern void CRC32_set8BitData(uint8_t dataIn, uint_fast8_t crcType);
N
N//*****************************************************************************
N//
N//! Sets the 16 Bit data to add into the CRC module to generate a new signature.
N//!
N//! \param dataIn is the data to be added, through the CRC module, to the
N//!       signature.
N//!        Modified bits are \b CRC16DIW0 of \b CRC16DIW0 register.
N//!                          \b CRC32DIW0 of \b CRC32DIW0 register.
N//! \param crcType selects between CRC32 and CRC16
N//!            Valid values are \b CRC16_MODE and \b CRC32_MODE
N//!
N//! This function sets the given data into the CRC module to generate the new
N//! signature from the current signature and new data. Bit 0 is
N//!    treated as LSB
N//!
N//! \return NONE
N//
N//*****************************************************************************
Nextern void CRC32_set16BitData(uint16_t dataIn, uint_fast8_t crcType);
N
N//*****************************************************************************
N//
N//! Sets the 32 Bit data to add into the CRC module to generate a new signature.
N//!    Available only for CRC32_MODE and not for CRC16_MODE
N//! \param dataIn is the data to be added, through the CRC module, to the
N//!       signature.
N//!        Modified bits are \b CRC32DIL0 of \b CRC32DIL0 register.
N//!
N//! This function sets the given data into the CRC module to generate the new
N//! signature from the current signature and new data. Bit 0 is
N//!    treated as LSB
N//!
N//! \return NONE
N//
N//*****************************************************************************
Nextern void CRC32_set32BitData(uint32_t dataIn);
N
N//*****************************************************************************
N//
N//! Translates the data by reversing the bits in each 8 bit data and then sets
N//! this data to add into the CRC module to generate a new signature.
N//!
N//! \param dataIn is the data to be added, through the CRC module, to the
N//!       signature.
N//!        Modified bits are \b CRC16DIRBB0 of \b CRC16DIRBB0 register.
N//!                             \b CRC32DIRBB0 of \b CRC32DIRBB0 register.
N//! \param crcType selects between CRC32 and CRC16
N//!            Valid values are \b CRC16_MODE and \b CRC32_MODE
N//!
N//! This function first reverses the bits in each byte of the data and then
N//! generates the new signature from the current signature and new translated
N//! data. Bit 0 is treated as MSB.
N//!
N//! \return NONE
N//
N//*****************************************************************************
Nextern void CRC32_set8BitDataReversed(uint8_t dataIn, uint_fast8_t crcType);
N
N//*****************************************************************************
N//
N//! Translates the data by reversing the bits in each 16 bit data and then
N//!    sets this data to add into the CRC module to generate a new signature.
N//!
N//! \param dataIn is the data to be added, through the CRC module, to the
N//!       signature.
N//!        Modified bits are \b CRC16DIRBW0 of \b CRC16DIRBW0 register.
N//!                             \b CRC32DIRBW0 of \b CRC32DIRBW0 register.
N//! \param crcType selects between CRC32 and CRC16
N//!            Valid values are \b CRC16_MODE and \b CRC32_MODE
N//!
N//! This function first reverses the bits in each byte of the data and then
N//! generates the new signature from the current signature and new translated
N//! data.  Bit 0 is treated as MSB.
N//!
N//! \return NONE
N//
N//*****************************************************************************
Nextern void CRC32_set16BitDataReversed(uint16_t dataIn, uint_fast8_t crcType);
N
N//*****************************************************************************
N//
N//! Translates the data by reversing the bits in each 32 Bit Data and then
N//!    sets this data to add into the CRC module to generate a new signature.
N//!    Available only for CRC32 mode and not for CRC16 mode
N//! \param dataIn is the data to be added, through the CRC module, to the
N//!       signature.
N//!        Modified bits are \b CRC32DIRBL0 of \b CRC32DIRBL0 register.
N//!
N//! This function first reverses the bits in each byte of the data and then
N//! generates the new signature from the current signature and new translated
N//! data.  Bit 0 is treated as MSB.
N//!
N//! \return NONE
N//
N//*****************************************************************************
Nextern void CRC32_set32BitDataReversed(uint32_t dataIn);
N
N//*****************************************************************************
N//
N//! Returns the value of CRC Signature Result.
N//!
N//! \param crcType selects between CRC32 and CRC16
N//!            Valid values are \b CRC16_MODE and \b CRC32_MODE
N//!
N//! This function returns the value of the signature result generated by the CRC.
N//! Bit 0 is treated as LSB.
N//! \return uint32_t Result
N//
N//*****************************************************************************
Nextern uint32_t CRC32_getResult(uint_fast8_t crcType);
N
N//*****************************************************************************
N//
N//! Returns the bit-wise reversed format of the 32 bit Signature Result.
N//!
N//! \param crcType selects between CRC32 and CRC16
N//!            Valid values are \b CRC16_MODE and \b CRC32_MODE
N//!
N//! This function returns the bit-wise reversed format of the Signature Result.
N//! Bit 0 is treated as MSB.
N//!
N//! \return uint32_t Result
N//
N//*****************************************************************************
Nextern uint32_t CRC32_getResultReversed(uint_fast8_t crcType);
N
N/* Defines for future devices that might have multiple instances */
N#define CRC32_setSeedMultipleInstance(a,b,c) CRC32_setSeed(b,c)
N#define CRC32_set8BitDataMultipleInstance(a,b,c)  CRC32_set8BitData(b,c)
N#define CRC32_set16BitDataMultipleInstance(a,b,c) CRC32_set16BitData(b,c)
N#define CRC32_set32BitDataMultipleInstance(a,b) CRC32_set32BitData(b)
N#define CRC32_set8BitDataReversedMultipleInstance(a,b,c) CRC32_set8BitDataReversed(b,c)
N#define CRC32_set16BitDataReversedMultipleInstance(a,b,c) CRC32_set16BitDataReversed(b,c)
N#define CRC32_set32BitDataReversedMultipleInstance(a,b) CRC32_set32BitDataReversed(b)
N#define CRC32_getResultMultipleInstance(a,b) CRC32_getResult()
N#define CRC32_getResultReversedMultipleInstance(a,b) CRC32_getResultReversed(b)
N
N//*****************************************************************************
N//
N// Close the Doxygen group.
N//! @}
N//
N//*****************************************************************************
N
N
N#endif
L 45 "C:/ti/msp432_driverlib_3_21_00_05/driverlib/MSP432P4xx/driverlib.h" 2
N#include "cs.h"
L 1 "C:\ti\msp432_driverlib_3_21_00_05\driverlib\MSP432P4xx\cs.h" 1
N/*
N * -------------------------------------------
N *    MSP432 DriverLib - v3_21_00_05 
N * -------------------------------------------
N *
N * --COPYRIGHT--,BSD,BSD
N * Copyright (c) 2016, Texas Instruments Incorporated
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N *
N * *  Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N *
N * *  Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * *  Neither the name of Texas Instruments Incorporated nor the names of
N *    its contributors may be used to endorse or promote products derived
N *    from this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
N * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
N * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
N * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
N * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
N * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
N * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
N * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
N * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * --/COPYRIGHT--*/
N#ifndef __CS_H__
N#define __CS_H__
N
N//*****************************************************************************
N//
N//! \addtogroup cs_api
N//! @{
N//
N//*****************************************************************************
N
N//*****************************************************************************
N//
N// If building with a C++ compiler, make all of the definitions in this header
N// have a C binding.
N//
N//*****************************************************************************
N#ifdef __cplusplus
Nextern "C"
N{
N#endif
N
N#include <stdint.h>
N#include <stdbool.h>
N#include <msp.h>
N
N//*****************************************************************************
N//
N// Control specific variables
N//
N//*****************************************************************************
N#define CS_CLOCK_DIVIDER_1 CS_CTL1_DIVS_0
N#define CS_CLOCK_DIVIDER_2 CS_CTL1_DIVS_1
N#define CS_CLOCK_DIVIDER_4 CS_CTL1_DIVS_2
N#define CS_CLOCK_DIVIDER_8 CS_CTL1_DIVS_3
N#define CS_CLOCK_DIVIDER_16 CS_CTL1_DIVS_4
N#define CS_CLOCK_DIVIDER_32 CS_CTL1_DIVS_5
N#define CS_CLOCK_DIVIDER_64 CS_CTL1_DIVS_6
N#define CS_CLOCK_DIVIDER_128 CS_CTL1_DIVS_7
N
N#define CS_LFXTCLK_SELECT   CS_CTL1_SELM_0
N#define CS_HFXTCLK_SELECT   CS_CTL1_SELM_5
N#define CS_VLOCLK_SELECT    CS_CTL1_SELM_1
N#define CS_REFOCLK_SELECT   CS_CTL1_SELM_2
N#define CS_DCOCLK_SELECT    CS_CTL1_SELM_3
N#define CS_MODOSC_SELECT    CS_CTL1_SELM_4
N
N#define CS_KEY 0x695A
N
N/* Number of positions to shift for divider calculation */
N#define CS_ACLK_DIV_BITPOS 0x04
N#define CS_MCLK_DIV_BITPOS 0x0C
N#define CS_SMCLK_DIV_BITPOS 0x00
N#define CS_HSMCLK_DIV_BITPOS 0x08
N
N/* Number of positions to shift for source calculation */
N#define CS_ACLK_SRC_BITPOS 0x08
N#define CS_MCLK_SRC_BITPOS 0x00
N#define CS_SMCLK_SRC_BITPOS 0x04
N#define CS_HSMCLK_SRC_BITPOS 0x04
N
N/* REFO Clock Values */
N#define CS_REFO_32KHZ 0x00
N#define CS_REFO_128KHZ 0x01
N
N/* Frequency Values */
N#define CS_VLOCLK_FREQUENCY 10000
N#define CS_MODCLK_FREQUENCY 24000000
N
N/* Interrupts */
N#define CS_LFXT_FAULT   CS_IE_LFXTIE
N#define CS_HFXT_FAULT   CS_IE_HFXTIE
N#define CS_DCO_OPEN_FAULT   CS_IE_DCOR_OPNIE
N#define CS_STARTCOUNT_LFXT_FAULT   CS_IE_FCNTLFIE
N#define CS_STARTCOUNT_HFXT_FAULT   CS_IE_FCNTHFIE
N#define CS_DCO_SHORT_FAULT   CS_IFG_DCOR_SHTIFG
N
N//#define CS_HFXT_DRIVE0 CS_CTL2_HFXTDRIVE_0
N//#define CS_HFXT_DRIVE1 CS_CTL2_HFXTDRIVE_1
N#define CS_HFXT_DRIVE CS_CTL2_HFXTDRIVE
N#define CS_HFXT_BYPASS CS_CTL2_HFXTBYPASS
N
N#define CS_LFXT_DRIVE0 CS_CTL2_LFXTDRIVE_0
N#define CS_LFXT_DRIVE1 CS_CTL2_LFXTDRIVE_1
N#define CS_LFXT_DRIVE2 CS_CTL2_LFXTDRIVE_2
N#define CS_LFXT_DRIVE3 CS_CTL2_LFXTDRIVE_3
N#define CS_LFXT_BYPASS CS_CTL2_LFXTBYPASS
N
N#define CS_ACLK CS_CLKEN_ACLK_EN
N#define CS_MCLK CS_CLKEN_MCLK_EN
N#define CS_SMCLK CS_CLKEN_SMCLK_EN
N#define CS_HSMCLK CS_CLKEN_HSMCLK_EN
N#define CS_BCLK CS_STAT_BCLK_READY
N
N#define CS_LFXTCLK  0x01
N
N#define CS_1MHZ 1000000
N#define CS_15MHZ 1500000
N#define CS_3MHZ 3000000
N#define CS_4MHZ 4000000
N#define CS_6MHZ 6000000
N#define CS_8MHZ 8000000
N#define CS_12MHZ 12000000
N#define CS_16MHZ 16000000
N#define CS_24MHZ 24000000
N#define CS_32MHZ 32000000
N#define CS_40MHZ 40000000
N#define CS_48MHZ 48000000
N
N#define CS_DCO_FREQUENCY_1_5 CS_CTL0_DCORSEL_0
N#define CS_DCO_FREQUENCY_3 CS_CTL0_DCORSEL_1
N#define CS_DCO_FREQUENCY_6 CS_CTL0_DCORSEL_2
N#define CS_DCO_FREQUENCY_12 CS_CTL0_DCORSEL_3
N#define CS_DCO_FREQUENCY_24 CS_CTL0_DCORSEL_4
N#define CS_DCO_FREQUENCY_48 CS_CTL0_DCORSEL_5
N
N#define CS_HFXT_FAULT_COUNTER 0x01
N#define CS_LFXT_FAULT_COUNTER 0x02
N
N#define CS_FAULT_COUNTER_4096_CYCLES CS_CTL3_FCNTLF_0
N#define CS_FAULT_COUNTER_8192_CYCLES CS_CTL3_FCNTLF_1
N#define CS_FAULT_COUNTER_16384_CYCLES CS_CTL3_FCNTLF_2
N#define CS_FAULT_COUNTER_32768_CYCLES CS_CTL3_FCNTLF_3
N
N#define CS_OVER32MHZ    0x01
N#define CS_UNDER32MHZ   0x02
N
N#define DEVICE_PG1_1    0x42
N
N//******************************************************************************
N//
N//! This function sets the external clock sources LFXT and HFXT crystal
N//! oscillator frequency values. This function must be called if an external
N//! crystal LFXT or HFXT is used and the user intends to call
N//! CS_getSMCLK, CS_getMCLK, CS_getBCLK,  CS_getHSMCLK, CS_getACLK and
N//! any of the HFXT oscillator control functions
N//!
N//! \param lfxt_XT_CLK_frequency is the LFXT crystal frequencies in Hz
N//! \param hfxt_XT_CLK_frequency is the HFXT crystal frequencies in Hz
N//!
N//! \return None
N//
N//******************************************************************************
Nextern void CS_setExternalClockSourceFrequency(uint32_t lfxt_XT_CLK_frequency,
N        uint32_t hfxt_XT_CLK_frequency);
N
N//******************************************************************************
N//
N//! This function initializes each of the clock signals. The user must ensure
N//! that this function is called for each clock signal. If not, the default
N//! state is assumed for the particular clock signal. Refer to DriverLib
N//! documentation for CS module or Device Family User's Guide for details of
N//! default clock signal states. 
N//!
N//! Note that this function is blocking and will wait on the appropriate bit
N//! to be set in the CSSTAT READY register to be set before setting the clock
N//! source.
N//!
N//! Also note that when HSMCLK and SMCLK share the same clock signal. If you
N//! change the clock signal for HSMCLK, the clock signal for SMCLK will change
N//! also (and vice-versa).
N//!
N//! HFXTCLK is not available for BCLK or ACLK.
N//!
N//! \param selectedClockSignal Clock signal to initialize.
N//!           - \b CS_ACLK,
N//!           - \b CS_MCLK,
N//!           - \b CS_HSMCLK
N//!           - \b CS_SMCLK
N//!           - \b CS_BCLK  [clockSourceDivider is ignored for this parameter]
N//! \param clockSource  Clock source for the selectedClockSignal signal.
N//!            - \b CS_LFXTCLK_SELECT,
N//!            - \b CS_HFXTCLK_SELECT,
N//!            - \b CS_VLOCLK_SELECT,     [Not available for BCLK]
N//!            - \b CS_DCOCLK_SELECT,     [Not available for ACLK, BCLK]
N//!            - \b CS_REFOCLK_SELECT,
N//!            - \b CS_MODOSC_SELECT      [Not available for ACLK, BCLK]
N//! \param clockSourceDivider - selected the clock divider to calculate
N//!         clock signal from clock source. This parameter is ignored when
N//!         setting BLCK. Valid values are:
N//!           - \b CS_CLOCK_DIVIDER_1,
N//!           - \b CS_CLOCK_DIVIDER_2,
N//!           - \b CS_CLOCK_DIVIDER_4,
N//!           - \b CS_CLOCK_DIVIDER_8,
N//!           - \b CS_CLOCK_DIVIDER_16,
N//!           - \b CS_CLOCK_DIVIDER_32,
N//!           - \b CS_CLOCK_DIVIDER_64,
N//!           - \b CS_CLOCK_DIVIDER_128
N//!
N//! \return NONE
N//
N//******************************************************************************
Nextern void CS_initClockSignal(uint32_t selectedClockSignal,
N        uint32_t clockSource, uint32_t clockSourceDivider);
N
N//******************************************************************************
N//
N//! Initializes the HFXT crystal oscillator, which supports crystal frequencies
N//! between 0 MHz and 48 MHz, depending on the selected drive strength. Loops
N//! until all oscillator fault flags are cleared, with no timeout. See the
N//! device-specific data sheet for appropriate drive settings. NOTE: User must
N//! call CS_setExternalClockSourceFrequency to set frequency of external clocks
N//! before calling this function.
N//!
N//! \param bypassMode When this variable is set, the oscillator will start
N//! in bypass mode and the signal can be generated by a digital square wave.
N//!
N//! \return true if started correctly, false otherwise
N//
N//******************************************************************************
Nextern bool CS_startHFXT(bool bypassMode);
N
N//******************************************************************************
N//
N//! Initializes the HFXT crystal oscillator, which supports crystal frequencies
N//! between 0 MHz and 48 MHz, depending on the selected drive strength. Loops
N//! until all oscillator fault flags are cleared, with no timeout. See the
N//! device-specific data sheet for appropriate drive settings. NOTE: User must
N//! call CS_setExternalClockSourceFrequency to set frequency of external clocks
N//! before calling this function. This function has a timeout associated with
N//! stabilizing the oscillator.
N//!
N//! \param bypassMode When this variable is set, the oscillator will start
N//! in bypass mode and the signal can be generated by a digital square wave.
N//!
N//! \param timeout is the count value that gets decremented every time the loop
N//!         that clears oscillator fault flags gets executed.
N//!
N//! \return true if started correctly, false otherwise
N//
N//******************************************************************************
Nextern bool CS_startHFXTWithTimeout(bool bypassMode, uint32_t timeout);
N
N//******************************************************************************
N//
N//! Initializes the LFXT crystal oscillator, which supports crystal frequencies
N//! up to 50kHz, depending on the selected drive strength. Loops
N//! until all oscillator fault flags are cleared, with no timeout. See the
N//! device-specific data sheet for appropriate drive settings. NOTE: User must
N//! call CS_setExternalClockSourceFrequency to set frequency of external clocks
N//! before calling this function.
N//!
N//! \param xtDrive is the target drive strength for the LFXT crystal
N//!                  oscillator.
N//!      Valid values are:
N//!         - \b CS_LFXT_DRIVE0,
N//!         - \b CS_LFXT_DRIVE1,
N//!         - \b CS_LFXT_DRIVE2,
N//!         - \b CS_LFXT_DRIVE3,  [Default Value]
N//!         - \b CS_LFXT_BYPASS
N//!
N//! \note When CS_LFXT_BYPASS is passed as a parameter the oscillator will start
N//! in bypass mode and the signal can be generated by a digital square wave.
N//!
N//! \return true if started correctly, false otherwise
N//
N//******************************************************************************
Nextern bool CS_startLFXT(uint32_t xtDrive);
N
N//******************************************************************************
N//
N//! Initializes the LFXT crystal oscillator, which supports crystal frequencies
N//! up to 50kHz, depending on the selected drive strength. Loops
N//! until all oscillator fault flags are cleared. See the
N//! device-specific data sheet for appropriate drive settings. NOTE: User must
N//! call CS_setExternalClockSourceFrequency to set frequency of external clocks
N//! before calling this function. This function has a timeout associated with
N//! stabilizing the oscillator.
N//!
N//! \param xtDrive is the target drive strength for the LFXT crystal
N//!                  oscillator.
N//!      Valid values are:
N//!         - \b CS_LFXT_DRIVE0,
N//!         - \b CS_LFXT_DRIVE1,
N//!         - \b CS_LFXT_DRIVE2,
N//!         - \b CS_LFXT_DRIVE3,  [Default Value]
N//!         - \b CS_LFXT_BYPASS
N//!
N//! \note When CS_LFXT_BYPASS is passed as a parameter the oscillator will
N//! start in bypass mode and the signal can be generated by a digital square
N//! wave.
N//!
N//! \param timeout is the count value that gets decremented every time the loop
N//!         that clears oscillator fault flags gets executed.
N//!
N//! \return true if started correctly, false otherwise
N//
N//******************************************************************************
Nextern bool CS_startLFXTWithTimeout(uint32_t xtDrive, uint32_t timeout);
N
N//******************************************************************************
N//
N//! Selects between the frequency of the internal REFO clock source
N//!
N//! \param referenceFrequency selects between the valid frequencies:
N//!        - \b CS_REFO_32KHZ,
N//!        - \b CS_REFO_128KHZ,
N//!
N//! \return NONE
N//
N//******************************************************************************
Nextern void CS_setReferenceOscillatorFrequency(uint8_t referenceFrequency);
N
N//******************************************************************************
N//
N//! Enables conditional module requests
N//!
N//! \param selectClock selects specific request enables. Valid values are
N//!        are a logical OR of the following values:
N//!        - \b CS_ACLK,
N//!        - \b CS_HSMCLK,
N//!        - \b CS_SMCLK,
N//!        - \b CS_MCLK
N//!
N//! \return NONE
N//
N//******************************************************************************
Nextern void CS_enableClockRequest(uint32_t selectClock);
N
N//******************************************************************************
N//
N//! Disables conditional module requests
N//!
N//! \param selectClock selects specific request disables. Valid values are
N//!        are a logical OR of the following values:
N//!        - \b CS_ACLK,
N//!        - \b CS_HSMCLK,
N//!        - \b CS_SMCLK,
N//!        - \b CS_MCLK
N//!
N//! \return NONE
N//
N//******************************************************************************
Nextern void CS_disableClockRequest(uint32_t selectClock);
N
N//******************************************************************************
N//
N//! Get the current ACLK frequency.
N//!
N//! If a oscillator fault is set, the frequency returned will be based on the
N//! fail safe mechanism of CS module. The user of this API must ensure that
N//! \link CS_setExternalClockSourceFrequency() \endlink API was invoked before
N//! in case LFXT is being used.
N//!
N//! \return Current ACLK frequency in Hz
N//
N//******************************************************************************
Nextern uint32_t CS_getACLK(void);
N
N//******************************************************************************
N//
N//! Get the current SMCLK frequency.
N//!
N//! If a oscillator fault is set, the frequency returned will be based on the
N//! fail safe mechanism of CS module. The user of this API must ensure that
N//! CS_setExternalClockSourceFrequency API was invoked before in case LFXT or
N//! HFXT is being used.
N//!
N//! \return Current SMCLK frequency in Hz
N//
N//******************************************************************************
Nextern uint32_t CS_getSMCLK(void);
N
N//******************************************************************************
N//
N//! Get the current MCLK frequency.
N//!
N//! If a oscillator fault is set, the frequency returned will be based on the
N//! fail safe mechanism of CS module. The user of this API must ensure that
N//! CS_setExternalClockSourceFrequency API was invoked before in case LFXT or
N//! HFXT is being used.
N//!
N//! \return Current MCLK frequency in Hz
N//
N//******************************************************************************
Nextern uint32_t CS_getMCLK(void);
N
N//******************************************************************************
N//
N//! Get the current BCLK frequency.
N//!
N//! If a oscillator fault is set, the frequency returned will be based on the
N//! fail safe mechanism of CS module. The user of this API must ensure that
N//! \link CS_setExternalClockSourceFrequency \endlink API was invoked before in
N//! case LFXT or HFXT is being used.
N//!
N//! \return Current BCLK frequency in Hz
N//
N//******************************************************************************
Nextern uint32_t CS_getBCLK(void);
N
N//******************************************************************************
N//
N//! Get the current HSMCLK frequency.
N//!
N//! If a oscillator fault is set, the frequency returned will be based on the
N//! fail safe mechanism of CS module. The user of this API must ensure that
N//! \link CS_setExternalClockSourceFrequency \endlink API was invoked before in
N//! case LFXT or HFXT is being used.
N//!
N//! \return Current HSMCLK frequency in Hz
N//
N//******************************************************************************
Nextern uint32_t CS_getHSMCLK(void);
N
N//******************************************************************************
N//
N//! Sets the centered frequency of DCO operation.  Each frequency represents
N//! the centred frequency of a particular frequency range. Further tuning can
N//! be achieved by using the CS_tuneDCOFrequency function. Note that setting
N//! the nominal frequency will reset the tuning parameters.
N//!
N//! \param dcoFreq selects between the valid frequencies:
N//!        - \b CS_DCO_FREQUENCY_1_5, [1MHz to 2MHz]
N//!        - \b CS_DCO_FREQUENCY_3,   [2MHz to 4MHz]
N//!        - \b CS_DCO_FREQUENCY_6,   [4MHz to 8MHz]
N//!        - \b CS_DCO_FREQUENCY_12,  [8MHz to 16MHz]
N//!        - \b CS_DCO_FREQUENCY_24,  [16MHz to 32MHz]
N//!        - \b CS_DCO_FREQUENCY_48   [32MHz to 64MHz]
N//!
N//! \return NONE
N//
N//******************************************************************************
Nextern void CS_setDCOCenteredFrequency(uint32_t dcoFreq);
N
N//******************************************************************************
N//
N//! Automatically sets/tunes the DCO to the given frequency. Any valid value
N//! up to max frequency in the spec can be given to this function and the API
N//! will do its best to determine the correct tuning parameter.
N//!
N//! \note The frequency ranges that can be custom tuned on early release MSP432
N//! devices is limited. For further details on supported tunable frequencies,
N//! please refer to the device errata sheet or data sheet.
N//!
N//! \param dcoFrequency Frequency in Hz that the user wants to set the DCO to.
N//!
N//! \note This function uses floating point math to calculate the DCO tuning
N//!         parameter. If efficiency is a concern, the user should use the
N//!         \link FPU_enableModule \endlink function (if available) to enable
N//!         the floating point co-processor.
N//!
N//! \return None
N//
N//******************************************************************************
Nextern void CS_setDCOFrequency(uint32_t dcoFrequency);
N
N//******************************************************************************
N//
N//! Tunes the DCO to a specific frequency. Tuning of the DCO is based off of the
N//! following equation in the user's guide:
N//!
N//! See the user's guide for more detailed information about DCO tuning.
N//!
N//! \note This function is not currently available on pre-release MSP432 devices.
N//!  On early release versions of MSP432, the DCO calibration information has not been
N//!  populated making the DCO only able to operate at the pre-calibrated centered 
N//!  frequencies accessible by the \link CS_setDCOCenteredFrequency \endlink
N//!  function. While this function will be added on the final devices being released,
N//!  for early silicon please default to the pre-calibrated DCO center frequencies.
N//!
N//! \param tuneParameter Tuning parameter in 2's Compliment representation.
N//!  Can be negative or positive.
N//!
N//! \return NONE
N//
N//******************************************************************************
Nextern void CS_tuneDCOFrequency(int16_t tuneParameter);
N
N//******************************************************************************
N//
N//! Enables the external resistor for DCO operation
N//!
N//! \return NONE
N//
N//******************************************************************************
Nextern void CS_enableDCOExternalResistor(void);
N
N//******************************************************************************
N//
N//! Disables the external resistor for DCO operation
N//!
N//! \return NONE
N//
N//******************************************************************************
Nextern void CS_disableDCOExternalResistor(void);
N
N//******************************************************************************
N//
N//! Sets the calibration value for the DCO when using the external resistor
N//! mode. This value is used for tuning the DCO to custom frequencies. By
N//! default, the value in the CS module is populated by the calibration
N//! data of the suggested external resistor (see device datasheet).
N//!
N//! \param calData is the calibration data constant for the external resistor.
N//!
N//! \param freqRange is the range of the DCO to set the external calibration
N//!             for. Frequencies above 32MHZ have a different calibration value
N//!             than frequencies below 32MHZ.
N//!
N//! \return None
N//
N//******************************************************************************
Nextern void CS_setDCOExternalResistorCalibration(uint_fast8_t uiCalData,
N                                                 uint_fast8_t freqRange);
N
N//******************************************************************************
N//
N//! Gets the current tuned DCO frequency. If no tuning has been done, this
N//! returns the nominal DCO frequency of the current DCO range. Note that this
N//! function will grab any constant/calibration data from the DDDS table
N//! without any user interaction needed.
N//!
N//! \note This function uses floating point math to calculate the DCO tuning
N//!         parameter. If efficiency is a concern, the user should use the
N//!         \link FPU_enableModule \endlink function (if available) to enable
N//!         the floating point co-processor.
N//!
N//! \return Current DCO frequency in Hz
N//
N//******************************************************************************
Nextern uint32_t CS_getDCOFrequency(void);
N
N//******************************************************************************
N//
N//! Automatically sets/tunes the DCO to the given frequency. Any valid value
N//! up to (and including) 64Mhz can be given to this function and the API
N//! will do its best to determine the correct tuning parameter.
N//!
N//!
N//! \note This function is not currently available on pre-release MSP432 devices.
N//!  On early release versions of MSP432, the DCO calibration information has not been
N//!  populated making the DCO only able to operate at the pre-calibrated centered 
N//!  frequencies accessible by the \link CS_setDCOCenteredFrequency \endlink
N//!  function. While this function will be added on the final devices being released,
N//!  for early silicon please default to the pre-calibrated DCO center frequencies.
N//!
N//! \param dcoFrequency Frequency in Hz (1500000 - 64000000) that the user wants
N//!         to set the DCO to.
N//!
N//! \note This function uses floating point math to calculate the DCO tuning
N//!         parameter. If efficiency is a concern, the user should use the
N//!         \link FPU_enableModule \endlink function (if available) to enable
N//!         the floating point co-processor.
N//!
N//! \return None
N//
N//******************************************************************************
Nextern void CS_setDCOFrequency(uint32_t dcoFrequency);
N
N//******************************************************************************
N//
N//! Enables the fault counter for the CS module. This function can enable
N//! either the HFXT fault counter or the LFXT fault counter.
N//!
N//! \param counterSelect selects the fault counter to enable
N//!        - \b CS_HFXT_FAULT_COUNTER
N//!        - \b CS_LFXT_FAULT_COUNTER
N//!
N//! \return NONE
N//
N//******************************************************************************
Nextern void CS_enableFaultCounter(uint_fast8_t counterSelect);
N
N//******************************************************************************
N//
N//! Disables the fault counter for the CS module. This function can disable
N//! either the HFXT fault counter or the LFXT fault counter.
N//!
N//! \param counterSelect selects the fault counter to disable
N//!        - \b CS_HFXT_FAULT_COUNTER
N//!        - \b CS_LFXT_FAULT_COUNTER
N//!
N//! \return NONE
N//
N//******************************************************************************
Nextern void CS_disableFaultCounter(uint_fast8_t counterSelect);
N
N//******************************************************************************
N//
N//! Resets the fault counter for the CS module. This function can reset
N//! either the HFXT fault counter or the LFXT fault counter.
N//!
N//! \param counterSelect selects the fault counter to reset
N//!        - \b CS_HFXT_FAULT_COUNTER
N//!        - \b CS_LFXT_FAULT_COUNTER
N//!
N//! \return NONE
N//
N//******************************************************************************
Nextern void CS_resetFaultCounter(uint_fast8_t counterSelect);
N
N//******************************************************************************
N//
N//! Sets the count for the start value of the fault counter. This function can
N//! be used to set either the HFXT count or the LFXT count.
N//!
N//! \param counterSelect selects the fault counter to reset
N//!        - \b CS_HFXT_FAULT_COUNTER
N//!        - \b CS_LFXT_FAULT_COUNTER
N//! \param countValue selects the cycles to set the fault counter to
N//!        - \b CS_FAULT_COUNTER_4096_CYCLES
N//!        - \b CS_FAULT_COUNTER_8192_CYCLES
N//!        - \b CS_FAULT_COUNTER_16384_CYCLES
N//!        - \b CS_FAULT_COUNTER_32768_CYCLES
N//!
N//! \return NONE
N//
N//******************************************************************************
Nextern void CS_startFaultCounter(uint_fast8_t counterSelect,
N        uint_fast8_t countValue);
N
N//*****************************************************************************
N//
N//! Enables individual clock control interrupt sources.
N//!
N//! \param flags is a bit mask of the interrupt sources to be enabled.  Must
N//! be a logical OR of:
N//!                     - \b CS_LFXT_FAULT,
N//!                     - \b CS_HFXT_FAULT,
N//!                     - \b CS_DCOMIN_FAULT,
N//!                     - \b CS_DCOMAX_FAULT,
N//!                     - \b CS_DCO_OPEN_FAULT,
N//!                     - \b CS_STARTCOUNT_LFXT_FAULT,
N//!                     - \b CS_STARTCOUNT_HFXT_FAULT,
N//!
N//! This function enables the indicated clock system interrupt sources.  Only
N//! the sources that are enabled can be reflected to the processor interrupt;
N//! disabled sources have no effect on the processor.
N//!
N//! \note The interrupt sources vary based on the part in use.
N//! Please consult the data sheet for the part you are using to determine
N//! which interrupt sources are available.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void CS_enableInterrupt(uint32_t flags);
N
N//*****************************************************************************
N//
N//! Disables individual clock system interrupt sources.
N//!
N//! \param flags is a bit mask of the interrupt sources to be disabled.  Must
N//! be a logical OR of:
N//!                     - \b CS_LFXT_FAULT,
N//!                     - \b CS_HFXT_FAULT,
N//!                     - \b CS_DCOMIN_FAULT,
N//!                     - \b CS_DCOMAX_FAULT,
N//!                     - \b CS_DCO_OPEN_FAULT,
N//!                     - \b CS_STARTCOUNT_LFXT_FAULT,
N//!                     - \b CS_STARTCOUNT_HFXT_FAULT,
N//!
N//! \note The interrupt sources vary based on the part in use.
N//! Please consult the data sheet for the part you are using to determine
N//! which interrupt sources are available.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void CS_disableInterrupt(uint32_t flags);
N
N//*****************************************************************************
N//
N//! Gets the current interrupt status masked with the enabled interrupts.
N//! This function is useful to call in ISRs to get a list of pending interrupts
N//! that are actually enabled and could have caused the ISR.
N//!
N//! \return The current interrupt status, enumerated as a bit field of
N//!                     - \b CS_LFXT_FAULT,
N//!                     - \b CS_HFXT_FAULT,
N//!                     - \b CS_DCO_OPEN_FAULT,
N//!                     - \b CS_DCO_SHORT_FAULT,
N//!                     - \b CS_STARTCOUNT_LFXT_FAULT,
N//!                     - \b CS_STARTCOUNT_HFXT_FAULT,
N//!
N//! \note The interrupt sources vary based on the part in use.
N//! Please consult the data sheet for the part you are using to determine
N//! which interrupt sources are available.
N//
N//*****************************************************************************
Nextern uint32_t CS_getEnabledInterruptStatus(void);
N
N//*****************************************************************************
N//
N//! Gets the current interrupt status.
N//!
N//! \return The current interrupt status, enumerated as a bit field of:
N//!                     - \b CS_LFXT_FAULT,
N//!                     - \b CS_HFXT_FAULT,
N//!                     - \b CS_DCO_OPEN_FAULT,
N//!                     - \b CS_DCO_SHORT_FAULT,
N//!                     - \b CS_STARTCOUNT_LFXT_FAULT,
N//!                     - \b CS_STARTCOUNT_HFXT_FAULT,
N//!
N//! \note The interrupt sources vary based on the part in use.
N//! Please consult the data sheet for the part you are using to determine
N//! which interrupt sources are available.
N//
N//*****************************************************************************
Nextern uint32_t CS_getInterruptStatus(void);
N
N//*****************************************************************************
N//
N//! Clears clock system interrupt sources.
N//!
N//! \param flags is a bit mask of the interrupt sources to be cleared.  Must
N//! be a logical OR of:
N//!                     - \b CS_LFXT_FAULT,
N//!                     - \b CS_HFXT_FAULT,
N//!                     - \b CS_DCO_OPEN_FAULT,
N//!                     - \b CS_STARTCOUNT_LFXT_FAULT,
N//!                     - \b CS_STARTCOUNT_HFXT_FAULT,
N//!
N//! The specified clock system interrupt sources are cleared, so that they no
N//! longer assert.  This function must be called in the interrupt handler to
N//! keep it from being called again immediately upon exit.
N//!
N//! \note Because there is a write buffer in the Cortex-M processor, it may
N//! take several clock cycles before the interrupt source is actually cleared.
N//! Therefore, it is recommended that the interrupt source be cleared early in
N//! the interrupt handler (as opposed to the very last action) to avoid
N//! returning from the interrupt handler before the interrupt source is
N//! actually cleared.  Failure to do so may result in the interrupt handler
N//! being immediately reentered (because the interrupt controller still sees
N//! the interrupt source asserted).
N//!
N//! \note The interrupt sources vary based on the part in use.
N//! Please consult the data sheet for the part you are using to determine
N//! which interrupt sources are available.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void CS_clearInterruptFlag(uint32_t flags);
N
N//*****************************************************************************
N//
N//! Registers an interrupt handler for the clock system interrupt.
N//!
N//! \param intHandler is a pointer to the function to be called when the clock
N//! system interrupt occurs.
N//!
N//! This function registers the handler to be called when a clock system
N//! interrupt occurs. This function enables the global interrupt in the
N//! interrupt controller; specific clock system interrupts must be enabled
N//! via CS_enableInterrupt().  It is the interrupt handler's responsibility to
N//! clear the interrupt source via CS_clearInterruptFlag().
N//!
N//! Clock System can generate interrupts when
N//!
N//! \sa Interrupt_registerInterrupt() for important information about
N//! registering interrupt handlers.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void CS_registerInterrupt(void (*intHandler)(void));
N
N//*****************************************************************************
N//
N//! Unregisters the interrupt handler for the clock system.
N//!
N//! This function unregisters the handler to be called when a clock system
N//! interrupt occurs.  This function also masks off the interrupt in the
N//! interrupt controller so that the interrupt handler no longer is called.
N//!
N//! \sa Interrupt_registerInterrupt() for important information about
N//! registering interrupt handlers.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void CS_unregisterInterrupt(void);
N
N//*****************************************************************************
N//
N// Mark the end of the C bindings section for C++ compilers.
N//
N//*****************************************************************************
N#ifdef __cplusplus
N}
N#endif
N
N//*****************************************************************************
N//
N// Close the Doxygen group.
N//! @}
N//
N//*****************************************************************************
N
N#endif
L 46 "C:/ti/msp432_driverlib_3_21_00_05/driverlib/MSP432P4xx/driverlib.h" 2
N#include "dma.h"
L 1 "C:\ti\msp432_driverlib_3_21_00_05\driverlib\MSP432P4xx\dma.h" 1
N/*
N * -------------------------------------------
N *    MSP432 DriverLib - v3_21_00_05 
N * -------------------------------------------
N *
N * --COPYRIGHT--,BSD,BSD
N * Copyright (c) 2016, Texas Instruments Incorporated
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N *
N * *  Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N *
N * *  Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * *  Neither the name of Texas Instruments Incorporated nor the names of
N *    its contributors may be used to endorse or promote products derived
N *    from this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
N * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
N * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
N * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
N * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
N * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
N * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
N * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
N * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * --/COPYRIGHT--*/
N#ifndef __DMA_H__
N#define __DMA_H__
N
N//*****************************************************************************
N//
N//! \addtogroup dma_api
N//! @{
N//
N//*****************************************************************************
N
N//*****************************************************************************
N//
N// If building with a C++ compiler, make all of the definitions in this header
N// have a C binding.
N//
N//*****************************************************************************
N#ifdef __cplusplus
Nextern "C"
N{
N#endif
N
N#include <stdbool.h>
N#include <msp.h>
N
N//*****************************************************************************
N//
N// A structure that defines an entry in the channel control table.  These
N// fields are used by the DMA controller and normally it is not necessary for
N// software to directly read or write fields in the table.
N//
N//*****************************************************************************
Ntypedef struct _DMA_ControlTable
N{
N    //
N    // The ending source address of the data transfer.
N    //
N    volatile void *srcEndAddr;
N
N    //
N    // The ending destination address of the data transfer.
N    //
N    volatile void *dstEndAddr;
N
N    //
N    // The channel control mode.
N    //
N    volatile uint32_t control;
N
N    //
N    // An unused location.
N    //
N    volatile uint32_t spare;
N} DMA_ControlTable;
N
N//*****************************************************************************
N//
N//! A helper macro for building scatter-gather task table entries.
N//!
N//! This macro is intended to be used to help populate a table of DMA tasks
N//! for a scatter-gather transfer.  This macro will calculate the values for
N//! the fields of a task structure entry based on the input parameters.
N//!
N//! There are specific requirements for the values of each parameter.  No
N//! checking is done so it is up to the caller to ensure that correct values
N//! are used for the parameters.
N//!
N//! The \b transferCount parameter is the number of items that will be
N//! transferred by this task.  It must be in the range 1-1024.
N//!
N//! The \b itemSize parameter is the bit size of the transfer data.  It must
N//! be one of \b UDMA_SIZE_8, \b UDMA_SIZE_16, or \b UDMA_SIZE_32.
N//!
N//! The \e srcIncrement parameter is the increment size for the source data.
N//! It must be one of \b UDMA_SRC_INC_8, \b UDMA_SRC_INC_16,
N//! \b UDMA_SRC_INC_32, or \b UDMA_SRC_INC_NONE.
N//!
N//! The \b srcAddr parameter is a void pointer to the beginning of the source
N//! data.
N//!
N//! The \b dstIncrement parameter is the increment size for the destination
N//! data.  It must be one of \b UDMA_DST_INC_8, \b UDMA_DST_INC_16,
N//! \b UDMA_DST_INC_32, or \b UDMA_DST_INC_NONE.
N//!
N//! The \b dstAddr parameter is a void pointer to the beginning of the
N//! location where the data will be transferred.
N//!
N//! The \b arbSize parameter is the arbitration size for the transfer, and
N//! must be one of \b UDMA_ARB_1, \b UDMA_ARB_2, \b UDMA_ARB_4, and so on
N//! up to \b UDMA_ARB_1024.  This is used to select the arbitration size in
N//! powers of 2, from 1 to 1024.
N//!
N//! The \e mode parameter is the mode to use for this transfer task.  It
N//! must be one of \b UDMA_MODE_BASIC, \b UDMA_MODE_AUTO,
N//! \b UDMA_MODE_MEM_SCATTER_GATHER, or \b UDMA_MODE_PER_SCATTER_GATHER.  Note
N//! that normally all tasks will be one of the scatter-gather modes while the
N//! last task is a task list will be AUTO or BASIC.
N//!
N//! This macro is intended to be used to initialize individual entries of
N//! a structure of DMA_ControlTable type, like this:
N//!
N//! \code{.c}
N//!     DMA_ControlTable MyTaskList[] =
N//!     {
N//!         DMA_TaskStructEntry(Task1Count, UDMA_SIZE_8,
N//!                             UDMA_SRC_INC_8, MySourceBuf,
N//!                             UDMA_DST_INC_8, MyDestBuf,
N//!                             UDMA_ARB_8, UDMA_MODE_MEM_SCATTER_GATHER),
N//!         DMA_TaskStructEntry(Task2Count, ... ),
N//!     }
N//! \endcode
N//!
N//! \param transferCount is the count of items to transfer for this task.
N//! \param itemSize is the bit size of the items to transfer for this task.
N//! \param srcIncrement is the bit size increment for source data.
N//! \param srcAddr is the starting address of the data to transfer.
N//! \param dstIncrement is the bit size increment for destination data.
N//! \param dstAddr is the starting address of the destination data.
N//! \param arbSize is the arbitration size to use for the transfer task.
N//! \param mode is the transfer mode for this task.
N//!
N//! \return Nothing; this is not a function.
N//
N//*****************************************************************************
N#define DMA_TaskStructEntry(transferCount,                                     \
N                            itemSize,                                          \
N                            srcIncrement,                                      \
N                            srcAddr,                                           \
N                            dstIncrement,                                      \
N                            dstAddr,                                           \
N                            arbSize,                                           \
N                            mode)                                              \
N    {                                                                          \
N        (((srcIncrement) == UDMA_SRC_INC_NONE) ? (void *)(srcAddr) :           \
N            ((void *)(&((uint8_t *)(srcAddr))[((transferCount) <<              \
N                                         ((srcIncrement) >> 26)) - 1]))),      \
N            (((dstIncrement) == UDMA_DST_INC_NONE) ? (void *)(dstAddr) :       \
N            ((void *)(&((uint8_t *)(dstAddr))[((transferCount) <<              \
N                                         ((dstIncrement) >> 30)) - 1]))),      \
N        (srcIncrement) | (dstIncrement) | (itemSize) | (arbSize) |             \
N        (((transferCount) - 1) << 4) |                                         \
N        ((((mode) == UDMA_MODE_MEM_SCATTER_GATHER) ||                          \
N          ((mode) == UDMA_MODE_PER_SCATTER_GATHER)) ?                          \
N                (mode) | UDMA_MODE_ALT_SELECT : (mode)), 0                     \
N    }
X#define DMA_TaskStructEntry(transferCount,                                                                 itemSize,                                                                      srcIncrement,                                                                  srcAddr,                                                                       dstIncrement,                                                                  dstAddr,                                                                       arbSize,                                                                       mode)                                                  {                                                                                  (((srcIncrement) == UDMA_SRC_INC_NONE) ? (void *)(srcAddr) :                       ((void *)(&((uint8_t *)(srcAddr))[((transferCount) <<                                                       ((srcIncrement) >> 26)) - 1]))),                  (((dstIncrement) == UDMA_DST_INC_NONE) ? (void *)(dstAddr) :                   ((void *)(&((uint8_t *)(dstAddr))[((transferCount) <<                                                       ((dstIncrement) >> 30)) - 1]))),              (srcIncrement) | (dstIncrement) | (itemSize) | (arbSize) |                     (((transferCount) - 1) << 4) |                                                 ((((mode) == UDMA_MODE_MEM_SCATTER_GATHER) ||                                    ((mode) == UDMA_MODE_PER_SCATTER_GATHER)) ?                                          (mode) | UDMA_MODE_ALT_SELECT : (mode)), 0                         }
N
N//*****************************************************************************
N//
N// Flags that can be passed to DMA_enableChannelAttribute(),
N// DMA_disableChannelAttribute(), and returned from DMA_getChannelAttribute().
N//
N//*****************************************************************************
N#define UDMA_ATTR_USEBURST      0x00000001
N#define UDMA_ATTR_ALTSELECT     0x00000002
N#define UDMA_ATTR_HIGH_PRIORITY 0x00000004
N#define UDMA_ATTR_REQMASK       0x00000008
N#define UDMA_ATTR_ALL           0x0000000F
N
N//*****************************************************************************
N//
N// DMA control modes that can be passed to DMAModeSet() and returned
N// DMAModeGet().
N//
N//*****************************************************************************
N#define UDMA_MODE_STOP          0x00000000
N#define UDMA_MODE_BASIC         0x00000001
N#define UDMA_MODE_AUTO          0x00000002
N#define UDMA_MODE_PINGPONG      0x00000003
N#define UDMA_MODE_MEM_SCATTER_GATHER                                          \
N                                0x00000004
X#define UDMA_MODE_MEM_SCATTER_GATHER                                                                          0x00000004
N#define UDMA_MODE_PER_SCATTER_GATHER                                          \
N                                0x00000006
X#define UDMA_MODE_PER_SCATTER_GATHER                                                                          0x00000006
N#define UDMA_MODE_ALT_SELECT    0x00000001
N
N//*****************************************************************************
N//
N// Channel configuration values that can be passed to DMAControlSet().
N//
N//*****************************************************************************
N#define UDMA_DST_INC_8          0x00000000
N#define UDMA_DST_INC_16         0x40000000
N#define UDMA_DST_INC_32         0x80000000
N#define UDMA_DST_INC_NONE       0xc0000000
N#define UDMA_SRC_INC_8          0x00000000
N#define UDMA_SRC_INC_16         0x04000000
N#define UDMA_SRC_INC_32         0x08000000
N#define UDMA_SRC_INC_NONE       0x0c000000
N#define UDMA_SIZE_8             0x00000000
N#define UDMA_SIZE_16            0x11000000
N#define UDMA_SIZE_32            0x22000000
N#define UDMA_DST_PROT_PRIV      0x00200000
N#define UDMA_SRC_PROT_PRIV      0x00040000
N#define UDMA_ARB_1              0x00000000
N#define UDMA_ARB_2              0x00004000
N#define UDMA_ARB_4              0x00008000
N#define UDMA_ARB_8              0x0000c000
N#define UDMA_ARB_16             0x00010000
N#define UDMA_ARB_32             0x00014000
N#define UDMA_ARB_64             0x00018000
N#define UDMA_ARB_128            0x0001c000
N#define UDMA_ARB_256            0x00020000
N#define UDMA_ARB_512            0x00024000
N#define UDMA_ARB_1024           0x00028000
N#define UDMA_NEXT_USEBURST      0x00000008
N
N//*****************************************************************************
N//
N// Flags to be OR'd with the channel ID to indicate if the primary or alternate
N// control structure should be used.
N//
N//*****************************************************************************
N#define UDMA_PRI_SELECT         0x00000000
N#define UDMA_ALT_SELECT         0x00000008
N
N//*****************************************************************************
N//
N// Values that can be passed to DMA_assignChannel() to select peripheral
N// mapping for each channel.  The channels named RESERVED may be assigned
N// to a peripheral in future parts.
N//
N//*****************************************************************************
N//
N// Channel 0
N//
N#define DMA_CH0_RESERVED0          0x00000000
N#define DMA_CH0_EUSCIA0TX          0x01000000
N#define DMA_CH0_EUSCIB0TX0         0x02000000
N#define DMA_CH0_EUSCIB3TX1         0x03000000
N#define DMA_CH0_EUSCIB2TX2         0x04000000
N#define DMA_CH0_EUSCIB1TX3         0x05000000
N#define DMA_CH0_TIMERA0CCR0        0x06000000
N#define DMA_CH0_AESTRIGGER0        0x07000000
N
N//
N// Channel 1
N//
N#define DMA_CH1_RESERVED0          0x00000001
N#define DMA_CH1_EUSCIA0RX          0x01000001
N#define DMA_CH1_EUSCIB0RX0         0x02000001
N#define DMA_CH1_EUSCIB3RX1         0x03000001
N#define DMA_CH1_EUSCIB2RX2         0x04000001
N#define DMA_CH1_EUSCIB1RX3         0x05000001
N#define DMA_CH1_TIMERA0CCR2        0x06000001
N#define DMA_CH1_AESTRIGGER1        0x07000001
N
N//
N// Channel 2
N//
N#define DMA_CH2_RESERVED0          0x00000002
N#define DMA_CH2_EUSCIA1TX          0x01000002
N#define DMA_CH2_EUSCIB1TX0         0x02000002
N#define DMA_CH2_EUSCIB0TX1         0x03000002
N#define DMA_CH2_EUSCIB3TX2         0x04000002
N#define DMA_CH2_EUSCIB2TX3         0x05000002
N#define DMA_CH2_TIMERA1CCR0        0x06000002
N#define DMA_CH2_AESTRIGGER2        0x07000002
N
N//
N// Channel 3
N//
N#define DMA_CH3_RESERVED0          0x00000003
N#define DMA_CH3_EUSCIA1RX          0x01000003
N#define DMA_CH3_EUSCIB1RX0         0x02000003
N#define DMA_CH3_EUSCIB0RX1         0x03000003
N#define DMA_CH3_EUSCIB3RX2         0x04000003
N#define DMA_CH3_EUSCIB2RX3         0x05000003
N#define DMA_CH3_TIMERA1CCR2        0x06000003
N#define DMA_CH3_RESERVED1          0x07000003
N
N//
N// Channel 4
N//
N#define DMA_CH4_RESERVED0          0x00000004
N#define DMA_CH4_EUSCIA2TX          0x01000004
N#define DMA_CH4_EUSCIB2TX0         0x02000004
N#define DMA_CH4_EUSCIB1TX1         0x03000004
N#define DMA_CH4_EUSCIB0TX2         0x04000004
N#define DMA_CH4_EUSCIB3TX3         0x05000004
N#define DMA_CH4_TIMERA2CCR0        0x06000004
N#define DMA_CH4_RESERVED1          0x07000004
N
N//
N// Channel 5
N//
N#define DMA_CH5_RESERVED0          0x00000005
N#define DMA_CH5_EUSCIA2RX          0x01000005
N#define DMA_CH5_EUSCIB2RX0         0x02000005
N#define DMA_CH5_EUSCIB1RX1         0x03000005
N#define DMA_CH5_EUSCIB0RX2         0x04000005
N#define DMA_CH5_EUSCIB3RX3         0x05000005
N#define DMA_CH5_TIMERA2CCR2        0x06000005
N#define DMA_CH5_RESERVED1          0x07000005
N
N//
N// Channel 6
N//
N#define DMA_CH6_RESERVED0          0x00000006
N#define DMA_CH6_EUSCIA3TX          0x01000006
N#define DMA_CH6_EUSCIB3TX0         0x02000006
N#define DMA_CH6_EUSCIB2TX1         0x03000006
N#define DMA_CH6_EUSCIB1TX2         0x04000006
N#define DMA_CH6_EUSCIB0TX3         0x05000006
N#define DMA_CH6_TIMERA3CCR0        0x06000006
N#define DMA_CH6_EXTERNALPIN        0x07000006
N
N//
N// Channel 7
N//
N#define DMA_CH7_RESERVED0          0x00000007
N#define DMA_CH7_EUSCIA3RX          0x01000007
N#define DMA_CH7_EUSCIB3RX0         0x02000007
N#define DMA_CH7_EUSCIB2RX1         0x03000007
N#define DMA_CH7_EUSCIB1RX2         0x04000007
N#define DMA_CH7_EUSCIB0RX3         0x05000007
N#define DMA_CH7_TIMERA3CCR2        0x06000007
N#define DMA_CH7_ADC14              0x07000007
N
N//
N//  Different interrupt handlers to pass into DMA_registerInterrupt and
N//   DMA_unregisterInterrupt and other Int functions
N//
N#define DMA_INT0   INT_DMA_INT0
N#define DMA_INT1   INT_DMA_INT1
N#define DMA_INT2   INT_DMA_INT2
N#define DMA_INT3   INT_DMA_INT3
N#define DMA_INTERR INT_DMA_ERR
N
N#define DMA_CHANNEL_0       0
N#define DMA_CHANNEL_1       1
N#define DMA_CHANNEL_2       2
N#define DMA_CHANNEL_3       3
N#define DMA_CHANNEL_4       4
N#define DMA_CHANNEL_5       5
N#define DMA_CHANNEL_6       6
N#define DMA_CHANNEL_7       7
N
N//*****************************************************************************
N//
N// API Function prototypes
N//
N//*****************************************************************************
N
N//*****************************************************************************
N//
N//! Enables the DMA controller for use.
N//!
N//! This function enables the DMA controller.  The DMA controller must be
N//! enabled before it can be configured and used.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void DMA_enableModule(void);
N
N//*****************************************************************************
N//
N//! Disables the DMA controller for use.
N//!
N//! This function disables the DMA controller.  Once disabled, the DMA
N//! controller cannot operate until re-enabled with DMA_enableModule().
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void DMA_disableModule(void);
N
N//*****************************************************************************
N//
N//! Gets the DMA error status.
N//!
N//! This function returns the DMA error status.  It should be called from
N//! within the DMA error interrupt handler to determine if a DMA error
N//! occurred.
N//!
N//! \return Returns non-zero if a DMA error is pending.
N//
N//*****************************************************************************
Nextern uint32_t DMA_getErrorStatus(void);
N
N//*****************************************************************************
N//
N//! Clears the DMA error interrupt.
N//!
N//! This function clears a pending DMA error interrupt.  This function should
N//! be called from within the DMA error interrupt handler to clear the
N//! interrupt.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void DMA_clearErrorStatus(void);
N
N//*****************************************************************************
N//
N//! Enables a DMA channel for operation.
N//!
N//! \param channelNum is the channel number to enable.
N//!
N//! When a DMA transfer is completed, the channel is automatically disabled by
N//! the DMA controller.  Therefore, this function should be called prior to
N//! starting up any new transfer.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void DMA_enableChannel(uint32_t channelNum);
N
N//*****************************************************************************
N//
N//! Disables a DMA channel for operation.
N//!
N//! \param channelNum is the channel number to disable.
N//!
N//! This function disables a specific DMA channel.  Once disabled, a channel
N//! cannot respond to DMA transfer requests until re-enabled via
N//! DMA_enableChannel().
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void DMA_disableChannel(uint32_t channelNum);
N
N//*****************************************************************************
N//
N//! Checks if a DMA channel is enabled for operation.
N//!
N//! \param channelNum is the channel number to check.
N//!
N//! This function checks to see if a specific DMA channel is enabled.  This
N//! function can be used to check the status of a transfer, as the channel is
N//! automatically disabled at the end of a transfer.
N//!
N//! \return Returns \b true if the channel is enabled, \b false if disabled.
N//
N//*****************************************************************************
Nextern bool DMA_isChannelEnabled(uint32_t channelNum);
N
N//*****************************************************************************
N//
N//! Sets the base address for the channel control table.
N//!
N//! \param controlTable is a pointer to the 1024-byte-aligned base address
N//! of the DMA channel control table.
N//!
N//! This function configures the base address of the channel control table.
N//! This table resides in system memory and holds control information for each
N//! DMA channel.  The table must be aligned on a 1024-byte boundary.  The base
N//! address must be configured before any of the channel functions can be used.
N//!
N//! The size of the channel control table depends on the number of DMA
N//! channels and the transfer modes that are used.  Refer to the introductory
N//! text and the microcontroller datasheet for more information about the
N//! channel control table.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void DMA_setControlBase(void *controlTable);
N
N//*****************************************************************************
N//
N//! Gets the base address for the channel control table.
N//!
N//! This function gets the base address of the channel control table.  This
N//! table resides in system memory and holds control information for each DMA
N//! channel.
N//!
N//! \return Returns a pointer to the base address of the channel control table.
N//
N//*****************************************************************************
Nextern void* DMA_getControlBase(void);
N
N//*****************************************************************************
N//
N//! Gets the base address for the channel control table alternate structures.
N//!
N//! This function gets the base address of the second half of the channel
N//! control table that holds the alternate control structures for each channel.
N//!
N//! \return Returns a pointer to the base address of the second half of the
N//! channel control table.
N//
N//*****************************************************************************
Nextern void* DMA_getControlAlternateBase(void);
N
N//*****************************************************************************
N//
N//! Requests a DMA channel to start a transfer.
N//!
N//! \param channelNum is the channel number on which to request a DMA
N//! transfer.
N//!
N//! This function allows software to request a DMA channel to begin a
N//! transfer.  This function could be used for performing a memory-to-memory
N//! transfer, or if for some reason a transfer needs to be initiated by
N//! software instead of the peripheral associated with that channel.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void DMA_requestChannel(uint32_t channelNum);
N
N//*****************************************************************************
N//
N//! Enables attributes of a DMA channel.
N//!
N//! \param channelNum is the channel to configure.
N//! \param attr is a combination of attributes for the channel.
N//!
N//! This function is used to enable attributes of a DMA channel.
N//!
N//! The \e attr parameter is the logical OR of any of the following:
N//!
N//! - \b UDMA_ATTR_USEBURST is used to restrict transfers to use only burst
N//!   mode.
N//! - \b UDMA_ATTR_ALTSELECT is used to select the alternate control structure
N//!   for this channel (it is very unlikely that this flag should be used).
N//! - \b UDMA_ATTR_HIGH_PRIORITY is used to set this channel to high priority.
N//! - \b UDMA_ATTR_REQMASK is used to mask the hardware request signal from the
N//!   peripheral for this channel.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void DMA_enableChannelAttribute(uint32_t channelNum, uint32_t attr);
N
N//*****************************************************************************
N//
N//! Disables attributes of a DMA channel.
N//!
N//! \param channelNum is the channel to configure.
N//! \param attr is a combination of attributes for the channel.
N//!
N//! This function is used to disable attributes of a DMA channel.
N//!
N//! The \e attr parameter is the logical OR of any of the following:
N//!
N//! - \b UDMA_ATTR_USEBURST is used to restrict transfers to use only burst
N//!   mode.
N//! - \b UDMA_ATTR_ALTSELECT is used to select the alternate control structure
N//!   for this channel.
N//! - \b UDMA_ATTR_HIGH_PRIORITY is used to set this channel to high priority.
N//! - \b UDMA_ATTR_REQMASK is used to mask the hardware request signal from the
N//!   peripheral for this channel.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void DMA_disableChannelAttribute(uint32_t channelNum, uint32_t attr);
N
N//*****************************************************************************
N//
N//! Gets the enabled attributes of a DMA channel.
N//!
N//! \param channelNum is the channel to configure.
N//!
N//! This function returns a combination of flags representing the attributes of
N//! the DMA channel.
N//!
N//! \return Returns the logical OR of the attributes of the DMA channel, which
N//! can be any of the following:
N//! - \b UDMA_ATTR_USEBURST is used to restrict transfers to use only burst
N//!   mode.
N//! - \b UDMA_ATTR_ALTSELECT is used to select the alternate control structure
N//!   for this channel.
N//! - \b UDMA_ATTR_HIGH_PRIORITY is used to set this channel to high priority.
N//! - \b UDMA_ATTR_REQMASK is used to mask the hardware request signal from the
N//!   peripheral for this channel.
N//
N//*****************************************************************************
Nextern uint32_t DMA_getChannelAttribute(uint32_t channelNum);
N
N//*****************************************************************************
N//
N//! Sets the control parameters for a DMA channel control structure.
N//!
N//! \param channelStructIndex is the logical OR of the DMA channel number
N//! with \b UDMA_PRI_SELECT or \b UDMA_ALT_SELECT.
N//! \param control is logical OR of several control values to set the control
N//! parameters for the channel.
N//!
N//! This function is used to set control parameters for a DMA transfer.  These
N//! parameters are typically not changed often.
N//!
N//! The \e channelStructIndex parameter should be the logical OR of the
N//! channel number with one of \b UDMA_PRI_SELECT or \b UDMA_ALT_SELECT to
N//! choose whether the primary or alternate data structure is used.
N//!
N//! The \e control parameter is the logical OR of five values: the data size,
N//! the source address increment, the destination address increment, the
N//! arbitration size, and the use burst flag.  The choices available for each
N//! of these values is described below.
N//!
N//! Choose the data size from one of \b UDMA_SIZE_8, \b UDMA_SIZE_16, or
N//! \b UDMA_SIZE_32 to select a data size of 8, 16, or 32 bits.
N//!
N//! Choose the source address increment from one of \b UDMA_SRC_INC_8,
N//! \b UDMA_SRC_INC_16, \b UDMA_SRC_INC_32, or \b UDMA_SRC_INC_NONE to select
N//! an address increment of 8-bit bytes, 16-bit half-words, 32-bit words, or
N//! to select non-incrementing.
N//!
N//! Choose the destination address increment from one of \b UDMA_DST_INC_8,
N//! \b UDMA_DST_INC_16, \b UDMA_DST_INC_32, or \b UDMA_SRC_INC_8 to select
N//! an address increment of 8-bit bytes, 16-bit half-words, 32-bit words, or
N//! to select non-incrementing.
N//!
N//! The arbitration size determines how many items are transferred before
N//! the DMA controller re-arbitrates for the bus.  Choose the arbitration size
N//! from one of \b UDMA_ARB_1, \b UDMA_ARB_2, \b UDMA_ARB_4, \b UDMA_ARB_8,
N//! through \b UDMA_ARB_1024 to select the arbitration size from 1 to 1024
N//! items, in powers of 2.
N//!
N//! The value \b UDMA_NEXT_USEBURST is used to force the channel to only
N//! respond to burst requests at the tail end of a scatter-gather transfer.
N//!
N//! \note The address increment cannot be smaller than the data size.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void DMA_setChannelControl(uint32_t channelStructIndex,
N        uint32_t control);
N
N//*****************************************************************************
N//
N//! Sets the transfer parameters for a DMA channel control structure.
N//!
N//! \param channelStructIndex is the logical OR of the DMA channel number
N//! with either \b UDMA_PRI_SELECT or \b UDMA_ALT_SELECT.
N//! \param mode is the type of DMA transfer.
N//! \param srcAddr is the source address for the transfer.
N//! \param dstAddr is the destination address for the transfer.
N//! \param transferSize is the number of data items to transfer.
N//!
N//! This function is used to configure the parameters for a DMA transfer.
N//! These parameters are typically changed often.  The function
N//! DMA_setChannelControl() MUST be called at least once for this channel prior
N//! to calling this function.
N//!
N//! The \e channelStructIndex parameter should be the logical OR of the
N//! channel number with one of \b UDMA_PRI_SELECT or \b UDMA_ALT_SELECT to
N//! choose whether the primary or alternate data structure is used.
N//!
N//! The \e mode parameter should be one of the following values:
N//!
N//! - \b UDMA_MODE_STOP stops the DMA transfer.  The controller sets the mode
N//!   to this value at the end of a transfer.
N//! - \b UDMA_MODE_BASIC to perform a basic transfer based on request.
N//! - \b UDMA_MODE_AUTO to perform a transfer that always completes once
N//!   started even if the request is removed.
N//! - \b UDMA_MODE_PINGPONG to set up a transfer that switches between the
N//!   primary and alternate control structures for the channel.  This mode
N//!   allows use of ping-pong buffering for DMA transfers.
N//! - \b UDMA_MODE_MEM_SCATTER_GATHER to set up a memory scatter-gather
N//!   transfer.
N//! - \b UDMA_MODE_PER_SCATTER_GATHER to set up a peripheral scatter-gather
N//!   transfer.
N//!
N//! The \e srcAddr and \e dstAddr parameters are pointers to the first
N//! location of the data to be transferred.  These addresses should be aligned
N//! according to the item size.  The compiler takes care of this alignment if
N//! the pointers are pointing to storage of the appropriate data type.
N//!
N//! The \e transferSize parameter is the number of data items, not the number
N//! of bytes.
N//!
N//! The two scatter-gather modes, memory and peripheral, are actually different
N//! depending on whether the primary or alternate control structure is
N//! selected.  This function looks for the \b UDMA_PRI_SELECT and
N//! \b UDMA_ALT_SELECT flag along with the channel number and sets the
N//! scatter-gather mode as appropriate for the primary or alternate control
N//! structure.
N//!
N//! The channel must also be enabled using DMA_enableChannel() after calling
N//! this function.  The transfer does not begin until the channel has been
N//! configured and enabled.  Note that the channel is automatically disabled
N//! after the transfer is completed, meaning that DMA_enableChannel() must be
N//! called again after setting up the next transfer.
N//!
N//! \note Great care must be taken to not modify a channel control structure
N//! that is in use or else the results are unpredictable, including the
N//! possibility of undesired data transfers to or from memory or peripherals.
N//! For BASIC and AUTO modes, it is safe to make changes when the channel is
N//! disabled, or the DMA_getChannelMode() returns \b UDMA_MODE_STOP.  For
N//! PINGPONG or one of the SCATTER_GATHER modes, it is safe to modify the
N//! primary or alternate control structure only when the other is being used.
N//! The DMA_getChannelMode() function returns \b UDMA_MODE_STOP when a
N//! channel control structure is inactive and safe to modify.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void DMA_setChannelTransfer(uint32_t channelStructIndex, uint32_t mode,
N        void *srcAddr, void *dstAddr, uint32_t transferSize);
N
N//*****************************************************************************
N//
N//! Configures a DMA channel for scatter-gather mode.
N//!
N//! \param channelNum is the DMA channel number.
N//! \param taskCount is the number of scatter-gather tasks to execute.
N//! \param taskList is a pointer to the beginning of the scatter-gather
N//! task list.
N//! \param isPeriphSG is a flag to indicate it is a peripheral scatter-gather
N//! transfer (else it is memory scatter-gather transfer)
N//!
N//! This function is used to configure a channel for scatter-gather mode.
N//! The caller must have already set up a task list and must pass a pointer to
N//! the start of the task list as the \e taskList parameter.  The
N//! \e taskCount parameter is the count of tasks in the task list, not the
N//! size of the task list.  The flag \e bIsPeriphSG should be used to indicate
N//! if scatter-gather should be configured for peripheral or memory
N//! operation.
N//!
N//! \sa DMA_TaskStructEntry
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void DMA_setChannelScatterGather(uint32_t channelNum, uint32_t taskCount,
N        void *taskList, uint32_t isPeriphSG);
N
N//*****************************************************************************
N//
N//! Gets the current transfer size for a DMA channel control structure.
N//!
N//! \param channelStructIndex is the logical OR of the DMA channel number
N//! with either \b UDMA_PRI_SELECT or \b UDMA_ALT_SELECT.
N//!
N//! This function is used to get the DMA transfer size for a channel.  The
N//! transfer size is the number of items to transfer, where the size of an item
N//! might be 8, 16, or 32 bits.  If a partial transfer has already occurred,
N//! then the number of remaining items is returned.  If the transfer is
N//! complete, then 0 is returned.
N//!
N//! \return Returns the number of items remaining to transfer.
N//
N//*****************************************************************************
Nextern uint32_t DMA_getChannelSize(uint32_t channelStructIndex);
N
N//*****************************************************************************
N//
N//! Gets the transfer mode for a DMA channel control structure.
N//!
N//! \param channelStructIndex is the logical OR of the DMA channel number
N//! with either \b UDMA_PRI_SELECT or \b UDMA_ALT_SELECT.
N//!
N//! This function is used to get the transfer mode for the DMA channel and
N//! to query the status of a transfer on a channel.  When the transfer is
N//! complete the mode is \b UDMA_MODE_STOP.
N//!
N//! \return Returns the transfer mode of the specified channel and control
N//! structure, which is one of the following values: \b UDMA_MODE_STOP,
N//! \b UDMA_MODE_BASIC, \b UDMA_MODE_AUTO, \b UDMA_MODE_PINGPONG,
N//! \b UDMA_MODE_MEM_SCATTER_GATHER, or \b UDMA_MODE_PER_SCATTER_GATHER.
N//
N//*****************************************************************************
Nextern uint32_t DMA_getChannelMode(uint32_t channelStructIndex);
N
N//*****************************************************************************
N//
N//! Assigns a peripheral mapping for a DMA channel.
N//!
N//! \param mapping is a macro specifying the peripheral assignment for
N//! a channel.
N//!
N//! This function assigns a peripheral mapping to a DMA channel.  It is
N//! used to select which peripheral is used for a DMA channel.  The parameter
N//! \e mapping should be one of the macros named \b UDMA_CHn_tttt from the
N//! header file \e dma.h.  For example, to assign DMA channel 0 to the
N//! eUSCI AO RX channel, the parameter should be the macro
N//! \b UDMA_CH1_EUSCIA0RX.
N//!
N//! Please consult the data sheet for a table showing all the
N//! possible peripheral assignments for the DMA channels for a particular
N//! device.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void DMA_assignChannel(uint32_t mapping);
N
N//*****************************************************************************
N//
N//! Initializes a software transfer of the corresponding DMA channel. This is
N//! done if the user wants to force a DMA on the specified channel without the
N//! hardware precondition. Specific channels can be configured using the
N//! DMA_assignChannel function.
N//!
N//! \param channel is the channel to trigger the interrupt
N//!
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void DMA_requestSoftwareTransfer(uint32_t channel);
N
N//*****************************************************************************
N//
N//! Assigns a specific DMA channel to the corresponding interrupt handler. For
N//! MSP432 devices, there are three configurable interrupts, and one master
N//! interrupt. This function will assign a specific DMA channel to the
N//! provided configurable DMA interrupt.
N//!
N//! Note that once a channel is assigned to a configurable interrupt, it will be
N//! masked in hardware from the master DMA interrupt (interruptNumber zero). This
N//! function can also be used in conjunction with the DMAIntTrigger function
N//! to provide the feature to software trigger specific channel interrupts.
N//!
N//! \param interruptNumber is the configurable interrupt to assign the given
N//! channel. Valid values are:
N//! - \b DMA_INT1 the first configurable DMA interrupt handler
N//! - \b DMA_INT2 the second configurable DMA interrupt handler
N//! - \b DMA_INT3 the third configurable DMA interrupt handler
N//!
N//! \param channel is the channel to assign the interrupt
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void DMA_assignInterrupt(uint32_t interruptNumber, uint32_t channel);
N
N//*****************************************************************************
N//
N//! Enables the specified interrupt for the DMA controller. Note for interrupts
N//! one through three, specific channels have to be mapped to the interrupt
N//! using the DMA_assignInterrupt function.
N//!
N//! \param interruptNumber identifies which DMA interrupt is to be enabled.
N//! This interrupt should be one of the following:
N//!
N//! - \b DMA_INT0 the master DMA interrupt handler
N//! - \b DMA_INT1 the first configurable DMA interrupt handler
N//! - \b DMA_INT2 the second configurable DMA interrupt handler
N//! - \b DMA_INT3 the third configurable DMA interrupt handler
N//! - \b DMA_INTERR the third configurable DMA interrupt handler
N//!
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void DMA_enableInterrupt(uint32_t interruptNumber);
N
N//*****************************************************************************
N//
N//! Disables the specified interrupt for the DMA controller.
N//!
N//! \param interruptNumber identifies which DMA interrupt is to be disabled.
N//! This interrupt should be one of the following:
N//!
N//! - \b DMA_INT0 the master DMA interrupt handler
N//! - \b DMA_INT1 the first configurable DMA interrupt handler
N//! - \b DMA_INT2 the second configurable DMA interrupt handler
N//! - \b DMA_INT3 the third configurable DMA interrupt handler
N//! - \b DMA_INTERR the third configurable DMA interrupt handler
N//!
N//!  Note for interrupts that are associated with a specific DMA channel
N//! (DMA_INT1 - DMA_INT3), this function will also enable that specific
N//! channel for interrupts.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void DMA_disableInterrupt(uint32_t interruptNumber);
N
N//*****************************************************************************
N//
N//! Gets the DMA controller channel interrupt status for interrupt zero.
N//!
N//! This function is used to get the interrupt status of the DMA controller.
N//! The returned value is a 32-bit bit mask that indicates which channels are
N//! requesting an interrupt.  This function can be used from within an
N//! interrupt handler to determine or confirm which DMA channel has requested
N//! an interrupt.
N//!
N//! Note that this will only apply to interrupt zero for the DMA
N//! controller as only one interrupt can be associated with interrupts one
N//! through three. If an interrupt is assigned to an interrupt other
N//! than interrupt zero, it will be masked by this function.
N//!
N//! \return Returns a 32-bit mask which indicates requesting DMA channels.
N//! There is a bit for each channel and a 1 indicates that the channel
N//! is requesting an interrupt.  Multiple bits can be set.
N//
N//*****************************************************************************
Nextern uint32_t DMA_getInterruptStatus(void);
N
N//*****************************************************************************
N//
N//! Clears the DMA controller channel interrupt mask for interrupt zero.
N//!
N//! \param channel is the channel interrupt to clear.
N//!
N//! This function is used to clear  the interrupt status of the DMA controller.
N//! Note that only interrupts that weren't assigned to DMA interrupts one
N//! through three using the DMA_assignInterrupt function will be affected by
N//! thisfunctions. For other DMA interrupts, only one channel can be associated
N//! and therefore clearing in unnecessary.
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void DMA_clearInterruptFlag(uint32_t intChannel);
N
N//*****************************************************************************
N//
N//! Registers an interrupt handler for the DMA controller.
N//!
N//! \param interruptNumber identifies which DMA interrupt is to be registered.
N//! \param intHandler is a pointer to the function to be called when the
N//! interrupt is called.
N//!
N//! This function registers and enables the handler to be called when the DMA
N//! controller generates an interrupt.  The \e interrupt parameter should be
N//! one of the following:
N//!
N//! - \b DMA_INT0 the master DMA interrupt handler
N//! - \b DMA_INT1 the first configurable DMA interrupt handler
N//! - \b DMA_INT2 the second configurable DMA interrupt handler
N//! - \b DMA_INT3 the third configurable DMA interrupt handler
N//! - \b DMA_INTERR the third configurable DMA interrupt handler
N//!
N//! \sa Interrupt_registerInterrupt() for important information about
N//! registering interrupt handlers.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void DMA_registerInterrupt(uint32_t intChannel, 
N                                    void (*intHandler)(void));
N
N//*****************************************************************************
N//
N//! Unregisters an interrupt handler for the DMA controller.
N//!
N//! \param interruptNumber identifies which DMA interrupt to unregister.
N//!
N//! This function disables and unregisters the handler to be called for the
N//! specified DMA interrupt.  The \e interrupt parameter should be one of
N//! \b the parameters as documented for the function
N//! DMA_registerInterrupt().
N//!
N//! Note fore interrupts that are associated with a specific DMA channel
N//! (DMA_INT1 - DMA_INT3), this function will also disable that specific
N//! channel for interrupts.
N//!
N//! \sa Interrupt_registerInterrupt() for important information about
N//!  registering interrupt handlers.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void DMA_unregisterInterrupt(uint32_t intChannel);
N
N//*****************************************************************************
N//
N// Mark the end of the C bindings section for C++ compilers.
N//
N//*****************************************************************************
N#ifdef __cplusplus
N}
N#endif
N
N//*****************************************************************************
N//
N// Close the Doxygen group.
N//! @}
N//
N//*****************************************************************************
N
N#endif // __UDMA_H__
L 47 "C:/ti/msp432_driverlib_3_21_00_05/driverlib/MSP432P4xx/driverlib.h" 2
N#include "eusci.h"
L 1 "C:\ti\msp432_driverlib_3_21_00_05\driverlib\MSP432P4xx\eusci.h" 1
N/*
N * -------------------------------------------
N *    MSP432 DriverLib - v3_21_00_05 
N * -------------------------------------------
N *
N * --COPYRIGHT--,BSD,BSD
N * Copyright (c) 2016, Texas Instruments Incorporated
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N *
N * *  Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N *
N * *  Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * *  Neither the name of Texas Instruments Incorporated nor the names of
N *    its contributors may be used to endorse or promote products derived
N *    from this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
N * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
N * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
N * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
N * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
N * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
N * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
N * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
N * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * --/COPYRIGHT--*/
N#ifndef EUSCI_H_
N#define EUSCI_H_
N
N#include <msp.h>
N
N#define EUSCI_A_CMSIS(x) ((EUSCI_A_Type *) x)
N#define EUSCI_B_CMSIS(x) ((EUSCI_B_Type *) x)
N
N#endif /* EUSCI_H_ */
L 48 "C:/ti/msp432_driverlib_3_21_00_05/driverlib/MSP432P4xx/driverlib.h" 2
N#include "flash.h"
L 1 "C:\ti\msp432_driverlib_3_21_00_05\driverlib\MSP432P4xx\flash.h" 1
N/*
N * -------------------------------------------
N *    MSP432 DriverLib - v3_21_00_05 
N * -------------------------------------------
N *
N * --COPYRIGHT--,BSD,BSD
N * Copyright (c) 2016, Texas Instruments Incorporated
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N *
N * *  Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N *
N * *  Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * *  Neither the name of Texas Instruments Incorporated nor the names of
N *    its contributors may be used to endorse or promote products derived
N *    from this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
N * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
N * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
N * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
N * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
N * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
N * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
N * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
N * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * --/COPYRIGHT--*/
N#ifndef __FLASH_H__
N#define __FLASH_H__
N
N//*****************************************************************************
N//
N//! \addtogroup flash_api
N//! @{
N//
N//*****************************************************************************
N
N//*****************************************************************************
N//
N// If building with a C++ compiler, make all of the definitions in this header
N// have a C binding.
N//
N//*****************************************************************************
N#ifdef __cplusplus
Nextern "C"
N{
N#endif
N
N#include <msp.h>
N#include <stdbool.h>
N
N//*****************************************************************************
N//
N// Control specific variables
N//
N//*****************************************************************************
N#define FLASH_BURST_PRG_BIT 0x03
N
N/* Interrupts */
N#define FLASH_PROGRAM_ERROR         FLCTL_IFG_PRG_ERR
N#define FLASH_BENCHMARK_INT         FLCTL_IFG_BMRK
N#define FLASH_ERASE_COMPLETE        FLCTL_IFG_ERASE
N#define FLASH_BRSTPRGM_COMPLETE     FLCTL_IFG_PRGB
N#define FLASH_WRDPRGM_COMPLETE      FLCTL_IFG_PRG
N#define FLASH_POSTVERIFY_FAILED     FLCTL_IFG_AVPST
N#define FLASH_PREVERIFY_FAILED      FLCTL_IFG_AVPRE
N#define FLASH_BRSTRDCMP_COMPLETE    FLCTL_IFG_RDBRST
N
N#define FLASH_NORMAL_READ_MODE            FLCTL_BANK0_RDCTL_RD_MODE_0
N#define FLASH_MARGIN0_READ_MODE           FLCTL_BANK0_RDCTL_RD_MODE_1
N#define FLASH_MARGIN1_READ_MODE           FLCTL_BANK0_RDCTL_RD_MODE_2
N#define FLASH_PROGRAM_VERIFY_READ_MODE    FLCTL_BANK0_RDCTL_RD_MODE_3
N#define FLASH_ERASE_VERIFY_READ_MODE      FLCTL_BANK0_RDCTL_RD_MODE_4
N#define FLASH_LEAKAGE_VERIFY_READ_MODE    FLCTL_BANK0_RDCTL_RD_MODE_5
N#define FLASH_MARGIN0B_READ_MODE          FLCTL_BANK0_RDCTL_RD_MODE_9
N#define FLASH_MARGIN1B_READ_MODE          FLCTL_BANK0_RDCTL_RD_MODE_10
N
N#define FLASH_PRGBRSTCTLSTAT_BURSTSTATUS_COMPLETE FLCTL_PRGBRST_CTLSTAT_BURST_STATUS_7
N
N#define FLASH_BANK0                 0x00
N#define FLASH_BANK1                 0x01
N#define FLASH_DATA_READ             0x00
N#define FLASH_INSTRUCTION_FETCH     0x01
N
N#define FLASH_MAIN_MEMORY_SPACE_BANK0     0x01
N#define FLASH_MAIN_MEMORY_SPACE_BANK1     0x02
N#define FLASH_INFO_MEMORY_SPACE_BANK0      0x03
N#define FLASH_INFO_MEMORY_SPACE_BANK1      0x04
N
N#define FLASH_MAIN_SPACE    FLCTL_RDBRST_CTLSTAT_MEM_TYPE_0
N#define FLASH_INFO_SPACE    FLCTL_RDBRST_CTLSTAT_MEM_TYPE_1
N#define FLASH_1_PATTERN FLCTL_RDBRST_CTLSTAT_DATA_CMP
N#define FLASH_0_PATTERN 0x00
N
N#define FLASH_SECTOR0               FLCTL_BANK0_MAIN_WEPROT_PROT0
N#define FLASH_SECTOR1               FLCTL_BANK0_MAIN_WEPROT_PROT1
N#define FLASH_SECTOR2               FLCTL_BANK0_MAIN_WEPROT_PROT2
N#define FLASH_SECTOR3               FLCTL_BANK0_MAIN_WEPROT_PROT3
N#define FLASH_SECTOR4               FLCTL_BANK0_MAIN_WEPROT_PROT4
N#define FLASH_SECTOR5               FLCTL_BANK0_MAIN_WEPROT_PROT5
N#define FLASH_SECTOR6               FLCTL_BANK0_MAIN_WEPROT_PROT6
N#define FLASH_SECTOR7               FLCTL_BANK0_MAIN_WEPROT_PROT7
N#define FLASH_SECTOR8               FLCTL_BANK0_MAIN_WEPROT_PROT8
N#define FLASH_SECTOR9               FLCTL_BANK0_MAIN_WEPROT_PROT9
N#define FLASH_SECTOR10              FLCTL_BANK0_MAIN_WEPROT_PROT10
N#define FLASH_SECTOR11              FLCTL_BANK0_MAIN_WEPROT_PROT11
N#define FLASH_SECTOR12              FLCTL_BANK0_MAIN_WEPROT_PROT12
N#define FLASH_SECTOR13              FLCTL_BANK0_MAIN_WEPROT_PROT13
N#define FLASH_SECTOR14              FLCTL_BANK0_MAIN_WEPROT_PROT14
N#define FLASH_SECTOR15              FLCTL_BANK0_MAIN_WEPROT_PROT15
N#define FLASH_SECTOR16              FLCTL_BANK0_MAIN_WEPROT_PROT16
N#define FLASH_SECTOR17              FLCTL_BANK0_MAIN_WEPROT_PROT17
N#define FLASH_SECTOR18              FLCTL_BANK0_MAIN_WEPROT_PROT18
N#define FLASH_SECTOR19              FLCTL_BANK0_MAIN_WEPROT_PROT19
N#define FLASH_SECTOR20              FLCTL_BANK0_MAIN_WEPROT_PROT20
N#define FLASH_SECTOR21              FLCTL_BANK0_MAIN_WEPROT_PROT21
N#define FLASH_SECTOR22              FLCTL_BANK0_MAIN_WEPROT_PROT22
N#define FLASH_SECTOR23              FLCTL_BANK0_MAIN_WEPROT_PROT23
N#define FLASH_SECTOR24              FLCTL_BANK0_MAIN_WEPROT_PROT24
N#define FLASH_SECTOR25              FLCTL_BANK0_MAIN_WEPROT_PROT25
N#define FLASH_SECTOR26              FLCTL_BANK0_MAIN_WEPROT_PROT26
N#define FLASH_SECTOR27              FLCTL_BANK0_MAIN_WEPROT_PROT27
N#define FLASH_SECTOR28              FLCTL_BANK0_MAIN_WEPROT_PROT28
N#define FLASH_SECTOR29              FLCTL_BANK0_MAIN_WEPROT_PROT29
N#define FLASH_SECTOR30              FLCTL_BANK0_MAIN_WEPROT_PROT30
N#define FLASH_SECTOR31              FLCTL_BANK0_MAIN_WEPROT_PROT31
N
N#define FLASH_NOVER     0
N#define FLASH_BURSTPOST FLCTL_PRGBRST_CTLSTAT_AUTO_PST
N#define FLASH_BURSTPRE FLCTL_PRGBRST_CTLSTAT_AUTO_PRE
N#define FLASH_REGPRE FLCTL_PRG_CTLSTAT_VER_PRE
N#define FLASH_REGPOST FLCTL_PRG_CTLSTAT_VER_PST
N#define FLASH_FULLVER (FLCTL_PRGBRST_CTLSTAT_AUTO_PST |                        \
N                    FLCTL_PRGBRST_CTLSTAT_AUTO_PRE | FLCTL_PRG_CTLSTAT_VER_PRE \
N                    | FLCTL_PRG_CTLSTAT_VER_PST)
X#define FLASH_FULLVER (FLCTL_PRGBRST_CTLSTAT_AUTO_PST |                                            FLCTL_PRGBRST_CTLSTAT_AUTO_PRE | FLCTL_PRG_CTLSTAT_VER_PRE                     | FLCTL_PRG_CTLSTAT_VER_PST)
N
N#define FLASH_COLLATED_WRITE_MODE  0x01
N#define FLASH_IMMEDIATE_WRITE_MODE 0x02
N
N#define __INFO_FLASH_TECH_START__  0x00200000
N#define __INFO_FLASH_TECH_MIDDLE__ 0x00202000
N
N
N//*****************************************************************************
N//
N// Prototypes for the APIs.
N//
N//*****************************************************************************
N
N//*****************************************************************************
N//
N//! Calculates the flash bank and sector number given an address. Stores the 
N//! results into the two pointers given as parameters. The user must provide
N//! a valid memory address (an address in SRAM for example will give an invalid
N//! result).
N//!
N//! \param addr Address to calculate the bank/sector information for
N//!
N//! \param sectorNum The sector number will be stored in here after the function
N//!                     completes.
N//!
N//! \param sectorNum The bank number will be stored in here after the function
N//!                     completes.
N//!
N//! \note For simplicity, this API only works with address in MAIN flash memory.
N//!        For calculating the sector/bank number of an address in info memory,
N//!         please refer to your device datasheet/
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void FlashCtl_getMemoryInfo(uint32_t addr, uint32_t *sectorNum, 
N                                uint32_t *bankNum);
N
N//*****************************************************************************
N//
N//! Enables read buffering on accesses to a specified bank of flash memory
N//!
N//! \param memoryBank is the value of the memory bank to enable read
N//!  buffering. Must be only one of the following values:
N//!  - \b FLASH_BANK0,
N//!  - \b FLASH_BANK1
N//!
N//! \param accessMethod is the value of the access type to enable read
N//!  buffering. Must be only one of the following values:
N//!  - \b FLASH_DATA_READ,
N//!  - \b FLASH_INSTRUCTION_FETCH
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void FlashCtl_enableReadBuffering(uint_fast8_t memoryBank,
N        uint_fast8_t accessMethod);
N
N//*****************************************************************************
N//
N//! Disables read buffering on accesses to a specified bank of flash memory
N//!
N//! \param memoryBank is the value of the memory bank to disable read
N//!  buffering. Must be only one of the following values:
N//!  - \b FLASH_BANK0,
N//!  - \b FLASH_BANK1
N//!
N//! \param accessMethod is the value of the access type to disable read
N//!  buffering. Must ne only one of the following values:
N//!  - \b FLASH_DATA_READ,
N//!  - \b FLASH_INSTRUCTION_FETCH
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void FlashCtl_disableReadBuffering(uint_fast8_t memoryBank,
N        uint_fast8_t accessMethod);
N
N//*****************************************************************************
N//
N//! Disables program protection on the given sector mask. This setting can be
N//! applied on a sector-wise bases on a given memory space (INFO or MAIN).
N//!
N//! \param memorySpace is the value of the memory bank to disable program
N//!  protection. Must be only one of the following values:
N//!  - \b FLASH_MAIN_MEMORY_SPACE_BANK0,
N//!  - \b FLASH_MAIN_MEMORY_SPACE_BANK1,
N//!  - \b FLASH_INFO_MEMORY_SPACE_BANK0,
N//!  - \b FLASH_INFO_MEMORY_SPACE_BANK1
N//!
N//! \param sectorMask is a bit mask of the sectors to disable program
N//!  protection. Must be a bitfield of the following values:
N//!  - \b FLASH_SECTOR0,
N//!  - \b FLASH_SECTOR1,
N//!  - \b FLASH_SECTOR2,
N//!  - \b FLASH_SECTOR3,
N//!  - \b FLASH_SECTOR4,
N//!  - \b FLASH_SECTOR5,
N//!  - \b FLASH_SECTOR6,
N//!  - \b FLASH_SECTOR7,
N//!  - \b FLASH_SECTOR8,
N//!  - \b FLASH_SECTOR9,
N//!  - \b FLASH_SECTOR10,
N//!  - \b FLASH_SECTOR11,
N//!  - \b FLASH_SECTOR12,
N//!  - \b FLASH_SECTOR13,
N//!  - \b FLASH_SECTOR14,
N//!  - \b FLASH_SECTOR15,
N//!  - \b FLASH_SECTOR16,
N//!  - \b FLASH_SECTOR17,
N//!  - \b FLASH_SECTOR18,
N//!  - \b FLASH_SECTOR19,
N//!  - \b FLASH_SECTOR20,
N//!  - \b FLASH_SECTOR21,
N//!  - \b FLASH_SECTOR22,
N//!  - \b FLASH_SECTOR23,
N//!  - \b FLASH_SECTOR24,
N//!  - \b FLASH_SECTOR25,
N//!  - \b FLASH_SECTOR26,
N//!  - \b FLASH_SECTOR27,
N//!  - \b FLASH_SECTOR28,
N//!  - \b FLASH_SECTOR29,
N//!  - \b FLASH_SECTOR30,
N//!  - \b FLASH_SECTOR31
N//!
N//!  \note Flash sector sizes are 4KB and the number of sectors may vary
N//!  depending on the specific device. Also, for INFO memory space, only sectors
N//!  \b FLASH_SECTOR0 and \b FLASH_SECTOR1 will exist.
N//!
N//! \note Not all devices will contain a dedicated INFO memory. Please check the
N//!  device datasheet to see if your device has INFO memory available for use.
N//!  For devices without INFO memory, any operation related to the INFO memory 
N//!  will be ignored by the hardware.
N//!
N//! \return true if sector protection disabled false otherwise.
N//
N//*****************************************************************************
Nextern bool FlashCtl_unprotectSector(uint_fast8_t memorySpace,
N        uint32_t sectorMask);
N
N//*****************************************************************************
N//
N//! Enables program protection on the given sector mask. This setting can be
N//! applied on a sector-wise bases on a given memory space (INFO or MAIN).
N//!
N//! \param memorySpace is the value of the memory bank to enable program
N//!  protection. Must be only one of the following values:
N//!  - \b FLASH_MAIN_MEMORY_SPACE_BANK0,
N//!  - \b FLASH_MAIN_MEMORY_SPACE_BANK1,
N//!  - \b FLASH_INFO_MEMORY_SPACE_BANK0,
N//!  - \b FLASH_INFO_MEMORY_SPACE_BANK1
N//!
N//! \param sectorMask is a bit mask of the sectors to enable program
N//!  protection. Must be a bitfield of the following values:
N//!  - \b FLASH_SECTOR0,
N//!  - \b FLASH_SECTOR1,
N//!  - \b FLASH_SECTOR2,
N//!  - \b FLASH_SECTOR3,
N//!  - \b FLASH_SECTOR4,
N//!  - \b FLASH_SECTOR5,
N//!  - \b FLASH_SECTOR6,
N//!  - \b FLASH_SECTOR7,
N//!  - \b FLASH_SECTOR8,
N//!  - \b FLASH_SECTOR9,
N//!  - \b FLASH_SECTOR10,
N//!  - \b FLASH_SECTOR11,
N//!  - \b FLASH_SECTOR12,
N//!  - \b FLASH_SECTOR13,
N//!  - \b FLASH_SECTOR14,
N//!  - \b FLASH_SECTOR15,
N//!  - \b FLASH_SECTOR16,
N//!  - \b FLASH_SECTOR17,
N//!  - \b FLASH_SECTOR18,
N//!  - \b FLASH_SECTOR19,
N//!  - \b FLASH_SECTOR20,
N//!  - \b FLASH_SECTOR21,
N//!  - \b FLASH_SECTOR22,
N//!  - \b FLASH_SECTOR23,
N//!  - \b FLASH_SECTOR24,
N//!  - \b FLASH_SECTOR25,
N//!  - \b FLASH_SECTOR26,
N//!  - \b FLASH_SECTOR27,
N//!  - \b FLASH_SECTOR28,
N//!  - \b FLASH_SECTOR29,
N//!  - \b FLASH_SECTOR30,
N//!  - \b FLASH_SECTOR31
N//!
N//!  \note Flash sector sizes are 4KB and the number of sectors may vary
N//!  depending on the specific device. Also, for INFO memory space, only sectors
N//!  \b FLASH_SECTOR0 and \b FLASH_SECTOR1 will exist.
N//!
N//! \note Not all devices will contain a dedicated INFO memory. Please check the
N//!  device datasheet to see if your device has INFO memory available for use.
N//!  For devices without INFO memory, any operation related to the INFO memory 
N//!  will be ignored by the hardware.
N//!
N//! \return true if sector protection enabled false otherwise.
N//
N//*****************************************************************************
Nextern bool FlashCtl_protectSector(uint_fast8_t memorySpace,
N        uint32_t sectorMask);
N
N//*****************************************************************************
N//
N//! Returns the sector protection for given sector mask and memory space
N//!
N//! \param memorySpace is the value of the memory bank to check for program
N//!  protection. Must be only one of the following values:
N//!  - \b FLASH_MAIN_MEMORY_SPACE_BANK0,
N//!  - \b FLASH_MAIN_MEMORY_SPACE_BANK1,
N//!  - \b FLASH_INFO_MEMORY_SPACE_BANK0,
N//!  - \b FLASH_INFO_MEMORY_SPACE_BANK1
N//!
N//! \param sector is the sector to check for program protection.
N//!  Must be one of the following values:
N//!  - \b FLASH_SECTOR0,
N//!  - \b FLASH_SECTOR1,
N//!  - \b FLASH_SECTOR2,
N//!  - \b FLASH_SECTOR3,
N//!  - \b FLASH_SECTOR4,
N//!  - \b FLASH_SECTOR5,
N//!  - \b FLASH_SECTOR6,
N//!  - \b FLASH_SECTOR7,
N//!  - \b FLASH_SECTOR8,
N//!  - \b FLASH_SECTOR9,
N//!  - \b FLASH_SECTOR10,
N//!  - \b FLASH_SECTOR11,
N//!  - \b FLASH_SECTOR12,
N//!  - \b FLASH_SECTOR13,
N//!  - \b FLASH_SECTOR14,
N//!  - \b FLASH_SECTOR15,
N//!  - \b FLASH_SECTOR16,
N//!  - \b FLASH_SECTOR17,
N//!  - \b FLASH_SECTOR18,
N//!  - \b FLASH_SECTOR19,
N//!  - \b FLASH_SECTOR20,
N//!  - \b FLASH_SECTOR21,
N//!  - \b FLASH_SECTOR22,
N//!  - \b FLASH_SECTOR23,
N//!  - \b FLASH_SECTOR24,
N//!  - \b FLASH_SECTOR25,
N//!  - \b FLASH_SECTOR26,
N//!  - \b FLASH_SECTOR27,
N//!  - \b FLASH_SECTOR28,
N//!  - \b FLASH_SECTOR29,
N//!  - \b FLASH_SECTOR30,
N//!  - \b FLASH_SECTOR31
N//!
N//!  Note that flash sector sizes are 4KB and the number of sectors may vary
N//!  depending on the specific device. Also, for INFO memory space, only sectors
N//!  FLASH_SECTOR0 and FLASH_SECTOR1 will exist.
N//!
N//! \note Not all devices will contain a dedicated INFO memory. Please check the
N//!  device datasheet to see if your device has INFO memory available for use.
N//!  For devices without INFO memory, any operation related to the INFO memory 
N//!  will be ignored by the hardware.
N//!
N//! \return true if sector protection enabled false otherwise.
N//
N//*****************************************************************************
Nextern bool FlashCtl_isSectorProtected(uint_fast8_t memorySpace,
N        uint32_t sector);
N
N//*****************************************************************************
N//
N//! Verifies a given segment of memory based off either a high (1) or low (0)
N//! state.
N//!
N//! \param verifyAddr Start address where verification will begin
N//!
N//! \param length Length in bytes to verify based off the pattern
N//!
N//! \param pattern The pattern which verification will check versus. This can
N//!  either be a low pattern (each register will be checked versus a pattern
N//!  of 32 zeros, or a high pattern (each register will be checked versus a
N//!  pattern of 32 ones). Valid values are: FLASH_0_PATTERN, FLASH_1_PATTERN
N//!
N//!  \note There are no sector/boundary restrictions for this function,
N//!  however it is encouraged to proved a start address aligned on 32-bit
N//!  boundaries.  Providing an unaligned address will result in unaligned data
N//!  accesses and detriment efficiency.
N//!
N//!  \note This function is blocking and will not exit until operation has
N//!  either completed or failed due to an error. Furthermore, given the
N//!  complex verification requirements of the flash controller, master
N//!  interrupts are disabled throughout execution of this function. The original
N//!  interrupt context is saved at the start of execution and restored prior
N//!  to exit of the API.
N//!
N//!  \note Due to the hardware limitations of the flash controller, this
N//!  function cannot verify a memory adress in the same flash bank that it
N//!  is executing from. If using the ROM version of this API (by using the
N//!  (ROM_ or MAP_ prefixes) this is a don't care, however if this API resides
N//!  in flash then special care needs to be taken to ensure no code execution
N//!  or reads happen in the flash bank being programmed while this API is
N//!  being executed.
N//!
N//! \return true if memory verification is successful, false otherwise.
N//
N//*****************************************************************************
Nextern bool FlashCtl_verifyMemory(void* verifyAddr, uint32_t length,
N        uint_fast8_t pattern);
N
N//*****************************************************************************
N//
N//!  Performs a mass erase on all unprotected flash sectors. Protected sectors
N//!  are ignored.
N//!
N//!  \note This function is blocking and will not exit until operation has
N//!  either completed or failed due to an error. Furthermore, given the
N//!  complex verification requirements of the flash controller, master
N//!  interrupts are disabled throughout execution of this function. The original
N//!  interrupt context is saved at the start of execution and restored prior
N//!  to exit of the API.
N//!
N//!  \note Due to the hardware limitations of the flash controller, this
N//!  function cannot erase a memory adress in the same flash bank that it
N//!  is executing from. If using the ROM version of this API (by using the
N//!  (ROM_ or MAP_ prefixes) this is a don't care, however if this API resides
N//!  in flash then special care needs to be taken to ensure no code execution
N//!  or reads happen in the flash bank being programmed while this API is
N//!  being executed.
N//!
N//! \return true if mass erase completes successfully, false otherwise
N//
N//*****************************************************************************
Nextern bool FlashCtl_performMassErase(void);
N
N//*****************************************************************************
N//
N//!  Initiates a mass erase and returns control back to the program. This is a
N//!  non-blocking function, however it is the user's responsibility to perform
N//!  the necessary verification requirements after the interrupt is set to
N//!  signify completion. 
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void FlashCtl_initiateMassErase(void);
N
N//*****************************************************************************
N//
N//! Erases a sector of MAIN or INFO flash memory.
N//!
N//! \param addr The start of the sector to erase. Note that with flash,
N//!         the minimum allowed size that can be erased is a flash sector
N//!         (which is 4KB on the MSP432 family). If an address is provided to
N//!         this function which is not on a 4KB boundary, the entire sector
N//!         will still be erased.
N//!
N//!  \note This function is blocking and will not exit until operation has
N//!  either completed or failed due to an error. Furthermore, given the
N//!  complex verification requirements of the flash controller, master
N//!  interrupts are disabled throughout execution of this function. The original
N//!  interrupt context is saved at the start of execution and restored prior
N//!  to exit of the API.
N//!
N//!  \note Due to the hardware limitations of the flash controller, this
N//!  function cannot erase a memory adress in the same flash bank that it
N//!  is executing from. If using the ROM version of this API (by using the
N//!  (ROM_ or MAP_ prefixes) this is a don't care, however if this API resides
N//!  in flash then special care needs to be taken to ensure no code execution
N//!  or reads happen in the flash bank being programmed while this API is
N//!  being executed.
N//!
N//! \return true if sector erase is successful, false otherwise.
N//
N//*****************************************************************************
Nextern bool FlashCtl_eraseSector(uint32_t addr);
N
N//*****************************************************************************
N//
N//! Program a portion of flash memory with the provided data
N//!
N//! \param src Pointer to the data source to program into flash
N//!
N//! \param dest Pointer to the destination in flash to program
N//!
N//! \param length Length in bytes to program
N//!
N//!  \note There are no sector/boundary restrictions for this function,
N//!  however it is encouraged to proved a start address aligned on 32-bit
N//!  boundaries.  Providing an unaligned address will result in unaligned data
N//!  accesses and detriment efficiency.
N//!
N//!  \note This function is blocking and will not exit until operation has
N//!  either completed or failed due to an error. Furthermore, given the
N//!  complex verification requirements of the flash controller, master
N//!  interrupts are disabled throughout execution of this function. The original
N//!  interrupt context is saved at the start of execution and restored prior
N//!  to exit of the API.
N//!
N//!  \note Due to the hardware limitations of the flash controller, this
N//!  function cannot program a memory adress in the same flash bank that it
N//!  is executing from. If using the ROM version of this API (by using the
N//!  (ROM_ or MAP_ prefixes) this is a don't care, however if this API resides
N//!  in flash then special care needs to be taken to ensure no code execution
N//!  or reads happen in the flash bank being programmed while this API is
N//!  being executed.
N//!
N//! \return Whether or not the program succeeded
N//
N//*****************************************************************************
Nextern bool FlashCtl_programMemory(void* src, void* dest, uint32_t length);
N
N//*****************************************************************************
N//
N//! Setups pre/post verification of burst and regular flash programming
N//! instructions. Note that this API is for advanced users that are programming
N//! their own flash drivers. The program/erase APIs are not affected by this
N//! setting and take care of the verification requirements.
N//!
N//! \param verificationSetting Verification setting to set. This value can
N//!  be a bitwise OR of the following values:
N//!     - \b FLASH_BURSTPOST,
N//!     - \b FLASH_BURSTPRE,
N//!     - \b FLASH_REGPRE,
N//!     - \b FLASH_REGPOST
N//!     - \b FLASH_NOVER No verification enabled
N//!     - \b FLASH_FULLVER Full verification enabled
N//!
N//! \return none
N//
N//*****************************************************************************
Nextern void FlashCtl_setProgramVerification(uint32_t verificationSetting);
N
N//*****************************************************************************
N//
N//! Clears pre/post verification of burst and regular flash programming
N//! instructions. Note that this API is for advanced users that are programming
N//! their own flash drivers. The program/erase APIs are not affected by this
N//! setting and take care of the verification requirements.
N//!
N//! \param verificationSetting Verification setting to clear. This value can
N//!  be a bitwise OR of the following values:
N//!     - \b FLASH_BURSTPOST,
N//!     - \b FLASH_BURSTPRE,
N//!     - \b FLASH_REGPRE,
N//!     - \b FLASH_REGPOST
N//!     - \b FLASH_NOVER No verification enabled
N//!     - \b FLASH_FULLVER Full verification enabled
N//!
N//! \return none
N//
N//*****************************************************************************
Nextern void FlashCtl_clearProgramVerification(uint32_t verificationSetting);
N
N//*****************************************************************************
N//
N//! Enables  word programming of flash memory.
N//!
N//! This function will enable word programming of the flash memory and set the
N//! mode of behavior when the flash write occurs.
N//!
N//! \param mode The mode specifies the behavior of the flash controller when
N//!        programming words to flash. In \b FLASH_IMMEDIATE_WRITE_MODE, the
N//!        program operation happens immediately on the write to flash while
N//!        in \b FLASH_COLLATED_WRITE_MODE the write will be delayed until a full
N//!        128-bits have been collated. Possible values include:
N//!             - \b FLASH_IMMEDIATE_WRITE_MODE
N//!             - \b FLASH_COLLATED_WRITE_MODE
N//!
N//!
N//! Refer to the user's guide for further documentation.
N//!
N//! \return none
N//
N//*****************************************************************************
Nextern void FlashCtl_enableWordProgramming(uint32_t mode);
N
N//*****************************************************************************
N//
N//! Disables  word programming of flash memory.
N//!
N//! Refer to FlashCtl_enableWordProgramming and the user's guide for description
N//! on the difference between full word and immediate programming
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void FlashCtl_disableWordProgramming(void);
N
N//*****************************************************************************
N//
N//! Returns if word programming mode is enabled (and if it is, the specific mode)
N//!
N//! Refer to FlashCtl_enableWordProgramming and the user's guide for description
N//! on the difference between full word and immediate programming
N//!
N//! \return a zero value if word programming is disabled,
N//!             - \b FLASH_IMMEDIATE_WRITE_MODE
N//!             - \b FLASH_COLLATED_WRITE_MODE
N//!
N//
N//*****************************************************************************
Nextern uint32_t FlashCtl_isWordProgrammingEnabled(void);
N
N//*****************************************************************************
N//
N//!  Sets the flash read mode to be used by default flash read operations.
N//!  Note that the proper wait states must be set prior to entering this
N//!   function.
N//!
N//! \param flashBank Flash bank to set read mode for. Valid values are:
N//!         - \b FLASH_BANK0
N//!         - \b FLASH_BANK1
N//!
N//! \param readMode The read mode to set. Valid values are:
N//!  - \b FLASH_NORMAL_READ_MODE,
N//!  - \b FLASH_MARGIN0_READ_MODE,
N//!  - \b FLASH_MARGIN1_READ_MODE,
N//!  - \b FLASH_PROGRAM_VERIFY_READ_MODE,
N//!  - \b FLASH_ERASE_VERIFY_READ_MODE,
N//!  - \b FLASH_LEAKAGE_VERIFY_READ_MODE,
N//!  - \b FLASH_MARGIN0B_READ_MODE,
N//!  - \b FLASH_MARGIN1B_READ_MODE
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern bool FlashCtl_setReadMode(uint32_t flashBank, uint32_t readMode);
N
N//*****************************************************************************
N//
N//!  Gets the flash read mode to be used by default flash read operations.
N//!
N//! \param flashBank Flash bank to set read mode for. Valid values are:
N//!         - \b FLASH_BANK0
N//!         - \b FLASH_BANK1
N//!
N//! \return Returns the read mode to set. Valid values are:
N//!  - \b FLASH_NORMAL_READ_MODE,
N//!  - \b FLASH_MARGIN0_READ_MODE,
N//!  - \b FLASH_MARGIN1_READ_MODE,
N//!  - \b FLASH_PROGRAM_VERIFY_READ_MODE,
N//!  - \b FLASH_ERASE_VERIFY_READ_MODE,
N//!  - \b FLASH_LEAKAGE_VERIFY_READ_MODE,
N//!  - \b FLASH_MARGIN0B_READ_MODE,
N//!  - \b FLASH_MARGIN1B_READ_MODE
N//!
N//
N//*****************************************************************************
Nextern uint32_t FlashCtl_getReadMode(uint32_t flashBank);
N
N//*****************************************************************************
N//
N//! Changes the number of wait states that are used by the flash controller
N//! for read operations. When changing frequency ranges of the clock, this
N//! functions must be used in order to allow for readable flash memory.
N//!
N//! \param waitState The number of wait states to set. Note that only
N//!     bits 0-3 are used.
N//!
N//! \param flashBank Flash bank to set wait state for. Valid values are:
N//!         - \b FLASH_BANK0
N//!         - \b FLASH_BANK1
N//!
N//
N//*****************************************************************************
Nextern void FlashCtl_setWaitState(uint32_t bank, uint32_t waitState);
N
N//*****************************************************************************
N//
N//! Returns the set number of flash wait states for the given flash bank.
N//!
N//! \param flashBank Flash bank to set wait state for. Valid values are:
N//!         - \b FLASH_BANK0
N//!         - \b FLASH_BANK1
N//!
N//! \return The wait state setting for the specified flash bank
N//
N//*****************************************************************************
Nextern uint32_t FlashCtl_getWaitState(uint32_t bank);
N
N//*****************************************************************************
N//
N//! Enables individual flash control interrupt sources.
N//!
N//! \param flags is a bit mask of the interrupt sources to be enabled.  Must
N//! be a logical OR of:
N//!         - \b FLASH_PROGRAM_ERROR,
N//!         - \b FLASH_BENCHMARK_INT,
N//!         - \b FLASH_ERASE_COMPLETE,
N//!         - \b FLASH_BRSTPRGM_COMPLETE,
N//!         - \b FLASH_WRDPRGM_COMPLETE,
N//!         - \b FLASH_POSTVERIFY_FAILED,
N//!         - \b FLASH_PREVERIFY_FAILED,
N//!         - \b FLASH_BRSTRDCMP_COMPLETE
N//!
N//! This function enables the indicated flash system interrupt sources.  Only
N//! the sources that are enabled can be reflected to the processor interrupt;
N//! disabled sources have no effect on the processor.
N//!
N//! \note The interrupt sources vary based on the part in use.
N//! Please consult the data sheet for the part you are using to determine
N//! which interrupt sources are available.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void FlashCtl_enableInterrupt(uint32_t flags);
N
N//*****************************************************************************
N//
N//! Disables individual flash system interrupt sources.
N//!
N//! \param flags is a bit mask of the interrupt sources to be disabled.  Must
N//! be a logical OR of:
N//!         - \b FLASH_PROGRAM_ERROR,
N//!         - \b FLASH_BENCHMARK_INT,
N//!         - \b FLASH_ERASE_COMPLETE,
N//!         - \b FLASH_BRSTPRGM_COMPLETE,
N//!         - \b FLASH_WRDPRGM_COMPLETE,
N//!         - \b FLASH_POSTVERIFY_FAILED,
N//!         - \b FLASH_PREVERIFY_FAILED,
N//!         - \b FLASH_BRSTRDCMP_COMPLETE
N//!
N//! This function disables the indicated flash system interrupt sources.
N//! Only the sources that are enabled can be reflected to the processor
N//! interrupt; disabled sources have no effect on the processor.
N//!
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void FlashCtl_disableInterrupt(uint32_t flags);
N
N//*****************************************************************************
N//
N//! Gets the current interrupt status masked with the enabled interrupts.
N//! This function is useful to call in ISRs to get a list
N//! of pending interrupts that are actually enabled and could have caused the
N//! ISR.
N//!
N//! \return The current interrupt status, enumerated as a bit field of
N//!         - \b FLASH_PROGRAM_ERROR,
N//!         - \b FLASH_BENCHMARK_INT,
N//!         - \b FLASH_ERASE_COMPLETE,
N//!         - \b FLASH_BRSTPRGM_COMPLETE,
N//!         - \b FLASH_WRDPRGM_COMPLETE,
N//!         - \b FLASH_POSTVERIFY_FAILED,
N//!         - \b FLASH_PREVERIFY_FAILED,
N//!         - \b FLASH_BRSTRDCMP_COMPLETE
N//!
N//! \note The interrupt sources vary based on the part in use.
N//! Please consult the data sheet for the part you are using to determine
N//! which interrupt sources are available.
N//
N//*****************************************************************************
Nextern uint32_t FlashCtl_getEnabledInterruptStatus(void);
N
N//*****************************************************************************
N//
N//! Gets the current interrupt status.
N//!
N//! \return The current interrupt status, enumerated as a bit field of:
N//!         - \b FLASH_PROGRAM_ERROR,
N//!         - \b FLASH_BENCHMARK_INT,
N//!         - \b FLASH_ERASE_COMPLETE,
N//!         - \b FLASH_BRSTPRGM_COMPLETE,
N//!         - \b FLASH_WRDPRGM_COMPLETE,
N//!         - \b FLASH_POSTVERIFY_FAILED,
N//!         - \b FLASH_PREVERIFY_FAILED,
N//!         - \b FLASH_BRSTRDCMP_COMPLETE
N//!
N//! \note The interrupt sources vary based on the part in use.
N//! Please consult the data sheet for the part you are using to determine
N//! which interrupt sources are available.
N//
N//*****************************************************************************
Nextern uint32_t FlashCtl_getInterruptStatus(void);
N
N//*****************************************************************************
N//
N//! Clears flash system interrupt sources.
N//!
N//! \param flags is a bit mask of the interrupt sources to be cleared.  Must
N//! be a logical OR of:
N//!         - \b FLASH_PROGRAM_ERROR,
N//!         - \b FLASH_BENCHMARK_INT,
N//!         - \b FLASH_ERASE_COMPLETE,
N//!         - \b FLASH_BRSTPRGM_COMPLETE,
N//!         - \b FLASH_WRDPRGM_COMPLETE,
N//!         - \b FLASH_POSTVERIFY_FAILED,
N//!         - \b FLASH_PREVERIFY_FAILED,
N//!         - \b FLASH_BRSTRDCMP_COMPLETE
N//!
N//! The specified flash system interrupt sources are cleared, so that they no
N//! longer assert.  This function must be called in the interrupt handler to
N//! keep it from being called again immediately upon exit.
N//!
N//! \note Because there is a write buffer in the Cortex-M processor, it may
N//! take several clock cycles before the interrupt source is actually cleared.
N//! Therefore, it is recommended that the interrupt source be cleared early in
N//! the interrupt handler (as opposed to the very last action) to avoid
N//! returning from the interrupt handler before the interrupt source is
N//! actually cleared.  Failure to do so may result in the interrupt handler
N//! being immediately reentered (because the interrupt controller still sees
N//! the interrupt source asserted).
N//!
N//! \note The interrupt sources vary based on the part in use.
N//! Please consult the data sheet for the part you are using to determine
N//! which interrupt sources are available.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void FlashCtl_clearInterruptFlag(uint32_t flags);
N
N//*****************************************************************************
N//
N//! Registers an interrupt handler for flash clock system interrupt.
N//!
N//! \param intHandler is a pointer to the function to be called when the clock
N//! system interrupt occurs.
N//!
N//! This function registers the handler to be called when a clock system
N//! interrupt occurs. This function enables the global interrupt in the
N//! interrupt controller; specific flash controller interrupts must be enabled
N//! via FlashCtl_enableInterrupt().  It is the interrupt handler's
N//! responsibility to clear the interrupt source via
N//! FlashCtl_clearInterruptFlag().
N//!
N//! \sa Interrupt_registerInterrupt() for important information about
N//! registering interrupt handlers.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void FlashCtl_registerInterrupt(void (*intHandler)(void));
N
N//*****************************************************************************
N//
N//! Unregisters the interrupt handler for the flash system.
N//!
N//! This function unregisters the handler to be called when a clock system
N//! interrupt occurs.  This function also masks off the interrupt in the
N//! interrupt controller so that the interrupt handler no longer is called.
N//!
N//! \sa Interrupt_registerInterrupt() for important information about
N//! registering interrupt handlers.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void FlashCtl_unregisterInterrupt(void);
N
N
N//*****************************************************************************
N//
N//! Initiates a sector erase of MAIN or INFO flash memory. Note that this 
N//! function simply initaites the sector erase, but does no verification
N//! which is required by the flash controller. The user must manually set
N//! and enable interrupts on the flash controller to fire on erase completion
N//! and then use the FlashCtl_verifyMemory function to verify that the sector
N//! was actually erased
N//!
N//! \param addr The start of the sector to erase. Note that with flash,
N//!         the minimum allowed size that can be erased is a flash sector
N//!         (which is 4KB on the MSP432 family). If an address is provided to
N//!         this function which is not on a 4KB boundary, the entire sector
N//!         will still be erased.
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void FlashCtl_initiateSectorErase(uint32_t addr);
N
N
N/* The following functions are advanced functions that are used by the flash
N * driver to remask a failed bit in the event of a post or pre verification
N * failure. They are meant to be advanced functions and should not be used
N * by the majority of users (unless you are writing your own flash driver).
N */
Nextern uint8_t __FlashCtl_remaskData8Post(uint8_t data, uint32_t addr);
Nextern uint8_t __FlashCtl_remaskData8Pre(uint8_t data, uint32_t addr);
Nextern uint32_t __FlashCtl_remaskData32Post(uint32_t data, uint32_t addr);
Nextern uint32_t __FlashCtl_remaskData32Pre(uint32_t data, uint32_t addr);
Nextern void __FlashCtl_remaskBurstDataPost(uint32_t addr, uint32_t size);
Nextern void __FlashCtl_remaskBurstDataPre(uint32_t addr, uint32_t size);
N
N//*****************************************************************************
N//
N// Mark the end of the C bindings section for C++ compilers.
N//
N//*****************************************************************************
N#ifdef __cplusplus
N}
N#endif
N
N//*****************************************************************************
N//
N// Close the Doxygen group.
N//! @}
N//
N//*****************************************************************************
N
N#endif // __FLASH_H__
L 49 "C:/ti/msp432_driverlib_3_21_00_05/driverlib/MSP432P4xx/driverlib.h" 2
N#include "fpu.h"
L 1 "C:\ti\msp432_driverlib_3_21_00_05\driverlib\MSP432P4xx\fpu.h" 1
N/*
N * -------------------------------------------
N *    MSP432 DriverLib - v3_21_00_05 
N * -------------------------------------------
N *
N * --COPYRIGHT--,BSD,BSD
N * Copyright (c) 2016, Texas Instruments Incorporated
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N *
N * *  Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N *
N * *  Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * *  Neither the name of Texas Instruments Incorporated nor the names of
N *    its contributors may be used to endorse or promote products derived
N *    from this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
N * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
N * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
N * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
N * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
N * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
N * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
N * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
N * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * --/COPYRIGHT--*/
N#ifndef __FPU_H__
N#define __FPU_H__
N
N//*****************************************************************************
N//
N//!
N//! \addtogroup fpu_api
N//! @{
N//
N//*****************************************************************************
N
N//*****************************************************************************
N//
N// If building with a C++ compiler, make all of the definitions in this header
N// have a C binding.
N//
N//*****************************************************************************
N#ifdef __cplusplus
Nextern "C"
N{
N#endif
N
N#include <stdint.h>
N#include <msp.h>
N
N//*****************************************************************************
N//
N// Values that can be passed to FPUHalfPrecisionSet as the mode parameter.
N//
N//*****************************************************************************
N#define FPU_HALF_IEEE           0x00000000
N#define FPU_HALF_ALTERNATE      0x04000000
N
N//*****************************************************************************
N//
N// Values that can be passed to FPU_setNaNMode as the mode parameter.
N//
N//*****************************************************************************
N#define FPU_NAN_PROPAGATE       0x00000000
N#define FPU_NAN_DEFAULT         0x02000000
N
N//*****************************************************************************
N//
N// Values that can be passed to FPU_setFlushToZeroMode as the mode parameter.
N//
N//*****************************************************************************
N#define FPU_FLUSH_TO_ZERO_DIS   0x00000000
N#define FPU_FLUSH_TO_ZERO_EN    0x01000000
N
N//*****************************************************************************
N//
N// Values that can be passed to FPU_setRoundingMode as the mode parameter.
N//
N//*****************************************************************************
N#define FPU_ROUND_NEAREST       0x00000000
N#define FPU_ROUND_POS_INF       0x00400000
N#define FPU_ROUND_NEG_INF       0x00800000
N#define FPU_ROUND_ZERO          0x00c00000
N
N//*****************************************************************************
N//
N//! Enables the floating-point unit.
N//!
N//! This function enables the floating-point unit, allowing the floating-point
N//! instructions to be executed.  This function must be called prior to
N//! performing any hardware floating-point operations; failure to do so results
N//! in a NOCP usage fault.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void FPU_enableModule(void);
N
N//*****************************************************************************
N//
N//! Disables the floating-point unit.
N//!
N//! This function disables the floating-point unit, preventing floating-point
N//! instructions from executing (generating a NOCP usage fault instead).
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void FPU_disableModule(void);
N
N//*****************************************************************************
N//
N//! Enables the stacking of floating-point registers.
N//!
N//! This function enables the stacking of floating-point registers s0-s15 when
N//! an interrupt is handled.  When enabled, space is reserved on the stack for
N//! the floating-point context and the floating-point state is saved into this
N//! stack space.  Upon return from the interrupt, the floating-point context is
N//! restored.
N//!
N//! If the floating-point registers are not stacked, floating-point
N//! instructions cannot be safely executed in an interrupt handler because the
N//! values of s0-s15 are not likely to be preserved for the interrupted code.
N//! On the other hand, stacking the floating-point registers increases the
N//! stacking operation from 8 words to 26 words, also increasing the interrupt
N//! response latency.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void FPU_enableStacking(void);
N
N//*****************************************************************************
N//
N//! Enables the lazy stacking of floating-point registers.
N//!
N//! This function enables the lazy stacking of floating-point registers s0-s15
N//! when an interrupt is handled.  When lazy stacking is enabled, space is
N//! reserved on the stack for the floating-point context, but the
N//! floating-point state is not saved.  If a floating-point instruction is
N//! executed from within the interrupt context, the floating-point context is
N//! first saved into the space reserved on the stack.  On completion of the
N//! interrupt handler, the floating-point context is only restored if it was
N//! saved (as the result of executing a floating-point instruction).
N//!
N//! This method provides a compromise between fast interrupt response (because
N//! the floating-point state is not saved on interrupt entry) and the ability
N//! to use floating-point in interrupt handlers (because the floating-point
N//! state is saved if floating-point instructions are used).
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void FPU_enableLazyStacking(void);
N
N//*****************************************************************************
N//
N//! Disables the stacking of floating-point registers.
N//!
N//! This function disables the stacking of floating-point registers s0-s15 when
N//! an interrupt is handled.  When floating-point context stacking is disabled,
N//! floating-point operations performed in an interrupt handler destroy the
N//! floating-point context of the main thread of execution.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void FPU_disableStacking(void);
N
N//*****************************************************************************
N//
N//! Selects the format of half-precision floating-point values.
N//!
N//! \param mode is the format for half-precision floating-point value, which
N//! is either \b FPU_HALF_IEEE or \b FPU_HALF_ALTERNATE.
N//!
N//! This function selects between the IEEE half-precision floating-point
N//! representation and the Cortex-M processor alternative representation.  The
N//! alternative representation has a larger range but does not have a way to
N//! encode infinity (positive or negative) or NaN (quiet or signalling).  The
N//! default setting is the IEEE format.
N//!
N//! \note Unless this function is called prior to executing any floating-point
N//! instructions, the default mode is used.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void FPU_setHalfPrecisionMode(uint32_t mode);
N
N//*****************************************************************************
N//
N//! Selects the NaN mode.
N//!
N//! \param mode is the mode for NaN results; which is 
N//! either \b FPU_NAN_PROPAGATE or \b FPU_NAN_DEFAULT.
N//!
N//! This function selects the handling of NaN results during floating-point
N//! computations.  NaNs can either propagate (the default), or they can return
N//! the default NaN.
N//!
N//! \note Unless this function is called prior to executing any floating-point
N//! instructions, the default mode is used.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void FPU_setNaNMode(uint32_t mode);
N
N//*****************************************************************************
N//
N//! Selects the flush-to-zero mode.
N//!
N//! \param mode is the flush-to-zero mode; which is either
N//! \b FPU_FLUSH_TO_ZERO_DIS or \b FPU_FLUSH_TO_ZERO_EN.
N//!
N//! This function enables or disables the flush-to-zero mode of the
N//! floating-point unit.  When disabled (the default), the floating-point unit
N//! is fully IEEE compliant.  When enabled, values close to zero are treated as
N//! zero, greatly improving the execution speed at the expense of some accuracy
N//! (as well as IEEE compliance).
N//!
N//! \note Unless this function is called prior to executing any floating-point
N//! instructions, the default mode is used.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void FPU_setFlushToZeroMode(uint32_t mode);
N
N//*****************************************************************************
N//
N//! Selects the rounding mode for floating-point results.
N//!
N//! \param mode is the rounding mode.
N//!
N//! This function selects the rounding mode for floating-point results.  After
N//! a floating-point operation, the result is rounded toward the specified
N//! value.  The default mode is \b FPU_ROUND_NEAREST.
N//!
N//! The following rounding modes are available (as specified by \e mode):
N//!
N//! - \b FPU_ROUND_NEAREST - round toward the nearest value
N//! - \b FPU_ROUND_POS_INF - round toward positive infinity
N//! - \b FPU_ROUND_NEG_INF - round toward negative infinity
N//! - \b FPU_ROUND_ZERO - round toward zero
N//!
N//! \note Unless this function is called prior to executing any floating-point
N//! instructions, the default mode is used.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void FPU_setRoundingMode(uint32_t mode);
N
N//*****************************************************************************
N//
N// Mark the end of the C bindings section for C++ compilers.
N//
N//*****************************************************************************
N#ifdef __cplusplus
N}
N#endif
N
N
N//*****************************************************************************
N//
N// Close the Doxygen group.
N//! @}
N//
N//*****************************************************************************
N
N
N#endif // __FPU_H__
L 50 "C:/ti/msp432_driverlib_3_21_00_05/driverlib/MSP432P4xx/driverlib.h" 2
N#include "gpio.h"
L 1 "C:\ti\msp432_driverlib_3_21_00_05\driverlib\MSP432P4xx\gpio.h" 1
N/*
N * -------------------------------------------
N *    MSP432 DriverLib - v3_21_00_05 
N * -------------------------------------------
N *
N * --COPYRIGHT--,BSD,BSD
N * Copyright (c) 2016, Texas Instruments Incorporated
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N *
N * *  Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N *
N * *  Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * *  Neither the name of Texas Instruments Incorporated nor the names of
N *    its contributors may be used to endorse or promote products derived
N *    from this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
N * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
N * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
N * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
N * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
N * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
N * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
N * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
N * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * --/COPYRIGHT--*/
N#ifndef __GPIO_H__
N#define __GPIO_H__
N
N//*****************************************************************************
N//
N//! \addtogroup gpio_api
N//! @{
N//
N//*****************************************************************************
N
N//*****************************************************************************
N//
N// If building with a C++ compiler, make all of the definitions in this header
N// have a C binding.
N//
N//*****************************************************************************
N#ifdef __cplusplus
Nextern "C"
N{
N#endif
N
N#include <msp.h>
N#include <stdint.h>
N
N#define GPIO_PORT_P1                                                          1
N#define GPIO_PORT_P2                                                          2
N#define GPIO_PORT_P3                                                          3
N#define GPIO_PORT_P4                                                          4
N#define GPIO_PORT_P5                                                          5
N#define GPIO_PORT_P6                                                          6
N#define GPIO_PORT_P7                                                          7
N#define GPIO_PORT_P8                                                          8
N#define GPIO_PORT_P9                                                          9
N#define GPIO_PORT_P10                                                         10
N#define GPIO_PORT_PA                                                           1
N#define GPIO_PORT_PB                                                           3
N#define GPIO_PORT_PC                                                           5
N#define GPIO_PORT_PD                                                           7
N#define GPIO_PORT_PE                                                           9
N#define GPIO_PORT_PJ                                                          11
N
N 
N#define GPIO_PIN0                                                      (0x0001)
N#define GPIO_PIN1                                                      (0x0002)
N#define GPIO_PIN2                                                      (0x0004)
N#define GPIO_PIN3                                                      (0x0008)
N#define GPIO_PIN4                                                      (0x0010)
N#define GPIO_PIN5                                                      (0x0020)
N#define GPIO_PIN6                                                      (0x0040)
N#define GPIO_PIN7                                                      (0x0080)
N#define GPIO_PIN8                                                      (0x0100)
N#define GPIO_PIN9                                                      (0x0200)
N#define GPIO_PIN10                                                     (0x0400)
N#define GPIO_PIN11                                                     (0x0800)
N#define GPIO_PIN12                                                     (0x1000)
N#define GPIO_PIN13                                                     (0x2000)
N#define GPIO_PIN14                                                     (0x4000)
N#define GPIO_PIN15                                                     (0x8000)
N#define PIN_ALL8                                                       (0xFF)
N#define PIN_ALL16                                                      (0xFFFF)
N
N#define GPIO_PRIMARY_MODULE_FUNCTION                                     (0x01)
N#define GPIO_SECONDARY_MODULE_FUNCTION                                   (0x02)
N#define GPIO_TERTIARY_MODULE_FUNCTION                                     (0x03)
N
N#define GPIO_HIGH_TO_LOW_TRANSITION                                      (0x01)
N#define GPIO_LOW_TO_HIGH_TRANSITION                                      (0x00)
N
N#define GPIO_INPUT_PIN_HIGH                                              (0x01)
N#define GPIO_INPUT_PIN_LOW                                               (0x00)
N
N//*****************************************************************************
N//
N// Prototypes for the APIs.
N//
N//*****************************************************************************
N
N//*****************************************************************************
N//
N//! \brief This function configures the selected Pin as output pin
N//!
N//! This function selected pins on a selected port as output pins.
N//!
N//! \param selectedPort is the selected port.
N//!        Valid values are:
N//!        - \b GPIO_PORT_P1
N//!        - \b GPIO_PORT_P2
N//!        - \b GPIO_PORT_P3
N//!        - \b GPIO_PORT_P4
N//!        - \b GPIO_PORT_P5
N//!        - \b GPIO_PORT_P6
N//!        - \b GPIO_PORT_P7
N//!        - \b GPIO_PORT_P8
N//!        - \b GPIO_PORT_P9
N//!        - \b GPIO_PORT_P10
N//!        - \b GPIO_PORT_P11
N//!        - \b GPIO_PORT_PJ
N//! \param selectedPins is the specified pin in the selected port.
N//!        Mask value is the logical OR of any of the following:
N//!        - \b GPIO_PIN0
N//!        - \b GPIO_PIN1
N//!        - \b GPIO_PIN2
N//!        - \b GPIO_PIN3
N//!        - \b GPIO_PIN4
N//!        - \b GPIO_PIN5
N//!        - \b GPIO_PIN6
N//!        - \b GPIO_PIN7
N//!        - \b GPIO_PIN8
N//!        - \b GPIO_PIN9
N//!        - \b GPIO_PIN10
N//!        - \b GPIO_PIN11
N//!        - \b GPIO_PIN12
N//!        - \b GPIO_PIN13
N//!        - \b GPIO_PIN14
N//!        - \b GPIO_PIN15
N//!
N//! Modified bits of \b PxDIR register and bits of \b PxSEL register.
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void GPIO_setAsOutputPin(uint_fast8_t selectedPort,
N        uint_fast16_t selectedPins);
N
N//*****************************************************************************
N//
N//! \brief This function configures the selected Pin as input pin
N//!
N//! This function selected pins on a selected port as input pins.
N//!
N//! \param selectedPort is the selected port.
N//!        Valid values are:
N//!        - \b GPIO_PORT_P1
N//!        - \b GPIO_PORT_P2
N//!        - \b GPIO_PORT_P3
N//!        - \b GPIO_PORT_P4
N//!        - \b GPIO_PORT_P5
N//!        - \b GPIO_PORT_P6
N//!        - \b GPIO_PORT_P7
N//!        - \b GPIO_PORT_P8
N//!        - \b GPIO_PORT_P9
N//!        - \b GPIO_PORT_P10
N//!        - \b GPIO_PORT_P11
N//!        - \b GPIO_PORT_PJ
N//! \param selectedPins is the specified pin in the selected port.
N//!        Mask value is the logical OR of any of the following:
N//!        - \b GPIO_PIN0
N//!        - \b GPIO_PIN1
N//!        - \b GPIO_PIN2
N//!        - \b GPIO_PIN3
N//!        - \b GPIO_PIN4
N//!        - \b GPIO_PIN5
N//!        - \b GPIO_PIN6
N//!        - \b GPIO_PIN7
N//!        - \b GPIO_PIN8
N//!        - \b GPIO_PIN9
N//!        - \b GPIO_PIN10
N//!        - \b GPIO_PIN11
N//!        - \b GPIO_PIN12
N//!        - \b GPIO_PIN13
N//!        - \b GPIO_PIN14
N//!        - \b GPIO_PIN15
N//!
N//! Modified bits of \b PxDIR register, bits of \b PxREN register and bits of
N//! \b PxSEL register.
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void GPIO_setAsInputPin(uint_fast8_t selectedPort,
N        uint_fast16_t selectedPins);
N
N//*****************************************************************************
N//
N//! \brief This function configures the peripheral module function in the
N//! output direction for the selected pin for either primary, secondary or
N//! ternary module function modes
N//!
N//! This function configures the peripheral module function in the output
N//! direction for the selected pin for either primary, secondary or ternary
N//! module function modes. Accepted values for mode are
N//! GPIO_PRIMARY_MODULE_FUNCTION, GPIO_SECONDARY_MODULE_FUNCTION, and
N//! GPIO_TERTIARY_MODULE_FUNCTION
N//!
N//! \param selectedPort is the selected port.
N//!        Valid values are:
N//!        - \b GPIO_PORT_P1
N//!        - \b GPIO_PORT_P2
N//!        - \b GPIO_PORT_P3
N//!        - \b GPIO_PORT_P4
N//!        - \b GPIO_PORT_P5
N//!        - \b GPIO_PORT_P6
N//!        - \b GPIO_PORT_P7
N//!        - \b GPIO_PORT_P8
N//!        - \b GPIO_PORT_P9
N//!        - \b GPIO_PORT_P10
N//!        - \b GPIO_PORT_P11
N//!        - \b GPIO_PORT_PJ
N//! \param selectedPins is the specified pin in the selected port.
N//!        Mask value is the logical OR of any of the following:
N//!        - \b GPIO_PIN0
N//!        - \b GPIO_PIN1
N//!        - \b GPIO_PIN2
N//!        - \b GPIO_PIN3
N//!        - \b GPIO_PIN4
N//!        - \b GPIO_PIN5
N//!        - \b GPIO_PIN6
N//!        - \b GPIO_PIN7
N//!        - \b GPIO_PIN8
N//!        - \b GPIO_PIN9
N//!        - \b GPIO_PIN10
N//!        - \b GPIO_PIN11
N//!        - \b GPIO_PIN12
N//!        - \b GPIO_PIN13
N//!        - \b GPIO_PIN14
N//!        - \b GPIO_PIN15
N//! \param mode is the specified mode that the pin should be configured for the
N//!        module function.
N//!        Valid values are:
N//!        - \b GPIO_PRIMARY_MODULE_FUNCTION
N//!        - \b GPIO_SECONDARY_MODULE_FUNCTION
N//!        - \b GPIO_TERTIARY_MODULE_FUNCTION
N//!
N//! Modified bits of \b PxDIR register and bits of \b PxSEL register.
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void GPIO_setAsPeripheralModuleFunctionOutputPin(
N        uint_fast8_t selectedPort, uint_fast16_t selectedPins,
N        uint_fast8_t mode);
N
N//*****************************************************************************
N//
N//! \brief This function configures the peripheral module function in the input
N//! direction for the selected pin for either primary, secondary or ternary
N//! module function modes.
N//!
N//! This function configures the peripheral module function in the input
N//! direction for the selected pin for either primary, secondary or ternary
N//! module function modes. Accepted values for mode are
N//! GPIO_PRIMARY_MODULE_FUNCTION, GPIO_SECONDARY_MODULE_FUNCTION, and
N//! GPIO_TERTIARY_MODULE_FUNCTION
N//!
N//! \param selectedPort is the selected port.
N//!        Valid values are:
N//!        - \b GPIO_PORT_P1
N//!        - \b GPIO_PORT_P2
N//!        - \b GPIO_PORT_P3
N//!        - \b GPIO_PORT_P4
N//!        - \b GPIO_PORT_P5
N//!        - \b GPIO_PORT_P6
N//!        - \b GPIO_PORT_P7
N//!        - \b GPIO_PORT_P8
N//!        - \b GPIO_PORT_P9
N//!        - \b GPIO_PORT_P10
N//!        - \b GPIO_PORT_P11
N//!        - \b GPIO_PORT_PJ
N//! \param selectedPins is the specified pin in the selected port.
N//!        Mask value is the logical OR of any of the following:
N//!        - \b GPIO_PIN0
N//!        - \b GPIO_PIN1
N//!        - \b GPIO_PIN2
N//!        - \b GPIO_PIN3
N//!        - \b GPIO_PIN4
N//!        - \b GPIO_PIN5
N//!        - \b GPIO_PIN6
N//!        - \b GPIO_PIN7
N//!        - \b GPIO_PIN8
N//!        - \b GPIO_PIN9
N//!        - \b GPIO_PIN10
N//!        - \b GPIO_PIN11
N//!        - \b GPIO_PIN12
N//!        - \b GPIO_PIN13
N//!        - \b GPIO_PIN14
N//!        - \b GPIO_PIN15
N//! \param mode is the specified mode that the pin should be configured for the
N//!        module function.
N//!        Valid values are:
N//!        - \b GPIO_PRIMARY_MODULE_FUNCTION
N//!        - \b GPIO_SECONDARY_MODULE_FUNCTION
N//!        - \b GPIO_TERTIARY_MODULE_FUNCTION
N//!
N//! Modified bits of \b PxDIR register and bits of \b PxSEL register.
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void GPIO_setAsPeripheralModuleFunctionInputPin(
N        uint_fast8_t selectedPort, uint_fast16_t selectedPins,
N        uint_fast8_t mode);
N
N//*****************************************************************************
N//
N//! \brief This function sets output HIGH on the selected Pin
N//!
N//! This function sets output HIGH on the selected port's pin.
N//!
N//! \param selectedPort is the selected port.
N//!        Valid values are:
N//!        - \b GPIO_PORT_P1
N//!        - \b GPIO_PORT_P2
N//!        - \b GPIO_PORT_P3
N//!        - \b GPIO_PORT_P4
N//!        - \b GPIO_PORT_P5
N//!        - \b GPIO_PORT_P6
N//!        - \b GPIO_PORT_P7
N//!        - \b GPIO_PORT_P8
N//!        - \b GPIO_PORT_P9
N//!        - \b GPIO_PORT_P10
N//!        - \b GPIO_PORT_P11
N//!        - \b GPIO_PORT_PJ
N//! \param selectedPins is the specified pin in the selected port.
N//!        Mask value is the logical OR of any of the following:
N//!        - \b GPIO_PIN0
N//!        - \b GPIO_PIN1
N//!        - \b GPIO_PIN2
N//!        - \b GPIO_PIN3
N//!        - \b GPIO_PIN4
N//!        - \b GPIO_PIN5
N//!        - \b GPIO_PIN6
N//!        - \b GPIO_PIN7
N//!        - \b GPIO_PIN8
N//!        - \b GPIO_PIN9
N//!        - \b GPIO_PIN10
N//!        - \b GPIO_PIN11
N//!        - \b GPIO_PIN12
N//!        - \b GPIO_PIN13
N//!        - \b GPIO_PIN14
N//!        - \b GPIO_PIN15
N//!
N//! Modified bits of \b PxOUT register.
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void GPIO_setOutputHighOnPin(uint_fast8_t selectedPort,
N        uint_fast16_t selectedPins);
N
N//*****************************************************************************
N//
N//! \brief This function sets output LOW on the selected Pin
N//!
N//! This function sets output LOW on the selected port's pin.
N//!
N//! \param selectedPort is the selected port.
N//!        Valid values are:
N//!        - \b GPIO_PORT_P1
N//!        - \b GPIO_PORT_P2
N//!        - \b GPIO_PORT_P3
N//!        - \b GPIO_PORT_P4
N//!        - \b GPIO_PORT_P5
N//!        - \b GPIO_PORT_P6
N//!        - \b GPIO_PORT_P7
N//!        - \b GPIO_PORT_P8
N//!        - \b GPIO_PORT_P9
N//!        - \b GPIO_PORT_P10
N//!        - \b GPIO_PORT_P11
N//!        - \b GPIO_PORT_PJ
N//! \param selectedPins is the specified pin in the selected port.
N//!        Mask value is the logical OR of any of the following:
N//!        - \b GPIO_PIN0
N//!        - \b GPIO_PIN1
N//!        - \b GPIO_PIN2
N//!        - \b GPIO_PIN3
N//!        - \b GPIO_PIN4
N//!        - \b GPIO_PIN5
N//!        - \b GPIO_PIN6
N//!        - \b GPIO_PIN7
N//!        - \b GPIO_PIN8
N//!        - \b GPIO_PIN9
N//!        - \b GPIO_PIN10
N//!        - \b GPIO_PIN11
N//!        - \b GPIO_PIN12
N//!        - \b GPIO_PIN13
N//!        - \b GPIO_PIN14
N//!        - \b GPIO_PIN15
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void GPIO_setOutputLowOnPin(uint_fast8_t selectedPort,
N        uint_fast16_t selectedPins);
N
N//*****************************************************************************
N//
N//! \brief This function toggles the output on the selected Pin
N//!
N//! This function toggles the output on the selected port's pin.
N//!
N//! \param selectedPort is the selected port.
N//!        Valid values are:
N//!        - \b GPIO_PORT_P1
N//!        - \b GPIO_PORT_P2
N//!        - \b GPIO_PORT_P3
N//!        - \b GPIO_PORT_P4
N//!        - \b GPIO_PORT_P5
N//!        - \b GPIO_PORT_P6
N//!        - \b GPIO_PORT_P7
N//!        - \b GPIO_PORT_P8
N//!        - \b GPIO_PORT_P9
N//!        - \b GPIO_PORT_P10
N//!        - \b GPIO_PORT_P11
N//!        - \b GPIO_PORT_PJ
N//! \param selectedPins is the specified pin in the selected port.
N//!        Mask value is the logical OR of any of the following:
N//!        - \b GPIO_PIN0
N//!        - \b GPIO_PIN1
N//!        - \b GPIO_PIN2
N//!        - \b GPIO_PIN3
N//!        - \b GPIO_PIN4
N//!        - \b GPIO_PIN5
N//!        - \b GPIO_PIN6
N//!        - \b GPIO_PIN7
N//!        - \b GPIO_PIN8
N//!        - \b GPIO_PIN9
N//!        - \b GPIO_PIN10
N//!        - \b GPIO_PIN11
N//!        - \b GPIO_PIN12
N//!        - \b GPIO_PIN13
N//!        - \b GPIO_PIN14
N//!        - \b GPIO_PIN15
N//!
N//! Modified bits of \b PxOUT register.
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void GPIO_toggleOutputOnPin(uint_fast8_t selectedPort,
N        uint_fast16_t selectedPins);
N
N//*****************************************************************************
N//
N//! \brief This function sets the selected Pin in input Mode with Pull Down
N//! resistor
N//!
N//! This function sets the selected Pin in input Mode with Pull Down resistor.
N//!
N//! \param selectedPort is the selected port.
N//!        Valid values are:
N//!        - \b GPIO_PORT_P1
N//!        - \b GPIO_PORT_P2
N//!        - \b GPIO_PORT_P3
N//!        - \b GPIO_PORT_P4
N//!        - \b GPIO_PORT_P5
N//!        - \b GPIO_PORT_P6
N//!        - \b GPIO_PORT_P7
N//!        - \b GPIO_PORT_P8
N//!        - \b GPIO_PORT_P9
N//!        - \b GPIO_PORT_P10
N//!        - \b GPIO_PORT_P11
N//!        - \b GPIO_PORT_PJ
N//! \param selectedPins is the specified pin in the selected port.
N//!        Mask value is the logical OR of any of the following:
N//!        - \b GPIO_PIN0
N//!        - \b GPIO_PIN1
N//!        - \b GPIO_PIN2
N//!        - \b GPIO_PIN3
N//!        - \b GPIO_PIN4
N//!        - \b GPIO_PIN5
N//!        - \b GPIO_PIN6
N//!        - \b GPIO_PIN7
N//!        - \b GPIO_PIN8
N//!        - \b GPIO_PIN9
N//!        - \b GPIO_PIN10
N//!        - \b GPIO_PIN11
N//!        - \b GPIO_PIN12
N//!        - \b GPIO_PIN13
N//!        - \b GPIO_PIN14
N//!        - \b GPIO_PIN15
N//!
N//! Modified bits of \b PxDIR register, bits of \b PxOUT register and bits of
N//! \b PxREN register.
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void GPIO_setAsInputPinWithPullDownResistor(uint_fast8_t selectedPort,
N        uint_fast16_t selectedPins);
N
N//*****************************************************************************
N//
N//! \brief This function sets the selected Pin in input Mode with Pull Up
N//! resistor
N//!
N//! This function sets the selected Pin in input Mode with Pull Up resistor.
N//!
N//! \param selectedPort is the selected port.
N//!        Valid values are:
N//!        - \b GPIO_PORT_P1
N//!        - \b GPIO_PORT_P2
N//!        - \b GPIO_PORT_P3
N//!        - \b GPIO_PORT_P4
N//!        - \b GPIO_PORT_P5
N//!        - \b GPIO_PORT_P6
N//!        - \b GPIO_PORT_P7
N//!        - \b GPIO_PORT_P8
N//!        - \b GPIO_PORT_P9
N//!        - \b GPIO_PORT_P10
N//!        - \b GPIO_PORT_P11
N//!        - \b GPIO_PORT_PJ
N//! \param selectedPins is the specified pin in the selected port.
N//!        Mask value is the logical OR of any of the following:
N//!        - \b GPIO_PIN0
N//!        - \b GPIO_PIN1
N//!        - \b GPIO_PIN2
N//!        - \b GPIO_PIN3
N//!        - \b GPIO_PIN4
N//!        - \b GPIO_PIN5
N//!        - \b GPIO_PIN6
N//!        - \b GPIO_PIN7
N//!        - \b GPIO_PIN8
N//!        - \b GPIO_PIN9
N//!        - \b GPIO_PIN10
N//!        - \b GPIO_PIN11
N//!        - \b GPIO_PIN12
N//!        - \b GPIO_PIN13
N//!        - \b GPIO_PIN14
N//!        - \b GPIO_PIN15
N//!
N//! Modified bits of \b PxDIR register, bits of \b PxOUT register and bits of
N//! \b PxREN register.
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void GPIO_setAsInputPinWithPullUpResistor(uint_fast8_t selectedPort,
N        uint_fast16_t selectedPins);
N
N//*****************************************************************************
N//
N//! \brief This function gets the input value on the selected pin
N//!
N//! This function gets the input value on the selected pin.
N//!
N//! \param selectedPort is the selected port.
N//!        Valid values are:
N//!        - \b GPIO_PORT_P1
N//!        - \b GPIO_PORT_P2
N//!        - \b GPIO_PORT_P3
N//!        - \b GPIO_PORT_P4
N//!        - \b GPIO_PORT_P5
N//!        - \b GPIO_PORT_P6
N//!        - \b GPIO_PORT_P7
N//!        - \b GPIO_PORT_P8
N//!        - \b GPIO_PORT_P9
N//!        - \b GPIO_PORT_P10
N//!        - \b GPIO_PORT_P11
N//!        - \b GPIO_PORT_PJ
N//! \param selectedPins is the specified pin in the selected port.
N//!        Valid values are:
N//!        - \b GPIO_PIN0
N//!        - \b GPIO_PIN1
N//!        - \b GPIO_PIN2
N//!        - \b GPIO_PIN3
N//!        - \b GPIO_PIN4
N//!        - \b GPIO_PIN5
N//!        - \b GPIO_PIN6
N//!        - \b GPIO_PIN7
N//!        - \b GPIO_PIN8
N//!        - \b GPIO_PIN9
N//!        - \b GPIO_PIN10
N//!        - \b GPIO_PIN11
N//!        - \b GPIO_PIN12
N//!        - \b GPIO_PIN13
N//!        - \b GPIO_PIN14
N//!        - \b GPIO_PIN15
N//!
N//! \return One of the following:
N//!         - \b GPIO_INPUT_PIN_HIGH
N//!         - \b GPIO_INPUT_PIN_LOW
N//!         \n indicating the status of the pin
N//
N//*****************************************************************************
Nextern uint8_t GPIO_getInputPinValue(uint_fast8_t selectedPort,
N        uint_fast16_t selectedPins);
N
N//*****************************************************************************
N//
N//! \brief This function enables the port interrupt on the selected pin
N//!
N//! This function enables the port interrupt on the selected pin. Note that
N//! only Port 1,2, A have this capability.
N//!
N//! \param selectedPort is the selected port.
N//!        Valid values are:
N//!        - \b GPIO_PORT_P1
N//!        - \b GPIO_PORT_P2
N//!        - \b GPIO_PORT_PA
N//! \param selectedPins is the specified pin in the selected port.
N//!        Mask value is the logical OR of any of the following:
N//!        - \b GPIO_PIN0
N//!        - \b GPIO_PIN1
N//!        - \b GPIO_PIN2
N//!        - \b GPIO_PIN3
N//!        - \b GPIO_PIN4
N//!        - \b GPIO_PIN5
N//!        - \b GPIO_PIN6
N//!        - \b GPIO_PIN7
N//!        - \b GPIO_PIN8
N//!        - \b GPIO_PIN9
N//!        - \b GPIO_PIN10
N//!        - \b GPIO_PIN11
N//!        - \b GPIO_PIN12
N//!        - \b GPIO_PIN13
N//!        - \b GPIO_PIN14
N//!        - \b GPIO_PIN15
N//!
N//! Modified bits of \b PxIE register.
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void GPIO_enableInterrupt(uint_fast8_t selectedPort,
N        uint_fast16_t selectedPins);
N
N//*****************************************************************************
N//
N//! \brief This function disables the port interrupt on the selected pin
N//!
N//! This function disables the port interrupt on the selected pin. Note that
N//! only Port 1,2, A have this capability.
N//!
N//! \param selectedPort is the selected port.
N//!        Valid values are:
N//!        - \b GPIO_PORT_P1
N//!        - \b GPIO_PORT_P2
N//!        - \b GPIO_PORT_PA
N//! \param selectedPins is the specified pin in the selected port.
N//!        Mask value is the logical OR of any of the following:
N//!        - \b GPIO_PIN0
N//!        - \b GPIO_PIN1
N//!        - \b GPIO_PIN2
N//!        - \b GPIO_PIN3
N//!        - \b GPIO_PIN4
N//!        - \b GPIO_PIN5
N//!        - \b GPIO_PIN6
N//!        - \b GPIO_PIN7
N//!        - \b GPIO_PIN8
N//!        - \b GPIO_PIN9
N//!        - \b GPIO_PIN10
N//!        - \b GPIO_PIN11
N//!        - \b GPIO_PIN12
N//!        - \b GPIO_PIN13
N//!        - \b GPIO_PIN14
N//!        - \b GPIO_PIN15
N//!
N//! Modified bits of \b PxIE register.
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void GPIO_disableInterrupt(uint_fast8_t selectedPort,
N        uint_fast16_t selectedPins);
N
N//*****************************************************************************
N//
N//! \brief This function gets the interrupt status of the selected pin
N//!
N//! This function gets the interrupt status of the selected pin. Note that only
N//! Port 1,2, A have this capability.
N//!
N//! \param selectedPort is the selected port.
N//!        Valid values are:
N//!        - \b GPIO_PORT_P1
N//!        - \b GPIO_PORT_P2
N//!        - \b GPIO_PORT_PA
N//! \param selectedPins is the specified pin in the selected port.
N//!        Mask value is the logical OR of any of the following:
N//!        - \b GPIO_PIN0
N//!        - \b GPIO_PIN1
N//!        - \b GPIO_PIN2
N//!        - \b GPIO_PIN3
N//!        - \b GPIO_PIN4
N//!        - \b GPIO_PIN5
N//!        - \b GPIO_PIN6
N//!        - \b GPIO_PIN7
N//!        - \b GPIO_PIN8
N//!        - \b GPIO_PIN9
N//!        - \b GPIO_PIN10
N//!        - \b GPIO_PIN11
N//!        - \b GPIO_PIN12
N//!        - \b GPIO_PIN13
N//!        - \b GPIO_PIN14
N//!        - \b GPIO_PIN15
N//!
N//! \return Logical OR of any of the following:
N//!         - \b GPIO_PIN0
N//!         - \b GPIO_PIN1
N//!         - \b GPIO_PIN2
N//!         - \b GPIO_PIN3
N//!         - \b GPIO_PIN4
N//!         - \b GPIO_PIN5
N//!         - \b GPIO_PIN6
N//!         - \b GPIO_PIN7
N//!         - \b GPIO_PIN8
N//!         - \b GPIO_PIN9
N//!         - \b GPIO_PIN10
N//!         - \b GPIO_PIN11
N//!         - \b GPIO_PIN12
N//!         - \b GPIO_PIN13
N//!         - \b GPIO_PIN14
N//!         - \b GPIO_PIN15
N//!         \n indicating the interrupt status of the selected pins [Default:
N//!         0]
N//
N//*****************************************************************************
Nextern uint_fast16_t GPIO_getInterruptStatus(uint_fast8_t selectedPort,
N        uint_fast16_t selectedPins);
N
N//*****************************************************************************
N//
N//! \brief This function clears the interrupt flag on the selected pin
N//!
N//! This function clears the interrupt flag on the selected pin. Note that only
N//! Port 1,2,A have this capability.
N//!
N//! \param selectedPort is the selected port.
N//!        Valid values are:
N//!        - \b GPIO_PORT_P1
N//!        - \b GPIO_PORT_P2
N//!        - \b GPIO_PORT_PA
N//! \param selectedPins is the specified pin in the selected port.
N//!        Mask value is the logical OR of any of the following:
N//!        - \b GPIO_PIN0
N//!        - \b GPIO_PIN1
N//!        - \b GPIO_PIN2
N//!        - \b GPIO_PIN3
N//!        - \b GPIO_PIN4
N//!        - \b GPIO_PIN5
N//!        - \b GPIO_PIN6
N//!        - \b GPIO_PIN7
N//!        - \b GPIO_PIN8
N//!        - \b GPIO_PIN9
N//!        - \b GPIO_PIN10
N//!        - \b GPIO_PIN11
N//!        - \b GPIO_PIN12
N//!        - \b GPIO_PIN13
N//!        - \b GPIO_PIN14
N//!        - \b GPIO_PIN15
N//!
N//! Modified bits of \b PxIFG register.
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void GPIO_clearInterruptFlag(uint_fast8_t selectedPort,
N        uint_fast16_t selectedPins);
N
N//*****************************************************************************
N//
N//! \brief This function selects on what edge the port interrupt flag should be
N//! set for a transition
N//!
N//! This function selects on what edge the port interrupt flag should be set
N//! for a transition. Values for edgeSelect should be
N//! GPIO_LOW_TO_HIGH_TRANSITION or GPIO_HIGH_TO_LOW_TRANSITION.
N//!
N//! \param selectedPort is the selected port.
N//!        Valid values are:
N//!        - \b GPIO_PORT_P1
N//!        - \b GPIO_PORT_P2
N//!        - \b GPIO_PORT_P3
N//!        - \b GPIO_PORT_P4
N//!        - \b GPIO_PORT_P5
N//!        - \b GPIO_PORT_P6
N//!        - \b GPIO_PORT_P7
N//!        - \b GPIO_PORT_P8
N//!        - \b GPIO_PORT_P9
N//!        - \b GPIO_PORT_P10
N//!        - \b GPIO_PORT_P11
N//!        - \b GPIO_PORT_PJ
N//! \param selectedPins is the specified pin in the selected port.
N//!        Mask value is the logical OR of any of the following:
N//!        - \b GPIO_PIN0
N//!        - \b GPIO_PIN1
N//!        - \b GPIO_PIN2
N//!        - \b GPIO_PIN3
N//!        - \b GPIO_PIN4
N//!        - \b GPIO_PIN5
N//!        - \b GPIO_PIN6
N//!        - \b GPIO_PIN7
N//!        - \b GPIO_PIN8
N//!        - \b GPIO_PIN9
N//!        - \b GPIO_PIN10
N//!        - \b GPIO_PIN11
N//!        - \b GPIO_PIN12
N//!        - \b GPIO_PIN13
N//!        - \b GPIO_PIN14
N//!        - \b GPIO_PIN15
N//! \param edgeSelect specifies what transition sets the interrupt flag
N//!        Valid values are:
N//!        - \b GPIO_HIGH_TO_LOW_TRANSITION
N//!        - \b GPIO_LOW_TO_HIGH_TRANSITION
N//!
N//! Modified bits of \b PxIES register.
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void GPIO_interruptEdgeSelect(uint_fast8_t selectedPort,
N        uint_fast16_t selectedPins, uint_fast8_t edgeSelect);
N
N//*****************************************************************************
N//
N//! \brief This function gets the interrupt status of the provided PIN and
N//!         masks it with the interrupts that are actually enabled. This is
N//!         useful for inside ISRs where the status of only the enabled
N//!         interrupts needs to be checked.
N//!
N//! \param selectedPort is the selected port.
N//!        Valid values are:
N//!        - \b GPIO_PORT_P1
N//!        - \b GPIO_PORT_P2
N//!        - \b GPIO_PORT_P3
N//!        - \b GPIO_PORT_P4
N//!        - \b GPIO_PORT_P5
N//!        - \b GPIO_PORT_P6
N//!        - \b GPIO_PORT_P7
N//!        - \b GPIO_PORT_P8
N//!        - \b GPIO_PORT_P9
N//!        - \b GPIO_PORT_P10
N//!        - \b GPIO_PORT_P11
N//!        - \b GPIO_PORT_PJ
N//!
N//! \return Logical OR of any of the following:
N//!         - \b GPIO_PIN0
N//!         - \b GPIO_PIN1
N//!         - \b GPIO_PIN2
N//!         - \b GPIO_PIN3
N//!         - \b GPIO_PIN4
N//!         - \b GPIO_PIN5
N//!         - \b GPIO_PIN6
N//!         - \b GPIO_PIN7
N//!         - \b GPIO_PIN8
N//!         - \b GPIO_PIN9
N//!         - \b GPIO_PIN10
N//!         - \b GPIO_PIN11
N//!         - \b GPIO_PIN12
N//!         - \b GPIO_PIN13
N//!         - \b GPIO_PIN14
N//!         - \b GPIO_PIN15,
N//!         - \b PIN_ALL8,
N//!         - \b PIN_ALL16
N//!         \n indicating the interrupt status of the selected pins [Default:
N//!         0]
N//
N//*****************************************************************************
Nextern uint_fast16_t GPIO_getEnabledInterruptStatus(uint_fast8_t selectedPort);
N
N
N//*****************************************************************************
N//
N//! Registers an interrupt handler for the port interrupt.
N//!
N//! \param selectedPort is the port to register the interrupt handler
N//!
N//! \param intHandler is a pointer to the function to be called when the port
N//! interrupt occurs.
N//!
N//! This function registers the handler to be called when a port
N//! interrupt occurs. This function enables the global interrupt in the
N//! interrupt controller; specific GPIO interrupts must be enabled
N//! via GPIO_enableInterrupt().  It is the interrupt handler's responsibility to
N//! clear the interrupt source via GPIO_clearInterruptFlag().
N//!
N//! Clock System can generate interrupts when
N//!
N//! \sa Interrupt_registerInterrupt() for important information about
N//! registering interrupt handlers.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void GPIO_registerInterrupt(uint_fast8_t selectedPort,
N        void (*intHandler)(void));
N
N//*****************************************************************************
N//
N//! Unregisters the interrupt handler for the port.
N//!
N//! \param selectedPort is the port to unregister the interrupt handler
N//!
N//! This function unregisters the handler to be called when a port
N//! interrupt occurs.  This function also masks off the interrupt in the
N//! interrupt controller so that the interrupt handler no longer is called.
N//!
N//! \sa Interrupt_registerInterrupt() for important information about
N//! registering interrupt handlers.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void GPIO_unregisterInterrupt(uint_fast8_t selectedPort);
N
N//*****************************************************************************
N//
N//! This function sets the drive strength to high for the selected port
N//!
N//!
N//! \param selectedPort is the selected port.
N//!             Valid values are:
N//!             - \b GPIO_PORT_P1,
N//!             - \b GPIO_PORT_P2,
N//!             - \b GPIO_PORT_P3,
N//!             - \b GPIO_PORT_P4,
N//!             - \b GPIO_PORT_P5,
N//!             - \b GPIO_PORT_P6,
N//!             - \b GPIO_PORT_P7,
N//!             - \b GPIO_PORT_P8,
N//!             - \b GPIO_PORT_P9,
N//!             - \b GPIO_PORT_P10,
N//!             - \b GPIO_PORT_PJ
N//! \param selectedPins is the specified pin in the selected port.
N//!             Valid values are:
N//!             - \b GPIO_PIN0,
N//!             - \b GPIO_PIN1,
N//!             - \b GPIO_PIN2,
N//!             - \b GPIO_PIN3,
N//!             - \b GPIO_PIN4,
N//!             - \b GPIO_PIN5,
N//!             - \b GPIO_PIN6,
N//!             - \b GPIO_PIN7,
N//!             - \b GPIO_PIN8,
N//!             - \b PIN_ALL8,
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void GPIO_setDriveStrengthHigh(uint_fast8_t selectedPort,
N        uint_fast8_t selectedPins);
N
N//*****************************************************************************
N//
N//! This function sets the drive strength to low for the selected port
N//!
N//!
N//! \param selectedPort is the selected port.
N//!             Valid values are:
N//!             - \b GPIO_PORT_P1,
N//!             - \b GPIO_PORT_P2,
N//!             - \b GPIO_PORT_P3,
N//!             - \b GPIO_PORT_P4,
N//!             - \b GPIO_PORT_P5,
N//!             - \b GPIO_PORT_P6,
N//!             - \b GPIO_PORT_P7,
N//!             - \b GPIO_PORT_P8,
N//!             - \b GPIO_PORT_P9,
N//!             - \b GPIO_PORT_P10,
N//!             - \b GPIO_PORT_PJ
N//! \param selectedPins is the specified pin in the selected port.
N//!             Valid values are:
N//!             - \b GPIO_PIN0,
N//!             - \b GPIO_PIN1,
N//!             - \b GPIO_PIN2,
N//!             - \b GPIO_PIN3,
N//!             - \b GPIO_PIN4,
N//!             - \b GPIO_PIN5,
N//!             - \b GPIO_PIN6,
N//!             - \b GPIO_PIN7,
N//!             - \b GPIO_PIN8,
N//!             - \b PIN_ALL8,
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void GPIO_setDriveStrengthLow(uint_fast8_t selectedPort,
N        uint_fast8_t selectedPins);
N        
N/* Backwards Compatibility Layer */
N#define  GPIO_selectInterruptEdge       GPIO_interruptEdgeSelect
N#define  GPIO_clearInterrupt            GPIO_clearInterruptFlag
N  
N//*****************************************************************************
N//
N// Mark the end of the C bindings section for C++ compilers.
N//
N//*****************************************************************************
N#ifdef __cplusplus
N}
N#endif
N
N//*****************************************************************************
N//
N// Close the Doxygen group.
N//! @}
N//
N//*****************************************************************************
N
N#endif // __GPIO_H__
L 51 "C:/ti/msp432_driverlib_3_21_00_05/driverlib/MSP432P4xx/driverlib.h" 2
N#include "i2c.h"
L 1 "C:\ti\msp432_driverlib_3_21_00_05\driverlib\MSP432P4xx\i2c.h" 1
N/*
N * -------------------------------------------
N *    MSP432 DriverLib - v3_21_00_05 
N * -------------------------------------------
N *
N * --COPYRIGHT--,BSD,BSD
N * Copyright (c) 2016, Texas Instruments Incorporated
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N *
N * *  Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N *
N * *  Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * *  Neither the name of Texas Instruments Incorporated nor the names of
N *    its contributors may be used to endorse or promote products derived
N *    from this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
N * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
N * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
N * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
N * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
N * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
N * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
N * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
N * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * --/COPYRIGHT--*/
N#ifndef I2C_H_
N#define I2C_H_
N
N//*****************************************************************************
N//
N//! \addtogroup i2c_api
N//! @{
N//
N//*****************************************************************************
N
N//*****************************************************************************
N//
N// If building with a C++ compiler, make all of the definitions in this header
N// have a C binding.
N//
N//*****************************************************************************
N#ifdef __cplusplus
Nextern "C"
N{
N#endif
N
N#include <stdint.h>
N#include <stdbool.h>
N#include <msp.h>
N#include "eusci.h"
N
N#define EUSCI_B_I2C_NO_AUTO_STOP                           EUSCI_B_CTLW1_ASTP_0
N#define EUSCI_B_I2C_SET_BYTECOUNT_THRESHOLD_FLAG           EUSCI_B_CTLW1_ASTP_1
N#define EUSCI_B_I2C_SEND_STOP_AUTOMATICALLY_ON_BYTECOUNT_THRESHOLD  \
N                                                           EUSCI_B_CTLW1_ASTP_2
X#define EUSCI_B_I2C_SEND_STOP_AUTOMATICALLY_ON_BYTECOUNT_THRESHOLD                                                             EUSCI_B_CTLW1_ASTP_2
N
N#define EUSCI_B_I2C_SET_DATA_RATE_1MBPS                                 1000000
N#define EUSCI_B_I2C_SET_DATA_RATE_400KBPS                                400000
N#define EUSCI_B_I2C_SET_DATA_RATE_100KBPS                                100000
N
N#define EUSCI_B_I2C_CLOCKSOURCE_ACLK                   EUSCI_B_CTLW0_SSEL__ACLK
N#define EUSCI_B_I2C_CLOCKSOURCE_SMCLK                 EUSCI_B_CTLW0_SSEL__SMCLK
N
N#define EUSCI_B_I2C_OWN_ADDRESS_OFFSET0                                    0x00
N#define EUSCI_B_I2C_OWN_ADDRESS_OFFSET1                                    0x02
N#define EUSCI_B_I2C_OWN_ADDRESS_OFFSET2                                    0x04
N#define EUSCI_B_I2C_OWN_ADDRESS_OFFSET3                                    0x06
N
N#define EUSCI_B_I2C_OWN_ADDRESS_DISABLE                                    0x00
N#define EUSCI_B_I2C_OWN_ADDRESS_ENABLE                      EUSCI_B_I2COA0_OAEN
N
N#define EUSCI_B_I2C_TRANSMIT_MODE                              EUSCI_B_CTLW0_TR
N#define EUSCI_B_I2C_RECEIVE_MODE                                           0x00
N
N#define EUSCI_B_I2C_NAK_INTERRUPT                             EUSCI_B_IE_NACKIE
N#define EUSCI_B_I2C_ARBITRATIONLOST_INTERRUPT                   EUSCI_B_IE_ALIE
N#define EUSCI_B_I2C_STOP_INTERRUPT                             EUSCI_B_IE_STPIE
N#define EUSCI_B_I2C_START_INTERRUPT                            EUSCI_B_IE_STTIE
N#define EUSCI_B_I2C_TRANSMIT_INTERRUPT0                        EUSCI_B_IE_TXIE0
N#define EUSCI_B_I2C_TRANSMIT_INTERRUPT1                        EUSCI_B_IE_TXIE1
N#define EUSCI_B_I2C_TRANSMIT_INTERRUPT2                        EUSCI_B_IE_TXIE2
N#define EUSCI_B_I2C_TRANSMIT_INTERRUPT3                        EUSCI_B_IE_TXIE3
N#define EUSCI_B_I2C_RECEIVE_INTERRUPT0                         EUSCI_B_IE_RXIE0
N#define EUSCI_B_I2C_RECEIVE_INTERRUPT1                         EUSCI_B_IE_RXIE1
N#define EUSCI_B_I2C_RECEIVE_INTERRUPT2                         EUSCI_B_IE_RXIE2
N#define EUSCI_B_I2C_RECEIVE_INTERRUPT3                         EUSCI_B_IE_RXIE3
N#define EUSCI_B_I2C_BIT9_POSITION_INTERRUPT                   EUSCI_B_IE_BIT9IE
N#define EUSCI_B_I2C_CLOCK_LOW_TIMEOUT_INTERRUPT               EUSCI_B_IE_CLTOIE
N#define EUSCI_B_I2C_BYTE_COUNTER_INTERRUPT                    EUSCI_B_IE_BCNTIE
N
N#define EUSCI_B_I2C_BUS_BUSY                                EUSCI_B_STATW_BBUSY
N#define EUSCI_B_I2C_BUS_NOT_BUSY                                           0x00
N
N#define EUSCI_B_I2C_STOP_SEND_COMPLETE                                     0x00
N#define EUSCI_B_I2C_SENDING_STOP                            EUSCI_B_CTLW0_TXSTP
N
N#define EUSCI_B_I2C_START_SEND_COMPLETE                                    0x00
N#define EUSCI_B_I2C_SENDING_START                           EUSCI_B_CTLW0_TXSTT
N
N//*****************************************************************************
N//
N//!     ypedef eUSCI_I2C_MasterConfig
N//! \brief Type definition for \link _eUSCI_I2C_MasterConfig \endlink structure
N//!
N//! \struct _eUSCI_I2C_MasterConfig
N//! \brief Configuration structure for master mode in the \b I2C module. See
N//!          \link I2C_initMaster \endlink for parameter documentation.
N//
N//*****************************************************************************
Ntypedef struct
N{
N    uint_fast8_t selectClockSource;
N    uint32_t i2cClk;
N    uint32_t dataRate;
N    uint_fast8_t byteCounterThreshold;
N    uint_fast8_t autoSTOPGeneration;
N} eUSCI_I2C_MasterConfig;
N
N
N//*****************************************************************************
N//
N//! Initializes the I2C Master block.
N//!
N//! \param moduleInstance is the instance of the eUSCI B (I2C) module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//!  <br>It is important to note that for eUSCI modules, only "B" modules such as
N//!  EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the
N//!  I2C mode.
N//! \param config Configuration structure for I2C master mode
N//!
N//! <hr>
N//! <b>Configuration options for \link eUSCI_I2C_MasterConfig \endlink structure.</b>
N//! <hr>
N//!
N//! \param selectClockSource is the clock source.
N//!         Valid values are
N//!         - \b EUSCI_B_I2C_CLOCKSOURCE_ACLK
N//!         - \b EUSCI_B_I2C_CLOCKSOURCE_SMCLK
N//! \param i2cClk is the rate of the clock supplied to the I2C module
N//!                   (the frequency in Hz of the clock source specified in
N//!                     selectClockSource).
N//! \param dataRate set up for selecting data transfer rate.
N//!         Valid values are
N//!         - \b EUSCI_B_I2C_SET_DATA_RATE_1MBPS
N//!         - \b EUSCI_B_I2C_SET_DATA_RATE_400KBPS
N//!         - \b EUSCI_B_I2C_SET_DATA_RATE_100KBPS
N//! \param byteCounterThreshold sets threshold for automatic STOP or UCSTPIFG
N//! \param autoSTOPGeneration sets up the STOP condition generation.
N//!         Valid values are
N//!         - \b EUSCI_B_I2C_NO_AUTO_STOP
N//!         - \b EUSCI_B_I2C_SET_BYTECOUNT_THRESHOLD_FLAG
N//!         - \b EUSCI_B_I2C_SEND_STOP_AUTOMATICALLY_ON_BYTECOUNT_THRESHOLD
N//!
N//! This function initializes operation of the I2C Master block.  Upon
N//! successful initialization of the I2C block, this function will have set the
N//! bus speed for the master; however I2C module is still disabled till
N//! I2C_enableModule is invoked
N//!
N//! Modified bits are \b UCMST,UCMODE_3,\b UCSYNC of \b UCBxCTL0 register
N//!                   \b UCSSELx, \b UCSWRST, of \b UCBxCTL1 register
N//!                   \b UCBxBR0 and \b UCBxBR1 registers
N//! \return None.
N//
N//*****************************************************************************
Nextern void I2C_initMaster(uint32_t moduleInstance,
N        const eUSCI_I2C_MasterConfig *config);
N
N//*****************************************************************************
N//
N//! Initializes the I2C Slave block.
N//!
N//! \param moduleInstance is the instance of the eUSCI B (I2C) module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//!  <br>It is important to note that for eUSCI modules, only "B" modules such as
N//!  EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the
N//!  I2C mode.
N//!
N//! \param slaveAddress 7-bit or 10-bit slave address 
N//! \param slaveAddressOffset Own address Offset referred to- 'x' value of
N//!     UCBxI2COAx. Valid values are:
N//!                  - \b EUSCI_B_I2C_OWN_ADDRESS_OFFSET0,
N//!                  - \b EUSCI_B_I2C_OWN_ADDRESS_OFFSET1,
N//!                  - \b EUSCI_B_I2C_OWN_ADDRESS_OFFSET2,
N//!                  - \b EUSCI_B_I2C_OWN_ADDRESS_OFFSET3
N//! \param slaveOwnAddressEnable selects if the specified address is enabled
N//!     or disabled. Valid values are:
N//!                     - \b EUSCI_B_I2C_OWN_ADDRESS_DISABLE,
N//!                     - \b EUSCI_B_I2C_OWN_ADDRESS_ENABLE
N//!
N//! This function initializes operation of the I2C as a Slave mode.  Upon
N//! successful initialization of the I2C blocks, this function will have set
N//! the slave address but the I2C module is still disabled till
N//! I2C_enableModule is invoked.
N//!
N//! The parameter slaveAddress is the value that will be compared against the
N//! slave address sent by an I2C master.
N//!
N//! Modified bits are \b UCMODE_3, \b UCSYNC of \b UCBxCTL0 register
N//!                   \b UCSWRST of \b UCBxCTL1 register
N//!                   \b UCBxI2COA register
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void I2C_initSlave(uint32_t moduleInstance, uint_fast16_t slaveAddress,
N        uint_fast8_t slaveAddressOffset, uint32_t slaveOwnAddressEnable);
N
N//*****************************************************************************
N//
N//! Enables the I2C block.
N//!
N//! \param moduleInstance is the instance of the eUSCI B (I2C) module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//!  <br>It is important to note that for eUSCI modules, only "B" modules such as
N//!  EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the
N//!  I2C mode.
N//!
N//! This will enable operation of the I2C block.
N//! Modified bits are \b UCSWRST of \b UCBxCTL1 register.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void I2C_enableModule(uint32_t moduleInstance);
N
N//*****************************************************************************
N//
N//! Disables the I2C block.
N//!
N//! \param moduleInstance is the instance of the eUSCI B (I2C) module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//!  <br>It is important to note that for eUSCI modules, only "B" modules such as
N//!  EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the
N//!  I2C mode.
N//!
N//! This will disable operation of the I2C block.
N//! Modified bits are \b UCSWRST of \b UCBxCTL1 register.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void I2C_disableModule(uint32_t moduleInstance);
N
N//*****************************************************************************
N//
N//! Sets the address that the I2C Master will place on the bus.
N//!
N//! \param moduleInstance is the instance of the eUSCI B (I2C) module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//!  <br>It is important to note that for eUSCI modules, only "B" modules such as
N//!  EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the
N//!  I2C mode.
N//!
N//! \param slaveAddress 7-bit or 10-bit slave address
N//!
N//! This function will set the address that the I2C Master will place on the
N//! bus when initiating a transaction.
N//! Modified register is  \b UCBxI2CSA register
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void I2C_setSlaveAddress(uint32_t moduleInstance,
N        uint_fast16_t slaveAddress);
N
N//*****************************************************************************
N//
N//! Sets the mode of the I2C device
N//!
N//! \param moduleInstance is the instance of the eUSCI B (I2C) module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//!  <br>It is important to note that for eUSCI modules, only "B" modules such as
N//!  EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the
N//!  I2C mode.
N//!
N//! \param mode indicates whether module is in transmit/receive mode
N//!     - \b EUSCI_B_I2C_TRANSMIT_MODE
N//!     - \b EUSCI_B_I2C_RECEIVE_MODE [Default value]
N//!
N//! Modified bits are \b UCTR of \b UCBxCTL1 register
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void I2C_setMode(uint32_t moduleInstance, uint_fast8_t mode);
N
N//*****************************************************************************
N//
N//! \brief Gets the mode of the I2C device
N//!
N//! Current I2C transmit/receive mode.
N//!
N//! \param moduleInstance is the instance of the eUSCI B (I2C) module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//!  <br>It is important to note that for eUSCI modules, only "B" modules such as
N//!  EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the
N//!  I2C mode.
N//!
N//! Modified bits are \b UCTR of \b UCBxCTL1 register.
N//!
N//! \return None
N//!         Return one of the following:
N//!         - \b EUSCI_B_I2C_TRANSMIT_MODE
N//!         - \b EUSCI_B_I2C_RECEIVE_MODE
N//!         \n indicating the current mode
N//
N//*****************************************************************************
Nextern uint_fast8_t I2C_getMode(uint32_t moduleInstance);
N
N//*****************************************************************************
N//
N//! Transmits a byte from the I2C Module.
N//!
N//! \param moduleInstance is the instance of the eUSCI B (I2C) module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//!  <br>It is important to note that for eUSCI modules, only "B" modules such as
N//!  EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the
N//!  I2C mode.
N//!
N//! \param transmitData data to be transmitted from the I2C module
N//!
N//! This function will place the supplied data into I2C transmit data register
N//! to start transmission
N//! Modified register is \b UCBxTXBUF register
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void I2C_slavePutData(uint32_t moduleInstance, uint8_t transmitData);
N
N//*****************************************************************************
N//
N//! Receives a byte that has been sent to the I2C Module.
N//!
N//! \param moduleInstance is the instance of the eUSCI B (I2C) module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//!  <br>It is important to note that for eUSCI modules, only "B" modules such as
N//!  EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the
N//!  I2C mode.
N//!
N//! This function reads a byte of data from the I2C receive data Register.
N//!
N//! \return Returns the byte received from by the I2C module, cast as an
N//! uint8_t.
N//! Modified bit is \b UCBxRXBUF register
N//
N//*****************************************************************************
Nextern uint8_t I2C_slaveGetData(uint32_t moduleInstance);
N
N//*****************************************************************************
N//
N//! Indicates whether or not the I2C bus is busy.
N//!
N//! \param moduleInstance is the instance of the eUSCI B (I2C) module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//!  <br>It is important to note that for eUSCI modules, only "B" modules such as
N//!  EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the
N//!  I2C mode.
N//!
N//!
N//! This function returns an indication of whether or not the I2C bus is
N//! busy.This function checks the status of the bus via UCBBUSY bit in
N//! UCBxSTAT register.
N//!
N//! \return Returns EUSCI_B_I2C_BUS_BUSY if the I2C Master is busy; otherwise,
N//! returns EUSCI_B_I2C_BUS_NOT_BUSY.
N//
N//*****************************************************************************
Nextern uint8_t I2C_isBusBusy(uint32_t moduleInstance);
N
N//*****************************************************************************
N//
N//! Does single byte transmission from Master to Slave
N//!
N//! \param moduleInstance is the instance of the eUSCI B (I2C) module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//!  <br>It is important to note that for eUSCI modules, only "B" modules such as
N//!  EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the
N//!  I2C mode.
N//!
N//! \param txData is the data byte to be transmitted
N//!
N//! This function is used by the Master module to send a single byte.
N//! This function
N//! - Sends START
N//! - Transmits the byte to the Slave
N//! - Sends STOP
N//!
N//! Modified registers are \b UCBxIE, \b UCBxCTL1, \b UCBxIFG, \b UCBxTXBUF,
N//! \b UCBxIE
N//!
N//! \return none
N//
N//*****************************************************************************
Nextern void I2C_masterSendSingleByte(uint32_t moduleInstance, uint8_t txData);
N
N//*****************************************************************************
N//
N//! Does single byte transmission from Master to Slave with timeout
N//!
N//! \param moduleInstance is the instance of the eUSCI B (I2C) module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//!  <br>It is important to note that for eUSCI modules, only "B" modules such as
N//!  EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the
N//!  I2C mode.
N//!
N//! \param txData is the data byte to be transmitted
N//! \param timeout is the amount of time to wait until giving up
N//!
N//! This function is used by the Master module to send a single byte.
N//! This function
N//! - Sends START
N//! - Transmits the byte to the Slave
N//! - Sends STOP
N//!
N//! Modified registers are \b UCBxIE, \b UCBxCTL1, \b UCBxIFG, \b UCBxTXBUF,
N//! \b UCBxIE
N//!
N//! \return 0x01 or 0x00URE of the transmission process.
N//
N//*****************************************************************************
Nextern bool I2C_masterSendSingleByteWithTimeout(uint32_t moduleInstance,
N        uint8_t txData, uint32_t timeout);
N
N//*****************************************************************************
N//
N//! Starts multi-byte transmission from Master to Slave
N//!
N//! \param moduleInstance is the instance of the eUSCI B (I2C) module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//!  <br>It is important to note that for eUSCI modules, only "B" modules such as
N//!  EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the
N//!  I2C mode.
N//!
N//! \param txData is the first data byte to be transmitted
N//!
N//! This function is used by the Master module to send a single byte.
N//! This function
N//! - Sends START
N//! - Transmits the first data byte of a multi-byte transmission to the Slave
N//!
N//! Modified registers are \b UCBxIE, \b UCBxCTL1, \b UCBxIFG, \b UCBxTXBUF,
N//! \b UCBxIE
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void I2C_masterSendMultiByteStart(uint32_t moduleInstance,
N        uint8_t txData);
N
N//*****************************************************************************
N//
N//! Starts multi-byte transmission from Master to Slave with timeout
N//!
N//! \param moduleInstance is the instance of the eUSCI B (I2C) module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//!  <br>It is important to note that for eUSCI modules, only "B" modules such as
N//!  EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the
N//!  I2C mode.
N//!
N//! \param txData is the first data byte to be transmitted
N//! \param timeout is the amount of time to wait until giving up
N//!
N//! This function is used by the Master module to send a single byte.
N//! This function
N//! - Sends START
N//! - Transmits the first data byte of a multi-byte transmission to the Slave
N//!
N//! Modified registers are \b UCBxIE, \b UCBxCTL1, \b UCBxIFG, \b UCBxTXBUF,
N//! \b UCBxIE
N//!
N//! \return 0x01 or 0x00URE of the transmission process.
N//
N//*****************************************************************************
Nextern bool I2C_masterSendMultiByteStartWithTimeout(uint32_t moduleInstance,
N        uint8_t txData, uint32_t timeout);
N
N//*****************************************************************************
N//
N//! Continues multi-byte transmission from Master to Slave
N//!
N//! \param moduleInstance is the instance of the eUSCI B (I2C) module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//!  <br>It is important to note that for eUSCI modules, only "B" modules such as
N//!  EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the
N//!  I2C mode.
N//!
N//! \param txData is the next data byte to be transmitted
N//!
N//! This function is used by the Master module continue each byte of a
N//! multi-byte trasmission. This function
N//! - Transmits each data byte of a multi-byte transmission to the Slave
N//!
N//! Modified registers are \b UCBxTXBUF
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void I2C_masterSendMultiByteNext(uint32_t moduleInstance,
N        uint8_t txData);
N
N//*****************************************************************************
N//
N//! Continues multi-byte transmission from Master to Slave with timeout
N//!
N//! \param moduleInstance is the instance of the eUSCI B (I2C) module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//!  <br>It is important to note that for eUSCI modules, only "B" modules such as
N//!  EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the
N//!  I2C mode.
N//!
N//! \param txData is the next data byte to be transmitted
N//!
N//! \param timeout is the amount of time to wait until giving up
N//!
N//! This function is used by the Master module continue each byte of a
N//! multi-byte transmission. This function
N//! - Transmits each data byte of a multi-byte transmission to the Slave
N//!
N//! Modified registers are \b UCBxTXBUF
N//!
N//! \return 0x01 or 0x00URE of the transmission process.
N//
N//*****************************************************************************
Nextern bool I2C_masterSendMultiByteNextWithTimeout(uint32_t moduleInstance,
N        uint8_t txData, uint32_t timeout);
N
N//*****************************************************************************
N//
N//! Finishes multi-byte transmission from Master to Slave
N//!
N//! \param moduleInstance is the instance of the eUSCI B (I2C) module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//!  <br>It is important to note that for eUSCI modules, only "B" modules such as
N//!  EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the
N//!  I2C mode.
N//!
N//! \param txData is the last data byte to be transmitted in a multi-byte
N//! transmsission
N//!
N//! This function is used by the Master module to send the last byte and STOP.
N//! This function
N//! - Transmits the last data byte of a multi-byte transmission to the Slave
N//! - Sends STOP
N//!
N//! Modified registers are \b UCBxTXBUF and \b UCBxCTL1.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void I2C_masterSendMultiByteFinish(uint32_t moduleInstance,
N        uint8_t txData);
N
N//*****************************************************************************
N//
N//! Finishes multi-byte transmission from Master to Slave with timeout
N//!
N//! \param moduleInstance is the instance of the eUSCI B (I2C) module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//!  <br>It is important to note that for eUSCI modules, only "B" modules such as
N//!  EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the
N//!  I2C mode.
N//!
N//! \param txData is the last data byte to be transmitted in a multi-byte
N//! transmission
N//! \param timeout is the amount of time to wait until giving up
N//!
N//! This function is used by the Master module to send the last byte and STOP.
N//! This function
N//! - Transmits the last data byte of a multi-byte transmission to the Slave
N//! - Sends STOP
N//!
N//! Modified registers are \b UCBxTXBUF and \b UCBxCTL1.
N//!
N//! \return 0x01 or 0x00URE of the transmission process.
N//
N//*****************************************************************************
Nextern bool I2C_masterSendMultiByteFinishWithTimeout(uint32_t moduleInstance,
N        uint8_t txData, uint32_t timeout);
N
N//*****************************************************************************
N//
N//! Send STOP byte at the end of a multi-byte transmission from Master to Slave
N//!
N//! \param moduleInstance is the instance of the eUSCI B (I2C) module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//!  <br>It is important to note that for eUSCI modules, only "B" modules such as
N//!  EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the
N//!  I2C mode.
N//!
N//!
N//! This function is used by the Master module send STOP at the end of a
N//! multi-byte transmission
N//!
N//! This function
N//! - Send a STOP after current transmission is complete
N//!
N//! Modified bits are \b UCTXSTP bit of \b UCBxCTL1.
N//! \return None.
N//
N//*****************************************************************************
Nextern void I2C_masterSendMultiByteStop(uint32_t moduleInstance);
N
N//*****************************************************************************
N//
N//! Send STOP byte at the end of a multi-byte transmission from Master to Slave
N//! with timeout
N//!
N//! \param moduleInstance is the instance of the eUSCI B (I2C) module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//!  <br>It is important to note that for eUSCI modules, only "B" modules such as
N//!  EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the
N//!  I2C mode.
N//!
N//! \param timeout is the amount of time to wait until giving up
N//!
N//! This function is used by the Master module send STOP at the end of a
N//! multi-byte transmission
N//!
N//! This function
N//! - Send a STOP after current transmission is complete
N//!
N//! Modified bits are \b UCTXSTP bit of \b UCBxCTL1.
N//! \return 0x01 or 0x00URE of the transmission process.
N//
N//*****************************************************************************
Nextern bool I2C_masterSendMultiByteStopWithTimeout(uint32_t moduleInstance,
N        uint32_t timeout);
N
N//*****************************************************************************
N//
N//! Starts reception at the Master end
N//!
N//! \param moduleInstance is the instance of the eUSCI B (I2C) module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//!  <br>It is important to note that for eUSCI modules, only "B" modules such as
N//!  EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the
N//!  I2C mode.
N//!
N//!
N//! This function is used by the Master module initiate reception of a single
N//! byte. This function
N//! - Sends START
N//!
N//! Modified bits are \b UCTXSTT bit of \b UCBxCTL1.
N//! \return None.
N//
N//*****************************************************************************
Nextern void I2C_masterReceiveStart(uint32_t moduleInstance);
N
N//*****************************************************************************
N//
N//! Starts multi-byte reception at the Master end one byte at a time
N//!
N//! \param moduleInstance is the instance of the eUSCI B (I2C) module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//!  <br>It is important to note that for eUSCI modules, only "B" modules such as
N//!  EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the
N//!  I2C mode.
N//!
N//!
N//! This function is used by the Master module to receive each byte of a
N//! multi-byte reception
N//! This function reads currently received byte
N//!
N//! Modified register is \b UCBxRXBUF.
N//! \return Received byte at Master end.
N//
N//*****************************************************************************
Nextern uint8_t I2C_masterReceiveMultiByteNext(uint32_t moduleInstance);
N
N//*****************************************************************************
N//
N//! Finishes multi-byte reception at the Master end
N//!
N//! \param moduleInstance is the instance of the eUSCI B (I2C) module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//!  <br>It is important to note that for eUSCI modules, only "B" modules such as
N//!  EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the
N//!  I2C mode.
N//!
N//!
N//! This function is used by the Master module to initiate completion of a
N//! multi-byte reception
N//! This function
N//! - Receives the current byte and initiates the STOP from Master to Slave
N//!
N//! Modified bits are \b UCTXSTP bit of \b UCBxCTL1.
N//!
N//! \return Received byte at Master end.
N//
N//*****************************************************************************
Nextern uint8_t I2C_masterReceiveMultiByteFinish(uint32_t moduleInstance);
N
N//*****************************************************************************
N//
N//! Finishes multi-byte reception at the Master end with timeout
N//!
N//! \param moduleInstance is the instance of the eUSCI B (I2C) module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//!  <br>It is important to note that for eUSCI modules, only "B" modules such as
N//!  EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the
N//!  I2C mode.
N//!
N//! \param txData is a pointer to the location to store the received byte at
N//!     master end
N//! \param timeout is the amount of time to wait until giving up
N//!
N//! This function is used by the Master module to initiate completion of a
N//! multi-byte reception
N//! This function
N//! - Receives the current byte and initiates the STOP from Master to Slave
N//!
N//! Modified bits are \b UCTXSTP bit of \b UCBxCTL1.
N//!
N//! \return 0x01 or 0x00URE of the transmission process.
N//
N//*****************************************************************************
Nextern bool I2C_masterReceiveMultiByteFinishWithTimeout(uint32_t moduleInstance,
N        uint8_t *txData, uint32_t timeout);
N
N//*****************************************************************************
N//
N//! Sends the STOP at the end of a multi-byte reception at the Master end
N//!
N//! \param moduleInstance is the instance of the eUSCI B (I2C) module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//!  <br>It is important to note that for eUSCI modules, only "B" modules such as
N//!  EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the
N//!  I2C mode.
N//!
N//!
N//! This function is used by the Master module to initiate STOP
N//!
N//! Modified bits are UCTXSTP bit of UCBxCTL1.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void I2C_masterReceiveMultiByteStop(uint32_t moduleInstance);
N
N//*****************************************************************************
N//
N//! Does single byte reception from the slave
N//!
N//! \param moduleInstance is the instance of the eUSCI B (I2C) module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//!  <br>It is important to note that for eUSCI modules, only "B" modules such as
N//!  EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the
N//!  I2C mode.
N//!
N//! This function is used by the Master module to receive a single byte.
N//! This function:
N//! - Sends START and STOP
N//! - Waits for data reception
N//! - Receives one byte from the Slave
N//!
N//! Modified registers are \b UCBxIE, \b UCBxCTL1, \b UCBxIFG, \b UCBxTXBUF,
N//! \b UCBxIE
N//!
N//! \return The byte that has been received from the slave
N//
N//*****************************************************************************
Nextern uint8_t I2C_masterReceiveSingleByte(uint32_t moduleInstance);
N
N//*****************************************************************************
N//
N//! Receives a byte that has been sent to the I2C Master Module.
N//!
N//! \param moduleInstance is the instance of the eUSCI B (I2C) module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//!  <br>It is important to note that for eUSCI modules, only "B" modules such as
N//!  EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the
N//!  I2C mode.
N//!
N//!
N//! This function reads a byte of data from the I2C receive data Register.
N//!
N//! \return Returns the byte received from by the I2C module, cast as an
N//! uint8_t.
N//
N//*****************************************************************************
Nextern uint8_t I2C_masterReceiveSingle(uint32_t moduleInstance);
N
N//*****************************************************************************
N//
N//! Returns the address of the RX Buffer of the I2C for the DMA module.
N//!
N//! \param moduleInstance is the instance of the eUSCI B (I2C) module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//!  <br>It is important to note that for eUSCI modules, only "B" modules such as
N//!  EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the
N//!  I2C mode.
N//!
N//!
N//! Returns the address of the I2C RX Buffer. This can be used in conjunction
N//! with the DMA to store the received data directly to memory.
N//!
N//! \return NONE
N//
N//*****************************************************************************
Nextern uint32_t I2C_getReceiveBufferAddressForDMA(uint32_t moduleInstance);
N
N//*****************************************************************************
N//
N//! Returns the address of the TX Buffer of the I2C for the DMA module.
N//!
N//! \param moduleInstance is the instance of the eUSCI B (I2C) module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//!  <br>It is important to note that for eUSCI modules, only "B" modules such as
N//!  EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the
N//!  I2C mode.
N//!
N//!
N//! Returns the address of the I2C TX Buffer. This can be used in conjunction
N//! with the DMA to obtain transmitted data directly from memory.
N//!
N//! \return NONE
N//
N//*****************************************************************************
Nextern uint32_t I2C_getTransmitBufferAddressForDMA(uint32_t moduleInstance);
N
N//*****************************************************************************
N//
N//! Indicates whether STOP got sent.
N//!
N//! \param moduleInstance is the instance of the eUSCI B (I2C) module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//!  <br>It is important to note that for eUSCI modules, only "B" modules such as
N//!  EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the
N//!  I2C mode.
N//!
N//!
N//! This function returns an indication of whether or not STOP got sent
N//! This function checks the status of the bus via UCTXSTP bit in
N//! UCBxCTL1 register.
N//!
N//! \return Returns EUSCI_B_I2C_STOP_SEND_COMPLETE if the I2C Master
N//!         finished sending STOP; otherwise, returns EUSCI_B_I2C_SENDING_STOP.
N//
N//*****************************************************************************
Nextern uint8_t I2C_masterIsStopSent(uint32_t moduleInstance);
N
N//*****************************************************************************
N//
N//! Indicates whether Start got sent.
N//!
N//! \param moduleInstance is the instance of the eUSCI B (I2C) module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//!  <br>It is important to note that for eUSCI modules, only "B" modules such as
N//!  EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the
N//!  I2C mode.
N//!
N//!
N//! This function returns an indication of whether or not Start got sent
N//! This function checks the status of the bus via UCTXSTT bit in
N//! UCBxCTL1 register.
N//!
N//! \return Returns true if the START has been sent, false if it is sending
N//
N//*****************************************************************************
Nextern bool I2C_masterIsStartSent(uint32_t moduleInstance);
N
N//*****************************************************************************
N//
N//! This function is used by the Master module to initiate START
N//!
N//! \param moduleInstance is the instance of the eUSCI B (I2C) module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//!  <br>It is important to note that for eUSCI modules, only "B" modules such as
N//!  EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the
N//!  I2C mode.
N//!
N//!
N//! This function is used by the Master module to initiate STOP
N//!
N//! Modified bits are UCTXSTT bit of UCBxCTLW0.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void I2C_masterSendStart(uint32_t moduleInstance);
N
N//*****************************************************************************
N//
N//! Enables Multi Master Mode
N//!
N//! \param moduleInstance is the instance of the eUSCI B (I2C) module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//!  <br>It is important to note that for eUSCI modules, only "B" modules such as
N//!  EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the
N//!  I2C mode.
N//!
N//!
N//! At the end of this function, the I2C module is still disabled till
N//! I2C_enableModule is invoked
N//!
N//! Modified bits are \b UCSWRST of \b OFS_UCBxCTLW0, \b UCMM bit of
N//! \b UCBxCTLW0
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void I2C_enableMultiMasterMode(uint32_t moduleInstance);
N
N//*****************************************************************************
N//
N//! Disables Multi Master Mode
N//!
N//! \param moduleInstance is the instance of the eUSCI B (I2C) module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//!  <br>It is important to note that for eUSCI modules, only "B" modules such as
N//!  EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the
N//!  I2C mode.
N//!
N//!
N//! At the end of this function, the I2C module is still disabled till
N//! I2C_enableModule is invoked
N//!
N//! Modified bits are \b UCSWRST of \b OFS_UCBxCTLW0, \b UCMM bit of
N//! \b UCBxCTLW0
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void I2C_disableMultiMasterMode(uint32_t moduleInstance);
N
N//*****************************************************************************
N//
N//! Enables individual I2C interrupt sources.
N//!
N//! \param moduleInstance is the instance of the eUSCI B (I2C) module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//!  <br>It is important to note that for eUSCI modules, only "B" modules such as
N//!  EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the
N//!  I2C mode.
N//!
N//! \param mask is the bit mask of the interrupt sources to
N//!                          be enabled.
N//!
N//! Enables the indicated I2C interrupt sources.  Only the sources that
N//! are enabled can be reflected to the processor interrupt; disabled sources
N//! have no effect on the processor.
N//!
N//! The mask parameter is the logical OR of any of the following:
N//!
N//! - \b EUSCI_B_I2C_STOP_INTERRUPT - STOP condition interrupt
N//! - \b EUSCI_B_I2C_START_INTERRUPT - START condition interrupt
N//! - \b EUSCI_B_I2C_TRANSMIT_INTERRUPT0 - Transmit interrupt0
N//! - \b EUSCI_B_I2C_TRANSMIT_INTERRUPT1 - Transmit interrupt1
N//! - \b EUSCI_B_I2C_TRANSMIT_INTERRUPT2 - Transmit interrupt2
N//! - \b EUSCI_B_I2C_TRANSMIT_INTERRUPT3 - Transmit interrupt3
N//! - \b EUSCI_B_I2C_RECEIVE_INTERRUPT0 - Receive interrupt0
N//! - \b EUSCI_B_I2C_RECEIVE_INTERRUPT1 - Receive interrupt1
N//! - \b EUSCI_B_I2C_RECEIVE_INTERRUPT2 - Receive interrupt2
N//! - \b EUSCI_B_I2C_RECEIVE_INTERRUPT3 - Receive interrupt3
N//! - \b EUSCI_B_I2C_NAK_INTERRUPT - Not-acknowledge interrupt
N//! - \b EUSCI_B_I2C_ARBITRATIONLOST_INTERRUPT - Arbitration lost interrupt
N//! - \b EUSCI_B_I2C_BIT9_POSITION_INTERRUPT - Bit position 9 interrupt enable
N//! - \b EUSCI_B_I2C_CLOCK_LOW_TIMEOUT_INTERRUPT - Clock low timeout interrupt
N//!                                                 enable
N//! - \b EUSCI_B_I2C_BYTE_COUNTER_INTERRUPT - Byte counter interrupt enable
N//!
N//! Modified registers are UCBxIFG and OFS_UCBxIE.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void I2C_enableInterrupt(uint32_t moduleInstance, uint_fast16_t mask);
N
N//*****************************************************************************
N//
N//! Disables individual I2C interrupt sources.
N//!
N//! \param moduleInstance is the instance of the eUSCI B (I2C) module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//!  <br>It is important to note that for eUSCI modules, only "B" modules such as
N//!  EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the
N//!  I2C mode.
N//!
N//! \param mask is the bit mask of the interrupt sources to be
N//! disabled.
N//!
N//! Disables the indicated I2C interrupt sources.  Only the sources that
N//! are enabled can be reflected to the processor interrupt; disabled sources
N//! have no effect on the processor.
N//!
N//! The mask parameter is the logical OR of any of the following:
N//!
N//! - \b EUSCI_B_I2C_STOP_INTERRUPT - STOP condition interrupt
N//! - \b EUSCI_B_I2C_START_INTERRUPT - START condition interrupt
N//! - \b EUSCI_B_I2C_TRANSMIT_INTERRUPT0 - Transmit interrupt0
N//! - \b EUSCI_B_I2C_TRANSMIT_INTERRUPT1 - Transmit interrupt1
N//! - \b EUSCI_B_I2C_TRANSMIT_INTERRUPT2 - Transmit interrupt2
N//! - \b EUSCI_B_I2C_TRANSMIT_INTERRUPT3 - Transmit interrupt3
N//! - \b EUSCI_B_I2C_RECEIVE_INTERRUPT0 - Receive interrupt0
N//! - \b EUSCI_B_I2C_RECEIVE_INTERRUPT1 - Receive interrupt1
N//! - \b EUSCI_B_I2C_RECEIVE_INTERRUPT2 - Receive interrupt2
N//! - \b EUSCI_B_I2C_RECEIVE_INTERRUPT3 - Receive interrupt3
N//! - \b EUSCI_B_I2C_NAK_INTERRUPT - Not-acknowledge interrupt
N//! - \b EUSCI_B_I2C_ARBITRATIONLOST_INTERRUPT - Arbitration lost interrupt
N//! - \b EUSCI_B_I2C_BIT9_POSITION_INTERRUPT - Bit position 9 interrupt enable
N//! - \b EUSCI_B_I2C_CLOCK_LOW_TIMEOUT_INTERRUPT - Clock low timeout interrupt
N//!                                                enable
N//! - \b EUSCI_B_I2C_BYTE_COUNTER_INTERRUPT - Byte counter interrupt enable
N//!
N//! Modified register is \b UCBxIE.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void I2C_disableInterrupt(uint32_t moduleInstance, uint_fast16_t mask);
N
N//*****************************************************************************
N//
N//! Clears I2C interrupt sources.
N//!
N//! \param moduleInstance is the instance of the eUSCI B (I2C) module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//!  <br>It is important to note that for eUSCI modules, only "B" modules such as
N//!  EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the
N//!  I2C mode.
N//!
N//! \param mask is a bit mask of the interrupt sources to be cleared.
N//!
N//! The I2C interrupt source is cleared, so that it no longer asserts.
N//! The highest interrupt flag is automatically cleared when an interrupt vector
N//! generator is used.
N//!
N//! The mask parameter has the same definition as the mask
N//! parameter to I2C_enableInterrupt().
N//!
N//! Modified register is \b UCBxIFG.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void I2C_clearInterruptFlag(uint32_t moduleInstance, uint_fast16_t mask);
N
N//*****************************************************************************
N//
N//! Gets the current I2C interrupt status.
N//!
N//! \param moduleInstance is the instance of the eUSCI B (I2C) module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//!  <br>It is important to note that for eUSCI modules, only "B" modules such as
N//!  EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the
N//!  I2C mode.
N//! \param mask is the masked interrupt flag status to be returned.
N//!        Mask value is the logical OR of any of the following:
N//!        - \b EUSCI_B_I2C_NAK_INTERRUPT - Not-acknowledge interrupt
N//!        - \b EUSCI_B_I2C_ARBITRATIONLOST_INTERRUPT - Arbitration lost
N//!           interrupt
N//!        - \b EUSCI_B_I2C_STOP_INTERRUPT - STOP condition interrupt
N//!        - \b EUSCI_B_I2C_START_INTERRUPT - START condition interrupt
N//!        - \b EUSCI_B_I2C_TRANSMIT_INTERRUPT0 - Transmit interrupt0
N//!        - \b EUSCI_B_I2C_TRANSMIT_INTERRUPT1 - Transmit interrupt1
N//!        - \b EUSCI_B_I2C_TRANSMIT_INTERRUPT2 - Transmit interrupt2
N//!        - \b EUSCI_B_I2C_TRANSMIT_INTERRUPT3 - Transmit interrupt3
N//!        - \b EUSCI_B_I2C_RECEIVE_INTERRUPT0 - Receive interrupt0
N//!        - \b EUSCI_B_I2C_RECEIVE_INTERRUPT1 - Receive interrupt1
N//!        - \b EUSCI_B_I2C_RECEIVE_INTERRUPT2 - Receive interrupt2
N//!        - \b EUSCI_B_I2C_RECEIVE_INTERRUPT3 - Receive interrupt3
N//!        - \b EUSCI_B_I2C_BIT9_POSITION_INTERRUPT - Bit position 9 interrupt
N//!        - \b EUSCI_B_I2C_CLOCK_LOW_TIMEOUT_INTERRUPT - Clock low timeout
N//!           interrupt enable
N//!        - \b EUSCI_B_I2C_BYTE_COUNTER_INTERRUPT - Byte counter interrupt
N//!           enable
N//!
N//! \return the masked status of the interrupt flag
N//! - \b EUSCI_B_I2C_STOP_INTERRUPT - STOP condition interrupt
N//! - \b EUSCI_B_I2C_START_INTERRUPT - START condition interrupt
N//! - \b EUSCI_B_I2C_TRANSMIT_INTERRUPT0 - Transmit interrupt0
N//! - \b EUSCI_B_I2C_TRANSMIT_INTERRUPT1 - Transmit interrupt1
N//! - \b EUSCI_B_I2C_TRANSMIT_INTERRUPT2 - Transmit interrupt2
N//! - \b EUSCI_B_I2C_TRANSMIT_INTERRUPT3 - Transmit interrupt3
N//! - \b EUSCI_B_I2C_RECEIVE_INTERRUPT0 - Receive interrupt0
N//! - \b EUSCI_B_I2C_RECEIVE_INTERRUPT1 - Receive interrupt1
N//! - \b EUSCI_B_I2C_RECEIVE_INTERRUPT2 - Receive interrupt2
N//! - \b EUSCI_B_I2C_RECEIVE_INTERRUPT3 - Receive interrupt3
N//! - \b EUSCI_B_I2C_NAK_INTERRUPT - Not-acknowledge interrupt
N//! - \b EUSCI_B_I2C_ARBITRATIONLOST_INTERRUPT - Arbitration lost interrupt
N//! - \b EUSCI_B_I2C_BIT9_POSITION_INTERRUPT - Bit position 9 interrupt enable
N//! - \b EUSCI_B_I2C_CLOCK_LOW_TIMEOUT_INTERRUPT - Clock low timeout interrupt
N//!                                                enable
N//! - \b EUSCI_B_I2C_BYTE_COUNTER_INTERRUPT - Byte counter interrupt enable
N//
N//*****************************************************************************
Nextern uint_fast16_t I2C_getInterruptStatus(uint32_t moduleInstance, uint16_t mask);
N
N//*****************************************************************************
N//
N//! Gets the current I2C interrupt status masked with the enabled interrupts.
N//! This function is useful to call in ISRs to get a list of pending interrupts
N//! that are actually enabled and could have caused the ISR.
N//!
N//! \param moduleInstance is the instance of the eUSCI B (I2C) module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//!  <br>It is important to note that for eUSCI modules, only "B" modules such as
N//!  EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the
N//!  I2C mode.
N//!
N//! \return the masked status of the interrupt flag
N//! - \b EUSCI_B_I2C_STOP_INTERRUPT - STOP condition interrupt
N//! - \b EUSCI_B_I2C_START_INTERRUPT - START condition interrupt
N//! - \b EUSCI_B_I2C_TRANSMIT_INTERRUPT0 - Transmit interrupt0
N//! - \b EUSCI_B_I2C_TRANSMIT_INTERRUPT1 - Transmit interrupt1
N//! - \b EUSCI_B_I2C_TRANSMIT_INTERRUPT2 - Transmit interrupt2
N//! - \b EUSCI_B_I2C_TRANSMIT_INTERRUPT3 - Transmit interrupt3
N//! - \b EUSCI_B_I2C_RECEIVE_INTERRUPT0 - Receive interrupt0
N//! - \b EUSCI_B_I2C_RECEIVE_INTERRUPT1 - Receive interrupt1
N//! - \b EUSCI_B_I2C_RECEIVE_INTERRUPT2 - Receive interrupt2
N//! - \b EUSCI_B_I2C_RECEIVE_INTERRUPT3 - Receive interrupt3
N//! - \b EUSCI_B_I2C_NAK_INTERRUPT - Not-acknowledge interrupt
N//! - \b EUSCI_B_I2C_ARBITRATIONLOST_INTERRUPT - Arbitration lost interrupt
N//! - \b EUSCI_B_I2C_BIT9_POSITION_INTERRUPT - Bit position 9 interrupt enable
N//! - \b EUSCI_B_I2C_CLOCK_LOW_TIMEOUT_INTERRUPT - Clock low timeout interrupt
N//!                                                enable
N//! - \b EUSCI_B_I2C_BYTE_COUNTER_INTERRUPT - Byte counter interrupt enable
N//
N//*****************************************************************************
Nextern uint_fast16_t I2C_getEnabledInterruptStatus(uint32_t moduleInstance);
N
N//*****************************************************************************
N//
N//! Registers an interrupt handler for I2C interrupts.
N//!
N//! \param moduleInstance is the instance of the eUSCI B (I2C) module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//!  <br>It is important to note that for eUSCI modules, only "B" modules such as
N//!  EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the
N//!  I2C mode.
N//!
N//! \param intHandler is a pointer to the function to be called when the
N//! timer capture compare interrupt occurs.
N//!
N//! This function registers the handler to be called when an I2C
N//! interrupt occurs. This function enables the global interrupt in the
N//! interrupt controller; specific I2C interrupts must be enabled
N//! via I2C_enableInterrupt().  It is the interrupt handler's responsibility to
N//! clear the interrupt source via I2C_clearInterruptFlag().
N//!
N//! \sa Interrupt_registerInterrupt() for important information about
N//! registering interrupt handlers.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void I2C_registerInterrupt(uint32_t moduleInstance,
N        void (*intHandler)(void));
N
N//*****************************************************************************
N//
N//! Unregisters the interrupt handler for the timer
N//!
N//! \param moduleInstance is the instance of the eUSCI B (I2C) module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//!  <br>It is important to note that for eUSCI modules, only "B" modules such as
N//!  EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the
N//!  I2C mode.
N//!
N//! This function unregisters the handler to be called when timer
N//! interrupt occurs.  This function also masks off the interrupt in the
N//! interrupt controller so that the interrupt handler no longer is called.
N//!
N//! \sa Interrupt_registerInterrupt() for important information about
N//! registering interrupt handlers.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void I2C_unregisterInterrupt(uint32_t moduleInstance);
N
N
N//*****************************************************************************
N//
N//! This function is used by the slave to send a NAK out over the I2C line
N//!
N//! \param moduleInstance is the instance of the eUSCI B (I2C) module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//!  <br>It is important to note that for eUSCI modules, only "B" modules such as
N//!  EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the
N//!  I2C mode.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void I2C_slaveSendNAK(uint32_t moduleInstance);
N
N/* Backwards Compatibility Layer */
N#define EUSCI_B_I2C_slaveInit I2C_initSlave
N#define EUSCI_B_I2C_enable I2C_enableModule
N#define EUSCI_B_I2C_disable I2C_disableModule
N#define EUSCI_B_I2C_setSlaveAddress I2C_setSlaveAddress
N#define EUSCI_B_I2C_setMode I2C_setMode
N#define EUSCI_B_I2C_getMode I2C_getMode
N#define EUSCI_B_I2C_slaveDataPut I2C_slavePutData
N#define EUSCI_B_I2C_slaveDataGet I2C_slaveGetData
N#define EUSCI_B_I2C_isBusBusy I2C_isBusBusy
N#define EUSCI_B_I2C_masterIsStopSent I2C_masterIsStopSent
N#define EUSCI_B_I2C_masterIsStartSent I2C_masterIsStartSent
N#define EUSCI_B_I2C_enableInterrupt I2C_enableInterrupt
N#define EUSCI_B_I2C_disableInterrupt I2C_disableInterrupt
N#define EUSCI_B_I2C_clearInterruptFlag I2C_clearInterruptFlag
N#define EUSCI_B_I2C_getInterruptStatus  I2C_getEnabledInterruptStatus
N#define EUSCI_B_I2C_masterSendSingleByte I2C_masterSendSingleByte
N#define EUSCI_B_I2C_masterReceiveSingleByte I2C_masterReceiveSingleByte
N#define EUSCI_B_I2C_masterSendSingleByteWithTimeout I2C_masterSendSingleByteWithTimeout
N#define EUSCI_B_I2C_masterMultiByteSendStart I2C_masterSendMultiByteStart
N#define EUSCI_B_I2C_masterMultiByteSendStartWithTimeout I2C_masterSendMultiByteStartWithTimeout
N#define EUSCI_B_I2C_masterMultiByteSendNext I2C_masterSendMultiByteNext
N#define EUSCI_B_I2C_masterMultiByteSendNextWithTimeout I2C_masterSendMultiByteNextWithTimeout
N#define EUSCI_B_I2C_masterMultiByteSendFinish I2C_masterSendMultiByteFinish
N#define EUSCI_B_I2C_masterMultiByteSendFinishWithTimeout I2C_masterSendMultiByteFinishWithTimeout
N#define EUSCI_B_I2C_masterSendStart I2C_masterSendStart
N#define EUSCI_B_I2C_masterMultiByteSendStop I2C_masterSendMultiByteStop
N#define EUSCI_B_I2C_masterMultiByteSendStopWithTimeout I2C_masterSendMultiByteStopWithTimeout
N#define EUSCI_B_I2C_masterReceiveStart I2C_masterReceiveStart
N#define EUSCI_B_I2C_masterMultiByteReceiveNext I2C_masterReceiveMultiByteNext
N#define EUSCI_B_I2C_masterMultiByteReceiveFinish I2C_masterReceiveMultiByteFinish
N#define EUSCI_B_I2C_masterMultiByteReceiveFinishWithTimeout I2C_masterReceiveMultiByteFinishWithTimeout
N#define EUSCI_B_I2C_masterMultiByteReceiveStop I2C_masterReceiveMultiByteStop
N#define EUSCI_B_I2C_enableMultiMasterMode I2C_enableMultiMasterMode
N#define EUSCI_B_I2C_disableMultiMasterMode I2C_disableMultiMasterMode
N#define EUSCI_B_I2C_masterSingleReceive I2C_masterReceiveSingle
N#define EUSCI_B_I2C_getReceiveBufferAddressForDMA I2C_getReceiveBufferAddressForDMA
N#define EUSCI_B_I2C_getTransmitBufferAddressForDMA I2C_getTransmitBufferAddressForDMA
N
N
N//*****************************************************************************
N//
N// Mark the end of the C bindings section for C++ compilers.
N//
N//*****************************************************************************
N#ifdef __cplusplus
N}
N#endif
N
N//*****************************************************************************
N//
N// Close the Doxygen group.
N//! @}
N//
N//*****************************************************************************
N
N#endif /* I2C_H_ */
N
L 52 "C:/ti/msp432_driverlib_3_21_00_05/driverlib/MSP432P4xx/driverlib.h" 2
N#include "interrupt.h"
L 1 "C:\ti\msp432_driverlib_3_21_00_05\driverlib\MSP432P4xx\interrupt.h" 1
N/*
N * -------------------------------------------
N *    MSP432 DriverLib - v3_21_00_05 
N * -------------------------------------------
N *
N * --COPYRIGHT--,BSD,BSD
N * Copyright (c) 2016, Texas Instruments Incorporated
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N *
N * *  Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N *
N * *  Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * *  Neither the name of Texas Instruments Incorporated nor the names of
N *    its contributors may be used to endorse or promote products derived
N *    from this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
N * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
N * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
N * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
N * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
N * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
N * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
N * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
N * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * --/COPYRIGHT--*/
N#ifndef __INTERRUPT_H__
N#define __INTERRUPT_H__
N
N//*****************************************************************************
N//
N//! \addtogroup interrupt_api
N//! @{
N//
N//*****************************************************************************
N
N
N//*****************************************************************************
N//
N// If building with a C++ compiler, make all of the definitions in this header
N// have a C binding.
N//
N//*****************************************************************************
N#ifdef __cplusplus
Nextern "C"
N{
N#endif
N
N#include <stdint.h>
N#include <stdbool.h>
N#include <msp.h>
N
N/******************************************************************************
N* NVIC interrupts                                                             *
N******************************************************************************/
N/* System exceptions */
N#define FAULT_NMI                                       ( 2) /* NMI fault */
N#define FAULT_HARD                                      ( 3) /* Hard fault */
N#define FAULT_MPU                                       ( 4) /* MPU fault */
N#define FAULT_BUS                                       ( 5) /* Bus fault */
N#define FAULT_USAGE                                     ( 6) /* Usage fault */
N#define FAULT_SVCALL                                    (11) /* SVCall */
N#define FAULT_DEBUG                                     (12) /* Debug monitor */
N#define FAULT_PENDSV                                    (14) /* PendSV */
N#define FAULT_SYSTICK                                   (15) /* System Tick */
N
N/* External interrupts */
N#define INT_PSS                                         (16) /* PSS IRQ */
N#define INT_CS                                          (17) /* CS IRQ */
N#define INT_PCM                                         (18) /* PCM IRQ */
N#define INT_WDT_A                                       (19) /* WDT_A IRQ */
N#define INT_FPU                                         (20) /* FPU IRQ */
N#define INT_FLCTL                                       (21) /* FLCTL IRQ */
N#define INT_COMP_E0                                     (22) /* COMP_E0 IRQ */
N#define INT_COMP_E1                                     (23) /* COMP_E1 IRQ */
N#define INT_TA0_0                                       (24) /* TA0_0 IRQ */
N#define INT_TA0_N                                       (25) /* TA0_N IRQ */
N#define INT_TA1_0                                       (26) /* TA1_0 IRQ */
N#define INT_TA1_N                                       (27) /* TA1_N IRQ */
N#define INT_TA2_0                                       (28) /* TA2_0 IRQ */
N#define INT_TA2_N                                       (29) /* TA2_N IRQ */
N#define INT_TA3_0                                       (30) /* TA3_0 IRQ */
N#define INT_TA3_N                                       (31) /* TA3_N IRQ */
N#define INT_EUSCIA0                                     (32) /* EUSCIA0 IRQ */
N#define INT_EUSCIA1                                     (33) /* EUSCIA1 IRQ */
N#define INT_EUSCIA2                                     (34) /* EUSCIA2 IRQ */
N#define INT_EUSCIA3                                     (35) /* EUSCIA3 IRQ */
N#define INT_EUSCIB0                                     (36) /* EUSCIB0 IRQ */
N#define INT_EUSCIB1                                     (37) /* EUSCIB1 IRQ */
N#define INT_EUSCIB2                                     (38) /* EUSCIB2 IRQ */
N#define INT_EUSCIB3                                     (39) /* EUSCIB3 IRQ */
N#define INT_ADC14                                       (40) /* ADC14 IRQ */
N#define INT_T32_INT1                                    (41) /* T32_INT1 IRQ */
N#define INT_T32_INT2                                    (42) /* T32_INT2 IRQ */
N#define INT_T32_INTC                                    (43) /* T32_INTC IRQ */
N#define INT_AES256                                      (44) /* AES256 IRQ */
N#define INT_RTC_C                                       (45) /* RTC_C IRQ */
N#define INT_DMA_ERR                                     (46) /* DMA_ERR IRQ */
N#define INT_DMA_INT3                                    (47) /* DMA_INT3 IRQ */
N#define INT_DMA_INT2                                    (48) /* DMA_INT2 IRQ */
N#define INT_DMA_INT1                                    (49) /* DMA_INT1 IRQ */
N#define INT_DMA_INT0                                    (50) /* DMA_INT0 IRQ */
N#define INT_PORT1                                       (51) /* PORT1 IRQ */
N#define INT_PORT2                                       (52) /* PORT2 IRQ */
N#define INT_PORT3                                       (53) /* PORT3 IRQ */
N#define INT_PORT4                                       (54) /* PORT4 IRQ */
N#define INT_PORT5                                       (55) /* PORT5 IRQ */
N#define INT_PORT6                                       (56) /* PORT6 IRQ */
N
N#define NUM_INTERRUPTS                                  (56)
N//*****************************************************************************
N//
N// Macro to generate an interrupt priority mask based on the number of bits
N// of priority supported by the hardware.
N//
N//*****************************************************************************
N#define INT_PRIORITY_MASK       ((0xFF << (8 - NUM_PRIORITY_BITS)) & 0xFF)
N#define NUM_PRIORITY            8
N
N#define NVIC_APINT_PRIGROUP_M   0x00000700  // Interrupt Priority Grouping
N#define NVIC_APINT_PRIGROUP_7_1 0x00000000  // Priority group 7.1 split
N#define NVIC_APINT_PRIGROUP_6_2 0x00000100  // Priority group 6.2 split
N#define NVIC_APINT_PRIGROUP_5_3 0x00000200  // Priority group 5.3 split
N#define NVIC_APINT_PRIGROUP_4_4 0x00000300  // Priority group 4.4 split
N#define NVIC_APINT_PRIGROUP_3_5 0x00000400  // Priority group 3.5 split
N#define NVIC_APINT_PRIGROUP_2_6 0x00000500  // Priority group 2.6 split
N#define NVIC_APINT_PRIGROUP_1_7 0x00000600  // Priority group 1.7 split
N#define NVIC_APINT_PRIGROUP_0_8 0x00000700  // Priority group 0.8 split
N#define NVIC_SYS_PRI1_R         0xE000ED18  // System Handler Priority 1
N#define NVIC_SYS_PRI2_R         0xE000ED1C  // System Handler Priority 2
N#define NVIC_SYS_PRI3_R         0xE000ED20  // System Handler Priority 3
N#define NVIC_PRI0_R             0xE000E400  // Interrupt 0-3 Priority
N#define NVIC_PRI1_R             0xE000E404  // Interrupt 4-7 Priority
N#define NVIC_PRI2_R             0xE000E408  // Interrupt 8-11 Priority
N#define NVIC_PRI3_R             0xE000E40C  // Interrupt 12-15 Priority
N#define NVIC_PRI4_R             0xE000E410  // Interrupt 16-19 Priority
N#define NVIC_PRI5_R             0xE000E414  // Interrupt 20-23 Priority
N#define NVIC_PRI6_R             0xE000E418  // Interrupt 24-27 Priority
N#define NVIC_PRI7_R             0xE000E41C  // Interrupt 28-31 Priority
N#define NVIC_PRI8_R             0xE000E420  // Interrupt 32-35 Priority
N#define NVIC_PRI9_R             0xE000E424  // Interrupt 36-39 Priority
N#define NVIC_PRI10_R            0xE000E428  // Interrupt 40-43 Priority
N#define NVIC_PRI11_R            0xE000E42C  // Interrupt 44-47 Priority
N#define NVIC_PRI12_R            0xE000E430  // Interrupt 48-51 Priority
N#define NVIC_PRI13_R            0xE000E434  // Interrupt 52-55 Priority
N#define NVIC_PRI14_R            0xE000E438  // Interrupt 56-59 Priority
N#define NVIC_PRI15_R            0xE000E43C  // Interrupt 60-63 Priority
N#define NVIC_EN0_R              0xE000E100  // Interrupt 0-31 Set Enable
N#define NVIC_EN1_R              0xE000E104  // Interrupt 32-54 Set Enable
N#define NVIC_DIS0_R             0xE000E180  // Interrupt 0-31 Clear Enable
N#define NVIC_DIS1_R             0xE000E184  // Interrupt 32-54 Clear Enable
N#define NVIC_PEND0_R            0xE000E200  // Interrupt 0-31 Set Pending
N#define NVIC_PEND1_R            0xE000E204  // Interrupt 32-54 Set Pending
N#define NVIC_UNPEND0_R          0xE000E280  // Interrupt 0-31 Clear Pending
N#define NVIC_UNPEND1_R          0xE000E284  // Interrupt 32-54 Clear Pending
N//*****************************************************************************
N//
N// Prototypes for the APIs.
N//
N//*****************************************************************************
N
N//*****************************************************************************
N//
N//! Enables the processor interrupt.
N//!
N//! This function allows the processor to respond to interrupts.  This function
N//! does not affect the set of interrupts enabled in the interrupt controller;
N//! it just gates the single interrupt from the controller to the processor.
N//!
N//! \return Returns \b true if interrupts were disabled when the function was
N//! called or \b false if they were initially enabled.
N//
N//*****************************************************************************
Nextern bool Interrupt_enableMaster(void);
N
N//*****************************************************************************
N//
N//! Disables the processor interrupt.
N//!
N//! This function prevents the processor from receiving interrupts.  This
N//! function does not affect the set of interrupts enabled in the interrupt
N//! controller; it just gates the single interrupt from the controller to the
N//! processor.
N//!
N//! \return Returns \b true if interrupts were already disabled when the
N//! function was called or \b false if they were initially enabled.
N//
N//*****************************************************************************
Nextern bool Interrupt_disableMaster(void);
N
N//*****************************************************************************
N//
N//! Registers a function to be called when an interrupt occurs.
N//!
N//! \param interruptNumber specifies the interrupt in question.
N//! \param intHandler is a pointer to the function to be called.
N//!
N//! \note The use of this function (directly or indirectly via a peripheral
N//! driver interrupt register function) moves the interrupt vector table from
N//! flash to SRAM.  Therefore, care must be taken when linking the application
N//! to ensure that the SRAM vector table is located at the beginning of SRAM;
N//! otherwise the NVIC does not look in the correct portion of memory for the
N//! vector table (it requires the vector table be on a 1 kB memory alignment).
N//! Normally, the SRAM vector table is so placed via the use of linker scripts.
N//! See the discussion of compile-time versus run-time interrupt handler
N//! registration in the introduction to this chapter.
N//!
N//! \note This function is only used if the customer wants to specify the 
N//!  interrupt handler at run time. In most cases, this is done through means
N//!  of the user setting the ISR function pointer in the startup file. Refer
N//!  Refer to the Module Operation section for more details.
N//!
N//! See \link Interrupt_enableInterrupt \endlink for details about the interrupt
N//! parameter
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void Interrupt_registerInterrupt(uint32_t interruptNumber,
N        void (*intHandler)(void));
N
N//*****************************************************************************
N//
N//! Unregisters the function to be called when an interrupt occurs.
N//!
N//! \param interruptNumber specifies the interrupt in question.
N//!
N//! This function is used to indicate that no handler should be called when the
N//! given interrupt is asserted to the processor.  The interrupt source is
N//! automatically disabled (via Interrupt_disableInterrupt()) if necessary.
N//!
N//! \sa Interrupt_registerInterrupt() for important information about
N//! registering interrupt handlers.
N//!
N//! See \link Interrupt_enableInterrupt \endlink for details about the interrupt
N//! parameter
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void Interrupt_unregisterInterrupt(uint32_t interruptNumber);
N
N//*****************************************************************************
N//
N//! Sets the priority grouping of the interrupt controller.
N//!
N//! \param bits specifies the number of bits of preemptable priority.
N//!
N//! This function specifies the split between preemptable priority levels and
N//! sub-priority levels in the interrupt priority specification.  The range of
N//! the grouping values are dependent upon the hardware implementation; on
N//! the MSP432 family, three bits are available for hardware interrupt
N//! prioritization and therefore priority grouping values of three through
N//! seven have the same effect.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void Interrupt_setPriorityGrouping(uint32_t bits);
N
N//*****************************************************************************
N//
N//! Gets the priority grouping of the interrupt controller.
N//!
N//! This function returns the split between preemptable priority levels and
N//! sub-priority levels in the interrupt priority specification.
N//!
N//! \return The number of bits of preemptable priority.
N//
N//*****************************************************************************
Nextern uint32_t Interrupt_getPriorityGrouping(void);
N
N//*****************************************************************************
N//
N//! Sets the priority of an interrupt.
N//!
N//! \param interruptNumber specifies the interrupt in question.
N//! \param priority specifies the priority of the interrupt.
N//!
N//! This function is used to set the priority of an interrupt.  When multiple
N//! interrupts are asserted simultaneously, the ones with the highest priority
N//! are processed before the lower priority interrupts.  Smaller numbers
N//! correspond to higher interrupt priorities; priority 0 is the highest
N//! interrupt priority.
N//!
N//! The hardware priority mechanism only looks at the upper N bits of the
N//! priority level (where N is 3 for the MSP432 family), so any
N//! prioritization must be performed in those bits.  The remaining bits can be
N//! used to sub-prioritize the interrupt sources, and may be used by the
N//! hardware priority mechanism on a future part.  This arrangement allows
N//! priorities to migrate to different NVIC implementations without changing
N//! the gross prioritization of the interrupts.
N//!
N//! See \link Interrupt_enableInterrupt \endlink for details about the interrupt
N//! parameter
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void Interrupt_setPriority(uint32_t interruptNumber, uint8_t priority);
N
N//*****************************************************************************
N//
N//! Gets the priority of an interrupt.
N//!
N//! \param interruptNumber specifies the interrupt in question.
N//!
N//! This function gets the priority of an interrupt.  See
N//! Interrupt_setPriority() for a definition of the priority value.
N//!
N//! See \link Interrupt_enableInterrupt \endlink for details about the interrupt
N//! parameter
N//!
N//! \return Returns the interrupt priority, or -1 if an invalid interrupt was
N//! specified.
N//
N//*****************************************************************************
Nextern uint8_t Interrupt_getPriority(uint32_t interruptNumber);
N
N//*****************************************************************************
N//
N//! Enables an interrupt.
N//!
N//! \param interruptNumber specifies the interrupt to be enabled.
N//!
N//! The specified interrupt is enabled in the interrupt controller.  Other
N//! enables for the interrupt (such as at the peripheral level) are unaffected
N//! by this function.
N//!
N//! Valid values will vary from part to part, so it is important to check the
N//! device specific datasheet, however for MSP432 101 the following values can
N//! be provided:
N//!     - \b FAULT_NMI
N//!     - \b FAULT_HARD
N//!     - \b FAULT_MPU
N//!     - \b FAULT_BUS
N//!     - \b FAULT_USAGE
N//!     - \b FAULT_SVCALL
N//!     - \b FAULT_DEBUG
N//!     - \b FAULT_PENDSV
N//!     - \b FAULT_SYSTICK
N//!     - \b INT_PSS
N//!     - \b INT_CS
N//!     - \b INT_PCM
N//!     - \b INT_WDT_A
N//!     - \b INT_FPU
N//!     - \b INT_FLCTL
N//!     - \b INT_COMP0
N//!     - \b INT_COMP1
N//!     - \b INT_TA0_0
N//!     - \b INT_TA0_N
N//!     - \b INT_TA1_0
N//!     - \b INT_TA1_N
N//!     - \b INT_TA2_0
N//!     - \b INT_TA2_N
N//!     - \b INT_TA3_0
N//!     - \b INT_TA3_N
N//!     - \b INT_EUSCIA0
N//!     - \b INT_EUSCIA1
N//!     - \b INT_EUSCIA2
N//!     - \b INT_EUSCIA3
N//!     - \b INT_EUSCIB0
N//!     - \b INT_EUSCIB1
N//!     - \b INT_EUSCIB2
N//!     - \b INT_EUSCIB3
N//!     - \b INT_ADC14
N//!     - \b INT_T32_INT1
N//!     - \b INT_T32_INT2
N//!     - \b INT_T32_INTC
N//!     - \b INT_AES
N//!     - \b INT_RTCC
N//!     - \b INT_DMA_ERR
N//!     - \b INT_DMA_INT3
N//!     - \b INT_DMA_INT2
N//!     - \b INT_DMA_INT1
N//!     - \b INT_DMA_INT0
N//!     - \b INT_PORT1
N//!     - \b INT_PORT2
N//!     - \b INT_PORT3
N//!     - \b INT_PORT4
N//!     - \b INT_PORT5
N//!     - \b INT_PORT6
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void Interrupt_enableInterrupt(uint32_t interruptNumber);
N
N//*****************************************************************************
N//
N//! Disables an interrupt.
N//!
N//! \param interruptNumber specifies the interrupt to be disabled.
N//!
N//! The specified interrupt is disabled in the interrupt controller.  Other
N//! enables for the interrupt (such as at the peripheral level) are unaffected
N//! by this function.
N//!
N//! See \link Interrupt_enableInterrupt \endlink for details about the interrupt
N//! parameter
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void Interrupt_disableInterrupt(uint32_t interruptNumber);
N
N//*****************************************************************************
N//
N//! Returns if a peripheral interrupt is enabled.
N//!
N//! \param interruptNumber specifies the interrupt to check.
N//!
N//! This function checks if the specified interrupt is enabled in the interrupt
N//! controller.
N//!
N//! See \link Interrupt_enableInterrupt \endlink for details about the interrupt
N//! parameter
N//!
N//! \return A non-zero value if the interrupt is enabled.
N//
N//*****************************************************************************
Nextern bool Interrupt_isEnabled(uint32_t interruptNumber);
N
N//*****************************************************************************
N//
N//! Pends an interrupt.
N//!
N//! \param interruptNumber specifies the interrupt to be pended.
N//!
N//! The specified interrupt is pended in the interrupt controller.  Pending an
N//! interrupt causes the interrupt controller to execute the corresponding
N//! interrupt handler at the next available time, based on the current
N//! interrupt state priorities. For example, if called by a higher priority
N//! interrupt handler, the specified interrupt handler is not called until
N//! after the current interrupt handler has completed execution.  The interrupt
N//! must have been enabled for it to be called.
N//!
N//! See \link Interrupt_enableInterrupt \endlink for details about the interrupt
N//! parameter
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void Interrupt_pendInterrupt(uint32_t interruptNumber);
N
N//*****************************************************************************
N//
N//! Un-pends an interrupt.
N//!
N//! \param interruptNumber specifies the interrupt to be un-pended.
N//!
N//! The specified interrupt is un-pended in the interrupt controller.  This
N//! will cause any previously generated interrupts that have not been handled
N//! yet (due to higher priority interrupts or the interrupt no having been
N//! enabled yet) to be discarded.
N//!
N//! See \link Interrupt_enableInterrupt \endlink for details about the interrupt
N//! parameter
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void Interrupt_unpendInterrupt(uint32_t interruptNumber);
N
N//*****************************************************************************
N//
N//! Sets the priority masking level
N//!
N//! \param priorityMask is the priority level that is masked.
N//!
N//! This function sets the interrupt priority masking level so that all
N//! interrupts at the specified or lesser priority level are masked.  Masking
N//! interrupts can be used to globally disable a set of interrupts with
N//! priority below a predetermined threshold.  A value of 0 disables priority
N//! masking.
N//!
N//! Smaller numbers correspond to higher interrupt priorities.  So for example
N//! a priority level mask of 4 allows interrupts of priority level 0-3,
N//! and interrupts with a numerical priority of 4 and greater are blocked.
N//!
N//! The hardware priority mechanism only looks at the upper N bits of the
N//! priority level (where N is 3 for the MSP432 family), so any
N//! prioritization must be performed in those bits.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void Interrupt_setPriorityMask(uint8_t priorityMask);
N
N//*****************************************************************************
N//
N//! Gets the priority masking level
N//!
N//! This function gets the current setting of the interrupt priority masking
N//! level.  The value returned is the priority level such that all interrupts
N//! of that and lesser priority are masked.  A value of 0 means that priority
N//! masking is disabled.
N//!
N//! Smaller numbers correspond to higher interrupt priorities.  So for example
N//! a priority level mask of 4 allows interrupts of priority level 0-3,
N//! and interrupts with a numerical priority of 4 and greater are blocked.
N//!
N//! The hardware priority mechanism only looks at the upper N bits of the
N//! priority level (where N is 3 for the MSP432 family), so any
N//! prioritization must be performed in those bits.
N//!
N//! \return Returns the value of the interrupt priority level mask.
N//
N//*****************************************************************************
Nextern uint8_t Interrupt_getPriorityMask(void);
N
N//*****************************************************************************
N//
N//! Sets the address of the vector table. This function is for advanced users
N//! who might want to switch between multiple instances of vector tables
N//! (perhaps between flash/ram).
N//!
N//! \param addr is the new address of the vector table.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void Interrupt_setVectorTableAddress(uint32_t addr);
N
N//*****************************************************************************
N//
N//! Returns the address of the interrupt vector table.
N//!
N//! \return Address of the vector table.
N//
N//*****************************************************************************
Nextern uint32_t Interrupt_getVectorTableAddress(void);
N
N//*****************************************************************************
N//
N//! Enables the processor to sleep when exiting an ISR. For low power operation,
N//! this is ideal as power cycles are not wasted with the processing required
N//! for waking up from an ISR and going back to sleep.
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void Interrupt_enableSleepOnIsrExit(void);
N
N//*****************************************************************************
N//
N//! Disables the processor to sleep when exiting an ISR.
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void Interrupt_disableSleepOnIsrExit(void);
N
N//*****************************************************************************
N//
N// Mark the end of the C bindings section for C++ compilers.
N//
N//*****************************************************************************
N#ifdef __cplusplus
N}
N#endif
N
N//*****************************************************************************
N//
N// Close the Doxygen group.
N//! @}
N//
N//*****************************************************************************
N
N#endif // __INTERRUPT_H__
L 53 "C:/ti/msp432_driverlib_3_21_00_05/driverlib/MSP432P4xx/driverlib.h" 2
N#include "mpu.h"
L 1 "C:\ti\msp432_driverlib_3_21_00_05\driverlib\MSP432P4xx\mpu.h" 1
N/*
N * -------------------------------------------
N *    MSP432 DriverLib - v3_21_00_05 
N * -------------------------------------------
N *
N * --COPYRIGHT--,BSD,BSD
N * Copyright (c) 2016, Texas Instruments Incorporated
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N *
N * *  Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N *
N * *  Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * *  Neither the name of Texas Instruments Incorporated nor the names of
N *    its contributors may be used to endorse or promote products derived
N *    from this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
N * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
N * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
N * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
N * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
N * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
N * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
N * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
N * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * --/COPYRIGHT--*/
N#ifndef __MPU_H__
N#define __MPU_H__
N
N//*****************************************************************************
N//
N//! \addtogroup mpu_api
N//! @{
N//
N//*****************************************************************************
N
N
N//*****************************************************************************
N//
N// If building with a C++ compiler, make all of the definitions in this header
N// have a C binding.
N//
N//*****************************************************************************
N#ifdef __cplusplus
Nextern "C"
N{
N#endif
N
N#include <msp.h>
N#include <stdint.h>
N
N//*****************************************************************************
N//
N// Flags that can be passed to MPU_enableModule.
N//
N//*****************************************************************************
N#define MPU_CONFIG_PRIV_DEFAULT     MPU_CTRL_PRIVDEFENA_Msk
N#define MPU_CONFIG_HARDFLT_NMI      MPU_CTRL_HFNMIENA_Msk
N#define MPU_CONFIG_NONE             0
N
N//*****************************************************************************
N//
N// Flags for the region size to be passed to MPU_setRegion.
N//
N//*****************************************************************************
N#define MPU_RGN_SIZE_32B            (4 << 1)
N#define MPU_RGN_SIZE_64B            (5 << 1)
N#define MPU_RGN_SIZE_128B           (6 << 1)
N#define MPU_RGN_SIZE_256B           (7 << 1)
N#define MPU_RGN_SIZE_512B           (8 << 1)
N
N#define MPU_RGN_SIZE_1K             (9 << 1)
N#define MPU_RGN_SIZE_2K             (10 << 1)
N#define MPU_RGN_SIZE_4K             (11 << 1)
N#define MPU_RGN_SIZE_8K             (12 << 1)
N#define MPU_RGN_SIZE_16K            (13 << 1)
N#define MPU_RGN_SIZE_32K            (14 << 1)
N#define MPU_RGN_SIZE_64K            (15 << 1)
N#define MPU_RGN_SIZE_128K           (16 << 1)
N#define MPU_RGN_SIZE_256K           (17 << 1)
N#define MPU_RGN_SIZE_512K           (18 << 1)
N
N#define MPU_RGN_SIZE_1M             (19 << 1)
N#define MPU_RGN_SIZE_2M             (20 << 1)
N#define MPU_RGN_SIZE_4M             (21 << 1)
N#define MPU_RGN_SIZE_8M             (22 << 1)
N#define MPU_RGN_SIZE_16M            (23 << 1)
N#define MPU_RGN_SIZE_32M            (24 << 1)
N#define MPU_RGN_SIZE_64M            (25 << 1)
N#define MPU_RGN_SIZE_128M           (26 << 1)
N#define MPU_RGN_SIZE_256M           (27 << 1)
N#define MPU_RGN_SIZE_512M           (28 << 1)
N
N#define MPU_RGN_SIZE_1G             (29 << 1)
N#define MPU_RGN_SIZE_2G             (30 << 1)
N#define MPU_RGN_SIZE_4G             (31 << 1)
N
N//*****************************************************************************
N//
N// Flags for the permissions to be passed to MPU_setRegion.
N//
N//*****************************************************************************
N#define MPU_RGN_PERM_EXEC           0x00000000
N#define MPU_RGN_PERM_NOEXEC         0x10000000
N#define MPU_RGN_PERM_PRV_NO_USR_NO  0x00000000
N#define MPU_RGN_PERM_PRV_RW_USR_NO  0x01000000
N#define MPU_RGN_PERM_PRV_RW_USR_RO  0x02000000
N#define MPU_RGN_PERM_PRV_RW_USR_RW  0x03000000
N#define MPU_RGN_PERM_PRV_RO_USR_NO  0x05000000
N#define MPU_RGN_PERM_PRV_RO_USR_RO  0x06000000
N
N//*****************************************************************************
N//
N// Flags for the sub-region to be passed to MPU_setRegion.
N//
N//*****************************************************************************
N#define MPU_SUB_RGN_DISABLE_0       0x00000100
N#define MPU_SUB_RGN_DISABLE_1       0x00000200
N#define MPU_SUB_RGN_DISABLE_2       0x00000400
N#define MPU_SUB_RGN_DISABLE_3       0x00000800
N#define MPU_SUB_RGN_DISABLE_4       0x00001000
N#define MPU_SUB_RGN_DISABLE_5       0x00002000
N#define MPU_SUB_RGN_DISABLE_6       0x00004000
N#define MPU_SUB_RGN_DISABLE_7       0x00008000
N
N//*****************************************************************************
N//
N// Flags to enable or disable a region, to be passed to MPU_setRegion.
N//
N//*****************************************************************************
N#define MPU_RGN_ENABLE              1
N#define MPU_RGN_DISABLE             0
N
N#define NVIC_MPU_TYPE_DREGION_S     8
N
N//*****************************************************************************
N//
N// API Function prototypes
N//
N//*****************************************************************************
N
N//*****************************************************************************
N//
N//! Enables and configures the MPU for use.
N//!
N//! \param mpuConfig is the logical OR of the possible configurations.
N//!
N//! This function enables the Cortex-M memory protection unit.  It also
N//! configures the default behavior when in privileged mode and while handling
N//! a hard fault or NMI.  Prior to enabling the MPU, at least one region must
N//! be set by calling MPU_setRegion() or else by enabling the default region for
N//! privileged mode by passing the \b MPU_CONFIG_PRIV_DEFAULT flag to
N//! MPU_enableModule().  Once the MPU is enabled, a memory management fault is
N//! generated for memory access violations.
N//!
N//! The \e mpuConfig parameter should be the logical OR of any of the
N//! following:
N//!
N//! - \b MPU_CONFIG_PRIV_DEFAULT enables the default memory map when in
N//! privileged mode and when no other regions are defined.  If this option
N//! is not enabled, then there must be at least one valid region already
N//! defined when the MPU is enabled.
N//! - \b MPU_CONFIG_HARDFLT_NMI enables the MPU while in a hard fault or NMI
N//! exception handler.  If this option is not enabled, then the MPU is
N//! disabled while in one of these exception handlers and the default
N//! memory map is applied.
N//! - \b MPU_CONFIG_NONE chooses none of the above options.  In this case,
N//! no default memory map is provided in privileged mode, and the MPU is
N//! not enabled in the fault handlers.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void MPU_enableModule(uint32_t mpuConfig);
N
N//*****************************************************************************
N//
N//! Disables the MPU for use.
N//!
N//! This function disables the Cortex-M memory protection unit.  When the
N//! MPU is disabled, the default memory map is used and memory management
N//! faults are not generated.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void MPU_disableModule(void);
N
N//*****************************************************************************
N//
N//! Gets the count of regions supported by the MPU.
N//!
N//! This function is used to get the total number of regions that are supported
N//! by the MPU, including regions that are already programmed.
N//!
N//! \return The number of memory protection regions that are available
N//! for programming using MPU_setRegion().
N//
N//*****************************************************************************
Nextern uint32_t MPU_getRegionCount(void);
N
N//*****************************************************************************
N//
N//! Enables a specific region.
N//!
N//! \param region is the region number to enable. Valid values are between
N//!  0 and 7 inclusively.
N//!
N//! This function is used to enable a memory protection region.  The region
N//! should already be configured with the MPU_setRegion() function.  Once
N//! enabled, the memory protection rules of the region are applied and access
N//! violations cause a memory management fault.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void MPU_enableRegion(uint32_t region);
N
N//*****************************************************************************
N//
N//! Disables a specific region.
N//!
N//! \param region is the region number to disable. Valid values are between
N//!  0 and 7 inclusively.
N//!
N//! This function is used to disable a previously enabled memory protection
N//! region.  The region remains configured if it is not overwritten with
N//! another call to MPU_setRegion(), and can be enabled again by calling
N//! MPU_enableRegion().
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void MPU_disableRegion(uint32_t region);
N
N//*****************************************************************************
N//
N//! Sets up the access rules for a specific region.
N//!
N//! \param region is the region number to set up.
N//! \param addr is the base address of the region.  It must be aligned
N//! according to the size of the region specified in flags.
N//! \param flags is a set of flags to define the attributes of the region.
N//!
N//! This function sets up the protection rules for a region.  The region has
N//! a base address and a set of attributes including the size. The base
N//! address parameter, \e addr, must be aligned according to the size, and
N//! the size must be a power of 2.
N//!
N//! \param region is the region number to set. Valid values are between
N//!  0 and 7 inclusively.
N//!
N//! The \e flags parameter is the logical OR of all of the attributes
N//! of the region.  It is a combination of choices for region size,
N//! execute permission, read/write permissions, disabled sub-regions,
N//! and a flag to determine if the region is enabled.
N//!
N//! The size flag determines the size of a region and must be one of the
N//! following:
N//!
N//! - \b MPU_RGN_SIZE_32B
N//! - \b MPU_RGN_SIZE_64B
N//! - \b MPU_RGN_SIZE_128B
N//! - \b MPU_RGN_SIZE_256B
N//! - \b MPU_RGN_SIZE_512B
N//! - \b MPU_RGN_SIZE_1K
N//! - \b MPU_RGN_SIZE_2K
N//! - \b MPU_RGN_SIZE_4K
N//! - \b MPU_RGN_SIZE_8K
N//! - \b MPU_RGN_SIZE_16K
N//! - \b MPU_RGN_SIZE_32K
N//! - \b MPU_RGN_SIZE_64K
N//! - \b MPU_RGN_SIZE_128K
N//! - \b MPU_RGN_SIZE_256K
N//! - \b MPU_RGN_SIZE_512K
N//! - \b MPU_RGN_SIZE_1M
N//! - \b MPU_RGN_SIZE_2M
N//! - \b MPU_RGN_SIZE_4M
N//! - \b MPU_RGN_SIZE_8M
N//! - \b MPU_RGN_SIZE_16M
N//! - \b MPU_RGN_SIZE_32M
N//! - \b MPU_RGN_SIZE_64M
N//! - \b MPU_RGN_SIZE_128M
N//! - \b MPU_RGN_SIZE_256M
N//! - \b MPU_RGN_SIZE_512M
N//! - \b MPU_RGN_SIZE_1G
N//! - \b MPU_RGN_SIZE_2G
N//! - \b MPU_RGN_SIZE_4G
N//!
N//! The execute permission flag must be one of the following:
N//!
N//! - \b MPU_RGN_PERM_EXEC enables the region for execution of code
N//! - \b MPU_RGN_PERM_NOEXEC disables the region for execution of code
N//!
N//! The read/write access permissions are applied separately for the
N//! privileged and user modes.  The read/write access flags must be one
N//! of the following:
N//!
N//! - \b MPU_RGN_PERM_PRV_NO_USR_NO - no access in privileged or user mode
N//! - \b MPU_RGN_PERM_PRV_RW_USR_NO - privileged read/write, user no access
N//! - \b MPU_RGN_PERM_PRV_RW_USR_RO - privileged read/write, user read-only
N//! - \b MPU_RGN_PERM_PRV_RW_USR_RW - privileged read/write, user read/write
N//! - \b MPU_RGN_PERM_PRV_RO_USR_NO - privileged read-only, user no access
N//! - \b MPU_RGN_PERM_PRV_RO_USR_RO - privileged read-only, user read-only
N//!
N//! The region is automatically divided into 8 equally-sized sub-regions by
N//! the MPU.  Sub-regions can only be used in regions of size 256 bytes
N//! or larger.  Any of these 8 sub-regions can be disabled, allowing for
N//! creation of ``holes'' in a region which can be left open, or overlaid
N//! by another region with different attributes.  Any of the 8 sub-regions
N//! can be disabled with a logical OR of any of the following flags:
N//!
N//! - \b MPU_SUB_RGN_DISABLE_0
N//! - \b MPU_SUB_RGN_DISABLE_1
N//! - \b MPU_SUB_RGN_DISABLE_2
N//! - \b MPU_SUB_RGN_DISABLE_3
N//! - \b MPU_SUB_RGN_DISABLE_4
N//! - \b MPU_SUB_RGN_DISABLE_5
N//! - \b MPU_SUB_RGN_DISABLE_6
N//! - \b MPU_SUB_RGN_DISABLE_7
N//!
N//! Finally, the region can be initially enabled or disabled with one of
N//! the following flags:
N//!
N//! - \b MPU_RGN_ENABLE
N//! - \b MPU_RGN_DISABLE
N//!
N//! As an example, to set a region with the following attributes: size of
N//! 32 KB, execution enabled, read-only for both privileged and user, one
N//! sub-region disabled, and initially enabled; the \e flags parameter would
N//! have the following value:
N//!
N//! <code>
N//! (MPU_RGN_SIZE_32K | MPU_RGN_PERM_EXEC | MPU_RGN_PERM_PRV_RO_USR_RO |
N//!  MPU_SUB_RGN_DISABLE_2 | MPU_RGN_ENABLE)
N//! </code>
N//!
N//! \note This function writes to multiple registers and is not protected
N//! from interrupts.  It is possible that an interrupt which accesses a
N//! region may occur while that region is in the process of being changed.
N//! The safest way to handle this is to disable a region before changing it.
N//! Refer to the discussion of this in the API Detailed Description section.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void MPU_setRegion(uint32_t region, uint32_t addr, uint32_t flags);
N
N//*****************************************************************************
N//
N//! Gets the current settings for a specific region.
N//!
N//! \param region is the region number to get. Valid values are between
N//!  0 and 7 inclusively.
N//! \param addr points to storage for the base address of the region.
N//! \param pflags points to the attribute flags for the region.
N//!
N//! This function retrieves the configuration of a specific region.  The
N//! meanings and format of the parameters is the same as that of the
N//! MPU_setRegion() function.
N//!
N//! This function can be used to save the configuration of a region for later
N//! use with the MPU_setRegion() function.  The region's enable state is
N//! preserved in the attributes that are saved.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void MPU_getRegion(uint32_t region, uint32_t *addr, uint32_t *pflags);
N
N//*****************************************************************************
N//
N//! Registers an interrupt handler for the memory management fault.
N//!
N//! \param intHandler is a pointer to the function to be called when the
N//! memory management fault occurs.
N//!
N//! This function sets and enables the handler to be called when the MPU
N//! generates a memory management fault due to a protection region access
N//! violation.
N//!
N//! \sa Interrupt_registerInterrupt() for important information about
N//! registering interrupt handlers.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void MPU_registerInterrupt(void (*intHandler)(void));
N
N//*****************************************************************************
N//
N//! Unregisters an interrupt handler for the memory management fault.
N//!
N//! This function disables and clears the handler to be called when a
N//! memory management fault occurs.
N//!
N//! \sa Interrupt_registerInterrupt() for important information about
N//! registering interrupt handlers.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void MPU_unregisterInterrupt(void);
N
N//*****************************************************************************
N//
N//! Enables the interrupt for the memory management fault.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void MPU_enableInterrupt(void);
N
N//*****************************************************************************
N//
N//! Disables the interrupt for the memory management fault.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void MPU_disableInterrupt(void);
N
N//*****************************************************************************
N//
N// Mark the end of the C bindings section for C++ compilers.
N//
N//*****************************************************************************
N#ifdef __cplusplus
N}
N#endif
N
N//*****************************************************************************
N//
N// Close the Doxygen group.
N//! @}
N//
N//*****************************************************************************
N
N#endif //  __MPU_H__
L 54 "C:/ti/msp432_driverlib_3_21_00_05/driverlib/MSP432P4xx/driverlib.h" 2
N#include "pcm.h"
L 1 "C:\ti\msp432_driverlib_3_21_00_05\driverlib\MSP432P4xx\pcm.h" 1
N/*
N * -------------------------------------------
N *    MSP432 DriverLib - v3_21_00_05 
N * -------------------------------------------
N *
N * --COPYRIGHT--,BSD,BSD
N * Copyright (c) 2016, Texas Instruments Incorporated
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N *
N * *  Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N *
N * *  Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * *  Neither the name of Texas Instruments Incorporated nor the names of
N *    its contributors may be used to endorse or promote products derived
N *    from this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
N * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
N * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
N * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
N * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
N * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
N * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
N * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
N * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * --/COPYRIGHT--*/
N#ifndef __PCM_H__
N#define __PCM_H__
N
N//*****************************************************************************
N//
N//! \addtogroup pcm_api
N//! @{
N//
N//*****************************************************************************
N
N//*****************************************************************************
N//
N// If building with a C++ compiler, make all of the definitions in this header
N// have a C binding.
N//
N//*****************************************************************************
N#ifdef __cplusplus
Nextern "C"
N{
N#endif
N
N#include <stdint.h>
N#include <stdbool.h>
N#include <msp.h>
N
N//*****************************************************************************
N//
N// Control specific variables 
N//
N//*****************************************************************************
N#define PCM_KEY 0x695A0000
N
N/* Power Modes */
N#define PCM_AM_LDO_VCORE0      0x00
N#define PCM_AM_LDO_VCORE1      0x01
N#define PCM_AM_DCDC_VCORE0     0x04
N#define PCM_AM_DCDC_VCORE1     0x05
N#define PCM_AM_LF_VCORE0      0x08
N#define PCM_AM_LF_VCORE1      0x09
N#define PCM_LPM0_LDO_VCORE0    0x10
N#define PCM_LPM0_LDO_VCORE1    0x11
N#define PCM_LPM0_DCDC_VCORE0   0x14
N#define PCM_LPM0_DCDC_VCORE1   0x15
N#define PCM_LPM0_LF_VCORE0    0x18
N#define PCM_LPM0_LF_VCORE1    0x19
N#define PCM_LPM3               0x20
N#define PCM_LPM4               0x21
N#define PCM_LPM35_VCORE0       0xC0
N#define PCM_LPM45              0xA0
N
N#define PCM_VCORE0     0x00
N#define PCM_VCORE1     0x01
N#define PCM_VCORELPM3   0x02
N
N#define PCM_LDO_MODE   0x00
N#define PCM_DCDC_MODE  0x01
N#define PCM_LF_MODE   0x02
N
N#define PCM_SHUTDOWN_PARTIAL PCM_LPM35_VCORE0
N#define PCM_SHUTDOWN_COMPLETE PCM_LPM45
N
N#define PCM_DCDCERROR PCM_IE_DCDC_ERROR_IE
N#define PCM_AM_INVALIDTRANSITION PCM_IE_AM_INVALID_TR_IE
N#define PCM_SM_INVALIDCLOCK PCM_IE_LPM_INVALID_CLK_IE
N#define PCM_SM_INVALIDTRANSITION PCM_IE_LPM_INVALID_TR_IE
N
N//*****************************************************************************
N//
N// Prototypes for the APIs.
N//
N//*****************************************************************************
N
N//******************************************************************************
N//
N//! Sets the core voltage level (Vcore). The function will take care of all
N//! power state transitions needed to shift between core voltage levels.
N//! Because transitions between voltage levels may require changes power modes,
N//! the power mode might temporarily be change. The power mode will be returned
N//! to the original state (with the new voltage level) at the end of a
N//! successful execution of this function.
N//!
N//! Refer to the device specific data sheet for specifics about core voltage
N//! levels.
N//!
N//! \param voltageLevel The voltage level to be shifted to.
N//!           - \b PCM_VCORE0,
N//!           - \b PCM_VCORE1
N//!
N//! \return true if voltage level set, false otherwise.
N//
N//******************************************************************************
Nextern bool PCM_setCoreVoltageLevel(uint_fast8_t voltageLevel);
N
N//******************************************************************************
N//
N//! Returns the current powers state of the system see the
N//! PCM_setCoreVoltageLevel function for specific information about the modes.
N//!
N//! \return The current voltage of the system
N//!
N//! Possible return values include:
N//!     - \b PCM_VCORE0
N//!     - \b PCM_VCORE1
N//!     - \b PCM_VCORELPM3
N//!
N//
N//******************************************************************************
Nextern uint8_t PCM_getCoreVoltageLevel(void);
N
N//******************************************************************************
N//
N//! Sets the core voltage level (Vcore). This function will take care of all
N//! power state transitions needed to shift between core voltage levels.
N//! Because transitions between voltage levels may require changes power modes,
N//! the power mode might temporarily be change. The power mode will be returned
N//! to the original state (with the new voltage level) at the end of a
N//! successful execution of this function.
N//!
N//! This function is similar to PCMSetCoreVoltageLevel, however a timeout
N//! mechanism is used.
N//!
N//! Refer to the device specific data sheet for specifics about core voltage
N//! levels.
N//!
N//! \param voltageLevel The voltage level to be shifted to.
N//!           - \b PCM_VCORE0,
N//!           - \b PCM_VCORE1
N//!
N//! \param timeOut Number of loop iterations to timeout when checking for
N//!         power state transitions. This should be used for debugging initial
N//!         power/hardware configurations. After a stable hardware base is
N//!         established, the PCMSetCoreVoltageLevel function should be used
N//!
N//! \return true if voltage level set, false otherwise.
N//
N//******************************************************************************
Nextern bool PCM_setCoreVoltageLevelWithTimeout(uint_fast8_t voltageLevel,
N        uint32_t timeOut);
N
N//******************************************************************************
N//
N//! Sets the core voltage level (Vcore).  This function is similar to
N//! PCM_setCoreVoltageLevel, however there are no polling flags to ensure
N//! a state has changed. Execution is returned back to the calling program
N//  and it is up to the user to ensure proper state transitions happen
N//! correctly. For MSP432, changing into different power modes/states
N//! require very specific logic. This function will initiate only one state
N//! transition and then return. It is up to the user to keep calling this
N//! function until the correct power state has been achieved.
N//!
N//! Refer to the device specific data sheet for specifics about core voltage
N//! levels.
N//!
N//! \param voltageLevel The voltage level to be shifted to.
N//!           - \b PCM_VCORE0,
N//!           - \b PCM_VCORE1
N//!
N//! \return true if voltage level set, false otherwise.
N//
N//******************************************************************************
Nextern bool PCM_setCoreVoltageLevelNonBlocking(uint_fast8_t voltageLevel);
N
N//******************************************************************************
N//
N//! Switches between power modes. This function will take care of all
N//! power state transitions needed to shift between power modes. Note for
N//! changing to DCDC mode, specific hardware considerations are required.
N//!
N//! Refer to the device specific data sheet for specifics about power modes.
N//!
N//! \param powerMode The voltage modes to be shifted to. Valid values are:
N//!           - \b PCM_LDO_MODE,
N//!           - \b PCM_DCDC_MODE,
N//!           - \b PCM_LF_MODE
N//!
N//! \return true if power mode is set, false otherwise.
N//
N//******************************************************************************
Nextern bool PCM_setPowerMode(uint_fast8_t powerMode);
N
N//******************************************************************************
N//
N//! Switches between power modes. This function will take care of all
N//! power state transitions needed to shift between power modes. Note for
N//! changing to DCDC mode, specific hardware considerations are required.
N//!
N//! This function is similar to PCMSetPowerMode, however a timeout
N//! mechanism is used.
N//!
N//! Refer to the device specific data sheet for specifics about power modes.
N//!
N//! \param powerMode The voltage modes to be shifted to. Valid values are:
N//!           - \b PCM_LDO_MODE,
N//!           - \b PCM_DCDC_MODE,
N//!           - \b PCM_LF_MODE
N//!
N//! \param timeOut Number of loop iterations to timeout when checking for
N//!         power state transitions. This should be used for debugging initial
N//!         power/hardware configurations. After a stable hardware base is
N//!         established, the PCMSetPowerMode function should be used
N//!
N//! \return true if power mode is set, false otherwise.
N//
N//******************************************************************************
Nextern bool PCM_setPowerModeWithTimeout(uint_fast8_t powerMode,
N        uint32_t timeOut);
N
N//******************************************************************************
N//
N//! Sets the core voltage level (Vcore).  This function is similar to
N//! PCM_setPowerMode, however there are no polling flags to ensure
N//! a state has changed. Execution is returned back to the calling program
N//  and it is up to the user to ensure proper state transitions happen
N//! correctly. For MSP432, changing into different power modes/states
N//! require very specific logic. This function will initiate only one state
N//! transition and then return. It is up to the user to keep calling this
N//! function until the correct power state has been achieved.
N//!
N//! Refer to the device specific data sheet for specifics about core voltage
N//! levels.
N//!
N//! \param powerMode The voltage modes to be shifted to. Valid values are:
N//!           - \b PCM_LDO_MODE,
N//!           - \b PCM_DCDC_MODE,
N//!           - \b PCM_LF_MODE
N//!
N//! \return true if power mode change was initiated, false otherwise
N//
N//******************************************************************************
Nextern bool PCM_setPowerModeNonBlocking(uint_fast8_t powerMode);
N
N//******************************************************************************
N//
N//! Returns the current powers state of the system see the \b PCM_setPowerState
N//! function for specific information about the modes.
N//!
N//! \return The current power mode of the system
N//!
N//
N//******************************************************************************
Nextern uint8_t PCM_getPowerMode(void);
N
N//******************************************************************************
N//
N//! Switches between power states. This is a convenience function that combines
N//! the functionality of PCM_setPowerMode and PCM_setCoreVoltageLevel as well as
N//! the LPM0/LPM3 functions.
N//!
N//! Refer to the device specific data sheet for specifics about power states.
N//!
N//! \param powerState The voltage modes to be shifted to. Valid values are:
N//!           - \b PCM_AM_LDO_VCORE0,      [Active Mode, LDO, VCORE0]
N//!           - \b PCM_AM_LDO_VCORE1,      [Active Mode, LDO, VCORE1]
N//!           - \b PCM_AM_DCDC_VCORE0,     [Active Mode, DCDC, VCORE0]
N//!           - \b PCM_AM_DCDC_VCORE1,     [Active Mode, DCDC, VCORE1]
N//!           - \b PCM_AM_LF_VCORE0,       [Active Mode, Low Frequency, VCORE0]
N//!           - \b PCM_AM_LF_VCORE1,       [Active Mode, Low Frequency, VCORE1]
N//!           - \b PCM_LPM0_LDO_VCORE0,    [LMP0, LDO, VCORE0]
N//!           - \b PCM_LPM0_LDO_VCORE1,    [LMP0, LDO, VCORE1]
N//!           - \b PCM_LPM0_DCDC_VCORE0,   [LMP0, DCDC, VCORE0]
N//!           - \b PCM_LPM0_DCDC_VCORE1,   [LMP0, DCDC, VCORE1]
N//!           - \b PCM_LPM0_LF_VCORE0,     [LMP0, Low Frequency, VCORE0]
N//!           - \b PCM_LPM0_LF_VCORE1,     [LMP0, Low Frequency, VCORE1]
N//!           - \b PCM_LPM3,               [LPM3]
N//!           - \b PCM_LPM35_VCORE0,       [LPM3.5 VCORE 0]
N//!           - \b PCM_LPM4,               [LPM4]
N//!           - \b PCM_LPM45,              [LPM4.5]
N//!
N//! \return true if power state is set, false otherwise.
N//
N//******************************************************************************
Nextern bool PCM_setPowerState(uint_fast8_t powerState);
N
N//******************************************************************************
N//
N//! Switches between power states. This is a convenience function that combines
N//! the functionality of PCM_setPowerMode and PCM_setCoreVoltageLevel as well as
N//! the LPM modes.
N//!
N//! This function is similar to PCM_setPowerState, however a timeout
N//! mechanism is used.
N//!
N//! Refer to the device specific data sheet for specifics about power states.
N//!
N//! \param powerState The voltage modes to be shifted to. Valid values are:
N//!           - \b PCM_AM_LDO_VCORE0,      [Active Mode, LDO, VCORE0]
N//!           - \b PCM_AM_LDO_VCORE1,      [Active Mode, LDO, VCORE1]
N//!           - \b PCM_AM_DCDC_VCORE0,     [Active Mode, DCDC, VCORE0]
N//!           - \b PCM_AM_DCDC_VCORE1,     [Active Mode, DCDC, VCORE1]
N//!           - \b PCM_AM_LF_VCORE0,       [Active Mode, Low Frequency, VCORE0]
N//!           - \b PCM_AM_LF_VCORE1,       [Active Mode, Low Frequency, VCORE1]
N//!           - \b PCM_LPM0_LDO_VCORE0,    [LMP0, LDO, VCORE0]
N//!           - \b PCM_LPM0_LDO_VCORE1,    [LMP0, LDO, VCORE1]
N//!           - \b PCM_LPM0_DCDC_VCORE0,   [LMP0, DCDC, VCORE0]
N//!           - \b PCM_LPM0_DCDC_VCORE1,   [LMP0, DCDC, VCORE1]
N//!           - \b PCM_LPM0_LF_VCORE0,     [LMP0, Low Frequency, VCORE0]
N//!           - \b PCM_LPM0_LF_VCORE1,     [LMP0, Low Frequency, VCORE1]
N//!           - \b PCM_LPM3,               [LPM3]
N//!           - \b PCM_LPM35_VCORE0,       [LPM3.5 VCORE 0]
N//!           - \b PCM_LPM4,               [LPM4]
N//!           - \b PCM_LPM45,              [LPM4.5]
N//!
N//! \param timeout Number of loop iterations to timeout when checking for
N//!         power state transitions. This should be used for debugging initial
N//!         power/hardware configurations. After a stable hardware base is
N//!         established, the PCMSetPowerMode function should be used
N//!
N//! \return true if power state is set, false otherwise. It is important to
N//!         note that if a timeout occurs, false will be returned, however the
N//!         power state at this point is not guaranteed to be the same as the
N//!         state prior to the function call
N//
N//******************************************************************************
Nextern bool PCM_setPowerStateWithTimeout(uint_fast8_t powerState,
N        uint32_t timeout);
N
N//******************************************************************************
N//
N//! Returns the current powers state of the system see the PCMChangePowerState
N//! function for specific information about the states.
N//!
N//! Refer to \link PCM_setPowerState \endlink for possible return values.
N//!
N//! \return The current power state of the system
N//
N//******************************************************************************
Nextern uint8_t PCM_getPowerState(void);
N
N//******************************************************************************
N//
N//! Sets the power state of the part.  This function is similar to
N//! PCM_getPowerState, however there are no polling flags to ensure
N//! a state has changed. Execution is returned back to the calling program
N//  and it is up to the user to ensure proper state transitions happen
N//! correctly. For MSP432, changing into different power modes/states
N//! require very specific logic. This function will initiate only one state
N//! transition and then return. It is up to the user to keep calling this
N//! function until the correct power state has been achieved.
N//!
N//! Refer to the device specific data sheet for specifics about core voltage
N//! levels.
N//!
N//! \param powerState The voltage modes to be shifted to. Valid values are:
N//!           - \b PCM_AM_LDO_VCORE0,      [Active Mode, LDO, VCORE0]
N//!           - \b PCM_AM_LDO_VCORE1,      [Active Mode, LDO, VCORE1]
N//!           - \b PCM_AM_DCDC_VCORE0,     [Active Mode, DCDC, VCORE0]
N//!           - \b PCM_AM_DCDC_VCORE1,     [Active Mode, DCDC, VCORE1]
N//!           - \b PCM_AM_LF_VCORE0,       [Active Mode, Low Frequency, VCORE0]
N//!           - \b PCM_AM_LF_VCORE1,       [Active Mode, Low Frequency, VCORE1]
N//!           - \b PCM_LPM0_LDO_VCORE0,    [LMP0, LDO, VCORE0]
N//!           - \b PCM_LPM0_LDO_VCORE1,    [LMP0, LDO, VCORE1]
N//!           - \b PCM_LPM0_DCDC_VCORE0,   [LMP0, DCDC, VCORE0]
N//!           - \b PCM_LPM0_DCDC_VCORE1,   [LMP0, DCDC, VCORE1]
N//!           - \b PCM_LPM0_LF_VCORE0,     [LMP0, Low Frequency, VCORE0]
N//!           - \b PCM_LPM0_LF_VCORE1,     [LMP0, Low Frequency, VCORE1]
N//!           - \b PCM_LPM3,               [LPM3]
N//!           - \b PCM_LPM35_VCORE0,       [LPM3.5 VCORE 0]
N//!           - \b PCM_LPM45,              [LPM4.5]
N//!
N//! \return true if power state change was initiated, false otherwise
N//
N//******************************************************************************
Nextern bool PCM_setPowerStateNonBlocking(uint_fast8_t powerState);
N
N//******************************************************************************
N//
N//! Transitions the device into LPM3.5/LPM4.5 mode.
N//!
N//! Refer to the device specific data sheet for specifics about shutdown modes.
N//!
N//! The following events will cause a wake up from LPM3.5 mode:
N//! - Device reset
N//! - External reset RST
N//! - Enabled RTC, WDT, and wake-up I/O only interrupt events
N//!
N//! The following events will cause a wake up from the LPM4.5 mode:
N//! - Device reset
N//! - External reset RST
N//! - Wake-up I/O only interrupt events
N//!
N//! \param shutdownMode Specific mode to go to. Valid values are:
N//!            - \b PCM_LPM35_VCORE0
N//!            - \b PCM_LPM45
N//!
N//!
N//! \return false if shutdown state cannot be entered, true otherwise.
N//
N//******************************************************************************
Nextern bool PCM_shutdownDevice(uint32_t shutdownMode);
N
N//******************************************************************************
N//
N//! Transitions the device into LPM0.
N//!
N//! Refer to the device specific data sheet for specifics about low power modes.
N//!
N//! \return false if sleep state cannot be entered, true otherwise.
N//
N//******************************************************************************
Nextern bool PCM_gotoLPM0(void);
N
N//******************************************************************************
N//
N//! Transitions the device into LPM3
N//!
N//! Refer to the device specific data sheet for specifics about low power modes.
N//! Note that since LPM3 cannot be entered from  a DCDC power modes, the
N//! power mode is first switched to LDO operation (if in DCDC mode), the deep
N//! sleep is entered, and the DCDC mode is restored on wake up.
N//!
N//! \return false if sleep state cannot be entered, true otherwise.
N//
N//******************************************************************************
Nextern bool PCM_gotoLPM3(void);
N
N//******************************************************************************
N//
N//! Transitions the device into LPM0 while maintaining a safe
N//! interrupt handling mentality. This function is meant to be used in
N//! situations where the user wants to go to sleep, however does not want
N//! to go to "miss" any interrupts due to the fact that going to LPM0 is not
N//! an atomic operation. This function will modify the PRIMASK and on exit of
N//! the program the master interrupts will be disabled.
N//!
N//! Refer to the device specific data sheet for specifics about low power modes.
N//!
N//! \return false if sleep state cannot be entered, true otherwise.
N//
N//******************************************************************************
Nextern bool PCM_gotoLPM0InterruptSafe(void);
N
N//******************************************************************************
N//
N//! Transitions the device into LPM3 while maintaining a safe
N//! interrupt handling mentality. This function is meant to be used in
N//! situations where the user wants to go to LPM3, however does not want
N//! to go to "miss" any interrupts due to the fact that going to LPM3 is not
N//! an atomic operation. This function will modify the PRIMASK and on exit of
N//! the program the master interrupts will be disabled.
N//!
N//! Refer to the device specific data sheet for specifics about low power modes.
N//! Note that since LPM3 cannot be entered from  a DCDC power modes, the
N//! power mode is first switched to LDO operation (if in DCDC mode), the deep
N//! sleep is entered, and the DCDC mode is restored on wake up.
N//!
N//! \return false if sleep state cannot be entered, true otherwise.
N//
N//******************************************************************************
Nextern bool PCM_gotoLPM3InterruptSafe(void);
N
N//******************************************************************************
N//
N//! Transitions the device into LPM4. LPM4 is the exact same with LPM3, just
N//! with RTC_C and WDT_A disabled. When waking up, RTC_C and WDT_A will remain
N//! disabled until reconfigured by the user.
N//!
N//! \return false if sleep state cannot be entered, true otherwise.
N//
N//******************************************************************************
Nextern bool PCM_gotoLPM4(void);
N
N//******************************************************************************
N//
N//! Transitions the device into LPM4 while maintaining a safe
N//! interrupt handling mentality. This function is meant to be used in
N//! situations where the user wants to go to LPM4, however does not want
N//! to go to "miss" any interrupts due to the fact that going to LPM4 is not
N//! an atomic operation. This function will modify the PRIMASK and on exit of
N//! the program the master interrupts will be disabled.
N//!
N//! Refer to the device specific data sheet for specifics about low power modes.
N//! Note that since LPM3 cannot be entered from  a DCDC power modes, the
N//! power mode is first switched to LDO operation (if in DCDC mode), the deep
N//! sleep is entered, and the DCDC mode is restored on wake up.
N//!
N//! \return false if sleep state cannot be entered, true otherwise.
N//
N//******************************************************************************
Nextern bool PCM_gotoLPM4InterruptSafe(void);
N
N//******************************************************************************
N//
N//! Enables "rude mode" entry into LPM3 and shutdown modes. With this mode
N//! enabled, an entry into shutdown or LPM3 will occur even if there are
N//! clock systems active. The system will forcibly  turn off all clock/systems
N//! when going into these modes.
N//!
N//! \return None
N//
N//******************************************************************************
Nextern void PCM_enableRudeMode(void);
N
N//******************************************************************************
N//
N//! Disables "rude mode" entry into LPM3 and shutdown modes. With this
N//! mode disabled, an entry into shutdown or LPM3 will wait for any
N//! active clock requests to free up before going into LPM3 or shutdown.
N//!
N//! \return None
N//
N//******************************************************************************
Nextern void PCM_disableRudeMode(void);
N
N//*****************************************************************************
N//
N//! Enables individual power control interrupt sources.
N//!
N//! \param flags is a bit mask of the interrupt sources to be enabled.  Must
N//! be a logical OR of:
N//!         - \b PCM_DCDCERROR,
N//!         - \b PCM_AM_INVALIDTRANSITION,
N//!         - \b PCM_SM_INVALIDCLOCK,
N//!         - \b PCM_SM_INVALIDTRANSITION
N//!
N//! This function enables the indicated power control interrupt sources.  Only
N//! the sources that are enabled can be reflected to the processor interrupt;
N//! disabled sources have no effect on the processor.
N//!
N//! \note The interrupt sources vary based on the part in use.
N//! Please consult the data sheet for the part you are using to determine
N//! which interrupt sources are available.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void PCM_enableInterrupt(uint32_t flags);
N
N//*****************************************************************************
N//
N//! Disables individual power control interrupt sources.
N//!
N//! \param flags is a bit mask of the interrupt sources to be enabled.  Must
N//! be a logical OR of:
N//!         - \b PCM_DCDCERROR,
N//!         - \b PCM_AM_INVALIDTRANSITION,
N//!         - \b PCM_SM_INVALIDCLOCK,
N//!         - \b PCM_SM_INVALIDTRANSITION
N//!
N//! This function disables the indicated power control interrupt sources.  Only
N//! the sources that are enabled can be reflected to the processor interrupt;
N//! disabled sources have no effect on the processor.
N//!
N//! \note The interrupt sources vary based on the part in use.
N//! Please consult the data sheet for the part you are using to determine
N//! which interrupt sources are available.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void PCM_disableInterrupt(uint32_t flags);
N
N//*****************************************************************************
N//
N//! Gets the current interrupt status.
N//!
N//! \return The current interrupt status, enumerated as a bit field of:
N//!         - \b PCM_DCDCERROR,
N//!         - \b PCM_AM_INVALIDTRANSITION,
N//!         - \b PCM_SM_INVALIDCLOCK,
N//!         - \b PCM_SM_INVALIDTRANSITION
N//!
N//! \note The interrupt sources vary based on the part in use.
N//! Please consult the data sheet for the part you are using to determine
N//! which interrupt sources are available.
N//
N//*****************************************************************************
Nextern uint32_t PCM_getInterruptStatus(void);
N
N//*****************************************************************************
N//
N//! Gets the current interrupt status masked with the enabled interrupts.
N//! This function is useful to call in ISRs to get a list of pending
N//! interrupts that are actually enabled and could have caused
N//! the ISR.
N//!
N//! \return The current interrupt status, enumerated as a bit field of:
N//!         - \b PCM_DCDCERROR,
N//!         - \b PCM_AM_INVALIDTRANSITION,
N//!         - \b PCM_SM_INVALIDCLOCK,
N//!         - \b PCM_SM_INVALIDTRANSITION
N//!
N//! \note The interrupt sources vary based on the part in use.
N//! Please consult the data sheet for the part you are using to determine
N//! which interrupt sources are available.
N//
N//*****************************************************************************
Nextern uint32_t PCM_getEnabledInterruptStatus(void);
N
N//*****************************************************************************
N//
N//! Clears power system interrupt sources.
N//!
N//! The specified power system interrupt sources are cleared, so that they no
N//! longer assert.  This function must be called in the interrupt handler to
N//! keep it from being called again immediately upon exit.
N//!
N//! \note Because there is a write buffer in the Cortex-M processor, it may
N//! take several clock cycles before the interrupt source is actually cleared.
N//! Therefore, it is recommended that the interrupt source be cleared early in
N//! the interrupt handler (as opposed to the very last action) to avoid
N//! returning from the interrupt handler before the interrupt source is
N//! actually cleared.  Failure to do so may result in the interrupt handler
N//! being immediately reentered (because the interrupt controller still sees
N//! the interrupt source asserted).
N//!
N//! \param flags is a bit mask of the interrupt sources to be cleared.  Must
N//! be a logical OR of
N//!         - \b PCM_DCDCERROR,
N//!         - \b PCM_AM_INVALIDTRANSITION,
N//!         - \b PCM_SM_INVALIDCLOCK,
N//!         - \b PCM_SM_INVALIDTRANSITION
N//!
N//! \note The interrupt sources vary based on the part in use.
N//! Please consult the data sheet for the part you are using to determine
N//! which interrupt sources are available.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void PCM_clearInterruptFlag(uint32_t flags);
N
N//*****************************************************************************
N//
N//! Registers an interrupt handler for the power system interrupt.
N//!
N//! \param intHandler is a pointer to the function to be called when the power
N//! system interrupt occurs.
N//!
N//! This function registers the handler to be called when a clock system
N//! interrupt occurs. This function enables the global interrupt in the
N//! interrupt controller; specific PCM  interrupts must be enabled
N//! via PCM_enableInterrupt().  It is the interrupt handler's responsibility to
N//! clear the interrupt source via \link PCM_clearInterruptFlag \endlink .
N//!
N//! \sa Interrupt_registerInterrupt() for important information about
N//! registering interrupt handlers.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void PCM_registerInterrupt(void (*intHandler)(void));
N
N//*****************************************************************************
N//
N//! Unregisters the interrupt handler for the power system.
N//!
N//! This function unregisters the handler to be called when a power system
N//! interrupt occurs.  This function also masks off the interrupt in the
N//! interrupt controller so that the interrupt handler no longer is called.
N//!
N//! \sa Interrupt_registerInterrupt() for important information about
N//! registering interrupt handlers.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void PCM_unregisterInterrupt(void);
N
N//*****************************************************************************
N//
N// Mark the end of the C bindings section for C++ compilers.
N//
N//*****************************************************************************
N#ifdef __cplusplus
N}
N#endif
N
N//*****************************************************************************
N//
N// Close the Doxygen group.
N//! @}
N//
N//*****************************************************************************
N
N#endif // __PCM_H__
L 55 "C:/ti/msp432_driverlib_3_21_00_05/driverlib/MSP432P4xx/driverlib.h" 2
N#include "pmap.h"
L 1 "C:\ti\msp432_driverlib_3_21_00_05\driverlib\MSP432P4xx\pmap.h" 1
N/*
N * -------------------------------------------
N *    MSP432 DriverLib - v3_21_00_05 
N * -------------------------------------------
N *
N * --COPYRIGHT--,BSD,BSD
N * Copyright (c) 2016, Texas Instruments Incorporated
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N *
N * *  Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N *
N * *  Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * *  Neither the name of Texas Instruments Incorporated nor the names of
N *    its contributors may be used to endorse or promote products derived
N *    from this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
N * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
N * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
N * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
N * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
N * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
N * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
N * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
N * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * --/COPYRIGHT--*/
N#ifndef __PMAP_H__
N#define __PMAP_H__
N
N//*****************************************************************************
N//
N//! \addtogroup pmap_api
N//! @{
N//
N//*****************************************************************************
N
N//*****************************************************************************
N//
N// If building with a C++ compiler, make all of the definitions in this header
N// have a C binding.
N//
N//*****************************************************************************
N#ifdef __cplusplus
Nextern "C"
N{
N#endif
N
N#include <stdint.h>
N#include <msp.h>
N
N//*****************************************************************************
N//
N//The following are values that can be passed to the PMAP_configurePorts() API
N//as the portMapReconfigure parameter.
N//
N//*****************************************************************************
N#define PMAP_ENABLE_RECONFIGURATION     PMAP_CTL_PRECFG
N#define PMAP_DISABLE_RECONFIGURATION    0x00
N
N//*****************************************************************************
N//
N//The following are values that can be passed to the PMAP_configurePorts() API
N//as the portMapReconfigure parameter.
N//
N//*****************************************************************************
N#define PMAP_P1MAP ((uint32_t)P1MAP - PMAP_BASE)
N#define PMAP_P2MAP ((uint32_t)P2MAP - PMAP_BASE)
N#define PMAP_P3MAP ((uint32_t)P3MAP - PMAP_BASE)
N#define PMAP_P4MAP ((uint32_t)P4MAP - PMAP_BASE)
N#define PMAP_P5MAP ((uint32_t)P5MAP - PMAP_BASE)
N#define PMAP_P6MAP ((uint32_t)P6MAP - PMAP_BASE)
N#define PMAP_P7MAP ((uint32_t)P7MAP - PMAP_BASE)
N
N
N//*****************************************************************************
N//
N//Prototypes for the APIs.
N//
N//*****************************************************************************
N
N//*****************************************************************************
N//
N//! This function configures the MSP432 Port Mapper
N//!
N//! \param portMapping is the pointer to init Data
N//! \param pxMAPy is the Port Mapper to initialize
N//! \param numberOfPorts is the number of Ports to initialize
N//! \param portMapReconfigure is used to enable/disable reconfiguration
N//!             Valid values are
N//!             \b PMAP_ENABLE_RECONFIGURATION
N//!             \b PMAP_DISABLE_RECONFIGURATION [Default value]
N//! Modified registers are \b PMAPKEYID, \b PMAPCTL
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void PMAP_configurePorts(const uint8_t *portMapping, uint8_t pxMAPy,
N        uint8_t numberOfPorts, uint8_t portMapReconfigure);
N
N/* Defines for future devices that might have multiple instances */
N#define PMAP_configurePortsMultipleInstance(a,b,c,d,e) PMAP_configurePorts(b,c,d,e)
N
N//*****************************************************************************
N//
N// Mark the end of the C bindings section for C++ compilers.
N//
N//*****************************************************************************
N#ifdef __cplusplus
N}
N#endif
N
N//*****************************************************************************
N//
N// Close the Doxygen group.
N//! @}
N//
N//*****************************************************************************
N
N#endif
L 56 "C:/ti/msp432_driverlib_3_21_00_05/driverlib/MSP432P4xx/driverlib.h" 2
N#include "pss.h"
L 1 "C:\ti\msp432_driverlib_3_21_00_05\driverlib\MSP432P4xx\pss.h" 1
N/*
N * -------------------------------------------
N *    MSP432 DriverLib - v3_21_00_05 
N * -------------------------------------------
N *
N * --COPYRIGHT--,BSD,BSD
N * Copyright (c) 2016, Texas Instruments Incorporated
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N *
N * *  Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N *
N * *  Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * *  Neither the name of Texas Instruments Incorporated nor the names of
N *    its contributors may be used to endorse or promote products derived
N *    from this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
N * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
N * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
N * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
N * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
N * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
N * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
N * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
N * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * --/COPYRIGHT--*/
N#ifndef __PSS_H__
N#define __PSS_H__
N
N//*****************************************************************************
N//
N//! \addtogroup pss_api
N//! @{
N//
N//*****************************************************************************
N
N//*****************************************************************************
N//
N// If building with a C++ compiler, make all of the definitions in this header
N// have a C binding.
N//
N//*****************************************************************************
N#ifdef __cplusplus
Nextern "C"
N{
N#endif
N
N#include <stdint.h>
N#include <msp.h>
N#include <stdbool.h>
N
N//*****************************************************************************
N//
N// Control specific variables
N//
N//*****************************************************************************
N#define PSS_KEY_VALUE PSS_KEY_KEY_VAL
N
N#define PSS_SVSMH PSS_IE_SVSMHIE
N
N#define PSS_FULL_PERFORMANCE_MODE   0x01
N#define PSS_NORMAL_PERFORMANCE_MODE 0x00
N
N//*****************************************************************************
N//
N// Prototypes for the APIs.
N//
N//*****************************************************************************
N
N//*****************************************************************************
N//
N//! Enables output of the High Side interrupt flag on the device \b SVMHOUT pin
N//!
N//! \param activeLow True if the signal should be logic low when SVSMHIFG
N//!     is set. False if signal should be high when \b SVSMHIFG is set.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void PSS_enableHighSidePinToggle(bool activeLow);
N
N//*****************************************************************************
N//
N//! Disables output of the High Side interrupt flag on the device \b SVMHOUT pin
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void PSS_disableHighSidePinToggle(void);
N
N//*****************************************************************************
N//
N//! Enables high side voltage supervisor/monitor.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void PSS_enableHighSide(void);
N
N//*****************************************************************************
N//
N//! Disables high side voltage supervisor/monitor.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void PSS_disableHighSide(void);
N
N//*****************************************************************************
N//
N//! Sets the performance mode of the high side regulator. Full performance
N//! mode allows for the best response times while normal performance mode is
N//! optimized for the lowest possible current consumption.
N//!
N//! \param powerMode is the performance mode to set. Valid values are one of
N//! the following:
N//!     - \b PSS_FULL_PERFORMANCE_MODE,
N//!     - \b PSS_NORMAL_PERFORMANCE_MODE
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void PSS_setHighSidePerformanceMode(uint_fast8_t powerMode);
N
N//*****************************************************************************
N//
N//! Gets the performance mode of the high side voltage regulator. Refer to the
N//! user's guide for specific information about information about the different
N//! performance modes.
N//!
N//! \return Performance mode of the voltage regulator
N//
N//*****************************************************************************
Nextern uint_fast8_t PSS_getHighSidePerformanceMode(void);
N
N//*****************************************************************************
N//
N//! Sets the high side voltage supervisor to monitor mode
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void PSS_enableHighSideMonitor(void);
N
N//*****************************************************************************
N//
N//! Switches the high side of the power supply system to be a supervisor instead
N//! of a monitor
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void PSS_disableHighSideMonitor(void);
N
N//*****************************************************************************
N//
N//! Sets the voltage level at which the high side of the device voltage
N//! regulator triggers a reset. This value is represented as an unsigned eight
N//! bit integer where only the lowest three bits are most significant.
N//!
N//! \param triggerVoltage Voltage level in which high side supervisor/monitor
N//!         triggers a reset. See the device specific data sheet for details
N//!         on these voltage levels.
N//!
N//! Typical values will vary from part to part (so it is very important to
N//! check the SVSH section of the data sheet. For reference only, the typical
N//! MSP432 101 values are listed below:
N//!     - 0 --> 1.57V
N//!     - 1 --> 1.62V
N//!     - 2 --> 1.83V
N//!     - 3 --> 2V
N//!     - 4 --> 2.25V
N//!     - 5 --> 2.4V
N//!     - 6 --> 2.6V
N//!     - 7 --> 2.8V
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void PSS_setHighSideVoltageTrigger(uint_fast8_t triggerVoltage);
N
N//*****************************************************************************
N//
N//! Returns the voltage level at which the high side of the device voltage
N//! regulator triggers a reset.
N//!
N//! \return The voltage level that the high side voltage supervisor/monitor
N//! triggers a reset. This value is represented as an unsigned eight
N//! bit integer where only the lowest three bits are most significant.
N//! See \link PSS_setHighSideVoltageTrigger \endlink for information regarding
N//! the return value
N//
N//*****************************************************************************
Nextern uint_fast8_t PSS_getHighSideVoltageTrigger(void);
N
N//*****************************************************************************
N//
N//! Enables the power supply system interrupt source.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void PSS_enableInterrupt(void);
N
N//*****************************************************************************
N//
N//! Disables the power supply system interrupt source.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void PSS_disableInterrupt(void);
N
N//*****************************************************************************
N//
N//! Gets the current interrupt status.
N//!
N//! \return The current interrupt status ( \b PSS_SVSMH )
N//!
N//*****************************************************************************
Nextern uint32_t PSS_getInterruptStatus(void);
N
N//*****************************************************************************
N//
N//! Clears power supply system interrupt source.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void PSS_clearInterruptFlag(void);
N
N
N//*****************************************************************************
N//
N//! Enables the "forced" mode of the DCDC regulator. In this mode, the fail
N//! safe mechanism that disables the regulator to LDO mode when the supply
N//! voltage falls below the minimum supply voltage required for DCDC operation
N//! is turned off.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void PSS_enableForcedDCDCOperation(void);
N
N
N//*****************************************************************************
N//
N//! Disables the "forced" mode of the DCDC regulator. In this mode, the fail
N//! safe mechanism that disables the regulator to LDO mode when the supply
N//! voltage falls below the minimum supply voltage required for DCDC operation
N//! is turned on.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void PSS_disableForcedDCDCOperation(void);
N
N//*****************************************************************************
N//
N//! Registers an interrupt handler for the power supply system interrupt.
N//!
N//! \param intHandler is a pointer to the function to be called when the power
N//! supply system interrupt occurs.
N//!
N//! This function registers the handler to be called when a power supply system
N//! interrupt occurs. This function enables the global interrupt in the
N//! interrupt controller; specific PSS interrupts must be enabled
N//! via PSS_enableInterrupt().  It is the interrupt handler's responsibility to
N//! clear the interrupt source via PSS_clearInterruptFlag().
N//!
N//! \sa Interrupt_registerInterrupt() for important information about
N//! registering interrupt handlers.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void PSS_registerInterrupt(void (*intHandler)(void));
N
N//*****************************************************************************
N//
N//! Unregisters the interrupt handler for the power supply system
N//!
N//! This function unregisters the handler to be called when a power supply
N//! system interrupt occurs.  This function also masks off the interrupt in the
N//! interrupt controller so that the interrupt handler no longer is called.
N//!
N//! \sa Interrupt_registerInterrupt() for important information about
N//! registering interrupt handlers.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void PSS_unregisterInterrupt(void);
N
N//*****************************************************************************
N//
N// Mark the end of the C bindings section for C++ compilers.
N//
N//*****************************************************************************
N#ifdef __cplusplus
N}
N#endif
N
N//*****************************************************************************
N//
N// Close the Doxygen group.
N//! @}
N//
N//*****************************************************************************
N
N#endif // __PSS_H__
L 57 "C:/ti/msp432_driverlib_3_21_00_05/driverlib/MSP432P4xx/driverlib.h" 2
N#include "ref_a.h"
L 1 "C:\ti\msp432_driverlib_3_21_00_05\driverlib\MSP432P4xx\ref_a.h" 1
N/*
N * -------------------------------------------
N *    MSP432 DriverLib - v3_21_00_05 
N * -------------------------------------------
N *
N * --COPYRIGHT--,BSD,BSD
N * Copyright (c) 2016, Texas Instruments Incorporated
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N *
N * *  Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N *
N * *  Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * *  Neither the name of Texas Instruments Incorporated nor the names of
N *    its contributors may be used to endorse or promote products derived
N *    from this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
N * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
N * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
N * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
N * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
N * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
N * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
N * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
N * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * --/COPYRIGHT--*/
N#ifndef __REF_B_H__
N#define __REF_B_H__
N
N//*****************************************************************************
N//
N//! \addtogroup ref_api
N//! @{
N//
N//*****************************************************************************
N
N#include <msp.h>
N#include <stdbool.h>
N#include <stdint.h>
N
N//*****************************************************************************
N//
N// If building with a C++ compiler, make all of the definitions in this header
N// have a C binding.
N//
N//*****************************************************************************
N#ifdef __cplusplus
Nextern "C"
N{
N#endif
N
N//*****************************************************************************
N//
N//The following are values that can be passed to Ref_setReferenceVoltage()
N//in the referenceVoltageSelect parameter.
N//
N//*****************************************************************************
N#define REF_A_VREF1_2V  REF_A_CTL0_VSEL_0
N#define REF_A_VREF1_45V REF_A_CTL0_VSEL_1
N#define REF_A_VREF2_5V  REF_A_CTL0_VSEL_3
N
N//*****************************************************************************
N//
N//The following are values that are returned by Ref_getBandgapMode().
N//
N//*****************************************************************************
N#define REF_A_STATICMODE 0x0
N#define REF_A_SAMPLEMODE REF_A_CTL0_BGMODE
N
N//*****************************************************************************
N//
N//! Sets the reference voltage for the voltage generator.
N//!
N//! \param referenceVoltageSelect is the desired voltage to generate for a
N//!       reference voltage.
N//!        Valid values are:
N//!        - \b REF_A_VREF1_2V [Default]
N//!        - \b REF_A_VREF1_45V
N//!        - \b REF_A_VREF2_5V
N//!        Modified bits are \b REFVSEL of \b REFCTL0 register.
N//!
N//! This function sets the reference voltage generated by the voltage generator
N//! to be used by other peripherals. This reference voltage will only be valid
N//! while the REF module is in control.
N//! Please note, if the \link REF_A_isRefGenBusy() \endlink returns \b REF_BUSY,
N//! this function  will have no effect.
N//!
N//! \return none
N//
N//*****************************************************************************
Nextern void REF_A_setReferenceVoltage(uint_fast8_t referenceVoltageSelect);
N
N//*****************************************************************************
N//
N//! Disables the internal temperature sensor to save power consumption.
N//!
N//! This function is used to turn off the internal temperature sensor to save
N//! on power consumption. The temperature sensor is enabled by default. Please
N//! note, that giving ADC12 module control over the REF module, the state of the
N//! temperature sensor is dependent on the controls of the ADC12 module.
N//! Please note, if the \link REF_A_isRefGenBusy() \endlink  returns
N//! \b REF_A_BUSY, this function will have no effect.
N//!
N//! Modified bits are \b REFTCOFF of \b REFCTL0 register.
N//! \return none
N//
N//*****************************************************************************
Nextern void REF_A_disableTempSensor(void);
N
N//*****************************************************************************
N//
N//! Enables the internal temperature sensor.
N//!
N//! This function is used to turn on the internal temperature sensor to use by
N//! other peripherals. The temperature sensor is enabled by default.
N//! Please note, if the \link REF_A_isRefGenBusy() \endlink returns
N//! \b REF_A_BUSY, this function will have no effect.
N//!
N//! Modified bits are \b REFTCOFF of \b REFCTL0 register.
N//!
N//! \return none
N//
N//*****************************************************************************
Nextern void REF_A_enableTempSensor(void);
N
N//*****************************************************************************
N//
N//! Outputs the reference voltage to an output pin.
N//!
N//! This function is used to output the reference voltage being generated to an
N//! output pin. Please note, the output pin is device specific. Please note,
N//! that giving ADC12 module control over the REF module, the state of the
N//! reference voltage as an output to a pin is dependent on the controls of the
N//! ADC12 module.
N//! Please note, if the \link REF_A_isRefGenBusy() \endlink returns
N//! \b REF_A_BUSY, this function will have no effect.
N//!
N//! Modified bits are \b REFOUT of \b REFCTL0 register.
N//! \return none
N//
N//*****************************************************************************
Nextern void REF_A_enableReferenceVoltageOutput(void);
N
N//*****************************************************************************
N//
N//! Disables the reference voltage as an output to a pin.
N//!
N//! This function is used to disables the reference voltage being generated to
N//! be given to an output pin.
N//! Please note, if the \link REF_A_isRefGenBusy() \endlink returns
N//! \b REF_A_BUSY, this function will have no effect.
N//!
N//! Modified bits are \b REFOUT of \b REFCTL0 register.
N//! \return none
N//
N//*****************************************************************************
Nextern void REF_A_disableReferenceVoltageOutput(void);
N
N//*****************************************************************************
N//
N//! Enables the reference voltage to be used by peripherals.
N//!
N//! This function is used to enable the generated reference voltage to be used
N//! other peripherals or by an output pin, if enabled. Please note, that giving
N//! ADC12 module control over the REF module, the state of the reference voltage
N//! is dependent on the controls of the ADC12 module.
N//! Please note, if the \link REF_A_isRefGenBusy() \endlink returns
N//! REF_A_BUSY, this function will have no effect.
N//!
N//! Modified bits are \b REFON of \b REFCTL0 register.
N//! \return none
N//
N//*****************************************************************************
Nextern void REF_A_enableReferenceVoltage(void);
N
N//*****************************************************************************
N//
N//! Disables the reference voltage.
N//!
N//! This function is used to disable the generated reference voltage.
N//! Please note, if the \link REF_A_isRefGenBusy() \endlink returns
N//!  \b  REF_A_BUSY, this function will have no effect.
N//!
N//! Modified bits are \b REFON of \b REFCTL0 register.
N//! \return none
N//
N//*****************************************************************************
Nextern void REF_A_disableReferenceVoltage(void);
N
N//*****************************************************************************
N//
N//! Returns the bandgap mode of the REF module.
N//!
N//! This function is used to return the bandgap mode of the REF module,
N//! requested by the peripherals using the bandgap. If a peripheral requests
N//! static mode, then the bandgap mode will be static for all modules, whereas
N//! if all of the peripherals using the bandgap request sample mode, then that
N//! will be the mode returned. Sample mode allows the bandgap to be active only
N//! when necessary to save on power consumption, static mode requires the
N//! bandgap to be active until no peripherals are using it anymore.
N//!
N//! \return The bandgap mode of the REF module:
N//!        - \b REF_A_STATICMODE if the bandgap is operating in static mode
N//!        - \b REF_A_SAMPLEMODE if the bandgap is operating in sample mode
N//
N//*****************************************************************************
Nextern uint_fast8_t REF_A_getBandgapMode(void);
N
N//*****************************************************************************
N//
N//! Returns the active status of the bandgap in the REF module.
N//!
N//! This function is used to return the active status of the bandgap in the REF
N//! module. If the bandgap is in use by a peripheral, then the status will be
N//! seen as active.
N//!
N//! \return true if the bandgap is being used, false otherwise
N//
N//*****************************************************************************
Nextern bool REF_A_isBandgapActive(void);
N
N//*****************************************************************************
N//
N//! Returns the busy status of the reference generator in the REF module.
N//!
N//! This function is used to return the busy status of the reference generator
N//! in the REF module. If the ref. generator is in use by a peripheral, then the
N//! status will be seen as busy.
N//!
N//! \return true if the reference generator is being used, false otherwise.
N//*****************************************************************************
Nextern bool REF_A_isRefGenBusy(void);
N
N//*****************************************************************************
N//
N//! Returns the active status of the reference generator in the REF module.
N//!
N//! This function is used to return the active status of the reference generator
N//! in the REF module. If the ref. generator is on and ready to use, then the
N//! status will be seen as active.
N//!
N//! \return true if the reference generator is active, false otherwise.
N//
N//*****************************************************************************
Nextern bool REF_A_isRefGenActive(void);
N
N//*****************************************************************************
N//
N//! Returns the busy status of the reference generator in the REF module.
N//!
N//! This function is used to return the buys status of the buffered bandgap
N//! voltage in the REF module. If the ref. generator is on and ready to use,
N//! then the status will be seen as active.
N//!
N//! \return true if the buffered bandgap voltage is ready to be used, false
N//!         otherwise
N//
N//*****************************************************************************
Nextern bool REF_A_getBufferedBandgapVoltageStatus(void);
N
N//*****************************************************************************
N//
N//! Returns the busy status of the variable reference voltage in the REF module.
N//!
N//! This function is used to return the buys status of the variable reference
N//! voltage in the REF module. If the ref. generator is on and ready to use,
N//! then the status will be seen as active.
N//!
N//! \return true if the variable bandgap voltage is ready to be used, false
N//!         otherwise
N//
N//*****************************************************************************
Nextern bool REF_A_getVariableReferenceVoltageStatus(void);
N
N//*****************************************************************************
N//
N//! Enables the one-time trigger of the reference voltage.
N//!
N//! Triggers the one-time generation of the variable reference voltage.  Once
N//! the reference voltage request is set, this bit is cleared by hardware
N//!
N//! Modified bits are \b REFGENOT of \b REFCTL0 register.
N//!
N//! \return none
N//
N//*****************************************************************************
Nextern void REF_A_setReferenceVoltageOneTimeTrigger(void);
N
N//*****************************************************************************
N//
N//! Enables the one-time trigger of the buffered bandgap voltage.
N//!
N//! Triggers the one-time generation of the buffered bandgap voltage.  Once
N//! the buffered bandgap voltage request is set, this bit is cleared by hardware
N//!
N//! Modified bits are \b RefGOT of \b REFCTL0 register.
N//!
N//! \return none
N//
N//*****************************************************************************
Nextern void REF_A_setBufferedBandgapVoltageOneTimeTrigger(void);
N
N/* Defines for future devices that might have multiple instances */
N#define REF_A_setReferenceVoltageMultipleInstance(a,b) REF_A_setReferenceVoltage(b)
N#define REF_A_disableTempSensorMultipleInstance(a) REF_A_disableTempSensor()
N#define REF_A_enableTempSensorMultipleInstance(a) REF_A_enableTempSensor()
N#define REF_A_enableReferenceVoltageOutputMultipleInstance(a) REF_A_enableReferenceVoltageOutput()
N#define REF_A_disableReferenceVoltageOutputMultipleInstance(a) REF_A_disableReferenceVoltageOutput()
N#define REF_A_enableReferenceVoltageMultipleInstance(a) REF_A_enableReferenceVoltage()
N#define REF_A_disableReferenceVoltageMultipleInstance(a) REF_A_disableReferenceVoltage()
N#define REF_A_getBandgapModeMultipleInstance(a) REF_A_getBandgapMode()
N#define REF_A_isBandgapActiveMultipleInstance(a) REF_A_isBandgapActive()
N#define REF_A_isRefGenBusyMultipleInstance(a) REF_A_isRefGenBusy()
N#define REF_A_isRefGenActiveMultipleInstance(a) REF_A_isRefGenActive()
N#define REF_A_getBufferedBandgapVoltageStatusMultipleInstance(a) REF_A_getBufferedBandgapVoltageStatus()
N#define REF_A_getVariableReferenceVoltageStatusMultipleInstance(a) REF_A_getVariableReferenceVoltageStatus()
N#define REF_A_setReferenceVoltageOneTimeTriggerMultipleInstance(a) REF_A_setReferenceVoltageOneTimeTrigger()
N#define REF_A_setBufferedBandgapVoltageOneTimeTriggerMultipleInstance(a) REF_A_setBufferedBandgapVoltageOneTimeTrigger()
N
N//*****************************************************************************
N//
N// Mark the end of the C bindings section for C++ compilers.
N//
N//*****************************************************************************
N#ifdef __cplusplus
N}
N#endif
N
N//*****************************************************************************
N//
N// Close the Doxygen group.
N//! @}
N//
N//*****************************************************************************
N
N#endif // __REF_A_H__
L 58 "C:/ti/msp432_driverlib_3_21_00_05/driverlib/MSP432P4xx/driverlib.h" 2
N#include "reset.h"
L 1 "C:\ti\msp432_driverlib_3_21_00_05\driverlib\MSP432P4xx\reset.h" 1
N/*
N * -------------------------------------------
N *    MSP432 DriverLib - v3_21_00_05 
N * -------------------------------------------
N *
N * --COPYRIGHT--,BSD,BSD
N * Copyright (c) 2016, Texas Instruments Incorporated
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N *
N * *  Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N *
N * *  Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * *  Neither the name of Texas Instruments Incorporated nor the names of
N *    its contributors may be used to endorse or promote products derived
N *    from this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
N * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
N * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
N * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
N * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
N * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
N * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
N * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
N * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * --/COPYRIGHT--*/
N#ifndef __RESET_H__
N#define __RESET_H__
N
N//*****************************************************************************
N//
N//! \addtogroup reset_api
N//! @{
N//
N//*****************************************************************************
N
N//*****************************************************************************
N//
N// If building with a C++ compiler, make all of the definitions in this header
N// have a C binding.
N//
N//*****************************************************************************
N#ifdef __cplusplus
Nextern "C"
N{
N#endif
N
N#include <msp.h>
N#include <stdint.h>
N
N//*****************************************************************************
N//
N// Control specific variables 
N//
N//*****************************************************************************
N#define RESET_KEY   0x6900
N#define RESET_HARD_RESET RSTCTL_RESET_REQ_HARD_REQ
N#define RESET_SOFT_RESET RSTCTL_RESET_REQ_SOFT_REQ
N
N#define RESET_SRC_0 RSTCTL_HARDRESET_CLR_SRC0
N#define RESET_SRC_1 RSTCTL_HARDRESET_CLR_SRC1
N#define RESET_SRC_2 RSTCTL_HARDRESET_CLR_SRC2
N#define RESET_SRC_3 RSTCTL_HARDRESET_CLR_SRC3
N#define RESET_SRC_4 RSTCTL_HARDRESET_CLR_SRC4
N#define RESET_SRC_5 RSTCTL_HARDRESET_CLR_SRC5
N#define RESET_SRC_6 RSTCTL_HARDRESET_CLR_SRC6
N#define RESET_SRC_7 RSTCTL_HARDRESET_CLR_SRC7
N#define RESET_SRC_8 RSTCTL_HARDRESET_CLR_SRC8
N#define RESET_SRC_9 RSTCTL_HARDRESET_CLR_SRC9
N#define RESET_SRC_10 RSTCTL_HARDRESET_CLR_SRC10
N#define RESET_SRC_11 RSTCTL_HARDRESET_CLR_SRC11
N#define RESET_SRC_12 RSTCTL_HARDRESET_CLR_SRC12
N#define RESET_SRC_13 RSTCTL_HARDRESET_CLR_SRC13
N#define RESET_SRC_14 RSTCTL_HARDRESET_CLR_SRC14
N#define RESET_SRC_15 RSTCTL_HARDRESET_CLR_SRC15
N
N#define RESET_VCCDET    RSTCTL_PSSRESET_CLR_BGREF
N#define RESET_SVSH_TRIP RSTCTL_PSSRESET_CLR_SVSMH
N#define RESET_BGREF_BAD RSTCTL_PSSRESET_CLR_BGREF
N
N#define RESET_LPM35   RSTCTL_PCMRESET_CLR_LPM35
N#define RESET_LPM45   RSTCTL_PCMRESET_CLR_LPM45
N
N//*****************************************************************************
N//
N// Prototypes for the APIs.
N//
N//*****************************************************************************
N
N//*****************************************************************************
N//
N//! Initiates a soft system reset.
N//!
N//! \return none
N//
N//*****************************************************************************
Nextern void ResetCtl_initiateSoftReset(void);
N
N//*****************************************************************************
N//
N//! Initiates a soft system reset with a particular source given. This source
N//! is generic and can be assigned by the user.
N//!
N//! \param source Source of the reset. Valid values are:
N//!             - \b RESET_SRC_0,
N//!             - \b RESET_SRC_1,
N//!             - \b RESET_SRC_2,
N//!             - \b RESET_SRC_3,
N//!             - \b RESET_SRC_4,
N//!             - \b RESET_SRC_5,
N//!             - \b RESET_SRC_6,
N//!             - \b RESET_SRC_7,
N//!             - \b RESET_SRC_8,
N//!             - \b RESET_SRC_9,
N//!             - \b RESET_SRC_10,
N//!             - \b RESET_SRC_11,
N//!             - \b RESET_SRC_12,
N//!             - \b RESET_SRC_13,
N//!             - \b RESET_SRC_14,
N//!             - \b RESET_SRC_15
N//!
N//! \return none
N//
N//*****************************************************************************
Nextern void ResetCtl_initiateSoftResetWithSource(uint32_t source);
N
N//*****************************************************************************
N//
N//! Retrieves previous soft reset sources
N//!
N//! \return the bitwise or of previous reset sources. These sources must be
N//! cleared using the \link ResetCtl_clearSoftResetSource \endlink function to
N//! be cleared.
N//! Possible values include:
N//!             - \b RESET_SRC_0,
N//!             - \b RESET_SRC_1,
N//!             - \b RESET_SRC_2,
N//!             - \b RESET_SRC_3,
N//!             - \b RESET_SRC_4,
N//!             - \b RESET_SRC_5,
N//!             - \b RESET_SRC_6,
N//!             - \b RESET_SRC_7,
N//!             - \b RESET_SRC_8,
N//!             - \b RESET_SRC_9,
N//!             - \b RESET_SRC_10,
N//!             - \b RESET_SRC_11,
N//!             - \b RESET_SRC_12,
N//!             - \b RESET_SRC_13,
N//!             - \b RESET_SRC_14,
N//!             - \b RESET_SRC_15
N//
N//*****************************************************************************
Nextern uint32_t ResetCtl_getSoftResetSource(void);
N
N//*****************************************************************************
N//
N//! Clears the reset sources associated with at soft reset
N//!
N//! \param mask - Bitwise OR of any of the following values:
N//!             - \b RESET_SRC_0,
N//!             - \b RESET_SRC_1,
N//!             - \b RESET_SRC_2,
N//!             - \b RESET_SRC_3,
N//!             - \b RESET_SRC_4,
N//!             - \b RESET_SRC_5,
N//!             - \b RESET_SRC_6,
N//!             - \b RESET_SRC_7,
N//!             - \b RESET_SRC_8,
N//!             - \b RESET_SRC_9,
N//!             - \b RESET_SRC_10,
N//!             - \b RESET_SRC_11,
N//!             - \b RESET_SRC_12,
N//!             - \b RESET_SRC_13,
N//!             - \b RESET_SRC_14,
N//!             - \b RESET_SRC_15
N//!
N//! \return none
N//
N//*****************************************************************************
Nextern void ResetCtl_clearSoftResetSource(uint32_t mask);
N
N//*****************************************************************************
N//
N//! Initiates a hard system reset.
N//!
N//! \return none
N//
N//*****************************************************************************
Nextern void ResetCtl_initiateHardReset(void);
N
N//*****************************************************************************
N//
N//! Initiates a hard system reset with a particular source given. This source
N//! is generic and can be assigned by the user.
N//!
N//! \param source - Valid values are one the following values:
N//!             - \b RESET_SRC_0,
N//!             - \b RESET_SRC_1,
N//!             - \b RESET_SRC_2,
N//!             - \b RESET_SRC_3,
N//!             - \b RESET_SRC_4,
N//!             - \b RESET_SRC_5,
N//!             - \b RESET_SRC_6,
N//!             - \b RESET_SRC_7,
N//!             - \b RESET_SRC_8,
N//!             - \b RESET_SRC_9,
N//!             - \b RESET_SRC_10,
N//!             - \b RESET_SRC_11,
N//!             - \b RESET_SRC_12,
N//!             - \b RESET_SRC_13,
N//!             - \b RESET_SRC_14,
N//!             - \b RESET_SRC_15
N//! \return none
N//
N//*****************************************************************************
Nextern void ResetCtl_initiateHardResetWithSource(uint32_t source);
N
N//*****************************************************************************
N//
N//! Retrieves previous hard reset sources
N//!
N//! \return the bitwise or of previous reset sources. These sources must be
N//! cleared using the \link ResetCtl_clearHardResetSource \endlink function to
N//! be cleared.
N//! Possible values include:
N//!             - \b RESET_SRC_0,
N//!             - \b RESET_SRC_1,
N//!             - \b RESET_SRC_2,
N//!             - \b RESET_SRC_3,
N//!             - \b RESET_SRC_4,
N//!             - \b RESET_SRC_5,
N//!             - \b RESET_SRC_6,
N//!             - \b RESET_SRC_7,
N//!             - \b RESET_SRC_8,
N//!             - \b RESET_SRC_9,
N//!             - \b RESET_SRC_10,
N//!             - \b RESET_SRC_11,
N//!             - \b RESET_SRC_12,
N//!             - \b RESET_SRC_13,
N//!             - \b RESET_SRC_14,
N//!             - \b RESET_SRC_15
N//
N//*****************************************************************************
Nextern uint32_t ResetCtl_getHardResetSource(void);
N
N//*****************************************************************************
N//
N//! Clears the reset sources associated with at hard reset
N//!
N//! \param mask - Bitwise OR of any of the following values:
N//!             - \b RESET_SRC_0,
N//!             - \b RESET_SRC_1,
N//!             - \b RESET_SRC_2,
N//!             - \b RESET_SRC_3,
N//!             - \b RESET_SRC_4,
N//!             - \b RESET_SRC_5,
N//!             - \b RESET_SRC_6,
N//!             - \b RESET_SRC_7,
N//!             - \b RESET_SRC_8,
N//!             - \b RESET_SRC_9,
N//!             - \b RESET_SRC_10,
N//!             - \b RESET_SRC_11,
N//!             - \b RESET_SRC_12,
N//!             - \b RESET_SRC_13,
N//!             - \b RESET_SRC_14,
N//!             - \b RESET_SRC_15
N//!
N//! \return none
N//
N//*****************************************************************************
Nextern void ResetCtl_clearHardResetSource(uint32_t mask);
N
N//*****************************************************************************
N//
N//! Indicates the last cause of a power-on reset (POR) due to PSS operation.
N//! Note that the bits returned from this function may be set in different
N//! combinations. When a cold power up occurs, the value of all the values ORed
N//! together could be returned as a cold power up causes these conditions.
N//!
N//! \return  Bitwise OR of any of the following values:
N//!                 - RESET_VCCDET,
N//!                 - RESET_SVSH_TRIP,
N//!                 - RESET_BGREF_BAD
N//
N//*****************************************************************************
Nextern uint32_t ResetCtl_getPSSSource(void);
N
N//*****************************************************************************
N//
N//! Clears the  PSS reset source flags
N//!
N//! \return none
N//
N//*****************************************************************************
Nextern void ResetCtl_clearPSSFlags(void);
N
N//*****************************************************************************
N//
N//! Indicates the last cause of a power-on reset (POR) due to PCM operation.
N//!
N//! \return  Bitwise OR of any of the following values:
N//!                 - RESET_LPM35,
N//!                 - RESET_LPM45
N//
N//*****************************************************************************
Nextern uint32_t ResetCtl_getPCMSource(void);
N
N//*****************************************************************************
N//
N//! Clears the corresponding PCM reset source flags
N//!
N//! \return none
N//
N//*****************************************************************************
Nextern void ResetCtl_clearPCMFlags(void);
N
N//*****************************************************************************
N//
N// Mark the end of the C bindings section for C++ compilers.
N//
N//*****************************************************************************
N#ifdef __cplusplus
N}
N#endif
N
N//*****************************************************************************
N//
N// Close the Doxygen group.
N//! @}
N//
N//*****************************************************************************
N
N#endif // __RESET_H__
L 59 "C:/ti/msp432_driverlib_3_21_00_05/driverlib/MSP432P4xx/driverlib.h" 2
N#include "rom.h"
L 1 "C:\ti\msp432_driverlib_3_21_00_05\driverlib\MSP432P4xx\rom.h" 1
N/*
N * -------------------------------------------
N *    MSP432 DriverLib - v3_21_00_05 
N * -------------------------------------------
N *
N * --COPYRIGHT--,BSD,BSD
N * Copyright (c) 2016, Texas Instruments Incorporated
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N *
N * *  Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N *
N * *  Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * *  Neither the name of Texas Instruments Incorporated nor the names of
N *    its contributors may be used to endorse or promote products derived
N *    from this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
N * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
N * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
N * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
N * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
N * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
N * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
N * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
N * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * --/COPYRIGHT--*/
N#ifndef __ROM_H__
N#define __ROM_H__
N
N//*****************************************************************************
N//
N// Pointers to the main API tables.
N//
N//*****************************************************************************
N#define ROM_APITABLE            ((unsigned long *)0x02000800)
N#define ROM_VERSION             (ROM_APITABLE[0])
N#define ROM_ADC14TABLE          ((unsigned long *)(ROM_APITABLE[1]))
N#define ROM_AES256TABLE         ((unsigned long *)(ROM_APITABLE[2]))
N#define ROM_COMPTABLE           ((unsigned long *)(ROM_APITABLE[3]))
N#define ROM_CRC32TABLE          ((unsigned long *)(ROM_APITABLE[4]))
N#define ROM_CSTABLE             ((unsigned long *)(ROM_APITABLE[5]))
N#define ROM_DMATABLE            ((unsigned long *)(ROM_APITABLE[6]))
N#define ROM_FLASHCTLTABLE       ((unsigned long *)(ROM_APITABLE[7]))
N#define ROM_FPUTABLE            ((unsigned long *)(ROM_APITABLE[8]))
N#define ROM_GPIOTABLE           ((unsigned long *)(ROM_APITABLE[9]))
N#define ROM_I2CTABLE            ((unsigned long *)(ROM_APITABLE[10]))
N#define ROM_INTTABLE            ((unsigned long *)(ROM_APITABLE[11]))
N#define ROM_MPUTABLE            ((unsigned long *)(ROM_APITABLE[12]))
N#define ROM_PCMTABLE            ((unsigned long *)(ROM_APITABLE[13]))
N#define ROM_PMAPTABLE           ((unsigned long *)(ROM_APITABLE[14]))
N#define ROM_PSSTABLE            ((unsigned long *)(ROM_APITABLE[15]))
N#define ROM_REFTABLE            ((unsigned long *)(ROM_APITABLE[16]))
N#define ROM_RESETCTLTABLE       ((unsigned long *)(ROM_APITABLE[17]))
N#define ROM_RTCTABLE            ((unsigned long *)(ROM_APITABLE[18]))
N#define ROM_SPITABLE            ((unsigned long *)(ROM_APITABLE[19]))
N#define ROM_SYSCTLTABLE         ((unsigned long *)(ROM_APITABLE[20]))
N#define ROM_SYSTICKTABLE        ((unsigned long *)(ROM_APITABLE[21]))
N#define ROM_TIMER_ATABLE        ((unsigned long *)(ROM_APITABLE[22]))
N#define ROM_TIMER32TABLE        ((unsigned long *)(ROM_APITABLE[23]))
N#define ROM_UARTTABLE           ((unsigned long *)(ROM_APITABLE[24]))
N#define ROM_WDTTABLE            ((unsigned long *)(ROM_APITABLE[25]))
N
N//*****************************************************************************
N//
N// Macros for calling ROM functions in the ADC14 API.
N//
N//*****************************************************************************
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_ADC14_enableModule                                                \
S        ((void (*)(void))ROM_ADC14TABLE[0])
X#define ROM_ADC14_enableModule                                                        ((void (*)(void))ROM_ADC14TABLE[0])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_ADC14_disableModule                                               \
S        ((bool (*)(void))ROM_ADC14TABLE[1])
X#define ROM_ADC14_disableModule                                                       ((bool (*)(void))ROM_ADC14TABLE[1])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_ADC14_initModule                                                  \
S        ((bool (*)(uint32_t clockSource,                                      \
S                   uint32_t clockPredivider,                                  \
S                   uint32_t clockDivider,                                     \
S                   uint32_t internalChannelMask))ROM_ADC14TABLE[2])
X#define ROM_ADC14_initModule                                                          ((bool (*)(uint32_t clockSource,                                                         uint32_t clockPredivider,                                                     uint32_t clockDivider,                                                        uint32_t internalChannelMask))ROM_ADC14TABLE[2])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_ADC14_setResolution                                               \
S        ((void (*)(uint32_t resolution))ROM_ADC14TABLE[3])
X#define ROM_ADC14_setResolution                                                       ((void (*)(uint32_t resolution))ROM_ADC14TABLE[3])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_ADC14_getResolution                                               \
S        ((uint_fast32_t (*)(void))ROM_ADC14TABLE[4])
X#define ROM_ADC14_getResolution                                                       ((uint_fast32_t (*)(void))ROM_ADC14TABLE[4])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_ADC14_setSampleHoldTrigger                                        \
S        ((bool (*)(uint32_t source,                                           \
S                   bool invertSignal))ROM_ADC14TABLE[5])
X#define ROM_ADC14_setSampleHoldTrigger                                                ((bool (*)(uint32_t source,                                                              bool invertSignal))ROM_ADC14TABLE[5])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_ADC14_setSampleHoldTime                                           \
S        ((bool (*)(uint32_t firstPulseWidth,                                  \
S                   uint32_t secondPulseWidth))ROM_ADC14TABLE[6])
X#define ROM_ADC14_setSampleHoldTime                                                   ((bool (*)(uint32_t firstPulseWidth,                                                     uint32_t secondPulseWidth))ROM_ADC14TABLE[6])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_ADC14_configureMultiSequenceMode                                  \
S        ((bool (*)(uint32_t memoryStart,                                      \
S                   uint32_t memoryEnd,                                        \
S                   bool repeatMode))ROM_ADC14TABLE[7])
X#define ROM_ADC14_configureMultiSequenceMode                                          ((bool (*)(uint32_t memoryStart,                                                         uint32_t memoryEnd,                                                           bool repeatMode))ROM_ADC14TABLE[7])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_ADC14_configureSingleSampleMode                                   \
S        ((bool (*)(uint32_t memoryDestination,                                \
S                   bool repeatMode))ROM_ADC14TABLE[8])
X#define ROM_ADC14_configureSingleSampleMode                                           ((bool (*)(uint32_t memoryDestination,                                                   bool repeatMode))ROM_ADC14TABLE[8])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_ADC14_enableConversion                                            \
S        ((bool (*)(void))ROM_ADC14TABLE[9])
X#define ROM_ADC14_enableConversion                                                    ((bool (*)(void))ROM_ADC14TABLE[9])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_ADC14_disableConversion                                           \
S        ((void (*)(void))ROM_ADC14TABLE[10])
X#define ROM_ADC14_disableConversion                                                   ((void (*)(void))ROM_ADC14TABLE[10])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_ADC14_isBusy                                                      \
S        ((bool (*)(void))ROM_ADC14TABLE[11])
X#define ROM_ADC14_isBusy                                                              ((bool (*)(void))ROM_ADC14TABLE[11])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_ADC14_configureConversionMemory                                   \
S        ((bool (*)(uint32_t memorySelect,                                     \
S                   uint32_t refSelect,                                        \
S                   uint32_t channelSelect,                                    \
S                   bool differntialMode))ROM_ADC14TABLE[12])
X#define ROM_ADC14_configureConversionMemory                                           ((bool (*)(uint32_t memorySelect,                                                        uint32_t refSelect,                                                           uint32_t channelSelect,                                                       bool differntialMode))ROM_ADC14TABLE[12])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_ADC14_enableComparatorWindow                                      \
S        ((bool (*)(uint32_t memorySelect,                                     \
S                   uint32_t windowSelect))ROM_ADC14TABLE[13])
X#define ROM_ADC14_enableComparatorWindow                                              ((bool (*)(uint32_t memorySelect,                                                        uint32_t windowSelect))ROM_ADC14TABLE[13])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_ADC14_disableComparatorWindow                                     \
S        ((bool (*)(uint32_t memorySelect))ROM_ADC14TABLE[14])
X#define ROM_ADC14_disableComparatorWindow                                             ((bool (*)(uint32_t memorySelect))ROM_ADC14TABLE[14])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_ADC14_setComparatorWindowValue                                    \
S        ((bool (*)(uint32_t window,                                           \
S                   int16_t low,                                               \
S                   int16_t high))ROM_ADC14TABLE[15])
X#define ROM_ADC14_setComparatorWindowValue                                            ((bool (*)(uint32_t window,                                                              int16_t low,                                                                  int16_t high))ROM_ADC14TABLE[15])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_ADC14_setResultFormat                                             \
S        ((bool (*)(uint32_t resultFormat))ROM_ADC14TABLE[16])
X#define ROM_ADC14_setResultFormat                                                     ((bool (*)(uint32_t resultFormat))ROM_ADC14TABLE[16])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_ADC14_getResult                                                   \
S        ((uint_fast16_t (*)(uint32_t memorySelect))ROM_ADC14TABLE[17])
X#define ROM_ADC14_getResult                                                           ((uint_fast16_t (*)(uint32_t memorySelect))ROM_ADC14TABLE[17])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_ADC14_getResultArray                                              \
S        ((void (*)(uint32_t memoryStart,                                      \
S                   uint32_t memoryEnd,                                        \
S                   uint16_t* res))ROM_ADC14TABLE[19])
X#define ROM_ADC14_getResultArray                                                      ((void (*)(uint32_t memoryStart,                                                         uint32_t memoryEnd,                                                           uint16_t* res))ROM_ADC14TABLE[19])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_ADC14_enableReferenceBurst                                        \
S        ((bool (*)(void))ROM_ADC14TABLE[20])
X#define ROM_ADC14_enableReferenceBurst                                                ((bool (*)(void))ROM_ADC14TABLE[20])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_ADC14_disableReferenceBurst                                       \
S        ((bool (*)(void))ROM_ADC14TABLE[21])
X#define ROM_ADC14_disableReferenceBurst                                               ((bool (*)(void))ROM_ADC14TABLE[21])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_ADC14_setPowerMode                                                \
S        ((bool (*)(uint32_t powerMode))ROM_ADC14TABLE[22])
X#define ROM_ADC14_setPowerMode                                                        ((bool (*)(uint32_t powerMode))ROM_ADC14TABLE[22])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_ADC14_enableInterrupt                                             \
S        ((void (*)(uint_fast64_t mask))ROM_ADC14TABLE[23])
X#define ROM_ADC14_enableInterrupt                                                     ((void (*)(uint_fast64_t mask))ROM_ADC14TABLE[23])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_ADC14_disableInterrupt                                            \
S        ((void (*)(uint_fast64_t mask))ROM_ADC14TABLE[24])
X#define ROM_ADC14_disableInterrupt                                                    ((void (*)(uint_fast64_t mask))ROM_ADC14TABLE[24])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_ADC14_getInterruptStatus                                          \
S        ((uint_fast64_t (*)(void))ROM_ADC14TABLE[25])
X#define ROM_ADC14_getInterruptStatus                                                  ((uint_fast64_t (*)(void))ROM_ADC14TABLE[25])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_ADC14_getEnabledInterruptStatus                                   \
S        ((uint_fast64_t (*)(void))ROM_ADC14TABLE[26])
X#define ROM_ADC14_getEnabledInterruptStatus                                           ((uint_fast64_t (*)(void))ROM_ADC14TABLE[26])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_ADC14_clearInterruptFlag                                          \
S        ((void (*)(uint_fast64_t mask))ROM_ADC14TABLE[27])
X#define ROM_ADC14_clearInterruptFlag                                                  ((void (*)(uint_fast64_t mask))ROM_ADC14TABLE[27])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_ADC14_toggleConversionTrigger                                     \
S        ((bool (*)(void))ROM_ADC14TABLE[28])
X#define ROM_ADC14_toggleConversionTrigger                                             ((bool (*)(void))ROM_ADC14TABLE[28])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_ADC14_enableSampleTimer                                           \
S        ((bool (*)(uint32_t multiSampleConvert))ROM_ADC14TABLE[29])
X#define ROM_ADC14_enableSampleTimer                                                   ((bool (*)(uint32_t multiSampleConvert))ROM_ADC14TABLE[29])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_ADC14_disableSampleTimer                                          \
S        ((bool (*)(void))ROM_ADC14TABLE[30])
X#define ROM_ADC14_disableSampleTimer                                                  ((bool (*)(void))ROM_ADC14TABLE[30])
N#endif
N
N//*****************************************************************************
N//
N// Macros for calling ROM functions in the AES256 API.
N//
N//*****************************************************************************
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_AES256_setCipherKey                                               \
S        ((bool (*)(uint32_t moduleInstance,                                   \
S                   const uint8_t *cipherKey,                                  \
S                   uint_fast16_t keyLength))ROM_AES256TABLE[0])
X#define ROM_AES256_setCipherKey                                                       ((bool (*)(uint32_t moduleInstance,                                                      const uint8_t *cipherKey,                                                     uint_fast16_t keyLength))ROM_AES256TABLE[0])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_AES256_encryptData                                                \
S        ((void (*)(uint32_t moduleInstance,                                   \
S                   const uint8_t *data,                                       \
S                   uint8_t *encryptedData))ROM_AES256TABLE[1])
X#define ROM_AES256_encryptData                                                        ((void (*)(uint32_t moduleInstance,                                                      const uint8_t *data,                                                          uint8_t *encryptedData))ROM_AES256TABLE[1])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_AES256_decryptData                                                \
S        ((void (*)(uint32_t moduleInstance,                                   \
S                   const uint8_t *data,                                       \
S                   uint8_t *decryptedData))ROM_AES256TABLE[2])
X#define ROM_AES256_decryptData                                                        ((void (*)(uint32_t moduleInstance,                                                      const uint8_t *data,                                                          uint8_t *decryptedData))ROM_AES256TABLE[2])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_AES256_setDecipherKey                                             \
S        ((bool (*)(uint32_t moduleInstance,                                   \
S                   const uint8_t *cipherKey,                                  \
S                   uint_fast16_t keyLength))ROM_AES256TABLE[3])
X#define ROM_AES256_setDecipherKey                                                     ((bool (*)(uint32_t moduleInstance,                                                      const uint8_t *cipherKey,                                                     uint_fast16_t keyLength))ROM_AES256TABLE[3])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_AES256_reset                                                      \
S        ((void (*)(uint32_t moduleInstance))ROM_AES256TABLE[4])
X#define ROM_AES256_reset                                                              ((void (*)(uint32_t moduleInstance))ROM_AES256TABLE[4])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_AES256_startEncryptData                                           \
S        ((void (*)(uint32_t moduleInstance,                                   \
S                   const uint8_t *data))ROM_AES256TABLE[5])
X#define ROM_AES256_startEncryptData                                                   ((void (*)(uint32_t moduleInstance,                                                      const uint8_t *data))ROM_AES256TABLE[5])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_AES256_startDecryptData                                           \
S        ((void (*)(uint32_t moduleInstance,                                   \
S                   const uint8_t *data))ROM_AES256TABLE[6])
X#define ROM_AES256_startDecryptData                                                   ((void (*)(uint32_t moduleInstance,                                                      const uint8_t *data))ROM_AES256TABLE[6])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_AES256_startSetDecipherKey                                        \
S        ((bool (*)(uint32_t moduleInstance,                                   \
S                   const uint8_t *cipherKey,                                  \
S                   uint_fast16_t keyLength))ROM_AES256TABLE[7])
X#define ROM_AES256_startSetDecipherKey                                                ((bool (*)(uint32_t moduleInstance,                                                      const uint8_t *cipherKey,                                                     uint_fast16_t keyLength))ROM_AES256TABLE[7])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_AES256_getDataOut                                                 \
S        ((bool (*)(uint32_t moduleInstance,                                   \
S                   uint8_t *outputData))ROM_AES256TABLE[8])
X#define ROM_AES256_getDataOut                                                         ((bool (*)(uint32_t moduleInstance,                                                      uint8_t *outputData))ROM_AES256TABLE[8])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_AES256_isBusy                                                     \
S        ((bool (*)(uint32_t moduleInstance))ROM_AES256TABLE[9])
X#define ROM_AES256_isBusy                                                             ((bool (*)(uint32_t moduleInstance))ROM_AES256TABLE[9])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_AES256_clearErrorFlag                                             \
S        ((void (*)(uint32_t moduleInstance))ROM_AES256TABLE[10])
X#define ROM_AES256_clearErrorFlag                                                     ((void (*)(uint32_t moduleInstance))ROM_AES256TABLE[10])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_AES256_getErrorFlagStatus                                         \
S        ((uint32_t (*)(uint32_t moduleInstance))ROM_AES256TABLE[11])
X#define ROM_AES256_getErrorFlagStatus                                                 ((uint32_t (*)(uint32_t moduleInstance))ROM_AES256TABLE[11])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_AES256_clearInterruptFlag                                         \
S        ((void (*)(uint32_t moduleInstance))ROM_AES256TABLE[12])
X#define ROM_AES256_clearInterruptFlag                                                 ((void (*)(uint32_t moduleInstance))ROM_AES256TABLE[12])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_AES256_getInterruptStatus                                         \
S        ((uint32_t (*)(uint32_t moduleInstance))ROM_AES256TABLE[13])
X#define ROM_AES256_getInterruptStatus                                                 ((uint32_t (*)(uint32_t moduleInstance))ROM_AES256TABLE[13])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_AES256_enableInterrupt                                            \
S        ((void (*)(uint32_t moduleInstance))ROM_AES256TABLE[14])
X#define ROM_AES256_enableInterrupt                                                    ((void (*)(uint32_t moduleInstance))ROM_AES256TABLE[14])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_AES256_disableInterrupt                                           \
S        ((void (*)(uint32_t moduleInstance))ROM_AES256TABLE[15])
X#define ROM_AES256_disableInterrupt                                                   ((void (*)(uint32_t moduleInstance))ROM_AES256TABLE[15])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_AES256_getInterruptFlagStatus                                     \
S        ((uint32_t (*)(uint32_t moduleInstance))ROM_AES256TABLE[18])
X#define ROM_AES256_getInterruptFlagStatus                                             ((uint32_t (*)(uint32_t moduleInstance))ROM_AES256TABLE[18])
N#endif
N
N//*****************************************************************************
N//
N// Macros for calling ROM functions in the Comp API.
N//
N//*****************************************************************************
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_COMP_E_initModule                                                 \
S        ((bool (*)(uint32_t comparator,                                       \
S                   const COMP_E_Config *config))ROM_COMPTABLE[0])
X#define ROM_COMP_E_initModule                                                         ((bool (*)(uint32_t comparator,                                                          const COMP_E_Config *config))ROM_COMPTABLE[0])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_COMP_E_setReferenceVoltage                                        \
S        ((void (*)(uint32_t comparator,                                       \
S                   uint_fast16_t supplyVoltageReferenceBase,                  \
S                   uint_fast16_t lowerLimitSupplyVoltageFractionOf32,         \
S                   uint_fast16_t upperLimitSupplyVoltageFractionOf32))ROM_COMPTABLE[1])
X#define ROM_COMP_E_setReferenceVoltage                                                ((void (*)(uint32_t comparator,                                                          uint_fast16_t supplyVoltageReferenceBase,                                     uint_fast16_t lowerLimitSupplyVoltageFractionOf32,                            uint_fast16_t upperLimitSupplyVoltageFractionOf32))ROM_COMPTABLE[1])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_COMP_E_setReferenceAccuracy                                       \
S        ((void (*)(uint32_t comparator,                                       \
S                   uint_fast16_t referenceAccuracy))ROM_COMPTABLE[2])
X#define ROM_COMP_E_setReferenceAccuracy                                               ((void (*)(uint32_t comparator,                                                          uint_fast16_t referenceAccuracy))ROM_COMPTABLE[2])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_COMP_E_setPowerMode                                               \
S        ((void (*)(uint32_t comparator,                                       \
S                   uint_fast16_t powerMode))ROM_COMPTABLE[3])
X#define ROM_COMP_E_setPowerMode                                                       ((void (*)(uint32_t comparator,                                                          uint_fast16_t powerMode))ROM_COMPTABLE[3])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_COMP_E_enableModule                                               \
S        ((void (*)(uint32_t comparator))ROM_COMPTABLE[4])
X#define ROM_COMP_E_enableModule                                                       ((void (*)(uint32_t comparator))ROM_COMPTABLE[4])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_COMP_E_disableModule                                              \
S        ((void (*)(uint32_t comparator))ROM_COMPTABLE[5])
X#define ROM_COMP_E_disableModule                                                      ((void (*)(uint32_t comparator))ROM_COMPTABLE[5])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_COMP_E_shortInputs                                                \
S        ((void (*)(uint32_t comparator))ROM_COMPTABLE[6])
X#define ROM_COMP_E_shortInputs                                                        ((void (*)(uint32_t comparator))ROM_COMPTABLE[6])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_COMP_E_unshortInputs                                              \
S        ((void (*)(uint32_t comparator))ROM_COMPTABLE[7])
X#define ROM_COMP_E_unshortInputs                                                      ((void (*)(uint32_t comparator))ROM_COMPTABLE[7])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_COMP_E_disableInputBuffer                                         \
S        ((void (*)(uint32_t comparator,                                       \
S                   uint_fast16_t inputPort))ROM_COMPTABLE[8])
X#define ROM_COMP_E_disableInputBuffer                                                 ((void (*)(uint32_t comparator,                                                          uint_fast16_t inputPort))ROM_COMPTABLE[8])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_COMP_E_enableInputBuffer                                          \
S        ((void (*)(uint32_t comparator,                                       \
S                   uint_fast16_t inputPort))ROM_COMPTABLE[9])
X#define ROM_COMP_E_enableInputBuffer                                                  ((void (*)(uint32_t comparator,                                                          uint_fast16_t inputPort))ROM_COMPTABLE[9])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_COMP_E_swapIO                                                     \
S        ((void (*)(uint32_t comparator))ROM_COMPTABLE[10])
X#define ROM_COMP_E_swapIO                                                             ((void (*)(uint32_t comparator))ROM_COMPTABLE[10])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_COMP_E_outputValue                                                \
S        ((uint8_t (*)(uint32_t comparator))ROM_COMPTABLE[11])
X#define ROM_COMP_E_outputValue                                                        ((uint8_t (*)(uint32_t comparator))ROM_COMPTABLE[11])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_COMP_E_enableInterrupt                                            \
S        ((void (*)(uint32_t comparator,                                       \
S                   uint_fast16_t mask))ROM_COMPTABLE[12])
X#define ROM_COMP_E_enableInterrupt                                                    ((void (*)(uint32_t comparator,                                                          uint_fast16_t mask))ROM_COMPTABLE[12])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_COMP_E_disableInterrupt                                           \
S        ((void (*)(uint32_t comparator,                                       \
S                   uint_fast16_t mask))ROM_COMPTABLE[13])
X#define ROM_COMP_E_disableInterrupt                                                   ((void (*)(uint32_t comparator,                                                          uint_fast16_t mask))ROM_COMPTABLE[13])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_COMP_E_clearInterruptFlag                                         \
S        ((void (*)(uint32_t comparator,                                       \
S                   uint_fast16_t mask))ROM_COMPTABLE[14])
X#define ROM_COMP_E_clearInterruptFlag                                                 ((void (*)(uint32_t comparator,                                                          uint_fast16_t mask))ROM_COMPTABLE[14])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_COMP_E_getInterruptStatus                                         \
S        ((uint_fast16_t (*)(uint32_t comparator))ROM_COMPTABLE[15])
X#define ROM_COMP_E_getInterruptStatus                                                 ((uint_fast16_t (*)(uint32_t comparator))ROM_COMPTABLE[15])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_COMP_E_getEnabledInterruptStatus                                  \
S        ((uint_fast16_t (*)(uint32_t comparator))ROM_COMPTABLE[16])
X#define ROM_COMP_E_getEnabledInterruptStatus                                          ((uint_fast16_t (*)(uint32_t comparator))ROM_COMPTABLE[16])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_COMP_E_setInterruptEdgeDirection                                  \
S        ((void (*)(uint32_t comparator,                                       \
S                   uint_fast8_t edgeDirection))ROM_COMPTABLE[17])
X#define ROM_COMP_E_setInterruptEdgeDirection                                          ((void (*)(uint32_t comparator,                                                          uint_fast8_t edgeDirection))ROM_COMPTABLE[17])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_COMP_E_toggleInterruptEdgeDirection                               \
S        ((void (*)(uint32_t comparator))ROM_COMPTABLE[18])
X#define ROM_COMP_E_toggleInterruptEdgeDirection                                       ((void (*)(uint32_t comparator))ROM_COMPTABLE[18])
N#endif
N
N//*****************************************************************************
N//
N// Macros for calling ROM functions in the CRC32 API.
N//
N//*****************************************************************************
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_CRC32_setSeed                                                     \
S        ((void (*)(uint32_t seed,                                             \
S                   uint_fast8_t crcType))ROM_CRC32TABLE[0])
X#define ROM_CRC32_setSeed                                                             ((void (*)(uint32_t seed,                                                                uint_fast8_t crcType))ROM_CRC32TABLE[0])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_CRC32_set8BitData                                                 \
S        ((void (*)(uint8_t dataIn,                                            \
S                   uint_fast8_t crcType))ROM_CRC32TABLE[1])
X#define ROM_CRC32_set8BitData                                                         ((void (*)(uint8_t dataIn,                                                               uint_fast8_t crcType))ROM_CRC32TABLE[1])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_CRC32_set16BitData                                                \
S        ((void (*)(uint16_t dataIn,                                           \
S                   uint_fast8_t crcType))ROM_CRC32TABLE[2])
X#define ROM_CRC32_set16BitData                                                        ((void (*)(uint16_t dataIn,                                                              uint_fast8_t crcType))ROM_CRC32TABLE[2])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_CRC32_set32BitData                                                \
S        ((void (*)(uint32_t dataIn))ROM_CRC32TABLE[3])
X#define ROM_CRC32_set32BitData                                                        ((void (*)(uint32_t dataIn))ROM_CRC32TABLE[3])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_CRC32_set8BitDataReversed                                         \
S        ((void (*)(uint8_t dataIn,                                            \
S                   uint_fast8_t crcType))ROM_CRC32TABLE[4])
X#define ROM_CRC32_set8BitDataReversed                                                 ((void (*)(uint8_t dataIn,                                                               uint_fast8_t crcType))ROM_CRC32TABLE[4])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_CRC32_set16BitDataReversed                                        \
S        ((void (*)(uint16_t dataIn,                                           \
S                   uint_fast8_t crcType))ROM_CRC32TABLE[5])
X#define ROM_CRC32_set16BitDataReversed                                                ((void (*)(uint16_t dataIn,                                                              uint_fast8_t crcType))ROM_CRC32TABLE[5])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_CRC32_set32BitDataReversed                                        \
S        ((void (*)(uint32_t dataIn))ROM_CRC32TABLE[6])
X#define ROM_CRC32_set32BitDataReversed                                                ((void (*)(uint32_t dataIn))ROM_CRC32TABLE[6])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_CRC32_getResult                                                   \
S        ((uint32_t (*)(uint_fast8_t crcType))ROM_CRC32TABLE[7])
X#define ROM_CRC32_getResult                                                           ((uint32_t (*)(uint_fast8_t crcType))ROM_CRC32TABLE[7])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_CRC32_getResultReversed                                           \
S        ((uint32_t (*)(uint_fast8_t crcType))ROM_CRC32TABLE[8])
X#define ROM_CRC32_getResultReversed                                                   ((uint32_t (*)(uint_fast8_t crcType))ROM_CRC32TABLE[8])
N#endif
N
N//*****************************************************************************
N//
N// Macros for calling ROM functions in the CS API.
N//
N//*****************************************************************************
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_CS_initClockSignal                                                \
S        ((void (*)(uint32_t selectedClockSignal,                              \
S                   uint32_t clockSource,                                      \
S                   uint32_t clockSourceDivider))ROM_CSTABLE[0])
X#define ROM_CS_initClockSignal                                                        ((void (*)(uint32_t selectedClockSignal,                                                 uint32_t clockSource,                                                         uint32_t clockSourceDivider))ROM_CSTABLE[0])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_CS_setReferenceOscillatorFrequency                                \
S        ((void (*)(uint8_t referenceFrequency))ROM_CSTABLE[1])
X#define ROM_CS_setReferenceOscillatorFrequency                                        ((void (*)(uint8_t referenceFrequency))ROM_CSTABLE[1])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_CS_enableClockRequest                                             \
S        ((void (*)(uint32_t selectClock))ROM_CSTABLE[2])
X#define ROM_CS_enableClockRequest                                                     ((void (*)(uint32_t selectClock))ROM_CSTABLE[2])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_CS_disableClockRequest                                            \
S        ((void (*)(uint32_t selectClock))ROM_CSTABLE[3])
X#define ROM_CS_disableClockRequest                                                    ((void (*)(uint32_t selectClock))ROM_CSTABLE[3])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_CS_setDCOCenteredFrequency                                        \
S        ((void (*)(uint32_t dcoFreq))ROM_CSTABLE[4])
X#define ROM_CS_setDCOCenteredFrequency                                                ((void (*)(uint32_t dcoFreq))ROM_CSTABLE[4])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_CS_tuneDCOFrequency                                               \
S        ((void (*)(int16_t tuneParameter))ROM_CSTABLE[5])
X#define ROM_CS_tuneDCOFrequency                                                       ((void (*)(int16_t tuneParameter))ROM_CSTABLE[5])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_CS_enableDCOExternalResistor                                      \
S        ((void (*)(void))ROM_CSTABLE[6])
X#define ROM_CS_enableDCOExternalResistor                                              ((void (*)(void))ROM_CSTABLE[6])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_CS_disableDCOExternalResistor                                     \
S        ((void (*)(void))ROM_CSTABLE[7])
X#define ROM_CS_disableDCOExternalResistor                                             ((void (*)(void))ROM_CSTABLE[7])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_CS_enableInterrupt                                                \
S        ((void (*)(uint32_t flags))ROM_CSTABLE[8])
X#define ROM_CS_enableInterrupt                                                        ((void (*)(uint32_t flags))ROM_CSTABLE[8])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_CS_disableInterrupt                                               \
S        ((void (*)(uint32_t flags))ROM_CSTABLE[9])
X#define ROM_CS_disableInterrupt                                                       ((void (*)(uint32_t flags))ROM_CSTABLE[9])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_CS_getEnabledInterruptStatus                                      \
S        ((uint32_t (*)(void))ROM_CSTABLE[10])
X#define ROM_CS_getEnabledInterruptStatus                                              ((uint32_t (*)(void))ROM_CSTABLE[10])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_CS_getInterruptStatus                                             \
S        ((uint32_t (*)(void))ROM_CSTABLE[11])
X#define ROM_CS_getInterruptStatus                                                     ((uint32_t (*)(void))ROM_CSTABLE[11])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_CS_setDCOFrequency                                                \
S        ((void (*)(uint32_t dcoFrequency))ROM_CSTABLE[12])
X#define ROM_CS_setDCOFrequency                                                        ((void (*)(uint32_t dcoFrequency))ROM_CSTABLE[12])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_CS_getDCOFrequency                                                \
S        ((uint32_t (*)(void))ROM_CSTABLE[13])
X#define ROM_CS_getDCOFrequency                                                        ((uint32_t (*)(void))ROM_CSTABLE[13])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_CS_enableFaultCounter                                             \
S        ((void (*)(uint_fast8_t counterSelect))ROM_CSTABLE[14])
X#define ROM_CS_enableFaultCounter                                                     ((void (*)(uint_fast8_t counterSelect))ROM_CSTABLE[14])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_CS_disableFaultCounter                                            \
S        ((void (*)(uint_fast8_t counterSelect))ROM_CSTABLE[15])
X#define ROM_CS_disableFaultCounter                                                    ((void (*)(uint_fast8_t counterSelect))ROM_CSTABLE[15])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_CS_resetFaultCounter                                              \
S        ((void (*)(uint_fast8_t counterSelect))ROM_CSTABLE[16])
X#define ROM_CS_resetFaultCounter                                                      ((void (*)(uint_fast8_t counterSelect))ROM_CSTABLE[16])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_CS_startFaultCounter                                              \
S        ((void (*)(uint_fast8_t counterSelect,                                \
S                   uint_fast8_t countValue))ROM_CSTABLE[17])
X#define ROM_CS_startFaultCounter                                                      ((void (*)(uint_fast8_t counterSelect,                                                   uint_fast8_t countValue))ROM_CSTABLE[17])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_CS_clearInterruptFlag                                             \
S        ((void (*)(uint32_t flags))ROM_CSTABLE[20])
X#define ROM_CS_clearInterruptFlag                                                     ((void (*)(uint32_t flags))ROM_CSTABLE[20])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_CS_setDCOExternalResistorCalibration                              \
S        ((void (*)(uint_fast8_t uiCalData,                                    \
S                   uint_fast8_t freqRange))ROM_CSTABLE[31])
X#define ROM_CS_setDCOExternalResistorCalibration                                      ((void (*)(uint_fast8_t uiCalData,                                                       uint_fast8_t freqRange))ROM_CSTABLE[31])
N#endif
N
N//*****************************************************************************
N//
N// Macros for calling ROM functions in the DMA API.
N//
N//*****************************************************************************
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_DMA_enableModule                                                  \
S        ((void (*)(void))ROM_DMATABLE[0])
X#define ROM_DMA_enableModule                                                          ((void (*)(void))ROM_DMATABLE[0])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_DMA_disableModule                                                 \
S        ((void (*)(void))ROM_DMATABLE[1])
X#define ROM_DMA_disableModule                                                         ((void (*)(void))ROM_DMATABLE[1])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_DMA_getErrorStatus                                                \
S        ((uint32_t (*)(void))ROM_DMATABLE[2])
X#define ROM_DMA_getErrorStatus                                                        ((uint32_t (*)(void))ROM_DMATABLE[2])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_DMA_clearErrorStatus                                              \
S        ((void (*)(void))ROM_DMATABLE[3])
X#define ROM_DMA_clearErrorStatus                                                      ((void (*)(void))ROM_DMATABLE[3])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_DMA_enableChannel                                                 \
S        ((void (*)(uint32_t channelNum))ROM_DMATABLE[4])
X#define ROM_DMA_enableChannel                                                         ((void (*)(uint32_t channelNum))ROM_DMATABLE[4])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_DMA_disableChannel                                                \
S        ((void (*)(uint32_t channelNum))ROM_DMATABLE[5])
X#define ROM_DMA_disableChannel                                                        ((void (*)(uint32_t channelNum))ROM_DMATABLE[5])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_DMA_isChannelEnabled                                              \
S        ((bool (*)(uint32_t channelNum))ROM_DMATABLE[6])
X#define ROM_DMA_isChannelEnabled                                                      ((bool (*)(uint32_t channelNum))ROM_DMATABLE[6])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_DMA_setControlBase                                                \
S        ((void (*)(void *controlTable))ROM_DMATABLE[7])
X#define ROM_DMA_setControlBase                                                        ((void (*)(void *controlTable))ROM_DMATABLE[7])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_DMA_getControlBase                                                \
S        ((void* (*)(void))ROM_DMATABLE[8])
X#define ROM_DMA_getControlBase                                                        ((void* (*)(void))ROM_DMATABLE[8])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_DMA_getControlAlternateBase                                       \
S        ((void* (*)(void))ROM_DMATABLE[9])
X#define ROM_DMA_getControlAlternateBase                                               ((void* (*)(void))ROM_DMATABLE[9])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_DMA_requestChannel                                                \
S        ((void (*)(uint32_t channelNum))ROM_DMATABLE[10])
X#define ROM_DMA_requestChannel                                                        ((void (*)(uint32_t channelNum))ROM_DMATABLE[10])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_DMA_enableChannelAttribute                                        \
S        ((void (*)(uint32_t channelNum,                                       \
S                   uint32_t attr))ROM_DMATABLE[11])
X#define ROM_DMA_enableChannelAttribute                                                ((void (*)(uint32_t channelNum,                                                          uint32_t attr))ROM_DMATABLE[11])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_DMA_disableChannelAttribute                                       \
S        ((void (*)(uint32_t channelNum,                                       \
S                   uint32_t attr))ROM_DMATABLE[12])
X#define ROM_DMA_disableChannelAttribute                                               ((void (*)(uint32_t channelNum,                                                          uint32_t attr))ROM_DMATABLE[12])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_DMA_getChannelAttribute                                           \
S        ((uint32_t (*)(uint32_t channelNum))ROM_DMATABLE[13])
X#define ROM_DMA_getChannelAttribute                                                   ((uint32_t (*)(uint32_t channelNum))ROM_DMATABLE[13])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_DMA_setChannelControl                                             \
S        ((void (*)(uint32_t channelStructIndex,                               \
S                   uint32_t control))ROM_DMATABLE[14])
X#define ROM_DMA_setChannelControl                                                     ((void (*)(uint32_t channelStructIndex,                                                  uint32_t control))ROM_DMATABLE[14])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_DMA_setChannelTransfer                                            \
S        ((void (*)(uint32_t channelStructIndex,                               \
S                   uint32_t mode,                                             \
S                   void *srcAddr,                                             \
S                   void *dstAddr,                                             \
S                   uint32_t transferSize))ROM_DMATABLE[15])
X#define ROM_DMA_setChannelTransfer                                                    ((void (*)(uint32_t channelStructIndex,                                                  uint32_t mode,                                                                void *srcAddr,                                                                void *dstAddr,                                                                uint32_t transferSize))ROM_DMATABLE[15])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_DMA_setChannelScatterGather                                       \
S        ((void (*)(uint32_t channelNum,                                       \
S                   uint32_t taskCount,                                        \
S                   void *taskList,                                            \
S                   uint32_t isPeriphSG))ROM_DMATABLE[16])
X#define ROM_DMA_setChannelScatterGather                                               ((void (*)(uint32_t channelNum,                                                          uint32_t taskCount,                                                           void *taskList,                                                               uint32_t isPeriphSG))ROM_DMATABLE[16])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_DMA_getChannelSize                                                \
S        ((uint32_t (*)(uint32_t channelStructIndex))ROM_DMATABLE[17])
X#define ROM_DMA_getChannelSize                                                        ((uint32_t (*)(uint32_t channelStructIndex))ROM_DMATABLE[17])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_DMA_getChannelMode                                                \
S        ((uint32_t (*)(uint32_t channelStructIndex))ROM_DMATABLE[18])
X#define ROM_DMA_getChannelMode                                                        ((uint32_t (*)(uint32_t channelStructIndex))ROM_DMATABLE[18])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_DMA_assignChannel                                                 \
S        ((void (*)(uint32_t mapping))ROM_DMATABLE[19])
X#define ROM_DMA_assignChannel                                                         ((void (*)(uint32_t mapping))ROM_DMATABLE[19])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_DMA_requestSoftwareTransfer                                       \
S        ((void (*)(uint32_t channel))ROM_DMATABLE[20])
X#define ROM_DMA_requestSoftwareTransfer                                               ((void (*)(uint32_t channel))ROM_DMATABLE[20])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_DMA_assignInterrupt                                               \
S        ((void (*)(uint32_t interruptNumber,                                  \
S                   uint32_t channel))ROM_DMATABLE[21])
X#define ROM_DMA_assignInterrupt                                                       ((void (*)(uint32_t interruptNumber,                                                     uint32_t channel))ROM_DMATABLE[21])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_DMA_enableInterrupt                                               \
S        ((void (*)(uint32_t interruptNumber))ROM_DMATABLE[22])
X#define ROM_DMA_enableInterrupt                                                       ((void (*)(uint32_t interruptNumber))ROM_DMATABLE[22])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_DMA_disableInterrupt                                              \
S        ((void (*)(uint32_t interruptNumber))ROM_DMATABLE[23])
X#define ROM_DMA_disableInterrupt                                                      ((void (*)(uint32_t interruptNumber))ROM_DMATABLE[23])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_DMA_getInterruptStatus                                            \
S        ((uint32_t (*)(void))ROM_DMATABLE[24])
X#define ROM_DMA_getInterruptStatus                                                    ((uint32_t (*)(void))ROM_DMATABLE[24])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_DMA_clearInterruptFlag                                            \
S        ((void (*)(uint32_t intChannel))ROM_DMATABLE[25])
X#define ROM_DMA_clearInterruptFlag                                                    ((void (*)(uint32_t intChannel))ROM_DMATABLE[25])
N#endif
N
N//*****************************************************************************
N//
N// Macros for calling ROM functions in the Flash API.
N//
N//*****************************************************************************
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_FlashCtl_enableReadBuffering                                      \
S        ((void (*)(uint_fast8_t memoryBank,                                   \
S                   uint_fast8_t accessMethod))ROM_FLASHCTLTABLE[2])
X#define ROM_FlashCtl_enableReadBuffering                                              ((void (*)(uint_fast8_t memoryBank,                                                      uint_fast8_t accessMethod))ROM_FLASHCTLTABLE[2])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_FlashCtl_disableReadBuffering                                     \
S        ((void (*)(uint_fast8_t memoryBank,                                   \
S                   uint_fast8_t accessMethod))ROM_FLASHCTLTABLE[3])
X#define ROM_FlashCtl_disableReadBuffering                                             ((void (*)(uint_fast8_t memoryBank,                                                      uint_fast8_t accessMethod))ROM_FLASHCTLTABLE[3])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_FlashCtl_unprotectSector                                          \
S        ((bool (*)(uint_fast8_t memorySpace,                                  \
S                   uint32_t sectorMask))ROM_FLASHCTLTABLE[4])
X#define ROM_FlashCtl_unprotectSector                                                  ((bool (*)(uint_fast8_t memorySpace,                                                     uint32_t sectorMask))ROM_FLASHCTLTABLE[4])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_FlashCtl_protectSector                                            \
S        ((bool (*)(uint_fast8_t memorySpace,                                  \
S                   uint32_t sectorMask))ROM_FLASHCTLTABLE[5])
X#define ROM_FlashCtl_protectSector                                                    ((bool (*)(uint_fast8_t memorySpace,                                                     uint32_t sectorMask))ROM_FLASHCTLTABLE[5])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_FlashCtl_isSectorProtected                                        \
S        ((bool (*)(uint_fast8_t memorySpace,                                  \
S                   uint32_t sector))ROM_FLASHCTLTABLE[6])
X#define ROM_FlashCtl_isSectorProtected                                                ((bool (*)(uint_fast8_t memorySpace,                                                     uint32_t sector))ROM_FLASHCTLTABLE[6])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_FlashCtl_verifyMemory                                             \
S        ((bool (*)(void* verifyAddr,                                          \
S                   uint32_t length,                                           \
S                   uint_fast8_t pattern))ROM_FLASHCTLTABLE[7])
X#define ROM_FlashCtl_verifyMemory                                                     ((bool (*)(void* verifyAddr,                                                             uint32_t length,                                                              uint_fast8_t pattern))ROM_FLASHCTLTABLE[7])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_FlashCtl_performMassErase                                         \
S        ((bool (*)(void))ROM_FLASHCTLTABLE[8])
X#define ROM_FlashCtl_performMassErase                                                 ((bool (*)(void))ROM_FLASHCTLTABLE[8])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_FlashCtl_eraseSector                                              \
S        ((bool (*)(uint32_t addr))ROM_FLASHCTLTABLE[9])
X#define ROM_FlashCtl_eraseSector                                                      ((bool (*)(uint32_t addr))ROM_FLASHCTLTABLE[9])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_FlashCtl_programMemory                                            \
S        ((bool (*)(void* src,                                                 \
S                   void* dest,                                                \
S                   uint32_t length))ROM_FLASHCTLTABLE[10])
X#define ROM_FlashCtl_programMemory                                                    ((bool (*)(void* src,                                                                    void* dest,                                                                   uint32_t length))ROM_FLASHCTLTABLE[10])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_FlashCtl_setProgramVerification                                   \
S        ((void (*)(uint32_t verificationSetting))ROM_FLASHCTLTABLE[11])
X#define ROM_FlashCtl_setProgramVerification                                           ((void (*)(uint32_t verificationSetting))ROM_FLASHCTLTABLE[11])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_FlashCtl_clearProgramVerification                                 \
S        ((void (*)(uint32_t verificationSetting))ROM_FLASHCTLTABLE[12])
X#define ROM_FlashCtl_clearProgramVerification                                         ((void (*)(uint32_t verificationSetting))ROM_FLASHCTLTABLE[12])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_FlashCtl_enableWordProgramming                                    \
S        ((void (*)(uint32_t mode))ROM_FLASHCTLTABLE[13])
X#define ROM_FlashCtl_enableWordProgramming                                            ((void (*)(uint32_t mode))ROM_FLASHCTLTABLE[13])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_FlashCtl_disableWordProgramming                                   \
S        ((void (*)(void))ROM_FLASHCTLTABLE[14])
X#define ROM_FlashCtl_disableWordProgramming                                           ((void (*)(void))ROM_FLASHCTLTABLE[14])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_FlashCtl_isWordProgrammingEnabled                                 \
S        ((uint32_t (*)(void))ROM_FLASHCTLTABLE[15])
X#define ROM_FlashCtl_isWordProgrammingEnabled                                         ((uint32_t (*)(void))ROM_FLASHCTLTABLE[15])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_FlashCtl_enableInterrupt                                          \
S        ((void (*)(uint32_t flags))ROM_FLASHCTLTABLE[16])
X#define ROM_FlashCtl_enableInterrupt                                                  ((void (*)(uint32_t flags))ROM_FLASHCTLTABLE[16])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_FlashCtl_disableInterrupt                                         \
S        ((void (*)(uint32_t flags))ROM_FLASHCTLTABLE[17])
X#define ROM_FlashCtl_disableInterrupt                                                 ((void (*)(uint32_t flags))ROM_FLASHCTLTABLE[17])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_FlashCtl_getEnabledInterruptStatus                                \
S        ((uint32_t (*)(void))ROM_FLASHCTLTABLE[18])
X#define ROM_FlashCtl_getEnabledInterruptStatus                                        ((uint32_t (*)(void))ROM_FLASHCTLTABLE[18])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_FlashCtl_getInterruptStatus                                       \
S        ((uint32_t (*)(void))ROM_FLASHCTLTABLE[19])
X#define ROM_FlashCtl_getInterruptStatus                                               ((uint32_t (*)(void))ROM_FLASHCTLTABLE[19])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_FlashCtl_clearInterruptFlag                                       \
S        ((void (*)(uint32_t flags))ROM_FLASHCTLTABLE[20])
X#define ROM_FlashCtl_clearInterruptFlag                                               ((void (*)(uint32_t flags))ROM_FLASHCTLTABLE[20])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_FlashCtl_setWaitState                                             \
S        ((void (*)(uint32_t bank,                                             \
S                   uint32_t waitState))ROM_FLASHCTLTABLE[21])
X#define ROM_FlashCtl_setWaitState                                                     ((void (*)(uint32_t bank,                                                                uint32_t waitState))ROM_FLASHCTLTABLE[21])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_FlashCtl_getWaitState                                             \
S        ((uint32_t (*)(uint32_t bank))ROM_FLASHCTLTABLE[22])
X#define ROM_FlashCtl_getWaitState                                                     ((uint32_t (*)(uint32_t bank))ROM_FLASHCTLTABLE[22])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_FlashCtl_setReadMode                                              \
S        ((bool (*)(uint32_t flashBank,                                        \
S                   uint32_t readMode))ROM_FLASHCTLTABLE[23])
X#define ROM_FlashCtl_setReadMode                                                      ((bool (*)(uint32_t flashBank,                                                           uint32_t readMode))ROM_FLASHCTLTABLE[23])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_FlashCtl_getReadMode                                              \
S        ((uint32_t (*)(uint32_t flashBank))ROM_FLASHCTLTABLE[24])
X#define ROM_FlashCtl_getReadMode                                                      ((uint32_t (*)(uint32_t flashBank))ROM_FLASHCTLTABLE[24])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM___FlashCtl_remaskData8Post                                        \
S        ((uint8_t (*)(uint8_t data,                                           \
S                      uint32_t addr))ROM_FLASHCTLTABLE[27])
X#define ROM___FlashCtl_remaskData8Post                                                ((uint8_t (*)(uint8_t data,                                                                 uint32_t addr))ROM_FLASHCTLTABLE[27])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM___FlashCtl_remaskData8Pre                                         \
S        ((uint8_t (*)(uint8_t data,                                           \
S                      uint32_t addr))ROM_FLASHCTLTABLE[28])
X#define ROM___FlashCtl_remaskData8Pre                                                 ((uint8_t (*)(uint8_t data,                                                                 uint32_t addr))ROM_FLASHCTLTABLE[28])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM___FlashCtl_remaskData32Pre                                        \
S        ((uint32_t (*)(uint32_t data,                                         \
S                       uint32_t addr))ROM_FLASHCTLTABLE[29])
X#define ROM___FlashCtl_remaskData32Pre                                                ((uint32_t (*)(uint32_t data,                                                                uint32_t addr))ROM_FLASHCTLTABLE[29])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM___FlashCtl_remaskData32Post                                       \
S        ((uint32_t (*)(uint32_t data,                                         \
S                       uint32_t addr))ROM_FLASHCTLTABLE[30])
X#define ROM___FlashCtl_remaskData32Post                                               ((uint32_t (*)(uint32_t data,                                                                uint32_t addr))ROM_FLASHCTLTABLE[30])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM___FlashCtl_remaskBurstDataPre                                     \
S        ((void (*)(uint32_t addr,                                             \
S                   uint32_t size))ROM_FLASHCTLTABLE[31])
X#define ROM___FlashCtl_remaskBurstDataPre                                             ((void (*)(uint32_t addr,                                                                uint32_t size))ROM_FLASHCTLTABLE[31])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM___FlashCtl_remaskBurstDataPost                                    \
S        ((void (*)(uint32_t addr,                                             \
S                   uint32_t size))ROM_FLASHCTLTABLE[32])
X#define ROM___FlashCtl_remaskBurstDataPost                                            ((void (*)(uint32_t addr,                                                                uint32_t size))ROM_FLASHCTLTABLE[32])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_FlashCtl_initiateSectorErase                                      \
S        ((void (*)(uint32_t addr))ROM_FLASHCTLTABLE[33])
X#define ROM_FlashCtl_initiateSectorErase                                              ((void (*)(uint32_t addr))ROM_FLASHCTLTABLE[33])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_FlashCtl_initiateMassErase                                        \
S        ((void (*)(void))ROM_FLASHCTLTABLE[34])
X#define ROM_FlashCtl_initiateMassErase                                                ((void (*)(void))ROM_FLASHCTLTABLE[34])
N#endif
N
N//*****************************************************************************
N//
N// Macros for calling ROM functions in the FPU API.
N//
N//*****************************************************************************
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_FPU_enableModule                                                  \
S        ((void (*)(void))ROM_FPUTABLE[0])
X#define ROM_FPU_enableModule                                                          ((void (*)(void))ROM_FPUTABLE[0])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_FPU_disableModule                                                 \
S        ((void (*)(void))ROM_FPUTABLE[1])
X#define ROM_FPU_disableModule                                                         ((void (*)(void))ROM_FPUTABLE[1])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_FPU_enableStacking                                                \
S        ((void (*)(void))ROM_FPUTABLE[2])
X#define ROM_FPU_enableStacking                                                        ((void (*)(void))ROM_FPUTABLE[2])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_FPU_enableLazyStacking                                            \
S        ((void (*)(void))ROM_FPUTABLE[3])
X#define ROM_FPU_enableLazyStacking                                                    ((void (*)(void))ROM_FPUTABLE[3])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_FPU_disableStacking                                               \
S        ((void (*)(void))ROM_FPUTABLE[4])
X#define ROM_FPU_disableStacking                                                       ((void (*)(void))ROM_FPUTABLE[4])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_FPU_setHalfPrecisionMode                                          \
S        ((void (*)(uint32_t mode))ROM_FPUTABLE[5])
X#define ROM_FPU_setHalfPrecisionMode                                                  ((void (*)(uint32_t mode))ROM_FPUTABLE[5])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_FPU_setNaNMode                                                    \
S        ((void (*)(uint32_t mode))ROM_FPUTABLE[6])
X#define ROM_FPU_setNaNMode                                                            ((void (*)(uint32_t mode))ROM_FPUTABLE[6])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_FPU_setFlushToZeroMode                                            \
S        ((void (*)(uint32_t mode))ROM_FPUTABLE[7])
X#define ROM_FPU_setFlushToZeroMode                                                    ((void (*)(uint32_t mode))ROM_FPUTABLE[7])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_FPU_setRoundingMode                                               \
S        ((void (*)(uint32_t mode))ROM_FPUTABLE[8])
X#define ROM_FPU_setRoundingMode                                                       ((void (*)(uint32_t mode))ROM_FPUTABLE[8])
N#endif
N
N//*****************************************************************************
N//
N// Macros for calling ROM functions in the GPIO API.
N//
N//*****************************************************************************
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_GPIO_setAsOutputPin                                               \
S        ((void (*)(uint_fast8_t selectedPort,                                 \
S                   uint_fast16_t selectedPins))ROM_GPIOTABLE[0])
X#define ROM_GPIO_setAsOutputPin                                                       ((void (*)(uint_fast8_t selectedPort,                                                    uint_fast16_t selectedPins))ROM_GPIOTABLE[0])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_GPIO_setOutputHighOnPin                                           \
S        ((void (*)(uint_fast8_t selectedPort,                                 \
S                   uint_fast16_t selectedPins))ROM_GPIOTABLE[1])
X#define ROM_GPIO_setOutputHighOnPin                                                   ((void (*)(uint_fast8_t selectedPort,                                                    uint_fast16_t selectedPins))ROM_GPIOTABLE[1])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_GPIO_setOutputLowOnPin                                            \
S        ((void (*)(uint_fast8_t selectedPort,                                 \
S                   uint_fast16_t selectedPins))ROM_GPIOTABLE[2])
X#define ROM_GPIO_setOutputLowOnPin                                                    ((void (*)(uint_fast8_t selectedPort,                                                    uint_fast16_t selectedPins))ROM_GPIOTABLE[2])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_GPIO_toggleOutputOnPin                                            \
S        ((void (*)(uint_fast8_t selectedPort,                                 \
S                   uint_fast16_t selectedPins))ROM_GPIOTABLE[3])
X#define ROM_GPIO_toggleOutputOnPin                                                    ((void (*)(uint_fast8_t selectedPort,                                                    uint_fast16_t selectedPins))ROM_GPIOTABLE[3])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_GPIO_setAsInputPinWithPullDownResistor                            \
S        ((void (*)(uint_fast8_t selectedPort,                                 \
S                   uint_fast16_t selectedPins))ROM_GPIOTABLE[4])
X#define ROM_GPIO_setAsInputPinWithPullDownResistor                                    ((void (*)(uint_fast8_t selectedPort,                                                    uint_fast16_t selectedPins))ROM_GPIOTABLE[4])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_GPIO_setAsInputPinWithPullUpResistor                              \
S        ((void (*)(uint_fast8_t selectedPort,                                 \
S                   uint_fast16_t selectedPins))ROM_GPIOTABLE[5])
X#define ROM_GPIO_setAsInputPinWithPullUpResistor                                      ((void (*)(uint_fast8_t selectedPort,                                                    uint_fast16_t selectedPins))ROM_GPIOTABLE[5])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_GPIO_setAsPeripheralModuleFunctionOutputPin                       \
S        ((void (*)( uint_fast8_t selectedPort,                                \
S                   uint_fast16_t selectedPins,                                \
S                   uint_fast8_t mode))ROM_GPIOTABLE[6])
X#define ROM_GPIO_setAsPeripheralModuleFunctionOutputPin                               ((void (*)( uint_fast8_t selectedPort,                                                   uint_fast16_t selectedPins,                                                   uint_fast8_t mode))ROM_GPIOTABLE[6])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_GPIO_setAsPeripheralModuleFunctionInputPin                        \
S        ((void (*)( uint_fast8_t selectedPort,                                \
S                   uint_fast16_t selectedPins,                                \
S                   uint_fast8_t mode))ROM_GPIOTABLE[7])
X#define ROM_GPIO_setAsPeripheralModuleFunctionInputPin                                ((void (*)( uint_fast8_t selectedPort,                                                   uint_fast16_t selectedPins,                                                   uint_fast8_t mode))ROM_GPIOTABLE[7])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_GPIO_getInputPinValue                                             \
S        ((uint8_t (*)(uint_fast8_t selectedPort,                              \
S                      uint_fast16_t selectedPins))ROM_GPIOTABLE[8])
X#define ROM_GPIO_getInputPinValue                                                     ((uint8_t (*)(uint_fast8_t selectedPort,                                                    uint_fast16_t selectedPins))ROM_GPIOTABLE[8])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_GPIO_interruptEdgeSelect                                          \
S        ((void (*)(uint_fast8_t selectedPort,                                 \
S                   uint_fast16_t selectedPins,                                \
S                   uint_fast8_t edgeSelect))ROM_GPIOTABLE[9])
X#define ROM_GPIO_interruptEdgeSelect                                                  ((void (*)(uint_fast8_t selectedPort,                                                    uint_fast16_t selectedPins,                                                   uint_fast8_t edgeSelect))ROM_GPIOTABLE[9])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_GPIO_enableInterrupt                                              \
S        ((void (*)(uint_fast8_t selectedPort,                                 \
S                   uint_fast16_t selectedPins))ROM_GPIOTABLE[10])
X#define ROM_GPIO_enableInterrupt                                                      ((void (*)(uint_fast8_t selectedPort,                                                    uint_fast16_t selectedPins))ROM_GPIOTABLE[10])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_GPIO_disableInterrupt                                             \
S        ((void (*)(uint_fast8_t selectedPort,                                 \
S                   uint_fast16_t selectedPins))ROM_GPIOTABLE[11])
X#define ROM_GPIO_disableInterrupt                                                     ((void (*)(uint_fast8_t selectedPort,                                                    uint_fast16_t selectedPins))ROM_GPIOTABLE[11])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_GPIO_getInterruptStatus                                           \
S        ((uint_fast16_t (*)(uint_fast8_t selectedPort,                        \
S                            uint_fast16_t selectedPins))ROM_GPIOTABLE[12])
X#define ROM_GPIO_getInterruptStatus                                                   ((uint_fast16_t (*)(uint_fast8_t selectedPort,                                                    uint_fast16_t selectedPins))ROM_GPIOTABLE[12])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_GPIO_clearInterruptFlag                                           \
S        ((void (*)(uint_fast8_t selectedPort,                                 \
S                   uint_fast16_t selectedPins))ROM_GPIOTABLE[13])
X#define ROM_GPIO_clearInterruptFlag                                                   ((void (*)(uint_fast8_t selectedPort,                                                    uint_fast16_t selectedPins))ROM_GPIOTABLE[13])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_GPIO_setAsInputPin                                                \
S        ((void (*)(uint_fast8_t selectedPort,                                 \
S                   uint_fast16_t selectedPins))ROM_GPIOTABLE[14])
X#define ROM_GPIO_setAsInputPin                                                        ((void (*)(uint_fast8_t selectedPort,                                                    uint_fast16_t selectedPins))ROM_GPIOTABLE[14])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_GPIO_getEnabledInterruptStatus                                    \
S        ((uint_fast16_t (*)(uint_fast8_t selectedPort))ROM_GPIOTABLE[15])
X#define ROM_GPIO_getEnabledInterruptStatus                                            ((uint_fast16_t (*)(uint_fast8_t selectedPort))ROM_GPIOTABLE[15])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_GPIO_setDriveStrengthHigh                                         \
S        ((void (*)(uint_fast8_t selectedPort,                                 \
S                   uint_fast8_t selectedPins))ROM_GPIOTABLE[16])
X#define ROM_GPIO_setDriveStrengthHigh                                                 ((void (*)(uint_fast8_t selectedPort,                                                    uint_fast8_t selectedPins))ROM_GPIOTABLE[16])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_GPIO_setDriveStrengthLow                                          \
S        ((void (*)(uint_fast8_t selectedPort,                                 \
S                   uint_fast8_t selectedPins))ROM_GPIOTABLE[17])
X#define ROM_GPIO_setDriveStrengthLow                                                  ((void (*)(uint_fast8_t selectedPort,                                                    uint_fast8_t selectedPins))ROM_GPIOTABLE[17])
N#endif
N
N//*****************************************************************************
N//
N// Macros for calling ROM functions in the I2C API.
N//
N//*****************************************************************************
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_I2C_initMaster                                                    \
S        ((void (*)(uint32_t moduleInstance,                                   \
S                   const eUSCI_I2C_MasterConfig *config))ROM_I2CTABLE[0])
X#define ROM_I2C_initMaster                                                            ((void (*)(uint32_t moduleInstance,                                                      const eUSCI_I2C_MasterConfig *config))ROM_I2CTABLE[0])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_I2C_initSlave                                                     \
S        ((void (*)(uint32_t moduleInstance,                                   \
S                   uint_fast16_t slaveAddress,                                \
S                   uint_fast8_t slaveAddressOffset,                           \
S                   uint32_t slaveOwnAddressEnable))ROM_I2CTABLE[1])
X#define ROM_I2C_initSlave                                                             ((void (*)(uint32_t moduleInstance,                                                      uint_fast16_t slaveAddress,                                                   uint_fast8_t slaveAddressOffset,                                              uint32_t slaveOwnAddressEnable))ROM_I2CTABLE[1])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_I2C_enableModule                                                  \
S        ((void (*)(uint32_t moduleInstance))ROM_I2CTABLE[2])
X#define ROM_I2C_enableModule                                                          ((void (*)(uint32_t moduleInstance))ROM_I2CTABLE[2])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_I2C_disableModule                                                 \
S        ((void (*)(uint32_t moduleInstance))ROM_I2CTABLE[3])
X#define ROM_I2C_disableModule                                                         ((void (*)(uint32_t moduleInstance))ROM_I2CTABLE[3])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_I2C_setSlaveAddress                                               \
S        ((void (*)(uint32_t moduleInstance,                                   \
S                   uint_fast16_t slaveAddress))ROM_I2CTABLE[4])
X#define ROM_I2C_setSlaveAddress                                                       ((void (*)(uint32_t moduleInstance,                                                      uint_fast16_t slaveAddress))ROM_I2CTABLE[4])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_I2C_setMode                                                       \
S        ((void (*)(uint32_t moduleInstance,                                   \
S                   uint_fast8_t mode))ROM_I2CTABLE[5])
X#define ROM_I2C_setMode                                                               ((void (*)(uint32_t moduleInstance,                                                      uint_fast8_t mode))ROM_I2CTABLE[5])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_I2C_slavePutData                                                  \
S        ((void (*)(uint32_t moduleInstance,                                   \
S                   uint8_t transmitData))ROM_I2CTABLE[6])
X#define ROM_I2C_slavePutData                                                          ((void (*)(uint32_t moduleInstance,                                                      uint8_t transmitData))ROM_I2CTABLE[6])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_I2C_slaveGetData                                                  \
S        ((uint8_t (*)(uint32_t moduleInstance))ROM_I2CTABLE[7])
X#define ROM_I2C_slaveGetData                                                          ((uint8_t (*)(uint32_t moduleInstance))ROM_I2CTABLE[7])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_I2C_isBusBusy                                                     \
S        ((uint8_t (*)(uint32_t moduleInstance))ROM_I2CTABLE[8])
X#define ROM_I2C_isBusBusy                                                             ((uint8_t (*)(uint32_t moduleInstance))ROM_I2CTABLE[8])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_I2C_masterSendSingleByte                                          \
S        ((void (*)(uint32_t moduleInstance,                                   \
S                   uint8_t txData))ROM_I2CTABLE[9])
X#define ROM_I2C_masterSendSingleByte                                                  ((void (*)(uint32_t moduleInstance,                                                      uint8_t txData))ROM_I2CTABLE[9])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_I2C_masterSendSingleByteWithTimeout                               \
S        ((bool (*)(uint32_t moduleInstance,                                   \
S                   uint8_t txData,                                            \
S                   uint32_t timeout))ROM_I2CTABLE[10])
X#define ROM_I2C_masterSendSingleByteWithTimeout                                       ((bool (*)(uint32_t moduleInstance,                                                      uint8_t txData,                                                               uint32_t timeout))ROM_I2CTABLE[10])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_I2C_masterSendMultiByteStart                                      \
S        ((void (*)(uint32_t moduleInstance,                                   \
S                   uint8_t txData))ROM_I2CTABLE[11])
X#define ROM_I2C_masterSendMultiByteStart                                              ((void (*)(uint32_t moduleInstance,                                                      uint8_t txData))ROM_I2CTABLE[11])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_I2C_masterSendMultiByteStartWithTimeout                           \
S        ((bool (*)(uint32_t moduleInstance,                                   \
S                   uint8_t txData,                                            \
S                   uint32_t timeout))ROM_I2CTABLE[12])
X#define ROM_I2C_masterSendMultiByteStartWithTimeout                                   ((bool (*)(uint32_t moduleInstance,                                                      uint8_t txData,                                                               uint32_t timeout))ROM_I2CTABLE[12])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_I2C_masterSendMultiByteNext                                       \
S        ((void (*)(uint32_t moduleInstance,                                   \
S                   uint8_t txData))ROM_I2CTABLE[13])
X#define ROM_I2C_masterSendMultiByteNext                                               ((void (*)(uint32_t moduleInstance,                                                      uint8_t txData))ROM_I2CTABLE[13])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_I2C_masterSendMultiByteNextWithTimeout                            \
S        ((bool (*)(uint32_t moduleInstance,                                   \
S                   uint8_t txData,                                            \
S                   uint32_t timeout))ROM_I2CTABLE[14])
X#define ROM_I2C_masterSendMultiByteNextWithTimeout                                    ((bool (*)(uint32_t moduleInstance,                                                      uint8_t txData,                                                               uint32_t timeout))ROM_I2CTABLE[14])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_I2C_masterSendMultiByteFinish                                     \
S        ((void (*)(uint32_t moduleInstance,                                   \
S                   uint8_t txData))ROM_I2CTABLE[15])
X#define ROM_I2C_masterSendMultiByteFinish                                             ((void (*)(uint32_t moduleInstance,                                                      uint8_t txData))ROM_I2CTABLE[15])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_I2C_masterSendMultiByteFinishWithTimeout                          \
S        ((bool (*)(uint32_t moduleInstance,                                   \
S                   uint8_t txData,                                            \
S                   uint32_t timeout))ROM_I2CTABLE[16])
X#define ROM_I2C_masterSendMultiByteFinishWithTimeout                                  ((bool (*)(uint32_t moduleInstance,                                                      uint8_t txData,                                                               uint32_t timeout))ROM_I2CTABLE[16])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_I2C_masterSendMultiByteStop                                       \
S        ((void (*)(uint32_t moduleInstance))ROM_I2CTABLE[17])
X#define ROM_I2C_masterSendMultiByteStop                                               ((void (*)(uint32_t moduleInstance))ROM_I2CTABLE[17])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_I2C_masterSendMultiByteStopWithTimeout                            \
S        ((bool (*)(uint32_t moduleInstance,                                   \
S                   uint32_t timeout))ROM_I2CTABLE[18])
X#define ROM_I2C_masterSendMultiByteStopWithTimeout                                    ((bool (*)(uint32_t moduleInstance,                                                      uint32_t timeout))ROM_I2CTABLE[18])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_I2C_masterReceiveStart                                            \
S        ((void (*)(uint32_t moduleInstance))ROM_I2CTABLE[19])
X#define ROM_I2C_masterReceiveStart                                                    ((void (*)(uint32_t moduleInstance))ROM_I2CTABLE[19])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_I2C_masterReceiveMultiByteNext                                    \
S        ((uint8_t (*)(uint32_t moduleInstance))ROM_I2CTABLE[20])
X#define ROM_I2C_masterReceiveMultiByteNext                                            ((uint8_t (*)(uint32_t moduleInstance))ROM_I2CTABLE[20])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_I2C_masterReceiveMultiByteFinish                                  \
S        ((uint8_t (*)(uint32_t moduleInstance))ROM_I2CTABLE[21])
X#define ROM_I2C_masterReceiveMultiByteFinish                                          ((uint8_t (*)(uint32_t moduleInstance))ROM_I2CTABLE[21])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_I2C_masterReceiveMultiByteFinishWithTimeout                       \
S        ((bool (*)(uint32_t moduleInstance,                                   \
S                   uint8_t *txData,                                           \
S                   uint32_t timeout))ROM_I2CTABLE[22])
X#define ROM_I2C_masterReceiveMultiByteFinishWithTimeout                               ((bool (*)(uint32_t moduleInstance,                                                      uint8_t *txData,                                                              uint32_t timeout))ROM_I2CTABLE[22])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_I2C_masterReceiveMultiByteStop                                    \
S        ((void (*)(uint32_t moduleInstance))ROM_I2CTABLE[23])
X#define ROM_I2C_masterReceiveMultiByteStop                                            ((void (*)(uint32_t moduleInstance))ROM_I2CTABLE[23])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_I2C_masterReceiveSingleByte                                       \
S        ((uint8_t (*)(uint32_t moduleInstance))ROM_I2CTABLE[24])
X#define ROM_I2C_masterReceiveSingleByte                                               ((uint8_t (*)(uint32_t moduleInstance))ROM_I2CTABLE[24])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_I2C_masterReceiveSingle                                           \
S        ((uint8_t (*)(uint32_t moduleInstance))ROM_I2CTABLE[25])
X#define ROM_I2C_masterReceiveSingle                                                   ((uint8_t (*)(uint32_t moduleInstance))ROM_I2CTABLE[25])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_I2C_getReceiveBufferAddressForDMA                                 \
S        ((uint32_t (*)(uint32_t moduleInstance))ROM_I2CTABLE[26])
X#define ROM_I2C_getReceiveBufferAddressForDMA                                         ((uint32_t (*)(uint32_t moduleInstance))ROM_I2CTABLE[26])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_I2C_getTransmitBufferAddressForDMA                                \
S        ((uint32_t (*)(uint32_t moduleInstance))ROM_I2CTABLE[27])
X#define ROM_I2C_getTransmitBufferAddressForDMA                                        ((uint32_t (*)(uint32_t moduleInstance))ROM_I2CTABLE[27])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_I2C_masterIsStopSent                                              \
S        ((uint8_t (*)(uint32_t moduleInstance))ROM_I2CTABLE[28])
X#define ROM_I2C_masterIsStopSent                                                      ((uint8_t (*)(uint32_t moduleInstance))ROM_I2CTABLE[28])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_I2C_masterIsStartSent                                             \
S        ((bool (*)(uint32_t moduleInstance))ROM_I2CTABLE[29])
X#define ROM_I2C_masterIsStartSent                                                     ((bool (*)(uint32_t moduleInstance))ROM_I2CTABLE[29])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_I2C_masterSendStart                                               \
S        ((void (*)(uint32_t moduleInstance))ROM_I2CTABLE[30])
X#define ROM_I2C_masterSendStart                                                       ((void (*)(uint32_t moduleInstance))ROM_I2CTABLE[30])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_I2C_enableMultiMasterMode                                         \
S        ((void (*)(uint32_t moduleInstance))ROM_I2CTABLE[31])
X#define ROM_I2C_enableMultiMasterMode                                                 ((void (*)(uint32_t moduleInstance))ROM_I2CTABLE[31])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_I2C_disableMultiMasterMode                                        \
S        ((void (*)(uint32_t moduleInstance))ROM_I2CTABLE[32])
X#define ROM_I2C_disableMultiMasterMode                                                ((void (*)(uint32_t moduleInstance))ROM_I2CTABLE[32])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_I2C_enableInterrupt                                               \
S        ((void (*)(uint32_t moduleInstance,                                   \
S                   uint_fast16_t mask))ROM_I2CTABLE[33])
X#define ROM_I2C_enableInterrupt                                                       ((void (*)(uint32_t moduleInstance,                                                      uint_fast16_t mask))ROM_I2CTABLE[33])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_I2C_disableInterrupt                                              \
S        ((void (*)(uint32_t moduleInstance,                                   \
S                   uint_fast16_t mask))ROM_I2CTABLE[34])
X#define ROM_I2C_disableInterrupt                                                      ((void (*)(uint32_t moduleInstance,                                                      uint_fast16_t mask))ROM_I2CTABLE[34])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_I2C_clearInterruptFlag                                            \
S        ((void (*)(uint32_t moduleInstance,                                   \
S                   uint_fast16_t mask))ROM_I2CTABLE[35])
X#define ROM_I2C_clearInterruptFlag                                                    ((void (*)(uint32_t moduleInstance,                                                      uint_fast16_t mask))ROM_I2CTABLE[35])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_I2C_getInterruptStatus                                            \
S        ((uint_fast16_t (*)(uint32_t moduleInstance,                          \
S                            uint16_t mask))ROM_I2CTABLE[36])
X#define ROM_I2C_getInterruptStatus                                                    ((uint_fast16_t (*)(uint32_t moduleInstance,                                                      uint16_t mask))ROM_I2CTABLE[36])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_I2C_getEnabledInterruptStatus                                     \
S        ((uint_fast16_t (*)(uint32_t moduleInstance))ROM_I2CTABLE[37])
X#define ROM_I2C_getEnabledInterruptStatus                                             ((uint_fast16_t (*)(uint32_t moduleInstance))ROM_I2CTABLE[37])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_I2C_getMode                                                       \
S        ((uint_fast8_t (*)(uint32_t moduleInstance))ROM_I2CTABLE[38])
X#define ROM_I2C_getMode                                                               ((uint_fast8_t (*)(uint32_t moduleInstance))ROM_I2CTABLE[38])
N#endif
N
N//*****************************************************************************
N//
N// Macros for calling ROM functions in the Interrupt API.
N//
N//*****************************************************************************
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_Interrupt_enableMaster                                            \
S        ((bool (*)(void))ROM_INTTABLE[0])
X#define ROM_Interrupt_enableMaster                                                    ((bool (*)(void))ROM_INTTABLE[0])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_Interrupt_disableMaster                                           \
S        ((bool (*)(void))ROM_INTTABLE[1])
X#define ROM_Interrupt_disableMaster                                                   ((bool (*)(void))ROM_INTTABLE[1])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_Interrupt_setPriorityGrouping                                     \
S        ((void (*)(uint32_t bits))ROM_INTTABLE[2])
X#define ROM_Interrupt_setPriorityGrouping                                             ((void (*)(uint32_t bits))ROM_INTTABLE[2])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_Interrupt_getPriorityGrouping                                     \
S        ((uint32_t (*)(void))ROM_INTTABLE[3])
X#define ROM_Interrupt_getPriorityGrouping                                             ((uint32_t (*)(void))ROM_INTTABLE[3])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_Interrupt_setPriority                                             \
S        ((void (*)(uint32_t interruptNumber,                                  \
S                   uint8_t priority))ROM_INTTABLE[4])
X#define ROM_Interrupt_setPriority                                                     ((void (*)(uint32_t interruptNumber,                                                     uint8_t priority))ROM_INTTABLE[4])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_Interrupt_getPriority                                             \
S        ((uint8_t (*)(uint32_t interruptNumber))ROM_INTTABLE[5])
X#define ROM_Interrupt_getPriority                                                     ((uint8_t (*)(uint32_t interruptNumber))ROM_INTTABLE[5])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_Interrupt_enableInterrupt                                         \
S        ((void (*)(uint32_t interruptNumber))ROM_INTTABLE[6])
X#define ROM_Interrupt_enableInterrupt                                                 ((void (*)(uint32_t interruptNumber))ROM_INTTABLE[6])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_Interrupt_disableInterrupt                                        \
S        ((void (*)(uint32_t interruptNumber))ROM_INTTABLE[7])
X#define ROM_Interrupt_disableInterrupt                                                ((void (*)(uint32_t interruptNumber))ROM_INTTABLE[7])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_Interrupt_isEnabled                                               \
S        ((bool (*)(uint32_t interruptNumber))ROM_INTTABLE[8])
X#define ROM_Interrupt_isEnabled                                                       ((bool (*)(uint32_t interruptNumber))ROM_INTTABLE[8])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_Interrupt_pendInterrupt                                           \
S        ((void (*)(uint32_t interruptNumber))ROM_INTTABLE[9])
X#define ROM_Interrupt_pendInterrupt                                                   ((void (*)(uint32_t interruptNumber))ROM_INTTABLE[9])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_Interrupt_setPriorityMask                                         \
S        ((void (*)(uint8_t priorityMask))ROM_INTTABLE[10])
X#define ROM_Interrupt_setPriorityMask                                                 ((void (*)(uint8_t priorityMask))ROM_INTTABLE[10])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_Interrupt_getPriorityMask                                         \
S        ((uint8_t (*)(void))ROM_INTTABLE[11])
X#define ROM_Interrupt_getPriorityMask                                                 ((uint8_t (*)(void))ROM_INTTABLE[11])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_Interrupt_setVectorTableAddress                                   \
S        ((void (*)(uint32_t addr))ROM_INTTABLE[12])
X#define ROM_Interrupt_setVectorTableAddress                                           ((void (*)(uint32_t addr))ROM_INTTABLE[12])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_Interrupt_getVectorTableAddress                                   \
S        ((uint32_t (*)(void))ROM_INTTABLE[13])
X#define ROM_Interrupt_getVectorTableAddress                                           ((uint32_t (*)(void))ROM_INTTABLE[13])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_Interrupt_enableSleepOnIsrExit                                    \
S        ((void (*)(void))ROM_INTTABLE[14])
X#define ROM_Interrupt_enableSleepOnIsrExit                                            ((void (*)(void))ROM_INTTABLE[14])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_Interrupt_disableSleepOnIsrExit                                   \
S        ((void (*)(void))ROM_INTTABLE[15])
X#define ROM_Interrupt_disableSleepOnIsrExit                                           ((void (*)(void))ROM_INTTABLE[15])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_Interrupt_unpendInterrupt                                         \
S        ((void (*)(uint32_t interruptNumber))ROM_INTTABLE[18])
X#define ROM_Interrupt_unpendInterrupt                                                 ((void (*)(uint32_t interruptNumber))ROM_INTTABLE[18])
N#endif
N
N//*****************************************************************************
N//
N// Macros for calling ROM functions in the MPU API.
N//
N//*****************************************************************************
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_MPU_enableModule                                                  \
S        ((void (*)(uint32_t mpuConfig))ROM_MPUTABLE[0])
X#define ROM_MPU_enableModule                                                          ((void (*)(uint32_t mpuConfig))ROM_MPUTABLE[0])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_MPU_disableModule                                                 \
S        ((void (*)(void))ROM_MPUTABLE[1])
X#define ROM_MPU_disableModule                                                         ((void (*)(void))ROM_MPUTABLE[1])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_MPU_getRegionCount                                                \
S        ((uint32_t (*)(void))ROM_MPUTABLE[2])
X#define ROM_MPU_getRegionCount                                                        ((uint32_t (*)(void))ROM_MPUTABLE[2])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_MPU_enableRegion                                                  \
S        ((void (*)(uint32_t region))ROM_MPUTABLE[3])
X#define ROM_MPU_enableRegion                                                          ((void (*)(uint32_t region))ROM_MPUTABLE[3])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_MPU_disableRegion                                                 \
S        ((void (*)(uint32_t region))ROM_MPUTABLE[4])
X#define ROM_MPU_disableRegion                                                         ((void (*)(uint32_t region))ROM_MPUTABLE[4])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_MPU_setRegion                                                     \
S        ((void (*)(uint32_t region,                                           \
S                   uint32_t addr,                                             \
S                   uint32_t flags))ROM_MPUTABLE[5])
X#define ROM_MPU_setRegion                                                             ((void (*)(uint32_t region,                                                              uint32_t addr,                                                                uint32_t flags))ROM_MPUTABLE[5])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_MPU_getRegion                                                     \
S        ((void (*)(uint32_t region,                                           \
S                   uint32_t *addr,                                            \
S                   uint32_t *pflags))ROM_MPUTABLE[6])
X#define ROM_MPU_getRegion                                                             ((void (*)(uint32_t region,                                                              uint32_t *addr,                                                               uint32_t *pflags))ROM_MPUTABLE[6])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_MPU_enableInterrupt                                               \
S        ((void (*)(void))ROM_MPUTABLE[7])
X#define ROM_MPU_enableInterrupt                                                       ((void (*)(void))ROM_MPUTABLE[7])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_MPU_disableInterrupt                                              \
S        ((void (*)(void))ROM_MPUTABLE[8])
X#define ROM_MPU_disableInterrupt                                                      ((void (*)(void))ROM_MPUTABLE[8])
N#endif
N
N//*****************************************************************************
N//
N// Macros for calling ROM functions in the PCM API.
N//
N//*****************************************************************************
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_PCM_setCoreVoltageLevel                                           \
S        ((bool (*)(uint_fast8_t voltageLevel))ROM_PCMTABLE[0])
X#define ROM_PCM_setCoreVoltageLevel                                                   ((bool (*)(uint_fast8_t voltageLevel))ROM_PCMTABLE[0])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_PCM_getCoreVoltageLevel                                           \
S        ((uint8_t (*)(void))ROM_PCMTABLE[1])
X#define ROM_PCM_getCoreVoltageLevel                                                   ((uint8_t (*)(void))ROM_PCMTABLE[1])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_PCM_setCoreVoltageLevelWithTimeout                                \
S        ((bool (*)(uint_fast8_t voltageLevel,                                 \
S                   uint32_t timeOut))ROM_PCMTABLE[2])
X#define ROM_PCM_setCoreVoltageLevelWithTimeout                                        ((bool (*)(uint_fast8_t voltageLevel,                                                    uint32_t timeOut))ROM_PCMTABLE[2])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_PCM_setPowerMode                                                  \
S        ((bool (*)(uint_fast8_t powerMode))ROM_PCMTABLE[3])
X#define ROM_PCM_setPowerMode                                                          ((bool (*)(uint_fast8_t powerMode))ROM_PCMTABLE[3])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_PCM_setPowerModeWithTimeout                                       \
S        ((bool (*)(uint_fast8_t powerMode,                                    \
S                   uint32_t timeOut))ROM_PCMTABLE[4])
X#define ROM_PCM_setPowerModeWithTimeout                                               ((bool (*)(uint_fast8_t powerMode,                                                       uint32_t timeOut))ROM_PCMTABLE[4])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_PCM_getPowerMode                                                  \
S        ((uint8_t (*)(void))ROM_PCMTABLE[5])
X#define ROM_PCM_getPowerMode                                                          ((uint8_t (*)(void))ROM_PCMTABLE[5])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_PCM_setPowerState                                                 \
S        ((bool (*)(uint_fast8_t powerState))ROM_PCMTABLE[6])
X#define ROM_PCM_setPowerState                                                         ((bool (*)(uint_fast8_t powerState))ROM_PCMTABLE[6])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_PCM_setPowerStateWithTimeout                                      \
S        ((bool (*)(uint_fast8_t powerState,                                   \
S                   uint32_t timeout))ROM_PCMTABLE[7])
X#define ROM_PCM_setPowerStateWithTimeout                                              ((bool (*)(uint_fast8_t powerState,                                                      uint32_t timeout))ROM_PCMTABLE[7])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_PCM_getPowerState                                                 \
S        ((uint8_t (*)(void))ROM_PCMTABLE[8])
X#define ROM_PCM_getPowerState                                                         ((uint8_t (*)(void))ROM_PCMTABLE[8])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_PCM_shutdownDevice                                                \
S        ((bool (*)(uint32_t shutdownMode))ROM_PCMTABLE[9])
X#define ROM_PCM_shutdownDevice                                                        ((bool (*)(uint32_t shutdownMode))ROM_PCMTABLE[9])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_PCM_gotoLPM0                                                      \
S        ((bool (*)(void))ROM_PCMTABLE[10])
X#define ROM_PCM_gotoLPM0                                                              ((bool (*)(void))ROM_PCMTABLE[10])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_PCM_gotoLPM3                                                      \
S        ((bool (*)(void))ROM_PCMTABLE[11])
X#define ROM_PCM_gotoLPM3                                                              ((bool (*)(void))ROM_PCMTABLE[11])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_PCM_enableInterrupt                                               \
S        ((void (*)(uint32_t flags))ROM_PCMTABLE[12])
X#define ROM_PCM_enableInterrupt                                                       ((void (*)(uint32_t flags))ROM_PCMTABLE[12])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_PCM_disableInterrupt                                              \
S        ((void (*)(uint32_t flags))ROM_PCMTABLE[13])
X#define ROM_PCM_disableInterrupt                                                      ((void (*)(uint32_t flags))ROM_PCMTABLE[13])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_PCM_getInterruptStatus                                            \
S        ((uint32_t (*)(void))ROM_PCMTABLE[14])
X#define ROM_PCM_getInterruptStatus                                                    ((uint32_t (*)(void))ROM_PCMTABLE[14])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_PCM_getEnabledInterruptStatus                                     \
S        ((uint32_t (*)(void))ROM_PCMTABLE[15])
X#define ROM_PCM_getEnabledInterruptStatus                                             ((uint32_t (*)(void))ROM_PCMTABLE[15])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_PCM_clearInterruptFlag                                            \
S        ((void (*)(uint32_t flags))ROM_PCMTABLE[16])
X#define ROM_PCM_clearInterruptFlag                                                    ((void (*)(uint32_t flags))ROM_PCMTABLE[16])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_PCM_enableRudeMode                                                \
S        ((void (*)(void))ROM_PCMTABLE[17])
X#define ROM_PCM_enableRudeMode                                                        ((void (*)(void))ROM_PCMTABLE[17])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_PCM_disableRudeMode                                               \
S        ((void (*)(void))ROM_PCMTABLE[18])
X#define ROM_PCM_disableRudeMode                                                       ((void (*)(void))ROM_PCMTABLE[18])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_PCM_gotoLPM0InterruptSafe                                         \
S        ((bool (*)(void))ROM_PCMTABLE[19])
X#define ROM_PCM_gotoLPM0InterruptSafe                                                 ((bool (*)(void))ROM_PCMTABLE[19])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_PCM_gotoLPM3InterruptSafe                                         \
S        ((bool (*)(void))ROM_PCMTABLE[20])
X#define ROM_PCM_gotoLPM3InterruptSafe                                                 ((bool (*)(void))ROM_PCMTABLE[20])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_PCM_setCoreVoltageLevelNonBlocking                                \
S        ((bool (*)(uint_fast8_t voltageLevel))ROM_PCMTABLE[23])
X#define ROM_PCM_setCoreVoltageLevelNonBlocking                                        ((bool (*)(uint_fast8_t voltageLevel))ROM_PCMTABLE[23])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_PCM_setPowerModeNonBlocking                                       \
S        ((bool (*)(uint_fast8_t powerMode))ROM_PCMTABLE[24])
X#define ROM_PCM_setPowerModeNonBlocking                                               ((bool (*)(uint_fast8_t powerMode))ROM_PCMTABLE[24])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_PCM_setPowerStateNonBlocking                                      \
S        ((bool (*)(uint_fast8_t powerState))ROM_PCMTABLE[25])
X#define ROM_PCM_setPowerStateNonBlocking                                              ((bool (*)(uint_fast8_t powerState))ROM_PCMTABLE[25])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_PCM_gotoLPM4                                                      \
S        ((bool (*)(void))ROM_PCMTABLE[26])
X#define ROM_PCM_gotoLPM4                                                              ((bool (*)(void))ROM_PCMTABLE[26])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_PCM_gotoLPM4InterruptSafe                                         \
S        ((bool (*)(void))ROM_PCMTABLE[27])
X#define ROM_PCM_gotoLPM4InterruptSafe                                                 ((bool (*)(void))ROM_PCMTABLE[27])
N#endif
N
N//*****************************************************************************
N//
N// Macros for calling ROM functions in the PMAP API.
N//
N//*****************************************************************************
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_PMAP_configurePorts                                               \
S        ((void (*)(const uint8_t *portMapping,                                \
S                   uint8_t pxMAPy,                                            \
S                   uint8_t numberOfPorts,                                     \
S                   uint8_t portMapReconfigure))ROM_PMAPTABLE[0])
X#define ROM_PMAP_configurePorts                                                       ((void (*)(const uint8_t *portMapping,                                                   uint8_t pxMAPy,                                                               uint8_t numberOfPorts,                                                        uint8_t portMapReconfigure))ROM_PMAPTABLE[0])
N#endif
N
N//*****************************************************************************
N//
N// Macros for calling ROM functions in the PSS API.
N//
N//*****************************************************************************
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_PSS_enableHighSidePinToggle                                       \
S        ((void (*)(bool activeLow))ROM_PSSTABLE[0])
X#define ROM_PSS_enableHighSidePinToggle                                               ((void (*)(bool activeLow))ROM_PSSTABLE[0])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_PSS_disableHighSidePinToggle                                      \
S        ((void (*)(void))ROM_PSSTABLE[1])
X#define ROM_PSS_disableHighSidePinToggle                                              ((void (*)(void))ROM_PSSTABLE[1])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_PSS_enableHighSide                                                \
S        ((void (*)(void))ROM_PSSTABLE[2])
X#define ROM_PSS_enableHighSide                                                        ((void (*)(void))ROM_PSSTABLE[2])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_PSS_disableHighSide                                               \
S        ((void (*)(void))ROM_PSSTABLE[3])
X#define ROM_PSS_disableHighSide                                                       ((void (*)(void))ROM_PSSTABLE[3])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_PSS_setHighSidePerformanceMode                                    \
S        ((void (*)(uint_fast8_t powerMode))ROM_PSSTABLE[6])
X#define ROM_PSS_setHighSidePerformanceMode                                            ((void (*)(uint_fast8_t powerMode))ROM_PSSTABLE[6])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_PSS_getHighSidePerformanceMode                                    \
S        ((uint_fast8_t (*)(void))ROM_PSSTABLE[7])
X#define ROM_PSS_getHighSidePerformanceMode                                            ((uint_fast8_t (*)(void))ROM_PSSTABLE[7])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_PSS_enableHighSideMonitor                                         \
S        ((void (*)(void))ROM_PSSTABLE[10])
X#define ROM_PSS_enableHighSideMonitor                                                 ((void (*)(void))ROM_PSSTABLE[10])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_PSS_disableHighSideMonitor                                        \
S        ((void (*)(void))ROM_PSSTABLE[11])
X#define ROM_PSS_disableHighSideMonitor                                                ((void (*)(void))ROM_PSSTABLE[11])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_PSS_setHighSideVoltageTrigger                                     \
S        ((void (*)(uint_fast8_t triggerVoltage))ROM_PSSTABLE[12])
X#define ROM_PSS_setHighSideVoltageTrigger                                             ((void (*)(uint_fast8_t triggerVoltage))ROM_PSSTABLE[12])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_PSS_getHighSideVoltageTrigger                                     \
S        ((uint_fast8_t (*)(void))ROM_PSSTABLE[13])
X#define ROM_PSS_getHighSideVoltageTrigger                                             ((uint_fast8_t (*)(void))ROM_PSSTABLE[13])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_PSS_enableInterrupt                                               \
S        ((void (*)(void))ROM_PSSTABLE[14])
X#define ROM_PSS_enableInterrupt                                                       ((void (*)(void))ROM_PSSTABLE[14])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_PSS_disableInterrupt                                              \
S        ((void (*)(void))ROM_PSSTABLE[15])
X#define ROM_PSS_disableInterrupt                                                      ((void (*)(void))ROM_PSSTABLE[15])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_PSS_getInterruptStatus                                            \
S        ((uint32_t (*)(void))ROM_PSSTABLE[16])
X#define ROM_PSS_getInterruptStatus                                                    ((uint32_t (*)(void))ROM_PSSTABLE[16])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_PSS_clearInterruptFlag                                            \
S        ((void (*)(void))ROM_PSSTABLE[17])
X#define ROM_PSS_clearInterruptFlag                                                    ((void (*)(void))ROM_PSSTABLE[17])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_PSS_enableForcedDCDCOperation                                     \
S        ((void (*)(void))ROM_PSSTABLE[20])
X#define ROM_PSS_enableForcedDCDCOperation                                             ((void (*)(void))ROM_PSSTABLE[20])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_PSS_disableForcedDCDCOperation                                    \
S        ((void (*)(void))ROM_PSSTABLE[21])
X#define ROM_PSS_disableForcedDCDCOperation                                            ((void (*)(void))ROM_PSSTABLE[21])
N#endif
N
N//*****************************************************************************
N//
N// Macros for calling ROM functions in the Ref API.
N//
N//*****************************************************************************
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_REF_A_setReferenceVoltage                                         \
S        ((void (*)(uint_fast8_t referenceVoltageSelect))ROM_REFTABLE[0])
X#define ROM_REF_A_setReferenceVoltage                                                 ((void (*)(uint_fast8_t referenceVoltageSelect))ROM_REFTABLE[0])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_REF_A_disableTempSensor                                           \
S        ((void (*)(void))ROM_REFTABLE[1])
X#define ROM_REF_A_disableTempSensor                                                   ((void (*)(void))ROM_REFTABLE[1])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_REF_A_enableTempSensor                                            \
S        ((void (*)(void))ROM_REFTABLE[2])
X#define ROM_REF_A_enableTempSensor                                                    ((void (*)(void))ROM_REFTABLE[2])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_REF_A_enableReferenceVoltageOutput                                \
S        ((void (*)(void))ROM_REFTABLE[3])
X#define ROM_REF_A_enableReferenceVoltageOutput                                        ((void (*)(void))ROM_REFTABLE[3])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_REF_A_disableReferenceVoltageOutput                               \
S        ((void (*)(void))ROM_REFTABLE[4])
X#define ROM_REF_A_disableReferenceVoltageOutput                                       ((void (*)(void))ROM_REFTABLE[4])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_REF_A_enableReferenceVoltage                                      \
S        ((void (*)(void))ROM_REFTABLE[5])
X#define ROM_REF_A_enableReferenceVoltage                                              ((void (*)(void))ROM_REFTABLE[5])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_REF_A_disableReferenceVoltage                                     \
S        ((void (*)(void))ROM_REFTABLE[6])
X#define ROM_REF_A_disableReferenceVoltage                                             ((void (*)(void))ROM_REFTABLE[6])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_REF_A_getBandgapMode                                              \
S        ((uint_fast8_t (*)(void))ROM_REFTABLE[7])
X#define ROM_REF_A_getBandgapMode                                                      ((uint_fast8_t (*)(void))ROM_REFTABLE[7])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_REF_A_isBandgapActive                                             \
S        ((bool (*)(void))ROM_REFTABLE[8])
X#define ROM_REF_A_isBandgapActive                                                     ((bool (*)(void))ROM_REFTABLE[8])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_REF_A_isRefGenBusy                                                \
S        ((bool (*)(void))ROM_REFTABLE[9])
X#define ROM_REF_A_isRefGenBusy                                                        ((bool (*)(void))ROM_REFTABLE[9])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_REF_A_isRefGenActive                                              \
S        ((bool (*)(void))ROM_REFTABLE[10])
X#define ROM_REF_A_isRefGenActive                                                      ((bool (*)(void))ROM_REFTABLE[10])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_REF_A_getBufferedBandgapVoltageStatus                             \
S        ((bool (*)(void))ROM_REFTABLE[11])
X#define ROM_REF_A_getBufferedBandgapVoltageStatus                                     ((bool (*)(void))ROM_REFTABLE[11])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_REF_A_getVariableReferenceVoltageStatus                           \
S        ((bool (*)(void))ROM_REFTABLE[12])
X#define ROM_REF_A_getVariableReferenceVoltageStatus                                   ((bool (*)(void))ROM_REFTABLE[12])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_REF_A_setReferenceVoltageOneTimeTrigger                           \
S        ((void (*)(void))ROM_REFTABLE[13])
X#define ROM_REF_A_setReferenceVoltageOneTimeTrigger                                   ((void (*)(void))ROM_REFTABLE[13])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_REF_A_setBufferedBandgapVoltageOneTimeTrigger                     \
S        ((void (*)(void))ROM_REFTABLE[14])
X#define ROM_REF_A_setBufferedBandgapVoltageOneTimeTrigger                             ((void (*)(void))ROM_REFTABLE[14])
N#endif
N
N//*****************************************************************************
N//
N// Macros for calling ROM functions in the ResetCtl API.
N//
N//*****************************************************************************
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_ResetCtl_initiateSoftReset                                        \
S        ((void (*)(void))ROM_RESETCTLTABLE[0])
X#define ROM_ResetCtl_initiateSoftReset                                                ((void (*)(void))ROM_RESETCTLTABLE[0])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_ResetCtl_initiateSoftResetWithSource                              \
S        ((void (*)(uint32_t source))ROM_RESETCTLTABLE[1])
X#define ROM_ResetCtl_initiateSoftResetWithSource                                      ((void (*)(uint32_t source))ROM_RESETCTLTABLE[1])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_ResetCtl_getSoftResetSource                                       \
S        ((uint32_t (*)(void))ROM_RESETCTLTABLE[2])
X#define ROM_ResetCtl_getSoftResetSource                                               ((uint32_t (*)(void))ROM_RESETCTLTABLE[2])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_ResetCtl_clearSoftResetSource                                     \
S        ((void (*)(uint32_t mask))ROM_RESETCTLTABLE[3])
X#define ROM_ResetCtl_clearSoftResetSource                                             ((void (*)(uint32_t mask))ROM_RESETCTLTABLE[3])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_ResetCtl_initiateHardReset                                        \
S        ((void (*)(void))ROM_RESETCTLTABLE[4])
X#define ROM_ResetCtl_initiateHardReset                                                ((void (*)(void))ROM_RESETCTLTABLE[4])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_ResetCtl_initiateHardResetWithSource                              \
S        ((void (*)(uint32_t source))ROM_RESETCTLTABLE[5])
X#define ROM_ResetCtl_initiateHardResetWithSource                                      ((void (*)(uint32_t source))ROM_RESETCTLTABLE[5])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_ResetCtl_getHardResetSource                                       \
S        ((uint32_t (*)(void))ROM_RESETCTLTABLE[6])
X#define ROM_ResetCtl_getHardResetSource                                               ((uint32_t (*)(void))ROM_RESETCTLTABLE[6])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_ResetCtl_clearHardResetSource                                     \
S        ((void (*)(uint32_t mask))ROM_RESETCTLTABLE[7])
X#define ROM_ResetCtl_clearHardResetSource                                             ((void (*)(uint32_t mask))ROM_RESETCTLTABLE[7])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_ResetCtl_getPSSSource                                             \
S        ((uint32_t (*)(void))ROM_RESETCTLTABLE[8])
X#define ROM_ResetCtl_getPSSSource                                                     ((uint32_t (*)(void))ROM_RESETCTLTABLE[8])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_ResetCtl_clearPSSFlags                                            \
S        ((void (*)(void))ROM_RESETCTLTABLE[9])
X#define ROM_ResetCtl_clearPSSFlags                                                    ((void (*)(void))ROM_RESETCTLTABLE[9])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_ResetCtl_getPCMSource                                             \
S        ((uint32_t (*)(void))ROM_RESETCTLTABLE[10])
X#define ROM_ResetCtl_getPCMSource                                                     ((uint32_t (*)(void))ROM_RESETCTLTABLE[10])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_ResetCtl_clearPCMFlags                                            \
S        ((void (*)(void))ROM_RESETCTLTABLE[11])
X#define ROM_ResetCtl_clearPCMFlags                                                    ((void (*)(void))ROM_RESETCTLTABLE[11])
N#endif
N
N//*****************************************************************************
N//
N// Macros for calling ROM functions in the RTC API.
N//
N//*****************************************************************************
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_RTC_C_startClock                                                  \
S        ((void (*)(void))ROM_RTCTABLE[0])
X#define ROM_RTC_C_startClock                                                          ((void (*)(void))ROM_RTCTABLE[0])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_RTC_C_holdClock                                                   \
S        ((void (*)(void))ROM_RTCTABLE[1])
X#define ROM_RTC_C_holdClock                                                           ((void (*)(void))ROM_RTCTABLE[1])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_RTC_C_setCalibrationFrequency                                     \
S        ((void (*)(uint_fast16_t frequencySelect))ROM_RTCTABLE[2])
X#define ROM_RTC_C_setCalibrationFrequency                                             ((void (*)(uint_fast16_t frequencySelect))ROM_RTCTABLE[2])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_RTC_C_setCalibrationData                                          \
S        ((void (*)(uint_fast8_t offsetDirection,                              \
S                   uint_fast8_t offsetValue))ROM_RTCTABLE[3])
X#define ROM_RTC_C_setCalibrationData                                                  ((void (*)(uint_fast8_t offsetDirection,                                                 uint_fast8_t offsetValue))ROM_RTCTABLE[3])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_RTC_C_setTemperatureCompensation                                  \
S        ((bool (*)(uint_fast16_t offsetDirection,                             \
S                   uint_fast8_t offsetValue))ROM_RTCTABLE[4])
X#define ROM_RTC_C_setTemperatureCompensation                                          ((bool (*)(uint_fast16_t offsetDirection,                                                uint_fast8_t offsetValue))ROM_RTCTABLE[4])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_RTC_C_initCalendar                                                \
S        ((void (*)(const RTC_C_Calendar *calendarTime,                        \
S                   uint_fast16_t formatSelect))ROM_RTCTABLE[5])
X#define ROM_RTC_C_initCalendar                                                        ((void (*)(const RTC_C_Calendar *calendarTime,                                           uint_fast16_t formatSelect))ROM_RTCTABLE[5])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_RTC_C_getCalendarTime                                             \
S        ((RTC_C_Calendar (*)(void))ROM_RTCTABLE[6])
X#define ROM_RTC_C_getCalendarTime                                                     ((RTC_C_Calendar (*)(void))ROM_RTCTABLE[6])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_RTC_C_setCalendarAlarm                                            \
S        ((void (*)(uint_fast8_t minutesAlarm,                                 \
S                   uint_fast8_t hoursAlarm,                                   \
S                   uint_fast8_t dayOfWeekAlarm,                               \
S                   uint_fast8_t dayOfmonthAlarm))ROM_RTCTABLE[7])
X#define ROM_RTC_C_setCalendarAlarm                                                    ((void (*)(uint_fast8_t minutesAlarm,                                                    uint_fast8_t hoursAlarm,                                                      uint_fast8_t dayOfWeekAlarm,                                                  uint_fast8_t dayOfmonthAlarm))ROM_RTCTABLE[7])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_RTC_C_setCalendarEvent                                            \
S        ((void (*)(uint_fast16_t eventSelect))ROM_RTCTABLE[8])
X#define ROM_RTC_C_setCalendarEvent                                                    ((void (*)(uint_fast16_t eventSelect))ROM_RTCTABLE[8])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_RTC_C_definePrescaleEvent                                         \
S        ((void (*)(uint_fast8_t prescaleSelect,                               \
S                   uint_fast8_t prescaleEventDivider))ROM_RTCTABLE[9])
X#define ROM_RTC_C_definePrescaleEvent                                                 ((void (*)(uint_fast8_t prescaleSelect,                                                  uint_fast8_t prescaleEventDivider))ROM_RTCTABLE[9])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_RTC_C_getPrescaleValue                                            \
S        ((uint_fast8_t (*)(uint_fast8_t prescaleSelect))ROM_RTCTABLE[10])
X#define ROM_RTC_C_getPrescaleValue                                                    ((uint_fast8_t (*)(uint_fast8_t prescaleSelect))ROM_RTCTABLE[10])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_RTC_C_setPrescaleValue                                            \
S        ((void (*)(uint_fast8_t prescaleSelect,                               \
S                   uint_fast8_t prescaleCounterValue))ROM_RTCTABLE[11])
X#define ROM_RTC_C_setPrescaleValue                                                    ((void (*)(uint_fast8_t prescaleSelect,                                                  uint_fast8_t prescaleCounterValue))ROM_RTCTABLE[11])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_RTC_C_convertBCDToBinary                                          \
S        ((uint16_t (*)(uint16_t valueToConvert))ROM_RTCTABLE[12])
X#define ROM_RTC_C_convertBCDToBinary                                                  ((uint16_t (*)(uint16_t valueToConvert))ROM_RTCTABLE[12])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_RTC_C_convertBinaryToBCD                                          \
S        ((uint16_t (*)(uint16_t valueToConvert))ROM_RTCTABLE[13])
X#define ROM_RTC_C_convertBinaryToBCD                                                  ((uint16_t (*)(uint16_t valueToConvert))ROM_RTCTABLE[13])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_RTC_C_enableInterrupt                                             \
S        ((void (*)(uint8_t interruptMask))ROM_RTCTABLE[14])
X#define ROM_RTC_C_enableInterrupt                                                     ((void (*)(uint8_t interruptMask))ROM_RTCTABLE[14])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_RTC_C_disableInterrupt                                            \
S        ((void (*)(uint8_t interruptMask))ROM_RTCTABLE[15])
X#define ROM_RTC_C_disableInterrupt                                                    ((void (*)(uint8_t interruptMask))ROM_RTCTABLE[15])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_RTC_C_getInterruptStatus                                          \
S        ((uint_fast8_t (*)(void))ROM_RTCTABLE[16])
X#define ROM_RTC_C_getInterruptStatus                                                  ((uint_fast8_t (*)(void))ROM_RTCTABLE[16])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_RTC_C_getEnabledInterruptStatus                                   \
S        ((uint_fast8_t (*)(void))ROM_RTCTABLE[17])
X#define ROM_RTC_C_getEnabledInterruptStatus                                           ((uint_fast8_t (*)(void))ROM_RTCTABLE[17])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_RTC_C_clearInterruptFlag                                          \
S        ((void (*)(uint_fast8_t interruptFlagMask))ROM_RTCTABLE[18])
X#define ROM_RTC_C_clearInterruptFlag                                                  ((void (*)(uint_fast8_t interruptFlagMask))ROM_RTCTABLE[18])
N#endif
N
N//*****************************************************************************
N//
N// Macros for calling ROM functions in the SPI API.
N//
N//*****************************************************************************
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_SPI_initMaster                                                    \
S        ((bool (*)(uint32_t moduleInstance,                                   \
S                   const eUSCI_SPI_MasterConfig *config))ROM_SPITABLE[0])
X#define ROM_SPI_initMaster                                                            ((bool (*)(uint32_t moduleInstance,                                                      const eUSCI_SPI_MasterConfig *config))ROM_SPITABLE[0])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_SPI_selectFourPinFunctionality                                    \
S        ((void (*)(uint32_t moduleInstance,                                   \
S                   uint_fast8_t select4PinFunctionality))ROM_SPITABLE[1])
X#define ROM_SPI_selectFourPinFunctionality                                            ((void (*)(uint32_t moduleInstance,                                                      uint_fast8_t select4PinFunctionality))ROM_SPITABLE[1])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_SPI_changeMasterClock                                             \
S        ((void (*)(uint32_t moduleInstance,                                   \
S                   uint32_t clockSourceFrequency,                             \
S                   uint32_t desiredSpiClock))ROM_SPITABLE[2])
X#define ROM_SPI_changeMasterClock                                                     ((void (*)(uint32_t moduleInstance,                                                      uint32_t clockSourceFrequency,                                                uint32_t desiredSpiClock))ROM_SPITABLE[2])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_SPI_initSlave                                                     \
S        ((bool (*)(uint32_t moduleInstance,                                   \
S                   const eUSCI_SPI_SlaveConfig *config))ROM_SPITABLE[3])
X#define ROM_SPI_initSlave                                                             ((bool (*)(uint32_t moduleInstance,                                                      const eUSCI_SPI_SlaveConfig *config))ROM_SPITABLE[3])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_SPI_changeClockPhasePolarity                                      \
S        ((void (*)(uint32_t moduleInstance,                                   \
S                   uint_fast16_t clockPhase,                                  \
S                   uint_fast16_t clockPolarity))ROM_SPITABLE[4])
X#define ROM_SPI_changeClockPhasePolarity                                              ((void (*)(uint32_t moduleInstance,                                                      uint_fast16_t clockPhase,                                                     uint_fast16_t clockPolarity))ROM_SPITABLE[4])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_SPI_transmitData                                                  \
S        ((void (*)(uint32_t moduleInstance,                                   \
S                   uint_fast8_t transmitData))ROM_SPITABLE[5])
X#define ROM_SPI_transmitData                                                          ((void (*)(uint32_t moduleInstance,                                                      uint_fast8_t transmitData))ROM_SPITABLE[5])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_SPI_receiveData                                                   \
S        ((uint8_t (*)(uint32_t moduleInstance))ROM_SPITABLE[6])
X#define ROM_SPI_receiveData                                                           ((uint8_t (*)(uint32_t moduleInstance))ROM_SPITABLE[6])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_SPI_enableModule                                                  \
S        ((void (*)(uint32_t moduleInstance))ROM_SPITABLE[7])
X#define ROM_SPI_enableModule                                                          ((void (*)(uint32_t moduleInstance))ROM_SPITABLE[7])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_SPI_disableModule                                                 \
S        ((void (*)(uint32_t moduleInstance))ROM_SPITABLE[8])
X#define ROM_SPI_disableModule                                                         ((void (*)(uint32_t moduleInstance))ROM_SPITABLE[8])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_SPI_getReceiveBufferAddressForDMA                                 \
S        ((uint32_t (*)(uint32_t moduleInstance))ROM_SPITABLE[9])
X#define ROM_SPI_getReceiveBufferAddressForDMA                                         ((uint32_t (*)(uint32_t moduleInstance))ROM_SPITABLE[9])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_SPI_getTransmitBufferAddressForDMA                                \
S        ((uint32_t (*)(uint32_t moduleInstance))ROM_SPITABLE[10])
X#define ROM_SPI_getTransmitBufferAddressForDMA                                        ((uint32_t (*)(uint32_t moduleInstance))ROM_SPITABLE[10])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_SPI_isBusy                                                        \
S        ((uint_fast8_t (*)(uint32_t moduleInstance))ROM_SPITABLE[11])
X#define ROM_SPI_isBusy                                                                ((uint_fast8_t (*)(uint32_t moduleInstance))ROM_SPITABLE[11])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_SPI_enableInterrupt                                               \
S        ((void (*)(uint32_t moduleInstance,                                   \
S                   uint_fast8_t mask))ROM_SPITABLE[12])
X#define ROM_SPI_enableInterrupt                                                       ((void (*)(uint32_t moduleInstance,                                                      uint_fast8_t mask))ROM_SPITABLE[12])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_SPI_disableInterrupt                                              \
S        ((void (*)(uint32_t moduleInstance,                                   \
S                   uint_fast8_t mask))ROM_SPITABLE[13])
X#define ROM_SPI_disableInterrupt                                                      ((void (*)(uint32_t moduleInstance,                                                      uint_fast8_t mask))ROM_SPITABLE[13])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_SPI_getInterruptStatus                                            \
S        ((uint_fast8_t (*)(uint32_t moduleInstance,                           \
S                           uint16_t mask))ROM_SPITABLE[14])
X#define ROM_SPI_getInterruptStatus                                                    ((uint_fast8_t (*)(uint32_t moduleInstance,                                                      uint16_t mask))ROM_SPITABLE[14])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_SPI_getEnabledInterruptStatus                                     \
S        ((uint_fast8_t (*)(uint32_t moduleInstance))ROM_SPITABLE[15])
X#define ROM_SPI_getEnabledInterruptStatus                                             ((uint_fast8_t (*)(uint32_t moduleInstance))ROM_SPITABLE[15])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_SPI_clearInterruptFlag                                            \
S        ((void (*)(uint32_t moduleInstance,                                   \
S                   uint_fast8_t mask))ROM_SPITABLE[16])
X#define ROM_SPI_clearInterruptFlag                                                    ((void (*)(uint32_t moduleInstance,                                                      uint_fast8_t mask))ROM_SPITABLE[16])
N#endif
N
N//*****************************************************************************
N//
N// Macros for calling ROM functions in the SysCtl API.
N//
N//*****************************************************************************
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_SysCtl_getSRAMSize                                                \
S        ((uint_least32_t (*)(void))ROM_SYSCTLTABLE[0])
X#define ROM_SysCtl_getSRAMSize                                                        ((uint_least32_t (*)(void))ROM_SYSCTLTABLE[0])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_SysCtl_getFlashSize                                               \
S        ((uint_least32_t (*)(void))ROM_SYSCTLTABLE[1])
X#define ROM_SysCtl_getFlashSize                                                       ((uint_least32_t (*)(void))ROM_SYSCTLTABLE[1])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_SysCtl_rebootDevice                                               \
S        ((void (*)(void))ROM_SYSCTLTABLE[2])
X#define ROM_SysCtl_rebootDevice                                                       ((void (*)(void))ROM_SYSCTLTABLE[2])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_SysCtl_enableSRAMBank                                             \
S        ((void (*)(uint_fast8_t sramBank))ROM_SYSCTLTABLE[3])
X#define ROM_SysCtl_enableSRAMBank                                                     ((void (*)(uint_fast8_t sramBank))ROM_SYSCTLTABLE[3])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_SysCtl_disableSRAMBank                                            \
S        ((void (*)(uint_fast8_t sramBank))ROM_SYSCTLTABLE[4])
X#define ROM_SysCtl_disableSRAMBank                                                    ((void (*)(uint_fast8_t sramBank))ROM_SYSCTLTABLE[4])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_SysCtl_enableSRAMBankRetention                                    \
S        ((void (*)(uint_fast8_t sramBank))ROM_SYSCTLTABLE[5])
X#define ROM_SysCtl_enableSRAMBankRetention                                            ((void (*)(uint_fast8_t sramBank))ROM_SYSCTLTABLE[5])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_SysCtl_disableSRAMBankRetention                                   \
S        ((void (*)(uint_fast8_t sramBank))ROM_SYSCTLTABLE[6])
X#define ROM_SysCtl_disableSRAMBankRetention                                           ((void (*)(uint_fast8_t sramBank))ROM_SYSCTLTABLE[6])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_SysCtl_enablePeripheralAtCPUHalt                                  \
S        ((void (*)(uint_fast16_t devices))ROM_SYSCTLTABLE[7])
X#define ROM_SysCtl_enablePeripheralAtCPUHalt                                          ((void (*)(uint_fast16_t devices))ROM_SYSCTLTABLE[7])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_SysCtl_disablePeripheralAtCPUHalt                                 \
S        ((void (*)(uint_fast16_t devices))ROM_SYSCTLTABLE[8])
X#define ROM_SysCtl_disablePeripheralAtCPUHalt                                         ((void (*)(uint_fast16_t devices))ROM_SYSCTLTABLE[8])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_SysCtl_setWDTTimeoutResetType                                     \
S        ((void (*)(uint_fast8_t resetType))ROM_SYSCTLTABLE[9])
X#define ROM_SysCtl_setWDTTimeoutResetType                                             ((void (*)(uint_fast8_t resetType))ROM_SYSCTLTABLE[9])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_SysCtl_setWDTPasswordViolationResetType                           \
S        ((void (*)(uint_fast8_t resetType))ROM_SYSCTLTABLE[10])
X#define ROM_SysCtl_setWDTPasswordViolationResetType                                   ((void (*)(uint_fast8_t resetType))ROM_SYSCTLTABLE[10])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_SysCtl_disableNMISource                                           \
S        ((void (*)(uint_fast8_t flags))ROM_SYSCTLTABLE[11])
X#define ROM_SysCtl_disableNMISource                                                   ((void (*)(uint_fast8_t flags))ROM_SYSCTLTABLE[11])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_SysCtl_enableNMISource                                            \
S        ((void (*)(uint_fast8_t flags))ROM_SYSCTLTABLE[12])
X#define ROM_SysCtl_enableNMISource                                                    ((void (*)(uint_fast8_t flags))ROM_SYSCTLTABLE[12])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_SysCtl_getNMISourceStatus                                         \
S        ((uint_fast8_t (*)(void))ROM_SYSCTLTABLE[13])
X#define ROM_SysCtl_getNMISourceStatus                                                 ((uint_fast8_t (*)(void))ROM_SYSCTLTABLE[13])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_SysCtl_getTempCalibrationConstant                                 \
S        ((uint_fast16_t (*)(uint32_t refVoltage,                              \
S                            uint32_t temperature))ROM_SYSCTLTABLE[14])
X#define ROM_SysCtl_getTempCalibrationConstant                                         ((uint_fast16_t (*)(uint32_t refVoltage,                                                          uint32_t temperature))ROM_SYSCTLTABLE[14])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_SysCtl_enableGlitchFilter                                         \
S        ((void (*)(void))ROM_SYSCTLTABLE[15])
X#define ROM_SysCtl_enableGlitchFilter                                                 ((void (*)(void))ROM_SYSCTLTABLE[15])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_SysCtl_disableGlitchFilter                                        \
S        ((void (*)(void))ROM_SYSCTLTABLE[16])
X#define ROM_SysCtl_disableGlitchFilter                                                ((void (*)(void))ROM_SYSCTLTABLE[16])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_SysCtl_getTLVInfo                                                 \
S        ((void (*)(uint_fast8_t tag,                                          \
S                   uint_fast8_t instance,                                     \
S                   uint_fast8_t *length,                                      \
S                   uint32_t **data_address))ROM_SYSCTLTABLE[17])
X#define ROM_SysCtl_getTLVInfo                                                         ((void (*)(uint_fast8_t tag,                                                             uint_fast8_t instance,                                                        uint_fast8_t *length,                                                         uint32_t **data_address))ROM_SYSCTLTABLE[17])
N#endif
N
N//*****************************************************************************
N//
N// Macros for calling ROM functions in the SysTick API.
N//
N//*****************************************************************************
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_SysTick_enableModule                                              \
S        ((void (*)(void))ROM_SYSTICKTABLE[0])
X#define ROM_SysTick_enableModule                                                      ((void (*)(void))ROM_SYSTICKTABLE[0])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_SysTick_disableModule                                             \
S        ((void (*)(void))ROM_SYSTICKTABLE[1])
X#define ROM_SysTick_disableModule                                                     ((void (*)(void))ROM_SYSTICKTABLE[1])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_SysTick_enableInterrupt                                           \
S        ((void (*)(void))ROM_SYSTICKTABLE[2])
X#define ROM_SysTick_enableInterrupt                                                   ((void (*)(void))ROM_SYSTICKTABLE[2])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_SysTick_disableInterrupt                                          \
S        ((void (*)(void))ROM_SYSTICKTABLE[3])
X#define ROM_SysTick_disableInterrupt                                                  ((void (*)(void))ROM_SYSTICKTABLE[3])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_SysTick_setPeriod                                                 \
S        ((void (*)(uint32_t period))ROM_SYSTICKTABLE[4])
X#define ROM_SysTick_setPeriod                                                         ((void (*)(uint32_t period))ROM_SYSTICKTABLE[4])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_SysTick_getPeriod                                                 \
S        ((uint32_t (*)(void))ROM_SYSTICKTABLE[5])
X#define ROM_SysTick_getPeriod                                                         ((uint32_t (*)(void))ROM_SYSTICKTABLE[5])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_SysTick_getValue                                                  \
S        ((uint32_t (*)(void))ROM_SYSTICKTABLE[6])
X#define ROM_SysTick_getValue                                                          ((uint32_t (*)(void))ROM_SYSTICKTABLE[6])
N#endif
N
N//*****************************************************************************
N//
N// Macros for calling ROM functions in the Timer_A API.
N//
N//*****************************************************************************
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_Timer_A_startCounter                                              \
S        ((void (*)(uint32_t timer,                                            \
S                   uint_fast16_t timerMode))ROM_TIMER_ATABLE[0])
X#define ROM_Timer_A_startCounter                                                      ((void (*)(uint32_t timer,                                                               uint_fast16_t timerMode))ROM_TIMER_ATABLE[0])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_Timer_A_configureContinuousMode                                   \
S        ((void (*)(uint32_t timer,                                            \
S                   const Timer_A_ContinuousModeConfig *config))ROM_TIMER_ATABLE[1])
X#define ROM_Timer_A_configureContinuousMode                                           ((void (*)(uint32_t timer,                                                               const Timer_A_ContinuousModeConfig *config))ROM_TIMER_ATABLE[1])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_Timer_A_configureUpMode                                           \
S        ((void (*)(uint32_t timer,                                            \
S                   const Timer_A_UpModeConfig *config))ROM_TIMER_ATABLE[2])
X#define ROM_Timer_A_configureUpMode                                                   ((void (*)(uint32_t timer,                                                               const Timer_A_UpModeConfig *config))ROM_TIMER_ATABLE[2])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_Timer_A_configureUpDownMode                                       \
S        ((void (*)(uint32_t timer,                                            \
S                   const Timer_A_UpDownModeConfig *config))ROM_TIMER_ATABLE[3])
X#define ROM_Timer_A_configureUpDownMode                                               ((void (*)(uint32_t timer,                                                               const Timer_A_UpDownModeConfig *config))ROM_TIMER_ATABLE[3])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_Timer_A_initCapture                                               \
S        ((void (*)(uint32_t timer,                                            \
S                   const Timer_A_CaptureModeConfig *config))ROM_TIMER_ATABLE[4])
X#define ROM_Timer_A_initCapture                                                       ((void (*)(uint32_t timer,                                                               const Timer_A_CaptureModeConfig *config))ROM_TIMER_ATABLE[4])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_Timer_A_initCompare                                               \
S        ((void (*)(uint32_t timer,                                            \
S                   const Timer_A_CompareModeConfig *config))ROM_TIMER_ATABLE[5])
X#define ROM_Timer_A_initCompare                                                       ((void (*)(uint32_t timer,                                                               const Timer_A_CompareModeConfig *config))ROM_TIMER_ATABLE[5])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_Timer_A_clearTimer                                                \
S        ((void (*)(uint32_t timer))ROM_TIMER_ATABLE[6])
X#define ROM_Timer_A_clearTimer                                                        ((void (*)(uint32_t timer))ROM_TIMER_ATABLE[6])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_Timer_A_getSynchronizedCaptureCompareInput                        \
S        ((uint_fast8_t (*)(uint32_t timer,                                    \
S                           uint_fast16_t captureCompareRegister,              \
S                           uint_fast16_t synchronizedSetting))ROM_TIMER_ATABLE[7])
X#define ROM_Timer_A_getSynchronizedCaptureCompareInput                                ((uint_fast8_t (*)(uint32_t timer,                                                               uint_fast16_t captureCompareRegister,                                         uint_fast16_t synchronizedSetting))ROM_TIMER_ATABLE[7])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_Timer_A_getOutputForOutputModeOutBitValue                         \
S        ((uint_fast8_t (*)(uint32_t timer,                                    \
S                           uint_fast16_t captureCompareRegister))ROM_TIMER_ATABLE[8])
X#define ROM_Timer_A_getOutputForOutputModeOutBitValue                                 ((uint_fast8_t (*)(uint32_t timer,                                                               uint_fast16_t captureCompareRegister))ROM_TIMER_ATABLE[8])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_Timer_A_getCaptureCompareCount                                    \
S        ((uint_fast16_t (*)(uint32_t timer,                                   \
S                            uint_fast16_t captureCompareRegister))ROM_TIMER_ATABLE[9])
X#define ROM_Timer_A_getCaptureCompareCount                                            ((uint_fast16_t (*)(uint32_t timer,                                                               uint_fast16_t captureCompareRegister))ROM_TIMER_ATABLE[9])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_Timer_A_generatePWM                                               \
S        ((void (*)(uint32_t timer,                                            \
S                   const Timer_A_PWMConfig *config))ROM_TIMER_ATABLE[11])
X#define ROM_Timer_A_generatePWM                                                       ((void (*)(uint32_t timer,                                                               const Timer_A_PWMConfig *config))ROM_TIMER_ATABLE[11])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_Timer_A_stopTimer                                                 \
S        ((void (*)(uint32_t timer))ROM_TIMER_ATABLE[12])
X#define ROM_Timer_A_stopTimer                                                         ((void (*)(uint32_t timer))ROM_TIMER_ATABLE[12])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_Timer_A_setCompareValue                                           \
S        ((void (*)(uint32_t timer,                                            \
S                   uint_fast16_t compareRegister,                             \
S                   uint_fast16_t compareValue))ROM_TIMER_ATABLE[13])
X#define ROM_Timer_A_setCompareValue                                                   ((void (*)(uint32_t timer,                                                               uint_fast16_t compareRegister,                                                uint_fast16_t compareValue))ROM_TIMER_ATABLE[13])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_Timer_A_clearInterruptFlag                                        \
S        ((void (*)(uint32_t timer))ROM_TIMER_ATABLE[14])
X#define ROM_Timer_A_clearInterruptFlag                                                ((void (*)(uint32_t timer))ROM_TIMER_ATABLE[14])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_Timer_A_clearCaptureCompareInterrupt                              \
S        ((void (*)(uint32_t timer,                                            \
S                   uint_fast16_t captureCompareRegister))ROM_TIMER_ATABLE[15])
X#define ROM_Timer_A_clearCaptureCompareInterrupt                                      ((void (*)(uint32_t timer,                                                               uint_fast16_t captureCompareRegister))ROM_TIMER_ATABLE[15])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_Timer_A_enableInterrupt                                           \
S        ((void (*)(uint32_t timer))ROM_TIMER_ATABLE[16])
X#define ROM_Timer_A_enableInterrupt                                                   ((void (*)(uint32_t timer))ROM_TIMER_ATABLE[16])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_Timer_A_disableInterrupt                                          \
S        ((void (*)(uint32_t timer))ROM_TIMER_ATABLE[17])
X#define ROM_Timer_A_disableInterrupt                                                  ((void (*)(uint32_t timer))ROM_TIMER_ATABLE[17])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_Timer_A_getInterruptStatus                                        \
S        ((uint32_t (*)(uint32_t timer))ROM_TIMER_ATABLE[18])
X#define ROM_Timer_A_getInterruptStatus                                                ((uint32_t (*)(uint32_t timer))ROM_TIMER_ATABLE[18])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_Timer_A_getEnabledInterruptStatus                                 \
S        ((uint32_t (*)(uint32_t timer))ROM_TIMER_ATABLE[19])
X#define ROM_Timer_A_getEnabledInterruptStatus                                         ((uint32_t (*)(uint32_t timer))ROM_TIMER_ATABLE[19])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_Timer_A_enableCaptureCompareInterrupt                             \
S        ((void (*)(uint32_t timer,                                            \
S                   uint_fast16_t captureCompareRegister))ROM_TIMER_ATABLE[20])
X#define ROM_Timer_A_enableCaptureCompareInterrupt                                     ((void (*)(uint32_t timer,                                                               uint_fast16_t captureCompareRegister))ROM_TIMER_ATABLE[20])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_Timer_A_disableCaptureCompareInterrupt                            \
S        ((void (*)(uint32_t timer,                                            \
S                   uint_fast16_t captureCompareRegister))ROM_TIMER_ATABLE[21])
X#define ROM_Timer_A_disableCaptureCompareInterrupt                                    ((void (*)(uint32_t timer,                                                               uint_fast16_t captureCompareRegister))ROM_TIMER_ATABLE[21])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_Timer_A_getCaptureCompareInterruptStatus                          \
S        ((uint32_t (*)(uint32_t timer,                                        \
S                       uint_fast16_t captureCompareRegister,                  \
S                       uint_fast16_t mask))ROM_TIMER_ATABLE[22])
X#define ROM_Timer_A_getCaptureCompareInterruptStatus                                  ((uint32_t (*)(uint32_t timer,                                                               uint_fast16_t captureCompareRegister,                                         uint_fast16_t mask))ROM_TIMER_ATABLE[22])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_Timer_A_getCaptureCompareEnabledInterruptStatus                   \
S        ((uint32_t (*)(uint32_t timer,                                        \
S                       uint_fast16_t captureCompareRegister))ROM_TIMER_ATABLE[23])
X#define ROM_Timer_A_getCaptureCompareEnabledInterruptStatus                           ((uint32_t (*)(uint32_t timer,                                                               uint_fast16_t captureCompareRegister))ROM_TIMER_ATABLE[23])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_Timer_A_getCounterValue                                           \
S        ((uint16_t (*)(uint32_t timer))ROM_TIMER_ATABLE[26])
X#define ROM_Timer_A_getCounterValue                                                   ((uint16_t (*)(uint32_t timer))ROM_TIMER_ATABLE[26])
N#endif
N
N//*****************************************************************************
N//
N// Macros for calling ROM functions in the Timer32 API.
N//
N//*****************************************************************************
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_Timer32_initModule                                                \
S        ((void (*)(uint32_t timer,                                            \
S                   uint32_t preScaler,                                        \
S                   uint32_t resolution,                                       \
S                   uint32_t mode))ROM_TIMER32TABLE[0])
X#define ROM_Timer32_initModule                                                        ((void (*)(uint32_t timer,                                                               uint32_t preScaler,                                                           uint32_t resolution,                                                          uint32_t mode))ROM_TIMER32TABLE[0])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_Timer32_setCount                                                  \
S        ((void (*)(uint32_t timer,                                            \
S                   uint32_t count))ROM_TIMER32TABLE[1])
X#define ROM_Timer32_setCount                                                          ((void (*)(uint32_t timer,                                                               uint32_t count))ROM_TIMER32TABLE[1])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_Timer32_setCountInBackground                                      \
S        ((void (*)(uint32_t timer,                                            \
S                   uint32_t count))ROM_TIMER32TABLE[2])
X#define ROM_Timer32_setCountInBackground                                              ((void (*)(uint32_t timer,                                                               uint32_t count))ROM_TIMER32TABLE[2])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_Timer32_getValue                                                  \
S        ((uint32_t (*)(uint32_t timer))ROM_TIMER32TABLE[3])
X#define ROM_Timer32_getValue                                                          ((uint32_t (*)(uint32_t timer))ROM_TIMER32TABLE[3])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_Timer32_startTimer                                                \
S        ((void (*)(uint32_t timer,                                            \
S                   bool oneShot))ROM_TIMER32TABLE[4])
X#define ROM_Timer32_startTimer                                                        ((void (*)(uint32_t timer,                                                               bool oneShot))ROM_TIMER32TABLE[4])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_Timer32_haltTimer                                                 \
S        ((void (*)(uint32_t timer))ROM_TIMER32TABLE[5])
X#define ROM_Timer32_haltTimer                                                         ((void (*)(uint32_t timer))ROM_TIMER32TABLE[5])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_Timer32_enableInterrupt                                           \
S        ((void (*)(uint32_t timer))ROM_TIMER32TABLE[6])
X#define ROM_Timer32_enableInterrupt                                                   ((void (*)(uint32_t timer))ROM_TIMER32TABLE[6])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_Timer32_disableInterrupt                                          \
S        ((void (*)(uint32_t timer))ROM_TIMER32TABLE[7])
X#define ROM_Timer32_disableInterrupt                                                  ((void (*)(uint32_t timer))ROM_TIMER32TABLE[7])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_Timer32_clearInterruptFlag                                        \
S        ((void (*)(uint32_t timer))ROM_TIMER32TABLE[8])
X#define ROM_Timer32_clearInterruptFlag                                                ((void (*)(uint32_t timer))ROM_TIMER32TABLE[8])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_Timer32_getInterruptStatus                                        \
S        ((uint32_t (*)(uint32_t timer))ROM_TIMER32TABLE[9])
X#define ROM_Timer32_getInterruptStatus                                                ((uint32_t (*)(uint32_t timer))ROM_TIMER32TABLE[9])
N#endif
N
N//*****************************************************************************
N//
N// Macros for calling ROM functions in the UART API.
N//
N//*****************************************************************************
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_UART_initModule                                                   \
S        ((bool (*)(uint32_t moduleInstance,                                   \
S                   const eUSCI_UART_Config *config))ROM_UARTTABLE[0])
X#define ROM_UART_initModule                                                           ((bool (*)(uint32_t moduleInstance,                                                      const eUSCI_UART_Config *config))ROM_UARTTABLE[0])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_UART_transmitData                                                 \
S        ((void (*)(uint32_t moduleInstance,                                   \
S                   uint_fast8_t transmitData))ROM_UARTTABLE[1])
X#define ROM_UART_transmitData                                                         ((void (*)(uint32_t moduleInstance,                                                      uint_fast8_t transmitData))ROM_UARTTABLE[1])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_UART_enableModule                                                 \
S        ((void (*)(uint32_t moduleInstance))ROM_UARTTABLE[2])
X#define ROM_UART_enableModule                                                         ((void (*)(uint32_t moduleInstance))ROM_UARTTABLE[2])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_UART_disableModule                                                \
S        ((void (*)(uint32_t moduleInstance))ROM_UARTTABLE[3])
X#define ROM_UART_disableModule                                                        ((void (*)(uint32_t moduleInstance))ROM_UARTTABLE[3])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_UART_queryStatusFlags                                             \
S        ((uint_fast8_t (*)(uint32_t moduleInstance,                           \
S                           uint_fast8_t mask))ROM_UARTTABLE[4])
X#define ROM_UART_queryStatusFlags                                                     ((uint_fast8_t (*)(uint32_t moduleInstance,                                                      uint_fast8_t mask))ROM_UARTTABLE[4])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_UART_setDormant                                                   \
S        ((void (*)(uint32_t moduleInstance))ROM_UARTTABLE[5])
X#define ROM_UART_setDormant                                                           ((void (*)(uint32_t moduleInstance))ROM_UARTTABLE[5])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_UART_resetDormant                                                 \
S        ((void (*)(uint32_t moduleInstance))ROM_UARTTABLE[6])
X#define ROM_UART_resetDormant                                                         ((void (*)(uint32_t moduleInstance))ROM_UARTTABLE[6])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_UART_transmitAddress                                              \
S        ((void (*)(uint32_t moduleInstance,                                   \
S                   uint_fast8_t transmitAddress))ROM_UARTTABLE[7])
X#define ROM_UART_transmitAddress                                                      ((void (*)(uint32_t moduleInstance,                                                      uint_fast8_t transmitAddress))ROM_UARTTABLE[7])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_UART_transmitBreak                                                \
S        ((void (*)(uint32_t moduleInstance))ROM_UARTTABLE[8])
X#define ROM_UART_transmitBreak                                                        ((void (*)(uint32_t moduleInstance))ROM_UARTTABLE[8])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_UART_getReceiveBufferAddressForDMA                                \
S        ((uint32_t (*)(uint32_t moduleInstance))ROM_UARTTABLE[9])
X#define ROM_UART_getReceiveBufferAddressForDMA                                        ((uint32_t (*)(uint32_t moduleInstance))ROM_UARTTABLE[9])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_UART_getTransmitBufferAddressForDMA                               \
S        ((uint32_t (*)(uint32_t moduleInstance))ROM_UARTTABLE[10])
X#define ROM_UART_getTransmitBufferAddressForDMA                                       ((uint32_t (*)(uint32_t moduleInstance))ROM_UARTTABLE[10])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_UART_selectDeglitchTime                                           \
S        ((void (*)(uint32_t moduleInstance,                                   \
S                   uint32_t deglitchTime))ROM_UARTTABLE[11])
X#define ROM_UART_selectDeglitchTime                                                   ((void (*)(uint32_t moduleInstance,                                                      uint32_t deglitchTime))ROM_UARTTABLE[11])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_UART_enableInterrupt                                              \
S        ((void (*)(uint32_t moduleInstance,                                   \
S                   uint_fast8_t mask))ROM_UARTTABLE[12])
X#define ROM_UART_enableInterrupt                                                      ((void (*)(uint32_t moduleInstance,                                                      uint_fast8_t mask))ROM_UARTTABLE[12])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_UART_disableInterrupt                                             \
S        ((void (*)(uint32_t moduleInstance,                                   \
S                   uint_fast8_t mask))ROM_UARTTABLE[13])
X#define ROM_UART_disableInterrupt                                                     ((void (*)(uint32_t moduleInstance,                                                      uint_fast8_t mask))ROM_UARTTABLE[13])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_UART_getInterruptStatus                                           \
S        ((uint_fast8_t (*)(uint32_t moduleInstance,                           \
S                           uint8_t mask))ROM_UARTTABLE[14])
X#define ROM_UART_getInterruptStatus                                                   ((uint_fast8_t (*)(uint32_t moduleInstance,                                                      uint8_t mask))ROM_UARTTABLE[14])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_UART_clearInterruptFlag                                           \
S        ((void (*)(uint32_t moduleInstance,                                   \
S                   uint_fast8_t mask))ROM_UARTTABLE[15])
X#define ROM_UART_clearInterruptFlag                                                   ((void (*)(uint32_t moduleInstance,                                                      uint_fast8_t mask))ROM_UARTTABLE[15])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_UART_receiveData                                                  \
S        ((uint8_t (*)(uint32_t moduleInstance))ROM_UARTTABLE[16])
X#define ROM_UART_receiveData                                                          ((uint8_t (*)(uint32_t moduleInstance))ROM_UARTTABLE[16])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_UART_getEnabledInterruptStatus                                    \
S        ((uint_fast8_t (*)(uint32_t moduleInstance))ROM_UARTTABLE[17])
X#define ROM_UART_getEnabledInterruptStatus                                            ((uint_fast8_t (*)(uint32_t moduleInstance))ROM_UARTTABLE[17])
N#endif
N
N//*****************************************************************************
N//
N// Macros for calling ROM functions in the WDT API.
N//
N//*****************************************************************************
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_WDT_A_holdTimer                                                   \
S        ((void (*)(void))ROM_WDTTABLE[0])
X#define ROM_WDT_A_holdTimer                                                           ((void (*)(void))ROM_WDTTABLE[0])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_WDT_A_startTimer                                                  \
S        ((void (*)(void))ROM_WDTTABLE[1])
X#define ROM_WDT_A_startTimer                                                          ((void (*)(void))ROM_WDTTABLE[1])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_WDT_A_clearTimer                                                  \
S        ((void (*)(void))ROM_WDTTABLE[2])
X#define ROM_WDT_A_clearTimer                                                          ((void (*)(void))ROM_WDTTABLE[2])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_WDT_A_initWatchdogTimer                                           \
S        ((void (*)(uint_fast8_t clockSelect,                                  \
S                   uint_fast8_t clockDivider))ROM_WDTTABLE[3])
X#define ROM_WDT_A_initWatchdogTimer                                                   ((void (*)(uint_fast8_t clockSelect,                                                     uint_fast8_t clockDivider))ROM_WDTTABLE[3])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_WDT_A_initIntervalTimer                                           \
S        ((void (*)(uint_fast8_t clockSelect,                                  \
S                   uint_fast8_t clockDivider))ROM_WDTTABLE[4])
X#define ROM_WDT_A_initIntervalTimer                                                   ((void (*)(uint_fast8_t clockSelect,                                                     uint_fast8_t clockDivider))ROM_WDTTABLE[4])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_WDT_A_setPasswordViolationReset                                   \
S        ((void (*)(uint_fast8_t resetType))ROM_WDTTABLE[7])
X#define ROM_WDT_A_setPasswordViolationReset                                           ((void (*)(uint_fast8_t resetType))ROM_WDTTABLE[7])
N#endif
N#if defined(TARGET_IS_MSP432P4XX)
X#if 0L
S#define ROM_WDT_A_setTimeoutReset                                             \
S        ((void (*)(uint_fast8_t resetType))ROM_WDTTABLE[8])
X#define ROM_WDT_A_setTimeoutReset                                                     ((void (*)(uint_fast8_t resetType))ROM_WDTTABLE[8])
N#endif
N
N#endif // __ROM_H__
L 60 "C:/ti/msp432_driverlib_3_21_00_05/driverlib/MSP432P4xx/driverlib.h" 2
N#include "rom_map.h"
L 1 "C:\ti\msp432_driverlib_3_21_00_05\driverlib\MSP432P4xx\rom_map.h" 1
N/*
N * -------------------------------------------
N *    MSP432 DriverLib - v3_21_00_05 
N * -------------------------------------------
N *
N * --COPYRIGHT--,BSD,BSD
N * Copyright (c) 2016, Texas Instruments Incorporated
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N *
N * *  Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N *
N * *  Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * *  Neither the name of Texas Instruments Incorporated nor the names of
N *    its contributors may be used to endorse or promote products derived
N *    from this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
N * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
N * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
N * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
N * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
N * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
N * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
N * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
N * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * --/COPYRIGHT--*/
N#ifndef __ROM_MAP_H__
N#define __ROM_MAP_H__
N
N//*****************************************************************************
N//
N// Macros for the ADC14 API.
N//
N//*****************************************************************************
N#ifdef ROM_ADC14_enableModule
S#define MAP_ADC14_enableModule                                                \
S        ROM_ADC14_enableModule
X#define MAP_ADC14_enableModule                                                        ROM_ADC14_enableModule
N#else
N#define MAP_ADC14_enableModule                                                \
N        ADC14_enableModule
X#define MAP_ADC14_enableModule                                                        ADC14_enableModule
N#endif
N#ifdef ROM_ADC14_disableModule
S#define MAP_ADC14_disableModule                                               \
S        ROM_ADC14_disableModule
X#define MAP_ADC14_disableModule                                                       ROM_ADC14_disableModule
N#else
N#define MAP_ADC14_disableModule                                               \
N        ADC14_disableModule
X#define MAP_ADC14_disableModule                                                       ADC14_disableModule
N#endif
N#ifdef ROM_ADC14_initModule
S#define MAP_ADC14_initModule                                                  \
S        ROM_ADC14_initModule
X#define MAP_ADC14_initModule                                                          ROM_ADC14_initModule
N#else
N#define MAP_ADC14_initModule                                                  \
N        ADC14_initModule
X#define MAP_ADC14_initModule                                                          ADC14_initModule
N#endif
N#ifdef ROM_ADC14_setResolution
S#define MAP_ADC14_setResolution                                               \
S        ROM_ADC14_setResolution
X#define MAP_ADC14_setResolution                                                       ROM_ADC14_setResolution
N#else
N#define MAP_ADC14_setResolution                                               \
N        ADC14_setResolution
X#define MAP_ADC14_setResolution                                                       ADC14_setResolution
N#endif
N#ifdef ROM_ADC14_getResolution
S#define MAP_ADC14_getResolution                                               \
S        ROM_ADC14_getResolution
X#define MAP_ADC14_getResolution                                                       ROM_ADC14_getResolution
N#else
N#define MAP_ADC14_getResolution                                               \
N        ADC14_getResolution
X#define MAP_ADC14_getResolution                                                       ADC14_getResolution
N#endif
N#ifdef ROM_ADC14_setSampleHoldTrigger
S#define MAP_ADC14_setSampleHoldTrigger                                        \
S        ROM_ADC14_setSampleHoldTrigger
X#define MAP_ADC14_setSampleHoldTrigger                                                ROM_ADC14_setSampleHoldTrigger
N#else
N#define MAP_ADC14_setSampleHoldTrigger                                        \
N        ADC14_setSampleHoldTrigger
X#define MAP_ADC14_setSampleHoldTrigger                                                ADC14_setSampleHoldTrigger
N#endif
N#ifdef ROM_ADC14_setSampleHoldTime
S#define MAP_ADC14_setSampleHoldTime                                           \
S        ROM_ADC14_setSampleHoldTime
X#define MAP_ADC14_setSampleHoldTime                                                   ROM_ADC14_setSampleHoldTime
N#else
N#define MAP_ADC14_setSampleHoldTime                                           \
N        ADC14_setSampleHoldTime
X#define MAP_ADC14_setSampleHoldTime                                                   ADC14_setSampleHoldTime
N#endif
N#ifdef ROM_ADC14_configureMultiSequenceMode
S#define MAP_ADC14_configureMultiSequenceMode                                  \
S        ROM_ADC14_configureMultiSequenceMode
X#define MAP_ADC14_configureMultiSequenceMode                                          ROM_ADC14_configureMultiSequenceMode
N#else
N#define MAP_ADC14_configureMultiSequenceMode                                  \
N        ADC14_configureMultiSequenceMode
X#define MAP_ADC14_configureMultiSequenceMode                                          ADC14_configureMultiSequenceMode
N#endif
N#ifdef ROM_ADC14_configureSingleSampleMode
S#define MAP_ADC14_configureSingleSampleMode                                   \
S        ROM_ADC14_configureSingleSampleMode
X#define MAP_ADC14_configureSingleSampleMode                                           ROM_ADC14_configureSingleSampleMode
N#else
N#define MAP_ADC14_configureSingleSampleMode                                   \
N        ADC14_configureSingleSampleMode
X#define MAP_ADC14_configureSingleSampleMode                                           ADC14_configureSingleSampleMode
N#endif
N#ifdef ROM_ADC14_enableConversion
S#define MAP_ADC14_enableConversion                                            \
S        ROM_ADC14_enableConversion
X#define MAP_ADC14_enableConversion                                                    ROM_ADC14_enableConversion
N#else
N#define MAP_ADC14_enableConversion                                            \
N        ADC14_enableConversion
X#define MAP_ADC14_enableConversion                                                    ADC14_enableConversion
N#endif
N#ifdef ROM_ADC14_disableConversion
S#define MAP_ADC14_disableConversion                                           \
S        ROM_ADC14_disableConversion
X#define MAP_ADC14_disableConversion                                                   ROM_ADC14_disableConversion
N#else
N#define MAP_ADC14_disableConversion                                           \
N        ADC14_disableConversion
X#define MAP_ADC14_disableConversion                                                   ADC14_disableConversion
N#endif
N#ifdef ROM_ADC14_isBusy
S#define MAP_ADC14_isBusy                                                      \
S        ROM_ADC14_isBusy
X#define MAP_ADC14_isBusy                                                              ROM_ADC14_isBusy
N#else
N#define MAP_ADC14_isBusy                                                      \
N        ADC14_isBusy
X#define MAP_ADC14_isBusy                                                              ADC14_isBusy
N#endif
N#ifdef ROM_ADC14_configureConversionMemory
S#define MAP_ADC14_configureConversionMemory                                   \
S        ROM_ADC14_configureConversionMemory
X#define MAP_ADC14_configureConversionMemory                                           ROM_ADC14_configureConversionMemory
N#else
N#define MAP_ADC14_configureConversionMemory                                   \
N        ADC14_configureConversionMemory
X#define MAP_ADC14_configureConversionMemory                                           ADC14_configureConversionMemory
N#endif
N#ifdef ROM_ADC14_enableComparatorWindow
S#define MAP_ADC14_enableComparatorWindow                                      \
S        ROM_ADC14_enableComparatorWindow
X#define MAP_ADC14_enableComparatorWindow                                              ROM_ADC14_enableComparatorWindow
N#else
N#define MAP_ADC14_enableComparatorWindow                                      \
N        ADC14_enableComparatorWindow
X#define MAP_ADC14_enableComparatorWindow                                              ADC14_enableComparatorWindow
N#endif
N#ifdef ROM_ADC14_disableComparatorWindow
S#define MAP_ADC14_disableComparatorWindow                                     \
S        ROM_ADC14_disableComparatorWindow
X#define MAP_ADC14_disableComparatorWindow                                             ROM_ADC14_disableComparatorWindow
N#else
N#define MAP_ADC14_disableComparatorWindow                                     \
N        ADC14_disableComparatorWindow
X#define MAP_ADC14_disableComparatorWindow                                             ADC14_disableComparatorWindow
N#endif
N#ifdef ROM_ADC14_setComparatorWindowValue
S#define MAP_ADC14_setComparatorWindowValue                                    \
S        ROM_ADC14_setComparatorWindowValue
X#define MAP_ADC14_setComparatorWindowValue                                            ROM_ADC14_setComparatorWindowValue
N#else
N#define MAP_ADC14_setComparatorWindowValue                                    \
N        ADC14_setComparatorWindowValue
X#define MAP_ADC14_setComparatorWindowValue                                            ADC14_setComparatorWindowValue
N#endif
N#ifdef ROM_ADC14_setResultFormat
S#define MAP_ADC14_setResultFormat                                             \
S        ROM_ADC14_setResultFormat
X#define MAP_ADC14_setResultFormat                                                     ROM_ADC14_setResultFormat
N#else
N#define MAP_ADC14_setResultFormat                                             \
N        ADC14_setResultFormat
X#define MAP_ADC14_setResultFormat                                                     ADC14_setResultFormat
N#endif
N#ifdef ROM_ADC14_getResult
S#define MAP_ADC14_getResult                                                   \
S        ROM_ADC14_getResult
X#define MAP_ADC14_getResult                                                           ROM_ADC14_getResult
N#else
N#define MAP_ADC14_getResult                                                   \
N        ADC14_getResult
X#define MAP_ADC14_getResult                                                           ADC14_getResult
N#endif
N#ifdef ROM_ADC14_getMultiSequenceResult
S#define MAP_ADC14_getMultiSequenceResult                                      \
S        ROM_ADC14_getMultiSequenceResult
X#define MAP_ADC14_getMultiSequenceResult                                              ROM_ADC14_getMultiSequenceResult
N#else
N#define MAP_ADC14_getMultiSequenceResult                                      \
N        ADC14_getMultiSequenceResult
X#define MAP_ADC14_getMultiSequenceResult                                              ADC14_getMultiSequenceResult
N#endif
N#ifdef ROM_ADC14_getResultArray
S#define MAP_ADC14_getResultArray                                              \
S        ROM_ADC14_getResultArray
X#define MAP_ADC14_getResultArray                                                      ROM_ADC14_getResultArray
N#else
N#define MAP_ADC14_getResultArray                                              \
N        ADC14_getResultArray
X#define MAP_ADC14_getResultArray                                                      ADC14_getResultArray
N#endif
N#ifdef ROM_ADC14_enableReferenceBurst
S#define MAP_ADC14_enableReferenceBurst                                        \
S        ROM_ADC14_enableReferenceBurst
X#define MAP_ADC14_enableReferenceBurst                                                ROM_ADC14_enableReferenceBurst
N#else
N#define MAP_ADC14_enableReferenceBurst                                        \
N        ADC14_enableReferenceBurst
X#define MAP_ADC14_enableReferenceBurst                                                ADC14_enableReferenceBurst
N#endif
N#ifdef ROM_ADC14_disableReferenceBurst
S#define MAP_ADC14_disableReferenceBurst                                       \
S        ROM_ADC14_disableReferenceBurst
X#define MAP_ADC14_disableReferenceBurst                                               ROM_ADC14_disableReferenceBurst
N#else
N#define MAP_ADC14_disableReferenceBurst                                       \
N        ADC14_disableReferenceBurst
X#define MAP_ADC14_disableReferenceBurst                                               ADC14_disableReferenceBurst
N#endif
N#ifdef ROM_ADC14_setPowerMode
S#define MAP_ADC14_setPowerMode                                                \
S        ROM_ADC14_setPowerMode
X#define MAP_ADC14_setPowerMode                                                        ROM_ADC14_setPowerMode
N#else
N#define MAP_ADC14_setPowerMode                                                \
N        ADC14_setPowerMode
X#define MAP_ADC14_setPowerMode                                                        ADC14_setPowerMode
N#endif
N#ifdef ROM_ADC14_enableInterrupt
S#define MAP_ADC14_enableInterrupt                                             \
S        ROM_ADC14_enableInterrupt
X#define MAP_ADC14_enableInterrupt                                                     ROM_ADC14_enableInterrupt
N#else
N#define MAP_ADC14_enableInterrupt                                             \
N        ADC14_enableInterrupt
X#define MAP_ADC14_enableInterrupt                                                     ADC14_enableInterrupt
N#endif
N#ifdef ROM_ADC14_disableInterrupt
S#define MAP_ADC14_disableInterrupt                                            \
S        ROM_ADC14_disableInterrupt
X#define MAP_ADC14_disableInterrupt                                                    ROM_ADC14_disableInterrupt
N#else
N#define MAP_ADC14_disableInterrupt                                            \
N        ADC14_disableInterrupt
X#define MAP_ADC14_disableInterrupt                                                    ADC14_disableInterrupt
N#endif
N#ifdef ROM_ADC14_getInterruptStatus
S#define MAP_ADC14_getInterruptStatus                                          \
S        ROM_ADC14_getInterruptStatus
X#define MAP_ADC14_getInterruptStatus                                                  ROM_ADC14_getInterruptStatus
N#else
N#define MAP_ADC14_getInterruptStatus                                          \
N        ADC14_getInterruptStatus
X#define MAP_ADC14_getInterruptStatus                                                  ADC14_getInterruptStatus
N#endif
N#ifdef ROM_ADC14_getEnabledInterruptStatus
S#define MAP_ADC14_getEnabledInterruptStatus                                   \
S        ROM_ADC14_getEnabledInterruptStatus
X#define MAP_ADC14_getEnabledInterruptStatus                                           ROM_ADC14_getEnabledInterruptStatus
N#else
N#define MAP_ADC14_getEnabledInterruptStatus                                   \
N        ADC14_getEnabledInterruptStatus
X#define MAP_ADC14_getEnabledInterruptStatus                                           ADC14_getEnabledInterruptStatus
N#endif
N#ifdef ROM_ADC14_clearInterruptFlag
S#define MAP_ADC14_clearInterruptFlag                                          \
S        ROM_ADC14_clearInterruptFlag
X#define MAP_ADC14_clearInterruptFlag                                                  ROM_ADC14_clearInterruptFlag
N#else
N#define MAP_ADC14_clearInterruptFlag                                          \
N        ADC14_clearInterruptFlag
X#define MAP_ADC14_clearInterruptFlag                                                  ADC14_clearInterruptFlag
N#endif
N#ifdef ROM_ADC14_toggleConversionTrigger
S#define MAP_ADC14_toggleConversionTrigger                                     \
S        ROM_ADC14_toggleConversionTrigger
X#define MAP_ADC14_toggleConversionTrigger                                             ROM_ADC14_toggleConversionTrigger
N#else
N#define MAP_ADC14_toggleConversionTrigger                                     \
N        ADC14_toggleConversionTrigger
X#define MAP_ADC14_toggleConversionTrigger                                             ADC14_toggleConversionTrigger
N#endif
N#ifdef ROM_ADC14_enableSampleTimer
S#define MAP_ADC14_enableSampleTimer                                           \
S        ROM_ADC14_enableSampleTimer
X#define MAP_ADC14_enableSampleTimer                                                   ROM_ADC14_enableSampleTimer
N#else
N#define MAP_ADC14_enableSampleTimer                                           \
N        ADC14_enableSampleTimer
X#define MAP_ADC14_enableSampleTimer                                                   ADC14_enableSampleTimer
N#endif
N#ifdef ROM_ADC14_disableSampleTimer
S#define MAP_ADC14_disableSampleTimer                                          \
S        ROM_ADC14_disableSampleTimer
X#define MAP_ADC14_disableSampleTimer                                                  ROM_ADC14_disableSampleTimer
N#else
N#define MAP_ADC14_disableSampleTimer                                          \
N        ADC14_disableSampleTimer
X#define MAP_ADC14_disableSampleTimer                                                  ADC14_disableSampleTimer
N#endif
N#ifdef ROM_ADC14_registerInterrupt
S#define MAP_ADC14_registerInterrupt                                           \
S        ROM_ADC14_registerInterrupt
X#define MAP_ADC14_registerInterrupt                                                   ROM_ADC14_registerInterrupt
N#else
N#define MAP_ADC14_registerInterrupt                                           \
N        ADC14_registerInterrupt
X#define MAP_ADC14_registerInterrupt                                                   ADC14_registerInterrupt
N#endif
N#ifdef ROM_ADC14_unregisterInterrupt
S#define MAP_ADC14_unregisterInterrupt                                         \
S        ROM_ADC14_unregisterInterrupt
X#define MAP_ADC14_unregisterInterrupt                                                 ROM_ADC14_unregisterInterrupt
N#else
N#define MAP_ADC14_unregisterInterrupt                                         \
N        ADC14_unregisterInterrupt
X#define MAP_ADC14_unregisterInterrupt                                                 ADC14_unregisterInterrupt
N#endif
N
N//*****************************************************************************
N//
N// Macros for the AES256 API.
N//
N//*****************************************************************************
N#ifdef ROM_AES256_setCipherKey
S#define MAP_AES256_setCipherKey                                               \
S        ROM_AES256_setCipherKey
X#define MAP_AES256_setCipherKey                                                       ROM_AES256_setCipherKey
N#else
N#define MAP_AES256_setCipherKey                                               \
N        AES256_setCipherKey
X#define MAP_AES256_setCipherKey                                                       AES256_setCipherKey
N#endif
N#ifdef ROM_AES256_encryptData
S#define MAP_AES256_encryptData                                                \
S        ROM_AES256_encryptData
X#define MAP_AES256_encryptData                                                        ROM_AES256_encryptData
N#else
N#define MAP_AES256_encryptData                                                \
N        AES256_encryptData
X#define MAP_AES256_encryptData                                                        AES256_encryptData
N#endif
N#ifdef ROM_AES256_decryptData
S#define MAP_AES256_decryptData                                                \
S        ROM_AES256_decryptData
X#define MAP_AES256_decryptData                                                        ROM_AES256_decryptData
N#else
N#define MAP_AES256_decryptData                                                \
N        AES256_decryptData
X#define MAP_AES256_decryptData                                                        AES256_decryptData
N#endif
N#ifdef ROM_AES256_setDecipherKey
S#define MAP_AES256_setDecipherKey                                             \
S        ROM_AES256_setDecipherKey
X#define MAP_AES256_setDecipherKey                                                     ROM_AES256_setDecipherKey
N#else
N#define MAP_AES256_setDecipherKey                                             \
N        AES256_setDecipherKey
X#define MAP_AES256_setDecipherKey                                                     AES256_setDecipherKey
N#endif
N#ifdef ROM_AES256_reset
S#define MAP_AES256_reset                                                      \
S        ROM_AES256_reset
X#define MAP_AES256_reset                                                              ROM_AES256_reset
N#else
N#define MAP_AES256_reset                                                      \
N        AES256_reset
X#define MAP_AES256_reset                                                              AES256_reset
N#endif
N#ifdef ROM_AES256_startEncryptData
S#define MAP_AES256_startEncryptData                                           \
S        ROM_AES256_startEncryptData
X#define MAP_AES256_startEncryptData                                                   ROM_AES256_startEncryptData
N#else
N#define MAP_AES256_startEncryptData                                           \
N        AES256_startEncryptData
X#define MAP_AES256_startEncryptData                                                   AES256_startEncryptData
N#endif
N#ifdef ROM_AES256_startDecryptData
S#define MAP_AES256_startDecryptData                                           \
S        ROM_AES256_startDecryptData
X#define MAP_AES256_startDecryptData                                                   ROM_AES256_startDecryptData
N#else
N#define MAP_AES256_startDecryptData                                           \
N        AES256_startDecryptData
X#define MAP_AES256_startDecryptData                                                   AES256_startDecryptData
N#endif
N#ifdef ROM_AES256_startSetDecipherKey
S#define MAP_AES256_startSetDecipherKey                                        \
S        ROM_AES256_startSetDecipherKey
X#define MAP_AES256_startSetDecipherKey                                                ROM_AES256_startSetDecipherKey
N#else
N#define MAP_AES256_startSetDecipherKey                                        \
N        AES256_startSetDecipherKey
X#define MAP_AES256_startSetDecipherKey                                                AES256_startSetDecipherKey
N#endif
N#ifdef ROM_AES256_getDataOut
S#define MAP_AES256_getDataOut                                                 \
S        ROM_AES256_getDataOut
X#define MAP_AES256_getDataOut                                                         ROM_AES256_getDataOut
N#else
N#define MAP_AES256_getDataOut                                                 \
N        AES256_getDataOut
X#define MAP_AES256_getDataOut                                                         AES256_getDataOut
N#endif
N#ifdef ROM_AES256_isBusy
S#define MAP_AES256_isBusy                                                     \
S        ROM_AES256_isBusy
X#define MAP_AES256_isBusy                                                             ROM_AES256_isBusy
N#else
N#define MAP_AES256_isBusy                                                     \
N        AES256_isBusy
X#define MAP_AES256_isBusy                                                             AES256_isBusy
N#endif
N#ifdef ROM_AES256_clearErrorFlag
S#define MAP_AES256_clearErrorFlag                                             \
S        ROM_AES256_clearErrorFlag
X#define MAP_AES256_clearErrorFlag                                                     ROM_AES256_clearErrorFlag
N#else
N#define MAP_AES256_clearErrorFlag                                             \
N        AES256_clearErrorFlag
X#define MAP_AES256_clearErrorFlag                                                     AES256_clearErrorFlag
N#endif
N#ifdef ROM_AES256_getErrorFlagStatus
S#define MAP_AES256_getErrorFlagStatus                                         \
S        ROM_AES256_getErrorFlagStatus
X#define MAP_AES256_getErrorFlagStatus                                                 ROM_AES256_getErrorFlagStatus
N#else
N#define MAP_AES256_getErrorFlagStatus                                         \
N        AES256_getErrorFlagStatus
X#define MAP_AES256_getErrorFlagStatus                                                 AES256_getErrorFlagStatus
N#endif
N#ifdef ROM_AES256_clearInterruptFlag
S#define MAP_AES256_clearInterruptFlag                                         \
S        ROM_AES256_clearInterruptFlag
X#define MAP_AES256_clearInterruptFlag                                                 ROM_AES256_clearInterruptFlag
N#else
N#define MAP_AES256_clearInterruptFlag                                         \
N        AES256_clearInterruptFlag
X#define MAP_AES256_clearInterruptFlag                                                 AES256_clearInterruptFlag
N#endif
N#ifdef ROM_AES256_getInterruptStatus
S#define MAP_AES256_getInterruptStatus                                         \
S        ROM_AES256_getInterruptStatus
X#define MAP_AES256_getInterruptStatus                                                 ROM_AES256_getInterruptStatus
N#else
N#define MAP_AES256_getInterruptStatus                                         \
N        AES256_getInterruptStatus
X#define MAP_AES256_getInterruptStatus                                                 AES256_getInterruptStatus
N#endif
N#ifdef ROM_AES256_enableInterrupt
S#define MAP_AES256_enableInterrupt                                            \
S        ROM_AES256_enableInterrupt
X#define MAP_AES256_enableInterrupt                                                    ROM_AES256_enableInterrupt
N#else
N#define MAP_AES256_enableInterrupt                                            \
N        AES256_enableInterrupt
X#define MAP_AES256_enableInterrupt                                                    AES256_enableInterrupt
N#endif
N#ifdef ROM_AES256_disableInterrupt
S#define MAP_AES256_disableInterrupt                                           \
S        ROM_AES256_disableInterrupt
X#define MAP_AES256_disableInterrupt                                                   ROM_AES256_disableInterrupt
N#else
N#define MAP_AES256_disableInterrupt                                           \
N        AES256_disableInterrupt
X#define MAP_AES256_disableInterrupt                                                   AES256_disableInterrupt
N#endif
N#ifdef ROM_AES256_registerInterrupt
S#define MAP_AES256_registerInterrupt                                          \
S        ROM_AES256_registerInterrupt
X#define MAP_AES256_registerInterrupt                                                  ROM_AES256_registerInterrupt
N#else
N#define MAP_AES256_registerInterrupt                                          \
N        AES256_registerInterrupt
X#define MAP_AES256_registerInterrupt                                                  AES256_registerInterrupt
N#endif
N#ifdef ROM_AES256_unregisterInterrupt
S#define MAP_AES256_unregisterInterrupt                                        \
S        ROM_AES256_unregisterInterrupt
X#define MAP_AES256_unregisterInterrupt                                                ROM_AES256_unregisterInterrupt
N#else
N#define MAP_AES256_unregisterInterrupt                                        \
N        AES256_unregisterInterrupt
X#define MAP_AES256_unregisterInterrupt                                                AES256_unregisterInterrupt
N#endif
N#ifdef ROM_AES256_getInterruptFlagStatus
S#define MAP_AES256_getInterruptFlagStatus                                     \
S        ROM_AES256_getInterruptFlagStatus
X#define MAP_AES256_getInterruptFlagStatus                                             ROM_AES256_getInterruptFlagStatus
N#else
N#define MAP_AES256_getInterruptFlagStatus                                     \
N        AES256_getInterruptFlagStatus
X#define MAP_AES256_getInterruptFlagStatus                                             AES256_getInterruptFlagStatus
N#endif
N
N//*****************************************************************************
N//
N// Macros for the Comp API.
N//
N//*****************************************************************************
N#ifdef ROM_COMP_E_initModule
S#define MAP_COMP_E_initModule                                                 \
S        ROM_COMP_E_initModule
X#define MAP_COMP_E_initModule                                                         ROM_COMP_E_initModule
N#else
N#define MAP_COMP_E_initModule                                                 \
N        COMP_E_initModule
X#define MAP_COMP_E_initModule                                                         COMP_E_initModule
N#endif
N#ifdef ROM_COMP_E_setReferenceVoltage
S#define MAP_COMP_E_setReferenceVoltage                                        \
S        ROM_COMP_E_setReferenceVoltage
X#define MAP_COMP_E_setReferenceVoltage                                                ROM_COMP_E_setReferenceVoltage
N#else
N#define MAP_COMP_E_setReferenceVoltage                                        \
N        COMP_E_setReferenceVoltage
X#define MAP_COMP_E_setReferenceVoltage                                                COMP_E_setReferenceVoltage
N#endif
N#ifdef ROM_COMP_E_setReferenceAccuracy
S#define MAP_COMP_E_setReferenceAccuracy                                       \
S        ROM_COMP_E_setReferenceAccuracy
X#define MAP_COMP_E_setReferenceAccuracy                                               ROM_COMP_E_setReferenceAccuracy
N#else
N#define MAP_COMP_E_setReferenceAccuracy                                       \
N        COMP_E_setReferenceAccuracy
X#define MAP_COMP_E_setReferenceAccuracy                                               COMP_E_setReferenceAccuracy
N#endif
N#ifdef ROM_COMP_E_setPowerMode
S#define MAP_COMP_E_setPowerMode                                               \
S        ROM_COMP_E_setPowerMode
X#define MAP_COMP_E_setPowerMode                                                       ROM_COMP_E_setPowerMode
N#else
N#define MAP_COMP_E_setPowerMode                                               \
N        COMP_E_setPowerMode
X#define MAP_COMP_E_setPowerMode                                                       COMP_E_setPowerMode
N#endif
N#ifdef ROM_COMP_E_enableModule
S#define MAP_COMP_E_enableModule                                               \
S        ROM_COMP_E_enableModule
X#define MAP_COMP_E_enableModule                                                       ROM_COMP_E_enableModule
N#else
N#define MAP_COMP_E_enableModule                                               \
N        COMP_E_enableModule
X#define MAP_COMP_E_enableModule                                                       COMP_E_enableModule
N#endif
N#ifdef ROM_COMP_E_disableModule
S#define MAP_COMP_E_disableModule                                              \
S        ROM_COMP_E_disableModule
X#define MAP_COMP_E_disableModule                                                      ROM_COMP_E_disableModule
N#else
N#define MAP_COMP_E_disableModule                                              \
N        COMP_E_disableModule
X#define MAP_COMP_E_disableModule                                                      COMP_E_disableModule
N#endif
N#ifdef ROM_COMP_E_shortInputs
S#define MAP_COMP_E_shortInputs                                                \
S        ROM_COMP_E_shortInputs
X#define MAP_COMP_E_shortInputs                                                        ROM_COMP_E_shortInputs
N#else
N#define MAP_COMP_E_shortInputs                                                \
N        COMP_E_shortInputs
X#define MAP_COMP_E_shortInputs                                                        COMP_E_shortInputs
N#endif
N#ifdef ROM_COMP_E_unshortInputs
S#define MAP_COMP_E_unshortInputs                                              \
S        ROM_COMP_E_unshortInputs
X#define MAP_COMP_E_unshortInputs                                                      ROM_COMP_E_unshortInputs
N#else
N#define MAP_COMP_E_unshortInputs                                              \
N        COMP_E_unshortInputs
X#define MAP_COMP_E_unshortInputs                                                      COMP_E_unshortInputs
N#endif
N#ifdef ROM_COMP_E_disableInputBuffer
S#define MAP_COMP_E_disableInputBuffer                                         \
S        ROM_COMP_E_disableInputBuffer
X#define MAP_COMP_E_disableInputBuffer                                                 ROM_COMP_E_disableInputBuffer
N#else
N#define MAP_COMP_E_disableInputBuffer                                         \
N        COMP_E_disableInputBuffer
X#define MAP_COMP_E_disableInputBuffer                                                 COMP_E_disableInputBuffer
N#endif
N#ifdef ROM_COMP_E_enableInputBuffer
S#define MAP_COMP_E_enableInputBuffer                                          \
S        ROM_COMP_E_enableInputBuffer
X#define MAP_COMP_E_enableInputBuffer                                                  ROM_COMP_E_enableInputBuffer
N#else
N#define MAP_COMP_E_enableInputBuffer                                          \
N        COMP_E_enableInputBuffer
X#define MAP_COMP_E_enableInputBuffer                                                  COMP_E_enableInputBuffer
N#endif
N#ifdef ROM_COMP_E_swapIO
S#define MAP_COMP_E_swapIO                                                     \
S        ROM_COMP_E_swapIO
X#define MAP_COMP_E_swapIO                                                             ROM_COMP_E_swapIO
N#else
N#define MAP_COMP_E_swapIO                                                     \
N        COMP_E_swapIO
X#define MAP_COMP_E_swapIO                                                             COMP_E_swapIO
N#endif
N#ifdef ROM_COMP_E_outputValue
S#define MAP_COMP_E_outputValue                                                \
S        ROM_COMP_E_outputValue
X#define MAP_COMP_E_outputValue                                                        ROM_COMP_E_outputValue
N#else
N#define MAP_COMP_E_outputValue                                                \
N        COMP_E_outputValue
X#define MAP_COMP_E_outputValue                                                        COMP_E_outputValue
N#endif
N#ifdef ROM_COMP_E_enableInterrupt
S#define MAP_COMP_E_enableInterrupt                                            \
S        ROM_COMP_E_enableInterrupt
X#define MAP_COMP_E_enableInterrupt                                                    ROM_COMP_E_enableInterrupt
N#else
N#define MAP_COMP_E_enableInterrupt                                            \
N        COMP_E_enableInterrupt
X#define MAP_COMP_E_enableInterrupt                                                    COMP_E_enableInterrupt
N#endif
N#ifdef ROM_COMP_E_disableInterrupt
S#define MAP_COMP_E_disableInterrupt                                           \
S        ROM_COMP_E_disableInterrupt
X#define MAP_COMP_E_disableInterrupt                                                   ROM_COMP_E_disableInterrupt
N#else
N#define MAP_COMP_E_disableInterrupt                                           \
N        COMP_E_disableInterrupt
X#define MAP_COMP_E_disableInterrupt                                                   COMP_E_disableInterrupt
N#endif
N#ifdef ROM_COMP_E_clearInterruptFlag
S#define MAP_COMP_E_clearInterruptFlag                                         \
S        ROM_COMP_E_clearInterruptFlag
X#define MAP_COMP_E_clearInterruptFlag                                                 ROM_COMP_E_clearInterruptFlag
N#else
N#define MAP_COMP_E_clearInterruptFlag                                         \
N        COMP_E_clearInterruptFlag
X#define MAP_COMP_E_clearInterruptFlag                                                 COMP_E_clearInterruptFlag
N#endif
N#ifdef ROM_COMP_E_getInterruptStatus
S#define MAP_COMP_E_getInterruptStatus                                         \
S        ROM_COMP_E_getInterruptStatus
X#define MAP_COMP_E_getInterruptStatus                                                 ROM_COMP_E_getInterruptStatus
N#else
N#define MAP_COMP_E_getInterruptStatus                                         \
N        COMP_E_getInterruptStatus
X#define MAP_COMP_E_getInterruptStatus                                                 COMP_E_getInterruptStatus
N#endif
N#ifdef ROM_COMP_E_getEnabledInterruptStatus
S#define MAP_COMP_E_getEnabledInterruptStatus                                  \
S        ROM_COMP_E_getEnabledInterruptStatus
X#define MAP_COMP_E_getEnabledInterruptStatus                                          ROM_COMP_E_getEnabledInterruptStatus
N#else
N#define MAP_COMP_E_getEnabledInterruptStatus                                  \
N        COMP_E_getEnabledInterruptStatus
X#define MAP_COMP_E_getEnabledInterruptStatus                                          COMP_E_getEnabledInterruptStatus
N#endif
N#ifdef ROM_COMP_E_setInterruptEdgeDirection
S#define MAP_COMP_E_setInterruptEdgeDirection                                  \
S        ROM_COMP_E_setInterruptEdgeDirection
X#define MAP_COMP_E_setInterruptEdgeDirection                                          ROM_COMP_E_setInterruptEdgeDirection
N#else
N#define MAP_COMP_E_setInterruptEdgeDirection                                  \
N        COMP_E_setInterruptEdgeDirection
X#define MAP_COMP_E_setInterruptEdgeDirection                                          COMP_E_setInterruptEdgeDirection
N#endif
N#ifdef ROM_COMP_E_toggleInterruptEdgeDirection
S#define MAP_COMP_E_toggleInterruptEdgeDirection                               \
S        ROM_COMP_E_toggleInterruptEdgeDirection
X#define MAP_COMP_E_toggleInterruptEdgeDirection                                       ROM_COMP_E_toggleInterruptEdgeDirection
N#else
N#define MAP_COMP_E_toggleInterruptEdgeDirection                               \
N        COMP_E_toggleInterruptEdgeDirection
X#define MAP_COMP_E_toggleInterruptEdgeDirection                                       COMP_E_toggleInterruptEdgeDirection
N#endif
N#ifdef ROM_COMP_E_registerInterrupt
S#define MAP_COMP_E_registerInterrupt                                          \
S        ROM_COMP_E_registerInterrupt
X#define MAP_COMP_E_registerInterrupt                                                  ROM_COMP_E_registerInterrupt
N#else
N#define MAP_COMP_E_registerInterrupt                                          \
N        COMP_E_registerInterrupt
X#define MAP_COMP_E_registerInterrupt                                                  COMP_E_registerInterrupt
N#endif
N#ifdef ROM_COMP_E_unregisterInterrupt
S#define MAP_COMP_E_unregisterInterrupt                                        \
S        ROM_COMP_E_unregisterInterrupt
X#define MAP_COMP_E_unregisterInterrupt                                                ROM_COMP_E_unregisterInterrupt
N#else
N#define MAP_COMP_E_unregisterInterrupt                                        \
N        COMP_E_unregisterInterrupt
X#define MAP_COMP_E_unregisterInterrupt                                                COMP_E_unregisterInterrupt
N#endif
N
N//*****************************************************************************
N//
N// Macros for the CRC32 API.
N//
N//*****************************************************************************
N#ifdef ROM_CRC32_setSeed
S#define MAP_CRC32_setSeed                                                     \
S        ROM_CRC32_setSeed
X#define MAP_CRC32_setSeed                                                             ROM_CRC32_setSeed
N#else
N#define MAP_CRC32_setSeed                                                     \
N        CRC32_setSeed
X#define MAP_CRC32_setSeed                                                             CRC32_setSeed
N#endif
N#ifdef ROM_CRC32_set8BitData
S#define MAP_CRC32_set8BitData                                                 \
S        ROM_CRC32_set8BitData
X#define MAP_CRC32_set8BitData                                                         ROM_CRC32_set8BitData
N#else
N#define MAP_CRC32_set8BitData                                                 \
N        CRC32_set8BitData
X#define MAP_CRC32_set8BitData                                                         CRC32_set8BitData
N#endif
N#ifdef ROM_CRC32_set16BitData
S#define MAP_CRC32_set16BitData                                                \
S        ROM_CRC32_set16BitData
X#define MAP_CRC32_set16BitData                                                        ROM_CRC32_set16BitData
N#else
N#define MAP_CRC32_set16BitData                                                \
N        CRC32_set16BitData
X#define MAP_CRC32_set16BitData                                                        CRC32_set16BitData
N#endif
N#ifdef ROM_CRC32_set32BitData
S#define MAP_CRC32_set32BitData                                                \
S        ROM_CRC32_set32BitData
X#define MAP_CRC32_set32BitData                                                        ROM_CRC32_set32BitData
N#else
N#define MAP_CRC32_set32BitData                                                \
N        CRC32_set32BitData
X#define MAP_CRC32_set32BitData                                                        CRC32_set32BitData
N#endif
N#ifdef ROM_CRC32_set8BitDataReversed
S#define MAP_CRC32_set8BitDataReversed                                         \
S        ROM_CRC32_set8BitDataReversed
X#define MAP_CRC32_set8BitDataReversed                                                 ROM_CRC32_set8BitDataReversed
N#else
N#define MAP_CRC32_set8BitDataReversed                                         \
N        CRC32_set8BitDataReversed
X#define MAP_CRC32_set8BitDataReversed                                                 CRC32_set8BitDataReversed
N#endif
N#ifdef ROM_CRC32_set16BitDataReversed
S#define MAP_CRC32_set16BitDataReversed                                        \
S        ROM_CRC32_set16BitDataReversed
X#define MAP_CRC32_set16BitDataReversed                                                ROM_CRC32_set16BitDataReversed
N#else
N#define MAP_CRC32_set16BitDataReversed                                        \
N        CRC32_set16BitDataReversed
X#define MAP_CRC32_set16BitDataReversed                                                CRC32_set16BitDataReversed
N#endif
N#ifdef ROM_CRC32_set32BitDataReversed
S#define MAP_CRC32_set32BitDataReversed                                        \
S        ROM_CRC32_set32BitDataReversed
X#define MAP_CRC32_set32BitDataReversed                                                ROM_CRC32_set32BitDataReversed
N#else
N#define MAP_CRC32_set32BitDataReversed                                        \
N        CRC32_set32BitDataReversed
X#define MAP_CRC32_set32BitDataReversed                                                CRC32_set32BitDataReversed
N#endif
N#ifdef ROM_CRC32_getResult
S#define MAP_CRC32_getResult                                                   \
S        ROM_CRC32_getResult
X#define MAP_CRC32_getResult                                                           ROM_CRC32_getResult
N#else
N#define MAP_CRC32_getResult                                                   \
N        CRC32_getResult
X#define MAP_CRC32_getResult                                                           CRC32_getResult
N#endif
N#ifdef ROM_CRC32_getResultReversed
S#define MAP_CRC32_getResultReversed                                           \
S        ROM_CRC32_getResultReversed
X#define MAP_CRC32_getResultReversed                                                   ROM_CRC32_getResultReversed
N#else
N#define MAP_CRC32_getResultReversed                                           \
N        CRC32_getResultReversed
X#define MAP_CRC32_getResultReversed                                                   CRC32_getResultReversed
N#endif
N
N//*****************************************************************************
N//
N// Macros for the CS API.
N//
N//*****************************************************************************
N#ifdef ROM_CS_initClockSignal
S#define MAP_CS_initClockSignal                                                \
S        ROM_CS_initClockSignal
X#define MAP_CS_initClockSignal                                                        ROM_CS_initClockSignal
N#else
N#define MAP_CS_initClockSignal                                                \
N        CS_initClockSignal
X#define MAP_CS_initClockSignal                                                        CS_initClockSignal
N#endif
N#ifdef ROM_CS_setReferenceOscillatorFrequency
S#define MAP_CS_setReferenceOscillatorFrequency                                \
S        ROM_CS_setReferenceOscillatorFrequency
X#define MAP_CS_setReferenceOscillatorFrequency                                        ROM_CS_setReferenceOscillatorFrequency
N#else
N#define MAP_CS_setReferenceOscillatorFrequency                                \
N        CS_setReferenceOscillatorFrequency
X#define MAP_CS_setReferenceOscillatorFrequency                                        CS_setReferenceOscillatorFrequency
N#endif
N#ifdef ROM_CS_enableClockRequest
S#define MAP_CS_enableClockRequest                                             \
S        ROM_CS_enableClockRequest
X#define MAP_CS_enableClockRequest                                                     ROM_CS_enableClockRequest
N#else
N#define MAP_CS_enableClockRequest                                             \
N        CS_enableClockRequest
X#define MAP_CS_enableClockRequest                                                     CS_enableClockRequest
N#endif
N#ifdef ROM_CS_disableClockRequest
S#define MAP_CS_disableClockRequest                                            \
S        ROM_CS_disableClockRequest
X#define MAP_CS_disableClockRequest                                                    ROM_CS_disableClockRequest
N#else
N#define MAP_CS_disableClockRequest                                            \
N        CS_disableClockRequest
X#define MAP_CS_disableClockRequest                                                    CS_disableClockRequest
N#endif
N#ifdef ROM_CS_setDCOCenteredFrequency
S#define MAP_CS_setDCOCenteredFrequency                                        \
S        ROM_CS_setDCOCenteredFrequency
X#define MAP_CS_setDCOCenteredFrequency                                                ROM_CS_setDCOCenteredFrequency
N#else
N#define MAP_CS_setDCOCenteredFrequency                                        \
N        CS_setDCOCenteredFrequency
X#define MAP_CS_setDCOCenteredFrequency                                                CS_setDCOCenteredFrequency
N#endif
N#ifdef ROM_CS_tuneDCOFrequency
S#define MAP_CS_tuneDCOFrequency                                               \
S        ROM_CS_tuneDCOFrequency
X#define MAP_CS_tuneDCOFrequency                                                       ROM_CS_tuneDCOFrequency
N#else
N#define MAP_CS_tuneDCOFrequency                                               \
N        CS_tuneDCOFrequency
X#define MAP_CS_tuneDCOFrequency                                                       CS_tuneDCOFrequency
N#endif
N#ifdef ROM_CS_enableDCOExternalResistor
S#define MAP_CS_enableDCOExternalResistor                                      \
S        ROM_CS_enableDCOExternalResistor
X#define MAP_CS_enableDCOExternalResistor                                              ROM_CS_enableDCOExternalResistor
N#else
N#define MAP_CS_enableDCOExternalResistor                                      \
N        CS_enableDCOExternalResistor
X#define MAP_CS_enableDCOExternalResistor                                              CS_enableDCOExternalResistor
N#endif
N#ifdef ROM_CS_disableDCOExternalResistor
S#define MAP_CS_disableDCOExternalResistor                                     \
S        ROM_CS_disableDCOExternalResistor
X#define MAP_CS_disableDCOExternalResistor                                             ROM_CS_disableDCOExternalResistor
N#else
N#define MAP_CS_disableDCOExternalResistor                                     \
N        CS_disableDCOExternalResistor
X#define MAP_CS_disableDCOExternalResistor                                             CS_disableDCOExternalResistor
N#endif
N#ifdef ROM_CS_enableInterrupt
S#define MAP_CS_enableInterrupt                                                \
S        ROM_CS_enableInterrupt
X#define MAP_CS_enableInterrupt                                                        ROM_CS_enableInterrupt
N#else
N#define MAP_CS_enableInterrupt                                                \
N        CS_enableInterrupt
X#define MAP_CS_enableInterrupt                                                        CS_enableInterrupt
N#endif
N#ifdef ROM_CS_disableInterrupt
S#define MAP_CS_disableInterrupt                                               \
S        ROM_CS_disableInterrupt
X#define MAP_CS_disableInterrupt                                                       ROM_CS_disableInterrupt
N#else
N#define MAP_CS_disableInterrupt                                               \
N        CS_disableInterrupt
X#define MAP_CS_disableInterrupt                                                       CS_disableInterrupt
N#endif
N#ifdef ROM_CS_getEnabledInterruptStatus
S#define MAP_CS_getEnabledInterruptStatus                                      \
S        ROM_CS_getEnabledInterruptStatus
X#define MAP_CS_getEnabledInterruptStatus                                              ROM_CS_getEnabledInterruptStatus
N#else
N#define MAP_CS_getEnabledInterruptStatus                                      \
N        CS_getEnabledInterruptStatus
X#define MAP_CS_getEnabledInterruptStatus                                              CS_getEnabledInterruptStatus
N#endif
N#ifdef ROM_CS_getInterruptStatus
S#define MAP_CS_getInterruptStatus                                             \
S        ROM_CS_getInterruptStatus
X#define MAP_CS_getInterruptStatus                                                     ROM_CS_getInterruptStatus
N#else
N#define MAP_CS_getInterruptStatus                                             \
N        CS_getInterruptStatus
X#define MAP_CS_getInterruptStatus                                                     CS_getInterruptStatus
N#endif
N#ifdef ROM_CS_setDCOFrequency
S#define MAP_CS_setDCOFrequency                                                \
S        ROM_CS_setDCOFrequency
X#define MAP_CS_setDCOFrequency                                                        ROM_CS_setDCOFrequency
N#else
N#define MAP_CS_setDCOFrequency                                                \
N        CS_setDCOFrequency
X#define MAP_CS_setDCOFrequency                                                        CS_setDCOFrequency
N#endif
N#ifdef ROM_CS_getDCOFrequency
S#define MAP_CS_getDCOFrequency                                                \
S        ROM_CS_getDCOFrequency
X#define MAP_CS_getDCOFrequency                                                        ROM_CS_getDCOFrequency
N#else
N#define MAP_CS_getDCOFrequency                                                \
N        CS_getDCOFrequency
X#define MAP_CS_getDCOFrequency                                                        CS_getDCOFrequency
N#endif
N#ifdef ROM_CS_enableFaultCounter
S#define MAP_CS_enableFaultCounter                                             \
S        ROM_CS_enableFaultCounter
X#define MAP_CS_enableFaultCounter                                                     ROM_CS_enableFaultCounter
N#else
N#define MAP_CS_enableFaultCounter                                             \
N        CS_enableFaultCounter
X#define MAP_CS_enableFaultCounter                                                     CS_enableFaultCounter
N#endif
N#ifdef ROM_CS_disableFaultCounter
S#define MAP_CS_disableFaultCounter                                            \
S        ROM_CS_disableFaultCounter
X#define MAP_CS_disableFaultCounter                                                    ROM_CS_disableFaultCounter
N#else
N#define MAP_CS_disableFaultCounter                                            \
N        CS_disableFaultCounter
X#define MAP_CS_disableFaultCounter                                                    CS_disableFaultCounter
N#endif
N#ifdef ROM_CS_resetFaultCounter
S#define MAP_CS_resetFaultCounter                                              \
S        ROM_CS_resetFaultCounter
X#define MAP_CS_resetFaultCounter                                                      ROM_CS_resetFaultCounter
N#else
N#define MAP_CS_resetFaultCounter                                              \
N        CS_resetFaultCounter
X#define MAP_CS_resetFaultCounter                                                      CS_resetFaultCounter
N#endif
N#ifdef ROM_CS_startFaultCounter
S#define MAP_CS_startFaultCounter                                              \
S        ROM_CS_startFaultCounter
X#define MAP_CS_startFaultCounter                                                      ROM_CS_startFaultCounter
N#else
N#define MAP_CS_startFaultCounter                                              \
N        CS_startFaultCounter
X#define MAP_CS_startFaultCounter                                                      CS_startFaultCounter
N#endif
N#ifdef ROM_CS_registerInterrupt
S#define MAP_CS_registerInterrupt                                              \
S        ROM_CS_registerInterrupt
X#define MAP_CS_registerInterrupt                                                      ROM_CS_registerInterrupt
N#else
N#define MAP_CS_registerInterrupt                                              \
N        CS_registerInterrupt
X#define MAP_CS_registerInterrupt                                                      CS_registerInterrupt
N#endif
N#ifdef ROM_CS_unregisterInterrupt
S#define MAP_CS_unregisterInterrupt                                            \
S        ROM_CS_unregisterInterrupt
X#define MAP_CS_unregisterInterrupt                                                    ROM_CS_unregisterInterrupt
N#else
N#define MAP_CS_unregisterInterrupt                                            \
N        CS_unregisterInterrupt
X#define MAP_CS_unregisterInterrupt                                                    CS_unregisterInterrupt
N#endif
N#ifdef ROM_CS_clearInterruptFlag
S#define MAP_CS_clearInterruptFlag                                             \
S        ROM_CS_clearInterruptFlag
X#define MAP_CS_clearInterruptFlag                                                     ROM_CS_clearInterruptFlag
N#else
N#define MAP_CS_clearInterruptFlag                                             \
N        CS_clearInterruptFlag
X#define MAP_CS_clearInterruptFlag                                                     CS_clearInterruptFlag
N#endif
N#ifdef ROM_CS_getACLK
S#define MAP_CS_getACLK                                                        \
S        ROM_CS_getACLK
X#define MAP_CS_getACLK                                                                ROM_CS_getACLK
N#else
N#define MAP_CS_getACLK                                                        \
N        CS_getACLK
X#define MAP_CS_getACLK                                                                CS_getACLK
N#endif
N#ifdef ROM_CS_getSMCLK
S#define MAP_CS_getSMCLK                                                       \
S        ROM_CS_getSMCLK
X#define MAP_CS_getSMCLK                                                               ROM_CS_getSMCLK
N#else
N#define MAP_CS_getSMCLK                                                       \
N        CS_getSMCLK
X#define MAP_CS_getSMCLK                                                               CS_getSMCLK
N#endif
N#ifdef ROM_CS_getMCLK
S#define MAP_CS_getMCLK                                                        \
S        ROM_CS_getMCLK
X#define MAP_CS_getMCLK                                                                ROM_CS_getMCLK
N#else
N#define MAP_CS_getMCLK                                                        \
N        CS_getMCLK
X#define MAP_CS_getMCLK                                                                CS_getMCLK
N#endif
N#ifdef ROM_CS_getBCLK
S#define MAP_CS_getBCLK                                                        \
S        ROM_CS_getBCLK
X#define MAP_CS_getBCLK                                                                ROM_CS_getBCLK
N#else
N#define MAP_CS_getBCLK                                                        \
N        CS_getBCLK
X#define MAP_CS_getBCLK                                                                CS_getBCLK
N#endif
N#ifdef ROM_CS_getHSMCLK
S#define MAP_CS_getHSMCLK                                                      \
S        ROM_CS_getHSMCLK
X#define MAP_CS_getHSMCLK                                                              ROM_CS_getHSMCLK
N#else
N#define MAP_CS_getHSMCLK                                                      \
N        CS_getHSMCLK
X#define MAP_CS_getHSMCLK                                                              CS_getHSMCLK
N#endif
N#ifdef ROM_CS_startHFXT
S#define MAP_CS_startHFXT                                                      \
S        ROM_CS_startHFXT
X#define MAP_CS_startHFXT                                                              ROM_CS_startHFXT
N#else
N#define MAP_CS_startHFXT                                                      \
N        CS_startHFXT
X#define MAP_CS_startHFXT                                                              CS_startHFXT
N#endif
N#ifdef ROM_CS_startHFXTWithTimeout
S#define MAP_CS_startHFXTWithTimeout                                           \
S        ROM_CS_startHFXTWithTimeout
X#define MAP_CS_startHFXTWithTimeout                                                   ROM_CS_startHFXTWithTimeout
N#else
N#define MAP_CS_startHFXTWithTimeout                                           \
N        CS_startHFXTWithTimeout
X#define MAP_CS_startHFXTWithTimeout                                                   CS_startHFXTWithTimeout
N#endif
N#ifdef ROM_CS_startLFXT
S#define MAP_CS_startLFXT                                                      \
S        ROM_CS_startLFXT
X#define MAP_CS_startLFXT                                                              ROM_CS_startLFXT
N#else
N#define MAP_CS_startLFXT                                                      \
N        CS_startLFXT
X#define MAP_CS_startLFXT                                                              CS_startLFXT
N#endif
N#ifdef ROM_CS_startLFXTWithTimeout
S#define MAP_CS_startLFXTWithTimeout                                           \
S        ROM_CS_startLFXTWithTimeout
X#define MAP_CS_startLFXTWithTimeout                                                   ROM_CS_startLFXTWithTimeout
N#else
N#define MAP_CS_startLFXTWithTimeout                                           \
N        CS_startLFXTWithTimeout
X#define MAP_CS_startLFXTWithTimeout                                                   CS_startLFXTWithTimeout
N#endif
N#ifdef ROM_CS_setExternalClockSourceFrequency
S#define MAP_CS_setExternalClockSourceFrequency                                \
S        ROM_CS_setExternalClockSourceFrequency
X#define MAP_CS_setExternalClockSourceFrequency                                        ROM_CS_setExternalClockSourceFrequency
N#else
N#define MAP_CS_setExternalClockSourceFrequency                                \
N        CS_setExternalClockSourceFrequency
X#define MAP_CS_setExternalClockSourceFrequency                                        CS_setExternalClockSourceFrequency
N#endif
N#ifdef ROM_CS_setDCOExternalResistorCalibration
S#define MAP_CS_setDCOExternalResistorCalibration                              \
S        ROM_CS_setDCOExternalResistorCalibration
X#define MAP_CS_setDCOExternalResistorCalibration                                      ROM_CS_setDCOExternalResistorCalibration
N#else
N#define MAP_CS_setDCOExternalResistorCalibration                              \
N        CS_setDCOExternalResistorCalibration
X#define MAP_CS_setDCOExternalResistorCalibration                                      CS_setDCOExternalResistorCalibration
N#endif
N
N//*****************************************************************************
N//
N// Macros for the DMA API.
N//
N//*****************************************************************************
N#ifdef ROM_DMA_enableModule
S#define MAP_DMA_enableModule                                                  \
S        ROM_DMA_enableModule
X#define MAP_DMA_enableModule                                                          ROM_DMA_enableModule
N#else
N#define MAP_DMA_enableModule                                                  \
N        DMA_enableModule
X#define MAP_DMA_enableModule                                                          DMA_enableModule
N#endif
N#ifdef ROM_DMA_disableModule
S#define MAP_DMA_disableModule                                                 \
S        ROM_DMA_disableModule
X#define MAP_DMA_disableModule                                                         ROM_DMA_disableModule
N#else
N#define MAP_DMA_disableModule                                                 \
N        DMA_disableModule
X#define MAP_DMA_disableModule                                                         DMA_disableModule
N#endif
N#ifdef ROM_DMA_getErrorStatus
S#define MAP_DMA_getErrorStatus                                                \
S        ROM_DMA_getErrorStatus
X#define MAP_DMA_getErrorStatus                                                        ROM_DMA_getErrorStatus
N#else
N#define MAP_DMA_getErrorStatus                                                \
N        DMA_getErrorStatus
X#define MAP_DMA_getErrorStatus                                                        DMA_getErrorStatus
N#endif
N#ifdef ROM_DMA_clearErrorStatus
S#define MAP_DMA_clearErrorStatus                                              \
S        ROM_DMA_clearErrorStatus
X#define MAP_DMA_clearErrorStatus                                                      ROM_DMA_clearErrorStatus
N#else
N#define MAP_DMA_clearErrorStatus                                              \
N        DMA_clearErrorStatus
X#define MAP_DMA_clearErrorStatus                                                      DMA_clearErrorStatus
N#endif
N#ifdef ROM_DMA_enableChannel
S#define MAP_DMA_enableChannel                                                 \
S        ROM_DMA_enableChannel
X#define MAP_DMA_enableChannel                                                         ROM_DMA_enableChannel
N#else
N#define MAP_DMA_enableChannel                                                 \
N        DMA_enableChannel
X#define MAP_DMA_enableChannel                                                         DMA_enableChannel
N#endif
N#ifdef ROM_DMA_disableChannel
S#define MAP_DMA_disableChannel                                                \
S        ROM_DMA_disableChannel
X#define MAP_DMA_disableChannel                                                        ROM_DMA_disableChannel
N#else
N#define MAP_DMA_disableChannel                                                \
N        DMA_disableChannel
X#define MAP_DMA_disableChannel                                                        DMA_disableChannel
N#endif
N#ifdef ROM_DMA_isChannelEnabled
S#define MAP_DMA_isChannelEnabled                                              \
S        ROM_DMA_isChannelEnabled
X#define MAP_DMA_isChannelEnabled                                                      ROM_DMA_isChannelEnabled
N#else
N#define MAP_DMA_isChannelEnabled                                              \
N        DMA_isChannelEnabled
X#define MAP_DMA_isChannelEnabled                                                      DMA_isChannelEnabled
N#endif
N#ifdef ROM_DMA_setControlBase
S#define MAP_DMA_setControlBase                                                \
S        ROM_DMA_setControlBase
X#define MAP_DMA_setControlBase                                                        ROM_DMA_setControlBase
N#else
N#define MAP_DMA_setControlBase                                                \
N        DMA_setControlBase
X#define MAP_DMA_setControlBase                                                        DMA_setControlBase
N#endif
N#ifdef ROM_DMA_getControlBase
S#define MAP_DMA_getControlBase                                                \
S        ROM_DMA_getControlBase
X#define MAP_DMA_getControlBase                                                        ROM_DMA_getControlBase
N#else
N#define MAP_DMA_getControlBase                                                \
N        DMA_getControlBase
X#define MAP_DMA_getControlBase                                                        DMA_getControlBase
N#endif
N#ifdef ROM_DMA_getControlAlternateBase
S#define MAP_DMA_getControlAlternateBase                                       \
S        ROM_DMA_getControlAlternateBase
X#define MAP_DMA_getControlAlternateBase                                               ROM_DMA_getControlAlternateBase
N#else
N#define MAP_DMA_getControlAlternateBase                                       \
N        DMA_getControlAlternateBase
X#define MAP_DMA_getControlAlternateBase                                               DMA_getControlAlternateBase
N#endif
N#ifdef ROM_DMA_requestChannel
S#define MAP_DMA_requestChannel                                                \
S        ROM_DMA_requestChannel
X#define MAP_DMA_requestChannel                                                        ROM_DMA_requestChannel
N#else
N#define MAP_DMA_requestChannel                                                \
N        DMA_requestChannel
X#define MAP_DMA_requestChannel                                                        DMA_requestChannel
N#endif
N#ifdef ROM_DMA_enableChannelAttribute
S#define MAP_DMA_enableChannelAttribute                                        \
S        ROM_DMA_enableChannelAttribute
X#define MAP_DMA_enableChannelAttribute                                                ROM_DMA_enableChannelAttribute
N#else
N#define MAP_DMA_enableChannelAttribute                                        \
N        DMA_enableChannelAttribute
X#define MAP_DMA_enableChannelAttribute                                                DMA_enableChannelAttribute
N#endif
N#ifdef ROM_DMA_disableChannelAttribute
S#define MAP_DMA_disableChannelAttribute                                       \
S        ROM_DMA_disableChannelAttribute
X#define MAP_DMA_disableChannelAttribute                                               ROM_DMA_disableChannelAttribute
N#else
N#define MAP_DMA_disableChannelAttribute                                       \
N        DMA_disableChannelAttribute
X#define MAP_DMA_disableChannelAttribute                                               DMA_disableChannelAttribute
N#endif
N#ifdef ROM_DMA_getChannelAttribute
S#define MAP_DMA_getChannelAttribute                                           \
S        ROM_DMA_getChannelAttribute
X#define MAP_DMA_getChannelAttribute                                                   ROM_DMA_getChannelAttribute
N#else
N#define MAP_DMA_getChannelAttribute                                           \
N        DMA_getChannelAttribute
X#define MAP_DMA_getChannelAttribute                                                   DMA_getChannelAttribute
N#endif
N#ifdef ROM_DMA_setChannelControl
S#define MAP_DMA_setChannelControl                                             \
S        ROM_DMA_setChannelControl
X#define MAP_DMA_setChannelControl                                                     ROM_DMA_setChannelControl
N#else
N#define MAP_DMA_setChannelControl                                             \
N        DMA_setChannelControl
X#define MAP_DMA_setChannelControl                                                     DMA_setChannelControl
N#endif
N#ifdef ROM_DMA_setChannelTransfer
S#define MAP_DMA_setChannelTransfer                                            \
S        ROM_DMA_setChannelTransfer
X#define MAP_DMA_setChannelTransfer                                                    ROM_DMA_setChannelTransfer
N#else
N#define MAP_DMA_setChannelTransfer                                            \
N        DMA_setChannelTransfer
X#define MAP_DMA_setChannelTransfer                                                    DMA_setChannelTransfer
N#endif
N#ifdef ROM_DMA_setChannelScatterGather
S#define MAP_DMA_setChannelScatterGather                                       \
S        ROM_DMA_setChannelScatterGather
X#define MAP_DMA_setChannelScatterGather                                               ROM_DMA_setChannelScatterGather
N#else
N#define MAP_DMA_setChannelScatterGather                                       \
N        DMA_setChannelScatterGather
X#define MAP_DMA_setChannelScatterGather                                               DMA_setChannelScatterGather
N#endif
N#ifdef ROM_DMA_getChannelSize
S#define MAP_DMA_getChannelSize                                                \
S        ROM_DMA_getChannelSize
X#define MAP_DMA_getChannelSize                                                        ROM_DMA_getChannelSize
N#else
N#define MAP_DMA_getChannelSize                                                \
N        DMA_getChannelSize
X#define MAP_DMA_getChannelSize                                                        DMA_getChannelSize
N#endif
N#ifdef ROM_DMA_getChannelMode
S#define MAP_DMA_getChannelMode                                                \
S        ROM_DMA_getChannelMode
X#define MAP_DMA_getChannelMode                                                        ROM_DMA_getChannelMode
N#else
N#define MAP_DMA_getChannelMode                                                \
N        DMA_getChannelMode
X#define MAP_DMA_getChannelMode                                                        DMA_getChannelMode
N#endif
N#ifdef ROM_DMA_assignChannel
S#define MAP_DMA_assignChannel                                                 \
S        ROM_DMA_assignChannel
X#define MAP_DMA_assignChannel                                                         ROM_DMA_assignChannel
N#else
N#define MAP_DMA_assignChannel                                                 \
N        DMA_assignChannel
X#define MAP_DMA_assignChannel                                                         DMA_assignChannel
N#endif
N#ifdef ROM_DMA_requestSoftwareTransfer
S#define MAP_DMA_requestSoftwareTransfer                                       \
S        ROM_DMA_requestSoftwareTransfer
X#define MAP_DMA_requestSoftwareTransfer                                               ROM_DMA_requestSoftwareTransfer
N#else
N#define MAP_DMA_requestSoftwareTransfer                                       \
N        DMA_requestSoftwareTransfer
X#define MAP_DMA_requestSoftwareTransfer                                               DMA_requestSoftwareTransfer
N#endif
N#ifdef ROM_DMA_assignInterrupt
S#define MAP_DMA_assignInterrupt                                               \
S        ROM_DMA_assignInterrupt
X#define MAP_DMA_assignInterrupt                                                       ROM_DMA_assignInterrupt
N#else
N#define MAP_DMA_assignInterrupt                                               \
N        DMA_assignInterrupt
X#define MAP_DMA_assignInterrupt                                                       DMA_assignInterrupt
N#endif
N#ifdef ROM_DMA_enableInterrupt
S#define MAP_DMA_enableInterrupt                                               \
S        ROM_DMA_enableInterrupt
X#define MAP_DMA_enableInterrupt                                                       ROM_DMA_enableInterrupt
N#else
N#define MAP_DMA_enableInterrupt                                               \
N        DMA_enableInterrupt
X#define MAP_DMA_enableInterrupt                                                       DMA_enableInterrupt
N#endif
N#ifdef ROM_DMA_disableInterrupt
S#define MAP_DMA_disableInterrupt                                              \
S        ROM_DMA_disableInterrupt
X#define MAP_DMA_disableInterrupt                                                      ROM_DMA_disableInterrupt
N#else
N#define MAP_DMA_disableInterrupt                                              \
N        DMA_disableInterrupt
X#define MAP_DMA_disableInterrupt                                                      DMA_disableInterrupt
N#endif
N#ifdef ROM_DMA_getInterruptStatus
S#define MAP_DMA_getInterruptStatus                                            \
S        ROM_DMA_getInterruptStatus
X#define MAP_DMA_getInterruptStatus                                                    ROM_DMA_getInterruptStatus
N#else
N#define MAP_DMA_getInterruptStatus                                            \
N        DMA_getInterruptStatus
X#define MAP_DMA_getInterruptStatus                                                    DMA_getInterruptStatus
N#endif
N#ifdef ROM_DMA_clearInterruptFlag
S#define MAP_DMA_clearInterruptFlag                                            \
S        ROM_DMA_clearInterruptFlag
X#define MAP_DMA_clearInterruptFlag                                                    ROM_DMA_clearInterruptFlag
N#else
N#define MAP_DMA_clearInterruptFlag                                            \
N        DMA_clearInterruptFlag
X#define MAP_DMA_clearInterruptFlag                                                    DMA_clearInterruptFlag
N#endif
N#ifdef ROM_DMA_registerInterrupt
S#define MAP_DMA_registerInterrupt                                             \
S        ROM_DMA_registerInterrupt
X#define MAP_DMA_registerInterrupt                                                     ROM_DMA_registerInterrupt
N#else
N#define MAP_DMA_registerInterrupt                                             \
N        DMA_registerInterrupt
X#define MAP_DMA_registerInterrupt                                                     DMA_registerInterrupt
N#endif
N#ifdef ROM_DMA_unregisterInterrupt
S#define MAP_DMA_unregisterInterrupt                                           \
S        ROM_DMA_unregisterInterrupt
X#define MAP_DMA_unregisterInterrupt                                                   ROM_DMA_unregisterInterrupt
N#else
N#define MAP_DMA_unregisterInterrupt                                           \
N        DMA_unregisterInterrupt
X#define MAP_DMA_unregisterInterrupt                                                   DMA_unregisterInterrupt
N#endif
N
N//*****************************************************************************
N//
N// Macros for the Flash API.
N//
N//*****************************************************************************
N#ifdef ROM_FlashCtl_enableReadParityCheck
S#define MAP_FlashCtl_enableReadParityCheck                                    \
S        ROM_FlashCtl_enableReadParityCheck
X#define MAP_FlashCtl_enableReadParityCheck                                            ROM_FlashCtl_enableReadParityCheck
N#else
N#define MAP_FlashCtl_enableReadParityCheck                                    \
N        FlashCtl_enableReadParityCheck
X#define MAP_FlashCtl_enableReadParityCheck                                            FlashCtl_enableReadParityCheck
N#endif
N#ifdef ROM_FlashCtl_disableReadParityCheck
S#define MAP_FlashCtl_disableReadParityCheck                                   \
S        ROM_FlashCtl_disableReadParityCheck
X#define MAP_FlashCtl_disableReadParityCheck                                           ROM_FlashCtl_disableReadParityCheck
N#else
N#define MAP_FlashCtl_disableReadParityCheck                                   \
N        FlashCtl_disableReadParityCheck
X#define MAP_FlashCtl_disableReadParityCheck                                           FlashCtl_disableReadParityCheck
N#endif
N#ifdef ROM_FlashCtl_enableReadBuffering
S#define MAP_FlashCtl_enableReadBuffering                                      \
S        ROM_FlashCtl_enableReadBuffering
X#define MAP_FlashCtl_enableReadBuffering                                              ROM_FlashCtl_enableReadBuffering
N#else
N#define MAP_FlashCtl_enableReadBuffering                                      \
N        FlashCtl_enableReadBuffering
X#define MAP_FlashCtl_enableReadBuffering                                              FlashCtl_enableReadBuffering
N#endif
N#ifdef ROM_FlashCtl_disableReadBuffering
S#define MAP_FlashCtl_disableReadBuffering                                     \
S        ROM_FlashCtl_disableReadBuffering
X#define MAP_FlashCtl_disableReadBuffering                                             ROM_FlashCtl_disableReadBuffering
N#else
N#define MAP_FlashCtl_disableReadBuffering                                     \
N        FlashCtl_disableReadBuffering
X#define MAP_FlashCtl_disableReadBuffering                                             FlashCtl_disableReadBuffering
N#endif
N#ifdef ROM_FlashCtl_unprotectSector
S#define MAP_FlashCtl_unprotectSector                                          \
S        ROM_FlashCtl_unprotectSector
X#define MAP_FlashCtl_unprotectSector                                                  ROM_FlashCtl_unprotectSector
N#else
N#define MAP_FlashCtl_unprotectSector                                          \
N        FlashCtl_unprotectSector
X#define MAP_FlashCtl_unprotectSector                                                  FlashCtl_unprotectSector
N#endif
N#ifdef ROM_FlashCtl_protectSector
S#define MAP_FlashCtl_protectSector                                            \
S        ROM_FlashCtl_protectSector
X#define MAP_FlashCtl_protectSector                                                    ROM_FlashCtl_protectSector
N#else
N#define MAP_FlashCtl_protectSector                                            \
N        FlashCtl_protectSector
X#define MAP_FlashCtl_protectSector                                                    FlashCtl_protectSector
N#endif
N#ifdef ROM_FlashCtl_isSectorProtected
S#define MAP_FlashCtl_isSectorProtected                                        \
S        ROM_FlashCtl_isSectorProtected
X#define MAP_FlashCtl_isSectorProtected                                                ROM_FlashCtl_isSectorProtected
N#else
N#define MAP_FlashCtl_isSectorProtected                                        \
N        FlashCtl_isSectorProtected
X#define MAP_FlashCtl_isSectorProtected                                                FlashCtl_isSectorProtected
N#endif
N#ifdef ROM_FlashCtl_verifyMemory
S#define MAP_FlashCtl_verifyMemory                                             \
S        ROM_FlashCtl_verifyMemory
X#define MAP_FlashCtl_verifyMemory                                                     ROM_FlashCtl_verifyMemory
N#else
N#define MAP_FlashCtl_verifyMemory                                             \
N        FlashCtl_verifyMemory
X#define MAP_FlashCtl_verifyMemory                                                     FlashCtl_verifyMemory
N#endif
N#ifdef ROM_FlashCtl_performMassErase
S#define MAP_FlashCtl_performMassErase                                         \
S        ROM_FlashCtl_performMassErase
X#define MAP_FlashCtl_performMassErase                                                 ROM_FlashCtl_performMassErase
N#else
N#define MAP_FlashCtl_performMassErase                                         \
N        FlashCtl_performMassErase
X#define MAP_FlashCtl_performMassErase                                                 FlashCtl_performMassErase
N#endif
N#ifdef ROM_FlashCtl_eraseSector
S#define MAP_FlashCtl_eraseSector                                              \
S        ROM_FlashCtl_eraseSector
X#define MAP_FlashCtl_eraseSector                                                      ROM_FlashCtl_eraseSector
N#else
N#define MAP_FlashCtl_eraseSector                                              \
N        FlashCtl_eraseSector
X#define MAP_FlashCtl_eraseSector                                                      FlashCtl_eraseSector
N#endif
N#ifdef ROM_FlashCtl_programMemory
S#define MAP_FlashCtl_programMemory                                            \
S        ROM_FlashCtl_programMemory
X#define MAP_FlashCtl_programMemory                                                    ROM_FlashCtl_programMemory
N#else
N#define MAP_FlashCtl_programMemory                                            \
N        FlashCtl_programMemory
X#define MAP_FlashCtl_programMemory                                                    FlashCtl_programMemory
N#endif
N#ifdef ROM_FlashCtl_setProgramVerification
S#define MAP_FlashCtl_setProgramVerification                                   \
S        ROM_FlashCtl_setProgramVerification
X#define MAP_FlashCtl_setProgramVerification                                           ROM_FlashCtl_setProgramVerification
N#else
N#define MAP_FlashCtl_setProgramVerification                                   \
N        FlashCtl_setProgramVerification
X#define MAP_FlashCtl_setProgramVerification                                           FlashCtl_setProgramVerification
N#endif
N#ifdef ROM_FlashCtl_clearProgramVerification
S#define MAP_FlashCtl_clearProgramVerification                                 \
S        ROM_FlashCtl_clearProgramVerification
X#define MAP_FlashCtl_clearProgramVerification                                         ROM_FlashCtl_clearProgramVerification
N#else
N#define MAP_FlashCtl_clearProgramVerification                                 \
N        FlashCtl_clearProgramVerification
X#define MAP_FlashCtl_clearProgramVerification                                         FlashCtl_clearProgramVerification
N#endif
N#ifdef ROM_FlashCtl_enableWordProgramming
S#define MAP_FlashCtl_enableWordProgramming                                    \
S        ROM_FlashCtl_enableWordProgramming
X#define MAP_FlashCtl_enableWordProgramming                                            ROM_FlashCtl_enableWordProgramming
N#else
N#define MAP_FlashCtl_enableWordProgramming                                    \
N        FlashCtl_enableWordProgramming
X#define MAP_FlashCtl_enableWordProgramming                                            FlashCtl_enableWordProgramming
N#endif
N#ifdef ROM_FlashCtl_disableWordProgramming
S#define MAP_FlashCtl_disableWordProgramming                                   \
S        ROM_FlashCtl_disableWordProgramming
X#define MAP_FlashCtl_disableWordProgramming                                           ROM_FlashCtl_disableWordProgramming
N#else
N#define MAP_FlashCtl_disableWordProgramming                                   \
N        FlashCtl_disableWordProgramming
X#define MAP_FlashCtl_disableWordProgramming                                           FlashCtl_disableWordProgramming
N#endif
N#ifdef ROM_FlashCtl_isWordProgrammingEnabled
S#define MAP_FlashCtl_isWordProgrammingEnabled                                 \
S        ROM_FlashCtl_isWordProgrammingEnabled
X#define MAP_FlashCtl_isWordProgrammingEnabled                                         ROM_FlashCtl_isWordProgrammingEnabled
N#else
N#define MAP_FlashCtl_isWordProgrammingEnabled                                 \
N        FlashCtl_isWordProgrammingEnabled
X#define MAP_FlashCtl_isWordProgrammingEnabled                                         FlashCtl_isWordProgrammingEnabled
N#endif
N#ifdef ROM_FlashCtl_enableInterrupt
S#define MAP_FlashCtl_enableInterrupt                                          \
S        ROM_FlashCtl_enableInterrupt
X#define MAP_FlashCtl_enableInterrupt                                                  ROM_FlashCtl_enableInterrupt
N#else
N#define MAP_FlashCtl_enableInterrupt                                          \
N        FlashCtl_enableInterrupt
X#define MAP_FlashCtl_enableInterrupt                                                  FlashCtl_enableInterrupt
N#endif
N#ifdef ROM_FlashCtl_disableInterrupt
S#define MAP_FlashCtl_disableInterrupt                                         \
S        ROM_FlashCtl_disableInterrupt
X#define MAP_FlashCtl_disableInterrupt                                                 ROM_FlashCtl_disableInterrupt
N#else
N#define MAP_FlashCtl_disableInterrupt                                         \
N        FlashCtl_disableInterrupt
X#define MAP_FlashCtl_disableInterrupt                                                 FlashCtl_disableInterrupt
N#endif
N#ifdef ROM_FlashCtl_getEnabledInterruptStatus
S#define MAP_FlashCtl_getEnabledInterruptStatus                                \
S        ROM_FlashCtl_getEnabledInterruptStatus
X#define MAP_FlashCtl_getEnabledInterruptStatus                                        ROM_FlashCtl_getEnabledInterruptStatus
N#else
N#define MAP_FlashCtl_getEnabledInterruptStatus                                \
N        FlashCtl_getEnabledInterruptStatus
X#define MAP_FlashCtl_getEnabledInterruptStatus                                        FlashCtl_getEnabledInterruptStatus
N#endif
N#ifdef ROM_FlashCtl_getInterruptStatus
S#define MAP_FlashCtl_getInterruptStatus                                       \
S        ROM_FlashCtl_getInterruptStatus
X#define MAP_FlashCtl_getInterruptStatus                                               ROM_FlashCtl_getInterruptStatus
N#else
N#define MAP_FlashCtl_getInterruptStatus                                       \
N        FlashCtl_getInterruptStatus
X#define MAP_FlashCtl_getInterruptStatus                                               FlashCtl_getInterruptStatus
N#endif
N#ifdef ROM_FlashCtl_clearInterruptFlag
S#define MAP_FlashCtl_clearInterruptFlag                                       \
S        ROM_FlashCtl_clearInterruptFlag
X#define MAP_FlashCtl_clearInterruptFlag                                               ROM_FlashCtl_clearInterruptFlag
N#else
N#define MAP_FlashCtl_clearInterruptFlag                                       \
N        FlashCtl_clearInterruptFlag
X#define MAP_FlashCtl_clearInterruptFlag                                               FlashCtl_clearInterruptFlag
N#endif
N#ifdef ROM_FlashCtl_setWaitState
S#define MAP_FlashCtl_setWaitState                                             \
S        ROM_FlashCtl_setWaitState
X#define MAP_FlashCtl_setWaitState                                                     ROM_FlashCtl_setWaitState
N#else
N#define MAP_FlashCtl_setWaitState                                             \
N        FlashCtl_setWaitState
X#define MAP_FlashCtl_setWaitState                                                     FlashCtl_setWaitState
N#endif
N#ifdef ROM_FlashCtl_getWaitState
S#define MAP_FlashCtl_getWaitState                                             \
S        ROM_FlashCtl_getWaitState
X#define MAP_FlashCtl_getWaitState                                                     ROM_FlashCtl_getWaitState
N#else
N#define MAP_FlashCtl_getWaitState                                             \
N        FlashCtl_getWaitState
X#define MAP_FlashCtl_getWaitState                                                     FlashCtl_getWaitState
N#endif
N#ifdef ROM_FlashCtl_setReadMode
S#define MAP_FlashCtl_setReadMode                                              \
S        ROM_FlashCtl_setReadMode
X#define MAP_FlashCtl_setReadMode                                                      ROM_FlashCtl_setReadMode
N#else
N#define MAP_FlashCtl_setReadMode                                              \
N        FlashCtl_setReadMode
X#define MAP_FlashCtl_setReadMode                                                      FlashCtl_setReadMode
N#endif
N#ifdef ROM_FlashCtl_getReadMode
S#define MAP_FlashCtl_getReadMode                                              \
S        ROM_FlashCtl_getReadMode
X#define MAP_FlashCtl_getReadMode                                                      ROM_FlashCtl_getReadMode
N#else
N#define MAP_FlashCtl_getReadMode                                              \
N        FlashCtl_getReadMode
X#define MAP_FlashCtl_getReadMode                                                      FlashCtl_getReadMode
N#endif
N#ifdef ROM_FlashCtl_registerInterrupt
S#define MAP_FlashCtl_registerInterrupt                                        \
S        ROM_FlashCtl_registerInterrupt
X#define MAP_FlashCtl_registerInterrupt                                                ROM_FlashCtl_registerInterrupt
N#else
N#define MAP_FlashCtl_registerInterrupt                                        \
N        FlashCtl_registerInterrupt
X#define MAP_FlashCtl_registerInterrupt                                                FlashCtl_registerInterrupt
N#endif
N#ifdef ROM_FlashCtl_unregisterInterrupt
S#define MAP_FlashCtl_unregisterInterrupt                                      \
S        ROM_FlashCtl_unregisterInterrupt
X#define MAP_FlashCtl_unregisterInterrupt                                              ROM_FlashCtl_unregisterInterrupt
N#else
N#define MAP_FlashCtl_unregisterInterrupt                                      \
N        FlashCtl_unregisterInterrupt
X#define MAP_FlashCtl_unregisterInterrupt                                              FlashCtl_unregisterInterrupt
N#endif
N#ifdef ROM___FlashCtl_remaskData8Post
S#define MAP___FlashCtl_remaskData8Post                                        \
S        ROM___FlashCtl_remaskData8Post
X#define MAP___FlashCtl_remaskData8Post                                                ROM___FlashCtl_remaskData8Post
N#else
N#define MAP___FlashCtl_remaskData8Post                                        \
N        __FlashCtl_remaskData8Post
X#define MAP___FlashCtl_remaskData8Post                                                __FlashCtl_remaskData8Post
N#endif
N#ifdef ROM___FlashCtl_remaskData8Pre
S#define MAP___FlashCtl_remaskData8Pre                                         \
S        ROM___FlashCtl_remaskData8Pre
X#define MAP___FlashCtl_remaskData8Pre                                                 ROM___FlashCtl_remaskData8Pre
N#else
N#define MAP___FlashCtl_remaskData8Pre                                         \
N        __FlashCtl_remaskData8Pre
X#define MAP___FlashCtl_remaskData8Pre                                                 __FlashCtl_remaskData8Pre
N#endif
N#ifdef ROM___FlashCtl_remaskData32Pre
S#define MAP___FlashCtl_remaskData32Pre                                        \
S        ROM___FlashCtl_remaskData32Pre
X#define MAP___FlashCtl_remaskData32Pre                                                ROM___FlashCtl_remaskData32Pre
N#else
N#define MAP___FlashCtl_remaskData32Pre                                        \
N        __FlashCtl_remaskData32Pre
X#define MAP___FlashCtl_remaskData32Pre                                                __FlashCtl_remaskData32Pre
N#endif
N#ifdef ROM___FlashCtl_remaskData32Post
S#define MAP___FlashCtl_remaskData32Post                                       \
S        ROM___FlashCtl_remaskData32Post
X#define MAP___FlashCtl_remaskData32Post                                               ROM___FlashCtl_remaskData32Post
N#else
N#define MAP___FlashCtl_remaskData32Post                                       \
N        __FlashCtl_remaskData32Post
X#define MAP___FlashCtl_remaskData32Post                                               __FlashCtl_remaskData32Post
N#endif
N#ifdef ROM___FlashCtl_remaskBurstDataPre
S#define MAP___FlashCtl_remaskBurstDataPre                                     \
S        ROM___FlashCtl_remaskBurstDataPre
X#define MAP___FlashCtl_remaskBurstDataPre                                             ROM___FlashCtl_remaskBurstDataPre
N#else
N#define MAP___FlashCtl_remaskBurstDataPre                                     \
N        __FlashCtl_remaskBurstDataPre
X#define MAP___FlashCtl_remaskBurstDataPre                                             __FlashCtl_remaskBurstDataPre
N#endif
N#ifdef ROM___FlashCtl_remaskBurstDataPost
S#define MAP___FlashCtl_remaskBurstDataPost                                    \
S        ROM___FlashCtl_remaskBurstDataPost
X#define MAP___FlashCtl_remaskBurstDataPost                                            ROM___FlashCtl_remaskBurstDataPost
N#else
N#define MAP___FlashCtl_remaskBurstDataPost                                    \
N        __FlashCtl_remaskBurstDataPost
X#define MAP___FlashCtl_remaskBurstDataPost                                            __FlashCtl_remaskBurstDataPost
N#endif
N#ifdef ROM_FlashCtl_initiateSectorErase
S#define MAP_FlashCtl_initiateSectorErase                                      \
S        ROM_FlashCtl_initiateSectorErase
X#define MAP_FlashCtl_initiateSectorErase                                              ROM_FlashCtl_initiateSectorErase
N#else
N#define MAP_FlashCtl_initiateSectorErase                                      \
N        FlashCtl_initiateSectorErase
X#define MAP_FlashCtl_initiateSectorErase                                              FlashCtl_initiateSectorErase
N#endif
N#ifdef ROM_FlashCtl_initiateMassErase
S#define MAP_FlashCtl_initiateMassErase                                        \
S        ROM_FlashCtl_initiateMassErase
X#define MAP_FlashCtl_initiateMassErase                                                ROM_FlashCtl_initiateMassErase
N#else
N#define MAP_FlashCtl_initiateMassErase                                        \
N        FlashCtl_initiateMassErase
X#define MAP_FlashCtl_initiateMassErase                                                FlashCtl_initiateMassErase
N#endif
N#ifdef ROM_FlashCtl_getMemoryInfo
S#define MAP_FlashCtl_getMemoryInfo                                            \
S        ROM_FlashCtl_getMemoryInfo
X#define MAP_FlashCtl_getMemoryInfo                                                    ROM_FlashCtl_getMemoryInfo
N#else
N#define MAP_FlashCtl_getMemoryInfo                                            \
N        FlashCtl_getMemoryInfo
X#define MAP_FlashCtl_getMemoryInfo                                                    FlashCtl_getMemoryInfo
N#endif
N
N//*****************************************************************************
N//
N// Macros for the FPU API.
N//
N//*****************************************************************************
N#ifdef ROM_FPU_enableModule
S#define MAP_FPU_enableModule                                                  \
S        ROM_FPU_enableModule
X#define MAP_FPU_enableModule                                                          ROM_FPU_enableModule
N#else
N#define MAP_FPU_enableModule                                                  \
N        FPU_enableModule
X#define MAP_FPU_enableModule                                                          FPU_enableModule
N#endif
N#ifdef ROM_FPU_disableModule
S#define MAP_FPU_disableModule                                                 \
S        ROM_FPU_disableModule
X#define MAP_FPU_disableModule                                                         ROM_FPU_disableModule
N#else
N#define MAP_FPU_disableModule                                                 \
N        FPU_disableModule
X#define MAP_FPU_disableModule                                                         FPU_disableModule
N#endif
N#ifdef ROM_FPU_enableStacking
S#define MAP_FPU_enableStacking                                                \
S        ROM_FPU_enableStacking
X#define MAP_FPU_enableStacking                                                        ROM_FPU_enableStacking
N#else
N#define MAP_FPU_enableStacking                                                \
N        FPU_enableStacking
X#define MAP_FPU_enableStacking                                                        FPU_enableStacking
N#endif
N#ifdef ROM_FPU_enableLazyStacking
S#define MAP_FPU_enableLazyStacking                                            \
S        ROM_FPU_enableLazyStacking
X#define MAP_FPU_enableLazyStacking                                                    ROM_FPU_enableLazyStacking
N#else
N#define MAP_FPU_enableLazyStacking                                            \
N        FPU_enableLazyStacking
X#define MAP_FPU_enableLazyStacking                                                    FPU_enableLazyStacking
N#endif
N#ifdef ROM_FPU_disableStacking
S#define MAP_FPU_disableStacking                                               \
S        ROM_FPU_disableStacking
X#define MAP_FPU_disableStacking                                                       ROM_FPU_disableStacking
N#else
N#define MAP_FPU_disableStacking                                               \
N        FPU_disableStacking
X#define MAP_FPU_disableStacking                                                       FPU_disableStacking
N#endif
N#ifdef ROM_FPU_setHalfPrecisionMode
S#define MAP_FPU_setHalfPrecisionMode                                          \
S        ROM_FPU_setHalfPrecisionMode
X#define MAP_FPU_setHalfPrecisionMode                                                  ROM_FPU_setHalfPrecisionMode
N#else
N#define MAP_FPU_setHalfPrecisionMode                                          \
N        FPU_setHalfPrecisionMode
X#define MAP_FPU_setHalfPrecisionMode                                                  FPU_setHalfPrecisionMode
N#endif
N#ifdef ROM_FPU_setNaNMode
S#define MAP_FPU_setNaNMode                                                    \
S        ROM_FPU_setNaNMode
X#define MAP_FPU_setNaNMode                                                            ROM_FPU_setNaNMode
N#else
N#define MAP_FPU_setNaNMode                                                    \
N        FPU_setNaNMode
X#define MAP_FPU_setNaNMode                                                            FPU_setNaNMode
N#endif
N#ifdef ROM_FPU_setFlushToZeroMode
S#define MAP_FPU_setFlushToZeroMode                                            \
S        ROM_FPU_setFlushToZeroMode
X#define MAP_FPU_setFlushToZeroMode                                                    ROM_FPU_setFlushToZeroMode
N#else
N#define MAP_FPU_setFlushToZeroMode                                            \
N        FPU_setFlushToZeroMode
X#define MAP_FPU_setFlushToZeroMode                                                    FPU_setFlushToZeroMode
N#endif
N#ifdef ROM_FPU_setRoundingMode
S#define MAP_FPU_setRoundingMode                                               \
S        ROM_FPU_setRoundingMode
X#define MAP_FPU_setRoundingMode                                                       ROM_FPU_setRoundingMode
N#else
N#define MAP_FPU_setRoundingMode                                               \
N        FPU_setRoundingMode
X#define MAP_FPU_setRoundingMode                                                       FPU_setRoundingMode
N#endif
N
N//*****************************************************************************
N//
N// Macros for the GPIO API.
N//
N//*****************************************************************************
N#ifdef ROM_GPIO_setAsOutputPin
S#define MAP_GPIO_setAsOutputPin                                               \
S        ROM_GPIO_setAsOutputPin
X#define MAP_GPIO_setAsOutputPin                                                       ROM_GPIO_setAsOutputPin
N#else
N#define MAP_GPIO_setAsOutputPin                                               \
N        GPIO_setAsOutputPin
X#define MAP_GPIO_setAsOutputPin                                                       GPIO_setAsOutputPin
N#endif
N#ifdef ROM_GPIO_setOutputHighOnPin
S#define MAP_GPIO_setOutputHighOnPin                                           \
S        ROM_GPIO_setOutputHighOnPin
X#define MAP_GPIO_setOutputHighOnPin                                                   ROM_GPIO_setOutputHighOnPin
N#else
N#define MAP_GPIO_setOutputHighOnPin                                           \
N        GPIO_setOutputHighOnPin
X#define MAP_GPIO_setOutputHighOnPin                                                   GPIO_setOutputHighOnPin
N#endif
N#ifdef ROM_GPIO_setOutputLowOnPin
S#define MAP_GPIO_setOutputLowOnPin                                            \
S        ROM_GPIO_setOutputLowOnPin
X#define MAP_GPIO_setOutputLowOnPin                                                    ROM_GPIO_setOutputLowOnPin
N#else
N#define MAP_GPIO_setOutputLowOnPin                                            \
N        GPIO_setOutputLowOnPin
X#define MAP_GPIO_setOutputLowOnPin                                                    GPIO_setOutputLowOnPin
N#endif
N#ifdef ROM_GPIO_toggleOutputOnPin
S#define MAP_GPIO_toggleOutputOnPin                                            \
S        ROM_GPIO_toggleOutputOnPin
X#define MAP_GPIO_toggleOutputOnPin                                                    ROM_GPIO_toggleOutputOnPin
N#else
N#define MAP_GPIO_toggleOutputOnPin                                            \
N        GPIO_toggleOutputOnPin
X#define MAP_GPIO_toggleOutputOnPin                                                    GPIO_toggleOutputOnPin
N#endif
N#ifdef ROM_GPIO_setAsInputPinWithPullDownResistor
S#define MAP_GPIO_setAsInputPinWithPullDownResistor                            \
S        ROM_GPIO_setAsInputPinWithPullDownResistor
X#define MAP_GPIO_setAsInputPinWithPullDownResistor                                    ROM_GPIO_setAsInputPinWithPullDownResistor
N#else
N#define MAP_GPIO_setAsInputPinWithPullDownResistor                            \
N        GPIO_setAsInputPinWithPullDownResistor
X#define MAP_GPIO_setAsInputPinWithPullDownResistor                                    GPIO_setAsInputPinWithPullDownResistor
N#endif
N#ifdef ROM_GPIO_setAsInputPinWithPullUpResistor
S#define MAP_GPIO_setAsInputPinWithPullUpResistor                              \
S        ROM_GPIO_setAsInputPinWithPullUpResistor
X#define MAP_GPIO_setAsInputPinWithPullUpResistor                                      ROM_GPIO_setAsInputPinWithPullUpResistor
N#else
N#define MAP_GPIO_setAsInputPinWithPullUpResistor                              \
N        GPIO_setAsInputPinWithPullUpResistor
X#define MAP_GPIO_setAsInputPinWithPullUpResistor                                      GPIO_setAsInputPinWithPullUpResistor
N#endif
N#ifdef ROM_GPIO_setAsPeripheralModuleFunctionOutputPin
S#define MAP_GPIO_setAsPeripheralModuleFunctionOutputPin                       \
S        ROM_GPIO_setAsPeripheralModuleFunctionOutputPin
X#define MAP_GPIO_setAsPeripheralModuleFunctionOutputPin                               ROM_GPIO_setAsPeripheralModuleFunctionOutputPin
N#else
N#define MAP_GPIO_setAsPeripheralModuleFunctionOutputPin                       \
N        GPIO_setAsPeripheralModuleFunctionOutputPin
X#define MAP_GPIO_setAsPeripheralModuleFunctionOutputPin                               GPIO_setAsPeripheralModuleFunctionOutputPin
N#endif
N#ifdef ROM_GPIO_setAsPeripheralModuleFunctionInputPin
S#define MAP_GPIO_setAsPeripheralModuleFunctionInputPin                        \
S        ROM_GPIO_setAsPeripheralModuleFunctionInputPin
X#define MAP_GPIO_setAsPeripheralModuleFunctionInputPin                                ROM_GPIO_setAsPeripheralModuleFunctionInputPin
N#else
N#define MAP_GPIO_setAsPeripheralModuleFunctionInputPin                        \
N        GPIO_setAsPeripheralModuleFunctionInputPin
X#define MAP_GPIO_setAsPeripheralModuleFunctionInputPin                                GPIO_setAsPeripheralModuleFunctionInputPin
N#endif
N#ifdef ROM_GPIO_getInputPinValue
S#define MAP_GPIO_getInputPinValue                                             \
S        ROM_GPIO_getInputPinValue
X#define MAP_GPIO_getInputPinValue                                                     ROM_GPIO_getInputPinValue
N#else
N#define MAP_GPIO_getInputPinValue                                             \
N        GPIO_getInputPinValue
X#define MAP_GPIO_getInputPinValue                                                     GPIO_getInputPinValue
N#endif
N#ifdef ROM_GPIO_interruptEdgeSelect
S#define MAP_GPIO_interruptEdgeSelect                                          \
S        ROM_GPIO_interruptEdgeSelect
X#define MAP_GPIO_interruptEdgeSelect                                                  ROM_GPIO_interruptEdgeSelect
N#else
N#define MAP_GPIO_interruptEdgeSelect                                          \
N        GPIO_interruptEdgeSelect
X#define MAP_GPIO_interruptEdgeSelect                                                  GPIO_interruptEdgeSelect
N#endif
N#ifdef ROM_GPIO_enableInterrupt
S#define MAP_GPIO_enableInterrupt                                              \
S        ROM_GPIO_enableInterrupt
X#define MAP_GPIO_enableInterrupt                                                      ROM_GPIO_enableInterrupt
N#else
N#define MAP_GPIO_enableInterrupt                                              \
N        GPIO_enableInterrupt
X#define MAP_GPIO_enableInterrupt                                                      GPIO_enableInterrupt
N#endif
N#ifdef ROM_GPIO_disableInterrupt
S#define MAP_GPIO_disableInterrupt                                             \
S        ROM_GPIO_disableInterrupt
X#define MAP_GPIO_disableInterrupt                                                     ROM_GPIO_disableInterrupt
N#else
N#define MAP_GPIO_disableInterrupt                                             \
N        GPIO_disableInterrupt
X#define MAP_GPIO_disableInterrupt                                                     GPIO_disableInterrupt
N#endif
N#ifdef ROM_GPIO_getInterruptStatus
S#define MAP_GPIO_getInterruptStatus                                           \
S        ROM_GPIO_getInterruptStatus
X#define MAP_GPIO_getInterruptStatus                                                   ROM_GPIO_getInterruptStatus
N#else
N#define MAP_GPIO_getInterruptStatus                                           \
N        GPIO_getInterruptStatus
X#define MAP_GPIO_getInterruptStatus                                                   GPIO_getInterruptStatus
N#endif
N#ifdef ROM_GPIO_clearInterruptFlag
S#define MAP_GPIO_clearInterruptFlag                                           \
S        ROM_GPIO_clearInterruptFlag
X#define MAP_GPIO_clearInterruptFlag                                                   ROM_GPIO_clearInterruptFlag
N#else
N#define MAP_GPIO_clearInterruptFlag                                           \
N        GPIO_clearInterruptFlag
X#define MAP_GPIO_clearInterruptFlag                                                   GPIO_clearInterruptFlag
N#endif
N#ifdef ROM_GPIO_setAsInputPin
S#define MAP_GPIO_setAsInputPin                                                \
S        ROM_GPIO_setAsInputPin
X#define MAP_GPIO_setAsInputPin                                                        ROM_GPIO_setAsInputPin
N#else
N#define MAP_GPIO_setAsInputPin                                                \
N        GPIO_setAsInputPin
X#define MAP_GPIO_setAsInputPin                                                        GPIO_setAsInputPin
N#endif
N#ifdef ROM_GPIO_getEnabledInterruptStatus
S#define MAP_GPIO_getEnabledInterruptStatus                                    \
S        ROM_GPIO_getEnabledInterruptStatus
X#define MAP_GPIO_getEnabledInterruptStatus                                            ROM_GPIO_getEnabledInterruptStatus
N#else
N#define MAP_GPIO_getEnabledInterruptStatus                                    \
N        GPIO_getEnabledInterruptStatus
X#define MAP_GPIO_getEnabledInterruptStatus                                            GPIO_getEnabledInterruptStatus
N#endif
N#ifdef ROM_GPIO_setDriveStrengthHigh
S#define MAP_GPIO_setDriveStrengthHigh                                         \
S        ROM_GPIO_setDriveStrengthHigh
X#define MAP_GPIO_setDriveStrengthHigh                                                 ROM_GPIO_setDriveStrengthHigh
N#else
N#define MAP_GPIO_setDriveStrengthHigh                                         \
N        GPIO_setDriveStrengthHigh
X#define MAP_GPIO_setDriveStrengthHigh                                                 GPIO_setDriveStrengthHigh
N#endif
N#ifdef ROM_GPIO_setDriveStrengthLow
S#define MAP_GPIO_setDriveStrengthLow                                          \
S        ROM_GPIO_setDriveStrengthLow
X#define MAP_GPIO_setDriveStrengthLow                                                  ROM_GPIO_setDriveStrengthLow
N#else
N#define MAP_GPIO_setDriveStrengthLow                                          \
N        GPIO_setDriveStrengthLow
X#define MAP_GPIO_setDriveStrengthLow                                                  GPIO_setDriveStrengthLow
N#endif
N#ifdef ROM_GPIO_registerInterrupt
S#define MAP_GPIO_registerInterrupt                                            \
S        ROM_GPIO_registerInterrupt
X#define MAP_GPIO_registerInterrupt                                                    ROM_GPIO_registerInterrupt
N#else
N#define MAP_GPIO_registerInterrupt                                            \
N        GPIO_registerInterrupt
X#define MAP_GPIO_registerInterrupt                                                    GPIO_registerInterrupt
N#endif
N#ifdef ROM_GPIO_unregisterInterrupt
S#define MAP_GPIO_unregisterInterrupt                                          \
S        ROM_GPIO_unregisterInterrupt
X#define MAP_GPIO_unregisterInterrupt                                                  ROM_GPIO_unregisterInterrupt
N#else
N#define MAP_GPIO_unregisterInterrupt                                          \
N        GPIO_unregisterInterrupt
X#define MAP_GPIO_unregisterInterrupt                                                  GPIO_unregisterInterrupt
N#endif
N
N//*****************************************************************************
N//
N// Macros for the I2C API.
N//
N//*****************************************************************************
N#ifdef ROM_I2C_initMaster
S#define MAP_I2C_initMaster                                                    \
S        ROM_I2C_initMaster
X#define MAP_I2C_initMaster                                                            ROM_I2C_initMaster
N#else
N#define MAP_I2C_initMaster                                                    \
N        I2C_initMaster
X#define MAP_I2C_initMaster                                                            I2C_initMaster
N#endif
N#ifdef ROM_I2C_initSlave
S#define MAP_I2C_initSlave                                                     \
S        ROM_I2C_initSlave
X#define MAP_I2C_initSlave                                                             ROM_I2C_initSlave
N#else
N#define MAP_I2C_initSlave                                                     \
N        I2C_initSlave
X#define MAP_I2C_initSlave                                                             I2C_initSlave
N#endif
N#ifdef ROM_I2C_enableModule
S#define MAP_I2C_enableModule                                                  \
S        ROM_I2C_enableModule
X#define MAP_I2C_enableModule                                                          ROM_I2C_enableModule
N#else
N#define MAP_I2C_enableModule                                                  \
N        I2C_enableModule
X#define MAP_I2C_enableModule                                                          I2C_enableModule
N#endif
N#ifdef ROM_I2C_disableModule
S#define MAP_I2C_disableModule                                                 \
S        ROM_I2C_disableModule
X#define MAP_I2C_disableModule                                                         ROM_I2C_disableModule
N#else
N#define MAP_I2C_disableModule                                                 \
N        I2C_disableModule
X#define MAP_I2C_disableModule                                                         I2C_disableModule
N#endif
N#ifdef ROM_I2C_setSlaveAddress
S#define MAP_I2C_setSlaveAddress                                               \
S        ROM_I2C_setSlaveAddress
X#define MAP_I2C_setSlaveAddress                                                       ROM_I2C_setSlaveAddress
N#else
N#define MAP_I2C_setSlaveAddress                                               \
N        I2C_setSlaveAddress
X#define MAP_I2C_setSlaveAddress                                                       I2C_setSlaveAddress
N#endif
N#ifdef ROM_I2C_setMode
S#define MAP_I2C_setMode                                                       \
S        ROM_I2C_setMode
X#define MAP_I2C_setMode                                                               ROM_I2C_setMode
N#else
N#define MAP_I2C_setMode                                                       \
N        I2C_setMode
X#define MAP_I2C_setMode                                                               I2C_setMode
N#endif
N#ifdef ROM_I2C_slavePutData
S#define MAP_I2C_slavePutData                                                  \
S        ROM_I2C_slavePutData
X#define MAP_I2C_slavePutData                                                          ROM_I2C_slavePutData
N#else
N#define MAP_I2C_slavePutData                                                  \
N        I2C_slavePutData
X#define MAP_I2C_slavePutData                                                          I2C_slavePutData
N#endif
N#ifdef ROM_I2C_slaveGetData
S#define MAP_I2C_slaveGetData                                                  \
S        ROM_I2C_slaveGetData
X#define MAP_I2C_slaveGetData                                                          ROM_I2C_slaveGetData
N#else
N#define MAP_I2C_slaveGetData                                                  \
N        I2C_slaveGetData
X#define MAP_I2C_slaveGetData                                                          I2C_slaveGetData
N#endif
N#ifdef ROM_I2C_isBusBusy
S#define MAP_I2C_isBusBusy                                                     \
S        ROM_I2C_isBusBusy
X#define MAP_I2C_isBusBusy                                                             ROM_I2C_isBusBusy
N#else
N#define MAP_I2C_isBusBusy                                                     \
N        I2C_isBusBusy
X#define MAP_I2C_isBusBusy                                                             I2C_isBusBusy
N#endif
N#ifdef ROM_I2C_masterSendSingleByte
S#define MAP_I2C_masterSendSingleByte                                          \
S        ROM_I2C_masterSendSingleByte
X#define MAP_I2C_masterSendSingleByte                                                  ROM_I2C_masterSendSingleByte
N#else
N#define MAP_I2C_masterSendSingleByte                                          \
N        I2C_masterSendSingleByte
X#define MAP_I2C_masterSendSingleByte                                                  I2C_masterSendSingleByte
N#endif
N#ifdef ROM_I2C_masterSendSingleByteWithTimeout
S#define MAP_I2C_masterSendSingleByteWithTimeout                               \
S        ROM_I2C_masterSendSingleByteWithTimeout
X#define MAP_I2C_masterSendSingleByteWithTimeout                                       ROM_I2C_masterSendSingleByteWithTimeout
N#else
N#define MAP_I2C_masterSendSingleByteWithTimeout                               \
N        I2C_masterSendSingleByteWithTimeout
X#define MAP_I2C_masterSendSingleByteWithTimeout                                       I2C_masterSendSingleByteWithTimeout
N#endif
N#ifdef ROM_I2C_masterSendMultiByteStart
S#define MAP_I2C_masterSendMultiByteStart                                      \
S        ROM_I2C_masterSendMultiByteStart
X#define MAP_I2C_masterSendMultiByteStart                                              ROM_I2C_masterSendMultiByteStart
N#else
N#define MAP_I2C_masterSendMultiByteStart                                      \
N        I2C_masterSendMultiByteStart
X#define MAP_I2C_masterSendMultiByteStart                                              I2C_masterSendMultiByteStart
N#endif
N#ifdef ROM_I2C_masterSendMultiByteStartWithTimeout
S#define MAP_I2C_masterSendMultiByteStartWithTimeout                           \
S        ROM_I2C_masterSendMultiByteStartWithTimeout
X#define MAP_I2C_masterSendMultiByteStartWithTimeout                                   ROM_I2C_masterSendMultiByteStartWithTimeout
N#else
N#define MAP_I2C_masterSendMultiByteStartWithTimeout                           \
N        I2C_masterSendMultiByteStartWithTimeout
X#define MAP_I2C_masterSendMultiByteStartWithTimeout                                   I2C_masterSendMultiByteStartWithTimeout
N#endif
N#ifdef ROM_I2C_masterSendMultiByteNext
S#define MAP_I2C_masterSendMultiByteNext                                       \
S        ROM_I2C_masterSendMultiByteNext
X#define MAP_I2C_masterSendMultiByteNext                                               ROM_I2C_masterSendMultiByteNext
N#else
N#define MAP_I2C_masterSendMultiByteNext                                       \
N        I2C_masterSendMultiByteNext
X#define MAP_I2C_masterSendMultiByteNext                                               I2C_masterSendMultiByteNext
N#endif
N#ifdef ROM_I2C_masterSendMultiByteNextWithTimeout
S#define MAP_I2C_masterSendMultiByteNextWithTimeout                            \
S        ROM_I2C_masterSendMultiByteNextWithTimeout
X#define MAP_I2C_masterSendMultiByteNextWithTimeout                                    ROM_I2C_masterSendMultiByteNextWithTimeout
N#else
N#define MAP_I2C_masterSendMultiByteNextWithTimeout                            \
N        I2C_masterSendMultiByteNextWithTimeout
X#define MAP_I2C_masterSendMultiByteNextWithTimeout                                    I2C_masterSendMultiByteNextWithTimeout
N#endif
N#ifdef ROM_I2C_masterSendMultiByteFinish
S#define MAP_I2C_masterSendMultiByteFinish                                     \
S        ROM_I2C_masterSendMultiByteFinish
X#define MAP_I2C_masterSendMultiByteFinish                                             ROM_I2C_masterSendMultiByteFinish
N#else
N#define MAP_I2C_masterSendMultiByteFinish                                     \
N        I2C_masterSendMultiByteFinish
X#define MAP_I2C_masterSendMultiByteFinish                                             I2C_masterSendMultiByteFinish
N#endif
N#ifdef ROM_I2C_masterSendMultiByteFinishWithTimeout
S#define MAP_I2C_masterSendMultiByteFinishWithTimeout                          \
S        ROM_I2C_masterSendMultiByteFinishWithTimeout
X#define MAP_I2C_masterSendMultiByteFinishWithTimeout                                  ROM_I2C_masterSendMultiByteFinishWithTimeout
N#else
N#define MAP_I2C_masterSendMultiByteFinishWithTimeout                          \
N        I2C_masterSendMultiByteFinishWithTimeout
X#define MAP_I2C_masterSendMultiByteFinishWithTimeout                                  I2C_masterSendMultiByteFinishWithTimeout
N#endif
N#ifdef ROM_I2C_masterSendMultiByteStop
S#define MAP_I2C_masterSendMultiByteStop                                       \
S        ROM_I2C_masterSendMultiByteStop
X#define MAP_I2C_masterSendMultiByteStop                                               ROM_I2C_masterSendMultiByteStop
N#else
N#define MAP_I2C_masterSendMultiByteStop                                       \
N        I2C_masterSendMultiByteStop
X#define MAP_I2C_masterSendMultiByteStop                                               I2C_masterSendMultiByteStop
N#endif
N#ifdef ROM_I2C_masterSendMultiByteStopWithTimeout
S#define MAP_I2C_masterSendMultiByteStopWithTimeout                            \
S        ROM_I2C_masterSendMultiByteStopWithTimeout
X#define MAP_I2C_masterSendMultiByteStopWithTimeout                                    ROM_I2C_masterSendMultiByteStopWithTimeout
N#else
N#define MAP_I2C_masterSendMultiByteStopWithTimeout                            \
N        I2C_masterSendMultiByteStopWithTimeout
X#define MAP_I2C_masterSendMultiByteStopWithTimeout                                    I2C_masterSendMultiByteStopWithTimeout
N#endif
N#ifdef ROM_I2C_masterReceiveStart
S#define MAP_I2C_masterReceiveStart                                            \
S        ROM_I2C_masterReceiveStart
X#define MAP_I2C_masterReceiveStart                                                    ROM_I2C_masterReceiveStart
N#else
N#define MAP_I2C_masterReceiveStart                                            \
N        I2C_masterReceiveStart
X#define MAP_I2C_masterReceiveStart                                                    I2C_masterReceiveStart
N#endif
N#ifdef ROM_I2C_masterReceiveMultiByteNext
S#define MAP_I2C_masterReceiveMultiByteNext                                    \
S        ROM_I2C_masterReceiveMultiByteNext
X#define MAP_I2C_masterReceiveMultiByteNext                                            ROM_I2C_masterReceiveMultiByteNext
N#else
N#define MAP_I2C_masterReceiveMultiByteNext                                    \
N        I2C_masterReceiveMultiByteNext
X#define MAP_I2C_masterReceiveMultiByteNext                                            I2C_masterReceiveMultiByteNext
N#endif
N#ifdef ROM_I2C_masterReceiveMultiByteFinish
S#define MAP_I2C_masterReceiveMultiByteFinish                                  \
S        ROM_I2C_masterReceiveMultiByteFinish
X#define MAP_I2C_masterReceiveMultiByteFinish                                          ROM_I2C_masterReceiveMultiByteFinish
N#else
N#define MAP_I2C_masterReceiveMultiByteFinish                                  \
N        I2C_masterReceiveMultiByteFinish
X#define MAP_I2C_masterReceiveMultiByteFinish                                          I2C_masterReceiveMultiByteFinish
N#endif
N#ifdef ROM_I2C_masterReceiveMultiByteFinishWithTimeout
S#define MAP_I2C_masterReceiveMultiByteFinishWithTimeout                       \
S        ROM_I2C_masterReceiveMultiByteFinishWithTimeout
X#define MAP_I2C_masterReceiveMultiByteFinishWithTimeout                               ROM_I2C_masterReceiveMultiByteFinishWithTimeout
N#else
N#define MAP_I2C_masterReceiveMultiByteFinishWithTimeout                       \
N        I2C_masterReceiveMultiByteFinishWithTimeout
X#define MAP_I2C_masterReceiveMultiByteFinishWithTimeout                               I2C_masterReceiveMultiByteFinishWithTimeout
N#endif
N#ifdef ROM_I2C_masterReceiveMultiByteStop
S#define MAP_I2C_masterReceiveMultiByteStop                                    \
S        ROM_I2C_masterReceiveMultiByteStop
X#define MAP_I2C_masterReceiveMultiByteStop                                            ROM_I2C_masterReceiveMultiByteStop
N#else
N#define MAP_I2C_masterReceiveMultiByteStop                                    \
N        I2C_masterReceiveMultiByteStop
X#define MAP_I2C_masterReceiveMultiByteStop                                            I2C_masterReceiveMultiByteStop
N#endif
N#ifdef ROM_I2C_masterReceiveSingleByte
S#define MAP_I2C_masterReceiveSingleByte                                       \
S        ROM_I2C_masterReceiveSingleByte
X#define MAP_I2C_masterReceiveSingleByte                                               ROM_I2C_masterReceiveSingleByte
N#else
N#define MAP_I2C_masterReceiveSingleByte                                       \
N        I2C_masterReceiveSingleByte
X#define MAP_I2C_masterReceiveSingleByte                                               I2C_masterReceiveSingleByte
N#endif
N#ifdef ROM_I2C_masterReceiveSingle
S#define MAP_I2C_masterReceiveSingle                                           \
S        ROM_I2C_masterReceiveSingle
X#define MAP_I2C_masterReceiveSingle                                                   ROM_I2C_masterReceiveSingle
N#else
N#define MAP_I2C_masterReceiveSingle                                           \
N        I2C_masterReceiveSingle
X#define MAP_I2C_masterReceiveSingle                                                   I2C_masterReceiveSingle
N#endif
N#ifdef ROM_I2C_getReceiveBufferAddressForDMA
S#define MAP_I2C_getReceiveBufferAddressForDMA                                 \
S        ROM_I2C_getReceiveBufferAddressForDMA
X#define MAP_I2C_getReceiveBufferAddressForDMA                                         ROM_I2C_getReceiveBufferAddressForDMA
N#else
N#define MAP_I2C_getReceiveBufferAddressForDMA                                 \
N        I2C_getReceiveBufferAddressForDMA
X#define MAP_I2C_getReceiveBufferAddressForDMA                                         I2C_getReceiveBufferAddressForDMA
N#endif
N#ifdef ROM_I2C_getTransmitBufferAddressForDMA
S#define MAP_I2C_getTransmitBufferAddressForDMA                                \
S        ROM_I2C_getTransmitBufferAddressForDMA
X#define MAP_I2C_getTransmitBufferAddressForDMA                                        ROM_I2C_getTransmitBufferAddressForDMA
N#else
N#define MAP_I2C_getTransmitBufferAddressForDMA                                \
N        I2C_getTransmitBufferAddressForDMA
X#define MAP_I2C_getTransmitBufferAddressForDMA                                        I2C_getTransmitBufferAddressForDMA
N#endif
N#ifdef ROM_I2C_masterIsStopSent
S#define MAP_I2C_masterIsStopSent                                              \
S        ROM_I2C_masterIsStopSent
X#define MAP_I2C_masterIsStopSent                                                      ROM_I2C_masterIsStopSent
N#else
N#define MAP_I2C_masterIsStopSent                                              \
N        I2C_masterIsStopSent
X#define MAP_I2C_masterIsStopSent                                                      I2C_masterIsStopSent
N#endif
N#ifdef ROM_I2C_masterIsStartSent
S#define MAP_I2C_masterIsStartSent                                             \
S        ROM_I2C_masterIsStartSent
X#define MAP_I2C_masterIsStartSent                                                     ROM_I2C_masterIsStartSent
N#else
N#define MAP_I2C_masterIsStartSent                                             \
N        I2C_masterIsStartSent
X#define MAP_I2C_masterIsStartSent                                                     I2C_masterIsStartSent
N#endif
N#ifdef ROM_I2C_masterSendStart
S#define MAP_I2C_masterSendStart                                               \
S        ROM_I2C_masterSendStart
X#define MAP_I2C_masterSendStart                                                       ROM_I2C_masterSendStart
N#else
N#define MAP_I2C_masterSendStart                                               \
N        I2C_masterSendStart
X#define MAP_I2C_masterSendStart                                                       I2C_masterSendStart
N#endif
N#ifdef ROM_I2C_enableMultiMasterMode
S#define MAP_I2C_enableMultiMasterMode                                         \
S        ROM_I2C_enableMultiMasterMode
X#define MAP_I2C_enableMultiMasterMode                                                 ROM_I2C_enableMultiMasterMode
N#else
N#define MAP_I2C_enableMultiMasterMode                                         \
N        I2C_enableMultiMasterMode
X#define MAP_I2C_enableMultiMasterMode                                                 I2C_enableMultiMasterMode
N#endif
N#ifdef ROM_I2C_disableMultiMasterMode
S#define MAP_I2C_disableMultiMasterMode                                        \
S        ROM_I2C_disableMultiMasterMode
X#define MAP_I2C_disableMultiMasterMode                                                ROM_I2C_disableMultiMasterMode
N#else
N#define MAP_I2C_disableMultiMasterMode                                        \
N        I2C_disableMultiMasterMode
X#define MAP_I2C_disableMultiMasterMode                                                I2C_disableMultiMasterMode
N#endif
N#ifdef ROM_I2C_enableInterrupt
S#define MAP_I2C_enableInterrupt                                               \
S        ROM_I2C_enableInterrupt
X#define MAP_I2C_enableInterrupt                                                       ROM_I2C_enableInterrupt
N#else
N#define MAP_I2C_enableInterrupt                                               \
N        I2C_enableInterrupt
X#define MAP_I2C_enableInterrupt                                                       I2C_enableInterrupt
N#endif
N#ifdef ROM_I2C_disableInterrupt
S#define MAP_I2C_disableInterrupt                                              \
S        ROM_I2C_disableInterrupt
X#define MAP_I2C_disableInterrupt                                                      ROM_I2C_disableInterrupt
N#else
N#define MAP_I2C_disableInterrupt                                              \
N        I2C_disableInterrupt
X#define MAP_I2C_disableInterrupt                                                      I2C_disableInterrupt
N#endif
N#ifdef ROM_I2C_clearInterruptFlag
S#define MAP_I2C_clearInterruptFlag                                            \
S        ROM_I2C_clearInterruptFlag
X#define MAP_I2C_clearInterruptFlag                                                    ROM_I2C_clearInterruptFlag
N#else
N#define MAP_I2C_clearInterruptFlag                                            \
N        I2C_clearInterruptFlag
X#define MAP_I2C_clearInterruptFlag                                                    I2C_clearInterruptFlag
N#endif
N#ifdef ROM_I2C_getInterruptStatus
S#define MAP_I2C_getInterruptStatus                                            \
S        ROM_I2C_getInterruptStatus
X#define MAP_I2C_getInterruptStatus                                                    ROM_I2C_getInterruptStatus
N#else
N#define MAP_I2C_getInterruptStatus                                            \
N        I2C_getInterruptStatus
X#define MAP_I2C_getInterruptStatus                                                    I2C_getInterruptStatus
N#endif
N#ifdef ROM_I2C_getEnabledInterruptStatus
S#define MAP_I2C_getEnabledInterruptStatus                                     \
S        ROM_I2C_getEnabledInterruptStatus
X#define MAP_I2C_getEnabledInterruptStatus                                             ROM_I2C_getEnabledInterruptStatus
N#else
N#define MAP_I2C_getEnabledInterruptStatus                                     \
N        I2C_getEnabledInterruptStatus
X#define MAP_I2C_getEnabledInterruptStatus                                             I2C_getEnabledInterruptStatus
N#endif
N#ifdef ROM_I2C_getMode
S#define MAP_I2C_getMode                                                       \
S        ROM_I2C_getMode
X#define MAP_I2C_getMode                                                               ROM_I2C_getMode
N#else
N#define MAP_I2C_getMode                                                       \
N        I2C_getMode
X#define MAP_I2C_getMode                                                               I2C_getMode
N#endif
N#ifdef ROM_I2C_registerInterrupt
S#define MAP_I2C_registerInterrupt                                             \
S        ROM_I2C_registerInterrupt
X#define MAP_I2C_registerInterrupt                                                     ROM_I2C_registerInterrupt
N#else
N#define MAP_I2C_registerInterrupt                                             \
N        I2C_registerInterrupt
X#define MAP_I2C_registerInterrupt                                                     I2C_registerInterrupt
N#endif
N#ifdef ROM_I2C_unregisterInterrupt
S#define MAP_I2C_unregisterInterrupt                                           \
S        ROM_I2C_unregisterInterrupt
X#define MAP_I2C_unregisterInterrupt                                                   ROM_I2C_unregisterInterrupt
N#else
N#define MAP_I2C_unregisterInterrupt                                           \
N        I2C_unregisterInterrupt
X#define MAP_I2C_unregisterInterrupt                                                   I2C_unregisterInterrupt
N#endif
N#ifdef ROM_I2C_slaveSendNAK
S#define MAP_I2C_slaveSendNAK                                                  \
S        ROM_I2C_slaveSendNAK
X#define MAP_I2C_slaveSendNAK                                                          ROM_I2C_slaveSendNAK
N#else
N#define MAP_I2C_slaveSendNAK                                                  \
N        I2C_slaveSendNAK
X#define MAP_I2C_slaveSendNAK                                                          I2C_slaveSendNAK
N#endif
N
N//*****************************************************************************
N//
N// Macros for the Interrupt API.
N//
N//*****************************************************************************
N#ifdef ROM_Interrupt_enableMaster
S#define MAP_Interrupt_enableMaster                                            \
S        ROM_Interrupt_enableMaster
X#define MAP_Interrupt_enableMaster                                                    ROM_Interrupt_enableMaster
N#else
N#define MAP_Interrupt_enableMaster                                            \
N        Interrupt_enableMaster
X#define MAP_Interrupt_enableMaster                                                    Interrupt_enableMaster
N#endif
N#ifdef ROM_Interrupt_disableMaster
S#define MAP_Interrupt_disableMaster                                           \
S        ROM_Interrupt_disableMaster
X#define MAP_Interrupt_disableMaster                                                   ROM_Interrupt_disableMaster
N#else
N#define MAP_Interrupt_disableMaster                                           \
N        Interrupt_disableMaster
X#define MAP_Interrupt_disableMaster                                                   Interrupt_disableMaster
N#endif
N#ifdef ROM_Interrupt_setPriorityGrouping
S#define MAP_Interrupt_setPriorityGrouping                                     \
S        ROM_Interrupt_setPriorityGrouping
X#define MAP_Interrupt_setPriorityGrouping                                             ROM_Interrupt_setPriorityGrouping
N#else
N#define MAP_Interrupt_setPriorityGrouping                                     \
N        Interrupt_setPriorityGrouping
X#define MAP_Interrupt_setPriorityGrouping                                             Interrupt_setPriorityGrouping
N#endif
N#ifdef ROM_Interrupt_getPriorityGrouping
S#define MAP_Interrupt_getPriorityGrouping                                     \
S        ROM_Interrupt_getPriorityGrouping
X#define MAP_Interrupt_getPriorityGrouping                                             ROM_Interrupt_getPriorityGrouping
N#else
N#define MAP_Interrupt_getPriorityGrouping                                     \
N        Interrupt_getPriorityGrouping
X#define MAP_Interrupt_getPriorityGrouping                                             Interrupt_getPriorityGrouping
N#endif
N#ifdef ROM_Interrupt_setPriority
S#define MAP_Interrupt_setPriority                                             \
S        ROM_Interrupt_setPriority
X#define MAP_Interrupt_setPriority                                                     ROM_Interrupt_setPriority
N#else
N#define MAP_Interrupt_setPriority                                             \
N        Interrupt_setPriority
X#define MAP_Interrupt_setPriority                                                     Interrupt_setPriority
N#endif
N#ifdef ROM_Interrupt_getPriority
S#define MAP_Interrupt_getPriority                                             \
S        ROM_Interrupt_getPriority
X#define MAP_Interrupt_getPriority                                                     ROM_Interrupt_getPriority
N#else
N#define MAP_Interrupt_getPriority                                             \
N        Interrupt_getPriority
X#define MAP_Interrupt_getPriority                                                     Interrupt_getPriority
N#endif
N#ifdef ROM_Interrupt_enableInterrupt
S#define MAP_Interrupt_enableInterrupt                                         \
S        ROM_Interrupt_enableInterrupt
X#define MAP_Interrupt_enableInterrupt                                                 ROM_Interrupt_enableInterrupt
N#else
N#define MAP_Interrupt_enableInterrupt                                         \
N        Interrupt_enableInterrupt
X#define MAP_Interrupt_enableInterrupt                                                 Interrupt_enableInterrupt
N#endif
N#ifdef ROM_Interrupt_disableInterrupt
S#define MAP_Interrupt_disableInterrupt                                        \
S        ROM_Interrupt_disableInterrupt
X#define MAP_Interrupt_disableInterrupt                                                ROM_Interrupt_disableInterrupt
N#else
N#define MAP_Interrupt_disableInterrupt                                        \
N        Interrupt_disableInterrupt
X#define MAP_Interrupt_disableInterrupt                                                Interrupt_disableInterrupt
N#endif
N#ifdef ROM_Interrupt_isEnabled
S#define MAP_Interrupt_isEnabled                                               \
S        ROM_Interrupt_isEnabled
X#define MAP_Interrupt_isEnabled                                                       ROM_Interrupt_isEnabled
N#else
N#define MAP_Interrupt_isEnabled                                               \
N        Interrupt_isEnabled
X#define MAP_Interrupt_isEnabled                                                       Interrupt_isEnabled
N#endif
N#ifdef ROM_Interrupt_pendInterrupt
S#define MAP_Interrupt_pendInterrupt                                           \
S        ROM_Interrupt_pendInterrupt
X#define MAP_Interrupt_pendInterrupt                                                   ROM_Interrupt_pendInterrupt
N#else
N#define MAP_Interrupt_pendInterrupt                                           \
N        Interrupt_pendInterrupt
X#define MAP_Interrupt_pendInterrupt                                                   Interrupt_pendInterrupt
N#endif
N#ifdef ROM_Interrupt_setPriorityMask
S#define MAP_Interrupt_setPriorityMask                                         \
S        ROM_Interrupt_setPriorityMask
X#define MAP_Interrupt_setPriorityMask                                                 ROM_Interrupt_setPriorityMask
N#else
N#define MAP_Interrupt_setPriorityMask                                         \
N        Interrupt_setPriorityMask
X#define MAP_Interrupt_setPriorityMask                                                 Interrupt_setPriorityMask
N#endif
N#ifdef ROM_Interrupt_getPriorityMask
S#define MAP_Interrupt_getPriorityMask                                         \
S        ROM_Interrupt_getPriorityMask
X#define MAP_Interrupt_getPriorityMask                                                 ROM_Interrupt_getPriorityMask
N#else
N#define MAP_Interrupt_getPriorityMask                                         \
N        Interrupt_getPriorityMask
X#define MAP_Interrupt_getPriorityMask                                                 Interrupt_getPriorityMask
N#endif
N#ifdef ROM_Interrupt_setVectorTableAddress
S#define MAP_Interrupt_setVectorTableAddress                                   \
S        ROM_Interrupt_setVectorTableAddress
X#define MAP_Interrupt_setVectorTableAddress                                           ROM_Interrupt_setVectorTableAddress
N#else
N#define MAP_Interrupt_setVectorTableAddress                                   \
N        Interrupt_setVectorTableAddress
X#define MAP_Interrupt_setVectorTableAddress                                           Interrupt_setVectorTableAddress
N#endif
N#ifdef ROM_Interrupt_getVectorTableAddress
S#define MAP_Interrupt_getVectorTableAddress                                   \
S        ROM_Interrupt_getVectorTableAddress
X#define MAP_Interrupt_getVectorTableAddress                                           ROM_Interrupt_getVectorTableAddress
N#else
N#define MAP_Interrupt_getVectorTableAddress                                   \
N        Interrupt_getVectorTableAddress
X#define MAP_Interrupt_getVectorTableAddress                                           Interrupt_getVectorTableAddress
N#endif
N#ifdef ROM_Interrupt_enableSleepOnIsrExit
S#define MAP_Interrupt_enableSleepOnIsrExit                                    \
S        ROM_Interrupt_enableSleepOnIsrExit
X#define MAP_Interrupt_enableSleepOnIsrExit                                            ROM_Interrupt_enableSleepOnIsrExit
N#else
N#define MAP_Interrupt_enableSleepOnIsrExit                                    \
N        Interrupt_enableSleepOnIsrExit
X#define MAP_Interrupt_enableSleepOnIsrExit                                            Interrupt_enableSleepOnIsrExit
N#endif
N#ifdef ROM_Interrupt_disableSleepOnIsrExit
S#define MAP_Interrupt_disableSleepOnIsrExit                                   \
S        ROM_Interrupt_disableSleepOnIsrExit
X#define MAP_Interrupt_disableSleepOnIsrExit                                           ROM_Interrupt_disableSleepOnIsrExit
N#else
N#define MAP_Interrupt_disableSleepOnIsrExit                                   \
N        Interrupt_disableSleepOnIsrExit
X#define MAP_Interrupt_disableSleepOnIsrExit                                           Interrupt_disableSleepOnIsrExit
N#endif
N#ifdef ROM_Interrupt_registerInterrupt
S#define MAP_Interrupt_registerInterrupt                                       \
S        ROM_Interrupt_registerInterrupt
X#define MAP_Interrupt_registerInterrupt                                               ROM_Interrupt_registerInterrupt
N#else
N#define MAP_Interrupt_registerInterrupt                                       \
N        Interrupt_registerInterrupt
X#define MAP_Interrupt_registerInterrupt                                               Interrupt_registerInterrupt
N#endif
N#ifdef ROM_Interrupt_unregisterInterrupt
S#define MAP_Interrupt_unregisterInterrupt                                     \
S        ROM_Interrupt_unregisterInterrupt
X#define MAP_Interrupt_unregisterInterrupt                                             ROM_Interrupt_unregisterInterrupt
N#else
N#define MAP_Interrupt_unregisterInterrupt                                     \
N        Interrupt_unregisterInterrupt
X#define MAP_Interrupt_unregisterInterrupt                                             Interrupt_unregisterInterrupt
N#endif
N#ifdef ROM_Interrupt_unpendInterrupt
S#define MAP_Interrupt_unpendInterrupt                                         \
S        ROM_Interrupt_unpendInterrupt
X#define MAP_Interrupt_unpendInterrupt                                                 ROM_Interrupt_unpendInterrupt
N#else
N#define MAP_Interrupt_unpendInterrupt                                         \
N        Interrupt_unpendInterrupt
X#define MAP_Interrupt_unpendInterrupt                                                 Interrupt_unpendInterrupt
N#endif
N
N//*****************************************************************************
N//
N// Macros for the MPU API.
N//
N//*****************************************************************************
N#ifdef ROM_MPU_enableModule
S#define MAP_MPU_enableModule                                                  \
S        ROM_MPU_enableModule
X#define MAP_MPU_enableModule                                                          ROM_MPU_enableModule
N#else
N#define MAP_MPU_enableModule                                                  \
N        MPU_enableModule
X#define MAP_MPU_enableModule                                                          MPU_enableModule
N#endif
N#ifdef ROM_MPU_disableModule
S#define MAP_MPU_disableModule                                                 \
S        ROM_MPU_disableModule
X#define MAP_MPU_disableModule                                                         ROM_MPU_disableModule
N#else
N#define MAP_MPU_disableModule                                                 \
N        MPU_disableModule
X#define MAP_MPU_disableModule                                                         MPU_disableModule
N#endif
N#ifdef ROM_MPU_getRegionCount
S#define MAP_MPU_getRegionCount                                                \
S        ROM_MPU_getRegionCount
X#define MAP_MPU_getRegionCount                                                        ROM_MPU_getRegionCount
N#else
N#define MAP_MPU_getRegionCount                                                \
N        MPU_getRegionCount
X#define MAP_MPU_getRegionCount                                                        MPU_getRegionCount
N#endif
N#ifdef ROM_MPU_enableRegion
S#define MAP_MPU_enableRegion                                                  \
S        ROM_MPU_enableRegion
X#define MAP_MPU_enableRegion                                                          ROM_MPU_enableRegion
N#else
N#define MAP_MPU_enableRegion                                                  \
N        MPU_enableRegion
X#define MAP_MPU_enableRegion                                                          MPU_enableRegion
N#endif
N#ifdef ROM_MPU_disableRegion
S#define MAP_MPU_disableRegion                                                 \
S        ROM_MPU_disableRegion
X#define MAP_MPU_disableRegion                                                         ROM_MPU_disableRegion
N#else
N#define MAP_MPU_disableRegion                                                 \
N        MPU_disableRegion
X#define MAP_MPU_disableRegion                                                         MPU_disableRegion
N#endif
N#ifdef ROM_MPU_setRegion
S#define MAP_MPU_setRegion                                                     \
S        ROM_MPU_setRegion
X#define MAP_MPU_setRegion                                                             ROM_MPU_setRegion
N#else
N#define MAP_MPU_setRegion                                                     \
N        MPU_setRegion
X#define MAP_MPU_setRegion                                                             MPU_setRegion
N#endif
N#ifdef ROM_MPU_getRegion
S#define MAP_MPU_getRegion                                                     \
S        ROM_MPU_getRegion
X#define MAP_MPU_getRegion                                                             ROM_MPU_getRegion
N#else
N#define MAP_MPU_getRegion                                                     \
N        MPU_getRegion
X#define MAP_MPU_getRegion                                                             MPU_getRegion
N#endif
N#ifdef ROM_MPU_enableInterrupt
S#define MAP_MPU_enableInterrupt                                               \
S        ROM_MPU_enableInterrupt
X#define MAP_MPU_enableInterrupt                                                       ROM_MPU_enableInterrupt
N#else
N#define MAP_MPU_enableInterrupt                                               \
N        MPU_enableInterrupt
X#define MAP_MPU_enableInterrupt                                                       MPU_enableInterrupt
N#endif
N#ifdef ROM_MPU_disableInterrupt
S#define MAP_MPU_disableInterrupt                                              \
S        ROM_MPU_disableInterrupt
X#define MAP_MPU_disableInterrupt                                                      ROM_MPU_disableInterrupt
N#else
N#define MAP_MPU_disableInterrupt                                              \
N        MPU_disableInterrupt
X#define MAP_MPU_disableInterrupt                                                      MPU_disableInterrupt
N#endif
N#ifdef ROM_MPU_registerInterrupt
S#define MAP_MPU_registerInterrupt                                             \
S        ROM_MPU_registerInterrupt
X#define MAP_MPU_registerInterrupt                                                     ROM_MPU_registerInterrupt
N#else
N#define MAP_MPU_registerInterrupt                                             \
N        MPU_registerInterrupt
X#define MAP_MPU_registerInterrupt                                                     MPU_registerInterrupt
N#endif
N#ifdef ROM_MPU_unregisterInterrupt
S#define MAP_MPU_unregisterInterrupt                                           \
S        ROM_MPU_unregisterInterrupt
X#define MAP_MPU_unregisterInterrupt                                                   ROM_MPU_unregisterInterrupt
N#else
N#define MAP_MPU_unregisterInterrupt                                           \
N        MPU_unregisterInterrupt
X#define MAP_MPU_unregisterInterrupt                                                   MPU_unregisterInterrupt
N#endif
N
N//*****************************************************************************
N//
N// Macros for the PCM API.
N//
N//*****************************************************************************
N#ifdef ROM_PCM_setCoreVoltageLevel
S#define MAP_PCM_setCoreVoltageLevel                                           \
S        ROM_PCM_setCoreVoltageLevel
X#define MAP_PCM_setCoreVoltageLevel                                                   ROM_PCM_setCoreVoltageLevel
N#else
N#define MAP_PCM_setCoreVoltageLevel                                           \
N        PCM_setCoreVoltageLevel
X#define MAP_PCM_setCoreVoltageLevel                                                   PCM_setCoreVoltageLevel
N#endif
N#ifdef ROM_PCM_getCoreVoltageLevel
S#define MAP_PCM_getCoreVoltageLevel                                           \
S        ROM_PCM_getCoreVoltageLevel
X#define MAP_PCM_getCoreVoltageLevel                                                   ROM_PCM_getCoreVoltageLevel
N#else
N#define MAP_PCM_getCoreVoltageLevel                                           \
N        PCM_getCoreVoltageLevel
X#define MAP_PCM_getCoreVoltageLevel                                                   PCM_getCoreVoltageLevel
N#endif
N#ifdef ROM_PCM_setCoreVoltageLevelWithTimeout
S#define MAP_PCM_setCoreVoltageLevelWithTimeout                                \
S        ROM_PCM_setCoreVoltageLevelWithTimeout
X#define MAP_PCM_setCoreVoltageLevelWithTimeout                                        ROM_PCM_setCoreVoltageLevelWithTimeout
N#else
N#define MAP_PCM_setCoreVoltageLevelWithTimeout                                \
N        PCM_setCoreVoltageLevelWithTimeout
X#define MAP_PCM_setCoreVoltageLevelWithTimeout                                        PCM_setCoreVoltageLevelWithTimeout
N#endif
N#ifdef ROM_PCM_setPowerMode
S#define MAP_PCM_setPowerMode                                                  \
S        ROM_PCM_setPowerMode
X#define MAP_PCM_setPowerMode                                                          ROM_PCM_setPowerMode
N#else
N#define MAP_PCM_setPowerMode                                                  \
N        PCM_setPowerMode
X#define MAP_PCM_setPowerMode                                                          PCM_setPowerMode
N#endif
N#ifdef ROM_PCM_setPowerModeWithTimeout
S#define MAP_PCM_setPowerModeWithTimeout                                       \
S        ROM_PCM_setPowerModeWithTimeout
X#define MAP_PCM_setPowerModeWithTimeout                                               ROM_PCM_setPowerModeWithTimeout
N#else
N#define MAP_PCM_setPowerModeWithTimeout                                       \
N        PCM_setPowerModeWithTimeout
X#define MAP_PCM_setPowerModeWithTimeout                                               PCM_setPowerModeWithTimeout
N#endif
N#ifdef ROM_PCM_getPowerMode
S#define MAP_PCM_getPowerMode                                                  \
S        ROM_PCM_getPowerMode
X#define MAP_PCM_getPowerMode                                                          ROM_PCM_getPowerMode
N#else
N#define MAP_PCM_getPowerMode                                                  \
N        PCM_getPowerMode
X#define MAP_PCM_getPowerMode                                                          PCM_getPowerMode
N#endif
N#ifdef ROM_PCM_setPowerState
S#define MAP_PCM_setPowerState                                                 \
S        ROM_PCM_setPowerState
X#define MAP_PCM_setPowerState                                                         ROM_PCM_setPowerState
N#else
N#define MAP_PCM_setPowerState                                                 \
N        PCM_setPowerState
X#define MAP_PCM_setPowerState                                                         PCM_setPowerState
N#endif
N#ifdef ROM_PCM_setPowerStateWithTimeout
S#define MAP_PCM_setPowerStateWithTimeout                                      \
S        ROM_PCM_setPowerStateWithTimeout
X#define MAP_PCM_setPowerStateWithTimeout                                              ROM_PCM_setPowerStateWithTimeout
N#else
N#define MAP_PCM_setPowerStateWithTimeout                                      \
N        PCM_setPowerStateWithTimeout
X#define MAP_PCM_setPowerStateWithTimeout                                              PCM_setPowerStateWithTimeout
N#endif
N#ifdef ROM_PCM_getPowerState
S#define MAP_PCM_getPowerState                                                 \
S        ROM_PCM_getPowerState
X#define MAP_PCM_getPowerState                                                         ROM_PCM_getPowerState
N#else
N#define MAP_PCM_getPowerState                                                 \
N        PCM_getPowerState
X#define MAP_PCM_getPowerState                                                         PCM_getPowerState
N#endif
N#ifdef ROM_PCM_shutdownDevice
S#define MAP_PCM_shutdownDevice                                                \
S        ROM_PCM_shutdownDevice
X#define MAP_PCM_shutdownDevice                                                        ROM_PCM_shutdownDevice
N#else
N#define MAP_PCM_shutdownDevice                                                \
N        PCM_shutdownDevice
X#define MAP_PCM_shutdownDevice                                                        PCM_shutdownDevice
N#endif
N#ifdef ROM_PCM_gotoLPM0
S#define MAP_PCM_gotoLPM0                                                      \
S        ROM_PCM_gotoLPM0
X#define MAP_PCM_gotoLPM0                                                              ROM_PCM_gotoLPM0
N#else
N#define MAP_PCM_gotoLPM0                                                      \
N        PCM_gotoLPM0
X#define MAP_PCM_gotoLPM0                                                              PCM_gotoLPM0
N#endif
N#ifdef ROM_PCM_gotoLPM3
S#define MAP_PCM_gotoLPM3                                                      \
S        ROM_PCM_gotoLPM3
X#define MAP_PCM_gotoLPM3                                                              ROM_PCM_gotoLPM3
N#else
N#define MAP_PCM_gotoLPM3                                                      \
N        PCM_gotoLPM3
X#define MAP_PCM_gotoLPM3                                                              PCM_gotoLPM3
N#endif
N#ifdef ROM_PCM_enableInterrupt
S#define MAP_PCM_enableInterrupt                                               \
S        ROM_PCM_enableInterrupt
X#define MAP_PCM_enableInterrupt                                                       ROM_PCM_enableInterrupt
N#else
N#define MAP_PCM_enableInterrupt                                               \
N        PCM_enableInterrupt
X#define MAP_PCM_enableInterrupt                                                       PCM_enableInterrupt
N#endif
N#ifdef ROM_PCM_disableInterrupt
S#define MAP_PCM_disableInterrupt                                              \
S        ROM_PCM_disableInterrupt
X#define MAP_PCM_disableInterrupt                                                      ROM_PCM_disableInterrupt
N#else
N#define MAP_PCM_disableInterrupt                                              \
N        PCM_disableInterrupt
X#define MAP_PCM_disableInterrupt                                                      PCM_disableInterrupt
N#endif
N#ifdef ROM_PCM_getInterruptStatus
S#define MAP_PCM_getInterruptStatus                                            \
S        ROM_PCM_getInterruptStatus
X#define MAP_PCM_getInterruptStatus                                                    ROM_PCM_getInterruptStatus
N#else
N#define MAP_PCM_getInterruptStatus                                            \
N        PCM_getInterruptStatus
X#define MAP_PCM_getInterruptStatus                                                    PCM_getInterruptStatus
N#endif
N#ifdef ROM_PCM_getEnabledInterruptStatus
S#define MAP_PCM_getEnabledInterruptStatus                                     \
S        ROM_PCM_getEnabledInterruptStatus
X#define MAP_PCM_getEnabledInterruptStatus                                             ROM_PCM_getEnabledInterruptStatus
N#else
N#define MAP_PCM_getEnabledInterruptStatus                                     \
N        PCM_getEnabledInterruptStatus
X#define MAP_PCM_getEnabledInterruptStatus                                             PCM_getEnabledInterruptStatus
N#endif
N#ifdef ROM_PCM_clearInterruptFlag
S#define MAP_PCM_clearInterruptFlag                                            \
S        ROM_PCM_clearInterruptFlag
X#define MAP_PCM_clearInterruptFlag                                                    ROM_PCM_clearInterruptFlag
N#else
N#define MAP_PCM_clearInterruptFlag                                            \
N        PCM_clearInterruptFlag
X#define MAP_PCM_clearInterruptFlag                                                    PCM_clearInterruptFlag
N#endif
N#ifdef ROM_PCM_enableRudeMode
S#define MAP_PCM_enableRudeMode                                                \
S        ROM_PCM_enableRudeMode
X#define MAP_PCM_enableRudeMode                                                        ROM_PCM_enableRudeMode
N#else
N#define MAP_PCM_enableRudeMode                                                \
N        PCM_enableRudeMode
X#define MAP_PCM_enableRudeMode                                                        PCM_enableRudeMode
N#endif
N#ifdef ROM_PCM_disableRudeMode
S#define MAP_PCM_disableRudeMode                                               \
S        ROM_PCM_disableRudeMode
X#define MAP_PCM_disableRudeMode                                                       ROM_PCM_disableRudeMode
N#else
N#define MAP_PCM_disableRudeMode                                               \
N        PCM_disableRudeMode
X#define MAP_PCM_disableRudeMode                                                       PCM_disableRudeMode
N#endif
N#ifdef ROM_PCM_gotoLPM0InterruptSafe
S#define MAP_PCM_gotoLPM0InterruptSafe                                         \
S        ROM_PCM_gotoLPM0InterruptSafe
X#define MAP_PCM_gotoLPM0InterruptSafe                                                 ROM_PCM_gotoLPM0InterruptSafe
N#else
N#define MAP_PCM_gotoLPM0InterruptSafe                                         \
N        PCM_gotoLPM0InterruptSafe
X#define MAP_PCM_gotoLPM0InterruptSafe                                                 PCM_gotoLPM0InterruptSafe
N#endif
N#ifdef ROM_PCM_gotoLPM3InterruptSafe
S#define MAP_PCM_gotoLPM3InterruptSafe                                         \
S        ROM_PCM_gotoLPM3InterruptSafe
X#define MAP_PCM_gotoLPM3InterruptSafe                                                 ROM_PCM_gotoLPM3InterruptSafe
N#else
N#define MAP_PCM_gotoLPM3InterruptSafe                                         \
N        PCM_gotoLPM3InterruptSafe
X#define MAP_PCM_gotoLPM3InterruptSafe                                                 PCM_gotoLPM3InterruptSafe
N#endif
N#ifdef ROM_PCM_registerInterrupt
S#define MAP_PCM_registerInterrupt                                             \
S        ROM_PCM_registerInterrupt
X#define MAP_PCM_registerInterrupt                                                     ROM_PCM_registerInterrupt
N#else
N#define MAP_PCM_registerInterrupt                                             \
N        PCM_registerInterrupt
X#define MAP_PCM_registerInterrupt                                                     PCM_registerInterrupt
N#endif
N#ifdef ROM_PCM_unregisterInterrupt
S#define MAP_PCM_unregisterInterrupt                                           \
S        ROM_PCM_unregisterInterrupt
X#define MAP_PCM_unregisterInterrupt                                                   ROM_PCM_unregisterInterrupt
N#else
N#define MAP_PCM_unregisterInterrupt                                           \
N        PCM_unregisterInterrupt
X#define MAP_PCM_unregisterInterrupt                                                   PCM_unregisterInterrupt
N#endif
N#ifdef ROM_PCM_setCoreVoltageLevelNonBlocking
S#define MAP_PCM_setCoreVoltageLevelNonBlocking                                \
S        ROM_PCM_setCoreVoltageLevelNonBlocking
X#define MAP_PCM_setCoreVoltageLevelNonBlocking                                        ROM_PCM_setCoreVoltageLevelNonBlocking
N#else
N#define MAP_PCM_setCoreVoltageLevelNonBlocking                                \
N        PCM_setCoreVoltageLevelNonBlocking
X#define MAP_PCM_setCoreVoltageLevelNonBlocking                                        PCM_setCoreVoltageLevelNonBlocking
N#endif
N#ifdef ROM_PCM_setPowerModeNonBlocking
S#define MAP_PCM_setPowerModeNonBlocking                                       \
S        ROM_PCM_setPowerModeNonBlocking
X#define MAP_PCM_setPowerModeNonBlocking                                               ROM_PCM_setPowerModeNonBlocking
N#else
N#define MAP_PCM_setPowerModeNonBlocking                                       \
N        PCM_setPowerModeNonBlocking
X#define MAP_PCM_setPowerModeNonBlocking                                               PCM_setPowerModeNonBlocking
N#endif
N#ifdef ROM_PCM_setPowerStateNonBlocking
S#define MAP_PCM_setPowerStateNonBlocking                                      \
S        ROM_PCM_setPowerStateNonBlocking
X#define MAP_PCM_setPowerStateNonBlocking                                              ROM_PCM_setPowerStateNonBlocking
N#else
N#define MAP_PCM_setPowerStateNonBlocking                                      \
N        PCM_setPowerStateNonBlocking
X#define MAP_PCM_setPowerStateNonBlocking                                              PCM_setPowerStateNonBlocking
N#endif
N#ifdef ROM_PCM_gotoLPM4
S#define MAP_PCM_gotoLPM4                                                      \
S        ROM_PCM_gotoLPM4
X#define MAP_PCM_gotoLPM4                                                              ROM_PCM_gotoLPM4
N#else
N#define MAP_PCM_gotoLPM4                                                      \
N        PCM_gotoLPM4
X#define MAP_PCM_gotoLPM4                                                              PCM_gotoLPM4
N#endif
N#ifdef ROM_PCM_gotoLPM4InterruptSafe
S#define MAP_PCM_gotoLPM4InterruptSafe                                         \
S        ROM_PCM_gotoLPM4InterruptSafe
X#define MAP_PCM_gotoLPM4InterruptSafe                                                 ROM_PCM_gotoLPM4InterruptSafe
N#else
N#define MAP_PCM_gotoLPM4InterruptSafe                                         \
N        PCM_gotoLPM4InterruptSafe
X#define MAP_PCM_gotoLPM4InterruptSafe                                                 PCM_gotoLPM4InterruptSafe
N#endif
N
N//*****************************************************************************
N//
N// Macros for the PMAP API.
N//
N//*****************************************************************************
N#ifdef ROM_PMAP_configurePorts
S#define MAP_PMAP_configurePorts                                               \
S        ROM_PMAP_configurePorts
X#define MAP_PMAP_configurePorts                                                       ROM_PMAP_configurePorts
N#else
N#define MAP_PMAP_configurePorts                                               \
N        PMAP_configurePorts
X#define MAP_PMAP_configurePorts                                                       PMAP_configurePorts
N#endif
N
N//*****************************************************************************
N//
N// Macros for the PSS API.
N//
N//*****************************************************************************
N#ifdef ROM_PSS_enableHighSidePinToggle
S#define MAP_PSS_enableHighSidePinToggle                                       \
S        ROM_PSS_enableHighSidePinToggle
X#define MAP_PSS_enableHighSidePinToggle                                               ROM_PSS_enableHighSidePinToggle
N#else
N#define MAP_PSS_enableHighSidePinToggle                                       \
N        PSS_enableHighSidePinToggle
X#define MAP_PSS_enableHighSidePinToggle                                               PSS_enableHighSidePinToggle
N#endif
N#ifdef ROM_PSS_disableHighSidePinToggle
S#define MAP_PSS_disableHighSidePinToggle                                      \
S        ROM_PSS_disableHighSidePinToggle
X#define MAP_PSS_disableHighSidePinToggle                                              ROM_PSS_disableHighSidePinToggle
N#else
N#define MAP_PSS_disableHighSidePinToggle                                      \
N        PSS_disableHighSidePinToggle
X#define MAP_PSS_disableHighSidePinToggle                                              PSS_disableHighSidePinToggle
N#endif
N#ifdef ROM_PSS_enableHighSide
S#define MAP_PSS_enableHighSide                                                \
S        ROM_PSS_enableHighSide
X#define MAP_PSS_enableHighSide                                                        ROM_PSS_enableHighSide
N#else
N#define MAP_PSS_enableHighSide                                                \
N        PSS_enableHighSide
X#define MAP_PSS_enableHighSide                                                        PSS_enableHighSide
N#endif
N#ifdef ROM_PSS_disableHighSide
S#define MAP_PSS_disableHighSide                                               \
S        ROM_PSS_disableHighSide
X#define MAP_PSS_disableHighSide                                                       ROM_PSS_disableHighSide
N#else
N#define MAP_PSS_disableHighSide                                               \
N        PSS_disableHighSide
X#define MAP_PSS_disableHighSide                                                       PSS_disableHighSide
N#endif
N#ifdef ROM_PSS_enableLowSide
S#define MAP_PSS_enableLowSide                                                 \
S        ROM_PSS_enableLowSide
X#define MAP_PSS_enableLowSide                                                         ROM_PSS_enableLowSide
N#else
N#define MAP_PSS_enableLowSide                                                 \
N        PSS_enableLowSide
X#define MAP_PSS_enableLowSide                                                         PSS_enableLowSide
N#endif
N#ifdef ROM_PSS_disableLowSide
S#define MAP_PSS_disableLowSide                                                \
S        ROM_PSS_disableLowSide
X#define MAP_PSS_disableLowSide                                                        ROM_PSS_disableLowSide
N#else
N#define MAP_PSS_disableLowSide                                                \
N        PSS_disableLowSide
X#define MAP_PSS_disableLowSide                                                        PSS_disableLowSide
N#endif
N#ifdef ROM_PSS_setHighSidePerformanceMode
S#define MAP_PSS_setHighSidePerformanceMode                                    \
S        ROM_PSS_setHighSidePerformanceMode
X#define MAP_PSS_setHighSidePerformanceMode                                            ROM_PSS_setHighSidePerformanceMode
N#else
N#define MAP_PSS_setHighSidePerformanceMode                                    \
N        PSS_setHighSidePerformanceMode
X#define MAP_PSS_setHighSidePerformanceMode                                            PSS_setHighSidePerformanceMode
N#endif
N#ifdef ROM_PSS_getHighSidePerformanceMode
S#define MAP_PSS_getHighSidePerformanceMode                                    \
S        ROM_PSS_getHighSidePerformanceMode
X#define MAP_PSS_getHighSidePerformanceMode                                            ROM_PSS_getHighSidePerformanceMode
N#else
N#define MAP_PSS_getHighSidePerformanceMode                                    \
N        PSS_getHighSidePerformanceMode
X#define MAP_PSS_getHighSidePerformanceMode                                            PSS_getHighSidePerformanceMode
N#endif
N#ifdef ROM_PSS_setLowSidePerformanceMode
S#define MAP_PSS_setLowSidePerformanceMode                                     \
S        ROM_PSS_setLowSidePerformanceMode
X#define MAP_PSS_setLowSidePerformanceMode                                             ROM_PSS_setLowSidePerformanceMode
N#else
N#define MAP_PSS_setLowSidePerformanceMode                                     \
N        PSS_setLowSidePerformanceMode
X#define MAP_PSS_setLowSidePerformanceMode                                             PSS_setLowSidePerformanceMode
N#endif
N#ifdef ROM_PSS_getLowSidePerformanceMode
S#define MAP_PSS_getLowSidePerformanceMode                                     \
S        ROM_PSS_getLowSidePerformanceMode
X#define MAP_PSS_getLowSidePerformanceMode                                             ROM_PSS_getLowSidePerformanceMode
N#else
N#define MAP_PSS_getLowSidePerformanceMode                                     \
N        PSS_getLowSidePerformanceMode
X#define MAP_PSS_getLowSidePerformanceMode                                             PSS_getLowSidePerformanceMode
N#endif
N#ifdef ROM_PSS_enableHighSideMonitor
S#define MAP_PSS_enableHighSideMonitor                                         \
S        ROM_PSS_enableHighSideMonitor
X#define MAP_PSS_enableHighSideMonitor                                                 ROM_PSS_enableHighSideMonitor
N#else
N#define MAP_PSS_enableHighSideMonitor                                         \
N        PSS_enableHighSideMonitor
X#define MAP_PSS_enableHighSideMonitor                                                 PSS_enableHighSideMonitor
N#endif
N#ifdef ROM_PSS_disableHighSideMonitor
S#define MAP_PSS_disableHighSideMonitor                                        \
S        ROM_PSS_disableHighSideMonitor
X#define MAP_PSS_disableHighSideMonitor                                                ROM_PSS_disableHighSideMonitor
N#else
N#define MAP_PSS_disableHighSideMonitor                                        \
N        PSS_disableHighSideMonitor
X#define MAP_PSS_disableHighSideMonitor                                                PSS_disableHighSideMonitor
N#endif
N#ifdef ROM_PSS_setHighSideVoltageTrigger
S#define MAP_PSS_setHighSideVoltageTrigger                                     \
S        ROM_PSS_setHighSideVoltageTrigger
X#define MAP_PSS_setHighSideVoltageTrigger                                             ROM_PSS_setHighSideVoltageTrigger
N#else
N#define MAP_PSS_setHighSideVoltageTrigger                                     \
N        PSS_setHighSideVoltageTrigger
X#define MAP_PSS_setHighSideVoltageTrigger                                             PSS_setHighSideVoltageTrigger
N#endif
N#ifdef ROM_PSS_getHighSideVoltageTrigger
S#define MAP_PSS_getHighSideVoltageTrigger                                     \
S        ROM_PSS_getHighSideVoltageTrigger
X#define MAP_PSS_getHighSideVoltageTrigger                                             ROM_PSS_getHighSideVoltageTrigger
N#else
N#define MAP_PSS_getHighSideVoltageTrigger                                     \
N        PSS_getHighSideVoltageTrigger
X#define MAP_PSS_getHighSideVoltageTrigger                                             PSS_getHighSideVoltageTrigger
N#endif
N#ifdef ROM_PSS_enableInterrupt
S#define MAP_PSS_enableInterrupt                                               \
S        ROM_PSS_enableInterrupt
X#define MAP_PSS_enableInterrupt                                                       ROM_PSS_enableInterrupt
N#else
N#define MAP_PSS_enableInterrupt                                               \
N        PSS_enableInterrupt
X#define MAP_PSS_enableInterrupt                                                       PSS_enableInterrupt
N#endif
N#ifdef ROM_PSS_disableInterrupt
S#define MAP_PSS_disableInterrupt                                              \
S        ROM_PSS_disableInterrupt
X#define MAP_PSS_disableInterrupt                                                      ROM_PSS_disableInterrupt
N#else
N#define MAP_PSS_disableInterrupt                                              \
N        PSS_disableInterrupt
X#define MAP_PSS_disableInterrupt                                                      PSS_disableInterrupt
N#endif
N#ifdef ROM_PSS_getInterruptStatus
S#define MAP_PSS_getInterruptStatus                                            \
S        ROM_PSS_getInterruptStatus
X#define MAP_PSS_getInterruptStatus                                                    ROM_PSS_getInterruptStatus
N#else
N#define MAP_PSS_getInterruptStatus                                            \
N        PSS_getInterruptStatus
X#define MAP_PSS_getInterruptStatus                                                    PSS_getInterruptStatus
N#endif
N#ifdef ROM_PSS_clearInterruptFlag
S#define MAP_PSS_clearInterruptFlag                                            \
S        ROM_PSS_clearInterruptFlag
X#define MAP_PSS_clearInterruptFlag                                                    ROM_PSS_clearInterruptFlag
N#else
N#define MAP_PSS_clearInterruptFlag                                            \
N        PSS_clearInterruptFlag
X#define MAP_PSS_clearInterruptFlag                                                    PSS_clearInterruptFlag
N#endif
N#ifdef ROM_PSS_registerInterrupt
S#define MAP_PSS_registerInterrupt                                             \
S        ROM_PSS_registerInterrupt
X#define MAP_PSS_registerInterrupt                                                     ROM_PSS_registerInterrupt
N#else
N#define MAP_PSS_registerInterrupt                                             \
N        PSS_registerInterrupt
X#define MAP_PSS_registerInterrupt                                                     PSS_registerInterrupt
N#endif
N#ifdef ROM_PSS_unregisterInterrupt
S#define MAP_PSS_unregisterInterrupt                                           \
S        ROM_PSS_unregisterInterrupt
X#define MAP_PSS_unregisterInterrupt                                                   ROM_PSS_unregisterInterrupt
N#else
N#define MAP_PSS_unregisterInterrupt                                           \
N        PSS_unregisterInterrupt
X#define MAP_PSS_unregisterInterrupt                                                   PSS_unregisterInterrupt
N#endif
N#ifdef ROM_PSS_enableForcedDCDCOperation
S#define MAP_PSS_enableForcedDCDCOperation                                     \
S        ROM_PSS_enableForcedDCDCOperation
X#define MAP_PSS_enableForcedDCDCOperation                                             ROM_PSS_enableForcedDCDCOperation
N#else
N#define MAP_PSS_enableForcedDCDCOperation                                     \
N        PSS_enableForcedDCDCOperation
X#define MAP_PSS_enableForcedDCDCOperation                                             PSS_enableForcedDCDCOperation
N#endif
N#ifdef ROM_PSS_disableForcedDCDCOperation
S#define MAP_PSS_disableForcedDCDCOperation                                    \
S        ROM_PSS_disableForcedDCDCOperation
X#define MAP_PSS_disableForcedDCDCOperation                                            ROM_PSS_disableForcedDCDCOperation
N#else
N#define MAP_PSS_disableForcedDCDCOperation                                    \
N        PSS_disableForcedDCDCOperation
X#define MAP_PSS_disableForcedDCDCOperation                                            PSS_disableForcedDCDCOperation
N#endif
N
N//*****************************************************************************
N//
N// Macros for the Ref API.
N//
N//*****************************************************************************
N#ifdef ROM_REF_A_setReferenceVoltage
S#define MAP_REF_A_setReferenceVoltage                                         \
S        ROM_REF_A_setReferenceVoltage
X#define MAP_REF_A_setReferenceVoltage                                                 ROM_REF_A_setReferenceVoltage
N#else
N#define MAP_REF_A_setReferenceVoltage                                         \
N        REF_A_setReferenceVoltage
X#define MAP_REF_A_setReferenceVoltage                                                 REF_A_setReferenceVoltage
N#endif
N#ifdef ROM_REF_A_disableTempSensor
S#define MAP_REF_A_disableTempSensor                                           \
S        ROM_REF_A_disableTempSensor
X#define MAP_REF_A_disableTempSensor                                                   ROM_REF_A_disableTempSensor
N#else
N#define MAP_REF_A_disableTempSensor                                           \
N        REF_A_disableTempSensor
X#define MAP_REF_A_disableTempSensor                                                   REF_A_disableTempSensor
N#endif
N#ifdef ROM_REF_A_enableTempSensor
S#define MAP_REF_A_enableTempSensor                                            \
S        ROM_REF_A_enableTempSensor
X#define MAP_REF_A_enableTempSensor                                                    ROM_REF_A_enableTempSensor
N#else
N#define MAP_REF_A_enableTempSensor                                            \
N        REF_A_enableTempSensor
X#define MAP_REF_A_enableTempSensor                                                    REF_A_enableTempSensor
N#endif
N#ifdef ROM_REF_A_enableReferenceVoltageOutput
S#define MAP_REF_A_enableReferenceVoltageOutput                                \
S        ROM_REF_A_enableReferenceVoltageOutput
X#define MAP_REF_A_enableReferenceVoltageOutput                                        ROM_REF_A_enableReferenceVoltageOutput
N#else
N#define MAP_REF_A_enableReferenceVoltageOutput                                \
N        REF_A_enableReferenceVoltageOutput
X#define MAP_REF_A_enableReferenceVoltageOutput                                        REF_A_enableReferenceVoltageOutput
N#endif
N#ifdef ROM_REF_A_disableReferenceVoltageOutput
S#define MAP_REF_A_disableReferenceVoltageOutput                               \
S        ROM_REF_A_disableReferenceVoltageOutput
X#define MAP_REF_A_disableReferenceVoltageOutput                                       ROM_REF_A_disableReferenceVoltageOutput
N#else
N#define MAP_REF_A_disableReferenceVoltageOutput                               \
N        REF_A_disableReferenceVoltageOutput
X#define MAP_REF_A_disableReferenceVoltageOutput                                       REF_A_disableReferenceVoltageOutput
N#endif
N#ifdef ROM_REF_A_enableReferenceVoltage
S#define MAP_REF_A_enableReferenceVoltage                                      \
S        ROM_REF_A_enableReferenceVoltage
X#define MAP_REF_A_enableReferenceVoltage                                              ROM_REF_A_enableReferenceVoltage
N#else
N#define MAP_REF_A_enableReferenceVoltage                                      \
N        REF_A_enableReferenceVoltage
X#define MAP_REF_A_enableReferenceVoltage                                              REF_A_enableReferenceVoltage
N#endif
N#ifdef ROM_REF_A_disableReferenceVoltage
S#define MAP_REF_A_disableReferenceVoltage                                     \
S        ROM_REF_A_disableReferenceVoltage
X#define MAP_REF_A_disableReferenceVoltage                                             ROM_REF_A_disableReferenceVoltage
N#else
N#define MAP_REF_A_disableReferenceVoltage                                     \
N        REF_A_disableReferenceVoltage
X#define MAP_REF_A_disableReferenceVoltage                                             REF_A_disableReferenceVoltage
N#endif
N#ifdef ROM_REF_A_getBandgapMode
S#define MAP_REF_A_getBandgapMode                                              \
S        ROM_REF_A_getBandgapMode
X#define MAP_REF_A_getBandgapMode                                                      ROM_REF_A_getBandgapMode
N#else
N#define MAP_REF_A_getBandgapMode                                              \
N        REF_A_getBandgapMode
X#define MAP_REF_A_getBandgapMode                                                      REF_A_getBandgapMode
N#endif
N#ifdef ROM_REF_A_isBandgapActive
S#define MAP_REF_A_isBandgapActive                                             \
S        ROM_REF_A_isBandgapActive
X#define MAP_REF_A_isBandgapActive                                                     ROM_REF_A_isBandgapActive
N#else
N#define MAP_REF_A_isBandgapActive                                             \
N        REF_A_isBandgapActive
X#define MAP_REF_A_isBandgapActive                                                     REF_A_isBandgapActive
N#endif
N#ifdef ROM_REF_A_isRefGenBusy
S#define MAP_REF_A_isRefGenBusy                                                \
S        ROM_REF_A_isRefGenBusy
X#define MAP_REF_A_isRefGenBusy                                                        ROM_REF_A_isRefGenBusy
N#else
N#define MAP_REF_A_isRefGenBusy                                                \
N        REF_A_isRefGenBusy
X#define MAP_REF_A_isRefGenBusy                                                        REF_A_isRefGenBusy
N#endif
N#ifdef ROM_REF_A_isRefGenActive
S#define MAP_REF_A_isRefGenActive                                              \
S        ROM_REF_A_isRefGenActive
X#define MAP_REF_A_isRefGenActive                                                      ROM_REF_A_isRefGenActive
N#else
N#define MAP_REF_A_isRefGenActive                                              \
N        REF_A_isRefGenActive
X#define MAP_REF_A_isRefGenActive                                                      REF_A_isRefGenActive
N#endif
N#ifdef ROM_REF_A_getBufferedBandgapVoltageStatus
S#define MAP_REF_A_getBufferedBandgapVoltageStatus                             \
S        ROM_REF_A_getBufferedBandgapVoltageStatus
X#define MAP_REF_A_getBufferedBandgapVoltageStatus                                     ROM_REF_A_getBufferedBandgapVoltageStatus
N#else
N#define MAP_REF_A_getBufferedBandgapVoltageStatus                             \
N        REF_A_getBufferedBandgapVoltageStatus
X#define MAP_REF_A_getBufferedBandgapVoltageStatus                                     REF_A_getBufferedBandgapVoltageStatus
N#endif
N#ifdef ROM_REF_A_getVariableReferenceVoltageStatus
S#define MAP_REF_A_getVariableReferenceVoltageStatus                           \
S        ROM_REF_A_getVariableReferenceVoltageStatus
X#define MAP_REF_A_getVariableReferenceVoltageStatus                                   ROM_REF_A_getVariableReferenceVoltageStatus
N#else
N#define MAP_REF_A_getVariableReferenceVoltageStatus                           \
N        REF_A_getVariableReferenceVoltageStatus
X#define MAP_REF_A_getVariableReferenceVoltageStatus                                   REF_A_getVariableReferenceVoltageStatus
N#endif
N#ifdef ROM_REF_A_setReferenceVoltageOneTimeTrigger
S#define MAP_REF_A_setReferenceVoltageOneTimeTrigger                           \
S        ROM_REF_A_setReferenceVoltageOneTimeTrigger
X#define MAP_REF_A_setReferenceVoltageOneTimeTrigger                                   ROM_REF_A_setReferenceVoltageOneTimeTrigger
N#else
N#define MAP_REF_A_setReferenceVoltageOneTimeTrigger                           \
N        REF_A_setReferenceVoltageOneTimeTrigger
X#define MAP_REF_A_setReferenceVoltageOneTimeTrigger                                   REF_A_setReferenceVoltageOneTimeTrigger
N#endif
N#ifdef ROM_REF_A_setBufferedBandgapVoltageOneTimeTrigger
S#define MAP_REF_A_setBufferedBandgapVoltageOneTimeTrigger                     \
S        ROM_REF_A_setBufferedBandgapVoltageOneTimeTrigger
X#define MAP_REF_A_setBufferedBandgapVoltageOneTimeTrigger                             ROM_REF_A_setBufferedBandgapVoltageOneTimeTrigger
N#else
N#define MAP_REF_A_setBufferedBandgapVoltageOneTimeTrigger                     \
N        REF_A_setBufferedBandgapVoltageOneTimeTrigger
X#define MAP_REF_A_setBufferedBandgapVoltageOneTimeTrigger                             REF_A_setBufferedBandgapVoltageOneTimeTrigger
N#endif
N
N//*****************************************************************************
N//
N// Macros for the ResetCtl API.
N//
N//*****************************************************************************
N#ifdef ROM_ResetCtl_initiateSoftReset
S#define MAP_ResetCtl_initiateSoftReset                                        \
S        ROM_ResetCtl_initiateSoftReset
X#define MAP_ResetCtl_initiateSoftReset                                                ROM_ResetCtl_initiateSoftReset
N#else
N#define MAP_ResetCtl_initiateSoftReset                                        \
N        ResetCtl_initiateSoftReset
X#define MAP_ResetCtl_initiateSoftReset                                                ResetCtl_initiateSoftReset
N#endif
N#ifdef ROM_ResetCtl_initiateSoftResetWithSource
S#define MAP_ResetCtl_initiateSoftResetWithSource                              \
S        ROM_ResetCtl_initiateSoftResetWithSource
X#define MAP_ResetCtl_initiateSoftResetWithSource                                      ROM_ResetCtl_initiateSoftResetWithSource
N#else
N#define MAP_ResetCtl_initiateSoftResetWithSource                              \
N        ResetCtl_initiateSoftResetWithSource
X#define MAP_ResetCtl_initiateSoftResetWithSource                                      ResetCtl_initiateSoftResetWithSource
N#endif
N#ifdef ROM_ResetCtl_getSoftResetSource
S#define MAP_ResetCtl_getSoftResetSource                                       \
S        ROM_ResetCtl_getSoftResetSource
X#define MAP_ResetCtl_getSoftResetSource                                               ROM_ResetCtl_getSoftResetSource
N#else
N#define MAP_ResetCtl_getSoftResetSource                                       \
N        ResetCtl_getSoftResetSource
X#define MAP_ResetCtl_getSoftResetSource                                               ResetCtl_getSoftResetSource
N#endif
N#ifdef ROM_ResetCtl_clearSoftResetSource
S#define MAP_ResetCtl_clearSoftResetSource                                     \
S        ROM_ResetCtl_clearSoftResetSource
X#define MAP_ResetCtl_clearSoftResetSource                                             ROM_ResetCtl_clearSoftResetSource
N#else
N#define MAP_ResetCtl_clearSoftResetSource                                     \
N        ResetCtl_clearSoftResetSource
X#define MAP_ResetCtl_clearSoftResetSource                                             ResetCtl_clearSoftResetSource
N#endif
N#ifdef ROM_ResetCtl_initiateHardReset
S#define MAP_ResetCtl_initiateHardReset                                        \
S        ROM_ResetCtl_initiateHardReset
X#define MAP_ResetCtl_initiateHardReset                                                ROM_ResetCtl_initiateHardReset
N#else
N#define MAP_ResetCtl_initiateHardReset                                        \
N        ResetCtl_initiateHardReset
X#define MAP_ResetCtl_initiateHardReset                                                ResetCtl_initiateHardReset
N#endif
N#ifdef ROM_ResetCtl_initiateHardResetWithSource
S#define MAP_ResetCtl_initiateHardResetWithSource                              \
S        ROM_ResetCtl_initiateHardResetWithSource
X#define MAP_ResetCtl_initiateHardResetWithSource                                      ROM_ResetCtl_initiateHardResetWithSource
N#else
N#define MAP_ResetCtl_initiateHardResetWithSource                              \
N        ResetCtl_initiateHardResetWithSource
X#define MAP_ResetCtl_initiateHardResetWithSource                                      ResetCtl_initiateHardResetWithSource
N#endif
N#ifdef ROM_ResetCtl_getHardResetSource
S#define MAP_ResetCtl_getHardResetSource                                       \
S        ROM_ResetCtl_getHardResetSource
X#define MAP_ResetCtl_getHardResetSource                                               ROM_ResetCtl_getHardResetSource
N#else
N#define MAP_ResetCtl_getHardResetSource                                       \
N        ResetCtl_getHardResetSource
X#define MAP_ResetCtl_getHardResetSource                                               ResetCtl_getHardResetSource
N#endif
N#ifdef ROM_ResetCtl_clearHardResetSource
S#define MAP_ResetCtl_clearHardResetSource                                     \
S        ROM_ResetCtl_clearHardResetSource
X#define MAP_ResetCtl_clearHardResetSource                                             ROM_ResetCtl_clearHardResetSource
N#else
N#define MAP_ResetCtl_clearHardResetSource                                     \
N        ResetCtl_clearHardResetSource
X#define MAP_ResetCtl_clearHardResetSource                                             ResetCtl_clearHardResetSource
N#endif
N#ifdef ROM_ResetCtl_getPSSSource
S#define MAP_ResetCtl_getPSSSource                                             \
S        ROM_ResetCtl_getPSSSource
X#define MAP_ResetCtl_getPSSSource                                                     ROM_ResetCtl_getPSSSource
N#else
N#define MAP_ResetCtl_getPSSSource                                             \
N        ResetCtl_getPSSSource
X#define MAP_ResetCtl_getPSSSource                                                     ResetCtl_getPSSSource
N#endif
N#ifdef ROM_ResetCtl_clearPSSFlags
S#define MAP_ResetCtl_clearPSSFlags                                            \
S        ROM_ResetCtl_clearPSSFlags
X#define MAP_ResetCtl_clearPSSFlags                                                    ROM_ResetCtl_clearPSSFlags
N#else
N#define MAP_ResetCtl_clearPSSFlags                                            \
N        ResetCtl_clearPSSFlags
X#define MAP_ResetCtl_clearPSSFlags                                                    ResetCtl_clearPSSFlags
N#endif
N#ifdef ROM_ResetCtl_getPCMSource
S#define MAP_ResetCtl_getPCMSource                                             \
S        ROM_ResetCtl_getPCMSource
X#define MAP_ResetCtl_getPCMSource                                                     ROM_ResetCtl_getPCMSource
N#else
N#define MAP_ResetCtl_getPCMSource                                             \
N        ResetCtl_getPCMSource
X#define MAP_ResetCtl_getPCMSource                                                     ResetCtl_getPCMSource
N#endif
N#ifdef ROM_ResetCtl_clearPCMFlags
S#define MAP_ResetCtl_clearPCMFlags                                            \
S        ROM_ResetCtl_clearPCMFlags
X#define MAP_ResetCtl_clearPCMFlags                                                    ROM_ResetCtl_clearPCMFlags
N#else
N#define MAP_ResetCtl_clearPCMFlags                                            \
N        ResetCtl_clearPCMFlags
X#define MAP_ResetCtl_clearPCMFlags                                                    ResetCtl_clearPCMFlags
N#endif
N
N//*****************************************************************************
N//
N// Macros for the RTC API.
N//
N//*****************************************************************************
N#ifdef ROM_RTC_C_startClock
S#define MAP_RTC_C_startClock                                                  \
S        ROM_RTC_C_startClock
X#define MAP_RTC_C_startClock                                                          ROM_RTC_C_startClock
N#else
N#define MAP_RTC_C_startClock                                                  \
N        RTC_C_startClock
X#define MAP_RTC_C_startClock                                                          RTC_C_startClock
N#endif
N#ifdef ROM_RTC_C_holdClock
S#define MAP_RTC_C_holdClock                                                   \
S        ROM_RTC_C_holdClock
X#define MAP_RTC_C_holdClock                                                           ROM_RTC_C_holdClock
N#else
N#define MAP_RTC_C_holdClock                                                   \
N        RTC_C_holdClock
X#define MAP_RTC_C_holdClock                                                           RTC_C_holdClock
N#endif
N#ifdef ROM_RTC_C_setCalibrationFrequency
S#define MAP_RTC_C_setCalibrationFrequency                                     \
S        ROM_RTC_C_setCalibrationFrequency
X#define MAP_RTC_C_setCalibrationFrequency                                             ROM_RTC_C_setCalibrationFrequency
N#else
N#define MAP_RTC_C_setCalibrationFrequency                                     \
N        RTC_C_setCalibrationFrequency
X#define MAP_RTC_C_setCalibrationFrequency                                             RTC_C_setCalibrationFrequency
N#endif
N#ifdef ROM_RTC_C_setCalibrationData
S#define MAP_RTC_C_setCalibrationData                                          \
S        ROM_RTC_C_setCalibrationData
X#define MAP_RTC_C_setCalibrationData                                                  ROM_RTC_C_setCalibrationData
N#else
N#define MAP_RTC_C_setCalibrationData                                          \
N        RTC_C_setCalibrationData
X#define MAP_RTC_C_setCalibrationData                                                  RTC_C_setCalibrationData
N#endif
N#ifdef ROM_RTC_C_setTemperatureCompensation
S#define MAP_RTC_C_setTemperatureCompensation                                  \
S        ROM_RTC_C_setTemperatureCompensation
X#define MAP_RTC_C_setTemperatureCompensation                                          ROM_RTC_C_setTemperatureCompensation
N#else
N#define MAP_RTC_C_setTemperatureCompensation                                  \
N        RTC_C_setTemperatureCompensation
X#define MAP_RTC_C_setTemperatureCompensation                                          RTC_C_setTemperatureCompensation
N#endif
N#ifdef ROM_RTC_C_initCalendar
S#define MAP_RTC_C_initCalendar                                                \
S        ROM_RTC_C_initCalendar
X#define MAP_RTC_C_initCalendar                                                        ROM_RTC_C_initCalendar
N#else
N#define MAP_RTC_C_initCalendar                                                \
N        RTC_C_initCalendar
X#define MAP_RTC_C_initCalendar                                                        RTC_C_initCalendar
N#endif
N#ifdef ROM_RTC_C_getCalendarTime
S#define MAP_RTC_C_getCalendarTime                                             \
S        ROM_RTC_C_getCalendarTime
X#define MAP_RTC_C_getCalendarTime                                                     ROM_RTC_C_getCalendarTime
N#else
N#define MAP_RTC_C_getCalendarTime                                             \
N        RTC_C_getCalendarTime
X#define MAP_RTC_C_getCalendarTime                                                     RTC_C_getCalendarTime
N#endif
N#ifdef ROM_RTC_C_setCalendarAlarm
S#define MAP_RTC_C_setCalendarAlarm                                            \
S        ROM_RTC_C_setCalendarAlarm
X#define MAP_RTC_C_setCalendarAlarm                                                    ROM_RTC_C_setCalendarAlarm
N#else
N#define MAP_RTC_C_setCalendarAlarm                                            \
N        RTC_C_setCalendarAlarm
X#define MAP_RTC_C_setCalendarAlarm                                                    RTC_C_setCalendarAlarm
N#endif
N#ifdef ROM_RTC_C_setCalendarEvent
S#define MAP_RTC_C_setCalendarEvent                                            \
S        ROM_RTC_C_setCalendarEvent
X#define MAP_RTC_C_setCalendarEvent                                                    ROM_RTC_C_setCalendarEvent
N#else
N#define MAP_RTC_C_setCalendarEvent                                            \
N        RTC_C_setCalendarEvent
X#define MAP_RTC_C_setCalendarEvent                                                    RTC_C_setCalendarEvent
N#endif
N#ifdef ROM_RTC_C_definePrescaleEvent
S#define MAP_RTC_C_definePrescaleEvent                                         \
S        ROM_RTC_C_definePrescaleEvent
X#define MAP_RTC_C_definePrescaleEvent                                                 ROM_RTC_C_definePrescaleEvent
N#else
N#define MAP_RTC_C_definePrescaleEvent                                         \
N        RTC_C_definePrescaleEvent
X#define MAP_RTC_C_definePrescaleEvent                                                 RTC_C_definePrescaleEvent
N#endif
N#ifdef ROM_RTC_C_getPrescaleValue
S#define MAP_RTC_C_getPrescaleValue                                            \
S        ROM_RTC_C_getPrescaleValue
X#define MAP_RTC_C_getPrescaleValue                                                    ROM_RTC_C_getPrescaleValue
N#else
N#define MAP_RTC_C_getPrescaleValue                                            \
N        RTC_C_getPrescaleValue
X#define MAP_RTC_C_getPrescaleValue                                                    RTC_C_getPrescaleValue
N#endif
N#ifdef ROM_RTC_C_setPrescaleValue
S#define MAP_RTC_C_setPrescaleValue                                            \
S        ROM_RTC_C_setPrescaleValue
X#define MAP_RTC_C_setPrescaleValue                                                    ROM_RTC_C_setPrescaleValue
N#else
N#define MAP_RTC_C_setPrescaleValue                                            \
N        RTC_C_setPrescaleValue
X#define MAP_RTC_C_setPrescaleValue                                                    RTC_C_setPrescaleValue
N#endif
N#ifdef ROM_RTC_C_convertBCDToBinary
S#define MAP_RTC_C_convertBCDToBinary                                          \
S        ROM_RTC_C_convertBCDToBinary
X#define MAP_RTC_C_convertBCDToBinary                                                  ROM_RTC_C_convertBCDToBinary
N#else
N#define MAP_RTC_C_convertBCDToBinary                                          \
N        RTC_C_convertBCDToBinary
X#define MAP_RTC_C_convertBCDToBinary                                                  RTC_C_convertBCDToBinary
N#endif
N#ifdef ROM_RTC_C_convertBinaryToBCD
S#define MAP_RTC_C_convertBinaryToBCD                                          \
S        ROM_RTC_C_convertBinaryToBCD
X#define MAP_RTC_C_convertBinaryToBCD                                                  ROM_RTC_C_convertBinaryToBCD
N#else
N#define MAP_RTC_C_convertBinaryToBCD                                          \
N        RTC_C_convertBinaryToBCD
X#define MAP_RTC_C_convertBinaryToBCD                                                  RTC_C_convertBinaryToBCD
N#endif
N#ifdef ROM_RTC_C_enableInterrupt
S#define MAP_RTC_C_enableInterrupt                                             \
S        ROM_RTC_C_enableInterrupt
X#define MAP_RTC_C_enableInterrupt                                                     ROM_RTC_C_enableInterrupt
N#else
N#define MAP_RTC_C_enableInterrupt                                             \
N        RTC_C_enableInterrupt
X#define MAP_RTC_C_enableInterrupt                                                     RTC_C_enableInterrupt
N#endif
N#ifdef ROM_RTC_C_disableInterrupt
S#define MAP_RTC_C_disableInterrupt                                            \
S        ROM_RTC_C_disableInterrupt
X#define MAP_RTC_C_disableInterrupt                                                    ROM_RTC_C_disableInterrupt
N#else
N#define MAP_RTC_C_disableInterrupt                                            \
N        RTC_C_disableInterrupt
X#define MAP_RTC_C_disableInterrupt                                                    RTC_C_disableInterrupt
N#endif
N#ifdef ROM_RTC_C_getInterruptStatus
S#define MAP_RTC_C_getInterruptStatus                                          \
S        ROM_RTC_C_getInterruptStatus
X#define MAP_RTC_C_getInterruptStatus                                                  ROM_RTC_C_getInterruptStatus
N#else
N#define MAP_RTC_C_getInterruptStatus                                          \
N        RTC_C_getInterruptStatus
X#define MAP_RTC_C_getInterruptStatus                                                  RTC_C_getInterruptStatus
N#endif
N#ifdef ROM_RTC_C_getEnabledInterruptStatus
S#define MAP_RTC_C_getEnabledInterruptStatus                                   \
S        ROM_RTC_C_getEnabledInterruptStatus
X#define MAP_RTC_C_getEnabledInterruptStatus                                           ROM_RTC_C_getEnabledInterruptStatus
N#else
N#define MAP_RTC_C_getEnabledInterruptStatus                                   \
N        RTC_C_getEnabledInterruptStatus
X#define MAP_RTC_C_getEnabledInterruptStatus                                           RTC_C_getEnabledInterruptStatus
N#endif
N#ifdef ROM_RTC_C_clearInterruptFlag
S#define MAP_RTC_C_clearInterruptFlag                                          \
S        ROM_RTC_C_clearInterruptFlag
X#define MAP_RTC_C_clearInterruptFlag                                                  ROM_RTC_C_clearInterruptFlag
N#else
N#define MAP_RTC_C_clearInterruptFlag                                          \
N        RTC_C_clearInterruptFlag
X#define MAP_RTC_C_clearInterruptFlag                                                  RTC_C_clearInterruptFlag
N#endif
N#ifdef ROM_RTC_C_registerInterrupt
S#define MAP_RTC_C_registerInterrupt                                           \
S        ROM_RTC_C_registerInterrupt
X#define MAP_RTC_C_registerInterrupt                                                   ROM_RTC_C_registerInterrupt
N#else
N#define MAP_RTC_C_registerInterrupt                                           \
N        RTC_C_registerInterrupt
X#define MAP_RTC_C_registerInterrupt                                                   RTC_C_registerInterrupt
N#endif
N#ifdef ROM_RTC_C_unregisterInterrupt
S#define MAP_RTC_C_unregisterInterrupt                                         \
S        ROM_RTC_C_unregisterInterrupt
X#define MAP_RTC_C_unregisterInterrupt                                                 ROM_RTC_C_unregisterInterrupt
N#else
N#define MAP_RTC_C_unregisterInterrupt                                         \
N        RTC_C_unregisterInterrupt
X#define MAP_RTC_C_unregisterInterrupt                                                 RTC_C_unregisterInterrupt
N#endif
N
N//*****************************************************************************
N//
N// Macros for the SPI API.
N//
N//*****************************************************************************
N#ifdef ROM_SPI_initMaster
S#define MAP_SPI_initMaster                                                    \
S        ROM_SPI_initMaster
X#define MAP_SPI_initMaster                                                            ROM_SPI_initMaster
N#else
N#define MAP_SPI_initMaster                                                    \
N        SPI_initMaster
X#define MAP_SPI_initMaster                                                            SPI_initMaster
N#endif
N#ifdef ROM_SPI_selectFourPinFunctionality
S#define MAP_SPI_selectFourPinFunctionality                                    \
S        ROM_SPI_selectFourPinFunctionality
X#define MAP_SPI_selectFourPinFunctionality                                            ROM_SPI_selectFourPinFunctionality
N#else
N#define MAP_SPI_selectFourPinFunctionality                                    \
N        SPI_selectFourPinFunctionality
X#define MAP_SPI_selectFourPinFunctionality                                            SPI_selectFourPinFunctionality
N#endif
N#ifdef ROM_SPI_changeMasterClock
S#define MAP_SPI_changeMasterClock                                             \
S        ROM_SPI_changeMasterClock
X#define MAP_SPI_changeMasterClock                                                     ROM_SPI_changeMasterClock
N#else
N#define MAP_SPI_changeMasterClock                                             \
N        SPI_changeMasterClock
X#define MAP_SPI_changeMasterClock                                                     SPI_changeMasterClock
N#endif
N#ifdef ROM_SPI_initSlave
S#define MAP_SPI_initSlave                                                     \
S        ROM_SPI_initSlave
X#define MAP_SPI_initSlave                                                             ROM_SPI_initSlave
N#else
N#define MAP_SPI_initSlave                                                     \
N        SPI_initSlave
X#define MAP_SPI_initSlave                                                             SPI_initSlave
N#endif
N#ifdef ROM_SPI_changeClockPhasePolarity
S#define MAP_SPI_changeClockPhasePolarity                                      \
S        ROM_SPI_changeClockPhasePolarity
X#define MAP_SPI_changeClockPhasePolarity                                              ROM_SPI_changeClockPhasePolarity
N#else
N#define MAP_SPI_changeClockPhasePolarity                                      \
N        SPI_changeClockPhasePolarity
X#define MAP_SPI_changeClockPhasePolarity                                              SPI_changeClockPhasePolarity
N#endif
N#ifdef ROM_SPI_transmitData
S#define MAP_SPI_transmitData                                                  \
S        ROM_SPI_transmitData
X#define MAP_SPI_transmitData                                                          ROM_SPI_transmitData
N#else
N#define MAP_SPI_transmitData                                                  \
N        SPI_transmitData
X#define MAP_SPI_transmitData                                                          SPI_transmitData
N#endif
N#ifdef ROM_SPI_receiveData
S#define MAP_SPI_receiveData                                                   \
S        ROM_SPI_receiveData
X#define MAP_SPI_receiveData                                                           ROM_SPI_receiveData
N#else
N#define MAP_SPI_receiveData                                                   \
N        SPI_receiveData
X#define MAP_SPI_receiveData                                                           SPI_receiveData
N#endif
N#ifdef ROM_SPI_enableModule
S#define MAP_SPI_enableModule                                                  \
S        ROM_SPI_enableModule
X#define MAP_SPI_enableModule                                                          ROM_SPI_enableModule
N#else
N#define MAP_SPI_enableModule                                                  \
N        SPI_enableModule
X#define MAP_SPI_enableModule                                                          SPI_enableModule
N#endif
N#ifdef ROM_SPI_disableModule
S#define MAP_SPI_disableModule                                                 \
S        ROM_SPI_disableModule
X#define MAP_SPI_disableModule                                                         ROM_SPI_disableModule
N#else
N#define MAP_SPI_disableModule                                                 \
N        SPI_disableModule
X#define MAP_SPI_disableModule                                                         SPI_disableModule
N#endif
N#ifdef ROM_SPI_getReceiveBufferAddressForDMA
S#define MAP_SPI_getReceiveBufferAddressForDMA                                 \
S        ROM_SPI_getReceiveBufferAddressForDMA
X#define MAP_SPI_getReceiveBufferAddressForDMA                                         ROM_SPI_getReceiveBufferAddressForDMA
N#else
N#define MAP_SPI_getReceiveBufferAddressForDMA                                 \
N        SPI_getReceiveBufferAddressForDMA
X#define MAP_SPI_getReceiveBufferAddressForDMA                                         SPI_getReceiveBufferAddressForDMA
N#endif
N#ifdef ROM_SPI_getTransmitBufferAddressForDMA
S#define MAP_SPI_getTransmitBufferAddressForDMA                                \
S        ROM_SPI_getTransmitBufferAddressForDMA
X#define MAP_SPI_getTransmitBufferAddressForDMA                                        ROM_SPI_getTransmitBufferAddressForDMA
N#else
N#define MAP_SPI_getTransmitBufferAddressForDMA                                \
N        SPI_getTransmitBufferAddressForDMA
X#define MAP_SPI_getTransmitBufferAddressForDMA                                        SPI_getTransmitBufferAddressForDMA
N#endif
N#ifdef ROM_SPI_isBusy
S#define MAP_SPI_isBusy                                                        \
S        ROM_SPI_isBusy
X#define MAP_SPI_isBusy                                                                ROM_SPI_isBusy
N#else
N#define MAP_SPI_isBusy                                                        \
N        SPI_isBusy
X#define MAP_SPI_isBusy                                                                SPI_isBusy
N#endif
N#ifdef ROM_SPI_enableInterrupt
S#define MAP_SPI_enableInterrupt                                               \
S        ROM_SPI_enableInterrupt
X#define MAP_SPI_enableInterrupt                                                       ROM_SPI_enableInterrupt
N#else
N#define MAP_SPI_enableInterrupt                                               \
N        SPI_enableInterrupt
X#define MAP_SPI_enableInterrupt                                                       SPI_enableInterrupt
N#endif
N#ifdef ROM_SPI_disableInterrupt
S#define MAP_SPI_disableInterrupt                                              \
S        ROM_SPI_disableInterrupt
X#define MAP_SPI_disableInterrupt                                                      ROM_SPI_disableInterrupt
N#else
N#define MAP_SPI_disableInterrupt                                              \
N        SPI_disableInterrupt
X#define MAP_SPI_disableInterrupt                                                      SPI_disableInterrupt
N#endif
N#ifdef ROM_SPI_getInterruptStatus
S#define MAP_SPI_getInterruptStatus                                            \
S        ROM_SPI_getInterruptStatus
X#define MAP_SPI_getInterruptStatus                                                    ROM_SPI_getInterruptStatus
N#else
N#define MAP_SPI_getInterruptStatus                                            \
N        SPI_getInterruptStatus
X#define MAP_SPI_getInterruptStatus                                                    SPI_getInterruptStatus
N#endif
N#ifdef ROM_SPI_getEnabledInterruptStatus
S#define MAP_SPI_getEnabledInterruptStatus                                     \
S        ROM_SPI_getEnabledInterruptStatus
X#define MAP_SPI_getEnabledInterruptStatus                                             ROM_SPI_getEnabledInterruptStatus
N#else
N#define MAP_SPI_getEnabledInterruptStatus                                     \
N        SPI_getEnabledInterruptStatus
X#define MAP_SPI_getEnabledInterruptStatus                                             SPI_getEnabledInterruptStatus
N#endif
N#ifdef ROM_SPI_clearInterruptFlag
S#define MAP_SPI_clearInterruptFlag                                            \
S        ROM_SPI_clearInterruptFlag
X#define MAP_SPI_clearInterruptFlag                                                    ROM_SPI_clearInterruptFlag
N#else
N#define MAP_SPI_clearInterruptFlag                                            \
N        SPI_clearInterruptFlag
X#define MAP_SPI_clearInterruptFlag                                                    SPI_clearInterruptFlag
N#endif
N#ifdef ROM_SPI_registerInterrupt
S#define MAP_SPI_registerInterrupt                                             \
S        ROM_SPI_registerInterrupt
X#define MAP_SPI_registerInterrupt                                                     ROM_SPI_registerInterrupt
N#else
N#define MAP_SPI_registerInterrupt                                             \
N        SPI_registerInterrupt
X#define MAP_SPI_registerInterrupt                                                     SPI_registerInterrupt
N#endif
N#ifdef ROM_SPI_unregisterInterrupt
S#define MAP_SPI_unregisterInterrupt                                           \
S        ROM_SPI_unregisterInterrupt
X#define MAP_SPI_unregisterInterrupt                                                   ROM_SPI_unregisterInterrupt
N#else
N#define MAP_SPI_unregisterInterrupt                                           \
N        SPI_unregisterInterrupt
X#define MAP_SPI_unregisterInterrupt                                                   SPI_unregisterInterrupt
N#endif
N
N//*****************************************************************************
N//
N// Macros for the SysCtl API.
N//
N//*****************************************************************************
N#ifdef ROM_SysCtl_getSRAMSize
S#define MAP_SysCtl_getSRAMSize                                                \
S        ROM_SysCtl_getSRAMSize
X#define MAP_SysCtl_getSRAMSize                                                        ROM_SysCtl_getSRAMSize
N#else
N#define MAP_SysCtl_getSRAMSize                                                \
N        SysCtl_getSRAMSize
X#define MAP_SysCtl_getSRAMSize                                                        SysCtl_getSRAMSize
N#endif
N#ifdef ROM_SysCtl_getFlashSize
S#define MAP_SysCtl_getFlashSize                                               \
S        ROM_SysCtl_getFlashSize
X#define MAP_SysCtl_getFlashSize                                                       ROM_SysCtl_getFlashSize
N#else
N#define MAP_SysCtl_getFlashSize                                               \
N        SysCtl_getFlashSize
X#define MAP_SysCtl_getFlashSize                                                       SysCtl_getFlashSize
N#endif
N#ifdef ROM_SysCtl_rebootDevice
S#define MAP_SysCtl_rebootDevice                                               \
S        ROM_SysCtl_rebootDevice
X#define MAP_SysCtl_rebootDevice                                                       ROM_SysCtl_rebootDevice
N#else
N#define MAP_SysCtl_rebootDevice                                               \
N        SysCtl_rebootDevice
X#define MAP_SysCtl_rebootDevice                                                       SysCtl_rebootDevice
N#endif
N#ifdef ROM_SysCtl_enableSRAMBank
S#define MAP_SysCtl_enableSRAMBank                                             \
S        ROM_SysCtl_enableSRAMBank
X#define MAP_SysCtl_enableSRAMBank                                                     ROM_SysCtl_enableSRAMBank
N#else
N#define MAP_SysCtl_enableSRAMBank                                             \
N        SysCtl_enableSRAMBank
X#define MAP_SysCtl_enableSRAMBank                                                     SysCtl_enableSRAMBank
N#endif
N#ifdef ROM_SysCtl_disableSRAMBank
S#define MAP_SysCtl_disableSRAMBank                                            \
S        ROM_SysCtl_disableSRAMBank
X#define MAP_SysCtl_disableSRAMBank                                                    ROM_SysCtl_disableSRAMBank
N#else
N#define MAP_SysCtl_disableSRAMBank                                            \
N        SysCtl_disableSRAMBank
X#define MAP_SysCtl_disableSRAMBank                                                    SysCtl_disableSRAMBank
N#endif
N#ifdef ROM_SysCtl_enableSRAMBankRetention
S#define MAP_SysCtl_enableSRAMBankRetention                                    \
S        ROM_SysCtl_enableSRAMBankRetention
X#define MAP_SysCtl_enableSRAMBankRetention                                            ROM_SysCtl_enableSRAMBankRetention
N#else
N#define MAP_SysCtl_enableSRAMBankRetention                                    \
N        SysCtl_enableSRAMBankRetention
X#define MAP_SysCtl_enableSRAMBankRetention                                            SysCtl_enableSRAMBankRetention
N#endif
N#ifdef ROM_SysCtl_disableSRAMBankRetention
S#define MAP_SysCtl_disableSRAMBankRetention                                   \
S        ROM_SysCtl_disableSRAMBankRetention
X#define MAP_SysCtl_disableSRAMBankRetention                                           ROM_SysCtl_disableSRAMBankRetention
N#else
N#define MAP_SysCtl_disableSRAMBankRetention                                   \
N        SysCtl_disableSRAMBankRetention
X#define MAP_SysCtl_disableSRAMBankRetention                                           SysCtl_disableSRAMBankRetention
N#endif
N#ifdef ROM_SysCtl_enablePeripheralAtCPUHalt
S#define MAP_SysCtl_enablePeripheralAtCPUHalt                                  \
S        ROM_SysCtl_enablePeripheralAtCPUHalt
X#define MAP_SysCtl_enablePeripheralAtCPUHalt                                          ROM_SysCtl_enablePeripheralAtCPUHalt
N#else
N#define MAP_SysCtl_enablePeripheralAtCPUHalt                                  \
N        SysCtl_enablePeripheralAtCPUHalt
X#define MAP_SysCtl_enablePeripheralAtCPUHalt                                          SysCtl_enablePeripheralAtCPUHalt
N#endif
N#ifdef ROM_SysCtl_disablePeripheralAtCPUHalt
S#define MAP_SysCtl_disablePeripheralAtCPUHalt                                 \
S        ROM_SysCtl_disablePeripheralAtCPUHalt
X#define MAP_SysCtl_disablePeripheralAtCPUHalt                                         ROM_SysCtl_disablePeripheralAtCPUHalt
N#else
N#define MAP_SysCtl_disablePeripheralAtCPUHalt                                 \
N        SysCtl_disablePeripheralAtCPUHalt
X#define MAP_SysCtl_disablePeripheralAtCPUHalt                                         SysCtl_disablePeripheralAtCPUHalt
N#endif
N#ifdef ROM_SysCtl_setWDTTimeoutResetType
S#define MAP_SysCtl_setWDTTimeoutResetType                                     \
S        ROM_SysCtl_setWDTTimeoutResetType
X#define MAP_SysCtl_setWDTTimeoutResetType                                             ROM_SysCtl_setWDTTimeoutResetType
N#else
N#define MAP_SysCtl_setWDTTimeoutResetType                                     \
N        SysCtl_setWDTTimeoutResetType
X#define MAP_SysCtl_setWDTTimeoutResetType                                             SysCtl_setWDTTimeoutResetType
N#endif
N#ifdef ROM_SysCtl_setWDTPasswordViolationResetType
S#define MAP_SysCtl_setWDTPasswordViolationResetType                           \
S        ROM_SysCtl_setWDTPasswordViolationResetType
X#define MAP_SysCtl_setWDTPasswordViolationResetType                                   ROM_SysCtl_setWDTPasswordViolationResetType
N#else
N#define MAP_SysCtl_setWDTPasswordViolationResetType                           \
N        SysCtl_setWDTPasswordViolationResetType
X#define MAP_SysCtl_setWDTPasswordViolationResetType                                   SysCtl_setWDTPasswordViolationResetType
N#endif
N#ifdef ROM_SysCtl_disableNMISource
S#define MAP_SysCtl_disableNMISource                                           \
S        ROM_SysCtl_disableNMISource
X#define MAP_SysCtl_disableNMISource                                                   ROM_SysCtl_disableNMISource
N#else
N#define MAP_SysCtl_disableNMISource                                           \
N        SysCtl_disableNMISource
X#define MAP_SysCtl_disableNMISource                                                   SysCtl_disableNMISource
N#endif
N#ifdef ROM_SysCtl_enableNMISource
S#define MAP_SysCtl_enableNMISource                                            \
S        ROM_SysCtl_enableNMISource
X#define MAP_SysCtl_enableNMISource                                                    ROM_SysCtl_enableNMISource
N#else
N#define MAP_SysCtl_enableNMISource                                            \
N        SysCtl_enableNMISource
X#define MAP_SysCtl_enableNMISource                                                    SysCtl_enableNMISource
N#endif
N#ifdef ROM_SysCtl_getNMISourceStatus
S#define MAP_SysCtl_getNMISourceStatus                                         \
S        ROM_SysCtl_getNMISourceStatus
X#define MAP_SysCtl_getNMISourceStatus                                                 ROM_SysCtl_getNMISourceStatus
N#else
N#define MAP_SysCtl_getNMISourceStatus                                         \
N        SysCtl_getNMISourceStatus
X#define MAP_SysCtl_getNMISourceStatus                                                 SysCtl_getNMISourceStatus
N#endif
N#ifdef ROM_SysCtl_getTempCalibrationConstant
S#define MAP_SysCtl_getTempCalibrationConstant                                 \
S        ROM_SysCtl_getTempCalibrationConstant
X#define MAP_SysCtl_getTempCalibrationConstant                                         ROM_SysCtl_getTempCalibrationConstant
N#else
N#define MAP_SysCtl_getTempCalibrationConstant                                 \
N        SysCtl_getTempCalibrationConstant
X#define MAP_SysCtl_getTempCalibrationConstant                                         SysCtl_getTempCalibrationConstant
N#endif
N#ifdef ROM_SysCtl_enableGlitchFilter
S#define MAP_SysCtl_enableGlitchFilter                                         \
S        ROM_SysCtl_enableGlitchFilter
X#define MAP_SysCtl_enableGlitchFilter                                                 ROM_SysCtl_enableGlitchFilter
N#else
N#define MAP_SysCtl_enableGlitchFilter                                         \
N        SysCtl_enableGlitchFilter
X#define MAP_SysCtl_enableGlitchFilter                                                 SysCtl_enableGlitchFilter
N#endif
N#ifdef ROM_SysCtl_disableGlitchFilter
S#define MAP_SysCtl_disableGlitchFilter                                        \
S        ROM_SysCtl_disableGlitchFilter
X#define MAP_SysCtl_disableGlitchFilter                                                ROM_SysCtl_disableGlitchFilter
N#else
N#define MAP_SysCtl_disableGlitchFilter                                        \
N        SysCtl_disableGlitchFilter
X#define MAP_SysCtl_disableGlitchFilter                                                SysCtl_disableGlitchFilter
N#endif
N#ifdef ROM_SysCtl_getTLVInfo
S#define MAP_SysCtl_getTLVInfo                                                 \
S        ROM_SysCtl_getTLVInfo
X#define MAP_SysCtl_getTLVInfo                                                         ROM_SysCtl_getTLVInfo
N#else
N#define MAP_SysCtl_getTLVInfo                                                 \
N        SysCtl_getTLVInfo
X#define MAP_SysCtl_getTLVInfo                                                         SysCtl_getTLVInfo
N#endif
N
N//*****************************************************************************
N//
N// Macros for the SysTick API.
N//
N//*****************************************************************************
N#ifdef ROM_SysTick_enableModule
S#define MAP_SysTick_enableModule                                              \
S        ROM_SysTick_enableModule
X#define MAP_SysTick_enableModule                                                      ROM_SysTick_enableModule
N#else
N#define MAP_SysTick_enableModule                                              \
N        SysTick_enableModule
X#define MAP_SysTick_enableModule                                                      SysTick_enableModule
N#endif
N#ifdef ROM_SysTick_disableModule
S#define MAP_SysTick_disableModule                                             \
S        ROM_SysTick_disableModule
X#define MAP_SysTick_disableModule                                                     ROM_SysTick_disableModule
N#else
N#define MAP_SysTick_disableModule                                             \
N        SysTick_disableModule
X#define MAP_SysTick_disableModule                                                     SysTick_disableModule
N#endif
N#ifdef ROM_SysTick_enableInterrupt
S#define MAP_SysTick_enableInterrupt                                           \
S        ROM_SysTick_enableInterrupt
X#define MAP_SysTick_enableInterrupt                                                   ROM_SysTick_enableInterrupt
N#else
N#define MAP_SysTick_enableInterrupt                                           \
N        SysTick_enableInterrupt
X#define MAP_SysTick_enableInterrupt                                                   SysTick_enableInterrupt
N#endif
N#ifdef ROM_SysTick_disableInterrupt
S#define MAP_SysTick_disableInterrupt                                          \
S        ROM_SysTick_disableInterrupt
X#define MAP_SysTick_disableInterrupt                                                  ROM_SysTick_disableInterrupt
N#else
N#define MAP_SysTick_disableInterrupt                                          \
N        SysTick_disableInterrupt
X#define MAP_SysTick_disableInterrupt                                                  SysTick_disableInterrupt
N#endif
N#ifdef ROM_SysTick_setPeriod
S#define MAP_SysTick_setPeriod                                                 \
S        ROM_SysTick_setPeriod
X#define MAP_SysTick_setPeriod                                                         ROM_SysTick_setPeriod
N#else
N#define MAP_SysTick_setPeriod                                                 \
N        SysTick_setPeriod
X#define MAP_SysTick_setPeriod                                                         SysTick_setPeriod
N#endif
N#ifdef ROM_SysTick_getPeriod
S#define MAP_SysTick_getPeriod                                                 \
S        ROM_SysTick_getPeriod
X#define MAP_SysTick_getPeriod                                                         ROM_SysTick_getPeriod
N#else
N#define MAP_SysTick_getPeriod                                                 \
N        SysTick_getPeriod
X#define MAP_SysTick_getPeriod                                                         SysTick_getPeriod
N#endif
N#ifdef ROM_SysTick_getValue
S#define MAP_SysTick_getValue                                                  \
S        ROM_SysTick_getValue
X#define MAP_SysTick_getValue                                                          ROM_SysTick_getValue
N#else
N#define MAP_SysTick_getValue                                                  \
N        SysTick_getValue
X#define MAP_SysTick_getValue                                                          SysTick_getValue
N#endif
N#ifdef ROM_SysTick_registerInterrupt
S#define MAP_SysTick_registerInterrupt                                         \
S        ROM_SysTick_registerInterrupt
X#define MAP_SysTick_registerInterrupt                                                 ROM_SysTick_registerInterrupt
N#else
N#define MAP_SysTick_registerInterrupt                                         \
N        SysTick_registerInterrupt
X#define MAP_SysTick_registerInterrupt                                                 SysTick_registerInterrupt
N#endif
N#ifdef ROM_SysTick_unregisterInterrupt
S#define MAP_SysTick_unregisterInterrupt                                       \
S        ROM_SysTick_unregisterInterrupt
X#define MAP_SysTick_unregisterInterrupt                                               ROM_SysTick_unregisterInterrupt
N#else
N#define MAP_SysTick_unregisterInterrupt                                       \
N        SysTick_unregisterInterrupt
X#define MAP_SysTick_unregisterInterrupt                                               SysTick_unregisterInterrupt
N#endif
N
N//*****************************************************************************
N//
N// Macros for the Timer_A API.
N//
N//*****************************************************************************
N#ifdef ROM_Timer_A_startCounter
S#define MAP_Timer_A_startCounter                                              \
S        ROM_Timer_A_startCounter
X#define MAP_Timer_A_startCounter                                                      ROM_Timer_A_startCounter
N#else
N#define MAP_Timer_A_startCounter                                              \
N        Timer_A_startCounter
X#define MAP_Timer_A_startCounter                                                      Timer_A_startCounter
N#endif
N#ifdef ROM_Timer_A_configureContinuousMode
S#define MAP_Timer_A_configureContinuousMode                                   \
S        ROM_Timer_A_configureContinuousMode
X#define MAP_Timer_A_configureContinuousMode                                           ROM_Timer_A_configureContinuousMode
N#else
N#define MAP_Timer_A_configureContinuousMode                                   \
N        Timer_A_configureContinuousMode
X#define MAP_Timer_A_configureContinuousMode                                           Timer_A_configureContinuousMode
N#endif
N#ifdef ROM_Timer_A_configureUpMode
S#define MAP_Timer_A_configureUpMode                                           \
S        ROM_Timer_A_configureUpMode
X#define MAP_Timer_A_configureUpMode                                                   ROM_Timer_A_configureUpMode
N#else
N#define MAP_Timer_A_configureUpMode                                           \
N        Timer_A_configureUpMode
X#define MAP_Timer_A_configureUpMode                                                   Timer_A_configureUpMode
N#endif
N#ifdef ROM_Timer_A_configureUpDownMode
S#define MAP_Timer_A_configureUpDownMode                                       \
S        ROM_Timer_A_configureUpDownMode
X#define MAP_Timer_A_configureUpDownMode                                               ROM_Timer_A_configureUpDownMode
N#else
N#define MAP_Timer_A_configureUpDownMode                                       \
N        Timer_A_configureUpDownMode
X#define MAP_Timer_A_configureUpDownMode                                               Timer_A_configureUpDownMode
N#endif
N#ifdef ROM_Timer_A_initCapture
S#define MAP_Timer_A_initCapture                                               \
S        ROM_Timer_A_initCapture
X#define MAP_Timer_A_initCapture                                                       ROM_Timer_A_initCapture
N#else
N#define MAP_Timer_A_initCapture                                               \
N        Timer_A_initCapture
X#define MAP_Timer_A_initCapture                                                       Timer_A_initCapture
N#endif
N#ifdef ROM_Timer_A_initCompare
S#define MAP_Timer_A_initCompare                                               \
S        ROM_Timer_A_initCompare
X#define MAP_Timer_A_initCompare                                                       ROM_Timer_A_initCompare
N#else
N#define MAP_Timer_A_initCompare                                               \
N        Timer_A_initCompare
X#define MAP_Timer_A_initCompare                                                       Timer_A_initCompare
N#endif
N#ifdef ROM_Timer_A_clearTimer
S#define MAP_Timer_A_clearTimer                                                \
S        ROM_Timer_A_clearTimer
X#define MAP_Timer_A_clearTimer                                                        ROM_Timer_A_clearTimer
N#else
N#define MAP_Timer_A_clearTimer                                                \
N        Timer_A_clearTimer
X#define MAP_Timer_A_clearTimer                                                        Timer_A_clearTimer
N#endif
N#ifdef ROM_Timer_A_getSynchronizedCaptureCompareInput
S#define MAP_Timer_A_getSynchronizedCaptureCompareInput                        \
S        ROM_Timer_A_getSynchronizedCaptureCompareInput
X#define MAP_Timer_A_getSynchronizedCaptureCompareInput                                ROM_Timer_A_getSynchronizedCaptureCompareInput
N#else
N#define MAP_Timer_A_getSynchronizedCaptureCompareInput                        \
N        Timer_A_getSynchronizedCaptureCompareInput
X#define MAP_Timer_A_getSynchronizedCaptureCompareInput                                Timer_A_getSynchronizedCaptureCompareInput
N#endif
N#ifdef ROM_Timer_A_getOutputForOutputModeOutBitValue
S#define MAP_Timer_A_getOutputForOutputModeOutBitValue                         \
S        ROM_Timer_A_getOutputForOutputModeOutBitValue
X#define MAP_Timer_A_getOutputForOutputModeOutBitValue                                 ROM_Timer_A_getOutputForOutputModeOutBitValue
N#else
N#define MAP_Timer_A_getOutputForOutputModeOutBitValue                         \
N        Timer_A_getOutputForOutputModeOutBitValue
X#define MAP_Timer_A_getOutputForOutputModeOutBitValue                                 Timer_A_getOutputForOutputModeOutBitValue
N#endif
N#ifdef ROM_Timer_A_getCaptureCompareCount
S#define MAP_Timer_A_getCaptureCompareCount                                    \
S        ROM_Timer_A_getCaptureCompareCount
X#define MAP_Timer_A_getCaptureCompareCount                                            ROM_Timer_A_getCaptureCompareCount
N#else
N#define MAP_Timer_A_getCaptureCompareCount                                    \
N        Timer_A_getCaptureCompareCount
X#define MAP_Timer_A_getCaptureCompareCount                                            Timer_A_getCaptureCompareCount
N#endif
N#ifdef ROM_Timer_A_setOutputForOutputModeOutBitValue
S#define MAP_Timer_A_setOutputForOutputModeOutBitValue                         \
S        ROM_Timer_A_setOutputForOutputModeOutBitValue
X#define MAP_Timer_A_setOutputForOutputModeOutBitValue                                 ROM_Timer_A_setOutputForOutputModeOutBitValue
N#else
N#define MAP_Timer_A_setOutputForOutputModeOutBitValue                         \
N        Timer_A_setOutputForOutputModeOutBitValue
X#define MAP_Timer_A_setOutputForOutputModeOutBitValue                                 Timer_A_setOutputForOutputModeOutBitValue
N#endif
N#ifdef ROM_Timer_A_generatePWM
S#define MAP_Timer_A_generatePWM                                               \
S        ROM_Timer_A_generatePWM
X#define MAP_Timer_A_generatePWM                                                       ROM_Timer_A_generatePWM
N#else
N#define MAP_Timer_A_generatePWM                                               \
N        Timer_A_generatePWM
X#define MAP_Timer_A_generatePWM                                                       Timer_A_generatePWM
N#endif
N#ifdef ROM_Timer_A_stopTimer
S#define MAP_Timer_A_stopTimer                                                 \
S        ROM_Timer_A_stopTimer
X#define MAP_Timer_A_stopTimer                                                         ROM_Timer_A_stopTimer
N#else
N#define MAP_Timer_A_stopTimer                                                 \
N        Timer_A_stopTimer
X#define MAP_Timer_A_stopTimer                                                         Timer_A_stopTimer
N#endif
N#ifdef ROM_Timer_A_setCompareValue
S#define MAP_Timer_A_setCompareValue                                           \
S        ROM_Timer_A_setCompareValue
X#define MAP_Timer_A_setCompareValue                                                   ROM_Timer_A_setCompareValue
N#else
N#define MAP_Timer_A_setCompareValue                                           \
N        Timer_A_setCompareValue
X#define MAP_Timer_A_setCompareValue                                                   Timer_A_setCompareValue
N#endif
N#ifdef ROM_Timer_A_clearInterruptFlag
S#define MAP_Timer_A_clearInterruptFlag                                        \
S        ROM_Timer_A_clearInterruptFlag
X#define MAP_Timer_A_clearInterruptFlag                                                ROM_Timer_A_clearInterruptFlag
N#else
N#define MAP_Timer_A_clearInterruptFlag                                        \
N        Timer_A_clearInterruptFlag
X#define MAP_Timer_A_clearInterruptFlag                                                Timer_A_clearInterruptFlag
N#endif
N#ifdef ROM_Timer_A_clearCaptureCompareInterrupt
S#define MAP_Timer_A_clearCaptureCompareInterrupt                              \
S        ROM_Timer_A_clearCaptureCompareInterrupt
X#define MAP_Timer_A_clearCaptureCompareInterrupt                                      ROM_Timer_A_clearCaptureCompareInterrupt
N#else
N#define MAP_Timer_A_clearCaptureCompareInterrupt                              \
N        Timer_A_clearCaptureCompareInterrupt
X#define MAP_Timer_A_clearCaptureCompareInterrupt                                      Timer_A_clearCaptureCompareInterrupt
N#endif
N#ifdef ROM_Timer_A_enableInterrupt
S#define MAP_Timer_A_enableInterrupt                                           \
S        ROM_Timer_A_enableInterrupt
X#define MAP_Timer_A_enableInterrupt                                                   ROM_Timer_A_enableInterrupt
N#else
N#define MAP_Timer_A_enableInterrupt                                           \
N        Timer_A_enableInterrupt
X#define MAP_Timer_A_enableInterrupt                                                   Timer_A_enableInterrupt
N#endif
N#ifdef ROM_Timer_A_disableInterrupt
S#define MAP_Timer_A_disableInterrupt                                          \
S        ROM_Timer_A_disableInterrupt
X#define MAP_Timer_A_disableInterrupt                                                  ROM_Timer_A_disableInterrupt
N#else
N#define MAP_Timer_A_disableInterrupt                                          \
N        Timer_A_disableInterrupt
X#define MAP_Timer_A_disableInterrupt                                                  Timer_A_disableInterrupt
N#endif
N#ifdef ROM_Timer_A_getInterruptStatus
S#define MAP_Timer_A_getInterruptStatus                                        \
S        ROM_Timer_A_getInterruptStatus
X#define MAP_Timer_A_getInterruptStatus                                                ROM_Timer_A_getInterruptStatus
N#else
N#define MAP_Timer_A_getInterruptStatus                                        \
N        Timer_A_getInterruptStatus
X#define MAP_Timer_A_getInterruptStatus                                                Timer_A_getInterruptStatus
N#endif
N#ifdef ROM_Timer_A_getEnabledInterruptStatus
S#define MAP_Timer_A_getEnabledInterruptStatus                                 \
S        ROM_Timer_A_getEnabledInterruptStatus
X#define MAP_Timer_A_getEnabledInterruptStatus                                         ROM_Timer_A_getEnabledInterruptStatus
N#else
N#define MAP_Timer_A_getEnabledInterruptStatus                                 \
N        Timer_A_getEnabledInterruptStatus
X#define MAP_Timer_A_getEnabledInterruptStatus                                         Timer_A_getEnabledInterruptStatus
N#endif
N#ifdef ROM_Timer_A_enableCaptureCompareInterrupt
S#define MAP_Timer_A_enableCaptureCompareInterrupt                             \
S        ROM_Timer_A_enableCaptureCompareInterrupt
X#define MAP_Timer_A_enableCaptureCompareInterrupt                                     ROM_Timer_A_enableCaptureCompareInterrupt
N#else
N#define MAP_Timer_A_enableCaptureCompareInterrupt                             \
N        Timer_A_enableCaptureCompareInterrupt
X#define MAP_Timer_A_enableCaptureCompareInterrupt                                     Timer_A_enableCaptureCompareInterrupt
N#endif
N#ifdef ROM_Timer_A_disableCaptureCompareInterrupt
S#define MAP_Timer_A_disableCaptureCompareInterrupt                            \
S        ROM_Timer_A_disableCaptureCompareInterrupt
X#define MAP_Timer_A_disableCaptureCompareInterrupt                                    ROM_Timer_A_disableCaptureCompareInterrupt
N#else
N#define MAP_Timer_A_disableCaptureCompareInterrupt                            \
N        Timer_A_disableCaptureCompareInterrupt
X#define MAP_Timer_A_disableCaptureCompareInterrupt                                    Timer_A_disableCaptureCompareInterrupt
N#endif
N#ifdef ROM_Timer_A_getCaptureCompareInterruptStatus
S#define MAP_Timer_A_getCaptureCompareInterruptStatus                          \
S        ROM_Timer_A_getCaptureCompareInterruptStatus
X#define MAP_Timer_A_getCaptureCompareInterruptStatus                                  ROM_Timer_A_getCaptureCompareInterruptStatus
N#else
N#define MAP_Timer_A_getCaptureCompareInterruptStatus                          \
N        Timer_A_getCaptureCompareInterruptStatus
X#define MAP_Timer_A_getCaptureCompareInterruptStatus                                  Timer_A_getCaptureCompareInterruptStatus
N#endif
N#ifdef ROM_Timer_A_getCaptureCompareEnabledInterruptStatus
S#define MAP_Timer_A_getCaptureCompareEnabledInterruptStatus                   \
S        ROM_Timer_A_getCaptureCompareEnabledInterruptStatus
X#define MAP_Timer_A_getCaptureCompareEnabledInterruptStatus                           ROM_Timer_A_getCaptureCompareEnabledInterruptStatus
N#else
N#define MAP_Timer_A_getCaptureCompareEnabledInterruptStatus                   \
N        Timer_A_getCaptureCompareEnabledInterruptStatus
X#define MAP_Timer_A_getCaptureCompareEnabledInterruptStatus                           Timer_A_getCaptureCompareEnabledInterruptStatus
N#endif
N#ifdef ROM_Timer_A_registerInterrupt
S#define MAP_Timer_A_registerInterrupt                                         \
S        ROM_Timer_A_registerInterrupt
X#define MAP_Timer_A_registerInterrupt                                                 ROM_Timer_A_registerInterrupt
N#else
N#define MAP_Timer_A_registerInterrupt                                         \
N        Timer_A_registerInterrupt
X#define MAP_Timer_A_registerInterrupt                                                 Timer_A_registerInterrupt
N#endif
N#ifdef ROM_Timer_A_unregisterInterrupt
S#define MAP_Timer_A_unregisterInterrupt                                       \
S        ROM_Timer_A_unregisterInterrupt
X#define MAP_Timer_A_unregisterInterrupt                                               ROM_Timer_A_unregisterInterrupt
N#else
N#define MAP_Timer_A_unregisterInterrupt                                       \
N        Timer_A_unregisterInterrupt
X#define MAP_Timer_A_unregisterInterrupt                                               Timer_A_unregisterInterrupt
N#endif
N#ifdef ROM_Timer_A_getCounterValue
S#define MAP_Timer_A_getCounterValue                                           \
S        ROM_Timer_A_getCounterValue
X#define MAP_Timer_A_getCounterValue                                                   ROM_Timer_A_getCounterValue
N#else
N#define MAP_Timer_A_getCounterValue                                           \
N        Timer_A_getCounterValue
X#define MAP_Timer_A_getCounterValue                                                   Timer_A_getCounterValue
N#endif
N
N//*****************************************************************************
N//
N// Macros for the Timer32 API.
N//
N//*****************************************************************************
N#ifdef ROM_Timer32_initModule
S#define MAP_Timer32_initModule                                                \
S        ROM_Timer32_initModule
X#define MAP_Timer32_initModule                                                        ROM_Timer32_initModule
N#else
N#define MAP_Timer32_initModule                                                \
N        Timer32_initModule
X#define MAP_Timer32_initModule                                                        Timer32_initModule
N#endif
N#ifdef ROM_Timer32_setCount
S#define MAP_Timer32_setCount                                                  \
S        ROM_Timer32_setCount
X#define MAP_Timer32_setCount                                                          ROM_Timer32_setCount
N#else
N#define MAP_Timer32_setCount                                                  \
N        Timer32_setCount
X#define MAP_Timer32_setCount                                                          Timer32_setCount
N#endif
N#ifdef ROM_Timer32_setCountInBackground
S#define MAP_Timer32_setCountInBackground                                      \
S        ROM_Timer32_setCountInBackground
X#define MAP_Timer32_setCountInBackground                                              ROM_Timer32_setCountInBackground
N#else
N#define MAP_Timer32_setCountInBackground                                      \
N        Timer32_setCountInBackground
X#define MAP_Timer32_setCountInBackground                                              Timer32_setCountInBackground
N#endif
N#ifdef ROM_Timer32_getValue
S#define MAP_Timer32_getValue                                                  \
S        ROM_Timer32_getValue
X#define MAP_Timer32_getValue                                                          ROM_Timer32_getValue
N#else
N#define MAP_Timer32_getValue                                                  \
N        Timer32_getValue
X#define MAP_Timer32_getValue                                                          Timer32_getValue
N#endif
N#ifdef ROM_Timer32_startTimer
S#define MAP_Timer32_startTimer                                                \
S        ROM_Timer32_startTimer
X#define MAP_Timer32_startTimer                                                        ROM_Timer32_startTimer
N#else
N#define MAP_Timer32_startTimer                                                \
N        Timer32_startTimer
X#define MAP_Timer32_startTimer                                                        Timer32_startTimer
N#endif
N#ifdef ROM_Timer32_haltTimer
S#define MAP_Timer32_haltTimer                                                 \
S        ROM_Timer32_haltTimer
X#define MAP_Timer32_haltTimer                                                         ROM_Timer32_haltTimer
N#else
N#define MAP_Timer32_haltTimer                                                 \
N        Timer32_haltTimer
X#define MAP_Timer32_haltTimer                                                         Timer32_haltTimer
N#endif
N#ifdef ROM_Timer32_enableInterrupt
S#define MAP_Timer32_enableInterrupt                                           \
S        ROM_Timer32_enableInterrupt
X#define MAP_Timer32_enableInterrupt                                                   ROM_Timer32_enableInterrupt
N#else
N#define MAP_Timer32_enableInterrupt                                           \
N        Timer32_enableInterrupt
X#define MAP_Timer32_enableInterrupt                                                   Timer32_enableInterrupt
N#endif
N#ifdef ROM_Timer32_disableInterrupt
S#define MAP_Timer32_disableInterrupt                                          \
S        ROM_Timer32_disableInterrupt
X#define MAP_Timer32_disableInterrupt                                                  ROM_Timer32_disableInterrupt
N#else
N#define MAP_Timer32_disableInterrupt                                          \
N        Timer32_disableInterrupt
X#define MAP_Timer32_disableInterrupt                                                  Timer32_disableInterrupt
N#endif
N#ifdef ROM_Timer32_clearInterruptFlag
S#define MAP_Timer32_clearInterruptFlag                                        \
S        ROM_Timer32_clearInterruptFlag
X#define MAP_Timer32_clearInterruptFlag                                                ROM_Timer32_clearInterruptFlag
N#else
N#define MAP_Timer32_clearInterruptFlag                                        \
N        Timer32_clearInterruptFlag
X#define MAP_Timer32_clearInterruptFlag                                                Timer32_clearInterruptFlag
N#endif
N#ifdef ROM_Timer32_getInterruptStatus
S#define MAP_Timer32_getInterruptStatus                                        \
S        ROM_Timer32_getInterruptStatus
X#define MAP_Timer32_getInterruptStatus                                                ROM_Timer32_getInterruptStatus
N#else
N#define MAP_Timer32_getInterruptStatus                                        \
N        Timer32_getInterruptStatus
X#define MAP_Timer32_getInterruptStatus                                                Timer32_getInterruptStatus
N#endif
N#ifdef ROM_Timer32_registerInterrupt
S#define MAP_Timer32_registerInterrupt                                         \
S        ROM_Timer32_registerInterrupt
X#define MAP_Timer32_registerInterrupt                                                 ROM_Timer32_registerInterrupt
N#else
N#define MAP_Timer32_registerInterrupt                                         \
N        Timer32_registerInterrupt
X#define MAP_Timer32_registerInterrupt                                                 Timer32_registerInterrupt
N#endif
N#ifdef ROM_Timer32_unregisterInterrupt
S#define MAP_Timer32_unregisterInterrupt                                       \
S        ROM_Timer32_unregisterInterrupt
X#define MAP_Timer32_unregisterInterrupt                                               ROM_Timer32_unregisterInterrupt
N#else
N#define MAP_Timer32_unregisterInterrupt                                       \
N        Timer32_unregisterInterrupt
X#define MAP_Timer32_unregisterInterrupt                                               Timer32_unregisterInterrupt
N#endif
N
N//*****************************************************************************
N//
N// Macros for the UART API.
N//
N//*****************************************************************************
N#ifdef ROM_UART_initModule
S#define MAP_UART_initModule                                                   \
S        ROM_UART_initModule
X#define MAP_UART_initModule                                                           ROM_UART_initModule
N#else
N#define MAP_UART_initModule                                                   \
N        UART_initModule
X#define MAP_UART_initModule                                                           UART_initModule
N#endif
N#ifdef ROM_UART_transmitData
S#define MAP_UART_transmitData                                                 \
S        ROM_UART_transmitData
X#define MAP_UART_transmitData                                                         ROM_UART_transmitData
N#else
N#define MAP_UART_transmitData                                                 \
N        UART_transmitData
X#define MAP_UART_transmitData                                                         UART_transmitData
N#endif
N#ifdef ROM_UART_enableModule
S#define MAP_UART_enableModule                                                 \
S        ROM_UART_enableModule
X#define MAP_UART_enableModule                                                         ROM_UART_enableModule
N#else
N#define MAP_UART_enableModule                                                 \
N        UART_enableModule
X#define MAP_UART_enableModule                                                         UART_enableModule
N#endif
N#ifdef ROM_UART_disableModule
S#define MAP_UART_disableModule                                                \
S        ROM_UART_disableModule
X#define MAP_UART_disableModule                                                        ROM_UART_disableModule
N#else
N#define MAP_UART_disableModule                                                \
N        UART_disableModule
X#define MAP_UART_disableModule                                                        UART_disableModule
N#endif
N#ifdef ROM_UART_queryStatusFlags
S#define MAP_UART_queryStatusFlags                                             \
S        ROM_UART_queryStatusFlags
X#define MAP_UART_queryStatusFlags                                                     ROM_UART_queryStatusFlags
N#else
N#define MAP_UART_queryStatusFlags                                             \
N        UART_queryStatusFlags
X#define MAP_UART_queryStatusFlags                                                     UART_queryStatusFlags
N#endif
N#ifdef ROM_UART_setDormant
S#define MAP_UART_setDormant                                                   \
S        ROM_UART_setDormant
X#define MAP_UART_setDormant                                                           ROM_UART_setDormant
N#else
N#define MAP_UART_setDormant                                                   \
N        UART_setDormant
X#define MAP_UART_setDormant                                                           UART_setDormant
N#endif
N#ifdef ROM_UART_resetDormant
S#define MAP_UART_resetDormant                                                 \
S        ROM_UART_resetDormant
X#define MAP_UART_resetDormant                                                         ROM_UART_resetDormant
N#else
N#define MAP_UART_resetDormant                                                 \
N        UART_resetDormant
X#define MAP_UART_resetDormant                                                         UART_resetDormant
N#endif
N#ifdef ROM_UART_transmitAddress
S#define MAP_UART_transmitAddress                                              \
S        ROM_UART_transmitAddress
X#define MAP_UART_transmitAddress                                                      ROM_UART_transmitAddress
N#else
N#define MAP_UART_transmitAddress                                              \
N        UART_transmitAddress
X#define MAP_UART_transmitAddress                                                      UART_transmitAddress
N#endif
N#ifdef ROM_UART_transmitBreak
S#define MAP_UART_transmitBreak                                                \
S        ROM_UART_transmitBreak
X#define MAP_UART_transmitBreak                                                        ROM_UART_transmitBreak
N#else
N#define MAP_UART_transmitBreak                                                \
N        UART_transmitBreak
X#define MAP_UART_transmitBreak                                                        UART_transmitBreak
N#endif
N#ifdef ROM_UART_getReceiveBufferAddressForDMA
S#define MAP_UART_getReceiveBufferAddressForDMA                                \
S        ROM_UART_getReceiveBufferAddressForDMA
X#define MAP_UART_getReceiveBufferAddressForDMA                                        ROM_UART_getReceiveBufferAddressForDMA
N#else
N#define MAP_UART_getReceiveBufferAddressForDMA                                \
N        UART_getReceiveBufferAddressForDMA
X#define MAP_UART_getReceiveBufferAddressForDMA                                        UART_getReceiveBufferAddressForDMA
N#endif
N#ifdef ROM_UART_getTransmitBufferAddressForDMA
S#define MAP_UART_getTransmitBufferAddressForDMA                               \
S        ROM_UART_getTransmitBufferAddressForDMA
X#define MAP_UART_getTransmitBufferAddressForDMA                                       ROM_UART_getTransmitBufferAddressForDMA
N#else
N#define MAP_UART_getTransmitBufferAddressForDMA                               \
N        UART_getTransmitBufferAddressForDMA
X#define MAP_UART_getTransmitBufferAddressForDMA                                       UART_getTransmitBufferAddressForDMA
N#endif
N#ifdef ROM_UART_selectDeglitchTime
S#define MAP_UART_selectDeglitchTime                                           \
S        ROM_UART_selectDeglitchTime
X#define MAP_UART_selectDeglitchTime                                                   ROM_UART_selectDeglitchTime
N#else
N#define MAP_UART_selectDeglitchTime                                           \
N        UART_selectDeglitchTime
X#define MAP_UART_selectDeglitchTime                                                   UART_selectDeglitchTime
N#endif
N#ifdef ROM_UART_enableInterrupt
S#define MAP_UART_enableInterrupt                                              \
S        ROM_UART_enableInterrupt
X#define MAP_UART_enableInterrupt                                                      ROM_UART_enableInterrupt
N#else
N#define MAP_UART_enableInterrupt                                              \
N        UART_enableInterrupt
X#define MAP_UART_enableInterrupt                                                      UART_enableInterrupt
N#endif
N#ifdef ROM_UART_disableInterrupt
S#define MAP_UART_disableInterrupt                                             \
S        ROM_UART_disableInterrupt
X#define MAP_UART_disableInterrupt                                                     ROM_UART_disableInterrupt
N#else
N#define MAP_UART_disableInterrupt                                             \
N        UART_disableInterrupt
X#define MAP_UART_disableInterrupt                                                     UART_disableInterrupt
N#endif
N#ifdef ROM_UART_getInterruptStatus
S#define MAP_UART_getInterruptStatus                                           \
S        ROM_UART_getInterruptStatus
X#define MAP_UART_getInterruptStatus                                                   ROM_UART_getInterruptStatus
N#else
N#define MAP_UART_getInterruptStatus                                           \
N        UART_getInterruptStatus
X#define MAP_UART_getInterruptStatus                                                   UART_getInterruptStatus
N#endif
N#ifdef ROM_UART_clearInterruptFlag
S#define MAP_UART_clearInterruptFlag                                           \
S        ROM_UART_clearInterruptFlag
X#define MAP_UART_clearInterruptFlag                                                   ROM_UART_clearInterruptFlag
N#else
N#define MAP_UART_clearInterruptFlag                                           \
N        UART_clearInterruptFlag
X#define MAP_UART_clearInterruptFlag                                                   UART_clearInterruptFlag
N#endif
N#ifdef ROM_UART_receiveData
S#define MAP_UART_receiveData                                                  \
S        ROM_UART_receiveData
X#define MAP_UART_receiveData                                                          ROM_UART_receiveData
N#else
N#define MAP_UART_receiveData                                                  \
N        UART_receiveData
X#define MAP_UART_receiveData                                                          UART_receiveData
N#endif
N#ifdef ROM_UART_getEnabledInterruptStatus
S#define MAP_UART_getEnabledInterruptStatus                                    \
S        ROM_UART_getEnabledInterruptStatus
X#define MAP_UART_getEnabledInterruptStatus                                            ROM_UART_getEnabledInterruptStatus
N#else
N#define MAP_UART_getEnabledInterruptStatus                                    \
N        UART_getEnabledInterruptStatus
X#define MAP_UART_getEnabledInterruptStatus                                            UART_getEnabledInterruptStatus
N#endif
N#ifdef ROM_UART_registerInterrupt
S#define MAP_UART_registerInterrupt                                            \
S        ROM_UART_registerInterrupt
X#define MAP_UART_registerInterrupt                                                    ROM_UART_registerInterrupt
N#else
N#define MAP_UART_registerInterrupt                                            \
N        UART_registerInterrupt
X#define MAP_UART_registerInterrupt                                                    UART_registerInterrupt
N#endif
N#ifdef ROM_UART_unregisterInterrupt
S#define MAP_UART_unregisterInterrupt                                          \
S        ROM_UART_unregisterInterrupt
X#define MAP_UART_unregisterInterrupt                                                  ROM_UART_unregisterInterrupt
N#else
N#define MAP_UART_unregisterInterrupt                                          \
N        UART_unregisterInterrupt
X#define MAP_UART_unregisterInterrupt                                                  UART_unregisterInterrupt
N#endif
N
N//*****************************************************************************
N//
N// Macros for the WDT API.
N//
N//*****************************************************************************
N#ifdef ROM_WDT_A_holdTimer
S#define MAP_WDT_A_holdTimer                                                   \
S        ROM_WDT_A_holdTimer
X#define MAP_WDT_A_holdTimer                                                           ROM_WDT_A_holdTimer
N#else
N#define MAP_WDT_A_holdTimer                                                   \
N        WDT_A_holdTimer
X#define MAP_WDT_A_holdTimer                                                           WDT_A_holdTimer
N#endif
N#ifdef ROM_WDT_A_startTimer
S#define MAP_WDT_A_startTimer                                                  \
S        ROM_WDT_A_startTimer
X#define MAP_WDT_A_startTimer                                                          ROM_WDT_A_startTimer
N#else
N#define MAP_WDT_A_startTimer                                                  \
N        WDT_A_startTimer
X#define MAP_WDT_A_startTimer                                                          WDT_A_startTimer
N#endif
N#ifdef ROM_WDT_A_clearTimer
S#define MAP_WDT_A_clearTimer                                                  \
S        ROM_WDT_A_clearTimer
X#define MAP_WDT_A_clearTimer                                                          ROM_WDT_A_clearTimer
N#else
N#define MAP_WDT_A_clearTimer                                                  \
N        WDT_A_clearTimer
X#define MAP_WDT_A_clearTimer                                                          WDT_A_clearTimer
N#endif
N#ifdef ROM_WDT_A_initWatchdogTimer
S#define MAP_WDT_A_initWatchdogTimer                                           \
S        ROM_WDT_A_initWatchdogTimer
X#define MAP_WDT_A_initWatchdogTimer                                                   ROM_WDT_A_initWatchdogTimer
N#else
N#define MAP_WDT_A_initWatchdogTimer                                           \
N        WDT_A_initWatchdogTimer
X#define MAP_WDT_A_initWatchdogTimer                                                   WDT_A_initWatchdogTimer
N#endif
N#ifdef ROM_WDT_A_initIntervalTimer
S#define MAP_WDT_A_initIntervalTimer                                           \
S        ROM_WDT_A_initIntervalTimer
X#define MAP_WDT_A_initIntervalTimer                                                   ROM_WDT_A_initIntervalTimer
N#else
N#define MAP_WDT_A_initIntervalTimer                                           \
N        WDT_A_initIntervalTimer
X#define MAP_WDT_A_initIntervalTimer                                                   WDT_A_initIntervalTimer
N#endif
N#ifdef ROM_WDT_A_registerInterrupt
S#define MAP_WDT_A_registerInterrupt                                           \
S        ROM_WDT_A_registerInterrupt
X#define MAP_WDT_A_registerInterrupt                                                   ROM_WDT_A_registerInterrupt
N#else
N#define MAP_WDT_A_registerInterrupt                                           \
N        WDT_A_registerInterrupt
X#define MAP_WDT_A_registerInterrupt                                                   WDT_A_registerInterrupt
N#endif
N#ifdef ROM_WDT_A_unregisterInterrupt
S#define MAP_WDT_A_unregisterInterrupt                                         \
S        ROM_WDT_A_unregisterInterrupt
X#define MAP_WDT_A_unregisterInterrupt                                                 ROM_WDT_A_unregisterInterrupt
N#else
N#define MAP_WDT_A_unregisterInterrupt                                         \
N        WDT_A_unregisterInterrupt
X#define MAP_WDT_A_unregisterInterrupt                                                 WDT_A_unregisterInterrupt
N#endif
N#ifdef ROM_WDT_A_setPasswordViolationReset
S#define MAP_WDT_A_setPasswordViolationReset                                   \
S        ROM_WDT_A_setPasswordViolationReset
X#define MAP_WDT_A_setPasswordViolationReset                                           ROM_WDT_A_setPasswordViolationReset
N#else
N#define MAP_WDT_A_setPasswordViolationReset                                   \
N        WDT_A_setPasswordViolationReset
X#define MAP_WDT_A_setPasswordViolationReset                                           WDT_A_setPasswordViolationReset
N#endif
N#ifdef ROM_WDT_A_setTimeoutReset
S#define MAP_WDT_A_setTimeoutReset                                             \
S        ROM_WDT_A_setTimeoutReset
X#define MAP_WDT_A_setTimeoutReset                                                     ROM_WDT_A_setTimeoutReset
N#else
N#define MAP_WDT_A_setTimeoutReset                                             \
N        WDT_A_setTimeoutReset
X#define MAP_WDT_A_setTimeoutReset                                                     WDT_A_setTimeoutReset
N#endif
N
N#endif // __ROM_MAP_H__
L 61 "C:/ti/msp432_driverlib_3_21_00_05/driverlib/MSP432P4xx/driverlib.h" 2
N#include "rtc_c.h"
L 1 "C:\ti\msp432_driverlib_3_21_00_05\driverlib\MSP432P4xx\rtc_c.h" 1
N/*
N * -------------------------------------------
N *    MSP432 DriverLib - v3_21_00_05 
N * -------------------------------------------
N *
N * --COPYRIGHT--,BSD,BSD
N * Copyright (c) 2016, Texas Instruments Incorporated
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N *
N * *  Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N *
N * *  Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * *  Neither the name of Texas Instruments Incorporated nor the names of
N *    its contributors may be used to endorse or promote products derived
N *    from this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
N * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
N * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
N * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
N * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
N * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
N * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
N * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
N * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * --/COPYRIGHT--*/
N#ifndef RTC_C_H_
N#define RTC_C_H_
N
N//*****************************************************************************
N//
N//! \addtogroup rtc_api
N//! @{
N//
N//*****************************************************************************
N
N
N//*****************************************************************************
N//
N// If building with a C++ compiler, make all of the definitions in this header
N// have a C binding.
N//
N//*****************************************************************************
N#ifdef __cplusplus
Nextern "C"
N{
N#endif
N
N#include <stdint.h>
N#include <stdbool.h>
N#include <msp.h>
N
N//*****************************************************************************
N//
N//The following is a struct that can be passed to RTC_CalendarInit() in the
N//CalendarTime parameter, as well as returned by RTC_getCalendarTime()
N//
N//*****************************************************************************
Ntypedef struct _RTC_C_Calendar
N{
N    uint_fast8_t seconds;
N    uint_fast8_t minutes;
N    uint_fast8_t hours;
N    uint_fast8_t dayOfWeek;
N    uint_fast8_t dayOfmonth;
N    uint_fast8_t month;
N    uint_fast16_t year;
N} RTC_C_Calendar;
N
N//*****************************************************************************
N//
N//The following are values that can be passed to RTC_setCalibrationData()
N//
N//*****************************************************************************
N#define RTC_C_CALIBRATIONFREQ_OFF   (RTC_C_CTL13_CALF_0)
N#define RTC_C_CALIBRATIONFREQ_512HZ (RTC_C_CTL13_CALF_1)
N#define RTC_C_CALIBRATIONFREQ_256HZ (RTC_C_CTL13_CALF_2)
N#define RTC_C_CALIBRATIONFREQ_1HZ   (RTC_C_CTL13_CALF_3)
N
N//*****************************************************************************
N//
N//The following are values that can be passed to RTC_setCalibrationData()
N//
N//*****************************************************************************
N#define RTC_C_CALIBRATION_DOWN1PPM  ( !(RTC_C_OCAL_OCALS) )
N#define RTC_C_CALIBRATION_UP1PPM    (RTC_C_OCAL_OCALS)
N
N//*****************************************************************************
N//
N//The following are values that can be passed to
N//RTC_setTemperatureCompensation()
N//
N//*****************************************************************************
N#define RTC_C_COMPENSATION_DOWN1PPM  ( !(RTC_C_TCMP_TCMPS) )
N#define RTC_C_COMPENSATION_UP1PPM    (RTC_C_TCMP_TCMPS)
N
N//*****************************************************************************
N//
N//The following are values that can be passed to RTC_iniRTC_Calendar()
N//
N//*****************************************************************************
N#define RTC_C_FORMAT_BINARY  ( !(RTC_C_CTL13_BCD) )
N#define RTC_C_FORMAT_BCD     (RTC_C_CTL13_BCD)
N
N//*****************************************************************************
N//
N//The following is a value that can be passed to RTC_seRTC_CalendarAlarm()
N//
N//*****************************************************************************
N#define RTC_C_ALARMCONDITION_OFF  (0x80)
N
N//*****************************************************************************
N//
N//The following are values that can be passed to RTC_seRTC_CalendarEvent()
N//in the eventSelect parameter.
N//
N//*****************************************************************************
N#define RTC_C_CALENDAREVENT_MINUTECHANGE  (RTC_C_CTL13_TEV_0)
N#define RTC_C_CALENDAREVENT_HOURCHANGE    (RTC_C_CTL13_TEV_1)
N#define RTC_C_CALENDAREVENT_NOON          (RTC_C_CTL13_TEV_2)
N#define RTC_C_CALENDAREVENT_MIDNIGHT      (RTC_C_CTL13_TEV_3)
N
N//*****************************************************************************
N//
N//The following are values that can be passed to RTC_definePrescaleEvent()
N//
N//*****************************************************************************
N#define RTC_C_PRESCALE_0  (0x0)
N#define RTC_C_PRESCALE_1  (0x1)
N
N//*****************************************************************************
N//
N//The following are values that can be passed to RTC_definePrescaleEvent()
N//in the prescaleEventDivider parameter.
N//
N//*****************************************************************************
N#define RTC_C_PSEVENTDIVIDER_2   (RTC_C_PS0CTL_RT0IP_0)
N#define RTC_C_PSEVENTDIVIDER_4   (RTC_C_PS0CTL_RT0IP_1)
N#define RTC_C_PSEVENTDIVIDER_8   (RTC_C_PS0CTL_RT0IP_2)
N#define RTC_C_PSEVENTDIVIDER_16  (RTC_C_PS0CTL_RT0IP_3)
N#define RTC_C_PSEVENTDIVIDER_32  (RTC_C_PS0CTL_RT0IP_4)
N#define RTC_C_PSEVENTDIVIDER_64  (RTC_C_PS0CTL_RT0IP_5)
N#define RTC_C_PSEVENTDIVIDER_128 (RTC_C_PS0CTL_RT0IP_6)
N#define RTC_C_PSEVENTDIVIDER_256 (RTC_C_PS0CTL_RT0IP_7)
N
N//*****************************************************************************
N//
N//The following are values that can be passed to the interrupt functions
N//
N//*****************************************************************************
N#define RTC_C_OSCILLATOR_FAULT_INTERRUPT  RTC_C_CTL0_OFIE
N#define RTC_C_TIME_EVENT_INTERRUPT        RTC_C_CTL0_TEVIE
N#define RTC_C_CLOCK_ALARM_INTERRUPT       RTC_C_CTL0_AIE
N#define RTC_C_CLOCK_READ_READY_INTERRUPT  RTC_C_CTL0_RDYIE
N#define RTC_C_PRESCALE_TIMER0_INTERRUPT   0x02
N#define RTC_C_PRESCALE_TIMER1_INTERRUPT   0x01
N
N//*****************************************************************************
N//
N//! Starts the RTC.
N//!
N//! This function clears the RTC main hold bit to allow the RTC to function.
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void RTC_C_startClock(void);
N
N//*****************************************************************************
N//
N//! Holds the RTC.
N//!
N//! This function sets the RTC main hold bit to disable RTC functionality.
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void RTC_C_holdClock(void);
N
N//*****************************************************************************
N//
N//! Allows and Sets the frequency output to RTCLK pin for calibration
N//! measurement.
N//!
N//! \param frequencySelect is the frequency output to RTCLK.
N//!        Valid values are
N//!        - \b   RTC_C_CALIBRATIONFREQ_OFF - turn off calibration
N//!                                                 output [Default]
N//!        - \b   RTC_C_CALIBRATIONFREQ_512HZ - output signal at 512Hz
N//!                                                     for calibration
N//!        - \b   RTC_C_CALIBRATIONFREQ_256HZ - output signal at 256Hz
N//!                                                     for calibration
N//!        - \b   RTC_C_CALIBRATIONFREQ_1HZ - output signal at 1Hz
N//!                                                     for calibration
N//!
N//! This function sets a frequency to measure at the RTCLK output pin. After
N//! testing the set frequency, the calibration could be set accordingly.
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void RTC_C_setCalibrationFrequency(uint_fast16_t frequencySelect);
N
N//*****************************************************************************
N//
N//! Sets the specified calibration for the RTC.
N//!
N//! \param offsetDirection is the direction that the calibration offset will
N//!        go. Valid values are
N//!        - \b   RTC_C_CALIBRATION_DOWN1PPM - calibrate at steps of -1
N//!        - \b   RTC_C_CALIBRATION_UP1PPM - calibrat at steps of +1
N//! \param offsetValue is the value that the offset will be a factor of; a
N//!       valid value is any integer from 1-240.
N//!
N//! This function sets the calibration offset to make the RTC as accurate as
N//! possible. The offsetDirection can be either +1-ppm or -1-ppm, and the
N//! offsetValue should be from 1-240 and is multiplied by the direction setting
N//! (i.e. +1-ppm * 8 (offsetValue) = +8-ppm).
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void RTC_C_setCalibrationData(uint_fast8_t offsetDirection,
N        uint_fast8_t offsetValue);
N
N//*****************************************************************************
N//
N//! Sets the specified temperature compensation for the RTC.
N//!
N//! \param offsetDirection is the direction that the calibration offset will
N//!        go. Valid values are
N//!        - \b   RTC_C_COMPENSATION_DOWN1PPM - calibrate at steps of -1
N//!        - \b   RTC_C_COMPENSATION_UP1PPM - calibrate at steps of +1
N//! \param offsetValue is the value that the offset will be a factor of; a
N//!       value is any integer from 1-240.
N//!
N//! This function sets the calibration offset to make the RTC as accurate as
N//! possible. The offsetDirection can be either +1-ppm or -1-ppm, and the
N//! offsetValue should be from 1-240 and is multiplied by the direction setting
N//! (i.e. +1-ppm * 8 (offsetValue) = +8-ppm).
N//!
N//! \return true if calibration was set, false if it could not be set
N//!
N//
N//*****************************************************************************
Nextern bool RTC_C_setTemperatureCompensation(uint_fast16_t offsetDirection,
N        uint_fast8_t offsetValue);
N
N//*****************************************************************************
N//
N//! Initializes the settings to operate the RTC in Calendar mode.
N//!
N//! \param calendarTime is the structure containing the values for the Calendar
N//!       to be initialized to.
N//!        Valid values should be of type Calendar and should contain the
N//!        following members and corresponding values:
N//!        - \b   seconds between 0-59
N//!        - \b   minutes between 0-59
N//!        - \b   hours between 0-24
N//!        - \b   dayOfWeek between 0-6
N//!        - \b   dayOfmonth between 0-31
N//!        - \b   year between 0-4095
N//!        \note Values beyond the ones specified may result in eradic behavior.
N//! \param formatSelect is the format for the Calendar registers to use.
N//!        Valid values are
N//!        - \b   RTC_FORMAT_BINARY [Default]
N//!        - \b   RTC_FORMAT_BCD
N//!
N//! This function initializes the Calendar mode of the RTC module.
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void RTC_C_initCalendar(const RTC_C_Calendar *calendarTime,
N        uint_fast16_t formatSelect);
N
N//*****************************************************************************
N//
N//! Returns the Calendar Time stored in the Calendar registers of the RTC.
N//!
N//!
N//! This function returns the current Calendar time in the form of a Calendar
N//! structure.
N//!
N//! \return A Calendar structure containing the current time.
N//
N//*****************************************************************************
Nextern RTC_C_Calendar RTC_C_getCalendarTime(void);
N
N//*****************************************************************************
N//
N//! Sets and Enables the desired Calendar Alarm settings.
N//!
N//! \param minutesAlarm is the alarm condition for the minutes.
N//!        Valid values are
N//!        - An integer between 0-59, OR
N//!        - \b   RTC_C_ALARMCONDITION_OFF [Default]
N//! \param hoursAlarm is the alarm condition for the hours.
N//!        Valid values are
N//!        - An integer between 0-24, OR
N//!        - \b   RTC_C_ALARMCONDITION_OFF [Default]
N//! \param dayOfWeekAlarm is the alarm condition for the day of week.
N//!        Valid values are
N//!        - An integer between 0-6, OR
N//!        - \b   RTC_C_ALARMCONDITION_OFF [Default]
N//! \param dayOfmonthAlarm is the alarm condition for the day of the month.
N//!        Valid values are
N//!        - An integer between 0-31, OR
N//!        - \b   RTC_C_ALARMCONDITION_OFF [Default]
N//!
N//! This function sets a Calendar interrupt condition to assert the RTCAIFG
N//! interrupt flag. The condition is a logical and of all of the parameters.
N//! For example if the minutes and hours alarm is set, then the interrupt will
N//! only assert when the minutes AND the hours change to the specified setting.
N//! Use the RTC_ALARM_OFF for any alarm settings that should not be apart of
N//! the alarm condition.
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void RTC_C_setCalendarAlarm(uint_fast8_t minutesAlarm,
N        uint_fast8_t hoursAlarm, uint_fast8_t dayOfWeekAlarm,
N        uint_fast8_t dayOfmonthAlarm);
N
N//*****************************************************************************
N//
N//! Sets a single specified Calendar interrupt condition.
N//!
N//! \param eventSelect is the condition selected.
N//!        Valid values are
N//!        - \b   RTC_C_CALENDAREVENT_MINUTECHANGE - assert interrupt on every
N//!             minute
N//!        - \b   RTC_C_CALENDAREVENT_HOURCHANGE - assert interrupt on every hour
N//!        - \b   RTC_C_CALENDAREVENT_NOON - assert interrupt when hour is 12
N//!        - \b   RTC_C_CALENDAREVENT_MIDNIGHT - assert interrupt when hour is 0
N//!
N//! This function sets a specified event to assert the RTCTEVIFG interrupt. This
N//! interrupt is independent from the Calendar alarm interrupt.
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void RTC_C_setCalendarEvent(uint_fast16_t eventSelect);
N
N//*****************************************************************************
N//
N//! Sets up an interrupt condition for the selected Prescaler.
N//!
N//! \param prescaleSelect is the prescaler to define an interrupt for.
N//!        Valid values are
N//!        - \b   RTC_C_PRESCALE_0
N//!        - \b   RTC_C_PRESCALE_1
N//! \param prescaleEventDivider is a divider to specify when an interrupt can
N//!       occur based on the clock source of the selected prescaler.
N//!       (Does not affect timer of the selected prescaler).
N//!       Valid values are
N//!       - \b   RTC_C_PSEVENTDIVIDER_2 [Default]
N//!       - \b   RTC_C_PSEVENTDIVIDER_4
N//!       - \b   RTC_C_PSEVENTDIVIDER_8
N//!       - \b   RTC_C_PSEVENTDIVIDER_16
N//!       - \b   RTC_C_PSEVENTDIVIDER_32
N//!       - \b   RTC_C_PSEVENTDIVIDER_64
N//!       - \b   RTC_C_PSEVENTDIVIDER_128
N//!       - \b   RTC_C_PSEVENTDIVIDER_256
N//!
N//! This function sets the condition for an interrupt to assert based on the
N//! individual prescalers.
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void RTC_C_definePrescaleEvent(uint_fast8_t prescaleSelect,
N        uint_fast8_t prescaleEventDivider);
N
N//*****************************************************************************
N//
N//! Returns the selected Prescaler value.
N//!
N//! \param prescaleSelect is the prescaler to obtain the value of.
N//!        Valid values are
N//!        - \b   RTC_C_PRESCALE_0
N//!        - \b   RTC_C_PRESCALE_1
N//!
N//! This function returns the value of the selected prescale counter register.
N//! The counter should be held before reading. If in counter mode, the
N//! individual prescaler can be held, while in Calendar mode the whole RTC must
N//! be held.
N//!
N//! \return The value of the specified Prescaler count register
N//
N//*****************************************************************************
Nextern uint_fast8_t RTC_C_getPrescaleValue(uint_fast8_t prescaleSelect);
N
N//*****************************************************************************
N//
N//! Sets the selected Prescaler value.
N//!
N//! \param prescaleSelect is the prescaler to set the value for.
N//!        Valid values are
N//!        - \b   RTC_C_PRESCALE_0
N//!        - \b   RTC_C_PRESCALE_1
N//! \param prescaleCounterValue is the specified value to set the prescaler to;
N//!       a valid value is any integer from 0-255.
N//!
N//! This function sets the prescale counter value. Before setting the prescale
N//! counter, it should be held.
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void RTC_C_setPrescaleValue(uint_fast8_t prescaleSelect,
N        uint_fast8_t prescaleCounterValue);
N
N//*****************************************************************************
N//
N//! Returns the given BCD value in Binary Format
N//!
N//! \param valueToConvert is the raw value in BCD format to convert to
N//!        Binary.
N//!
N//! This function converts BCD values to Binary format.
N//!
N//! \return The Binary version of the valueToConvert parameter.
N//
N//*****************************************************************************
Nextern uint16_t RTC_C_convertBCDToBinary(uint16_t valueToConvert);
N
N//*****************************************************************************
N//
N//! Returns the given Binary value in BCD Format
N//!
N
N//! \param valueToConvert is the raw value in Binary format to convert to
N//!        BCD.
N//!
N//! This function converts Binary values to BCD format.
N//!
N//! \return The BCD version of the valueToConvert parameter.
N//
N//*****************************************************************************
Nextern uint16_t RTC_C_convertBinaryToBCD(uint16_t valueToConvert);
N
N//*****************************************************************************
N//
N//! Enables selected RTC interrupt sources.
N//!
N//! \param interruptMask is a bit mask of the interrupts to enable.
N//!        Mask Value is the logical OR of any of the following
N//!        - \b  RTC_C_TIME_EVENT_INTERRUPT - asserts when counter overflows in
N//!             counter mode or when Calendar event condition defined by
N//!             defineCalendarEvent() is met.
N//!        - \b  RTC_C_CLOCK_ALARM_INTERRUPT - asserts when alarm condition in
N//!             Calendar mode is met.
N//!        - \b  RTC_C_CLOCK_READ_READY_INTERRUPT - asserts when Calendar
N//!             registers are settled.
N//!        - \b  RTC_C_PRESCALE_TIMER0_INTERRUPT - asserts when Prescaler 0
N//!             event condition is met.
N//!        - \b  RTC_C_PRESCALE_TIMER1_INTERRUPT - asserts when Prescaler 1
N//!             event condition is met.
N//!        - \b  RTC_C_OSCILLATOR_FAULT_INTERRUPT - asserts if there is
N//!             a problem with the 32kHz oscillator, while the RTC is running.
N//!
N//! This function enables the selected RTC interrupt source.  Only the sources
N//! that are enabled can be reflected to the processor interrupt; disabled
N//! sources have no effect on the processor.
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void RTC_C_enableInterrupt(uint8_t interruptMask);
N
N//*****************************************************************************
N//
N//! Disables selected RTC interrupt sources.
N//!
N//! \param interruptMask is a bit mask of the interrupts to disable.
N//!        Mask Value is the logical OR of any of the following
N//!        - \b  RTC_C_TIME_EVENT_INTERRUPT - asserts when counter overflows in
N//!             counter mode or when Calendar event condition defined by
N//!             defineCalendarEvent() is met.
N//!        - \b  RTC_C_CLOCK_ALARM_INTERRUPT - asserts when alarm condition in
N//!             Calendar mode is met.
N//!        - \b  RTC_CLOCK_READ_READY_INTERRUPT - asserts when Calendar
N//!             registers are settled.
N//!        - \b  RTC_C_PRESCALE_TIMER0_INTERRUPT - asserts when Prescaler 0
N//!             event condition is met.
N//!        - \b  RTC_C_PRESCALE_TIMER1_INTERRUPT - asserts when Prescaler 1
N//!             event condition is met.
N//!        - \b  RTC_C_OSCILLATOR_FAULT_INTERRUPT - asserts if there is a
N//!             problem with the 32kHz oscillator, while the RTC is running.
N//!
N//! This function disables the selected RTC interrupt source.  Only the sources
N//! that are enabled can be reflected to the processor interrupt; disabled
N//! sources have no effect on the processor.
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void RTC_C_disableInterrupt(uint8_t interruptMask);
N
N//*****************************************************************************
N//
N//! Returns the status of the interrupts flags.
N//!
N//! \return A bit mask of the selected interrupt flag's status.
N//!        Mask Value is the logical OR of any of the following
N//!        - \b  RTC_C_TIME_EVENT_INTERRUPT - asserts when counter overflows in
N//!             counter mode or when Calendar event condition defined by
N//!             defineCalendarEvent() is met.
N//!        - \b  RTC_C_CLOCK_ALARM_INTERRUPT - asserts when alarm condition in
N//!             Calendar mode is met.
N//!        - \b  RTC_C_CLOCK_READ_READY_INTERRUPT - asserts when Calendar
N//!             registers are settled.
N//!        - \b  RTC_C_PRESCALE_TIMER0_INTERRUPT - asserts when Prescaler 0
N//!             event condition is met.
N//!        - \b  RTC_C_PRESCALE_TIMER1_INTERRUPT - asserts when Prescaler 1
N//!             event condition is met.
N//!        - \b  RTC_C_OSCILLATOR_FAULT_INTERRUPT - asserts if there is a
N//!             problem with the 32kHz oscillator, while the RTC is running.
N//
N//*****************************************************************************
Nextern uint_fast8_t RTC_C_getInterruptStatus(void);
N
N//*****************************************************************************
N//
N//! Returns the status of the interrupts flags masked with the enabled
N//! interrupts.  This function is useful to call in ISRs to get a
N//! list of pending interrupts that are actually enabled and could have caused
N//! the ISR.
N//!
N//! \return A bit mask of the selected interrupt flag's status.
N//!        Mask Value is the logical OR of any of the following
N//!        - \b  RTC_TIME_EVENT_INTERRUPT - asserts when counter overflows in
N//!             counter mode or when Calendar event condition defined by
N//!             defineCalendarEvent() is met.
N//!        - \b  RTC_CLOCK_ALARM_INTERRUPT - asserts when alarm condition in
N//!             Calendar mode is met.
N//!        - \b  RTC_CLOCK_READ_READY_INTERRUPT - asserts when Calendar
N//!             registers are settled.
N//!        - \b  RTC_C_PRESCALE_TIMER0_INTERRUPT - asserts when Prescaler 0
N//!             event condition is met.
N//!        - \b  RTC_C_PRESCALE_TIMER1_INTERRUPT - asserts when Prescaler 1
N//!             event condition is met.
N//!        - \b  RTC_OSCILLATOR_FAULT_INTERRUPT - asserts if there is a problem
N//!             with the 32kHz oscillator, while the RTC is running.
N//
N//*****************************************************************************
Nextern uint_fast8_t RTC_C_getEnabledInterruptStatus(void);
N
N//*****************************************************************************
N//
N//! Clears selected RTC interrupt flags.
N//!
N//! \param interruptFlagMask is a bit mask of the interrupt flags to be
N//!        cleared. Mask Value is the logical OR of any of the following
N//!        - \b  RTC_C_TIME_EVENT_INTERRUPT - asserts when counter overflows in
N//!             counter mode or when Calendar event condition defined by
N//!             defineCalendarEvent() is met.
N//!        - \b  RTC_C_CLOCK_ALARM_INTERRUPT - asserts when alarm condition in
N//!             Calendar mode is met.
N//!        - \b  RTC_C_CLOCK_READ_READY_INTERRUPT - asserts when Calendar
N//!             registers are settled.
N//!        - \b  RTC_C_PRESCALE_TIMER0_INTERRUPT - asserts when Prescaler 0
N//!             event condition is met.
N//!        - \b  RTC_C_PRESCALE_TIMER1_INTERRUPT - asserts when Prescaler 1
N//!             event condition is met.
N//!        - \b  RTC_C_OSCILLATOR_FAULT_INTERRUPT - asserts if there is
N//!             a problem with the 32kHz oscillator, while the RTC is running.
N//!
N//! This function clears the RTC interrupt flag is cleared, so that it no longer
N//! asserts.
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void RTC_C_clearInterruptFlag(uint_fast8_t interruptFlagMask);
N
N//*****************************************************************************
N//
N//! Registers an interrupt handler for the RTC interrupt.
N//!
N//! \param intHandler is a pointer to the function to be called when the
N//! RTC interrupt occurs.
N//!
N//! This function registers the handler to be called when a RTC
N//! interrupt occurs. This function enables the global interrupt in the
N//! interrupt controller; specific AES interrupts must be enabled
N//! via RTC_enableInterrupt().  It is the interrupt handler's responsibility to
N//! clear the interrupt source via RTC_clearInterruptFlag().
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void RTC_C_registerInterrupt(void (*intHandler)(void));
N
N//*****************************************************************************
N//
N//! Unregisters the interrupt handler for the RTC interrupt
N//!
N//! This function unregisters the handler to be called when RTC
N//! interrupt occurs.  This function also masks off the interrupt in the
N//! interrupt controller so that the interrupt handler no longer is called.
N//!
N//! \sa Interrupt_registerInterrupt() for important information about
N//! registering interrupt handlers.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void RTC_C_unregisterInterrupt(void);
N
N/* Defines for future devices that might have multiple instances */
N#define RTC_C_startClockMultipleInstance(a) RTC_C_startClock()
N#define RTC_C_holdClockMultipleInstance(a) RTC_C_holdClock()
N#define RTC_C_setCalibrationFrequencyMultipleInstance(a,b) RTC_C_setCalibrationFrequency(b)
N#define RTC_C_setCalibrationDataMultipleInstance(a,b,c) RTC_C_setCalibrationData(b,c)
N#define RTC_C_setTemperatureCompensationMultipleInstance(a,b,c) RTC_C_setTemperatureCompensation(b,c)
N#define RTC_C_initCalendarMultipleInstance(a,b,c) RTC_C_initCalendar(b,c)
N#define RTC_C_getCalendarTimeMultipleInstance(a) RTC_C_getCalendarTime()
N#define RTC_C_setCalendarAlarmMultipleInstance(a,b,c,d,e) RTC_C_setCalendarAlarm(b,c,d,e)
N#define RTC_C_setCalendarEventMultipleInstance(a,b) RTC_C_setCalendarEvent(b)
N#define RTC_C_definePrescaleEventMultipleInstance(a,b,c) RTC_C_definePrescaleEvent(b,c)
N#define RTC_C_getPrescaleValueMultipleInstance(a,b) RTC_C_getPrescaleValue(b)
N#define RTC_C_setPrescaleValueMultipleInstance(a,b,c) RTC_C_setPrescaleValue(b,c)
N#define RTC_C_convertBCDToBinaryMultipleInstance(a,b) RTC_C_convertBCDToBinary(b)
N#define RTC_C_convertBinaryToBCDMultipleInstance(a,b) RTC_C_convertBinaryToBCD(b)
N#define RTC_C_enableInterruptMultipleInstance(a,b) RTC_C_enableInterrupt(b)
N#define RTC_C_disableInterruptMultipleInstance(a,b) RTC_C_disableInterrupt(b)
N#define RTC_C_getInterruptStatusMultipleInstance(a) RTC_C_getInterruptStatus()
N#define RTC_C_getEnabledInterruptStatusMultipleInstance(a) RTC_C_getEnabledInterruptStatus()
N#define RTC_C_clearInterruptFlagMultipleInstance(a,b) RTC_C_clearInterruptFlag(b)
N#define RTC_C_registerInterruptMultipleInstance(a,b) RTC_C_registerInterrupt(b)
N#define RTC_C_unregisterInterruptMultipleInstance(a) RTC_C_unregisterInterrupt()
N
N//*****************************************************************************
N//
N// Mark the end of the C bindings section for C++ compilers.
N//
N//*****************************************************************************
N#ifdef __cplusplus
N}
N#endif
N
N//*****************************************************************************
N//
N// Close the Doxygen group.
N//! @}
N//
N//*****************************************************************************
N
N#endif /* RTC_H */
L 62 "C:/ti/msp432_driverlib_3_21_00_05/driverlib/MSP432P4xx/driverlib.h" 2
N#include "spi.h"
L 1 "C:\ti\msp432_driverlib_3_21_00_05\driverlib\MSP432P4xx\spi.h" 1
N/*
N * -------------------------------------------
N *    MSP432 DriverLib - v3_21_00_05 
N * -------------------------------------------
N *
N * --COPYRIGHT--,BSD,BSD
N * Copyright (c) 2016, Texas Instruments Incorporated
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N *
N * *  Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N *
N * *  Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * *  Neither the name of Texas Instruments Incorporated nor the names of
N *    its contributors may be used to endorse or promote products derived
N *    from this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
N * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
N * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
N * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
N * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
N * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
N * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
N * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
N * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * --/COPYRIGHT--*/
N#ifndef SPI_H_
N#define SPI_H_
N
N//*****************************************************************************
N//
N//! \addtogroup spi_api
N//! @{
N//
N//*****************************************************************************
N
N//*****************************************************************************
N//
N// If building with a C++ compiler, make all of the definitions in this header
N// have a C binding.
N//
N//*****************************************************************************
N#ifdef __cplusplus
Nextern "C"
N{
N#endif
N
N#include <stdbool.h>
N#include <stdint.h>
N#include <msp.h>
N#include "eusci.h"
N
N/* Configuration Defines */
N#define EUSCI_SPI_CLOCKSOURCE_ACLK    EUSCI_B_CTLW0_SSEL__ACLK
N#define EUSCI_SPI_CLOCKSOURCE_SMCLK   EUSCI_B_CTLW0_SSEL__SMCLK
N
N#define EUSCI_SPI_MSB_FIRST    EUSCI_B_CTLW0_MSB
N#define EUSCI_SPI_LSB_FIRST    0x00
N
N#define EUSCI_SPI_BUSY        EUSCI_A_STATW_BUSY
N#define EUSCI_SPI_NOT_BUSY    0x00
N
N#define EUSCI_SPI_PHASE_DATA_CHANGED_ONFIRST_CAPTURED_ON_NEXT    0x00
N#define EUSCI_SPI_PHASE_DATA_CAPTURED_ONFIRST_CHANGED_ON_NEXT    EUSCI_B_CTLW0_CKPH
N
N#define EUSCI_SPI_3PIN                      EUSCI_B_CTLW0_MODE_0
N#define EUSCI_SPI_4PIN_UCxSTE_ACTIVE_HIGH   EUSCI_B_CTLW0_MODE_1
N#define EUSCI_SPI_4PIN_UCxSTE_ACTIVE_LOW    EUSCI_B_CTLW0_MODE_2
N
N#define EUSCI_SPI_CLOCKPOLARITY_INACTIVITY_HIGH    EUSCI_B_CTLW0_CKPL
N#define EUSCI_SPI_CLOCKPOLARITY_INACTIVITY_LOW     0x00
N
N#define EUSCI_SPI_TRANSMIT_INTERRUPT    EUSCI_B__TXIE
N#define EUSCI_SPI_RECEIVE_INTERRUPT     EUSCI_B__RXIE
N
N#define EUSCI_SPI_ENABLE_SIGNAL_FOR_4WIRE_SLAVE           EUSCI_B_CTLW0_STEM
N#define EUSCI_SPI_PREVENT_CONFLICTS_WITH_OTHER_MASTERS    0x00
N
N//*****************************************************************************
N//
N//!     ypedef eUSCI_SPI_MasterConfig
N//! \brief Type definition for \link _eUSCI_SPI_MasterConfig \endlink structure
N//!
N//! \struct _eUSCI_SPI_MasterConfig
N//! \brief Configuration structure for master mode in the \b SPI module. See
N//!          \link SPI_initMaster \endlink for parameter documentation.
N//
N//*****************************************************************************
Ntypedef struct _eUSCI_SPI_MasterConfig
N{
N    uint_fast8_t selectClockSource;
N    uint32_t clockSourceFrequency;
N    uint32_t desiredSpiClock;
N    uint_fast16_t msbFirst;
N    uint_fast16_t clockPhase;
N    uint_fast16_t clockPolarity;
N    uint_fast16_t spiMode;
N} eUSCI_SPI_MasterConfig;
N
N//*****************************************************************************
N//
N//!     ypedef eUSCI_SPI_SlaveConfig
N//! \brief Type definition for \link _eUSCI_SPI_SlaveConfig \endlink structure
N//!
N//! \struct _eUSCI_SPI_SlaveConfig
N//! \brief Configuration structure for slave mode in the \b SPI module. See
N//!          \link SPI_initSlave \endlink for parameter documentation.
N//
N//*****************************************************************************
Ntypedef struct _eUSCI_SPI_SlaveConfig
N{
N    uint_fast16_t msbFirst;
N    uint_fast16_t clockPhase;
N    uint_fast16_t clockPolarity;
N    uint_fast16_t spiMode;
N} eUSCI_SPI_SlaveConfig;
N
N//*****************************************************************************
N//
N//! Initializes the SPI Master block.
N//!
N//! \param moduleInstance is the instance of the eUSCI A/B module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_A0_BASE
N//!         - \b EUSCI_A1_BASE
N//!         - \b EUSCI_A2_BASE
N//!         - \b EUSCI_A3_BASE
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//! \param config Configuration structure for SPI master mode
N//!
N//! <hr>
N//! <b>Configuration options for \link eUSCI_SPI_MasterConfig \endlink structure.</b>
N//! <hr>
N//!
N//! \param selectClockSource selects clock source. Valid values are
N//!         - \b  EUSCI_SPI_CLOCKSOURCE_ACLK
N//!         - \b  EUSCI_SPI_CLOCKSOURCE_SMCLK
N//! \param clockSourceFrequency is the frequency of the selected clock source
N//! \param desiredSpiClock is the desired clock rate for SPI communication
N//! \param msbFirst controls the direction of the receive and transmit shift
N//!      register. Valid values are
N//!         - \b  EUSCI_SPI_MSB_FIRST
N//!         - \b  EUSCI_SPI_LSB_FIRST [Default Value]
N//! \param clockPhase is clock phase select.
N//!         Valid values are
N//!         - \b  EUSCI_SPI_PHASE_DATA_CHANGED_ONFIRST_CAPTURED_ON_NEXT
N//!                                                          [Default Value]
N//!         - \b  EUSCI_SPI_PHASE_DATA_CAPTURED_ONFIRST_CHANGED_ON_NEXT
N//! \param clockPolarity is clock polarity select.
N//!         Valid values are
N//!         - \b  EUSCI_SPI_CLOCKPOLARITY_INACTIVITY_HIGH
N//!         - \b  EUSCI_SPI_CLOCKPOLARITY_INACTIVITY_LOW  [Default Value]
N//! \param spiMode is SPI mode select.
N//!         Valid values are
N//!         - \b  EUSCI_SPI_3PIN [Default Value]
N//!         - \b  EUSCI_SPI_4PIN_UCxSTE_ACTIVE_HIGH
N//!         - \b  EUSCI_SPI_4PIN_UCxSTE_ACTIVE_LOW
N//! Upon successful initialization of the SPI master block, this function
N//! will have set the bus speed for the master, but the SPI Master block
N//! still remains disabled and must be enabled with SPI_enableModule()
N//!
N//! Modified bits are \b UCCKPH, \b UCCKPL, \b UC7BIT, \b UCMSB,\b UCSSELx,
N//! \b UCSWRST bits of \b UCAxCTLW0 register
N//!
N//! \return true
N//
N//*****************************************************************************
Nextern bool SPI_initMaster(uint32_t moduleInstance,
N        const eUSCI_SPI_MasterConfig *config);
N
N//*****************************************************************************
N//
N//! Selects 4Pin Functionality
N//!
N//! \param moduleInstance is the instance of the eUSCI A/B module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_A0_BASE
N//!         - \b EUSCI_A1_BASE
N//!         - \b EUSCI_A2_BASE
N//!         - \b EUSCI_A3_BASE
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//!
N//! \param select4PinFunctionality selects Clock source. Valid values are
N//!         - \b EUSCI_SPI_PREVENT_CONFLICTS_WITH_OTHER_MASTERS
N//!         - \b EUSCI_SPI_ENABLE_SIGNAL_FOR_4WIRE_SLAVE
N//! This function should be invoked only in 4-wire mode. Invoking this function
N//! has no effect in 3-wire mode.
N//!
N//! Modified bits are \b UCSTEM bit of \b UCAxCTLW0 register
N//!
N//! \return true
N//
N//*****************************************************************************
Nextern void SPI_selectFourPinFunctionality(uint32_t moduleInstance,
N        uint_fast8_t select4PinFunctionality);
N
N//*****************************************************************************
N//
N//! Initializes the SPI Master clock.At the end of this function call, SPI
N//! module is left enabled.
N//!
N//! \param moduleInstance is the instance of the eUSCI A/B module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_A0_BASE
N//!         - \b EUSCI_A1_BASE
N//!         - \b EUSCI_A2_BASE
N//!         - \b EUSCI_A3_BASE
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//!
N//! \param clockSourceFrequency is the frequency of the selected clock source
N//! \param desiredSpiClock is the desired clock rate for SPI communication.
N//!
N//! Modified bits are \b UCSWRST bit of \b UCAxCTLW0 register and
N//! \b UCAxBRW register
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void SPI_changeMasterClock(uint32_t moduleInstance,
N        uint32_t clockSourceFrequency, uint32_t desiredSpiClock);
N
N//*****************************************************************************
N//
N//! Initializes the SPI Slave block.
N//!
N//! \param moduleInstance is the instance of the eUSCI A/B module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_A0_BASE
N//!         - \b EUSCI_A1_BASE
N//!         - \b EUSCI_A2_BASE
N//!         - \b EUSCI_A3_BASE
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//! \param config Configuration structure for SPI slave mode
N//!
N//! <hr>
N//! <b>Configuration options for \link eUSCI_SPI_SlaveConfig \endlink structure.</b>
N//! <hr>
N//!
N//! \param msbFirst controls the direction of the receive and transmit shift
N//!      register. Valid values are
N//!         - \b  EUSCI_SPI_MSB_FIRST
N//!         - \b  EUSCI_SPI_LSB_FIRST [Default Value]
N//! \param clockPhase is clock phase select.
N//!         Valid values are
N//!         - \b  EUSCI_SPI_PHASE_DATA_CHANGED_ONFIRST_CAPTURED_ON_NEXT
N//!                                                          [Default Value]
N//!         - \b  EUSCI_SPI_PHASE_DATA_CAPTURED_ONFIRST_CHANGED_ON_NEXT
N//! \param clockPolarity is clock polarity select.
N//!         Valid values are
N//!         - \b  EUSCI_SPI_CLOCKPOLARITY_INACTIVITY_HIGH
N//!         - \b  EUSCI_SPI_CLOCKPOLARITY_INACTIVITY_LOW [Default Value]
N//! \param spiMode is SPI mode select.
N//!         Valid values are
N//!         - \b  EUSCI_SPI_3PIN [Default Value]
N//!         - \b  EUSCI_SPI_4PIN_UCxSTE_ACTIVE_HIGH
N//!         - \b  EUSCI_SPI_4PIN_UCxSTE_ACTIVE_LOW
N//! Upon successful initialization of the SPI slave block, this function
N//! will have initialized the slave block, but the SPI Slave block
N//! still remains disabled and must be enabled with SPI_enableModule()
N//!
N//! Modified bits are \b UCMSB, \b UC7BIT, \b UCMST, \b UCCKPL, \b UCCKPH,
N//! \b UCMODE, \b UCSWRST bits of \b UCAxCTLW0
N//!
N//! \return true
N//*****************************************************************************
Nextern bool SPI_initSlave(uint32_t moduleInstance,
N        const eUSCI_SPI_SlaveConfig *config);
N
N//*****************************************************************************
N//
N//! Changes the SPI clock phase and polarity.At the end of this function call,
N//! SPI module is left enabled.
N//!
N//! \param moduleInstance is the instance of the eUSCI A/B module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_A0_BASE
N//!         - \b EUSCI_A1_BASE
N//!         - \b EUSCI_A2_BASE
N//!         - \b EUSCI_A3_BASE
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//!
N//! \param clockPhase is clock phase select.
N//!         Valid values are:
N//!             - \b EUSCI_SPI_PHASE_DATA_CHANGED_ONFIRST_CAPTURED_ON_NEXT
N//!                                                          [Default Value]
N//!             - \b EUSCI_SPI_PHASE_DATA_CAPTURED_ONFIRST_CHANGED_ON_NEXT
N//! \param clockPolarity is clock polarity select.
N//!         Valid values are:
N//!             - \b EUSCI_SPI_CLOCKPOLARITY_INACTIVITY_HIGH
N//!             - \b EUSCI_SPI_CLOCKPOLARITY_INACTIVITY_LOW  [Default Value]
N//!
N//! Modified bits are \b UCSWRST, \b UCCKPH, \b UCCKPL, \b UCSWRST bits of
N//! \b UCAxCTLW0
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void SPI_changeClockPhasePolarity(uint32_t moduleInstance,
N        uint_fast16_t clockPhase, uint_fast16_t clockPolarity);
N
N//*****************************************************************************
N//
N//! Transmits a byte from the SPI Module.
N//!
N//! \param moduleInstance is the instance of the eUSCI A/B module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_A0_BASE
N//!         - \b EUSCI_A1_BASE
N//!         - \b EUSCI_A2_BASE
N//!         - \b EUSCI_A3_BASE
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//!
N//! \param transmitData data to be transmitted from the SPI module
N//!
N//! This function will place the supplied data into SPI transmit data register
N//! to start transmission
N//!
N//! Modified register is \b UCAxTXBUF
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void SPI_transmitData(uint32_t moduleInstance,
N        uint_fast8_t transmitData);
N
N//*****************************************************************************
N//
N//! Receives a byte that has been sent to the SPI Module.
N//!
N//! \param moduleInstance is the instance of the eUSCI A/B module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_A0_BASE
N//!         - \b EUSCI_A1_BASE
N//!         - \b EUSCI_A2_BASE
N//!         - \b EUSCI_A3_BASE
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//!
N//!
N//! This function reads a byte of data from the SPI receive data Register.
N//!
N//! \return Returns the byte received from by the SPI module, cast as an
N//! uint8_t.
N//
N//*****************************************************************************
Nextern uint8_t SPI_receiveData(uint32_t moduleInstance);
N
N//*****************************************************************************
N//
N//! Enables the SPI block.
N//!
N//! \param moduleInstance is the instance of the eUSCI A/B module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_A0_BASE
N//!         - \b EUSCI_A1_BASE
N//!         - \b EUSCI_A2_BASE
N//!         - \b EUSCI_A3_BASE
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//!
N//!
N//! This will enable operation of the SPI block.
N//! Modified bits are \b UCSWRST bit of \b UCAxCTLW0 register.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void SPI_enableModule(uint32_t moduleInstance);
N
N//*****************************************************************************
N//
N//! Disables the SPI block.
N//!
N//! \param moduleInstance is the instance of the eUSCI A/B module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_A0_BASE
N//!         - \b EUSCI_A1_BASE
N//!         - \b EUSCI_A2_BASE
N//!         - \b EUSCI_A3_BASE
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//!
N//!
N//! This will disable operation of the SPI block.
N//!
N//! Modified bits are \b UCSWRST bit of \b UCAxCTLW0 register.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void SPI_disableModule(uint32_t moduleInstance);
N
N//*****************************************************************************
N//
N//! Returns the address of the RX Buffer of the SPI for the DMA module.
N//!
N//! \param moduleInstance is the instance of the eUSCI A/B module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_A0_BASE
N//!         - \b EUSCI_A1_BASE
N//!         - \b EUSCI_A2_BASE
N//!         - \b EUSCI_A3_BASE
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//!
N//!
N//! Returns the address of the SPI RX Buffer. This can be used in conjunction
N//! with the DMA to store the received data directly to memory.
N//!
N//! \return NONE
N//
N//*****************************************************************************
Nextern uint32_t SPI_getReceiveBufferAddressForDMA(uint32_t moduleInstance);
N
N//*****************************************************************************
N//
N//! Returns the address of the TX Buffer of the SPI for the DMA module.
N//!
N//! \param moduleInstance is the instance of the eUSCI A/B module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_A0_BASE
N//!         - \b EUSCI_A1_BASE
N//!         - \b EUSCI_A2_BASE
N//!         - \b EUSCI_A3_BASE
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//!
N//!
N//! Returns the address of the SPI TX Buffer. This can be used in conjunction
N//! with the DMA to obtain transmitted data directly from memory.
N//!
N//! \return NONE
N//
N//*****************************************************************************
Nextern uint32_t SPI_getTransmitBufferAddressForDMA(uint32_t moduleInstance);
N
N//*****************************************************************************
N//
N//! Indicates whether or not the SPI bus is busy.
N//!
N//! \param moduleInstance is the instance of the eUSCI A/B module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_A0_BASE
N//!         - \b EUSCI_A1_BASE
N//!         - \b EUSCI_A2_BASE
N//!         - \b EUSCI_A3_BASE
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//!
N//!
N//! This function returns an indication of whether or not the SPI bus is
N//! busy.This function checks the status of the bus via UCBBUSY bit
N//!
N//! \return EUSCI_SPI_BUSY if the SPI module transmitting or receiving
N//! is busy; otherwise, returns EUSCI_SPI_NOT_BUSY.
N//
N//*****************************************************************************
Nextern uint_fast8_t SPI_isBusy(uint32_t moduleInstance);
N
N//*****************************************************************************
N//
N//! Enables individual SPI interrupt sources.
N//!
N//! \param moduleInstance is the instance of the eUSCI A/B module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_A0_BASE
N//!         - \b EUSCI_A1_BASE
N//!         - \b EUSCI_A2_BASE
N//!         - \b EUSCI_A3_BASE
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//!
N//! \param mask is the bit mask of the interrupt sources to be enabled.
N//!
N//! Enables the indicated SPI interrupt sources.  Only the sources that
N//! are enabled can be reflected to the processor interrupt; disabled sources
N//! have no effect on the processor.
N//!
N//! The mask parameter is the logical OR of any of the following:
N//!       - \b EUSCI_SPI_RECEIVE_INTERRUPT Receive interrupt
N//!       - \b EUSCI_SPI_TRANSMIT_INTERRUPT Transmit interrupt
N//!
N//! Modified registers are \b UCAxIFG and \b UCAxIE
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void SPI_enableInterrupt(uint32_t moduleInstance, uint_fast8_t mask);
N
N//*****************************************************************************
N//
N//! Disables individual SPI interrupt sources.
N//!
N//! \param moduleInstance is the instance of the eUSCI A/B module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_A0_BASE
N//!         - \b EUSCI_A1_BASE
N//!         - \b EUSCI_A2_BASE
N//!         - \b EUSCI_A3_BASE
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//!
N//! \param mask is the bit mask of the interrupt sources to be
N//! disabled.
N//!
N//! Disables the indicated SPI interrupt sources.  Only the sources that
N//! are enabled can be reflected to the processor interrupt; disabled sources
N//! have no effect on the processor.
N//!
N//! The mask parameter is the logical OR of any of the following:
N//!       - \b EUSCI_SPI_RECEIVE_INTERRUPT Receive interrupt
N//!       - \b EUSCI_SPI_TRANSMIT_INTERRUPT Transmit interrupt
N//!
N//! Modified register is \b UCAxIE
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void SPI_disableInterrupt(uint32_t moduleInstance, uint_fast8_t mask);
N
N//*****************************************************************************
N//
N//! Gets the current SPI interrupt status.
N//!
N//! \param moduleInstance is the instance of the eUSCI A/B module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_A0_BASE
N//!         - \b EUSCI_A1_BASE
N//!         - \b EUSCI_A2_BASE
N//!         - \b EUSCI_A3_BASE
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//! \param mask Mask of interrupt to filter. This can include:
N//!          - \b EUSCI_SPI_RECEIVE_INTERRUPT -Receive interrupt
N//!          - \b EUSCI_SPI_TRANSMIT_INTERRUPT - Transmit interrupt
N//!
N//! Modified registers are \b UCAxIFG.
N//!
N//! \return The current interrupt status as the mask of the set flags
N//! Mask parameter can be either any of the following selection:
N//! - \b EUSCI_SPI_RECEIVE_INTERRUPT -Receive interrupt
N//! - \b EUSCI_SPI_TRANSMIT_INTERRUPT - Transmit interrupt
N//
N//*****************************************************************************
Nextern uint_fast8_t SPI_getInterruptStatus(uint32_t moduleInstance,
N        uint16_t mask);
N
N//*****************************************************************************
N//
N//! Gets the current SPI interrupt status masked with the enabled interrupts.
N//! This function is useful to call in ISRs to get a list of pending
N//! interrupts that are actually enabled and could have caused
N//! the ISR.
N//!
N//! \param moduleInstance is the instance of the eUSCI A/B module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_A0_BASE
N//!         - \b EUSCI_A1_BASE
N//!         - \b EUSCI_A2_BASE
N//!         - \b EUSCI_A3_BASE
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//!
N//! Modified registers are \b UCAxIFG.
N//!
N//! \return The current interrupt status as the mask of the set flags
N//! Mask parameter can be either any of the following selection:
N//! - \b EUSCI_SPI_RECEIVE_INTERRUPT -Receive interrupt
N//! - \b EUSCI_SPI_TRANSMIT_INTERRUPT - Transmit interrupt
N//
N//*****************************************************************************
Nextern uint_fast8_t SPI_getEnabledInterruptStatus(uint32_t moduleInstance);
N
N//*****************************************************************************
N//
N//! Clears the selected SPI interrupt status flag.
N//!
N//! \param moduleInstance is the instance of the eUSCI A/B module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_A0_BASE
N//!         - \b EUSCI_A1_BASE
N//!         - \b EUSCI_A2_BASE
N//!         - \b EUSCI_A3_BASE
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//!
N//! \param mask is the masked interrupt flag to be cleared.
N//!
N//! The mask parameter is the logical OR of any of the following:
N//! - \b EUSCI_SPI_RECEIVE_INTERRUPT -Receive interrupt
N//! - \b EUSCI_SPI_TRANSMIT_INTERRUPT - Transmit interrupt
N//! Modified registers are \b UCAxIFG.
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void SPI_clearInterruptFlag(uint32_t moduleInstance, uint_fast8_t mask);
N
N//*****************************************************************************
N//
N//! Registers an interrupt handler for the timer capture compare interrupt.
N//!
N//! \param moduleInstance is the instance of the eUSCI (SPI) module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_A0_BASE
N//!         - \b EUSCI_A1_BASE
N//!         - \b EUSCI_A2_BASE
N//!         - \b EUSCI_A3_BASE
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//!  It is important to note that for eUSCI modules, only "B" modules such as
N//!  EUSCI_B0 can be used. "A" modules such as EUSCI_A0 do not support the
N//!  I2C mode.
N//!
N//! \param intHandler is a pointer to the function to be called when the
N//! timer capture compare interrupt occurs.
N//!
N//! This function registers the handler to be called when a timer
N//! interrupt occurs. This function enables the global interrupt in the
N//! interrupt controller; specific SPI interrupts must be enabled
N//! via SPI_enableInterrupt().  It is the interrupt handler's responsibility to
N//! clear the interrupt source via SPI_clearInterruptFlag().
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void SPI_registerInterrupt(uint32_t moduleInstance,
N        void (*intHandler)(void));
N
N//*****************************************************************************
N//
N//! Unregisters the interrupt handler for the timer
N//!
N//! \param moduleInstance is the instance of the eUSCI A/B module. Valid
N//! parameters vary from part to part, but can include:
N//!         - \b EUSCI_A0_BASE
N//!         - \b EUSCI_A1_BASE
N//!         - \b EUSCI_A2_BASE
N//!         - \b EUSCI_A3_BASE
N//!         - \b EUSCI_B0_BASE
N//!         - \b EUSCI_B1_BASE
N//!         - \b EUSCI_B2_BASE
N//!         - \b EUSCI_B3_BASE
N//!
N//! This function unregisters the handler to be called when timer
N//! interrupt occurs.  This function also masks off the interrupt in the
N//! interrupt controller so that the interrupt handler no longer is called.
N//!
N//! \sa Interrupt_registerInterrupt() for important information about
N//! registering interrupt handlers.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void SPI_unregisterInterrupt(uint32_t moduleInstance);
N
N/* Backwards Compatibility Layer */
N#define EUSCI_B_SPI_PHASE_DATA_CHANGED_ONFIRST_CAPTURED_ON_NEXT            0x00
N#define EUSCI_B_SPI_PHASE_DATA_CAPTURED_ONFIRST_CHANGED_ON_NEXT          UCCKPH
N
N#define EUSCI_B_SPI_MSB_FIRST                                             UCMSB
N#define EUSCI_B_SPI_LSB_FIRST                                              0x00
N
N#define EUSCI_B_SPI_CLOCKPOLARITY_INACTIVITY_HIGH                        UCCKPL
N#define EUSCI_B_SPI_CLOCKPOLARITY_INACTIVITY_LOW                           0x00
N
N#define EUSCI_B_SPI_CLOCKSOURCE_ACLK                               UCSSEL__ACLK
N#define EUSCI_B_SPI_CLOCKSOURCE_SMCLK                             UCSSEL__SMCLK
N
N#define EUSCI_B_SPI_3PIN                                               UCMODE_0
N#define EUSCI_B_SPI_4PIN_UCxSTE_ACTIVE_HIGH                            UCMODE_1
N#define EUSCI_B_SPI_4PIN_UCxSTE_ACTIVE_LOW                             UCMODE_2
N
N#define EUSCI_B_SPI_PREVENT_CONFLICTS_WITH_OTHER_MASTERS                   0x00
N#define EUSCI_B_SPI_ENABLE_SIGNAL_FOR_4WIRE_SLAVE                        UCSTEM
N
N#define EUSCI_B_SPI_TRANSMIT_INTERRUPT                                   UCTXIE
N#define EUSCI_B_SPI_RECEIVE_INTERRUPT                                    UCRXIE
N
N#define EUSCI_B_SPI_BUSY                                                 UCBUSY
N#define EUSCI_B_SPI_NOT_BUSY                                               0x00
N
N#define EUSCI_A_SPI_PHASE_DATA_CHANGED_ONFIRST_CAPTURED_ON_NEXT            0x00
N#define EUSCI_A_SPI_PHASE_DATA_CAPTURED_ONFIRST_CHANGED_ON_NEXT          UCCKPH
N
N#define EUSCI_A_SPI_MSB_FIRST                                             UCMSB
N#define EUSCI_A_SPI_LSB_FIRST                                              0x00
N
N#define EUSCI_A_SPI_CLOCKPOLARITY_INACTIVITY_HIGH                        UCCKPL
N#define EUSCI_A_SPI_CLOCKPOLARITY_INACTIVITY_LOW                           0x00
N
N#define EUSCI_A_SPI_CLOCKSOURCE_ACLK                               UCSSEL__ACLK
N#define EUSCI_A_SPI_CLOCKSOURCE_SMCLK                             UCSSEL__SMCLK
N
N#define EUSCI_A_SPI_3PIN                                               UCMODE_0
N#define EUSCI_A_SPI_4PIN_UCxSTE_ACTIVE_HIGH                            UCMODE_1
N#define EUSCI_A_SPI_4PIN_UCxSTE_ACTIVE_LOW                             UCMODE_2
N
N#define EUSCI_A_SPI_PREVENT_CONFLICTS_WITH_OTHER_MASTERS                   0x00
N#define EUSCI_A_SPI_ENABLE_SIGNAL_FOR_4WIRE_SLAVE                        UCSTEM
N
N#define EUSCI_A_SPI_TRANSMIT_INTERRUPT                                   UCTXIE
N#define EUSCI_A_SPI_RECEIVE_INTERRUPT                                    UCRXIE
N
N#define EUSCI_A_SPI_BUSY                                                 UCBUSY
N#define EUSCI_A_SPI_NOT_BUSY                                               0x00
N
Nextern void EUSCI_A_SPI_select4PinFunctionality(uint32_t baseAddress,
N        uint8_t select4PinFunctionality);
Nextern void EUSCI_A_SPI_masterChangeClock(uint32_t baseAddress,
N        uint32_t clockSourceFrequency, uint32_t desiredSpiClock);
Nextern bool EUSCI_A_SPI_slaveInit(uint32_t baseAddress, uint16_t msbFirst,
N        uint16_t clockPhase, uint16_t clockPolarity, uint16_t spiMode);
Nextern void EUSCI_A_SPI_changeClockPhasePolarity(uint32_t baseAddress,
N        uint16_t clockPhase, uint16_t clockPolarity);
Nextern void EUSCI_A_SPI_transmitData(uint32_t baseAddress,
N        uint8_t transmitData);
Nextern uint8_t EUSCI_A_SPI_receiveData(uint32_t baseAddress);
Nextern void EUSCI_A_SPI_enableInterrupt(uint32_t baseAddress, uint8_t mask);
Nextern void EUSCI_A_SPI_disableInterrupt(uint32_t baseAddress, uint8_t mask);
Nextern uint8_t EUSCI_A_SPI_getInterruptStatus(uint32_t baseAddress,
N        uint8_t mask);
Nextern void EUSCI_A_SPI_clearInterruptFlag(uint32_t baseAddress, uint8_t mask);
Nextern void EUSCI_A_SPI_enable(uint32_t baseAddress);
Nextern void EUSCI_A_SPI_disable(uint32_t baseAddress);
Nextern uint32_t EUSCI_A_SPI_getReceiveBufferAddressForDMA(uint32_t baseAddress);
Nextern uint32_t EUSCI_A_SPI_getTransmitBufferAddressForDMA(
N        uint32_t baseAddress);
Nextern bool EUSCI_A_SPI_isBusy(uint32_t baseAddress);
Nextern void EUSCI_B_SPI_select4PinFunctionality(uint32_t baseAddress,
N        uint8_t select4PinFunctionality);
Nextern void EUSCI_B_SPI_masterChangeClock(uint32_t baseAddress,
N        uint32_t clockSourceFrequency, uint32_t desiredSpiClock);
Nextern bool EUSCI_B_SPI_slaveInit(uint32_t baseAddress, uint16_t msbFirst,
N        uint16_t clockPhase, uint16_t clockPolarity, uint16_t spiMode);
Nextern void EUSCI_B_SPI_changeClockPhasePolarity(uint32_t baseAddress,
N        uint16_t clockPhase, uint16_t clockPolarity);
Nextern void EUSCI_B_SPI_transmitData(uint32_t baseAddress,
N        uint8_t transmitData);
Nextern uint8_t EUSCI_B_SPI_receiveData(uint32_t baseAddress);
Nextern void EUSCI_B_SPI_enableInterrupt(uint32_t baseAddress, uint8_t mask);
Nextern void EUSCI_B_SPI_disableInterrupt(uint32_t baseAddress, uint8_t mask);
Nextern uint8_t EUSCI_B_SPI_getInterruptStatus(uint32_t baseAddress,
N        uint8_t mask);
Nextern void EUSCI_B_SPI_clearInterruptFlag(uint32_t baseAddress, uint8_t mask);
Nextern void EUSCI_B_SPI_enable(uint32_t baseAddress);
Nextern void EUSCI_B_SPI_disable(uint32_t baseAddress);
Nextern uint32_t EUSCI_B_SPI_getReceiveBufferAddressForDMA(uint32_t baseAddress);
Nextern uint32_t EUSCI_B_SPI_getTransmitBufferAddressForDMA(
N        uint32_t baseAddress);
Nextern bool EUSCI_B_SPI_isBusy(uint32_t baseAddress);
N
N//*****************************************************************************
N//
N// Mark the end of the C bindings section for C++ compilers.
N//
N//*****************************************************************************
N#ifdef __cplusplus
N}
N#endif
N
N//*****************************************************************************
N//
N// Close the Doxygen group.
N//! @}
N//
N//*****************************************************************************
N
N#endif /* SPI_H_ */
N
L 63 "C:/ti/msp432_driverlib_3_21_00_05/driverlib/MSP432P4xx/driverlib.h" 2
N#include "sysctl.h"
L 1 "C:\ti\msp432_driverlib_3_21_00_05\driverlib\MSP432P4xx\sysctl.h" 1
N/*
N * -------------------------------------------
N *    MSP432 DriverLib - v3_21_00_05 
N * -------------------------------------------
N *
N * --COPYRIGHT--,BSD,BSD
N * Copyright (c) 2016, Texas Instruments Incorporated
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N *
N * *  Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N *
N * *  Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * *  Neither the name of Texas Instruments Incorporated nor the names of
N *    its contributors may be used to endorse or promote products derived
N *    from this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
N * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
N * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
N * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
N * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
N * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
N * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
N * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
N * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * --/COPYRIGHT--*/
N#ifndef __SYSCTL_H__
N#define __SYSCTL_H__
N
N//*****************************************************************************
N//
N//! \addtogroup sysctl_api
N//! @{
N//
N//*****************************************************************************
N
N//*****************************************************************************
N//
N// If building with a C++ compiler, make all of the definitions in this header
N// have a C binding.
N//
N//*****************************************************************************
N#ifdef __cplusplus
Nextern "C"
N{
N#endif
N
N#include <stdint.h>
N#include <msp.h>
N
N//*****************************************************************************
N//
N// Control specific variables 
N//
N//*****************************************************************************
N#define SYSCTL_SRAM_BANK7 SYSCTL_SRAM_BANKEN_BNK7_EN
N#define SYSCTL_SRAM_BANK6 SYSCTL_SRAM_BANKEN_BNK6_EN
N#define SYSCTL_SRAM_BANK5 SYSCTL_SRAM_BANKEN_BNK5_EN
N#define SYSCTL_SRAM_BANK4 SYSCTL_SRAM_BANKEN_BNK4_EN
N#define SYSCTL_SRAM_BANK3 SYSCTL_SRAM_BANKEN_BNK3_EN
N#define SYSCTL_SRAM_BANK2 SYSCTL_SRAM_BANKEN_BNK2_EN
N#define SYSCTL_SRAM_BANK1 SYSCTL_SRAM_BANKEN_BNK1_EN
N
N#define SYSCTL_HARD_RESET 1
N#define SYSCTL_SOFT_RESET 0
N
N#define SYSCTL_PERIPH_DMA SYSCTL_PERIHALT_CTL_HALT_DMA
N#define SYSCTL_PERIPH_WDT SYSCTL_PERIHALT_CTL_HALT_WDT
N#define SYSCTL_PERIPH_ADC SYSCTL_PERIHALT_CTL_HALT_ADC
N#define SYSCTL_PERIPH_EUSCIB3 SYSCTL_PERIHALT_CTL_HALT_EUB3
N#define SYSCTL_PERIPH_EUSCIB2 SYSCTL_PERIHALT_CTL_HALT_EUB2
N#define SYSCTL_PERIPH_EUSCIB1 SYSCTL_PERIHALT_CTL_HALT_EUB1
N#define SYSCTL_PERIPH_EUSCIB0 SYSCTL_PERIHALT_CTL_HALT_EUB0
N#define SYSCTL_PERIPH_EUSCIA3 SYSCTL_PERIHALT_CTL_HALT_EUA3
N#define SYSCTL_PERIPH_EUSCIA2 SYSCTL_PERIHALT_CTL_HALT_EUA2
N#define SYSCTL_PERIPH_EUSCIA1 SYSCTL_PERIHALT_CTL_HALT_EUA1
N#define SYSCTL_PERIPH_EUSCIA0 SYSCTL_PERIHALT_CTL_HALT_EUA0
N#define SYSCTL_PERIPH_TIMER32_0_MODULE SYSCTL_PERIHALT_CTL_HALT_T32_0
N#define SYSCTL_PERIPH_TIMER16_3 SYSCTL_PERIHALT_CTL_HALT_T16_3
N#define SYSCTL_PERIPH_TIMER16_2 SYSCTL_PERIHALT_CTL_HALT_T16_2
N#define SYSCTL_PERIPH_TIMER16_1 SYSCTL_PERIHALT_CTL_HALT_T16_1
N#define SYSCTL_PERIPH_TIMER16_0 SYSCTL_PERIHALT_CTL_HALT_T16_0
N
N#define SYSCTL_NMIPIN_SRC SYSCTL_NMI_CTLSTAT_PIN_SRC
N#define SYSCTL_PCM_SRC SYSCTL_NMI_CTLSTAT_PCM_SRC
N#define SYSCTL_PSS_SRC SYSCTL_NMI_CTLSTAT_PSS_SRC
N#define SYSCTL_CS_SRC SYSCTL_NMI_CTLSTAT_CS_SRC
N
N#define SYSCTL_REBOOT_KEY   0x6900
N
N#define SYSCTL_1_2V_REF        (uint32_t)&TLV->ADC14_REF1P2V_TS30C - (uint32_t)TLV_BASE
N#define SYSCTL_1_45V_REF       (uint32_t)&TLV->ADC14_REF1P45V_TS30C - (uint32_t)TLV_BASE
N#define SYSCTL_2_5V_REF        (uint32_t)&TLV->ADC14_REF2P5V_TS30C - (uint32_t)TLV_BASE
N
N#define SYSCTL_85_DEGREES_C    4
N#define SYSCTL_30_DEGREES_C    0
N
N
N#define TLV_START               0x00201004
N#define TLV_TAG_RESERVED1      1
N#define TLV_TAG_RESERVED2      2
N#define TLV_TAG_CS             3
N#define TLV_TAG_FLASHCTL       4
N#define TLV_TAG_ADC14          5
N#define TLV_TAG_RESERVED6      6
N#define TLV_TAG_RESERVED7      7
N#define TLV_TAG_REF            8
N#define TLV_TAG_RESERVED9      9
N#define TLV_TAG_RESERVED10     10
N#define TLV_TAG_DEVINFO        11
N#define TLV_TAG_DIEREC         12
N#define TLV_TAG_RANDNUM        13
N#define TLV_TAG_RESERVED14     14
N#define TLV_TAG_BSL            15
N#define TLV_TAGEND             0x0BD0E11D
N
N//*****************************************************************************
N//
N// Structures for TLV definitions
N// 
N//*****************************************************************************
Ntypedef struct
N{
N    uint32_t    maxProgramPulses;
N    uint32_t    maxErasePulses;
N} SysCtl_FlashTLV_Info;
N
Ntypedef struct
N{
N    uint32_t rDCOIR_FCAL_RSEL04;
N    uint32_t rDCOIR_FCAL_RSEL5;
N    uint32_t rDCOIR_MAXPOSTUNE_RSEL04;
N    uint32_t rDCOIR_MAXNEGTUNE_RSEL04;
N    uint32_t rDCOIR_MAXPOSTUNE_RSEL5;
N    uint32_t rDCOIR_MAXNEGTUNE_RSEL5;
N    uint32_t rDCOIR_CONSTK_RSEL04;
N    uint32_t rDCOIR_CONSTK_RSEL5;
N    uint32_t rDCOER_FCAL_RSEL04;
N    uint32_t rDCOER_FCAL_RSEL5;
N    uint32_t rDCOER_MAXPOSTUNE_RSEL04;
N    uint32_t rDCOER_MAXNEGTUNE_RSEL04;
N    uint32_t rDCOER_MAXPOSTUNE_RSEL5;
N    uint32_t rDCOER_MAXNEGTUNE_RSEL5;
N    uint32_t rDCOER_CONSTK_RSEL04;
N    uint32_t rDCOER_CONSTK_RSEL5;
N
N} SysCtl_CSCalTLV_Info;
N
N//*****************************************************************************
N//
N// Prototypes for the APIs.
N//
N//*****************************************************************************
N
N//*****************************************************************************
N//
N//! Gets the size of the SRAM.
N//!
N//! \return The total number of bytes of SRAM.
N//
N//*****************************************************************************
Nextern uint_least32_t SysCtl_getSRAMSize(void);
N
N//*****************************************************************************
N//
N//! Gets the size of the flash.
N//!
N//! \return The total number of bytes of flash.
N//
N//*****************************************************************************
Nextern uint_least32_t SysCtl_getFlashSize(void);
N
N//*****************************************************************************
N//
N//! Reboots the device and causes the device to re-initialize itself.
N//!
N//! \return This function does not return.
N//
N//*****************************************************************************
Nextern void SysCtl_rebootDevice(void);
N
N//*****************************************************************************
N//
N//! The TLV structure uses a tag or base address to identify segments of the
N//! table where information is stored. Some examples of TLV tags are Peripheral
N//! Descriptor, Interrupts, Info Block and Die Record. This function retrieves
N//! the value of a tag and the length of the tag.
N//!
N//! \param tag represents the tag for which the information needs to be
N//!        retrieved.
N//!        Valid values are:
N//!        - \b TLV_TAG_RESERVED1
N//!        - \b TLV_TAG_RESERVED2
N//!        - \b TLV_TAG_CS
N//!        - \b TLV_TAG_FLASHCTL
N//!        - \b TLV_TAG_ADC14
N//!        - \b TLV_TAG_RESERVED6
N//!        - \b TLV_TAG_RESERVED7
N//!        - \b TLV_TAG_REF
N//!        - \b TLV_TAG_RESERVED9
N//!        - \b TLV_TAG_RESERVED10
N//!        - \b TLV_TAG_DEVINFO
N//!        - \b TLV_TAG_DIEREC
N//!        - \b TLV_TAG_RANDNUM
N//!        - \b TLV_TAG_RESERVED14
N//! \param instance In some cases a specific tag may have more than one
N//!        instance. For example there may be multiple instances of timer
N//!        calibration data present under a single Timer Cal tag. This variable
N//!        specifies the instance for which information is to be retrieved (0,
N//!        1, etc.). When only one instance exists; 0 is passed.
N//! \param length Acts as a return through indirect reference. The function
N//!        retrieves the value of the TLV tag length. This value is pointed to
N//!        by *length and can be used by the application level once the
N//!        function is called. If the specified tag is not found then the
N//!        pointer is null 0.
N//! \param data_address acts as a return through indirect reference. Once the
N//!        function is called data_address points to the pointer that holds the
N//!        value retrieved from the specified TLV tag. If the specified tag is
N//!        not found then the pointer is null 0.
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void SysCtl_getTLVInfo(uint_fast8_t tag, uint_fast8_t instance,
N        uint_fast8_t *length, uint32_t **data_address);
N
N//*****************************************************************************
N//
N//! Enables a set of banks in the SRAM. This can be used to optimize power
N//! consumption when every SRAM bank isn't needed. It is important to note
N//! that when a  higher bank is enabled, all of the SRAM banks below that bank
N//! are also enabled. For example, if the user enables SYSCTL_SRAM_BANK7,
N//! the banks SYSCTL_SRAM_BANK1 through SYSCTL_SRAM_BANK7 will be enabled
N//! (SRAM_BANK0 is reserved and always enabled).
N//!
N//! \param sramBank The SRAM bank tier to enable.
N//!        Must be only one of the following values:
N//!                 - \b SYSCTL_SRAM_BANK1,
N//!                 - \b SYSCTL_SRAM_BANK2,
N//!                 - \b SYSCTL_SRAM_BANK3,
N//!                 - \b SYSCTL_SRAM_BANK4,
N//!                 - \b SYSCTL_SRAM_BANK5,
N//!                 - \b SYSCTL_SRAM_BANK6,
N//!                 - \b SYSCTL_SRAM_BANK7
N//!
N//! \note \b SYSCTL_SRAM_BANK0 is reserved and always enabled.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void SysCtl_enableSRAMBank(uint_fast8_t sramBank);
N
N//*****************************************************************************
N//
N//! Disables a set of banks in the SRAM. This can be used to optimize power
N//! consumption when every SRAM bank isn't needed. It is important to note
N//! that when a  higher bank is disabled, all of the SRAM banks above that bank
N//! are also disabled. For example, if the user disables SYSCTL_SRAM_BANK5,
N//! the banks SYSCTL_SRAM_BANK6 through SYSCTL_SRAM_BANK7 will be disabled.
N//!
N//! \param sramBank The SRAM bank tier to disable.
N//!        Must be only one of the following values:
N//!                 - \b SYSCTL_SRAM_BANK1,
N//!                 - \b SYSCTL_SRAM_BANK2,
N//!                 - \b SYSCTL_SRAM_BANK3,
N//!                 - \b SYSCTL_SRAM_BANK4,
N//!                 - \b SYSCTL_SRAM_BANK5,
N//!                 - \b SYSCTL_SRAM_BANK6,
N//!                 - \b SYSCTL_SRAM_BANK7
N//!
N//! \note \b SYSCTL_SRAM_BANK0 is reserved and always enabled.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void SysCtl_disableSRAMBank(uint_fast8_t sramBank);
N
N//*****************************************************************************
N//
N//! Enables retention of the specified SRAM bank register when the device goes
N//! into LPM3 mode. When the system is placed in LPM3 mode, the SRAM
N//! banks specified with this function will be placed into retention mode. By
N//! default, retention of every SRAM bank except SYSCTL_SRAM_BANK0 (reserved) is
N//! disabled. Retention of individual banks can be set without the restrictions
N//! of the enable/disable functions.
N//!
N//! \param sramBank The SRAM banks to enable retention
N//!        Can be a bitwise OR of the following values:
N//!                 - \b SYSCTL_SRAM_BANK1,
N//!                 - \b SYSCTL_SRAM_BANK2,
N//!                 - \b SYSCTL_SRAM_BANK3,
N//!                 - \b SYSCTL_SRAM_BANK4,
N//!                 - \b SYSCTL_SRAM_BANK5,
N//!                 - \b SYSCTL_SRAM_BANK6,
N//!                 - \b SYSCTL_SRAM_BANK7
N//! \note  \b SYSCTL_SRAM_BANK0 is reserved and retention is always enabled.
N//!
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void SysCtl_enableSRAMBankRetention(uint_fast8_t sramBank);
N
N//*****************************************************************************
N//
N//! Disables retention of the specified SRAM bank register when the device goes
N//! into LPM3 mode. When the system is placed in LPM3 mode, the SRAM
N//! banks specified with this function will not be placed into retention mode.
N//! By default, retention of every SRAM bank except SYSCTL_SRAM_BANK0 (reserved)
N//! is disabled. Retention of individual banks can be set without the
N//! restrictions of the enable/disable SRAM bank functions.
N//!
N//! \param sramBank The SRAM banks to disable retention
N//!        Can be a bitwise OR of the following values:
N//!                 - \b SYSCTL_SRAM_BANK1,
N//!                 - \b SYSCTL_SRAM_BANK2,
N//!                 - \b SYSCTL_SRAM_BANK3,
N//!                 - \b SYSCTL_SRAM_BANK4,
N//!                 - \b SYSCTL_SRAM_BANK5,
N//!                 - \b SYSCTL_SRAM_BANK6,
N//!                 - \b SYSCTL_SRAM_BANK7
N//! \note  \b SYSCTL_SRAM_BANK0 is reserved and retention is always enabled.
N//!
N//! \return None.
N//
N//
N//*****************************************************************************
Nextern void SysCtl_disableSRAMBankRetention(uint_fast8_t sramBank);
N
N//*****************************************************************************
N//
N//! Makes it so that the provided peripherals will either halt execution after
N//! a CPU HALT. Parameters in this function can be combined to account for
N//! multiple peripherals. By default, all peripherals keep running after a
N//! CPU HALT.
N//!
N//! \param devices The peripherals to continue running after a CPU HALT
N//!         This can be a bitwise OR of the following values:
N//!                 - \b SYSCTL_PERIPH_DMA,
N//!                 - \b SYSCTL_PERIPH_WDT,
N//!                 - \b SYSCTL_PERIPH_ADC,
N//!                 - \b SYSCTL_PERIPH_EUSCIB3,
N//!                 - \b SYSCTL_PERIPH_EUSCIB2,
N//!                 - \b SYSCTL_PERIPH_EUSCIB1
N//!                 - \b SYSCTL_PERIPH_EUSCIB0,
N//!                 - \b SYSCTL_PERIPH_EUSCIA3,
N//!                 - \b SYSCTL_PERIPH_EUSCIA2
N//!                 - \b SYSCTL_PERIPH_EUSCIA1,
N//!                 - \b SYSCTL_PERIPH_EUSCIA0,
N//!                 - \b SYSCTL_PERIPH_TIMER32_0_MODULE,
N//!                 - \b SYSCTL_PERIPH_TIMER16_3,
N//!                 - \b SYSCTL_PERIPH_TIMER16_2,
N//!                 - \b SYSCTL_PERIPH_TIMER16_1,
N//!                 - \b SYSCTL_PERIPH_TIMER16_0
N//!
N//! \return None.
N//
N//
N//*****************************************************************************
Nextern void SysCtl_enablePeripheralAtCPUHalt(uint_fast16_t devices);
N
N//*****************************************************************************
N//
N//! Makes it so that the provided peripherals will either halt execution after
N//! a CPU HALT. Parameters in this function can be combined to account for
N//! multiple peripherals. By default, all peripherals keep running after a
N//! CPU HALT.
N//!
N//! \param devices The peripherals to disable after a CPU HALT
N//!
N//! The \e devices parameter can be a bitwise OR of the following values:
N//!         This can be a bitwise OR of the following values:
N//!                 - \b SYSCTL_PERIPH_DMA,
N//!                 - \b SYSCTL_PERIPH_WDT,
N//!                 - \b SYSCTL_PERIPH_ADC,
N//!                 - \b SYSCTL_PERIPH_EUSCIB3,
N//!                 - \b SYSCTL_PERIPH_EUSCIB2,
N//!                 - \b SYSCTL_PERIPH_EUSCIB1
N//!                 - \b SYSCTL_PERIPH_EUSCIB0,
N//!                 - \b SYSCTL_PERIPH_EUSCIA3,
N//!                 - \b SYSCTL_PERIPH_EUSCIA2
N//!                 - \b SYSCTL_PERIPH_EUSCIA1,
N//!                 - \b SYSCTL_PERIPH_EUSCIA0,
N//!                 - \b SYSCTL_PERIPH_TIMER32_0_MODULE,
N//!                 - \b SYSCTL_PERIPH_TIMER16_3,
N//!                 - \b SYSCTL_PERIPH_TIMER16_2,
N//!                 - \b SYSCTL_PERIPH_TIMER16_1,
N//!                 - \b SYSCTL_PERIPH_TIMER16_0
N//!
N//! \return None.
N//
N//
N//*****************************************************************************
Nextern void SysCtl_disablePeripheralAtCPUHalt(uint_fast16_t devices);
N
N//*****************************************************************************
N//
N//! Sets the type of RESET that happens when a watchdog timeout occurs.
N//!
N//! \param resetType The type of reset to set
N//!
N//! The \e resetType parameter must be only one of the following values:
N//!         - \b SYSCTL_HARD_RESET,
N//!         - \b SYSCTL_SOFT_RESET
N//!
N//! \return None.
N//
N//
N//*****************************************************************************
Nextern void SysCtl_setWDTTimeoutResetType(uint_fast8_t resetType);
N
N//*****************************************************************************
N//
N//! Sets the type of RESET that happens when a watchdog password violation
N//! occurs.
N//!
N//! \param resetType The type of reset to set
N//!
N//! The \e resetType parameter must be only one of the following values:
N//!         - \b SYSCTL_HARD_RESET,
N//!         - \b SYSCTL_SOFT_RESET
N//!
N//! \return None.
N//
N//
N//*****************************************************************************
Nextern void SysCtl_setWDTPasswordViolationResetType(uint_fast8_t resetType);
N
N//*****************************************************************************
N//
N//! Disables NMIs for the provided modules. When disabled, a NMI flag will not
N//! occur when a fault condition comes from the corresponding modules.
N//!
N//! \param flags The NMI sources to disable
N//! Can be a bitwise OR of the following parameters:
N//!         - \b SYSCTL_NMIPIN_SRC,
N//!         - \b SYSCTL_PCM_SRC,
N//!         - \b SYSCTL_PSS_SRC,
N//!         - \b SYSCTL_CS_SRC
N//!
N//
N//*****************************************************************************
Nextern void SysCtl_disableNMISource(uint_fast8_t flags);
N
N//*****************************************************************************
N//
N//! Enables NMIs for the provided modules. When enabled, a NMI flag will
N//! occur when a fault condition comes from the corresponding modules.
N//!
N//! \param flags The NMI sources to enable
N//! Can be a bitwise OR of the following parameters:
N//!         - \b SYSCTL_NMIPIN_SRC,
N//!         - \b SYSCTL_PCM_SRC,
N//!         - \b SYSCTL_PSS_SRC,
N//!         - \b SYSCTL_CS_SRC
N//!
N//
N//*****************************************************************************
Nextern void SysCtl_enableNMISource(uint_fast8_t flags);
N
N//*****************************************************************************
N//
N//! Returns the current sources of NMIs that are enabled
N//!
N//! \return Bitwise OR of NMI flags that are enabled
N//
N//*****************************************************************************
Nextern uint_fast8_t SysCtl_getNMISourceStatus(void);
N
N//*****************************************************************************
N//
N//! Enables glitch suppression on the reset pin of the device. Refer to the
N//! device data sheet for specific information about glitch suppression
N//!
N//! \return None.
N//
N//
N//*****************************************************************************
Nextern void SysCtl_enableGlitchFilter(void);
N
N//*****************************************************************************
N//
N//! Disables glitch suppression on the reset pin of the device. Refer to the
N//! device data sheet for specific information about glitch suppression
N//!
N//! \return None.
N//
N//
N//*****************************************************************************
Nextern void SysCtl_disableGlitchFilter(void);
N
N//*****************************************************************************
N//
N//! Retrieves the calibration constant of the temperature sensor to be used
N//! in temperature calculation.
N//!
N//! \param refVoltage Reference voltage being used.
N//!
N//! The \e refVoltage parameter must be only one of the following values:
N//!         - \b SYSCTL_1_2V_REF
N//!         - \b SYSCTL_1_45V_REF
N//!         - \b SYSCTL_2_5V_REF
N//!
N//! \param temperature is the calibration temperature that the user wants to be
N//!     returned.
N//!
N//! The \e temperature parameter must be only one of the following values:
N//!         - \b SYSCTL_30_DEGREES_C
N//!         - \b SYSCTL_85_DEGREES_C
N//!
N//! \return None.
N//
N//
N//*****************************************************************************
Nextern uint_fast16_t SysCtl_getTempCalibrationConstant(uint32_t refVoltage,
N        uint32_t temperature);
N
N//*****************************************************************************
N//
N// Mark the end of the C bindings section for C++ compilers.
N//
N//*****************************************************************************
N#ifdef __cplusplus
N}
N#endif
N
N//*****************************************************************************
N//
N// Close the Doxygen group.
N//! @}
N//
N//*****************************************************************************
N
N#endif // __SYSCTL_H__
L 64 "C:/ti/msp432_driverlib_3_21_00_05/driverlib/MSP432P4xx/driverlib.h" 2
N#include "systick.h"
L 1 "C:\ti\msp432_driverlib_3_21_00_05\driverlib\MSP432P4xx\systick.h" 1
N/*
N * -------------------------------------------
N *    MSP432 DriverLib - v3_21_00_05 
N * -------------------------------------------
N *
N * --COPYRIGHT--,BSD,BSD
N * Copyright (c) 2016, Texas Instruments Incorporated
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N *
N * *  Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N *
N * *  Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * *  Neither the name of Texas Instruments Incorporated nor the names of
N *    its contributors may be used to endorse or promote products derived
N *    from this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
N * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
N * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
N * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
N * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
N * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
N * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
N * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
N * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * --/COPYRIGHT--*/
N#ifndef __SYSTICK_H__
N#define __SYSTICK_H__
N
N//*****************************************************************************
N//
N//! \addtogroup systick_api
N//! @{
N//
N//*****************************************************************************
N
N//*****************************************************************************
N//
N// If building with a C++ compiler, make all of the definitions in this header
N// have a C binding.
N//
N//*****************************************************************************
N#ifdef __cplusplus
Nextern "C"
N{
N#endif
N#include <stdint.h>
N
N//*****************************************************************************
N//
N// Prototypes for the APIs.
N//
N//*****************************************************************************
N
N//*****************************************************************************
N//
N//! Enables the SysTick counter.
N//!
N//! This function starts the SysTick counter.  If an interrupt handler has been
N//! registered, it is called when the SysTick counter rolls over.
N//!
N//! \note Calling this function causes the SysTick counter to (re)commence
N//! counting from its current value.  The counter is not automatically reloaded
N//! with the period as specified in a previous call to SysTick_setPeriod().  If
N//! an immediate reload is required, the \b NVIC_ST_CURRENT register must be
N//! written to force the reload.  Any write to this register clears the SysTick
N//! counter to 0 and causes a reload with the supplied period on the next
N//! clock.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void SysTick_enableModule(void);
N
N//*****************************************************************************
N//
N//! Disables the SysTick counter.
N//!
N//! This function stops the SysTick counter.  If an interrupt handler has been
N//! registered, it is not called until SysTick is restarted.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void SysTick_disableModule(void);
N
N//*****************************************************************************
N//
N//! Registers an interrupt handler for the SysTick interrupt.
N//!
N//! \param intHandler is a pointer to the function to be called when the
N//! SysTick interrupt occurs.
N//!
N//! This function registers the handler to be called when a SysTick interrupt
N//! occurs.
N//!
N//! \sa Interrupt_registerInterrupt() for important information about
N//! registering interrupt handlers.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void SysTick_registerInterrupt(void (*intHandler)(void));
N
N//*****************************************************************************
N//
N//! Unregisters the interrupt handler for the SysTick interrupt.
N//!
N//! This function unregisters the handler to be called when a SysTick interrupt
N//! occurs.
N//!
N//! \sa Interrupt_registerInterrupt() for important information about
N//! registering interrupt handlers.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void SysTick_unregisterInterrupt(void);
N
N//*****************************************************************************
N//
N//! Enables the SysTick interrupt.
N//!
N//! This function enables the SysTick interrupt, allowing it to be
N//! reflected to the processor.
N//!
N//! \note The SysTick interrupt handler is not required to clear the SysTick
N//! interrupt source because it is cleared automatically by the NVIC when the
N//! interrupt handler is called.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void SysTick_enableInterrupt(void);
N
N//*****************************************************************************
N//
N//! Disables the SysTick interrupt.
N//!
N//! This function disables the SysTick interrupt, preventing it from being
N//! reflected to the processor.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void SysTick_disableInterrupt(void);
N
N//*****************************************************************************
N//
N//! Sets the period of the SysTick counter.
N//!
N//! \param period is the number of clock ticks in each period of the SysTick
N//! counter and must be between 1 and 16,777,216, inclusive.
N//!
N//! This function sets the rate at which the SysTick counter wraps, which
N//! equates to the number of processor clocks between interrupts.
N//!
N//! \note Calling this function does not cause the SysTick counter to reload
N//! immediately.  If an immediate reload is required, the \b NVIC_ST_CURRENT
N//! register must be written.  Any write to this register clears the SysTick
N//! counter to 0 and causes a reload with the \e period supplied here on
N//! the next clock after SysTick is enabled.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void SysTick_setPeriod(uint32_t period);
N
N//*****************************************************************************
N//
N//! Gets the period of the SysTick counter.
N//!
N//! This function returns the rate at which the SysTick counter wraps, which
N//! equates to the number of processor clocks between interrupts.
N//!
N//! \return Returns the period of the SysTick counter.
N//
N//*****************************************************************************
Nextern uint32_t SysTick_getPeriod(void);
N
N//*****************************************************************************
N//
N//! Gets the current value of the SysTick counter.
N//!
N//! This function returns the current value of the SysTick counter, which is
N//! a value between the period - 1 and zero, inclusive.
N//!
N//! \return Returns the current value of the SysTick counter.
N//
N//*****************************************************************************
Nextern uint32_t SysTick_getValue(void);
N
N//*****************************************************************************
N//
N// Mark the end of the C bindings section for C++ compilers.
N//
N//*****************************************************************************
N#ifdef __cplusplus
N}
N#endif
N
N//*****************************************************************************
N//
N// Close the Doxygen group.
N//! @}
N//
N//*****************************************************************************
N
N#endif // __SYSTICK_H__
L 65 "C:/ti/msp432_driverlib_3_21_00_05/driverlib/MSP432P4xx/driverlib.h" 2
N#include "timer32.h"
L 1 "C:\ti\msp432_driverlib_3_21_00_05\driverlib\MSP432P4xx\timer32.h" 1
N/*
N * -------------------------------------------
N *    MSP432 DriverLib - v3_21_00_05 
N * -------------------------------------------
N *
N * --COPYRIGHT--,BSD,BSD
N * Copyright (c) 2016, Texas Instruments Incorporated
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N *
N * *  Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N *
N * *  Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * *  Neither the name of Texas Instruments Incorporated nor the names of
N *    its contributors may be used to endorse or promote products derived
N *    from this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
N * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
N * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
N * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
N * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
N * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
N * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
N * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
N * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * --/COPYRIGHT--*/
N#ifndef TIMER32_H_
N#define TIMER32_H_
N
N//*****************************************************************************
N//
N//! \addtogroup timer32_api
N//! @{
N//
N//*****************************************************************************
N
N//*****************************************************************************
N//
N// If building with a C++ compiler, make all of the definitions in this header
N// have a C binding.
N//
N//*****************************************************************************
N#ifdef __cplusplus
Nextern "C"
N{
N#endif
N#include <stdint.h>
N#include <stdbool.h>
N#include <msp.h>
N
N//*****************************************************************************
N//
N// Control specific variables
N//
N//*****************************************************************************
N#define TIMER32_CMSIS(x) ((Timer32_Type *) x)
N
N#define TIMER_OFFSET    0x020
N
N#define TIMER32_0_BASE   (uint32_t)TIMER32_1
N#define TIMER32_1_BASE   (uint32_t)TIMER32_2
N
N#define TIMER32_0_INTERRUPT         INT_T32_INT1
N#define TIMER32_1_INTERRUPT         INT_T32_INT2
N#define TIMER32_COMBINED_INTERRUPT  INT_T32_INTC
N
N#define TIMER32_16BIT            0x00
N#define TIMER32_32BIT            0x01
N
N#define TIMER32_PRESCALER_1      0x00
N#define TIMER32_PRESCALER_16     0x04
N#define TIMER32_PRESCALER_256    0x08
N
N#define TIMER32_FREE_RUN_MODE   0x00
N#define TIMER32_PERIODIC_MODE   0x01
N
N//*****************************************************************************
N//
N// API Function prototypes
N//
N//*****************************************************************************
N
N//*****************************************************************************
N//
N//! Initializes the Timer32 module
N//!
N//! \param timer is the instance of the Timer32 module.
N//! Valid parameters must be one of the following values:
N//!         - \b TIMER32_0_BASE
N//!         - \b TIMER32_1_BASE
N//!
N//! \param preScaler is the prescaler (or divider) to apply to the clock
N//! source given to the Timer32 module.
N//!         Valid values are
N//!         - \b TIMER32_PRESCALER_1 [DEFAULT]
N//!         - \b TIMER32_PRESCALER_16
N//!         - \b TIMER32_PRESCALER_256
N//! \param resolution is the bit resolution of the Timer32 module.
N//!         Valid values are
N//!         - \b TIMER32_16BIT [DEFAULT]
N//!         - \b TIMER32_32BIT
N//! \param mode selects between free run and periodic mode. In free run
N//! mode, the value of the timer is reset to UINT16_MAX (for 16-bit mode) or
N//! UINT32_MAX (for 16-bit mode) when the timer reaches zero. In periodic mode,
N//! the timer is reset to the value set by the Timer32_setCount function.
N//!         Valid values are
N//!         - \b TIMER32_FREE_RUN_MODE [DEFAULT]
N//!         - \b TIMER32_PERIODIC_MODE
N//!
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void Timer32_initModule(uint32_t timer, uint32_t preScaler,
N        uint32_t resolution, uint32_t mode);
N
N//*****************************************************************************
N//
N//! Sets the count of the timer and resets the current value to the value
N//! passed. This value is set on the next rising edge of the clock provided to
N//! the timer module
N//!
N//! \param timer is the instance of the Timer32 module.
N//! Valid parameters must be one of the following values:
N//!         - \b TIMER32_0_BASE
N//!         - \b TIMER32_1_BASE
N//! \param count Value of the timer to set. Note that
N//! if the timer is in 16-bit mode and a value is passed in that exceeds
N//! UINT16_MAX, the value will be truncated to UINT16_MAX.
N//!
N//! Also note that if the timer is operating in periodic mode, the value passed
N//! into this function will represent the new period of the timer (the value
N//! which is reloaded into the timer each time it reaches a zero value).
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void Timer32_setCount(uint32_t timer, uint32_t count);
N
N//*****************************************************************************
N//
N//! Sets the count of the timer without resetting the current value. When the
N//! current value of the timer reaches zero, the value passed into this function
N//! will be set as the new count value.
N//!
N//! \param timer is the instance of the Timer32 module.
N//! Valid parameters must be one of the following values:
N//!         - \b TIMER32_0_BASE
N//!         - \b TIMER32_1_BASE
N//! \param count Value of the timer to set in the background. Note that
N//! if the timer is in 16-bit mode and a value is passed in that exceeds
N//! UINT16_MAX, the value will be truncated to UINT16_MAX.
N//!
N//! Also note that if the timer is operating in periodic mode, the value passed
N//! into this function will represent the new period of the timer (the value
N//! which is reloaded into the timer each time it reaches a zero value).
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void Timer32_setCountInBackground(uint32_t timer, uint32_t count);
N
N//*****************************************************************************
N//
N//! Returns the current value of the timer.
N//!
N//! \param timer is the instance of the Timer32 module.
N//! Valid parameters must be one of the following values:
N//!         - \b TIMER32_0_BASE
N//!         - \b TIMER32_1_BASE
N//!
N//! \return The current count of the timer.
N//
N//*****************************************************************************
Nextern uint32_t Timer32_getValue(uint32_t timer);
N
N//*****************************************************************************
N//
N//! Starts the timer. The Timer32_initModule function should be called (in
N//! conjunction with Timer32_setCount if periodic mode is desired) prior to
N//  starting the timer.
N//!
N//! \param timer is the instance of the Timer32 module.
N//! Valid parameters must be one of the following values:
N//!         - \b TIMER32_0_BASE
N//!         - \b TIMER32_1_BASE
N//!
N//! \param oneShot sets whether the Timer32 module operates in one shot
N//!  or continuous mode. In one shot mode, the timer will halt when a zero is
N//!  reached and stay halted until either:
N//!         - The user calls the Timer32PeriodSet function
N//!         - The Timer32_initModule is called to reinitialize the timer with one-shot
N//!             mode disabled.
N//!
N//! A true value will cause the timer to operate in one shot mode while a false
N//! value will cause the timer to operate in continuous mode
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void Timer32_startTimer(uint32_t timer, bool oneShot);
N
N//*****************************************************************************
N//
N//! Halts the timer. Current count and setting values are preserved.
N//!
N//! \param timer is the instance of the Timer32 module.
N//! Valid parameters must be one of the following values:
N//!         - \b TIMER32_0_BASE
N//!         - \b TIMER32_1_BASE
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void Timer32_haltTimer(uint32_t timer);
N
N//*****************************************************************************
N//
N//! Enables a Timer32 interrupt source.
N//!
N//! \param timer is the instance of the Timer32 module.
N//! Valid parameters must be one of the following values:
N//!         - \b TIMER32_0_BASE
N//!         - \b TIMER32_1_BASE
N//!
N//! Enables the indicated Timer32 interrupt source.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void Timer32_enableInterrupt(uint32_t timer);
N
N//*****************************************************************************
N//
N//! Disables a Timer32 interrupt source.
N//!
N//! \param timer is the instance of the Timer32 module.
N//! Valid parameters must be one of the following values:
N//!         - \b TIMER32_0_BASE
N//!         - \b TIMER32_1_BASE
N//!
N//! Disables the indicated Timer32 interrupt source.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void Timer32_disableInterrupt(uint32_t timer);
N
N//*****************************************************************************
N//
N//! Clears Timer32 interrupt source.
N//!
N//! \param timer is the instance of the Timer32 module.
N//! Valid parameters must be one of the following values:
N//!         - \b TIMER32_0_BASE
N//!         - \b TIMER32_1_BASE
N//!
N//! The Timer32 interrupt source is cleared, so that it no longer asserts.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void Timer32_clearInterruptFlag(uint32_t timer);
N
N//*****************************************************************************
N//
N//! Gets the current Timer32 interrupt status.
N//!
N//! \param timer is the instance of the Timer32 module.
N//! Valid parameters must be one of the following values:
N//!         - \b TIMER32_0_BASE
N//!         - \b TIMER32_1_BASE
N//!
N//! This returns the interrupt status for the Timer32 module. A positive value
N//! will indicate that an interrupt is pending while a zero value will indicate
N//! that no interrupt is pending.
N//!
N//! \return The current interrupt status
N//
N//*****************************************************************************
Nextern uint32_t Timer32_getInterruptStatus(uint32_t timer);
N
N//*****************************************************************************
N//
N//! Registers an interrupt handler for Timer32 interrupts.
N//!
N//! \param timerInterrupt is the specific interrupt to register. For the
N//! Timer32 module, there are a total of three different interrupts: one
N//! interrupt for each two Timer32 modules, and a "combined" interrupt which
N//! is a logical OR of each individual Timer32 interrupt.
N//!         - \b TIMER32_0_INTERRUPT
N//!         - \b TIMER32_1_INTERRUPT
N//!         - \b TIMER32_COMBINED_INTERRUPT
N//!
N//! \param intHandler is a pointer to the function to be called when the
N//! Timer32 interrupt occurs.
N//!
N//! This function registers the handler to be called when an Timer32
N//! interrupt occurs. This function enables the global interrupt in the
N//! interrupt controller; specific Timer32 interrupts must be enabled
N//! via Timer32_enableInterrupt().  It is the interrupt handler's
N//! responsibility to clear the interrupt source
N//! via Timer32_clearInterruptFlag().
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void Timer32_registerInterrupt(uint32_t timerInterrupt,
N        void (*intHandler)(void));
N
N//*****************************************************************************
N//
N//! Unregisters the interrupt handler for the Timer32 interrupt.
N//!
N//! \param timerInterrupt is the specific interrupt to register. For the
N//! Timer32 module, there are a total of three different interrupts: one
N//! interrupt for each two Timer32 modules, and a "combined" interrupt which
N//! is a logical OR of each individual Timer32 interrupt.
N//!         - \b TIMER32_0_INTERRUPT
N//!         - \b TIMER32_1_INTERRUPT
N//!         - \b TIMER32_COMBINED_INTERRUPT
N//!
N//! This function unregisters the handler to be called when a Timer32
N//! interrupt occurs.  This function also masks off the interrupt in the
N//! interrupt controller so that the interrupt handler no longer is called.
N//!
N//! \sa Interrupt_registerInterrupt() for important information about
N//! registering interrupt handlers.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void Timer32_unregisterInterrupt(uint32_t timerInterrupt);
N
N//*****************************************************************************
N//
N// Mark the end of the C bindings section for C++ compilers.
N//
N//*****************************************************************************
N#ifdef __cplusplus
N}
N#endif
N
N//*****************************************************************************
N//
N// Close the Doxygen group.
N//! @}
N//
N//*****************************************************************************
N
N#endif /* TIMER32_H_ */
L 66 "C:/ti/msp432_driverlib_3_21_00_05/driverlib/MSP432P4xx/driverlib.h" 2
N#include "timer_a.h"
L 1 "C:\ti\msp432_driverlib_3_21_00_05\driverlib\MSP432P4xx\timer_a.h" 1
N/*
N * -------------------------------------------
N *    MSP432 DriverLib - v3_21_00_05 
N * -------------------------------------------
N *
N * --COPYRIGHT--,BSD,BSD
N * Copyright (c) 2016, Texas Instruments Incorporated
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N *
N * *  Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N *
N * *  Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * *  Neither the name of Texas Instruments Incorporated nor the names of
N *    its contributors may be used to endorse or promote products derived
N *    from this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
N * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
N * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
N * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
N * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
N * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
N * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
N * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
N * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * --/COPYRIGHT--*/
N#ifndef TIMERA_H_
N#define TIMERA_H_
N
N//*****************************************************************************
N//
N//! \addtogroup timera_api
N//! @{
N//
N//*****************************************************************************
N
N//*****************************************************************************
N//
N// If building with a C++ compiler, make all of the definitions in this header
N// have a C binding.
N//
N//*****************************************************************************
N#ifdef __cplusplus
Nextern "C"
N{
N#endif
N#include <stdint.h>
N#include <msp.h>
N#include <stdbool.h>
N
N//*****************************************************************************
N//
N// Timer_A Specific Parameters
N//
N//*****************************************************************************
N#define TIMER_A_CMSIS(x) ((Timer_A_Type *) x)
N
N#define TIMER_A_CCR0_INTERRUPT              0x00
N#define TIMER_A_CCRX_AND_OVERFLOW_INTERRUPT 0x01
N
N//*****************************************************************************
N//
N//!     ypedef Timer_A_ContinuousModeConfig
N//! \brief Type definition for \link _Timer_A_ContinuousModeConfig \endlink
N//!     structure
N//!
N//! \struct _Timer_A_ContinuousModeConfig
N//! \brief Configuration structure for continuous mode in the \b Timer_A module.
N//!         See \link Timer_A_configureContinuousMode \endlink for parameter
N//!                 documentation.
N//
N//*****************************************************************************
Ntypedef struct _Timer_A_ContinuousModeConfig
N{
N    uint_fast16_t clockSource;
N    uint_fast16_t clockSourceDivider;
N    uint_fast16_t timerInterruptEnable_TAIE;
N    uint_fast16_t timerClear;
N} Timer_A_ContinuousModeConfig;
N
N//*****************************************************************************
N//
N//!     ypedef Timer_A_UpModeConfig
N//! \brief Type definition for \link _Timer_A_UpModeConfig \endlink
N//!     structure
N//!
N//! \struct _Timer_A_UpModeConfig
N//! \brief Configuration structure for Up mode in the \b Timer_A module. See
N//!          \link Timer_A_configureUpMode \endlink for parameter
N//!                 documentation.
N//
N//*****************************************************************************
Ntypedef struct _Timer_A_UpModeConfig
N{
N    uint_fast16_t clockSource;
N    uint_fast16_t clockSourceDivider;
N    uint_fast16_t timerPeriod;
N    uint_fast16_t timerInterruptEnable_TAIE;
N    uint_fast16_t captureCompareInterruptEnable_CCR0_CCIE;
N    uint_fast16_t timerClear;
N} Timer_A_UpModeConfig;
N
N//*****************************************************************************
N//
N//!     ypedef Timer_A_UpDownModeConfig
N//! \brief Type definition for \link _Timer_A_UpDownModeConfig \endlink
N//!     structure
N//!
N//! \struct _Timer_A_UpDownModeConfig
N//! \brief Configuration structure for UpDown mode in the \b Timer_A module. See
N//!          \link Timer_A_configureUpDownMode \endlink for parameter
N//!                 documentation.
N//
N//*****************************************************************************
Ntypedef struct _Timer_A_UpDownModeConfig
N{
N    uint_fast16_t clockSource;
N    uint_fast16_t clockSourceDivider;
N    uint_fast16_t timerPeriod;
N    uint_fast16_t timerInterruptEnable_TAIE;
N    uint_fast16_t captureCompareInterruptEnable_CCR0_CCIE;
N    uint_fast16_t timerClear;
N} Timer_A_UpDownModeConfig;
N
N//*****************************************************************************
N//
N//!     ypedef Timer_A_CaptureModeConfig
N//! \brief Type definition for \link _Timer_A_CaptureModeConfig \endlink
N//!     structure
N//!
N//! \struct _Timer_A_CaptureModeConfig
N//! \brief Configuration structure for capture mode in the \b Timer_A module.
N//!         See  \link Timer_A_initCapture \endlink for parameter
N//!                 documentation.
N//
N//*****************************************************************************
Ntypedef struct _Timer_A_CaptureModeConfig
N{
N    uint_fast16_t captureRegister;
N    uint_fast16_t captureMode;
N    uint_fast16_t captureInputSelect;
N    uint_fast16_t synchronizeCaptureSource;
N    uint_fast8_t captureInterruptEnable;
N    uint_fast16_t captureOutputMode;
N} Timer_A_CaptureModeConfig;
N
N//*****************************************************************************
N//
N//!     ypedef Timer_A_CompareModeConfig
N//! \brief Type definition for \link _Timer_A_CompareModeConfig \endlink
N//!     structure
N//!
N//! \struct _Timer_A_CompareModeConfig
N//! \brief Configuration structure for compare mode in the \b Timer_A module.
N//!          See \link Timer_A_initCompare \endlink for parameter
N//!                 documentation.
N//
N//*****************************************************************************
Ntypedef struct _Timer_A_CompareModeConfig
N{
N    uint_fast16_t compareRegister;
N    uint_fast16_t compareInterruptEnable;
N    uint_fast16_t compareOutputMode;
N    uint_fast16_t compareValue;
N} Timer_A_CompareModeConfig;
N
N//*****************************************************************************
N//
N//!     ypedef Timer_A_PWMConfig
N//! \brief Type definition for \link _Timer_A_PWMConfig \endlink
N//!     structure
N//!
N//! \struct _Timer_A_PWMConfig
N//! \brief Configuration structure for PWM mode in the \b Timer_A module. See
N//!          \link Timer_A_generatePWM \endlink for parameter
N//!                 documentation.
N//
N//*****************************************************************************
Ntypedef struct _Timer_A_PWMConfig
N{
N    uint_fast16_t clockSource;
N    uint_fast16_t clockSourceDivider;
N    uint_fast16_t timerPeriod;
N    uint_fast16_t compareRegister;
N    uint_fast16_t compareOutputMode;
N    uint_fast16_t dutyCycle;
N} Timer_A_PWMConfig;
N
N
N//*****************************************************************************
N//
N// The following is a parameter determines the maximum difference in counts of
N// the TAxR register for a majority vote
N//
N//*****************************************************************************
N#define TIMER_A_THRESHOLD                                                     50
N
N//*****************************************************************************
N//
N// The following are values that can be passed to the clockSourceDivider
N// parameter
N//
N//*****************************************************************************
N#define TIMER_A_CLOCKSOURCE_DIVIDER_1                                      0x01
N#define TIMER_A_CLOCKSOURCE_DIVIDER_2                                      0x02
N#define TIMER_A_CLOCKSOURCE_DIVIDER_4                                      0x04
N#define TIMER_A_CLOCKSOURCE_DIVIDER_8                                      0x08
N#define TIMER_A_CLOCKSOURCE_DIVIDER_3                                      0x03
N#define TIMER_A_CLOCKSOURCE_DIVIDER_5                                      0x05
N#define TIMER_A_CLOCKSOURCE_DIVIDER_6                                      0x06
N#define TIMER_A_CLOCKSOURCE_DIVIDER_7                                      0x07
N#define TIMER_A_CLOCKSOURCE_DIVIDER_10                                     0x0A
N#define TIMER_A_CLOCKSOURCE_DIVIDER_12                                     0x0C
N#define TIMER_A_CLOCKSOURCE_DIVIDER_14                                     0x0E
N#define TIMER_A_CLOCKSOURCE_DIVIDER_16                                     0x10
N#define TIMER_A_CLOCKSOURCE_DIVIDER_20                                     0x14
N#define TIMER_A_CLOCKSOURCE_DIVIDER_24                                     0x18
N#define TIMER_A_CLOCKSOURCE_DIVIDER_28                                     0x1C
N#define TIMER_A_CLOCKSOURCE_DIVIDER_32                                     0x20
N#define TIMER_A_CLOCKSOURCE_DIVIDER_40                                     0x28
N#define TIMER_A_CLOCKSOURCE_DIVIDER_48                                     0x30
N#define TIMER_A_CLOCKSOURCE_DIVIDER_56                                     0x38
N#define TIMER_A_CLOCKSOURCE_DIVIDER_64                                     0x40
N
N//*****************************************************************************
N//
N// The following are values that can be passed to the timerMode parameter
N//
N//*****************************************************************************
N#define TIMER_A_STOP_MODE                                                  TIMER_A_CTL_MC_0
N#define TIMER_A_UP_MODE                                                    TIMER_A_CTL_MC_1
N#define TIMER_A_CONTINUOUS_MODE                                            TIMER_A_CTL_MC_2
N#define TIMER_A_UPDOWN_MODE                                                TIMER_A_CTL_MC_3
N
N//*****************************************************************************
N//
N// The following are values that can be passed to the timerClear parameter
N//
N//*****************************************************************************
N#define TIMER_A_DO_CLEAR                                                  TIMER_A_CTL_CLR
N#define TIMER_A_SKIP_CLEAR                                                 0x00
N
N//*****************************************************************************
N//
N// The following are values that can be passed to the clockSource parameter
N//
N//*****************************************************************************
N#define TIMER_A_CLOCKSOURCE_EXTERNAL_TXCLK                        TIMER_A_CTL_SSEL__TACLK
N#define TIMER_A_CLOCKSOURCE_ACLK                                  TIMER_A_CTL_SSEL__ACLK
N#define TIMER_A_CLOCKSOURCE_SMCLK                                 TIMER_A_CTL_SSEL__SMCLK
N#define TIMER_A_CLOCKSOURCE_INVERTED_EXTERNAL_TXCLK               TIMER_A_CTL_SSEL__INCLK
N
N//*****************************************************************************
N//
N// The following are values that can be passed to the timerInterruptEnable_TAIE
N// parameter
N//
N//*****************************************************************************
N#define TIMER_A_TAIE_INTERRUPT_ENABLE                                      TIMER_A_CTL_IE
N#define TIMER_A_TAIE_INTERRUPT_DISABLE                                     0x00
N
N//*****************************************************************************
N//
N// The following are values that can be passed to the
N// captureCompareInterruptEnable_CCR0_CCIE parameter
N//
N//*****************************************************************************
N#define TIMER_A_CCIE_CCR0_INTERRUPT_ENABLE                                 TIMER_A_CCTLN_CCIE
N#define TIMER_A_CCIE_CCR0_INTERRUPT_DISABLE                                0x00
N
N//*****************************************************************************
N//
N// The following are values that can be passed to the captureInterruptEnable
N// parameter
N//
N//*****************************************************************************
N#define TIMER_A_CAPTURECOMPARE_INTERRUPT_DISABLE                           0x00
N#define TIMER_A_CAPTURECOMPARE_INTERRUPT_ENABLE                            TIMER_A_CCTLN_CCIE
N
N//*****************************************************************************
N//
N// The following are values that can be passed to the captureInputSelect
N// parameter
N//
N//*****************************************************************************
N#define TIMER_A_CAPTURE_INPUTSELECT_CCIxA                                TIMER_A_CCTLN_CCIS_0
N#define TIMER_A_CAPTURE_INPUTSELECT_CCIxB                                TIMER_A_CCTLN_CCIS_1
N#define TIMER_A_CAPTURE_INPUTSELECT_GND                                  TIMER_A_CCTLN_CCIS_2
N#define TIMER_A_CAPTURE_INPUTSELECT_Vcc                                  TIMER_A_CCTLN_CCIS_3
N
N//*****************************************************************************
N//
N// The following are values that can be passed to the compareOutputMode
N// parameter
N//
N//*****************************************************************************
N#define TIMER_A_OUTPUTMODE_OUTBITVALUE                                 TIMER_A_CCTLN_OUTMOD_0
N#define TIMER_A_OUTPUTMODE_SET                                         TIMER_A_CCTLN_OUTMOD_1
N#define TIMER_A_OUTPUTMODE_TOGGLE_RESET                                TIMER_A_CCTLN_OUTMOD_2
N#define TIMER_A_OUTPUTMODE_SET_RESET                                   TIMER_A_CCTLN_OUTMOD_3
N#define TIMER_A_OUTPUTMODE_TOGGLE                                      TIMER_A_CCTLN_OUTMOD_4
N#define TIMER_A_OUTPUTMODE_RESET                                       TIMER_A_CCTLN_OUTMOD_5
N#define TIMER_A_OUTPUTMODE_TOGGLE_SET                                  TIMER_A_CCTLN_OUTMOD_6
N#define TIMER_A_OUTPUTMODE_RESET_SET                                   TIMER_A_CCTLN_OUTMOD_7
N
N//*****************************************************************************
N//
N// The following are values that can be passed to the compareRegister parameter
N//
N//*****************************************************************************
N#define TIMER_A_CAPTURECOMPARE_REGISTER_0                                  0x02
N#define TIMER_A_CAPTURECOMPARE_REGISTER_1                                  0x04
N#define TIMER_A_CAPTURECOMPARE_REGISTER_2                                  0x06
N#define TIMER_A_CAPTURECOMPARE_REGISTER_3                                  0x08
N#define TIMER_A_CAPTURECOMPARE_REGISTER_4                                  0x0A
N#define TIMER_A_CAPTURECOMPARE_REGISTER_5                                  0x0C
N#define TIMER_A_CAPTURECOMPARE_REGISTER_6                                  0x0E
N
N//*****************************************************************************
N//
N// The following are values that can be passed to the captureMode parameter
N//
N//*****************************************************************************
N#define TIMER_A_CAPTUREMODE_NO_CAPTURE                                     TIMER_A_CCTLN_CM_0
N#define TIMER_A_CAPTUREMODE_RISING_EDGE                                    TIMER_A_CCTLN_CM_1
N#define TIMER_A_CAPTUREMODE_FALLING_EDGE                                   TIMER_A_CCTLN_CM_2
N#define TIMER_A_CAPTUREMODE_RISING_AND_FALLING_EDGE                        TIMER_A_CCTLN_CM_3
N
N//*****************************************************************************
N//
N// The following are values that can be passed to the synchronizeCaptureSource
N// parameter
N//
N//*****************************************************************************
N#define TIMER_A_CAPTURE_ASYNCHRONOUS                                       0x00
N#define TIMER_A_CAPTURE_SYNCHRONOUS                                        TIMER_A_CCTLN_SCS
N
N//*****************************************************************************
N//
N// The following are values that can be passed to the mask parameter
N//
N//*****************************************************************************
N#define TIMER_A_CAPTURE_OVERFLOW                                          TIMER_A_CCTLN_COV
N#define TIMER_A_CAPTURECOMPARE_INTERRUPT_FLAG                             TIMER_A_CCTLN_CCIFG
N
N//*****************************************************************************
N//
N// The following are values that can be passed to the synchronized parameter
N//
N//*****************************************************************************
N#define TIMER_A_READ_SYNCHRONIZED_CAPTURECOMPAREINPUT                      TIMER_A_CCTLN_SCCI
N#define TIMER_A_READ_CAPTURE_COMPARE_INPUT                                 TIMER_A_CCTLN_CCI
N
N
N#define TIMER_A_CAPTURECOMPARE_INPUT_HIGH                                  0x01
N#define TIMER_A_CAPTURECOMPARE_INPUT_LOW                                   0x00
N
N//*****************************************************************************
N//
N// The following are values that can be passed to the outputModeOutBitValue
N// parameter
N//
N//*****************************************************************************
N#define TIMER_A_OUTPUTMODE_OUTBITVALUE_HIGH                                TIMER_A_CCTLN_OUT
N#define TIMER_A_OUTPUTMODE_OUTBITVALUE_LOW                                 0x00
N
N//*****************************************************************************
N//
N// The following are values that can be passed toThe following are values that
N// can be returned by the interrupt functions
N//
N//*****************************************************************************
N#define TIMER_A_INTERRUPT_NOT_PENDING                                      0x00
N#define TIMER_A_INTERRUPT_PENDING                                          0x01
N
N
N/* Convenience function for setting the PWM Duty Cycle */
N#define Timer_A_setDutyCycle(timer,dutyCycle) \
N                Timer_A_setCompareValue(timer,dutyCycle)
X#define Timer_A_setDutyCycle(timer,dutyCycle)                 Timer_A_setCompareValue(timer,dutyCycle)
N
N//*****************************************************************************
N//
N//Prototypes for the APIs.
N//
N//*****************************************************************************
N
N//*****************************************************************************
N//
N//! Starts Timer_A counter
N//!
N//! \param timer is the instance of the Timer_A module. Valid parameters
N//! vary from part to part, but can include:
N//!         - \b TIMER_A0_BASE
N//!         - \b TIMER_A1_BASE
N//!         - \b TIMER_A2_BASE
N//!         - \b TIMER_A3_BASE
N//! \param timerMode selects Clock source. Valid values are
N//!       - \b TIMER_A_CONTINUOUS_MODE [Default value]
N//!       - \b TIMER_A_UPDOWN_MODE
N//!       - \b TIMER_A_UP_MODE
N//!
N//! \note This function assumes that the timer has been previously configured
N//! using Timer_A_configureContinuousMode,  Timer_A_configureUpMode or
N//! Timer_A_configureUpDownMode.
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void Timer_A_startCounter(uint32_t timer, uint_fast16_t timerMode);
N
N//*****************************************************************************
N//
N//! Configures Timer_A in continuous mode.
N//!
N//! \param timer is the instance of the Timer_A module. Valid parameters
N//! vary from part to part, but can include:
N//!         - \b TIMER_A0_BASE
N//!         - \b TIMER_A1_BASE
N//!         - \b TIMER_A2_BASE
N//!         - \b TIMER_A3_BASE
N//! \param config Configuration structure for Timer_A continuous mode
N//!
N//! <hr>
N//! <b>Configuration options for \link Timer_A_ContinuousModeConfig \endlink
N//!         structure.</b>
N//! <hr>
N//!
N//! \param clockSource selects Clock source. Valid values are
N//!       - \b TIMER_A_CLOCKSOURCE_EXTERNAL_TXCLK [Default value]
N//!       - \b TIMER_A_CLOCKSOURCE_ACLK
N//!       - \b TIMER_A_CLOCKSOURCE_SMCLK
N//!       - \b TIMER_A_CLOCKSOURCE_INVERTED_EXTERNAL_TXCLK
N//! \param timerInterruptEnable_TAIE is the divider for Clock source.
N//!       Valid values are:
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_1 [Default value]
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_2
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_4
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_8
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_3
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_5
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_6
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_7
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_10
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_12
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_14
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_16
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_20
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_24
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_28
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_32
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_40
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_48
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_56
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_64
N//! \param timerInterruptEnable_TAIE is to enable or disable Timer_A
N//!        interrupt. Valid values are
N//!      - \b TIMER_A_TAIE_INTERRUPT_ENABLE
N//!      - \b TIMER_A_TAIE_INTERRUPT_DISABLE [Default value]
N//! \param timerClear decides if Timer_A clock divider, count direction,
N//!        count need to be reset. Valid values are
N//!      - \b TIMER_A_DO_CLEAR
N//!      - \b TIMER_A_SKIP_CLEAR [Default value]
N//!
N//! \note This API does not start the timer. Timer needs to be started when
N//! required using the Timer_A_startCounter API.
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void Timer_A_configureContinuousMode(uint32_t timer,
N        const Timer_A_ContinuousModeConfig *config);
N
N//*****************************************************************************
N//
N//! Configures Timer_A in up mode.
N//!
N//! \param timer is the instance of the Timer_A module. Valid parameters
N//! vary from part to part, but can include:
N//!         - \b TIMER_A0_BASE
N//!         - \b TIMER_A1_BASE
N//!         - \b TIMER_A2_BASE
N//!         - \b TIMER_A3_BASE
N//! \param config Configuration structure for Timer_A Up mode
N//!
N//! <hr>
N//! <b>Configuration options for \link Timer_A_UpModeConfig \endlink
N//!         structure.</b>
N//! <hr>
N//! \param clockSource selects Clock source. Valid values are
N//!       - \b TIMER_A_CLOCKSOURCE_EXTERNAL_TXCLK [Default value]
N//!       - \b TIMER_A_CLOCKSOURCE_ACLK
N//!       - \b TIMER_A_CLOCKSOURCE_SMCLK
N//!       - \b TIMER_A_CLOCKSOURCE_INVERTED_EXTERNAL_TXCLK
N//! \param clockSourceDivider is the divider for Clock source. Valid values
N//!         are:
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_1 [Default value]
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_2
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_4
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_8
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_3
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_5
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_6
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_7
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_10
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_12
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_14
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_16
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_20
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_24
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_28
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_32
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_40
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_48
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_56
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_64
N//! \param timerPeriod is the specified Timer_A period. This is the value
N//!         that gets written into the CCR0. Limited to 16 bits[uint16_t]
N//! \param timerInterruptEnable_TAIE is to enable or disable Timer_A
N//!        interrupt. Valid values are:
N//!      - \b TIMER_A_TAIE_INTERRUPT_ENABLE and
N//!      - \b TIMER_A_TAIE_INTERRUPT_DISABLE [Default value]
N//! \param captureCompareInterruptEnable_CCR0_CCIE is to enable or disable
N//!         Timer_A CCR0 captureComapre interrupt. Valid values are
N//!      - \b TIMER_A_CCIE_CCR0_INTERRUPT_ENABLE and
N//!      - \b TIMER_A_CCIE_CCR0_INTERRUPT_DISABLE [Default value]
N//! \param timerClear decides if Timer_A clock divider, count direction,
N//!        count need to be reset. Valid values are
N//!      - \b TIMER_A_DO_CLEAR
N//!      - \b TIMER_A_SKIP_CLEAR [Default value]
N//!
N//!\note This API does not start the timer. Timer needs to be started when
N//!required using the Timer_A_startCounter API.
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void Timer_A_configureUpMode(uint32_t timer,
N        const Timer_A_UpModeConfig *config);
N
N//*****************************************************************************
N//
N//! Configures Timer_A in up down mode.
N//!
N//! \param timer is the instance of the Timer_A module. Valid parameters
N//! vary from part to part, but can include:
N//!         - \b TIMER_A0_BASE
N//!         - \b TIMER_A1_BASE
N//!         - \b TIMER_A2_BASE
N//!         - \b TIMER_A3_BASE
N//! \param config Configuration structure for Timer_A UpDown mode
N//!
N//! <hr>
N//! <b>Configuration options for \link Timer_A_UpDownModeConfig \endlink
N//!         structure.</b>
N//! <hr>
N//! \param clockSource selects Clock source. Valid values are
N//!       - \b TIMER_A_CLOCKSOURCE_EXTERNAL_TXCLK [Default value]
N//!       - \b TIMER_A_CLOCKSOURCE_ACLK
N//!       - \b TIMER_A_CLOCKSOURCE_SMCLK
N//!       - \b TIMER_A_CLOCKSOURCE_INVERTED_EXTERNAL_TXCLK
N//! \param clockSourceDivider is the divider for Clock source. Valid values
N//!         are:
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_1 [Default value]
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_2
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_4
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_8
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_3
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_5
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_6
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_7
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_10
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_12
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_14
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_16
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_20
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_24
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_28
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_32
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_40
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_48
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_56
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_64
N//! \param timerPeriod is the specified Timer_A period
N//! \param timerInterruptEnable_TAIE is to enable or disable Timer_A
N//!         interrupt.
N//!        Valid values are
N//!      - \b TIMER_A_TAIE_INTERRUPT_ENABLE
N//!      - \b TIMER_A_TAIE_INTERRUPT_DISABLE [Default value]
N//! \param captureCompareInterruptEnable_CCR0_CCIE is to enable or disable
N//!         Timer_A CCR0 captureComapre interrupt. Valid values are
N//!      - \b TIMER_A_CCIE_CCR0_INTERRUPT_ENABLE and
N//!      - \b TIMER_A_CCIE_CCR0_INTERRUPT_DISABLE [Default value]
N//! \param timerClear decides if Timer_A clock divider, count direction, count
N//!        need to be reset. Valid values are
N//!      - \b TIMER_A_DO_CLEAR
N//!      - \b TIMER_A_SKIP_CLEAR [Default value]
N//!
N//!This API does not start the timer. Timer needs to be started when required
N//!using the Timer_A_startCounter API.
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void Timer_A_configureUpDownMode(uint32_t timer,
N        const Timer_A_UpDownModeConfig *config);
N
N//*****************************************************************************
N//
N//! Initializes Capture Mode
N//!
N//! \param timer is the instance of the Timer_A module. Valid parameters
N//! vary from part to part, but can include:
N//!         - \b TIMER_A0_BASE
N//!         - \b TIMER_A1_BASE
N//!         - \b TIMER_A2_BASE
N//!         - \b TIMER_A3_BASE
N//! \param config Configuration structure for Timer_A capture mode
N//!
N//! <hr>
N//! <b>Configuration options for \link Timer_A_CaptureModeConfig \endlink
N//!         structure.</b>
N//! <hr>
N//! \param captureRegister selects the Capture register being used. Valid
N//!     values are
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_0
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_1
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_2
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_3
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_4
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_5
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_6
N//!    \n Refer to datasheet to ensure the device has the capture compare
N//!    register being used
N//! \param captureMode is the capture mode selected. Valid values are
N//!      - \b TIMER_A_CAPTUREMODE_NO_CAPTURE [Default value]
N//!      - \b TIMER_A_CAPTUREMODE_RISING_EDGE
N//!      - \b TIMER_A_CAPTUREMODE_FALLING_EDGE
N//!      - \b TIMER_A_CAPTUREMODE_RISING_AND_FALLING_EDGE
N//! \param captureInputSelect decides the Input Select
N//!      - \b TIMER_A_CAPTURE_INPUTSELECT_CCIxA [Default value]
N//!      - \b TIMER_A_CAPTURE_INPUTSELECT_CCIxB
N//!      - \b TIMER_A_CAPTURE_INPUTSELECT_GND
N//!      - \b TIMER_A_CAPTURE_INPUTSELECT_Vcc
N//! \param synchronizeCaptureSource decides if capture source should be
N//!         synchronized with timer clock
N//!        Valid values are
N//!      - \b TIMER_A_CAPTURE_ASYNCHRONOUS [Default value]
N//!      - \b TIMER_A_CAPTURE_SYNCHRONOUS
N//! \param captureInterruptEnable is to enable or disable
N//!         timer captureComapre interrupt. Valid values are
N//!      - \b TIMER_A_CAPTURECOMPARE_INTERRUPT_DISABLE [Default value]
N//!      - \b TIMER_A_CAPTURECOMPARE_INTERRUPT_ENABLE
N//! \param captureOutputMode specifies the ouput mode. Valid values are
N//!      - \b TIMER_A_OUTPUTMODE_OUTBITVALUE [Default value],
N//!      - \b TIMER_A_OUTPUTMODE_SET,
N//!      - \b TIMER_A_OUTPUTMODE_TOGGLE_RESET,
N//!      - \b TIMER_A_OUTPUTMODE_SET_RESET
N//!      - \b TIMER_A_OUTPUTMODE_TOGGLE,
N//!      - \b TIMER_A_OUTPUTMODE_RESET,
N//!      - \b TIMER_A_OUTPUTMODE_TOGGLE_SET,
N//!      - \b TIMER_A_OUTPUTMODE_RESET_SET
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void Timer_A_initCapture(uint32_t timer,
N        const Timer_A_CaptureModeConfig *config);
N
N//*****************************************************************************
N//
N//! Initializes Compare Mode
N//!
N//! \param timer is the instance of the Timer_A module. Valid parameters
N//! vary from part to part, but can include:
N//!         - \b TIMER_A0_BASE
N//!         - \b TIMER_A1_BASE
N//!         - \b TIMER_A2_BASE
N//!         - \b TIMER_A3_BASE
N//! \param config Configuration structure for Timer_A compare mode
N//!
N//! <hr>
N//! <b>Configuration options for \link Timer_A_CompareModeConfig \endlink
N//!         structure.</b>
N//! <hr>
N//! \param compareRegister selects the Capture register being used. Valid
N//!     values are
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_0
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_1
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_2
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_3
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_4
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_5
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_6
N//!    \n Refer to datasheet to ensure the device has the capture compare
N//!    register being used
N//! \param compareInterruptEnable is to enable or disable
N//!         timer captureComapre interrupt. Valid values are
N//!      - \b TIMER_A_CAPTURECOMPARE_INTERRUPT_ENABLE and
N//!      - \b TIMER_A_CAPTURECOMPARE_INTERRUPT_DISABLE [Default value]
N//! \param compareOutputMode specifies the output mode. Valid values are
N//!      - \b TIMER_A_OUTPUTMODE_OUTBITVALUE [Default value],
N//!      - \b TIMER_A_OUTPUTMODE_SET,
N//!      - \b TIMER_A_OUTPUTMODE_TOGGLE_RESET,
N//!      - \b TIMER_A_OUTPUTMODE_SET_RESET
N//!      - \b TIMER_A_OUTPUTMODE_TOGGLE,
N//!      - \b TIMER_A_OUTPUTMODE_RESET,
N//!      - \b TIMER_A_OUTPUTMODE_TOGGLE_SET,
N//!      - \b TIMER_A_OUTPUTMODE_RESET_SET
N//! \param compareValue is the count to be compared with in compare mode
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void Timer_A_initCompare(uint32_t timer,
N        const Timer_A_CompareModeConfig *config);
N
N//*****************************************************************************
N//
N//! Reset/Clear the timer clock divider, count direction, count
N//!
N//! \param timer is the instance of the Timer_A module. Valid parameters
N//! vary from part to part, but can include:
N//!         - \b TIMER_A0_BASE
N//!         - \b TIMER_A1_BASE
N//!         - \b TIMER_A2_BASE
N//!         - \b TIMER_A3_BASE
N//!
N//! \returns None
N//
N//*****************************************************************************
Nextern void Timer_A_clearTimer(uint32_t timer);
N
N//*****************************************************************************
N//
N//! Get synchronized capture compare input
N//!
N//! \param timer is the instance of the Timer_A module. Valid parameters
N//! vary from part to part, but can include:
N//!         - \b TIMER_A0_BASE
N//!         - \b TIMER_A1_BASE
N//!         - \b TIMER_A2_BASE
N//!         - \b TIMER_A3_BASE
N//! \param captureCompareRegister selects the Capture register being used.
N//!     Valid values are
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_0
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_1
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_2
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_3
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_4
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_5
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_6
N//!    \n Refer to datasheet to ensure the device has the capture compare
N//!    register being used
N//! \param synchronizedSetting is to select type of capture compare input.
N//!         Valid values are
N//!      - \b TIMER_A_READ_CAPTURE_COMPARE_INPUT
N//!      - \b TIMER_A_READ_SYNCHRONIZED_CAPTURECOMPAREINPUT
N//!
N//! \return \b TIMER_A_CAPTURECOMPARE_INPUT_HIGH or
N//!       - \b TIMER_A_CAPTURECOMPARE_INPUT_LOW
N//
N//*****************************************************************************
Nextern uint_fast8_t Timer_A_getSynchronizedCaptureCompareInput(uint32_t timer,
N        uint_fast16_t captureCompareRegister,
N        uint_fast16_t synchronizedSetting);
N
N//*****************************************************************************
N//
N//! Get ouput bit for output mode
N//!
N//! \param timer is the instance of the Timer_A module. Valid parameters
N//! vary from part to part, but can include:
N//!         - \b TIMER_A0_BASE
N//!         - \b TIMER_A1_BASE
N//!         - \b TIMER_A2_BASE
N//!         - \b TIMER_A3_BASE
N//! \param captureCompareRegister selects the Capture register being used.
N//!     Valid values are
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_0
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_1
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_2
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_3
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_4
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_5
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_6
N//!    \n Refer to datasheet to ensure the device has the capture compare
N//!    register being used
N//!
N//! \return \b TIMER_A_OUTPUTMODE_OUTBITVALUE_HIGH or
N//!       - \b TIMER_A_OUTPUTMODE_OUTBITVALUE_LOW
N//
N//*****************************************************************************
Nextern uint_fast8_t Timer_A_getOutputForOutputModeOutBitValue(uint32_t timer,
N        uint_fast16_t captureCompareRegister);
N
N//*****************************************************************************
N//
N//! Get current capture compare count
N//!
N//! \param timer is the instance of the Timer_A module. Valid parameters
N//! vary from part to part, but can include:
N//!         - \b TIMER_A0_BASE
N//!         - \b TIMER_A1_BASE
N//!         - \b TIMER_A2_BASE
N//!         - \b TIMER_A3_BASE
N//! \param captureCompareRegister selects the Capture register being used.
N//!     Valid values are
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_0
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_1
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_2
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_3
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_4
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_5
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_6
N//!    \n Refer to datasheet to ensure the device has the capture compare
N//!    register being used
N//!
N//! \return current count as uint16_t
N//
N//*****************************************************************************
Nextern uint_fast16_t Timer_A_getCaptureCompareCount(uint32_t timer,
N        uint_fast16_t captureCompareRegister);
N
N//*****************************************************************************
N//
N//! Set ouput bit for output mode
N//!
N//! \param timer is the instance of the Timer_A module. Valid parameters
N//! vary from part to part, but can include:
N//!         - \b TIMER_A0_BASE
N//!         - \b TIMER_A1_BASE
N//!         - \b TIMER_A2_BASE
N//!         - \b TIMER_A3_BASE
N//! \param captureCompareRegister selects the Capture register being used.
N//!     are
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_0
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_1
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_2
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_3
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_4
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_5
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_6
N//!    \n Refer to datasheet to ensure the device has the capture compare
N//!    register being used
N//! \param outputModeOutBitValue the value to be set for out bit.
N//!     Valid values are:
N//!                    - \b TIMER_A_OUTPUTMODE_OUTBITVALUE_HIGH
N//!                    - \b TIMER_A_OUTPUTMODE_OUTBITVALUE_LOW
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void Timer_A_setOutputForOutputModeOutBitValue(uint32_t timer,
N        uint_fast16_t captureCompareRegister,
N        uint_fast8_t outputModeOutBitValue);
N
N//*****************************************************************************
N//
N//! Generate a PWM with timer running in up mode
N//!
N//! \param timer is the instance of the Timer_A module. Valid parameters
N//! vary from part to part, but can include:
N//!         - \b TIMER_A0_BASE
N//!         - \b TIMER_A1_BASE
N//!         - \b TIMER_A2_BASE
N//!         - \b TIMER_A3_BASE
N//! \param config Configuration structure for Timer_A PWM mode
N//!
N//! <hr>
N//! <b>Configuration options for \link Timer_A_PWMConfig \endlink
N//!         structure.</b>
N//! <hr>
N//! \param clockSource selects Clock source. Valid values are
N//!       - \b TIMER_A_CLOCKSOURCE_EXTERNAL_TXCLK
N//!       - \b TIMER_A_CLOCKSOURCE_ACLK
N//!       - \b TIMER_A_CLOCKSOURCE_SMCLK
N//!       - \b TIMER_A_CLOCKSOURCE_INVERTED_EXTERNAL_TXCLK
N//! \param clockSourceDivider is the divider for Clock source. Valid values
N//!         are
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_1
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_2
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_4
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_8
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_3
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_5
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_6
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_7
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_10
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_12
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_14
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_16
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_20
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_24
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_28
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_32
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_40
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_48
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_56
N//!      - \b TIMER_A_CLOCKSOURCE_DIVIDER_64
N//! \param timerPeriod selects the desired timer period
N//! \param compareRegister selects the compare register being used.
N//!     Valid values are
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_0
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_1
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_2
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_3
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_4
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_5
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_6
N//!    <br>\n Refer to datasheet to ensure the device has the capture compare
N//!    register being used
N//! \param compareOutputMode specifies the ouput mode. Valid values are:
N//!      - \b TIMER_A_OUTPUTMODE_OUTBITVALUE,
N//!      - \b TIMER_A_OUTPUTMODE_SET,
N//!      - \b TIMER_A_OUTPUTMODE_TOGGLE_RESET,
N//!      - \b TIMER_A_OUTPUTMODE_SET_RESET
N//!      - \b TIMER_A_OUTPUTMODE_TOGGLE,
N//!      - \b TIMER_A_OUTPUTMODE_RESET,
N//!      - \b TIMER_A_OUTPUTMODE_TOGGLE_SET,
N//!      - \b TIMER_A_OUTPUTMODE_RESET_SET
N//! \param dutyCycle specifies the dutycycle for the generated waveform
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void Timer_A_generatePWM(uint32_t timer,
N                                const Timer_A_PWMConfig *config);
N
N//*****************************************************************************
N//
N//! Stops the timer
N//!
N//! \param timer is the instance of the Timer_A module. Valid parameters
N//! vary from part to part, but can include:
N//!         - \b TIMER_A0_BASE
N//!         - \b TIMER_A1_BASE
N//!         - \b TIMER_A2_BASE
N//!         - \b TIMER_A3_BASE
N//!
N//! \returns None
N//
N//*****************************************************************************
Nextern void Timer_A_stopTimer(uint32_t timer);
N
N//*****************************************************************************
N//
N//! Sets the value of the capture-compare register
N//!
N//! \param timer is the instance of the Timer_A module. Valid parameters
N//! vary from part to part, but can include:
N//!         - \b TIMER_A0_BASE
N//!         - \b TIMER_A1_BASE
N//!         - \b TIMER_A2_BASE
N//!         - \b TIMER_A3_BASE
N//! \param compareRegister selects the Capture register being used. Valid
N//!     values are
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_0
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_1
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_2
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_3
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_4
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_5
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_6
N//!    <br>\n Refer to datasheet to ensure the device has the capture compare
N//!     register being used
N//! \param compareValue is the count to be compared with in compare mode
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void Timer_A_setCompareValue(uint32_t timer,
N        uint_fast16_t compareRegister, uint_fast16_t compareValue);
N
N//*****************************************************************************
N//
N//! Returns the current value of the specified timer. Note that according to
N//! the Timer A user guide, reading the value of the counter is unreliable
N//! if the system clock is asynchronous from the timer clock. The API addresses
N//! this concern by reading the timer count register twice and then determining
N//! the integrity of the value. If the two values are within 10 timer counts
N//! of each other, the value is deemed safe and returned. If not, the process
N//! is repeated until a reliable timer value is determined.
N//!
N//! \param timer is the instance of the Timer_A module. Valid parameters
N//! vary from part to part, but can include:
N//!         - \b TIMER_A0_BASE
N//!         - \b TIMER_A1_BASE
N//!         - \b TIMER_A2_BASE
N//!         - \b TIMER_A3_BASE
N//!
N//! \returns The value of the specified timer
N//
N//*****************************************************************************
Nextern uint16_t Timer_A_getCounterValue(uint32_t timer);
N
N//*****************************************************************************
N//
N//! Clears the Timer TAIFG interrupt flag
N//!
N//! \param timer is the instance of the Timer_A module. Valid parameters
N//! vary from part to part, but can include:
N//!         - \b TIMER_A0_BASE
N//!         - \b TIMER_A1_BASE
N//!         - \b TIMER_A2_BASE
N//!         - \b TIMER_A3_BASE
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void Timer_A_clearInterruptFlag(uint32_t timer);
N
N//*****************************************************************************
N//
N//! Clears the capture-compare interrupt flag
N//!
N//! \param timer is the instance of the Timer_A module. Valid parameters
N//! vary from part to part, but can include:
N//!         - \b TIMER_A0_BASE
N//!         - \b TIMER_A1_BASE
N//!         - \b TIMER_A2_BASE
N//!         - \b TIMER_A3_BASE
N//! \param captureCompareRegister selects the Capture-compare register being
N//! used. Valid values are
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_0
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_1
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_2
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_3
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_4
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_5
N//!   - \b TIMER_A_CAPTURECOMPARE_REGISTER_6
N//!    <br>Refer to the datasheet to ensure the device has the capture compare
N//!    register being used
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void Timer_A_clearCaptureCompareInterrupt(uint32_t timer,
N        uint_fast16_t captureCompareRegister);
N
N//*****************************************************************************
N//
N//! Enable timer interrupt
N//!
N//! \param timer is the instance of the Timer_A module. Valid parameters
N//! vary from part to part, but can include:
N//!         - \b TIMER_A0_BASE
N//!         - \b TIMER_A1_BASE
N//!         - \b TIMER_A2_BASE
N//!         - \b TIMER_A3_BASE
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void Timer_A_enableInterrupt(uint32_t timer);
N
N//*****************************************************************************
N//
N//! Disable timer interrupt
N//!
N//! \param timer is the instance of the Timer_A module. Valid parameters
N//! vary from part to part, but can include:
N//!         - \b TIMER_A0_BASE
N//!         - \b TIMER_A1_BASE
N//!         - \b TIMER_A2_BASE
N//!         - \b TIMER_A3_BASE
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void Timer_A_disableInterrupt(uint32_t timer);
N
N//*****************************************************************************
N//
N//! Get timer interrupt status
N//!
N//! \param timer is the instance of the Timer_A module. Valid parameters
N//! vary from part to part, but can include:
N//!         - \b TIMER_A0_BASE
N//!         - \b TIMER_A1_BASE
N//!         - \b TIMER_A2_BASE
N//!         - \b TIMER_A3_BASE
N//!
N//! \return uint32_t. Return interrupt status. Valid values are
N//!       - \b TIMER_A_INTERRUPT_PENDING
N//!       - \b TIMER_A_INTERRUPT_NOT_PENDING
N//
N//*****************************************************************************
Nextern uint32_t Timer_A_getInterruptStatus(uint32_t timer);
N
N//*****************************************************************************
N//
N//! Get timer interrupt status masked with the enabled interrupts.
N//! This function is useful to call in ISRs to get a list of pending
N//! interrupts that are actually enabled and could have caused
N//! the ISR.
N//!
N//! \param timer is the instance of the Timer_A module. Valid parameters
N//! vary from part to part, but can include:
N//!         - \b TIMER_A0_BASE
N//!         - \b TIMER_A1_BASE
N//!         - \b TIMER_A2_BASE
N//!         - \b TIMER_A3_BASE
N//!
N//! \return uint32_t. Return interrupt status. Valid values are
N//!       - \b TIMER_A_INTERRUPT_PENDING
N//!       - \b TIMER_A_INTERRUPT_NOT_PENDING
N//
N//*****************************************************************************
Nextern uint32_t Timer_A_getEnabledInterruptStatus(uint32_t timer);
N
N//*****************************************************************************
N//
N//! Enable capture compare interrupt
N//!
N//! \param timer is the instance of the Timer_A module. Valid parameters
N//! vary from part to part, but can include:
N//!         - \b TIMER_A0_BASE
N//!         - \b TIMER_A1_BASE
N//!         - \b TIMER_A2_BASE
N//!         - \b TIMER_A3_BASE
N//! \param captureCompareRegister is the selected capture compare register
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void Timer_A_enableCaptureCompareInterrupt(uint32_t timer,
N        uint_fast16_t captureCompareRegister);
N
N//*****************************************************************************
N//
N//! Disable capture compare interrupt
N//!
N//! \param timer is the instance of the Timer_A module. Valid parameters
N//! vary from part to part, but can include:
N//!         - \b TIMER_A0_BASE
N//!         - \b TIMER_A1_BASE
N//!         - \b TIMER_A2_BASE
N//!         - \b TIMER_A3_BASE
N//! \param captureCompareRegister is the selected capture compare register
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void Timer_A_disableCaptureCompareInterrupt(uint32_t timer,
N        uint_fast16_t captureCompareRegister);
N
N//*****************************************************************************
N//
N//! Return capture compare interrupt status
N//!
N//! \param timer is the instance of the Timer_A module. Valid parameters
N//! vary from part to part, but can include:
N//!         - \b TIMER_A0_BASE
N//!         - \b TIMER_A1_BASE
N//!         - \b TIMER_A2_BASE
N//!         - \b TIMER_A3_BASE
N//! \param captureCompareRegister is the selected capture compare register
N//!
N//! \param mask is the mask for the interrupt status
N//!        Mask value is the logical OR of any of the following:
N//!        - \b TIMER_A_CAPTURE_OVERFLOW
N//!        - \b TIMER_A_CAPTURECOMPARE_INTERRUPT_FLAG
N//!
N//! \returns uint32_t. The mask of the set flags.
N//!         Valid values is an OR of
N//!       - \b TIMER_A_CAPTURE_OVERFLOW,
N//!       - \b TIMER_A_CAPTURECOMPARE_INTERRUPT_FLAG
N//
N//*****************************************************************************
Nextern uint32_t Timer_A_getCaptureCompareInterruptStatus(uint32_t timer,
N        uint_fast16_t captureCompareRegister, uint_fast16_t mask);
N
N//*****************************************************************************
N//
N//! Return capture compare interrupt status masked with the enabled interrupts.
N//! This function is useful to call in ISRs to get a list of pending
N//! interrupts that are actually enabled and could have caused
N//! the ISR.
N//!
N//! \param timer is the instance of the Timer_A module. Valid parameters
N//! vary from part to part, but can include:
N//!         - \b TIMER_A0_BASE
N//!         - \b TIMER_A1_BASE
N//!         - \b TIMER_A2_BASE
N//!         - \b TIMER_A3_BASE
N//! \param captureCompareRegister is the selected capture compare register
N//!
N//! \returns uint32_t. The mask of the set flags.
N//!         Valid values is an OR of
N//!       - \b TIMER_A_CAPTURE_OVERFLOW,
N//!       - \b TIMER_A_CAPTURECOMPARE_INTERRUPT_FLAG
N//
N//*****************************************************************************
Nextern uint32_t Timer_A_getCaptureCompareEnabledInterruptStatus(uint32_t timer,
N        uint_fast16_t captureCompareRegister);
N
N//*****************************************************************************
N//
N//! Registers an interrupt handler for the timer capture compare interrupt.
N//!
N//! \param timer is the instance of the Timer_A module. Valid parameters
N//! vary from part to part, but can include:
N//!         - \b TIMER_A0_BASE
N//!         - \b TIMER_A1_BASE
N//!         - \b TIMER_A2_BASE
N//!         - \b TIMER_A3_BASE
N//!
N//! \param interruptSelect Selects which timer interrupt handler to
N//! register. For the timer module, there are two separate interrupt handlers
N//! that can be registered:
N//!         - \b TIMER_A_CCR0_INTERRUPT Corresponds to the interrupt for CCR0
N//!         - \b TIMER_A_CCRX_AND_OVERFLOW_INTERRUPT Corresponds to the
N//!          interrupt for CCR1-6, as well as the overflow interrupt.
N//!
N//! \param intHandler is a pointer to the function to be called when the
N//! timer capture compare interrupt occurs.
N//!
N//! This function registers the handler to be called when a timer
N//! interrupt occurs. This function enables the global interrupt in the
N//! interrupt controller; specific Timer_Ainterrupts must be enabled
N//! via Timer_A_enableInterrupt().  It is the interrupt handler's
N//! responsibility to clear the interrupt source
N//! via Timer_A_clearCaptureCompareInterrupt().
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void Timer_A_registerInterrupt(uint32_t timer,
N        uint_fast8_t interruptSelect, void (*intHandler)(void));
N
N//*****************************************************************************
N//
N//! Unregisters the interrupt handler for the timer
N//!
N//! \param timer is the instance of the Timer_A module. Valid parameters
N//! vary from part to part, but can include:
N//!         - \b TIMER_A0_BASE
N//!         - \b TIMER_A1_BASE
N//!         - \b TIMER_A2_BASE
N//!         - \b TIMER_A3_BASE
N//!
N//! \param interruptSelect Selects which timer interrupt handler to
N//! register. For the timer module, there are two separate interrupt handlers
N//! that can be registered:
N//!         - \b TIMER_A_CCR0_INTERRUPT Corresponds to the interrupt for CCR0
N//!         - \b TIMER_A_CCRX_AND_OVERFLOW_INTERRUPT Corresponds to the
N//!          interrupt for CCR1-6, as well as the overflow interrupt.
N//!
N//! This function unregisters the handler to be called when timer
N//! interrupt occurs.  This function also masks off the interrupt in the
N//! interrupt controller so that the interrupt handler no longer is called.
N//!
N//! \sa Interrupt_registerInterrupt() for important information about
N//! registering interrupt handlers.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void Timer_A_unregisterInterrupt(uint32_t timer,
N        uint_fast8_t interruptSelect);
N
N/* Backwards Compatibility Layer */
N#define Timer_A_clearTimerInterrupt Timer_A_clearInterruptFlag
N#define Timer_A_clear Timer_A_clearTimer
N#define Timer_A_initCaptureMode Timer_A_initCapture
N#define Timer_A_initCompareMode Timer_A_initCompare
N#define Timer_A_initContinuousMode Timer_A_configureContinuousMode
N#define Timer_A_initUpDownMode Timer_A_configureUpDownMode
N#define Timer_A_initUpMode Timer_A_configureUpMode
N#define Timer_A_outputPWM Timer_A_generatePWM
N#define Timer_A_stop Timer_A_stopTimer
N
N//*****************************************************************************
N//
N// Mark the end of the C bindings section for C++ compilers.
N//
N//*****************************************************************************
N#ifdef __cplusplus
N}
N#endif
N
N//*****************************************************************************
N//
N// Close the Doxygen group.
N//! @}
N//
N//*****************************************************************************
N
N#endif /* TIMERA_H_ */
L 67 "C:/ti/msp432_driverlib_3_21_00_05/driverlib/MSP432P4xx/driverlib.h" 2
N#include "uart.h"
L 1 "C:\ti\msp432_driverlib_3_21_00_05\driverlib\MSP432P4xx\uart.h" 1
N/*
N * -------------------------------------------
N *    MSP432 DriverLib - v3_21_00_05 
N * -------------------------------------------
N *
N * --COPYRIGHT--,BSD,BSD
N * Copyright (c) 2016, Texas Instruments Incorporated
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N *
N * *  Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N *
N * *  Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * *  Neither the name of Texas Instruments Incorporated nor the names of
N *    its contributors may be used to endorse or promote products derived
N *    from this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
N * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
N * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
N * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
N * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
N * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
N * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
N * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
N * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * --/COPYRIGHT--*/
N#ifndef UART_H_
N#define UART_H_
N
N//*****************************************************************************
N//
N//! \addtogroup uart_api
N//! @{
N//
N//*****************************************************************************
N
N//*****************************************************************************
N//
N// If building with a C++ compiler, make all of the definitions in this header
N// have a C binding.
N//
N//*****************************************************************************
N#ifdef __cplusplus
Nextern "C"
N{
N#endif
N
N#include <stdint.h>
N#include <stdbool.h>
N
N#include <msp.h>
N#include "eusci.h"
N
N#define DEFAULT_SYNC                                    0x00
N#define EUSCI_A_UART_AUTOMATICBAUDRATE_SYNC             0x55
N
N#define EUSCI_A_UART_NO_PARITY                          0x00
N#define EUSCI_A_UART_ODD_PARITY                         0x01
N#define EUSCI_A_UART_EVEN_PARITY                        0x02
N
N#define EUSCI_A_UART_MSB_FIRST                          EUSCI_A_CTLW0_MSB
N#define EUSCI_A_UART_LSB_FIRST                          0x00
N
N#define EUSCI_A_UART_MODE                               EUSCI_A_CTLW0_MODE_0
N#define EUSCI_A_UART_IDLE_LINE_MULTI_PROCESSOR_MODE        EUSCI_A_CTLW0_MODE_1
N#define EUSCI_A_UART_ADDRESS_BIT_MULTI_PROCESSOR_MODE   EUSCI_A_CTLW0_MODE_2
N#define EUSCI_A_UART_AUTOMATIC_BAUDRATE_DETECTION_MODE  EUSCI_A_CTLW0_MODE_3
N
N#define EUSCI_A_UART_CLOCKSOURCE_SMCLK                  EUSCI_A_CTLW0_SSEL__SMCLK
N#define EUSCI_A_UART_CLOCKSOURCE_ACLK                   EUSCI_A_CTLW0_SSEL__ACLK
N
N#define EUSCI_A_UART_ONE_STOP_BIT                       0x00
N#define EUSCI_A_UART_TWO_STOP_BITS                      EUSCI_A_CTLW0_SPB
N
N#define EUSCI_A_UART_OVERSAMPLING_BAUDRATE_GENERATION   0x01
N#define EUSCI_A_UART_LOW_FREQUENCY_BAUDRATE_GENERATION  0x00
N
N#define EUSCI_A_UART_RECEIVE_INTERRUPT                  EUSCI_A_IE_RXIE
N#define EUSCI_A_UART_TRANSMIT_INTERRUPT                 EUSCI_A_IE_TXIE
N#define EUSCI_A_UART_RECEIVE_ERRONEOUSCHAR_INTERRUPT    EUSCI_A_CTLW0_RXEIE
N#define EUSCI_A_UART_BREAKCHAR_INTERRUPT                EUSCI_A_CTLW0_BRKIE
N#define EUSCI_A_UART_STARTBIT_INTERRUPT                 EUSCI_A_IE_STTIE
N#define EUSCI_A_UART_TRANSMIT_COMPLETE_INTERRUPT        EUSCI_B_IE_STPIE
N
N#define EUSCI_A_UART_RECEIVE_INTERRUPT_FLAG             EUSCI_A_IFG_RXIFG
N#define EUSCI_A_UART_TRANSMIT_INTERRUPT_FLAG            EUSCI_A_IFG_TXIFG
N#define EUSCI_A_UART_STARTBIT_INTERRUPT_FLAG            EUSCI_A_IFG_STTIFG
N#define EUSCI_A_UART_TRANSMIT_COMPLETE_INTERRUPT_FLAG   EUSCI_A_IFG_TXCPTIFG
N
N#define EUSCI_A_UART_LISTEN_ENABLE                      EUSCI_A_STATW_LISTEN
N#define EUSCI_A_UART_FRAMING_ERROR                      EUSCI_A_STATW_FE
N#define EUSCI_A_UART_OVERRUN_ERROR                      EUSCI_A_STATW_OE
N#define EUSCI_A_UART_PARITY_ERROR                       EUSCI_A_STATW_PE
N#define EUSCI_A_UART_BREAK_DETECT                       EUSCI_A_STATW_BRK
N#define EUSCI_A_UART_RECEIVE_ERROR                      EUSCI_A_STATW_RXERR
N#define EUSCI_A_UART_ADDRESS_RECEIVED                   EUSCI_A_STATW_ADDR_IDLE
N#define EUSCI_A_UART_IDLELINE                           EUSCI_A_STATW_ADDR_IDLE
N#define EUSCI_A_UART_BUSY                               EUSCI_A_STATW_BUSY
N
N#define EUSCI_A_UART_DEGLITCH_TIME_2ns                  0x00
N#define EUSCI_A_UART_DEGLITCH_TIME_50ns                 0x0001
N#define EUSCI_A_UART_DEGLITCH_TIME_100ns                0x0002
N#define EUSCI_A_UART_DEGLITCH_TIME_200ns                (0x0001 + 0x0002)
N
N//*****************************************************************************
N//
N//!     ypedef eUSCI_eUSCI_UART_Config
N//! \brief Type definition for \link _eUSCI_UART_Config \endlink
N//!     structure
N//!
N//! \struct _eUSCI_eUSCI_UART_Config
N//! \brief Configuration structure for compare mode in the \b UART module. See
N//!          \link UART_initModule \endlink for parameter
N//!                 documentation.
N//
N//*****************************************************************************
Ntypedef struct _eUSCI_eUSCI_UART_Config
N{
N    uint_fast8_t selectClockSource;
N    uint_fast16_t clockPrescalar;
N    uint_fast8_t firstModReg;
N    uint_fast8_t secondModReg;
N    uint_fast8_t parity;
N    uint_fast16_t msborLsbFirst;
N    uint_fast16_t numberofStopBits;
N    uint_fast16_t uartMode;
N    uint_fast8_t overSampling;
N} eUSCI_UART_Config;
N
N//*****************************************************************************
N//
N//! Initialization routine for the UART block. The values to be written
N//! into the UCAxBRW and UCAxMCTLW registers should be pre-computed and passed
N//! into the initialization function
N//!
N//! \param moduleInstance is the instance of the eUSCI A (UART) module.
N//! Valid parameters vary from part to part, but can include:
N//!         - \b EUSCI_A0_BASE
N//!         - \b EUSCI_A1_BASE
N//!         - \b EUSCI_A2_BASE
N//!         - \b EUSCI_A3_BASE
N//! \param config Configuration structure for the UART module
N//!
N//! <hr>
N//! <b>Configuration options for \link eUSCI_UART_Config \endlink
N//!         structure.</b>
N//! <hr>
N//!  <br> It is important to note that for eUSCI modules, only "A" modules such
N//!  as EUSCI_A0 can be used. "B" modules such as EUSCI_B0 do not support the
N//!  UART mode.
N//! \param selectClockSource selects Clock source. Valid values are
N//!       - \b EUSCI_A_UART_CLOCKSOURCE_SMCLK
N//!       - \b EUSCI_A_UART_CLOCKSOURCE_ACLK
N//! \param clockPrescalar is the value to be written into UCBRx bits
N//! \param firstModReg  is First modulation stage register setting. This
N//!     value is a pre-calculated value which can be obtained from the Device
N//!     User Guide.This value is written into UCBRFx bits of UCAxMCTLW.
N//! \param secondModReg is Second modulation stage register setting.
N//!     This value is a pre-calculated value which can be obtained from the
N//!     Device User Guide. This value is written into UCBRSx bits of
N//!     UCAxMCTLW.
N//! \param parity is the desired parity. Valid values are
N//!      - \b EUSCI_A_UART_NO_PARITY  [Default Value],
N//!      - \b EUSCI_A_UART_ODD_PARITY,
N//!      - \b EUSCI_A_UART_EVEN_PARITY
N//! \param msborLsbFirst controls direction of receive and transmit shift
N//!     register. Valid values are
N//!      - \b EUSCI_A_UART_MSB_FIRST
N//!      - \b EUSCI_A_UART_LSB_FIRST [Default Value]
N//! \param numberofStopBits indicates one/two STOP bits
N//!      Valid values are
N//!      - \b EUSCI_A_UART_ONE_STOP_BIT [Default Value]
N//!      - \b EUSCI_A_UART_TWO_STOP_BITS
N//! \param uartMode selects the mode of operation
N//!      Valid values are
N//!      - \b EUSCI_A_UART_MODE  [Default Value],
N//!      - \b EUSCI_A_UART_IDLE_LINE_MULTI_PROCESSOR_MODE,
N//!      - \b EUSCI_A_UART_ADDRESS_BIT_MULTI_PROCESSOR_MODE,
N//!      - \b EUSCI_A_UART_AUTOMATIC_BAUDRATE_DETECTION_MODE
N//! \param overSampling indicates low frequency or oversampling baud
N//!      generation
N//!     Valid values are
N//!      - \b EUSCI_A_UART_OVERSAMPLING_BAUDRATE_GENERATION
N//!      - \b EUSCI_A_UART_LOW_FREQUENCY_BAUDRATE_GENERATION
N//!
N//! Upon successful initialization of the UART block, this function
N//! will have initialized the module, but the UART block still remains
N//! disabled and must be enabled with UART_enableModule()
N//!
N//! Refer to
N//! <a href="http://software-dl.ti.com/msp430/msp430_public_sw/mcu/msp430/MSP430BaudRateConverter/index.html">
N//! this calculator </a> for help on calculating values for the parameters.
N//!
N//! Modified bits are \b UCPEN, \b UCPAR, \b UCMSB, \b UC7BIT, \b UCSPB,
N//! \b UCMODEx, \b UCSYNC bits of \b UCAxCTL0 and \b UCSSELx,
N//! \b UCSWRST bits of \b UCAxCTL1
N//!
N//! \return true or
N//!         STATUS_FAIL of the initialization process
N//
N//*****************************************************************************
Nextern bool UART_initModule(uint32_t moduleInstance,
N        const eUSCI_UART_Config *config);
N
N//*****************************************************************************
N//
N//! Transmits a byte from the UART Module.
N//!
N//! \param moduleInstance is the instance of the eUSCI A (UART) module.
N//! Valid parameters vary from part to part, but can include:
N//!         - \b EUSCI_A0_BASE
N//!         - \b EUSCI_A1_BASE
N//!         - \b EUSCI_A2_BASE
N//!         - \b EUSCI_A3_BASE
N//!  <br> It is important to note that for eUSCI modules, only "A" modules such
N//!  as EUSCI_A0 can be used. "B" modules such as EUSCI_B0 do not support the
N//!  UART mode
N//! \param transmitData data to be transmitted from the UART module
N//!
N//! This function will place the supplied data into UART transmit data register
N//! to start transmission
N//!
N//! Modified register is \b UCAxTXBUF
N//! \return None.
N//
N//*****************************************************************************
Nextern void UART_transmitData(uint32_t moduleInstance,
N        uint_fast8_t transmitData);
N
N//*****************************************************************************
N//
N//! Receives a byte that has been sent to the UART Module.
N//!
N//! \param moduleInstance is the instance of the eUSCI A (UART) module.
N//! Valid parameters vary from part to part, but can include:
N//!         - \b EUSCI_A0_BASE
N//!         - \b EUSCI_A1_BASE
N//!         - \b EUSCI_A2_BASE
N//!         - \b EUSCI_A3_BASE
N//!  <br> It is important to note that for eUSCI modules, only "A" modules such
N//!  as  EUSCI_A0 can be used. "B" modules such as EUSCI_B0 do not support the
N//!  UART mode
N//!
N//! This function reads a byte of data from the UART receive data Register.
N//!
N//! Modified register is \b UCAxRXBUF
N//!
N//! \return Returns the byte received from by the UART module, cast as an
N//! uint8_t.
N//
N//*****************************************************************************
Nextern uint8_t UART_receiveData(uint32_t moduleInstance);
N
N//*****************************************************************************
N//
N//! Enables the UART block.
N//!
N//! \param moduleInstance is the instance of the eUSCI A (UART) module.
N//! Valid parameters vary from part to part, but can include:
N//!         - \b EUSCI_A0_BASE
N//!         - \b EUSCI_A1_BASE
N//!         - \b EUSCI_A2_BASE
N//!         - \b EUSCI_A3_BASE
N//!  <br> It is important to note that for eUSCI modules, only "A" modules such
N//!  as EUSCI_A0 can be used. "B" modules such as EUSCI_B0 do not support the
N//!  UART mode
N//!
N//! This will enable operation of the UART block.
N//!
N//! Modified register is \b UCAxCTL1
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void UART_enableModule(uint32_t moduleInstance);
N
N//*****************************************************************************
N//
N//! Disables the UART block.
N//!
N//! \param moduleInstance is the instance of the eUSCI A (UART) module.
N//! Valid parameters vary from part to part, but can include:
N//!         - \b EUSCI_A0_BASE
N//!         - \b EUSCI_A1_BASE
N//!         - \b EUSCI_A2_BASE
N//!         - \b EUSCI_A3_BASE
N//!  <br> It is important to note that for eUSCI modules, only "A" modules such
N//!  as EUSCI_A0 can be used. "B" modules such as EUSCI_B0 do not support the
N//!  UART mode
N//!
N//! This will disable operation of the UART block.
N//!
N//! Modified register is \b UCAxCTL1
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void UART_disableModule(uint32_t moduleInstance);
N
N//*****************************************************************************
N//
N//! Gets the current UART status flags.
N//!
N//! \param moduleInstance is the instance of the eUSCI A (UART) module.
N//! Valid parameters vary from part to part, but can include:
N//!         - \b EUSCI_A0_BASE
N//!         - \b EUSCI_A1_BASE
N//!         - \b EUSCI_A2_BASE
N//!         - \b EUSCI_A3_BASE
N//!  <br> It is important to note that for eUSCI modules, only "A" modules such
N//!  as EUSCI_A0 can be used. "B" modules such as EUSCI_B0 do not support the
N//!  UART mode
N//! \param mask is the masked interrupt flag status to be returned.
N//!
N//! This returns the status for the UART  module based on which
N//! flag is passed. mask parameter can be either any of the following
N//! selection.
N//! - \b EUSCI_A_UART_LISTEN_ENABLE
N//! - \b EUSCI_A_UART_FRAMING_ERROR
N//! - \b EUSCI_A_UART_OVERRUN_ERROR
N//! - \b EUSCI_A_UART_PARITY_ERROR
N//! - \b eUARTBREAK_DETECT
N//! - \b EUSCI_A_UART_RECEIVE_ERROR
N//! - \b EUSCI_A_UART_ADDRESS_RECEIVED
N//! - \b EUSCI_A_UART_IDLELINE
N//! - \b EUSCI_A_UART_BUSY
N//!
N//! Modified register is \b UCAxSTAT
N//!
N//! \return the masked status flag
N//
N//*****************************************************************************
Nextern uint_fast8_t UART_queryStatusFlags(uint32_t moduleInstance,
N        uint_fast8_t mask);
N
N//*****************************************************************************
N//
N//! Sets the UART module in dormant mode
N//!
N//! \param moduleInstance is the instance of the eUSCI A (UART) module.
N//! Valid parameters vary from part to part, but can include:
N//!         - \b EUSCI_A0_BASE
N//!         - \b EUSCI_A1_BASE
N//!         - \b EUSCI_A2_BASE
N//!         - \b EUSCI_A3_BASE
N//!  <br> It is important to note that for eUSCI modules, only "A" modules such
N//!  as EUSCI_A0 can be used. "B" modules such as EUSCI_B0 do not support the
N//!  UART mode
N//!
N//! Puts USCI in sleep mode
N//! Only characters that are preceded by an idle-line or with address bit set
N//! UCRXIFG. In UART mode with automatic baud-rate detection, only the
N//! combination of a break and synch field sets UCRXIFG.
N//!
N//! Modified register is \b UCAxCTL1
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void UART_setDormant(uint32_t moduleInstance);
N
N//*****************************************************************************
N//
N//! Re-enables UART module from dormant mode
N//!
N//! \param moduleInstance is the instance of the eUSCI A (UART) module.
N//! Valid parameters vary from part to part, but can include:
N//!         - \b EUSCI_A0_BASE
N//!         - \b EUSCI_A1_BASE
N//!         - \b EUSCI_A2_BASE
N//!         - \b EUSCI_A3_BASE
N//!  <br> It is important to note that for eUSCI modules, only "A" modules such
N//!  as EUSCI_A0 can be used. "B" modules such as EUSCI_B0 do not support the
N//!  UART mode
N//!
N//! Not dormant. All received characters set UCRXIFG.
N//!
N//! Modified bits are \b UCDORM of \b UCAxCTL1 register.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void UART_resetDormant(uint32_t moduleInstance);
N
N//*****************************************************************************
N//
N//! Transmits the next byte to be transmitted marked as address depending on
N//! selected multiprocessor mode
N//!
N//! \param moduleInstance is the instance of the eUSCI A (UART) module.
N//! Valid parameters vary from part to part, but can include:
N//!         - \b EUSCI_A0_BASE
N//!         - \b EUSCI_A1_BASE
N//!         - \b EUSCI_A2_BASE
N//!         - \b EUSCI_A3_BASE
N//!  <br> It is important to note that for eUSCI modules, only "A" modules such
N//!  as EUSCI_A0 can be used. "B" modules such as EUSCI_B0 do not support the
N//!  UART mode
N//! \param transmitAddress is the next byte to be transmitted
N//!
N//! Modified register is \b UCAxCTL1, \b UCAxTXBUF
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void UART_transmitAddress(uint32_t moduleInstance,
N        uint_fast8_t transmitAddress);
N
N//*****************************************************************************
N//
N//! Transmit break. Transmits a break with the next write to the transmit
N//! buffer. In UART mode with automatic baud-rate detection,
N//! EUSCI_A_UART_AUTOMATICBAUDRATE_SYNC(0x55) must be written into UCAxTXBUF to
N//! generate the required break/synch fields.
N//! Otherwise, DEFAULT_SYNC(0x00) must be written into the transmit buffer.
N//! Also ensures module is ready for transmitting the next data
N//!
N//! \param moduleInstance is the instance of the eUSCI A (UART) module.
N//! Valid parameters vary from part to part, but can include:
N//!         - \b EUSCI_A0_BASE
N//!         - \b EUSCI_A1_BASE
N//!         - \b EUSCI_A2_BASE
N//!         - \b EUSCI_A3_BASE
N//!  <br> It is important to note that for eUSCI modules, only "A" modules such
N//!  asEUSCI_A0 can be used. "B" modules such as EUSCI_B0 do not support the
N//!  UART mode
N//!
N//! Modified register is \b UCAxCTL1, \b UCAxTXBUF
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void UART_transmitBreak(uint32_t moduleInstance);
N
N//*****************************************************************************
N//
N//! Returns the address of the RX Buffer of the UART for the DMA module.
N//!
N//! \param moduleInstance is the instance of the eUSCI A (UART) module.
N//! Valid parameters vary from part to part, but can include:
N//!         - \b EUSCI_A0_BASE
N//!         - \b EUSCI_A1_BASE
N//!         - \b EUSCI_A2_BASE
N//!         - \b EUSCI_A3_BASE
N//!  <br> It is important to note that for eUSCI modules, only "A" modules such
N//!  as EUSCI_A0 can be used. "B" modules such as EUSCI_B0 do not support the
N//!  UART mode
N//!
N//! Returns the address of the UART RX Buffer. This can be used in conjunction
N//! with the DMA to store the received data directly to memory.
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern uint32_t UART_getReceiveBufferAddressForDMA(uint32_t moduleInstance);
N
N//*****************************************************************************
N//
N//! Returns the address of the TX Buffer of the UART for the DMA module.
N//!
N//! \param moduleInstance is the instance of the eUSCI A (UART) module.
N//! Valid parameters vary from part to part, but can include:
N//!         - \b EUSCI_A0_BASE
N//!         - \b EUSCI_A1_BASE
N//!         - \b EUSCI_A2_BASE
N//!         - \b EUSCI_A3_BASE
N//!  <br> It is important to note that for eUSCI modules, only "A" modules such
N//!  as EUSCI_A0 can be used. "B" modules such as EUSCI_B0 do not support the
N//!  UART mode
N//!
N//! Returns the address of the UART TX Buffer. This can be used in conjunction
N//! with the DMA to obtain transmitted data directly from memory.
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern uint32_t UART_getTransmitBufferAddressForDMA(uint32_t moduleInstance);
N
N//*****************************************************************************
N//
N//! Sets the deglitch time
N//!
N//! \param moduleInstance is the instance of the eUSCI A (UART) module.
N//! Valid parameters vary from part to part, but can include:
N//!         - \b EUSCI_A0_BASE
N//!         - \b EUSCI_A1_BASE
N//!         - \b EUSCI_A2_BASE
N//!         - \b EUSCI_A3_BASE
N//!  <br> It is important to note that for eUSCI modules, only "A" modules such
N//!  as EUSCI_A0 can be used. "B" modules such as EUSCI_B0 do not support the
N//!  UART mode
N//! \param deglitchTime is the selected deglitch time
N//!     Valid values are
N//!         - \b EUSCI_A_UART_DEGLITCH_TIME_2ns
N//!         - \b EUSCI_A_UART_DEGLITCH_TIME_50ns
N//!         - \b EUSCI_A_UART_DEGLITCH_TIME_100ns
N//!         - \b EUSCI_A_UART_DEGLITCH_TIME_200ns
N//!
N//!
N//! Returns the address of the UART TX Buffer. This can be used in conjunction
N//! with the DMA to obtain transmitted data directly from memory.
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void UART_selectDeglitchTime(uint32_t moduleInstance,
N        uint32_t deglitchTime);
N
N//*****************************************************************************
N//
N//! Enables individual UART interrupt sources.
N//!
N//! \param moduleInstance is the instance of the eUSCI A (UART) module.
N//! Valid parameters vary from part to part, but can include:
N//!         - \b EUSCI_A0_BASE
N//!         - \b EUSCI_A1_BASE
N//!         - \b EUSCI_A2_BASE
N//!         - \b EUSCI_A3_BASE
N//!  <br> It is important to note that for eUSCI modules, only "A" modules such
N//!  as EUSCI_A0 can be used. "B" modules such as EUSCI_B0 do not support the
N//!  UART mode
N//! \param mask is the bit mask of the interrupt sources to be enabled.
N//!
N//! Enables the indicated UART interrupt sources.  The interrupt flag is first
N//! and then the corresponding interrupt is enabled. Only the sources that
N//! are enabled can be reflected to the processor interrupt; disabled sources
N//! have no effect on the processor.
N//!
N//! The mask parameter is the logical OR of any of the following:
N//! - \b EUSCI_A_UART_RECEIVE_INTERRUPT -Receive interrupt
N//! - \b EUSCI_A_UART_TRANSMIT_INTERRUPT - Transmit interrupt
N//! - \b EUSCI_A_UART_RECEIVE_ERRONEOUSCHAR_INTERRUPT - Receive
N//!                             erroneous-character interrupt enable
N//! - \b EUSCI_A_UART_BREAKCHAR_INTERRUPT - Receive break character interrupt
N//!                                           enable
N//!
N//! Modified register is \b UCAxIFG, \b UCAxIE and \b UCAxCTL1
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void UART_enableInterrupt(uint32_t moduleInstance, uint_fast8_t mask);
N
N//*****************************************************************************
N//
N//! Disables individual UART interrupt sources.
N//!
N//! \param moduleInstance is the instance of the eUSCI A (UART) module.
N//! Valid parameters vary from part to part, but can include:
N//!         - \b EUSCI_A0_BASE
N//!         - \b EUSCI_A1_BASE
N//!         - \b EUSCI_A2_BASE
N//!         - \b EUSCI_A3_BASE
N//!  <br> It is important to note that for eUSCI modules, only "A" modules such
N//!  as EUSCI_A0 can be used. "B" modules such as EUSCI_B0 do not support the
N//!  UART mode
N//! \param mask is the bit mask of the interrupt sources to be
N//! disabled.
N//!
N//! Disables the indicated UART interrupt sources.  Only the sources that
N//! are enabled can be reflected to the processor interrupt; disabled sources
N//! have no effect on the processor.
N//!
N//! The mask parameter is the logical OR of any of the following:
N//! - \b EUSCI_A_UART_RECEIVE_INTERRUPT -Receive interrupt
N//! - \b EUSCI_A_UART_TRANSMIT_INTERRUPT - Transmit interrupt
N//! - \b EUSCI_A_UART_RECEIVE_ERRONEOUSCHAR_INTERRUPT - Receive
N//!                             erroneous-character interrupt enable
N//! - \b EUSCI_A_UART_BREAKCHAR_INTERRUPT - Receive break character interrupt
N//!                                             enable
N//!
N//! Modified register is \b UCAxIFG, \b UCAxIE and \b UCAxCTL1
N//! \return None.
N//
N//*****************************************************************************
Nextern void UART_disableInterrupt(uint32_t moduleInstance, uint_fast8_t mask);
N
N//*****************************************************************************
N//
N//! Gets the current UART interrupt status.
N//!
N//! \param moduleInstance is the instance of the eUSCI A (UART) module.
N//! Valid parameters vary from part to part, but can include:
N//!         - \b EUSCI_A0_BASE
N//!         - \b EUSCI_A1_BASE
N//!         - \b EUSCI_A2_BASE
N//!         - \b EUSCI_A3_BASE
N//!  <br> It is important to note that for eUSCI modules, only "A" modules such
N//!  as EUSCI_A0 can be used. "B" modules such as EUSCI_B0 do not support the
N//!  UART mode
N//! \param mask is the masked interrupt flag status to be returned.
N//!        Mask value is the logical OR of any of the following:
N//!        - \b EUSCI_A_UART_RECEIVE_INTERRUPT_FLAG
N//!        - \b EUSCI_A_UART_TRANSMIT_INTERRUPT_FLAG
N//!        - \b EUSCI_A_UART_STARTBIT_INTERRUPT_FLAG
N//!        - \b EUSCI_A_UART_TRANSMIT_COMPLETE_INTERRUPT_FLAG
N//!
N//!
N//! \return The current interrupt status as an ORed bit mask:
N//! - \b EUSCI_A_UART_RECEIVE_INTERRUPT_FLAG -Receive interrupt flag
N//! - \b EUSCI_A_UART_TRANSMIT_INTERRUPT_FLAG - Transmit interrupt flag
N//
N//*****************************************************************************
Nextern uint_fast8_t UART_getInterruptStatus(uint32_t moduleInstance,
N        uint8_t mask);
N
N//*****************************************************************************
N//
N//! Gets the current UART interrupt status masked with the enabled interrupts.
N//! This function is useful to call in ISRs to get a list of pending
N//! interrupts that are actually enabled and could have caused
N//! the ISR.
N
N//!
N//! \param moduleInstance is the instance of the eUSCI A (UART) module.
N//! Valid parameters vary from part to part, but can include:
N//!         - \b EUSCI_A0_BASE
N//!         - \b EUSCI_A1_BASE
N//!         - \b EUSCI_A2_BASE
N//!         - \b EUSCI_A3_BASE
N//!  <br> It is important to note that for eUSCI modules, only "A" modules such
N//!  as EUSCI_A0 can be used. "B" modules such as EUSCI_B0 do not support the
N//!  UART mode
N//!
N//! \return The current interrupt status as an ORed bit mask:
N//! - \b EUSCI_A_UART_RECEIVE_INTERRUPT_FLAG -Receive interrupt flag
N//! - \b EUSCI_A_UART_TRANSMIT_INTERRUPT_FLAG - Transmit interrupt flag
N//
N//*****************************************************************************
Nextern uint_fast8_t UART_getEnabledInterruptStatus(uint32_t moduleInstance);
N
N//*****************************************************************************
N//
N//! Clears UART interrupt sources.
N//!
N//! \param moduleInstance is the instance of the eUSCI A (UART) module.
N//! Valid parameters vary from part to part, but can include:
N//!         - \b EUSCI_A0_BASE
N//!         - \b EUSCI_A1_BASE
N//!         - \b EUSCI_A2_BASE
N//!         - \b EUSCI_A3_BASE
N//!  <br> It is important to note that for eUSCI modules, only "A" modules such
N//!  as EUSCI_A0 can be used. "B" modules such as EUSCI_B0 do not support the
N//!  UART mode
N//! \param mask is a bit mask of the interrupt sources to be cleared.
N//!
N//! The UART interrupt source is cleared, so that it no longer asserts.
N//! The highest interrupt flag is automatically cleared when an interrupt vector
N//! generator is used.
N//!
N//! The mask parameter has the same definition as the mask parameter to
N//! EUSCI_A_UART_enableInterrupt().
N//!
N//! Modified register is \b UCAxIFG
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void UART_clearInterruptFlag(uint32_t moduleInstance, uint_fast8_t mask);
N
N//*****************************************************************************
N//
N//! Registers an interrupt handler for UART interrupts.
N//!
N//! \param moduleInstance is the instance of the eUSCI A (UART) module.
N//! Valid parameters vary from part to part, but can include:
N//!         - \b EUSCI_A0_BASE
N//!         - \b EUSCI_A1_BASE
N//!         - \b EUSCI_A2_BASE
N//!         - \b EUSCI_A3_BASE
N//!  <br> It is important to note that for eUSCI modules, only "A" modules such
N//!  as EUSCI_A0 can be used. "B" modules such as EUSCI_B0 do not support the
N//!  UART mode.
N//!
N//! \param intHandler is a pointer to the function to be called when the
N//! timer capture compare interrupt occurs.
N//!
N//! This function registers the handler to be called when an UART
N//! interrupt occurs. This function enables the global interrupt in the
N//! interrupt controller; specific UART interrupts must be enabled
N//! via UART_enableInterrupt().  It is the interrupt handler's responsibility to
N//! clear the interrupt source via UART_clearInterruptFlag().
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void UART_registerInterrupt(uint32_t moduleInstance,
N        void (*intHandler)(void));
N
N//*****************************************************************************
N//
N//! Unregisters the interrupt handler for the UART module
N//!
N//! \param moduleInstance is the instance of the eUSCI A (UART) module.
N//! Valid parameters vary from part to part, but can include:
N//!         - \b EUSCI_A0_BASE
N//!         - \b EUSCI_A1_BASE
N//!         - \b EUSCI_A2_BASE
N//!         - \b EUSCI_A3_BASE
N//!  <br> It is important to note that for eUSCI modules, only "A" modules such
N//!  as EUSCI_A0 can be used. "B" modules such as EUSCI_B0 do not support the
N//!  UART mode.
N//!
N//! This function unregisters the handler to be called when timer
N//! interrupt occurs.  This function also masks off the interrupt in the
N//! interrupt controller so that the interrupt handler no longer is called.
N//!
N//! \sa Interrupt_registerInterrupt() for important information about
N//! registering interrupt handlers.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void UART_unregisterInterrupt(uint32_t moduleInstance);
N
N/* Backwards Compatibility Layer */
N#define EUSCI_A_UART_transmitData UART_transmitData
N#define EUSCI_A_UART_receiveData UART_receiveData
N#define EUSCI_A_UART_enableInterrupt UART_enableInterrupt
N#define EUSCI_A_UART_disableInterrupt UART_disableInterrupt
N#define EUSCI_A_UART_getInterruptStatus UART_getInterruptStatus
N#define EUSCI_A_UART_clearInterruptFlag UART_clearInterruptFlag
N#define EUSCI_A_UART_enable UART_enableModule
N#define EUSCI_A_UART_disable UART_disableModule
N#define EUSCI_A_UART_queryStatusFlags UART_queryStatusFlags
N#define EUSCI_A_UART_setDormant UART_setDormant
N#define EUSCI_A_UART_resetDormant UART_resetDormant
N#define EUSCI_A_UART_transmitAddress UART_transmitAddress
N#define EUSCI_A_UART_transmitBreak UART_transmitBreak
N#define EUSCI_A_UART_getReceiveBufferAddressForDMA UART_getReceiveBufferAddressForDMA
N#define EUSCI_A_UART_getTransmitBufferAddressForDMA UART_getTransmitBufferAddressForDMA
N#define EUSCI_A_UART_selectDeglitchTime UART_selectDeglitchTime
N
N//*****************************************************************************
N//
N// Mark the end of the C bindings section for C++ compilers.
N//
N//*****************************************************************************
N#ifdef __cplusplus
N}
N#endif
N
N//*****************************************************************************
N//
N// Close the Doxygen group.
N//! @}
N//
N//*****************************************************************************
N
N#endif /* UART_H_ */
L 68 "C:/ti/msp432_driverlib_3_21_00_05/driverlib/MSP432P4xx/driverlib.h" 2
N#include "wdt_a.h"
L 1 "C:\ti\msp432_driverlib_3_21_00_05\driverlib\MSP432P4xx\wdt_a.h" 1
N/*
N * -------------------------------------------
N *    MSP432 DriverLib - v3_21_00_05 
N * -------------------------------------------
N *
N * --COPYRIGHT--,BSD,BSD
N * Copyright (c) 2016, Texas Instruments Incorporated
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N *
N * *  Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N *
N * *  Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * *  Neither the name of Texas Instruments Incorporated nor the names of
N *    its contributors may be used to endorse or promote products derived
N *    from this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
N * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
N * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
N * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
N * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
N * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
N * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
N * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
N * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * --/COPYRIGHT--*/
N#ifndef __WATCHDOG_H__
N#define __WATCHDOG_H__
N
N//*****************************************************************************
N//
N//! \addtogroup wdt_api
N//! @{
N//
N//*****************************************************************************
N
N//*****************************************************************************
N//
N// If building with a C++ compiler, make all of the definitions in this header
N// have a C binding.
N//
N//*****************************************************************************
N#ifdef __cplusplus
Nextern "C"
N{
N#endif
N
N#include <msp.h>
N#include <stdint.h>
N#include "sysctl.h"
N
N#define WDT_A_HARD_RESET SYSCTL_HARD_RESET
N#define WDT_A_SOFT_RESET SYSCTL_SOFT_RESET
N
N//*****************************************************************************
N//
N// The following are values that can be passed to the clockSelect parameter for
N// functions: WDT_A_watchdogTimerInit(), and WDT_A_intervalTimerInit().
N//
N//*****************************************************************************
N#define WDT_A_CLOCKSOURCE_SMCLK                                     (WDT_A_CTL_SSEL_0)
N#define WDT_A_CLOCKSOURCE_ACLK                                      (WDT_A_CTL_SSEL_1)
N#define WDT_A_CLOCKSOURCE_VLOCLK                                    (WDT_A_CTL_SSEL_2)
N#define WDT_A_CLOCKSOURCE_XCLK                                      (WDT_A_CTL_SSEL_3)
N#define WDT_A_CLOCKSOURCE_BCLK                                      (WDT_A_CTL_SSEL_4)
N
N//*****************************************************************************
N//
N// The following are values that can be passed to the clockDivider parameter
N// for functions: WDT_A_watchdogTimerInit(), and WDT_A_intervalTimerInit().
N//
N//*****************************************************************************
N#define WDT_A_CLOCKDIVIDER_2G                                         (WDT_A_CTL_IS_0)
N#define WDT_A_CLOCKDIVIDER_128M                                       (WDT_A_CTL_IS_1)
N#define WDT_A_CLOCKDIVIDER_8192K                                      (WDT_A_CTL_IS_2)
N#define WDT_A_CLOCKDIVIDER_512K                                       (WDT_A_CTL_IS_3)
N#define WDT_A_CLOCKDIVIDER_32K                                        (WDT_A_CTL_IS_4)
N#define WDT_A_CLOCKDIVIDER_8192                                       (WDT_A_CTL_IS_5)
N#define WDT_A_CLOCKDIVIDER_512                                        (WDT_A_CTL_IS_6)
N#define WDT_A_CLOCKDIVIDER_64                                         (WDT_A_CTL_IS_7)
N#define WDT_A_CLOCKITERATIONS_2G    WDT_A_CLOCKDIVIDER_2G
N#define WDT_A_CLOCKITERATIONS_128M  WDT_A_CLOCKDIVIDER_128M
N#define WDT_A_CLOCKITERATIONS_8192K WDT_A_CLOCKDIVIDER_8192K
N#define WDT_A_CLOCKITERATIONS_512K  WDT_A_CLOCKDIVIDER_512K
N#define WDT_A_CLOCKITERATIONS_32K   WDT_A_CLOCKDIVIDER_32K
N#define WDT_A_CLOCKITERATIONS_8192  WDT_A_CLOCKDIVIDER_8192
N#define WDT_A_CLOCKITERATIONS_512   WDT_A_CLOCKDIVIDER_512
N#define WDT_A_CLOCKITERATIONS_64    WDT_A_CLOCKDIVIDER_64
N
N//*****************************************************************************
N//
N// Prototypes for the APIs.
N//
N//*****************************************************************************
N
N//*****************************************************************************
N//
N//! Holds the Watchdog Timer.
N//!
N//! This function stops the watchdog timer from running. This way no interrupt
N//! or PUC is asserted.
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void WDT_A_holdTimer(void);
N
N//*****************************************************************************
N//
N//! Starts the Watchdog Timer.
N//!
N//! This function starts the watchdog timer functionality to start counting.
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void WDT_A_startTimer(void);
N
N//*****************************************************************************
N//
N//! Clears the timer counter of the Watchdog Timer.
N//!
N//! This function clears the watchdog timer count to 0x0000h. This function
N//! is used to "service the dog" when operating in watchdog mode.
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void WDT_A_clearTimer(void);
N
N//*****************************************************************************
N//
N//! Sets the clock source for the Watchdog Timer in watchdog mode.
N//!
N//! \param clockSelect is the clock source that the watchdog timer will use.
N//!        Valid values are
N//!        - \b WDT_A_CLOCKSOURCE_SMCLK [Default]
N//!        - \b WDT_A_CLOCKSOURCE_ACLK
N//!        - \b WDT_A_CLOCKSOURCE_VLOCLK
N//!        - \b WDT_A_CLOCKSOURCE_BCLK
N//! \param clockIterations is the number of clock iterations for a watchdog
N//!         timeout.
N//!        Valid values are
N//!        - \b WDT_A_CLOCKITERATIONS_2G [Default]
N//!        - \b WDT_A_CLOCKITERATIONS_128M
N//!        - \b WDT_A_CLOCKITERATIONS_8192K
N//!        - \b WDT_A_CLOCKITERATIONS_512K
N//!        - \b WDT_A_CLOCKITERATIONS_32K
N//!        - \b WDT_A_CLOCKITERATIONS_8192
N//!        - \b WDT_A_CLOCKITERATIONS_512
N//!        - \b WDT_A_CLOCKITERATIONS_64
N//!
N//! This function sets the watchdog timer in watchdog mode, which will cause a
N//! PUC when the timer overflows. When in the mode, a PUC can be avoided with a
N//! call to WDT_A_resetTimer() before the timer runs out.
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void WDT_A_initWatchdogTimer(uint_fast8_t clockSelect,
N        uint_fast8_t clockDivider);
N
N//*****************************************************************************
N//
N//! Sets the clock source for the Watchdog Timer in timer interval mode.
N//!
N//! \param clockSelect is the clock source that the watchdog timer will use.
N//!        Valid values are
N//!        - \b WDT_A_CLOCKSOURCE_SMCLK [Default]
N//!        - \b WDT_A_CLOCKSOURCE_ACLK
N//!        - \b WDT_A_CLOCKSOURCE_VLOCLK
N//!        - \b WDT_A_CLOCKSOURCE_BCLK
N//! \param clockIterations is the number of clock iterations for a watchdog
N//!         interval.
N//!        Valid values are
N//!        - \b WDT_A_CLOCKITERATIONS_2G [Default]
N//!        - \b WDT_A_CLOCKITERATIONS_128M
N//!        - \b WDT_A_CLOCKITERATIONS_8192K
N//!        - \b WDT_A_CLOCKITERATIONS_512K
N//!        - \b WDT_A_CLOCKITERATIONS_32K
N//!        - \b WDT_A_CLOCKITERATIONS_8192
N//!        - \b WDT_A_CLOCKITERATIONS_512
N//!        - \b WDT_A_CLOCKITERATIONS_64
N//!
N//! This function sets the watchdog timer as timer interval mode, which will
N//! assert an interrupt without causing a PUC.
N//!
N//! \return None
N//
N//*****************************************************************************
Nextern void WDT_A_initIntervalTimer(uint_fast8_t clockSelect,
N        uint_fast8_t clockDivider);
N
N//*****************************************************************************
N//
N//! Registers an interrupt handler for the watchdog interrupt.
N//!
N//! \param intHandler is a pointer to the function to be called when the
N//! watchdog interrupt occurs.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void WDT_A_registerInterrupt(void (*intHandler)(void));
N
N//*****************************************************************************
N//
N//! Unregisters the interrupt handler for the watchdog.
N//!
N//! This function unregisters the handler to be called when a watchdog
N//! interrupt occurs.  This function also masks off the interrupt in the
N//! interrupt controller so that the interrupt handler no longer is called.
N//!
N//! \sa Interrupt_registerInterrupt() for important information about
N//! registering interrupt handlers.
N//!
N//! \return None.
N//
N//*****************************************************************************
Nextern void WDT_A_unregisterInterrupt(void);
N
N//*****************************************************************************
N//
N//! Sets the type of RESET that happens when a watchdog password violation
N//! occurs.
N//!
N//! \param resetType The type of reset to set
N//!
N//! The \e resetType parameter must be only one of the following values:
N//!     - \b WDT_A_HARD_RESET
N//!     - \b WDT_A_SOFT_RESET
N//!
N//! \return None.
N//
N//
N//*****************************************************************************
Nextern void WDT_A_setPasswordViolationReset(uint_fast8_t resetType);
N
N//*****************************************************************************
N//
N//! Sets the type of RESET that happens when a watchdog timeout occurs.
N//!
N//! \param resetType The type of reset to set
N//!
N//! The \e resetType parameter must be only one of the following values:
N//!     - \b WDT_A_HARD_RESET
N//!     - \b WDT_A_SOFT_RESET
N//!
N//! \return None.
N//
N//
N//*****************************************************************************
Nextern void WDT_A_setTimeoutReset(uint_fast8_t resetType);
N
N/* Defines for future devices that might have multiple instances */
N#define WDT_A_holdTimerMultipleTimer(a)  WDT_A_holdTimer()
N#define WDT_A_startTimerMultipleTimer(a) WDT_A_startTimer()
N#define WDT_A_resetTimerMultipleTimer(a) WDT_A_clearTimer()
N#define WDT_A_initWatchdogTimerMultipleTimer(a,b,c) WDT_A_initWatchdogTimer(b,c)
N#define WDT_A_initIntervalTimerMultipleTimer(a,b,c) WDT_A_initIntervalTimer(b,c)
N#define WDT_A_registerInterruptMultipleTimer(a,b) WDT_A_registerInterrupt(b)
N#define WDT_A_unregisterInterruptMultipleTimer(a) WDT_A_unregisterInterrupt()
N
N/* Backwards compatibility layer */
N#define WDT_A_hold WDT_A_holdTimerMultipleTimer
N#define WDT_A_start WDT_A_startTimerMultipleTimer
N#define WDT_A_resetTimer WDT_A_resetTimerMultipleTimer
N#define WDT_A_watchdogTimerInit WDT_A_initWatchdogTimerMultipleTimer
N#define WDT_A_intervalTimerInit WDT_A_initIntervalTimerMultipleTimer
N
N//*****************************************************************************
N//
N// Mark the end of the C bindings section for C++ compilers.
N//
N//*****************************************************************************
N#ifdef __cplusplus
N}
N#endif
N
N//*****************************************************************************
N//
N// Close the Doxygen group.
N//! @}
N//
N//*****************************************************************************
N
N#endif // __WATCHDOG_H__
L 69 "C:/ti/msp432_driverlib_3_21_00_05/driverlib/MSP432P4xx/driverlib.h" 2
N
N#endif
L 12 "..\MiniSegway.h" 2
N#include <stdint.h>
N#include "MotorController.h"
L 1 "..\MotorController.h" 1
N/*
N * MotorController.h
N *
N *  Created on: Jun 17, 2020
N *      Author: Juan Francisco Valle
N */
N
N#ifndef MOTORCONTROLLER_H_
N#define MOTORCONTROLLER_H_
N
N#include "Motor.h"
L 1 "..\Motor.h" 1
N/*
N * Motor.h
N *
N *  Created on: Jun 17, 2020
N *      Author: Juan Francisco Valle
N */
N
N#ifndef MOTOR_H_
N#define MOTOR_H_
N
N#include <stdint.h>
N#include <driverlib.h>
N
Nclass Motor{
Nprivate:
N
N    volatile uint16_t * pwmRegister;
N
Npublic:
N    int16_t maxPWM;
N    int16_t currentPWM;
N    uint16_t forwardPort;
N    uint32_t forwardPin;
N    uint16_t backwardPort;
N    uint32_t backwardPin;
N
N    uint16_t enc_portA;
N    uint32_t enc_pinA;
N    uint16_t enc_portB;
N    uint32_t enc_pinB;
N
N    volatile long enc_count;
N    volatile double enc_velocity;
N
N    volatile long prev_tick;
N
N    //Constructor
N    Motor(uint8_t maxPWM, uint16_t forwardPort, uint32_t forwardPin, uint16_t backwardPort, uint32_t backwardPin, volatile uint16_t * pwmRegister,
N          uint16_t enc_portA, uint32_t enc_pinA,  uint16_t enc_portB, uint32_t enc_pinB);
N
N    // Getters and setters
N    void setPWM(int16_t pwm);
N    uint8_t getPWM();
N
N    void forward();
N    void backward();
N};
N
N
N#endif /* MOTOR_H_ */
L 12 "..\MotorController.h" 2
N
Nclass MotorController{
Nprivate:
N    Motor* rightMotor;
N    Motor* leftMotor;
N
Npublic:
N
N    MotorController(Motor* rightMotor, Motor* leftMotor);
N
N    void commandMotors(double* const req_PWMs);
N
N};
N
N
N
N
N
N#endif /* MOTORCONTROLLER_H_ */
L 14 "..\MiniSegway.h" 2
N#include "LPF.h"
L 1 "..\LPF.h" 1
N/*
N * LPF.h
N *
N *  Created on: Jun 17, 2020
N *      Author: Juan Francisco Valle
N */
N
N#ifndef LPF_H_
N#define LPF_H_
N#include "MiniSegway.h"
L 1 "..\MiniSegway.h" 1
N/*
N * MiniSegway.h
N *
N *  Created on: Jun 17, 2020
N *      Author: Juan Francisco Vallejo
N */
N
N#ifndef MINISEGWAY_H_
S#define MINISEGWAY_H_
S
S#include "driverlib.h"
S#include <stdint.h>
S#include "MotorController.h"
S#include "LPF.h"
S#include "msp.h"
S#include <stdio.h>
S#include "UART_Wrapper.h"
S#include "initConfigs.h"
S#include "IMU.h"
S#include "SPI.h"
S#include "PID.h"
S#include "OuterPID.h"
S#include "RFInterface.h"
S
S// Global definitions
S#define DCO_Freq 16E+6
S#define MAX_PWM 225
Sconst double dt = 0.01;
S
Sconst double Kp_tilt = 15;//18
Sconst double Kd_tilt = 0.03;//0.05
Sconst double Ki_tilt = 0.1;//0.1;
Sconst double windup_tilt = 225;
Sconst double alpha_PWM = 1;
S
Sconst double Kp_turning = 20;//17;
Sconst double Kd_turning = 0.03;
Sconst double Ki_turning = 0;
Sconst double windup_turning = 225;
S
Sconst double Kp_velocity = 0.006;//0.006;
Sconst double Kd_velocity = 0;//0;
Sconst double Ki_velocity = 0.003;//0.001;
Sconst double windup_velocity = 225;
Sconst double alpha_velocity = 0.4;
S
Sconst double odom_velocity_alpha = 0.2;
Sconst double wheelRadius = 50.25;
Sconst double wheelBase = 167.5;
Sconst double ticksPerRev = 240;
S
S
S// Motor pins
S#define CW_1_PORT GPIO_PORT_P3
S#define CW_1_PIN GPIO_PIN7
S#define CCW_1_PORT GPIO_PORT_P3
S#define CCW_1_PIN GPIO_PIN6
S
S#define CW_2_PORT GPIO_PORT_P3
S#define CW_2_PIN GPIO_PIN5
S#define CCW_2_PORT GPIO_PORT_P5
S#define CCW_2_PIN GPIO_PIN2
S
S// Encoder Pins
S// Right Wheel
S#define RIGHT_ENC_PORT GPIO_PORT_P4
S#define RIGHT_ENC_PIN_A GPIO_PIN0
S#define RIGHT_ENC_PIN_B GPIO_PIN2
S// Left Wheel
S#define LEFT_ENC_PORT GPIO_PORT_P5
S#define LEFT_ENC_PIN_A GPIO_PIN4
S#define LEFT_ENC_PIN_B GPIO_PIN7 // On Port 4, 5.5 is fried
S
Sclass Motor;
Sclass Odometry;
Sclass UART;
Sclass IMU;
Sclass PID;
Sclass OuterPID;
Sclass RFInterface;
S
S// Global variables
Sextern Motor rightMotor;
Sextern Motor leftMotor;
Sextern UART UARTHandler;
Sextern Odometry odom;
Sextern IMU imu;
Sextern PID tiltController;
Sextern PID turningController;
Sextern OuterPID velocityController;
Sextern RFInterface commandInterface;
S
Sextern long ms; // Counts number of ms since program started
Sextern long last_ms;
S
N#endif /* MINISEGWAY_H_ */
L 11 "..\LPF.h" 2
N
Nvoid LPF(double rawData, double* filteredData, double alpha);
N
N
N#endif /* LPF_H_ */
L 15 "..\MiniSegway.h" 2
N#include "msp.h"
N#include <stdio.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/stdio.h" 1
N/* -*- C++ -*- */
N/*===--------------------------- complex.h --------------------------------===*/
N/*                                                                            */
N/*                     The LLVM Compiler Infrastructure                       */
N/*                                                                            */
N/* This file is dual licensed under the MIT and the University of Illinois Open
N** Source Licenses. See LICENSE.TXT for details.
N*/
N/*===----------------------------------------------------------------------===*/
N
N#if defined(__need_FILE) || defined(__need___FILE)
X#if 0L || 0L
S
S#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
S#pragma GCC system_header
S#endif
S
S#include_next <stdio.h>
S
N#elif !defined(_LIBCPP_STDIO_H)
X#elif !0L
N#define _LIBCPP_STDIO_H
N
N/*
N    stdio.h synopsis
N
NMacros:
N
N    BUFSIZ
N    EOF
N    FILENAME_MAX
N    FOPEN_MAX
N    L_tmpnam
N    NULL
N    SEEK_CUR
N    SEEK_END
N    SEEK_SET
N    TMP_MAX
N    _IOFBF
N    _IOLBF
N    _IONBF
N    stderr
N    stdin
N    stdout
N
NTypes:
N
NFILE
Nfpos_t
Nsize_t
N
Nint remove(const char* filename);
Nint rename(const char* old, const char* new);
NFILE* tmpfile(void);
Nchar* tmpnam(char* s);
Nint fclose(FILE* stream);
Nint fflush(FILE* stream);
NFILE* fopen(const char* restrict filename, const char* restrict mode);
NFILE* freopen(const char* restrict filename, const char * restrict mode,
N              FILE * restrict stream);
Nvoid setbuf(FILE* restrict stream, char* restrict buf);
Nint setvbuf(FILE* restrict stream, char* restrict buf, int mode, size_t size);
Nint fprintf(FILE* restrict stream, const char* restrict format, ...);
Nint fscanf(FILE* restrict stream, const char * restrict format, ...);
Nint printf(const char* restrict format, ...);
Nint scanf(const char* restrict format, ...);
Nint snprintf(char* restrict s, size_t n, const char* restrict format, ...);    // C99
Nint sprintf(char* restrict s, const char* restrict format, ...);
Nint sscanf(const char* restrict s, const char* restrict format, ...);
Nint vfprintf(FILE* restrict stream, const char* restrict format, va_list arg);
Nint vfscanf(FILE* restrict stream, const char* restrict format, va_list arg);  // C99
Nint vprintf(const char* restrict format, va_list arg);
Nint vscanf(const char* restrict format, va_list arg);                          // C99
Nint vsnprintf(char* restrict s, size_t n, const char* restrict format,         // C99
N              va_list arg);
Nint vsprintf(char* restrict s, const char* restrict format, va_list arg);
Nint vsscanf(const char* restrict s, const char* restrict format, va_list arg); // C99
Nint fgetc(FILE* stream);
Nchar* fgets(char* restrict s, int n, FILE* restrict stream);
Nint fputc(int c, FILE* stream);
Nint fputs(const char* restrict s, FILE* restrict stream);
Nint getc(FILE* stream);
Nint getchar(void);
Nchar* gets(char* s);  // removed in C++14
Nint putc(int c, FILE* stream);
Nint putchar(int c);
Nint puts(const char* s);
Nint ungetc(int c, FILE* stream);
Nsize_t fread(void* restrict ptr, size_t size, size_t nmemb,
N             FILE* restrict stream);
Nsize_t fwrite(const void* restrict ptr, size_t size, size_t nmemb,
N              FILE* restrict stream);
Nint fgetpos(FILE* restrict stream, fpos_t* restrict pos);
Nint fseek(FILE* stream, long offset, int whence);
Nint fsetpos(FILE*stream, const fpos_t* pos);
Nlong ftell(FILE* stream);
Nvoid rewind(FILE* stream);
Nvoid clearerr(FILE* stream);
Nint feof(FILE* stream);
Nint ferror(FILE* stream);
Nvoid perror(const char* s);
N*/
N
N#include <__config>
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N#include_next <stdio.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/stdio.h" 1
N/*****************************************************************************/
N/* STDIO.H                                                                   */
N/*                                                                           */
N/* Copyright (c) 1993 Texas Instruments Incorporated                         */
N/* http://www.ti.com/                                                        */
N/*                                                                           */
N/*  Redistribution and  use in source  and binary forms, with  or without    */
N/*  modification,  are permitted provided  that the  following conditions    */
N/*  are met:                                                                 */
N/*                                                                           */
N/*     Redistributions  of source  code must  retain the  above copyright    */
N/*     notice, this list of conditions and the following disclaimer.         */
N/*                                                                           */
N/*     Redistributions in binary form  must reproduce the above copyright    */
N/*     notice, this  list of conditions  and the following  disclaimer in    */
N/*     the  documentation  and/or   other  materials  provided  with  the    */
N/*     distribution.                                                         */
N/*                                                                           */
N/*     Neither the  name of Texas Instruments Incorporated  nor the names    */
N/*     of its  contributors may  be used to  endorse or  promote products    */
N/*     derived  from   this  software  without   specific  prior  written    */
N/*     permission.                                                           */
N/*                                                                           */
N/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS    */
N/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT    */
N/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    */
N/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT    */
N/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    */
N/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT    */
N/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    */
N/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    */
N/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT    */
N/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    */
N/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     */
N/*                                                                           */
N/*****************************************************************************/
N#ifndef _STDIO_H_
N#define _STDIO_H_
N
N#if defined(__TMS320C2000__)
X#if 0L
S#if defined(__TMS320C28XX_CLA__)
S#error "Header file <stdio.h> not supported by CLA compiler"
S#endif
N#endif
N
N#include <_ti_config.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/_ti_config.h" 1
N/*****************************************************************************/
N/* _ti_config.h                                                              */
N/*                                                                           */
N/* Copyright (c) 2017 Texas Instruments Incorporated                         */
N/* http://www.ti.com/                                                        */
N/*                                                                           */
N/*  Redistribution and  use in source  and binary forms, with  or without    */
N/*  modification,  are permitted provided  that the  following conditions    */
N/*  are met:                                                                 */
N/*                                                                           */
N/*     Redistributions  of source  code must  retain the  above copyright    */
N/*     notice, this list of conditions and the following disclaimer.         */
N/*                                                                           */
N/*     Redistributions in binary form  must reproduce the above copyright    */
N/*     notice, this  list of conditions  and the following  disclaimer in    */
N/*     the  documentation  and/or   other  materials  provided  with  the    */
N/*     distribution.                                                         */
N/*                                                                           */
N/*     Neither the  name of Texas Instruments Incorporated  nor the names    */
N/*     of its  contributors may  be used to  endorse or  promote products    */
N/*     derived  from   this  software  without   specific  prior  written    */
N/*     permission.                                                           */
N/*                                                                           */
N/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS    */
N/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT    */
N/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    */
N/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT    */
N/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    */
N/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT    */
N/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    */
N/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    */
N/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT    */
N/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    */
N/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     */
N/*                                                                           */
N/*****************************************************************************/
N
N#ifndef __TI_CONFIG_H
N#define __TI_CONFIG_H
N
N#pragma diag_push
N#pragma CHECK_MISRA("-19.4")
N#pragma CHECK_MISRA("-19.1")
N
N/* Common definitions */
N
N#if defined(__cplusplus)
X#if 1L
N/* C++ */
N# if (__cplusplus >= 201103L)
X# if (201402L >= 201103L)
N /* C++11 */
N#  define _TI_NORETURN [[noreturn]]
N#  define _TI_NOEXCEPT noexcept
N# else
S /* C++98/03 */
S#  define _TI_NORETURN __attribute__((noreturn))
S#  define _TI_NOEXCEPT throw()
N# endif
N#else
S/* C */
S# if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L)
S /* C11 */
S#  define _TI_NORETURN _Noreturn
S# else
S /* C89/C99 */
S#  define _TI_NORETURN __attribute__((noreturn))
S# endif
S# define _TI_NOEXCEPT
N#endif
N
N#if defined(__cplusplus) && (__cplusplus >= 201103L)
X#if 1L && (201402L >= 201103L)
N# define _TI_CPP11LIB 1
N#endif
N
N#if defined(__cplusplus) && (__cplusplus >= 201402L)
X#if 1L && (201402L >= 201402L)
N# define _TI_CPP14LIB 1
N#endif
N
N#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) || \
N    defined(_TI_CPP11LIB)
X#if 0L && (__STDC_VERSION__ >= 199901L) ||     1L
N# define _TI_C99LIB 1
N#endif
N
N#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L) || \
N    defined(_TI_CPP14LIB)
X#if 0L && (__STDC_VERSION__ >= 201112L) ||     1L
N# define _TI_C11LIB 1
N#endif
N
N/* _TI_NOEXCEPT_CPP14 is defined to noexcept only when compiling for C++14. It
N   is intended to be used for functions like abort and atexit that are supposed
N   to be declared noexcept only in C++14 mode. */
N#ifdef _TI_CPP14LIB
N# define _TI_NOEXCEPT_CPP14 noexcept
N#else
S# define _TI_NOEXCEPT_CPP14
N#endif
N
N/* Target-specific definitions */
N#include <linkage.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/linkage.h" 1
N/*****************************************************************************/
N/* linkage.h                                                                 */
N/*                                                                           */
N/* Copyright (c) 1998 Texas Instruments Incorporated                         */
N/* http://www.ti.com/                                                        */
N/*                                                                           */
N/*  Redistribution and  use in source  and binary forms, with  or without    */
N/*  modification,  are permitted provided  that the  following conditions    */
N/*  are met:                                                                 */
N/*                                                                           */
N/*     Redistributions  of source  code must  retain the  above copyright    */
N/*     notice, this list of conditions and the following disclaimer.         */
N/*                                                                           */
N/*     Redistributions in binary form  must reproduce the above copyright    */
N/*     notice, this  list of conditions  and the following  disclaimer in    */
N/*     the  documentation  and/or   other  materials  provided  with  the    */
N/*     distribution.                                                         */
N/*                                                                           */
N/*     Neither the  name of Texas Instruments Incorporated  nor the names    */
N/*     of its  contributors may  be used to  endorse or  promote products    */
N/*     derived  from   this  software  without   specific  prior  written    */
N/*     permission.                                                           */
N/*                                                                           */
N/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS    */
N/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT    */
N/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    */
N/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT    */
N/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    */
N/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT    */
N/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    */
N/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    */
N/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT    */
N/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    */
N/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     */
N/*                                                                           */
N/*****************************************************************************/
N
N#ifndef _LINKAGE
N#define _LINKAGE
N
N#pragma diag_push
N#pragma CHECK_MISRA("-19.4") /* macros required for implementation */
N
N/* No modifiers are needed to access code or data */
N
N#define _CODE_ACCESS
N#define _DATA_ACCESS
N#define _DATA_ACCESS_NEAR
N
N/*--------------------------------------------------------------------------*/
N/* Define _IDECL ==> how inline functions are declared                      */
N/*--------------------------------------------------------------------------*/
N#ifdef _INLINE
S#define _IDECL static __inline
S#define _IDEFN static __inline
N#else
N#define _IDECL extern _CODE_ACCESS
N#define _IDEFN _CODE_ACCESS
N#endif
N
N#pragma diag_pop
N
N#endif /* ifndef _LINKAGE */
L 99 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/_ti_config.h" 2
N
N#pragma diag_pop
N
N#endif /* ifndef __TI_CONFIG_H */
L 47 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/stdio.h" 2
N#include <stdarg.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/stdarg.h" 1
N/*****************************************************************************/
N/* stdarg.h                                                                  */
N/*                                                                           */
N/* Copyright (c) 1996 Texas Instruments Incorporated                         */
N/* http://www.ti.com/                                                        */
N/*                                                                           */
N/*  Redistribution and  use in source  and binary forms, with  or without    */
N/*  modification,  are permitted provided  that the  following conditions    */
N/*  are met:                                                                 */
N/*                                                                           */
N/*     Redistributions  of source  code must  retain the  above copyright    */
N/*     notice, this list of conditions and the following disclaimer.         */
N/*                                                                           */
N/*     Redistributions in binary form  must reproduce the above copyright    */
N/*     notice, this  list of conditions  and the following  disclaimer in    */
N/*     the  documentation  and/or   other  materials  provided  with  the    */
N/*     distribution.                                                         */
N/*                                                                           */
N/*     Neither the  name of Texas Instruments Incorporated  nor the names    */
N/*     of its  contributors may  be used to  endorse or  promote products    */
N/*     derived  from   this  software  without   specific  prior  written    */
N/*     permission.                                                           */
N/*                                                                           */
N/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS    */
N/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT    */
N/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    */
N/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT    */
N/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    */
N/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT    */
N/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    */
N/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    */
N/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT    */
N/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    */
N/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     */
N/*                                                                           */
N/*****************************************************************************/
N
N#ifndef _STDARG
N#define _STDARG
N
N#pragma diag_push
N#pragma CHECK_MISRA("-19.7") /* need function-like macros */
N#pragma CHECK_MISRA("-19.10") /* need types as macro arguments */
N#pragma CHECK_MISRA("-20.1") /* standard headers must define standard names */
N#pragma CHECK_MISRA("-20.2") /* standard headers must define standard names */
N
N#include <sys/_types.h>  /* For __va_list */
N
N#ifndef _VA_LIST_DECLARED
N#define _VA_LIST_DECLARED
Ntypedef __va_list va_list;
N#endif
N
N#define _VA_RNDUP(sz) 	(((sz) + 3) & ~3)
N#define _VA_MASK(tp)     ((__ALIGNOF__(tp) == 8) ? 7 : 3)
N#define _VA_ALN(ap,tp)  (((int)(ap) + _VA_MASK(tp)) & ~(_VA_MASK(tp)))
N
N#define va_start(ap, parmN)						      \
N   ((ap).__ap = ((void *)((((int)__va_parmadr(parmN))&~3) +                   \
N		                              _VA_RNDUP(sizeof(parmN)))))
X#define va_start(ap, parmN)						         ((ap).__ap = ((void *)((((int)__va_parmadr(parmN))&~3) +                   		                              _VA_RNDUP(sizeof(parmN)))))
N
N#ifdef __big_endian__
S#define va_arg(_ap, _type)					 	      \
S    (((_ap).__ap = (void*)(_VA_ALN((_ap).__ap, _type) +                       \
S			                         _VA_RNDUP(sizeof(_type)))),  \
S     (*(_type *)((int)(_ap).__ap -                                            \
S		   (__va_argcsu(_type) ? _VA_RNDUP(sizeof(_type))	      \
S		                       : (sizeof(_type))))))
X#define va_arg(_ap, _type)					 	          (((_ap).__ap = (void*)(_VA_ALN((_ap).__ap, _type) +                       			                         _VA_RNDUP(sizeof(_type)))),       (*(_type *)((int)(_ap).__ap -                                            		   (__va_argcsu(_type) ? _VA_RNDUP(sizeof(_type))	      		                       : (sizeof(_type))))))
N#else
N#define va_arg(_ap, _type) 						      \
N   (((_ap).__ap = (void *)(_VA_ALN((_ap).__ap,_type) +                        \
N			   _VA_RNDUP(sizeof(_type)))),                        \
N	     (*(_type *) ((int)(_ap).__ap - _VA_RNDUP(sizeof(_type)))))
X#define va_arg(_ap, _type) 						         (((_ap).__ap = (void *)(_VA_ALN((_ap).__ap,_type) +                        			   _VA_RNDUP(sizeof(_type)))),                        	     (*(_type *) ((int)(_ap).__ap - _VA_RNDUP(sizeof(_type)))))
N#endif
N
N#define va_end(ap) ((void)0)
N#define va_copy(dst, src) ((dst)=(src))
N
N
N#pragma diag_pop
N
N#endif /* _STDARG */
N
L 48 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/stdio.h" 2
N
N#pragma diag_push
N#pragma CHECK_MISRA("-20.2") /* reuse of standard macros/objects/funcs */
N#pragma CHECK_MISRA("-20.1") /* redefining reserved identifiers */
N#pragma CHECK_MISRA("-19.7") /* use function instead of function-like macro */
N#pragma CHECK_MISRA("-19.4") /* macros should have only simple expansions */
N#pragma CHECK_MISRA("-19.1") /* include should follow directive or comment */
N#pragma CHECK_MISRA("-16.3") /* parameters without names */
N#pragma CHECK_MISRA("-6.3")  /* use size/sign-specific typedefs */
N
N/*---------------------------------------------------------------------------*/
N/* Attributes are only available in relaxed ANSI mode.                       */
N/*---------------------------------------------------------------------------*/
N#ifndef __ATTRIBUTE
N#define __ATTRIBUTE(attr) __attribute__(attr)
N#endif
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
N/****************************************************************************/
N/* TYPES THAT ANSI REQUIRES TO BE DEFINED                                   */
N/****************************************************************************/
N#ifndef _SIZE_T_DECLARED
N#define _SIZE_T_DECLARED
N#ifdef __clang__
Stypedef __SIZE_TYPE__ size_t;
N#else
Ntypedef __SIZE_T_TYPE__ size_t;
Xtypedef unsigned size_t;
N#endif
N#endif
N
Nstruct __sFILE {
N      int fd;                    /* File descriptor */
N      unsigned char* buf;        /* Pointer to start of buffer */
N      unsigned char* pos;        /* Position in buffer */
N      unsigned char* bufend;     /* Pointer to end of buffer */
N      unsigned char* buff_stop;  /* Pointer to last read char in buffer */
N      unsigned int   flags;      /* File status flags (see below) */
N};
N
N#ifndef _STDFILE_DECLARED
N#define _STDFILE_DECLARED
Ntypedef struct __sFILE FILE;
N#endif
N
N#ifndef _FPOS_T
N#define _FPOS_T
N#if defined(_AEABI_PORTABILITY_LEVEL) && _AEABI_PORTABILITY_LEVEL != 0
X#if 0L && _AEABI_PORTABILITY_LEVEL != 0
Stypedef struct __fpos_t_struct {
S    unsigned long long __pos;
S    struct {
S        unsigned int __state1, __state2;
S    } __mbstate;
S} fpos_t;
S#elif !defined(__C6X_MIGRATION__) && (defined(_TMS320C6X) || defined(__TMS320C6X__))
X#elif !0L && (0L || 0L)
Stypedef int fpos_t;
N#else
Ntypedef long fpos_t;
N#endif /* c6x */
N#endif /* _FPOS_T */
N
N/****************************************************************************/
N/* DEVICE AND STREAM RELATED MACROS                                         */
N/****************************************************************************/
N/****************************************************************************/
N/* MACROS THAT DEFINE AND USE FILE STATUS FLAGS                             */
N/****************************************************************************/
N#if defined(_AEABI_PORTABILITY_LEVEL) && _AEABI_PORTABILITY_LEVEL != 0
X#if 0L && _AEABI_PORTABILITY_LEVEL != 0
Sextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
S#define stdin  (__aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__aeabi_L_tmpnam)
S
N#else /* _AEABI_PORTABILITY_LEVEL */
N
N#define _IOFBF       0x0001
N#define _IOLBF       0x0002
N#define _IONBF       0x0004
N#define _BUFFALOC    0x0008
N#define _MODER       0x0010
N#define _MODEW       0x0020
N#define _MODERW      0x0040
N#define _MODEA       0x0080
N#define _MODEBIN     0x0100
N#define _STATEOF     0x0200
N#define _STATERR     0x0400
N#define _UNGETC      0x0800
N#define _TMPFILE     0x1000
N
N#define _SET(_fp, _b)      (((_fp)->flags) |= (_b))
N#define _UNSET(_fp, _b)    (((_fp)->flags) &= ~(_b))
N#define _STCHK(_fp, _b)    (((_fp)->flags) & (_b))
N#define _BUFFMODE(_fp)     (((_fp)->flags) & (_IOFBF | _IOLBF | _IONBF))
N#define _ACCMODE(_fp)      (((_fp)->flags) & (_MODER | _MODEW))
N
N/****************************************************************************/
N/* MACROS THAT ANSI REQUIRES TO BE DEFINED                                  */
N/****************************************************************************/
N#define BUFSIZ          256
N
N#define FOPEN_MAX       _NFILE
N#define FILENAME_MAX    256
N#define TMP_MAX         65535
N
N#define stdin     (&_ftable[0])
N#define stdout    (&_ftable[1])
N#define stderr    (&_ftable[2])
N
N#define L_tmpnam  _LTMPNAM
N
N#endif /* _AEABI_PORTABILITY_LEVEL */
N
N#define SEEK_SET  (0x0000)
N#define SEEK_CUR  (0x0001)
N#define SEEK_END  (0x0002)
N
N#ifndef NULL
N#define NULL 0
N#endif
N
N#ifndef EOF
N#define EOF    (-1)
N#endif
N
N/******** END OF ANSI MACROS ************************************************/
N
N#define P_tmpdir        ""                   /* Path for temp files         */
N
N/****************************************************************************/
N/* DEVICE AND STREAM RELATED DATA STRUCTURES AND MACROS                     */
N/****************************************************************************/
N#if defined(__TMS320C6X__)
X#if 0L
S#define _NFILE           20                   /* Max number of files open   */
N#else
N#define _NFILE           10                   /* Max number of files open   */
N#endif
N#define _LTMPNAM         16                   /* Length of temp name        */
N
Nextern _DATA_ACCESS FILE _ftable[_NFILE];
Xextern  FILE _ftable[10];
Nextern _DATA_ACCESS char __TI_tmpnams[_NFILE][_LTMPNAM];
Xextern  char __TI_tmpnams[10][16];
N
N/****************************************************************************/
N/*   FUNCTION DEFINITIONS  - ANSI                                           */
N/****************************************************************************/
N/****************************************************************************/
N/* OPERATIONS ON FILES                                                      */
N/****************************************************************************/
Nextern _CODE_ACCESS int     remove(const char *_file);
Xextern  int     remove(const char *_file);
Nextern _CODE_ACCESS int     rename(const char *_old, const char *_new);
Xextern  int     rename(const char *_old, const char *_new);
Nextern _CODE_ACCESS FILE   *tmpfile(void);
Xextern  FILE   *tmpfile(void);
Nextern _CODE_ACCESS char   *tmpnam(char *_s);
Xextern  char   *tmpnam(char *_s);
N
N/****************************************************************************/
N/* FILE ACCESS FUNCTIONS                                                    */
N/****************************************************************************/
Nextern _CODE_ACCESS int     fclose(FILE * __restrict _fp);
Xextern  int     fclose(FILE * __restrict _fp);
Nextern _CODE_ACCESS FILE   *fopen(const char * __restrict _fname,
Xextern  FILE   *fopen(const char * __restrict _fname,
N                                  const char * __restrict _mode);
Nextern _CODE_ACCESS FILE   *freopen(const char * __restrict _fname,
Xextern  FILE   *freopen(const char * __restrict _fname,
N                                    const char * __restrict _mode,
N			            FILE * __restrict _fp);
Nextern _CODE_ACCESS void    setbuf(FILE * __restrict _fp,
Xextern  void    setbuf(FILE * __restrict _fp,
N                                   char * __restrict _buf);
Nextern _CODE_ACCESS int     setvbuf(FILE * __restrict _fp,
Xextern  int     setvbuf(FILE * __restrict _fp,
N                                    char * __restrict _buf,
N			            int _type, size_t _size);
Nextern _CODE_ACCESS int     fflush(FILE *_fp);
Xextern  int     fflush(FILE *_fp);
N
N/****************************************************************************/
N/* FORMATTED INPUT/OUTPUT FUNCTIONS                                         */
N/****************************************************************************/
Nextern _CODE_ACCESS int fprintf(FILE * __restrict _fp,
Xextern  int fprintf(FILE * __restrict _fp,
N                                const char * __restrict _format, ...)
N               __ATTRIBUTE ((__format__ (__printf__, 2, 3)));
X               __attribute__((__format__ (__printf__, 2, 3)));
Nextern _CODE_ACCESS int fscanf(FILE * __restrict _fp,
Xextern  int fscanf(FILE * __restrict _fp,
N                               const char * __restrict _fmt, ...)
N               __ATTRIBUTE ((__format__ (__scanf__, 2, 3)));
X               __attribute__((__format__ (__scanf__, 2, 3)));
Nextern _CODE_ACCESS int printf(const char * __restrict _format, ...)
Xextern  int printf(const char * __restrict _format, ...)
N               __ATTRIBUTE ((__format__ (__printf__, 1, 2)));
X               __attribute__((__format__ (__printf__, 1, 2)));
Nextern _CODE_ACCESS int scanf(const char * __restrict _fmt, ...)
Xextern  int scanf(const char * __restrict _fmt, ...)
N               __ATTRIBUTE ((__format__ (__scanf__, 1, 2)));
X               __attribute__((__format__ (__scanf__, 1, 2)));
Nextern _CODE_ACCESS int sprintf(char * __restrict _string,
Xextern  int sprintf(char * __restrict _string,
N                                const char * __restrict _format, ...)
N               __ATTRIBUTE ((__format__ (__printf__, 2, 3)));
X               __attribute__((__format__ (__printf__, 2, 3)));
Nextern _CODE_ACCESS int snprintf(char * __restrict _string, size_t _n,
Xextern  int snprintf(char * __restrict _string, size_t _n,
N				 const char * __restrict _format, ...)
N               __ATTRIBUTE ((__format__ (__printf__, 3, 4)));
X               __attribute__((__format__ (__printf__, 3, 4)));
Nextern _CODE_ACCESS int sscanf(const char * __restrict _str,
Xextern  int sscanf(const char * __restrict _str,
N                               const char * __restrict _fmt, ...)
N               __ATTRIBUTE ((__format__ (__scanf__, 2, 3)));
X               __attribute__((__format__ (__scanf__, 2, 3)));
Nextern _CODE_ACCESS int vfprintf(FILE * __restrict _fp,
Xextern  int vfprintf(FILE * __restrict _fp,
N                                 const char * __restrict _format, va_list _ap)
N               __ATTRIBUTE ((__format__ (__printf__, 2, 0)));
X               __attribute__((__format__ (__printf__, 2, 0)));
Nextern _CODE_ACCESS int vfscanf(FILE * __restrict _fp,
Xextern  int vfscanf(FILE * __restrict _fp,
N                                const char * __restrict _fmt, va_list _ap)
N               __ATTRIBUTE ((__format__ (__scanf__, 2, 0)));
X               __attribute__((__format__ (__scanf__, 2, 0)));
Nextern _CODE_ACCESS int vprintf(const char * __restrict _format, va_list _ap)
Xextern  int vprintf(const char * __restrict _format, va_list _ap)
N               __ATTRIBUTE ((__format__ (__printf__, 1, 0)));
X               __attribute__((__format__ (__printf__, 1, 0)));
Nextern _CODE_ACCESS int vscanf(const char * __restrict _format, va_list _ap)
Xextern  int vscanf(const char * __restrict _format, va_list _ap)
N               __ATTRIBUTE ((__format__ (__scanf__, 1, 0)));
X               __attribute__((__format__ (__scanf__, 1, 0)));
Nextern _CODE_ACCESS int vsprintf(char * __restrict _string,
Xextern  int vsprintf(char * __restrict _string,
N                                 const char * __restrict _format, va_list _ap)
N               __ATTRIBUTE ((__format__ (__printf__, 2, 0)));
X               __attribute__((__format__ (__printf__, 2, 0)));
Nextern _CODE_ACCESS int vsnprintf(char * __restrict _string, size_t _n,
Xextern  int vsnprintf(char * __restrict _string, size_t _n,
N				  const char * __restrict _format, va_list _ap)
N               __ATTRIBUTE ((__format__ (__printf__, 3, 0)));
X               __attribute__((__format__ (__printf__, 3, 0)));
Nextern _CODE_ACCESS int vsscanf(const char * __restrict _str,
Xextern  int vsscanf(const char * __restrict _str,
N                                const char * __restrict _fmt, va_list _ap)
N               __ATTRIBUTE ((__format__ (__scanf__, 2, 0)));
X               __attribute__((__format__ (__scanf__, 2, 0)));
Nextern _CODE_ACCESS int	asprintf(char **, const char *, ...)
Xextern  int	asprintf(char **, const char *, ...)
N               __ATTRIBUTE ((__format__ (__printf__, 2, 3)));
X               __attribute__((__format__ (__printf__, 2, 3)));
Nextern _CODE_ACCESS int	vasprintf(char **, const char *, va_list)
Xextern  int	vasprintf(char **, const char *, va_list)
N               __ATTRIBUTE ((__format__ (__printf__, 2, 0)));
X               __attribute__((__format__ (__printf__, 2, 0)));
N
N/****************************************************************************/
N/* CHARACTER INPUT/OUTPUT FUNCTIONS                                         */
N/****************************************************************************/
Nextern _CODE_ACCESS int     fgetc(FILE *_fp);
Xextern  int     fgetc(FILE *_fp);
Nextern _CODE_ACCESS char   *fgets(char * __restrict _ptr, int _size,
Xextern  char   *fgets(char * __restrict _ptr, int _size,
N				  FILE * __restrict _fp);
Nextern _CODE_ACCESS int     fputc(int _c, FILE *_fp);
Xextern  int     fputc(int _c, FILE *_fp);
Nextern _CODE_ACCESS int     fputs(const char * __restrict _ptr,
Xextern  int     fputs(const char * __restrict _ptr,
N                                  FILE * __restrict _fp);
Nextern _CODE_ACCESS int     getc(FILE *_p);
Xextern  int     getc(FILE *_p);
Nextern _CODE_ACCESS int     getchar(void);
Xextern  int     getchar(void);
Nextern _CODE_ACCESS char   *gets(char *_ptr);
Xextern  char   *gets(char *_ptr);
Nextern _CODE_ACCESS int     putc(int _x, FILE *_fp);
Xextern  int     putc(int _x, FILE *_fp);
Nextern _CODE_ACCESS int     putchar(int _x);
Xextern  int     putchar(int _x);
Nextern _CODE_ACCESS int     puts(const char *_ptr);
Xextern  int     puts(const char *_ptr);
Nextern _CODE_ACCESS int     ungetc(int _c, FILE *_fp);
Xextern  int     ungetc(int _c, FILE *_fp);
N
N/****************************************************************************/
N/* DIRECT INPUT/OUTPUT FUNCTIONS                                            */
N/****************************************************************************/
Nextern _CODE_ACCESS size_t  fread(void * __restrict _ptr,
Xextern  size_t  fread(void * __restrict _ptr,
N                                  size_t _size, size_t _count,
N				  FILE * __restrict _fp);
Nextern _CODE_ACCESS size_t  fwrite(const void * __restrict _ptr,
Xextern  size_t  fwrite(const void * __restrict _ptr,
N                                   size_t _size, size_t _count,
N                                   FILE * __restrict _fp);
N
N/****************************************************************************/
N/* FILE POSITIONING FUNCTIONS                                               */
N/****************************************************************************/
Nextern _CODE_ACCESS int     fgetpos(FILE * __restrict _fp,
Xextern  int     fgetpos(FILE * __restrict _fp,
N                                    fpos_t * __restrict _pos);
Nextern _CODE_ACCESS int     fseek(FILE *_fp, long _offset,
Xextern  int     fseek(FILE *_fp, long _offset,
N				  int _ptrname);
Nextern _CODE_ACCESS int     fsetpos(FILE * __restrict _fp,
Xextern  int     fsetpos(FILE * __restrict _fp,
N                                    const fpos_t * __restrict _pos);
Nextern _CODE_ACCESS long    ftell(FILE *_fp);
Xextern  long    ftell(FILE *_fp);
Nextern _CODE_ACCESS void    rewind(FILE *_fp);
Xextern  void    rewind(FILE *_fp);
N
N/****************************************************************************/
N/* ERROR-HANDLING FUNCTIONS                                                 */
N/****************************************************************************/
Nextern _CODE_ACCESS void    clearerr(FILE *_fp);
Xextern  void    clearerr(FILE *_fp);
Nextern _CODE_ACCESS int     feof(FILE *_fp);
Xextern  int     feof(FILE *_fp);
Nextern _CODE_ACCESS int     ferror(FILE *_fp);
Xextern  int     ferror(FILE *_fp);
Nextern _CODE_ACCESS void    perror(const char *_s);
Xextern  void    perror(const char *_s);
N
N#define _getchar()      getc(stdin)
N#define _putchar(_x)    putc((_x), stdout)
N#define _clearerr(_fp)   ((void) ((_fp)->flags &= ~(_STATERR | _STATEOF)))
N
N#define _ferror(_x)     ((_x)->flags & _STATERR)
N
N#define _remove(_fl)    (unlink((_fl)))
N
N#ifdef __cplusplus
N} /* extern "C" */
N#endif  /* __cplusplus */
N
N#pragma diag_pop
N
N#if defined(_AEABI_PORTABILITY_LEVEL) && _AEABI_PORTABILITY_LEVEL != 0 && \
N   !defined(_AEABI_PORTABLE)
X#if 0L && _AEABI_PORTABILITY_LEVEL != 0 &&    !0L
S#define _AEABI_PORTABLE
N#endif
N
N/*----------------------------------------------------------------------------*/
N/* If sys/cdefs.h is available, go ahead and include it. xlocale.h assumes    */
N/* this file will have already included sys/cdefs.h.                          */
N/*----------------------------------------------------------------------------*/
N#if __has_include(<sys/cdefs.h>)
X#if 1
N#include <sys/cdefs.h>
N#endif
N
N/*----------------------------------------------------------------------------*/
N/* Include xlocale/_stdio.h if xlocale.h has already been included. This is   */
N/* to conform with FreeBSD's xlocale implementation.                          */
N/*----------------------------------------------------------------------------*/
N#ifdef _XLOCALE_H_
S__BEGIN_DECLS
S#include <xlocale/_stdio.h>
S__END_DECLS
N#endif
N
N#endif  /* #ifndef _STDIO_H_ */
L 109 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/stdio.h" 2
N
N#ifdef __cplusplus
N
N/* snprintf */
N#if defined(_LIBCPP_MSVCRT_LIKE)
X#if 0L
Sextern "C" {
Sint vasprintf(char **sptr, const char *__restrict fmt, va_list ap);
S}
N#endif
N
N#undef getc
N#undef putc
N#undef clearerr
N#undef feof
N#undef ferror
N
N#endif
N
N#endif  /* _LIBCPP_STDIO_H */
L 17 "..\MiniSegway.h" 2
N#include "UART_Wrapper.h"
L 1 "..\UART_Wrapper.h" 1
N/*
N * UART_Wrapper.h
N *
N *  Created on: Jun 18, 2020
N *      Author: Juan Francisco Valle
N */
N
N#ifndef UART_WRAPPER_H_
N#define UART_WRAPPER_H_
N
N#include <stdint.h>
N#include <driverlib.h>
N#include "Odometry.h"
L 1 "..\Odometry.h" 1
N/*
N * Odometry.h
N *
N *  Created on: Jun 16, 2020
N *      Author: Juan Francisco Vallejo
N */
N
N#ifndef ODOMETRY_H_
N#define ODOMETRY_H_
N
N#include <stdint.h>
N#include <driverlib.h>
N#include "Motor.h"
N#include <cmath>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/cmath" 1
N// -*- C++ -*-
N//===---------------------------- cmath -----------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is dual licensed under the MIT and the University of Illinois Open
N// Source Licenses. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP_CMATH
N#define _LIBCPP_CMATH
N
N/*
N    cmath synopsis
N
NMacros:
N
N    HUGE_VAL
N    HUGE_VALF               // C99
N    HUGE_VALL               // C99
N    INFINITY                // C99
N    NAN                     // C99
N    FP_INFINITE             // C99
N    FP_NAN                  // C99
N    FP_NORMAL               // C99
N    FP_SUBNORMAL            // C99
N    FP_ZERO                 // C99
N    FP_FAST_FMA             // C99
N    FP_FAST_FMAF            // C99
N    FP_FAST_FMAL            // C99
N    FP_ILOGB0               // C99
N    FP_ILOGBNAN             // C99
N    MATH_ERRNO              // C99
N    MATH_ERREXCEPT          // C99
N    math_errhandling        // C99
N
Nnamespace std
N{
N
NTypes:
N
N    float_t                 // C99
N    double_t                // C99
N
N// C90
N
Nfloating_point abs(floating_point x);
N
Nfloating_point acos (arithmetic x);
Nfloat          acosf(float x);
Nlong double    acosl(long double x);
N
Nfloating_point asin (arithmetic x);
Nfloat          asinf(float x);
Nlong double    asinl(long double x);
N
Nfloating_point atan (arithmetic x);
Nfloat          atanf(float x);
Nlong double    atanl(long double x);
N
Nfloating_point atan2 (arithmetic y, arithmetic x);
Nfloat          atan2f(float y, float x);
Nlong double    atan2l(long double y, long double x);
N
Nfloating_point ceil (arithmetic x);
Nfloat          ceilf(float x);
Nlong double    ceill(long double x);
N
Nfloating_point cos (arithmetic x);
Nfloat          cosf(float x);
Nlong double    cosl(long double x);
N
Nfloating_point cosh (arithmetic x);
Nfloat          coshf(float x);
Nlong double    coshl(long double x);
N
Nfloating_point exp (arithmetic x);
Nfloat          expf(float x);
Nlong double    expl(long double x);
N
Nfloating_point fabs (arithmetic x);
Nfloat          fabsf(float x);
Nlong double    fabsl(long double x);
N
Nfloating_point floor (arithmetic x);
Nfloat          floorf(float x);
Nlong double    floorl(long double x);
N
Nfloating_point fmod (arithmetic x, arithmetic y);
Nfloat          fmodf(float x, float y);
Nlong double    fmodl(long double x, long double y);
N
Nfloating_point frexp (arithmetic value, int* exp);
Nfloat          frexpf(float value, int* exp);
Nlong double    frexpl(long double value, int* exp);
N
Nfloating_point ldexp (arithmetic value, int exp);
Nfloat          ldexpf(float value, int exp);
Nlong double    ldexpl(long double value, int exp);
N
Nfloating_point log (arithmetic x);
Nfloat          logf(float x);
Nlong double    logl(long double x);
N
Nfloating_point log10 (arithmetic x);
Nfloat          log10f(float x);
Nlong double    log10l(long double x);
N
Nfloating_point modf (floating_point value, floating_point* iptr);
Nfloat          modff(float value, float* iptr);
Nlong double    modfl(long double value, long double* iptr);
N
Nfloating_point pow (arithmetic x, arithmetic y);
Nfloat          powf(float x, float y);
Nlong double    powl(long double x, long double y);
N
Nfloating_point sin (arithmetic x);
Nfloat          sinf(float x);
Nlong double    sinl(long double x);
N
Nfloating_point sinh (arithmetic x);
Nfloat          sinhf(float x);
Nlong double    sinhl(long double x);
N
Nfloating_point sqrt (arithmetic x);
Nfloat          sqrtf(float x);
Nlong double    sqrtl(long double x);
N
Nfloating_point tan (arithmetic x);
Nfloat          tanf(float x);
Nlong double    tanl(long double x);
N
Nfloating_point tanh (arithmetic x);
Nfloat          tanhf(float x);
Nlong double    tanhl(long double x);
N
N//  C99
N
Nbool signbit(arithmetic x);
N
Nint fpclassify(arithmetic x);
N
Nbool isfinite(arithmetic x);
Nbool isinf(arithmetic x);
Nbool isnan(arithmetic x);
Nbool isnormal(arithmetic x);
N
Nbool isgreater(arithmetic x, arithmetic y);
Nbool isgreaterequal(arithmetic x, arithmetic y);
Nbool isless(arithmetic x, arithmetic y);
Nbool islessequal(arithmetic x, arithmetic y);
Nbool islessgreater(arithmetic x, arithmetic y);
Nbool isunordered(arithmetic x, arithmetic y);
N
Nfloating_point acosh (arithmetic x);
Nfloat          acoshf(float x);
Nlong double    acoshl(long double x);
N
Nfloating_point asinh (arithmetic x);
Nfloat          asinhf(float x);
Nlong double    asinhl(long double x);
N
Nfloating_point atanh (arithmetic x);
Nfloat          atanhf(float x);
Nlong double    atanhl(long double x);
N
Nfloating_point cbrt (arithmetic x);
Nfloat          cbrtf(float x);
Nlong double    cbrtl(long double x);
N
Nfloating_point copysign (arithmetic x, arithmetic y);
Nfloat          copysignf(float x, float y);
Nlong double    copysignl(long double x, long double y);
N
Nfloating_point erf (arithmetic x);
Nfloat          erff(float x);
Nlong double    erfl(long double x);
N
Nfloating_point erfc (arithmetic x);
Nfloat          erfcf(float x);
Nlong double    erfcl(long double x);
N
Nfloating_point exp2 (arithmetic x);
Nfloat          exp2f(float x);
Nlong double    exp2l(long double x);
N
Nfloating_point expm1 (arithmetic x);
Nfloat          expm1f(float x);
Nlong double    expm1l(long double x);
N
Nfloating_point fdim (arithmetic x, arithmetic y);
Nfloat          fdimf(float x, float y);
Nlong double    fdiml(long double x, long double y);
N
Nfloating_point fma (arithmetic x, arithmetic y, arithmetic z);
Nfloat          fmaf(float x, float y, float z);
Nlong double    fmal(long double x, long double y, long double z);
N
Nfloating_point fmax (arithmetic x, arithmetic y);
Nfloat          fmaxf(float x, float y);
Nlong double    fmaxl(long double x, long double y);
N
Nfloating_point fmin (arithmetic x, arithmetic y);
Nfloat          fminf(float x, float y);
Nlong double    fminl(long double x, long double y);
N
Nfloating_point hypot (arithmetic x, arithmetic y);
Nfloat          hypotf(float x, float y);
Nlong double    hypotl(long double x, long double y);
N
Ndouble       hypot(double x, double y, double z);                // C++17
Nfloat        hypot(float x, float y, float z);                   // C++17
Nlong double  hypot(long double x, long double y, long double z); // C++17
N
Nint ilogb (arithmetic x);
Nint ilogbf(float x);
Nint ilogbl(long double x);
N
Nfloating_point lgamma (arithmetic x);
Nfloat          lgammaf(float x);
Nlong double    lgammal(long double x);
N
Nlong long llrint (arithmetic x);
Nlong long llrintf(float x);
Nlong long llrintl(long double x);
N
Nlong long llround (arithmetic x);
Nlong long llroundf(float x);
Nlong long llroundl(long double x);
N
Nfloating_point log1p (arithmetic x);
Nfloat          log1pf(float x);
Nlong double    log1pl(long double x);
N
Nfloating_point log2 (arithmetic x);
Nfloat          log2f(float x);
Nlong double    log2l(long double x);
N
Nfloating_point logb (arithmetic x);
Nfloat          logbf(float x);
Nlong double    logbl(long double x);
N
Nlong lrint (arithmetic x);
Nlong lrintf(float x);
Nlong lrintl(long double x);
N
Nlong lround (arithmetic x);
Nlong lroundf(float x);
Nlong lroundl(long double x);
N
Ndouble      nan (const char* str);
Nfloat       nanf(const char* str);
Nlong double nanl(const char* str);
N
Nfloating_point nearbyint (arithmetic x);
Nfloat          nearbyintf(float x);
Nlong double    nearbyintl(long double x);
N
Nfloating_point nextafter (arithmetic x, arithmetic y);
Nfloat          nextafterf(float x, float y);
Nlong double    nextafterl(long double x, long double y);
N
Nfloating_point nexttoward (arithmetic x, long double y);
Nfloat          nexttowardf(float x, long double y);
Nlong double    nexttowardl(long double x, long double y);
N
Nfloating_point remainder (arithmetic x, arithmetic y);
Nfloat          remainderf(float x, float y);
Nlong double    remainderl(long double x, long double y);
N
Nfloating_point remquo (arithmetic x, arithmetic y, int* pquo);
Nfloat          remquof(float x, float y, int* pquo);
Nlong double    remquol(long double x, long double y, int* pquo);
N
Nfloating_point rint (arithmetic x);
Nfloat          rintf(float x);
Nlong double    rintl(long double x);
N
Nfloating_point round (arithmetic x);
Nfloat          roundf(float x);
Nlong double    roundl(long double x);
N
Nfloating_point scalbln (arithmetic x, long ex);
Nfloat          scalblnf(float x, long ex);
Nlong double    scalblnl(long double x, long ex);
N
Nfloating_point scalbn (arithmetic x, int ex);
Nfloat          scalbnf(float x, int ex);
Nlong double    scalbnl(long double x, int ex);
N
Nfloating_point tgamma (arithmetic x);
Nfloat          tgammaf(float x);
Nlong double    tgammal(long double x);
N
Nfloating_point trunc (arithmetic x);
Nfloat          truncf(float x);
Nlong double    truncl(long double x);
N
N}  // std
N
N*/
N
N#include <__config>
N#include <math.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/math.h" 1
N/* -*- C++ -*- */
N/*===--------------------------- complex.h --------------------------------===*/
N/*                                                                            */
N/*                     The LLVM Compiler Infrastructure                       */
N/*                                                                            */
N/* This file is dual licensed under the MIT and the University of Illinois Open
N** Source Licenses. See LICENSE.TXT for details.
N*/
N/*===----------------------------------------------------------------------===*/
N
N#ifndef _LIBCPP_MATH_H
N#define _LIBCPP_MATH_H
N
N/*
N    math.h synopsis
N
NMacros:
N
N    HUGE_VAL
N    HUGE_VALF               // C99
N    HUGE_VALL               // C99
N    INFINITY                // C99
N    NAN                     // C99
N    FP_INFINITE             // C99
N    FP_NAN                  // C99
N    FP_NORMAL               // C99
N    FP_SUBNORMAL            // C99
N    FP_ZERO                 // C99
N    FP_FAST_FMA             // C99
N    FP_FAST_FMAF            // C99
N    FP_FAST_FMAL            // C99
N    FP_ILOGB0               // C99
N    FP_ILOGBNAN             // C99
N    MATH_ERRNO              // C99
N    MATH_ERREXCEPT          // C99
N    math_errhandling        // C99
N
NTypes:
N
N    float_t                 // C99
N    double_t                // C99
N
N// C90
N
Nfloating_point abs(floating_point x);
N
Nfloating_point acos (arithmetic x);
Nfloat          acosf(float x);
Nlong double    acosl(long double x);
N
Nfloating_point asin (arithmetic x);
Nfloat          asinf(float x);
Nlong double    asinl(long double x);
N
Nfloating_point atan (arithmetic x);
Nfloat          atanf(float x);
Nlong double    atanl(long double x);
N
Nfloating_point atan2 (arithmetic y, arithmetic x);
Nfloat          atan2f(float y, float x);
Nlong double    atan2l(long double y, long double x);
N
Nfloating_point ceil (arithmetic x);
Nfloat          ceilf(float x);
Nlong double    ceill(long double x);
N
Nfloating_point cos (arithmetic x);
Nfloat          cosf(float x);
Nlong double    cosl(long double x);
N
Nfloating_point cosh (arithmetic x);
Nfloat          coshf(float x);
Nlong double    coshl(long double x);
N
Nfloating_point exp (arithmetic x);
Nfloat          expf(float x);
Nlong double    expl(long double x);
N
Nfloating_point fabs (arithmetic x);
Nfloat          fabsf(float x);
Nlong double    fabsl(long double x);
N
Nfloating_point floor (arithmetic x);
Nfloat          floorf(float x);
Nlong double    floorl(long double x);
N
Nfloating_point fmod (arithmetic x, arithmetic y);
Nfloat          fmodf(float x, float y);
Nlong double    fmodl(long double x, long double y);
N
Nfloating_point frexp (arithmetic value, int* exp);
Nfloat          frexpf(float value, int* exp);
Nlong double    frexpl(long double value, int* exp);
N
Nfloating_point ldexp (arithmetic value, int exp);
Nfloat          ldexpf(float value, int exp);
Nlong double    ldexpl(long double value, int exp);
N
Nfloating_point log (arithmetic x);
Nfloat          logf(float x);
Nlong double    logl(long double x);
N
Nfloating_point log10 (arithmetic x);
Nfloat          log10f(float x);
Nlong double    log10l(long double x);
N
Nfloating_point modf (floating_point value, floating_point* iptr);
Nfloat          modff(float value, float* iptr);
Nlong double    modfl(long double value, long double* iptr);
N
Nfloating_point pow (arithmetic x, arithmetic y);
Nfloat          powf(float x, float y);
Nlong double    powl(long double x, long double y);
N
Nfloating_point sin (arithmetic x);
Nfloat          sinf(float x);
Nlong double    sinl(long double x);
N
Nfloating_point sinh (arithmetic x);
Nfloat          sinhf(float x);
Nlong double    sinhl(long double x);
N
Nfloating_point sqrt (arithmetic x);
Nfloat          sqrtf(float x);
Nlong double    sqrtl(long double x);
N
Nfloating_point tan (arithmetic x);
Nfloat          tanf(float x);
Nlong double    tanl(long double x);
N
Nfloating_point tanh (arithmetic x);
Nfloat          tanhf(float x);
Nlong double    tanhl(long double x);
N
N//  C99
N
Nbool signbit(arithmetic x);
N
Nint fpclassify(arithmetic x);
N
Nbool isfinite(arithmetic x);
Nbool isinf(arithmetic x);
Nbool isnan(arithmetic x);
Nbool isnormal(arithmetic x);
N
Nbool isgreater(arithmetic x, arithmetic y);
Nbool isgreaterequal(arithmetic x, arithmetic y);
Nbool isless(arithmetic x, arithmetic y);
Nbool islessequal(arithmetic x, arithmetic y);
Nbool islessgreater(arithmetic x, arithmetic y);
Nbool isunordered(arithmetic x, arithmetic y);
N
Nfloating_point acosh (arithmetic x);
Nfloat          acoshf(float x);
Nlong double    acoshl(long double x);
N
Nfloating_point asinh (arithmetic x);
Nfloat          asinhf(float x);
Nlong double    asinhl(long double x);
N
Nfloating_point atanh (arithmetic x);
Nfloat          atanhf(float x);
Nlong double    atanhl(long double x);
N
Nfloating_point cbrt (arithmetic x);
Nfloat          cbrtf(float x);
Nlong double    cbrtl(long double x);
N
Nfloating_point copysign (arithmetic x, arithmetic y);
Nfloat          copysignf(float x, float y);
Nlong double    copysignl(long double x, long double y);
N
Nfloating_point erf (arithmetic x);
Nfloat          erff(float x);
Nlong double    erfl(long double x);
N
Nfloating_point erfc (arithmetic x);
Nfloat          erfcf(float x);
Nlong double    erfcl(long double x);
N
Nfloating_point exp2 (arithmetic x);
Nfloat          exp2f(float x);
Nlong double    exp2l(long double x);
N
Nfloating_point expm1 (arithmetic x);
Nfloat          expm1f(float x);
Nlong double    expm1l(long double x);
N
Nfloating_point fdim (arithmetic x, arithmetic y);
Nfloat          fdimf(float x, float y);
Nlong double    fdiml(long double x, long double y);
N
Nfloating_point fma (arithmetic x, arithmetic y, arithmetic z);
Nfloat          fmaf(float x, float y, float z);
Nlong double    fmal(long double x, long double y, long double z);
N
Nfloating_point fmax (arithmetic x, arithmetic y);
Nfloat          fmaxf(float x, float y);
Nlong double    fmaxl(long double x, long double y);
N
Nfloating_point fmin (arithmetic x, arithmetic y);
Nfloat          fminf(float x, float y);
Nlong double    fminl(long double x, long double y);
N
Nfloating_point hypot (arithmetic x, arithmetic y);
Nfloat          hypotf(float x, float y);
Nlong double    hypotl(long double x, long double y);
N
Nint ilogb (arithmetic x);
Nint ilogbf(float x);
Nint ilogbl(long double x);
N
Nfloating_point lgamma (arithmetic x);
Nfloat          lgammaf(float x);
Nlong double    lgammal(long double x);
N
Nlong long llrint (arithmetic x);
Nlong long llrintf(float x);
Nlong long llrintl(long double x);
N
Nlong long llround (arithmetic x);
Nlong long llroundf(float x);
Nlong long llroundl(long double x);
N
Nfloating_point log1p (arithmetic x);
Nfloat          log1pf(float x);
Nlong double    log1pl(long double x);
N
Nfloating_point log2 (arithmetic x);
Nfloat          log2f(float x);
Nlong double    log2l(long double x);
N
Nfloating_point logb (arithmetic x);
Nfloat          logbf(float x);
Nlong double    logbl(long double x);
N
Nlong lrint (arithmetic x);
Nlong lrintf(float x);
Nlong lrintl(long double x);
N
Nlong lround (arithmetic x);
Nlong lroundf(float x);
Nlong lroundl(long double x);
N
Ndouble      nan (const char* str);
Nfloat       nanf(const char* str);
Nlong double nanl(const char* str);
N
Nfloating_point nearbyint (arithmetic x);
Nfloat          nearbyintf(float x);
Nlong double    nearbyintl(long double x);
N
Nfloating_point nextafter (arithmetic x, arithmetic y);
Nfloat          nextafterf(float x, float y);
Nlong double    nextafterl(long double x, long double y);
N
Nfloating_point nexttoward (arithmetic x, long double y);
Nfloat          nexttowardf(float x, long double y);
Nlong double    nexttowardl(long double x, long double y);
N
Nfloating_point remainder (arithmetic x, arithmetic y);
Nfloat          remainderf(float x, float y);
Nlong double    remainderl(long double x, long double y);
N
Nfloating_point remquo (arithmetic x, arithmetic y, int* pquo);
Nfloat          remquof(float x, float y, int* pquo);
Nlong double    remquol(long double x, long double y, int* pquo);
N
Nfloating_point rint (arithmetic x);
Nfloat          rintf(float x);
Nlong double    rintl(long double x);
N
Nfloating_point round (arithmetic x);
Nfloat          roundf(float x);
Nlong double    roundl(long double x);
N
Nfloating_point scalbln (arithmetic x, long ex);
Nfloat          scalblnf(float x, long ex);
Nlong double    scalblnl(long double x, long ex);
N
Nfloating_point scalbn (arithmetic x, int ex);
Nfloat          scalbnf(float x, int ex);
Nlong double    scalbnl(long double x, int ex);
N
Nfloating_point tgamma (arithmetic x);
Nfloat          tgammaf(float x);
Nlong double    tgammal(long double x);
N
Nfloating_point trunc (arithmetic x);
Nfloat          truncf(float x);
Nlong double    truncl(long double x);
N
N*/
N
N#include <__config>
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N#include_next <math.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/math.h" 1
N/*
N * Copyright (c) 2015-2015 Texas Instruments Incorporated
N *
N * ====================================================
N * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
N *
N * Developed at SunPro, a Sun Microsystems, Inc. business.
N * Permission to use, copy, modify, and distribute this
N * software is freely granted, provided that this notice
N * is preserved.
N * ====================================================
N */
N
N/*
N * from: @(#)fdlibm.h 5.1 93/09/24
N * $FreeBSD$
N */
N
N#ifndef _TI_MATH_H_
N#define	_TI_MATH_H_
N
N#pragma diag_push
N#pragma CHECK_MISRA("-6.3") /* standard types required for standard headers */
N#pragma CHECK_MISRA("-12.7") /* bitwise operators not allowed on signed ints */
N#pragma CHECK_MISRA("-16.4") /* identifiers in fn defn/decl identical??? fabs/fabsf */
N#pragma CHECK_MISRA("-19.1") /* only comments and preproc before #include */
N#pragma CHECK_MISRA("-19.7") /* macros required for implementation */
N#pragma CHECK_MISRA("-20.1") /* standard headers must define standard names */
N#pragma CHECK_MISRA("-20.2") /* standard headers must define standard names */
N
N#include <_ti_config.h>
N#include <_defs.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/_defs.h" 1
N/*****************************************************************************/
N/* _defs.h                                                                   */
N/*                                                                           */
N/* Copyright (c) 2015 Texas Instruments Incorporated                         */
N/* http://www.ti.com/                                                        */
N/*                                                                           */
N/*  Redistribution and  use in source  and binary forms, with  or without    */
N/*  modification,  are permitted provided  that the  following conditions    */
N/*  are met:                                                                 */
N/*                                                                           */
N/*     Redistributions  of source  code must  retain the  above copyright    */
N/*     notice, this list of conditions and the following disclaimer.         */
N/*                                                                           */
N/*     Redistributions in binary form  must reproduce the above copyright    */
N/*     notice, this  list of conditions  and the following  disclaimer in    */
N/*     the  documentation  and/or   other  materials  provided  with  the    */
N/*     distribution.                                                         */
N/*                                                                           */
N/*     Neither the  name of Texas Instruments Incorporated  nor the names    */
N/*     of its  contributors may  be used to  endorse or  promote products    */
N/*     derived  from   this  software  without   specific  prior  written    */
N/*     permission.                                                           */
N/*                                                                           */
N/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS    */
N/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT    */
N/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    */
N/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT    */
N/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    */
N/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT    */
N/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    */
N/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    */
N/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT    */
N/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    */
N/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     */
N/*                                                                           */
N/*****************************************************************************/
N
N#ifndef _DEFS_H_
N#define _DEFS_H_
N
N#pragma diag_push
N
N#pragma CHECK_MISRA("-8.1") /* visible prototypes */
N#pragma CHECK_MISRA("-8.5") /* functions in header files */
N#pragma CHECK_MISRA("-8.11") /* use static on fns with internal linkage */
N#pragma CHECK_MISRA("-10.1") /* implicit conversion ... bool to int??? */
N#pragma CHECK_MISRA("-12.1") /* operator precedence */
N#pragma CHECK_MISRA("-12.2") /* different order of operations??? */
N#pragma CHECK_MISRA("-12.4") /* RHS of &&/|| has side effects??? */
N#pragma CHECK_MISRA("-12.7") /* Bitwise operators on signed types */
N#pragma CHECK_MISRA("-14.7") /* single point of return */
N#pragma CHECK_MISRA("-14.9") /* only compound statement after if/else */
N#pragma CHECK_MISRA("-19.1") /* only comments and preproc before #include??? */
N#pragma CHECK_MISRA("-19.4") /* macro expands to unparenthesized */
N
N#pragma diag_suppress 1558 /* --float_operations_allowed checks */
N
N/*---------------------------------------------------------------------------*/
N/* _INLINE_DEFINITION                                                        */
N/*                                                                           */
N/* The regular (non-llvm-based) TI tools assume C++ inline semantics by      */
N/* default, so if a function ends up not being inlined, then its definition  */
N/* is kept in the compilation unit (but via COMDAT, we'll only keep one      */
N/* definition of the function for the whole application).                    */
N/*                                                                           */
N/* However, llvm-based TI tools (like arm-llvm) use clang, and clang does    */
N/* not assume C++ inline semantics by default. With the below definition of  */
N/* _INLINE_DEFINITION for clang, we are going to force functions that are    */
N/* declared with __inline to be *always* inlined (even when optimization or  */
N/* inlining is somehow disabled).                                            */
N/*---------------------------------------------------------------------------*/
N#ifndef _INLINE_DEFINITION
N#ifdef __cplusplus
N#define _INLINE_DEFINITION inline
N#elif defined(__clang__)
S#define _INLINE_DEFINITION __inline __attribute__((always_inline))
S#else
S#define _INLINE_DEFINITION __inline
N#endif
N#endif
N
N/* This file is included in other user header files; take care not to
N   pollute the namespace */
N
N#if __has_include(<sys/_types.h>)
X#if 1
N#include <sys/_types.h>
N#include <machine/_limits.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/machine/_limits.h" 1
N/*-
N * SPDX-License-Identifier: BSD-3-Clause
N *
N * Copyright (c) 1988, 1993
N *	The Regents of the University of California.  All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N * 1. Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N * 3. Neither the name of the University nor the names of its contributors
N *    may be used to endorse or promote products derived from this software
N *    without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
N * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
N * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
N * SUCH DAMAGE.
N *
N *	@(#)limits.h	8.3 (Berkeley) 1/4/94
N * $FreeBSD$
N */
N
N#ifndef _MACHINE__LIMITS_H_
N#define	_MACHINE__LIMITS_H_
N
N/*
N * According to ANSI (section 2.2.4.2), the values below must be usable by
N * #if preprocessing directives.  Additionally, the expression must have the
N * same type as would an expression that is an object of the corresponding
N * type converted according to the integral promotions.  The subtraction for
N * INT_MIN, etc., is so the value is not unsigned; e.g., 0x80000000 is an
N * unsigned int for 32-bit two's complement ANSI compilers (section 3.1.3.2).
N */
N
N#define	__CHAR_BIT	8		/* number of bits in a char */
N
N#define	__SCHAR_MAX	0x7f		/* max value for a signed char */
N#define	__SCHAR_MIN	(-0x7f - 1)	/* min value for a signed char */
N
N#define	__UCHAR_MAX	0xff		/* max value for an unsigned char */
N
N#define	__USHRT_MAX	0xffff		/* max value for an unsigned short */
N#define	__SHRT_MAX	0x7fff		/* max value for a short */
N#define	__SHRT_MIN	(-0x7fff - 1)	/* min value for a short */
N
N#define	__UINT_MAX	0xffffffff	/* max value for an unsigned int */
N#define	__INT_MAX	0x7fffffff	/* max value for an int */
N#define	__INT_MIN	(-0x7fffffff - 1)	/* min value for an int */
N
N#define	__ULONG_MAX	0xffffffffUL	/* max value for an unsigned long */
N#define	__LONG_MAX	0x7fffffffL	/* max value for a long */
N#define	__LONG_MIN	(-0x7fffffffL - 1)	/* min value for a long */
N
N			/* max value for an unsigned long long */
N#define	__ULLONG_MAX	0xffffffffffffffffULL
N#define	__LLONG_MAX	0x7fffffffffffffffLL	/* max value for a long long */
N#define	__LLONG_MIN	(-0x7fffffffffffffffLL - 1)  /* min for a long long */
N
N#define	__SSIZE_MAX	__INT_MAX	/* max value for a ssize_t */
N
N#define	__SIZE_T_MAX	__UINT_MAX	/* max value for a size_t */
N
N#define	__OFF_MAX	__LLONG_MAX	/* max value for a off_t */
N#define	__OFF_MIN	__LLONG_MIN	/* min value for a off_t */
N
N/* Quads and long longs are the same size.  Ensure they stay in sync. */
N#define	__UQUAD_MAX	__ULLONG_MAX	/* max value for a uquad_t */
N#define	__QUAD_MAX	__LLONG_MAX	/* max value for a quad_t */
N#define	__QUAD_MIN	__LLONG_MIN	/* min value for a quad_t */
N
N#define	__LONG_BIT	32
N#define	__WORD_BIT	32
N
N/* Minimum signal stack size. */
N#define	__MINSIGSTKSZ	(1024 * 4)
N
N#endif /* !_MACHINE__LIMITS_H_ */
L 88 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/_defs.h" 2
N#else
Stypedef unsigned long long __uint64_t;
S#if defined(__TMS320C2000__) || defined(__MSP430__)
Stypedef unsigned long __uint32_t;
S#define __INT_MAX 32767
S#else
Stypedef unsigned __uint32_t;
S#define __INT_MAX  2147483647
S#endif
N#endif
N
N#if __has_include(<sys/cdefs.h>)
X#if 1
N#include <sys/cdefs.h>
N#else
S#ifdef __cplusplus
S#define __BEGIN_DECLS extern "C" {
S#define __END_DECLS }
S#else
S#define __BEGIN_DECLS
S#define __END_DECLS
S#endif
N#endif
N
N/* normalize target-specific intrinsics */
N
N#if defined (__clang__)
X#if 0L
Sstatic __inline __uint32_t __f32_bits_as_u32(float x) {
S    const union { float f; __uint32_t i; } rep = {.f = x};
S    return rep.i;
S}
S
Sstatic __inline float __u32_bits_as_f32(__uint32_t x) {
S    const union { float f; __uint32_t i; } rep = {.i = x};
S    return rep.f;
S}
S
Sstatic __inline __uint64_t __f64_bits_as_u64(double x) {
S    const union { double f; __uint64_t i; } rep = {.f = x};
S    return rep.i;
S}
S
Sstatic __inline double __u64_bits_as_f64(__uint64_t x) {
S    const union { double f; __uint64_t i; } rep = {.i = x};
S    return rep.f;
S}
S
Sstatic __inline __uint32_t __f64_upper_bits_as_u32(double x) {
S    const union { double f; __uint64_t i; } rep = {.f = x};
S    return rep.i >> 32;
S}
S
Sstatic __inline __uint32_t __f64_lower_bits_as_u32(double x) {
S    const union { double f; __uint64_t i; } rep = {.f = x};
S    return (__uint32_t)rep.i;
S}
S
Sstatic __inline double __u32x2_bits_as_f64(__uint32_t x, __uint32_t y) {
S    const union { double f; __uint64_t i; } rep = {.i = (__uint64_t)x << 32 | y };
S    return rep.f;
S}
N#elif defined(__ARM_ARCH)
X#elif 1L
N#define __u32_bits_as_f32(x) (_itof(x))
N#define __f32_bits_as_u32(x) (_ftoi(x))
N#define __u64_bits_as_f64(x) (_itod((x)>>32,(x)&0xffffffff))
N#define __f64_bits_as_u64(x) ((((__uint64_t)_hi(x) << 32 | _lo(x))))
N#define __f64_upper_bits_as_u32(x) (_hi(x))
N#define __f64_lower_bits_as_u32(x) (_lo(x))
N#define __u32x2_bits_as_f64(x,y) (_itod((x),(y)))
N#elif defined(__C7000__) /* Keep __C7000__ ordered before __TMS320C6X */
S#define __u32_bits_as_f32(x) (__as_float(x))
S#define __f32_bits_as_u32(x) (__as_uint(x))
S#define __u64_bits_as_f64(x) (__as_double(x))
S#define __f64_bits_as_u64(x) (__as_ulong(x))
S#define __f64_upper_bits_as_u32(x) (__as_uint2(x).hi)
S#define __f64_lower_bits_as_u32(x) (__as_uint2(x).lo)
S#define __u32x2_bits_as_f64(x,y) (__as_double((__uint2)(y, x)))
S#elif defined(__TMS320C6X__)
S#define __u32_bits_as_f32(x) (_itof(x))
S#define __f32_bits_as_u32(x) (_ftoi(x))
S#define __u64_bits_as_f64(x) (_lltod(x))
S#define __f64_bits_as_u64(x) (_dtoll(x))
S#define __f64_upper_bits_as_u32(x) (_hi(x))
S#define __f64_lower_bits_as_u32(x) (_lo(x))
S#define __u32x2_bits_as_f64(x,y) (_itod((x),(y)))
S#else
S#define __f64_upper_bits_as_u32(x) (__f64_bits_as_u64(x) >> 32)
S#define __f64_lower_bits_as_u32(x) (__f64_bits_as_u64(x) & 0xffffffff)
S#define __u32x2_bits_as_f64(x,y) (__u64_bits_as_f64((__uint64_t)(x) << 32 | (__uint32_t)(y)))
N#endif
N
N#define __IEEE32_BIAS 0x7f
N#define __IEEE32_MANT_DIG 24
N#define __IEEE32_MAX_EXP 128u
N#define __IEEE32_MIN 0x1.0p-126
N#define __IEEE32_BIT_MASK(n) (((__uint32_t)(1) << (n)) - 1)
N#define __IEEE32_EXP_BITS_MASK ((__IEEE32_MAX_EXP * 2) - 1)
N#define __IEEE32_SGN_TEST_MASK ((__uint32_t)(1) << (32-1))
N#define __IEEE32_EXP_TEST_MASK 0x7f80u
N
N#define __IEEE32_SIGN_BIT_ZERO(f) \
N    ((__f32_bits_as_u32(f) & __IEEE32_SGN_TEST_MASK) == 0)
X#define __IEEE32_SIGN_BIT_ZERO(f)     ((__f32_bits_as_u32(f) & __IEEE32_SGN_TEST_MASK) == 0)
N
N#define __IEEE32_BIASED_EXP(f) \
N    (((unsigned int)(__f32_bits_as_u32(f) >> (__IEEE32_MANT_DIG-1))) & __IEEE32_EXP_BITS_MASK)
X#define __IEEE32_BIASED_EXP(f)     (((unsigned int)(__f32_bits_as_u32(f) >> (__IEEE32_MANT_DIG-1))) & __IEEE32_EXP_BITS_MASK)
N
N#define __IEEE32_BIASED_EXP_IS_MAX(f) \
N   ((((unsigned int)(__f32_bits_as_u32(f) >> 16)) & \
N     __IEEE32_EXP_TEST_MASK) == __IEEE32_EXP_TEST_MASK)
X#define __IEEE32_BIASED_EXP_IS_MAX(f)    ((((unsigned int)(__f32_bits_as_u32(f) >> 16)) &      __IEEE32_EXP_TEST_MASK) == __IEEE32_EXP_TEST_MASK)
N
N#define __IEEE32_FRAC_PART(f) \
N   (__f32_bits_as_u32(f) & __IEEE32_BIT_MASK(__IEEE32_MANT_DIG-1))
X#define __IEEE32_FRAC_PART(f)    (__f32_bits_as_u32(f) & __IEEE32_BIT_MASK(__IEEE32_MANT_DIG-1))
N
N#define __IEEE32_FRAC_PART_IS_ZERO(f) (__IEEE32_FRAC_PART(f) == 0)
N
N#define __IEEE32_DISCARD_N_FRAC_BITS(v,n) \
N    (__u32_bits_as_f32(__f32_bits_as_u32(v) & ~__IEEE32_BIT_MASK(n)))
X#define __IEEE32_DISCARD_N_FRAC_BITS(v,n)     (__u32_bits_as_f32(__f32_bits_as_u32(v) & ~__IEEE32_BIT_MASK(n)))
N
N#define __IEEE32_DISCARD_EXP_AND_FRAC_PARTS(v) \
N    (__u32_bits_as_f32(__f32_bits_as_u32(v) & __IEEE32_SGN_TEST_MASK))
X#define __IEEE32_DISCARD_EXP_AND_FRAC_PARTS(v)     (__u32_bits_as_f32(__f32_bits_as_u32(v) & __IEEE32_SGN_TEST_MASK))
N
N#define __IEEE32_UNBIASED_EXP(f) \
N    (__IEEE32_BIASED_EXP(f) - __IEEE32_BIAS)
X#define __IEEE32_UNBIASED_EXP(f)     (__IEEE32_BIASED_EXP(f) - __IEEE32_BIAS)
N
N#define __IEEE32_BIASED_EXP_IS_ZERO(f) (__IEEE32_BIASED_EXP(f) == 0)
N
N#define __IEEE32_IS_ZERO(f) \
N    ((__f32_bits_as_u32(f) & ~__IEEE32_SGN_TEST_MASK)==0)
X#define __IEEE32_IS_ZERO(f)     ((__f32_bits_as_u32(f) & ~__IEEE32_SGN_TEST_MASK)==0)
N
N#define __IEEE64_BIAS 1023
N#define __IEEE64_MANT_DIG 53
N#define __IEEE64_MAX_EXP 1024u
N#define __IEEE64_MIN C(0x1.0p-1022)
N#define __IEEE64_BIT_MASK(n) (((__uint64_t)(1) << (n)) - 1)
N#define __IEEE64_EXP_BITS_MASK ((__IEEE64_MAX_EXP * 2) - 1)
N#define __IEEE64_SGN_TEST_MASK ((__uint64_t)(1) << (64-1))
N#define __IEEE64_EXP_TEST_MASK 0x7ff0u
N
N#define __IEEE64_SIGN_BIT_ZERO(f) \
N   ((__f64_bits_as_u64(f) & __IEEE64_SGN_TEST_MASK) == 0)
X#define __IEEE64_SIGN_BIT_ZERO(f)    ((__f64_bits_as_u64(f) & __IEEE64_SGN_TEST_MASK) == 0)
N
N#define __IEEE64_BIASED_EXP(f) \
N   ((__f64_bits_as_u64(f) >> (__IEEE64_MANT_DIG-1)) & __IEEE64_EXP_BITS_MASK)
X#define __IEEE64_BIASED_EXP(f)    ((__f64_bits_as_u64(f) >> (__IEEE64_MANT_DIG-1)) & __IEEE64_EXP_BITS_MASK)
N
N#define __IEEE64_BIASED_EXP_IS_MAX(f) \
N   ((((unsigned int)(__f64_bits_as_u64(f) >> 48)) &  \
N     __IEEE64_EXP_TEST_MASK) == __IEEE64_EXP_TEST_MASK)
X#define __IEEE64_BIASED_EXP_IS_MAX(f)    ((((unsigned int)(__f64_bits_as_u64(f) >> 48)) &       __IEEE64_EXP_TEST_MASK) == __IEEE64_EXP_TEST_MASK)
N
N#define __IEEE64_FRAC_PART(f) \
N   (__f64_bits_as_u64(f) & __IEEE64_BIT_MASK(__IEEE64_MANT_DIG-1))
X#define __IEEE64_FRAC_PART(f)    (__f64_bits_as_u64(f) & __IEEE64_BIT_MASK(__IEEE64_MANT_DIG-1))
N
N#define __IEEE64_FRAC_PART_IS_ZERO(f) (__IEEE64_FRAC_PART(f) == 0)
N
N#define __IEEE64_DISCARD_N_FRAC_BITS(v,n) \
N   (__u64_bits_as_f64(__f64_bits_as_u64(v) & ~__IEEE64_BIT_MASK(n)))
X#define __IEEE64_DISCARD_N_FRAC_BITS(v,n)    (__u64_bits_as_f64(__f64_bits_as_u64(v) & ~__IEEE64_BIT_MASK(n)))
N
N#define __IEEE64_DISCARD_EXP_AND_FRAC_PARTS(v) \
N   (__u64_bits_as_f64(__f64_bits_as_u64(v) & __IEEE64_SGN_TEST_MASK))
X#define __IEEE64_DISCARD_EXP_AND_FRAC_PARTS(v)    (__u64_bits_as_f64(__f64_bits_as_u64(v) & __IEEE64_SGN_TEST_MASK))
N
N#define __IEEE64_UNBIASED_EXP(f) \
N   (__IEEE64_BIASED_EXP(f) - __IEEE64_BIAS)
X#define __IEEE64_UNBIASED_EXP(f)    (__IEEE64_BIASED_EXP(f) - __IEEE64_BIAS)
N
N#define __IEEE64_BIASED_EXP_IS_ZERO(f) \
N   (__IEEE64_BIASED_EXP(f) == 0)
X#define __IEEE64_BIASED_EXP_IS_ZERO(f)    (__IEEE64_BIASED_EXP(f) == 0)
N
N#define __IEEE64_IS_ZERO(f) \
N   ((__f64_bits_as_u64(f) & ~__IEEE64_SGN_TEST_MASK)==0)
X#define __IEEE64_IS_ZERO(f)    ((__f64_bits_as_u64(f) & ~__IEEE64_SGN_TEST_MASK)==0)
N
N#define __FLOAT_UNBIASED_EXP(f)            (__IEEE32_UNBIASED_EXP(f))
N#define __FLOAT_FRAC_PART_IS_ZERO(f)       (__IEEE32_FRAC_PART_IS_ZERO(f))
N#define __FLOAT_BIASED_EXP_IS_ZERO(f)      (__IEEE32_BIASED_EXP_IS_ZERO(f))
N#define __FLOAT_BIASED_EXP_IS_MAX(f)       (__IEEE32_BIASED_EXP_IS_MAX(f))
N#define __FLOAT_SIGN_BIT_ZERO(f)           (__IEEE32_SIGN_BIT_ZERO(f))
N#define __FLOAT_MANT_DIG                   (__IEEE32_MANT_DIG)
N
N#if (defined(__TMS320C2000__)     && !defined(__TI_EABI__)) || \
N    (defined(__TMS320C28XX_CLA__) && !defined(__TI_EABI__)) || \
N    (defined(__MSP430__)          && !defined(__TI_EABI__))
X#if (0L     && !1L) ||     (0L && !1L) ||     (0L          && !1L)
S#define __DOUBLE_UNBIASED_EXP(f)            (__IEEE32_UNBIASED_EXP(f))
S#define __DOUBLE_FRAC_PART_IS_ZERO(f)       (__IEEE32_FRAC_PART_IS_ZERO(f))
S#define __DOUBLE_BIASED_EXP_IS_ZERO(f)      (__IEEE32_BIASED_EXP_IS_ZERO(f))
S#define __DOUBLE_BIASED_EXP_IS_MAX(f)       (__IEEE32_BIASED_EXP_IS_MAX(f))
S#define __DOUBLE_SIGN_BIT_ZERO(f)           (__IEEE32_SIGN_BIT_ZERO(f))
S#define __DOUBLE_MANT_DIG                   (__IEEE32_MANT_DIG)
N#else
N#define __DOUBLE_UNBIASED_EXP(f)            (__IEEE64_UNBIASED_EXP(f))
N#define __DOUBLE_FRAC_PART_IS_ZERO(f)       (__IEEE64_FRAC_PART_IS_ZERO(f))
N#define __DOUBLE_BIASED_EXP_IS_ZERO(f)      (__IEEE64_BIASED_EXP_IS_ZERO(f))
N#define __DOUBLE_BIASED_EXP_IS_MAX(f)       (__IEEE64_BIASED_EXP_IS_MAX(f))
N#define __DOUBLE_SIGN_BIT_ZERO(f)           (__IEEE64_SIGN_BIT_ZERO(f))
N#define __DOUBLE_MANT_DIG                   (__IEEE64_MANT_DIG)
N#endif
N
N#if defined(__MSP430__) && !defined(__TI_EABI__)
X#if 0L && !1L
S#define __LDOUBLE_UNBIASED_EXP(f)            (__IEEE32_UNBIASED_EXP(f))
S#define __LDOUBLE_FRAC_PART_IS_ZERO(f)       (__IEEE32_FRAC_PART_IS_ZERO(f))
S#define __LDOUBLE_BIASED_EXP_IS_ZERO(f)      (__IEEE32_BIASED_EXP_IS_ZERO(f))
S#define __LDOUBLE_BIASED_EXP_IS_MAX(f)       (__IEEE32_BIASED_EXP_IS_MAX(f))
S#define __LDOUBLE_SIGN_BIT_ZERO(f)           (__IEEE32_SIGN_BIT_ZERO(f))
S#define __LDOUBLE_MANT_DIG                   (__IEEE32_MANT_DIG)
N#else
N#define __LDOUBLE_UNBIASED_EXP(f)            (__IEEE64_UNBIASED_EXP(f))
N#define __LDOUBLE_FRAC_PART_IS_ZERO(f)       (__IEEE64_FRAC_PART_IS_ZERO(f))
N#define __LDOUBLE_BIASED_EXP_IS_ZERO(f)      (__IEEE64_BIASED_EXP_IS_ZERO(f))
N#define __LDOUBLE_BIASED_EXP_IS_MAX(f)       (__IEEE64_BIASED_EXP_IS_MAX(f))
N#define __LDOUBLE_SIGN_BIT_ZERO(f)           (__IEEE64_SIGN_BIT_ZERO(f))
N#define __LDOUBLE_MANT_DIG                   (__IEEE64_MANT_DIG)
N#endif
N
N__BEGIN_DECLS
Xextern "C" {
N
N#if !defined(__TMS320C28XX_CLA__)
X#if !0L
N
N#if defined(__TMS320C6X__) || defined(__ARP32__) || defined(__PRU__)
X#if 0L || 0L || 0L
S/* c6xabi, arp32abi, and pruabi choose to put these functions in the
S   ABI, giving them names like __c6xabi_isfinite (see elfnames.h).
S   That's fine, but while GENERIC_MATH and FREEBSD_MATH share the same
S   names, we'll run into some conflict.  Avoid this issue by undoing
S   the elfnames.h aliases */
S#undef __isfinite
S#undef __isfinitef
S#undef __isfinitel
S#undef __isnan
S#undef __isnanf
S#undef __isnanl
S#undef __isnormal
S#undef __isnormalf
S#undef __isnormall
S#undef __isinf
S#undef __isinff
S#undef __isinfl
S#undef __fpclassify
S#undef __fpclassifyf
S#undef __fpclassifyl
N#endif /* __TMS320C6X__ || __ARP32__ || __PRU__ */
N
N#include <_ti_config.h>
N
N/* always inline these functions so that calls to them don't appear in
N   an object file and become part of the ABI. */
N
N_CODE_ACCESS _INLINE_DEFINITION int __isfinite(double d)
X inline int __isfinite(double d)
N{ return __DOUBLE_BIASED_EXP_IS_MAX(d) == 0; }
X{ return (((((unsigned int)(((((__uint64_t)_hi(d) << 32 | _lo(d)))) >> 48)) & 0x7ff0u) == 0x7ff0u)) == 0; }
N_CODE_ACCESS _INLINE_DEFINITION int __isfinitef(float f)
X inline int __isfinitef(float f)
N{ return __FLOAT_BIASED_EXP_IS_MAX(f) == 0; }
X{ return (((((unsigned int)((_ftoi(f)) >> 16)) & 0x7f80u) == 0x7f80u)) == 0; }
N_CODE_ACCESS _INLINE_DEFINITION int __isfinitel(long double e)
X inline int __isfinitel(long double e)
N{ return __LDOUBLE_BIASED_EXP_IS_MAX(e) == 0; }
X{ return (((((unsigned int)(((((__uint64_t)_hi(e) << 32 | _lo(e)))) >> 48)) & 0x7ff0u) == 0x7ff0u)) == 0; }
N
N_CODE_ACCESS _INLINE_DEFINITION int __isnan(double d)
X inline int __isnan(double d)
N{ return __DOUBLE_BIASED_EXP_IS_MAX(d) &&
X{ return (((((unsigned int)(((((__uint64_t)_hi(d) << 32 | _lo(d)))) >> 48)) & 0x7ff0u) == 0x7ff0u)) &&
N        (__DOUBLE_FRAC_PART_IS_ZERO(d) == 0); }
X        ((((((((__uint64_t)_hi(d) << 32 | _lo(d)))) & (((__uint64_t)(1) << (53-1)) - 1)) == 0)) == 0); }
N_CODE_ACCESS _INLINE_DEFINITION int __isnanf(float f)
X inline int __isnanf(float f)
N{ return __FLOAT_BIASED_EXP_IS_MAX(f) &&
X{ return (((((unsigned int)((_ftoi(f)) >> 16)) & 0x7f80u) == 0x7f80u)) &&
N        (__FLOAT_FRAC_PART_IS_ZERO(f) == 0); }
X        (((((_ftoi(f)) & (((__uint32_t)(1) << (24-1)) - 1)) == 0)) == 0); }
N_CODE_ACCESS _INLINE_DEFINITION int __isnanl(long double e)
X inline int __isnanl(long double e)
N{ return __LDOUBLE_BIASED_EXP_IS_MAX(e) &&
X{ return (((((unsigned int)(((((__uint64_t)_hi(e) << 32 | _lo(e)))) >> 48)) & 0x7ff0u) == 0x7ff0u)) &&
N        (__LDOUBLE_FRAC_PART_IS_ZERO(e) == 0); }
X        ((((((((__uint64_t)_hi(e) << 32 | _lo(e)))) & (((__uint64_t)(1) << (53-1)) - 1)) == 0)) == 0); }
N
N_CODE_ACCESS _INLINE_DEFINITION int __isnormal(double d)
X inline int __isnormal(double d)
N{ return (__DOUBLE_BIASED_EXP_IS_ZERO(d) == 0) &&
X{ return (((((((((__uint64_t)_hi(d) << 32 | _lo(d)))) >> (53-1)) & ((1024u * 2) - 1)) == 0)) == 0) &&
N         (__DOUBLE_BIASED_EXP_IS_MAX(d) == 0); }
X         ((((((unsigned int)(((((__uint64_t)_hi(d) << 32 | _lo(d)))) >> 48)) & 0x7ff0u) == 0x7ff0u)) == 0); }
N
N_CODE_ACCESS _INLINE_DEFINITION int __isnormalf(float f)
X inline int __isnormalf(float f)
N{ return (__FLOAT_BIASED_EXP_IS_ZERO(f) == 0) &&
X{ return ((((((unsigned int)((_ftoi(f)) >> (24-1))) & ((128u * 2) - 1)) == 0)) == 0) &&
N         (__FLOAT_BIASED_EXP_IS_MAX(f) == 0); }
X         ((((((unsigned int)((_ftoi(f)) >> 16)) & 0x7f80u) == 0x7f80u)) == 0); }
N
N_CODE_ACCESS _INLINE_DEFINITION int __isnormall(long double e)
X inline int __isnormall(long double e)
N{ return (__LDOUBLE_BIASED_EXP_IS_ZERO(e) == 0) &&
X{ return (((((((((__uint64_t)_hi(e) << 32 | _lo(e)))) >> (53-1)) & ((1024u * 2) - 1)) == 0)) == 0) &&
N         (__LDOUBLE_BIASED_EXP_IS_MAX(e) == 0); }
X         ((((((unsigned int)(((((__uint64_t)_hi(e) << 32 | _lo(e)))) >> 48)) & 0x7ff0u) == 0x7ff0u)) == 0); }
N
N_CODE_ACCESS _INLINE_DEFINITION int __signbit(double d)
X inline int __signbit(double d)
N{ return __DOUBLE_SIGN_BIT_ZERO(d) == 0; }
X{ return (((((((__uint64_t)_hi(d) << 32 | _lo(d)))) & ((__uint64_t)(1) << (64-1))) == 0)) == 0; }
N_CODE_ACCESS _INLINE_DEFINITION int __signbitf(float f)
X inline int __signbitf(float f)
N{ return __FLOAT_SIGN_BIT_ZERO(f) == 0; }
X{ return ((((_ftoi(f)) & ((__uint32_t)(1) << (32-1))) == 0)) == 0; }
N_CODE_ACCESS _INLINE_DEFINITION int __signbitl(long double e)
X inline int __signbitl(long double e)
N{ return __LDOUBLE_SIGN_BIT_ZERO(e) == 0; }
X{ return (((((((__uint64_t)_hi(e) << 32 | _lo(e)))) & ((__uint64_t)(1) << (64-1))) == 0)) == 0; }
N
N/* FreeBSD lib/libc/gen/isinf.c says "These routines belong in libm,
N   but they must remain in libc for binary compat until we can bump
N   libm's major version number" */
N
N_CODE_ACCESS _INLINE_DEFINITION int __isinff(float f)
X inline int __isinff(float f)
N{ return __FLOAT_BIASED_EXP_IS_MAX(f) && __FLOAT_FRAC_PART_IS_ZERO(f); }
X{ return (((((unsigned int)((_ftoi(f)) >> 16)) & 0x7f80u) == 0x7f80u)) && ((((_ftoi(f)) & (((__uint32_t)(1) << (24-1)) - 1)) == 0)); }
N_CODE_ACCESS _INLINE_DEFINITION int __isinf (double d)
X inline int __isinf (double d)
N{ return __DOUBLE_BIASED_EXP_IS_MAX(d) && __DOUBLE_FRAC_PART_IS_ZERO(d); }
X{ return (((((unsigned int)(((((__uint64_t)_hi(d) << 32 | _lo(d)))) >> 48)) & 0x7ff0u) == 0x7ff0u)) && (((((((__uint64_t)_hi(d) << 32 | _lo(d)))) & (((__uint64_t)(1) << (53-1)) - 1)) == 0)); }
N_CODE_ACCESS _INLINE_DEFINITION int __isinfl(long double e)
X inline int __isinfl(long double e)
N{ return __LDOUBLE_BIASED_EXP_IS_MAX(e) && __LDOUBLE_FRAC_PART_IS_ZERO(e); }
X{ return (((((unsigned int)(((((__uint64_t)_hi(e) << 32 | _lo(e)))) >> 48)) & 0x7ff0u) == 0x7ff0u)) && (((((((__uint64_t)_hi(e) << 32 | _lo(e)))) & (((__uint64_t)(1) << (53-1)) - 1)) == 0)); }
N
N/* Symbolic constants to classify floating point numbers. */
N#if defined(__ARM_ARCH) || defined(__MSP430__) || defined(__TMS320C2000__)
X#if 1L || 0L || 0L
N#define	__FP_INFINITE	1
N#define	__FP_NAN	2
N#define	__FP_NORMAL	(-1)
N#define	__FP_SUBNORMAL	(-2)
N#define	__FP_ZERO	0
N#elif defined(__TMS320C6X__) || defined(__ARP32__) || defined(__PRU__) || defined(__C7000__)
S#define	__FP_INFINITE	1
S#define	__FP_NAN	2
S#define	__FP_NORMAL	3
S#define	__FP_SUBNORMAL	5
S#define	__FP_ZERO	4
N#endif
N
N_CODE_ACCESS _INLINE_DEFINITION int __fpclassifyf(float f)
X inline int __fpclassifyf(float f)
N{
N    if (__FLOAT_BIASED_EXP_IS_MAX(f))
X    if ((((((unsigned int)((_ftoi(f)) >> 16)) & 0x7f80u) == 0x7f80u)))
N    {
N        if (__FLOAT_FRAC_PART_IS_ZERO(f))
X        if (((((_ftoi(f)) & (((__uint32_t)(1) << (24-1)) - 1)) == 0)))
N            return __FP_INFINITE;
X            return 1;
N        else return __FP_NAN;
X        else return 2;
N    }
N    if (__FLOAT_BIASED_EXP_IS_ZERO(f))
X    if ((((((unsigned int)((_ftoi(f)) >> (24-1))) & ((128u * 2) - 1)) == 0)))
N    {
N        if (__FLOAT_FRAC_PART_IS_ZERO(f))
X        if (((((_ftoi(f)) & (((__uint32_t)(1) << (24-1)) - 1)) == 0)))
N            return __FP_ZERO;
X            return 0;
N        else return __FP_SUBNORMAL;
X        else return (-2);
N    }
N    return __FP_NORMAL;
X    return (-1);
N}
N
N_CODE_ACCESS _INLINE_DEFINITION int __fpclassify (double d)
X inline int __fpclassify (double d)
N{
N    if (__DOUBLE_BIASED_EXP_IS_MAX(d))
X    if ((((((unsigned int)(((((__uint64_t)_hi(d) << 32 | _lo(d)))) >> 48)) & 0x7ff0u) == 0x7ff0u)))
N    {
N        if (__DOUBLE_FRAC_PART_IS_ZERO(d))
X        if ((((((((__uint64_t)_hi(d) << 32 | _lo(d)))) & (((__uint64_t)(1) << (53-1)) - 1)) == 0)))
N            return __FP_INFINITE;
X            return 1;
N        else return __FP_NAN;
X        else return 2;
N    }
N    if (__DOUBLE_BIASED_EXP_IS_ZERO(d))
X    if (((((((((__uint64_t)_hi(d) << 32 | _lo(d)))) >> (53-1)) & ((1024u * 2) - 1)) == 0)))
N    {
N        if (__DOUBLE_FRAC_PART_IS_ZERO(d))
X        if ((((((((__uint64_t)_hi(d) << 32 | _lo(d)))) & (((__uint64_t)(1) << (53-1)) - 1)) == 0)))
N            return __FP_ZERO;
X            return 0;
N        else return __FP_SUBNORMAL;
X        else return (-2);
N    }
N    return __FP_NORMAL;
X    return (-1);
N}
N
N_CODE_ACCESS _INLINE_DEFINITION int __fpclassifyl(long double e)
X inline int __fpclassifyl(long double e)
N{
N    if (__LDOUBLE_BIASED_EXP_IS_MAX(e))
X    if ((((((unsigned int)(((((__uint64_t)_hi(e) << 32 | _lo(e)))) >> 48)) & 0x7ff0u) == 0x7ff0u)))
N    {
N        if (__LDOUBLE_FRAC_PART_IS_ZERO(e))
X        if ((((((((__uint64_t)_hi(e) << 32 | _lo(e)))) & (((__uint64_t)(1) << (53-1)) - 1)) == 0)))
N            return __FP_INFINITE;
X            return 1;
N        else return __FP_NAN;
X        else return 2;
N    }
N    if (__LDOUBLE_BIASED_EXP_IS_ZERO(e))
X    if (((((((((__uint64_t)_hi(e) << 32 | _lo(e)))) >> (53-1)) & ((1024u * 2) - 1)) == 0)))
N    {
N        if (__LDOUBLE_FRAC_PART_IS_ZERO(e))
X        if ((((((((__uint64_t)_hi(e) << 32 | _lo(e)))) & (((__uint64_t)(1) << (53-1)) - 1)) == 0)))
N            return __FP_ZERO;
X            return 0;
N        else return __FP_SUBNORMAL;
X        else return (-2);
N    }
N    return __FP_NORMAL;
X    return (-1);
N}
N
N#endif /* !defined(__TMS320C28XX_CLA__) */
N
N__END_DECLS
X}
N
N/*
N * Relevant target macros indicating hardware float support
N *
N * all
N * 	__TI_STRICT_FP_MODE__
N * ARM
N *      __ARM_FP
N * C2000
N *      __TMS320C28XX_FPU32__
N *      __TMS320C28XX_FPU64__
N *      __TMS320C28XX_TMU__	adds div, sqrt, sin, cos, atan, atan2
N * C6000
N *      _TMS320C6700		indicates C67x or later
N */
N
N#if ((defined(__ARM_ARCH) &&                    \
N      defined(__ARM_FP))  ||          \
N     defined(__TMS320C28XX_FPU32__) ||          \
N     defined(__TMS320C28XX_FPU64__) ||          \
N     defined(_TMS320C6700))
X#if ((1L &&                          1L)  ||               0L ||               0L ||               0L)
N#define __TI_HAS_F32_HARDWARE 1
N#else
S#define __TI_HAS_F32_HARDWARE 0
N#endif
N
N#if ((defined(__ARM_FP) && __ARM_FP & 0x8) || \
N     defined(__TMS320C28XX_FPU64__)        || \
N     defined(_TMS320C6700))
X#if ((1L && 6 & 0x8) ||      0L        ||      0L)
S#define __TI_HAS_F64_HARDWARE 1
N#else
N#define __TI_HAS_F64_HARDWARE 0
N#endif
N
N#if !defined(__clang__) && defined(__ARM_FP)
X#if !0L && 1L
N#define __TI_HAS_BUILTIN_SQRT32 1
N#else
S#define __TI_HAS_BUILTIN_SQRT32 0
N#endif
N
N#define __ti_builtin_sqrt32(x) __sqrtf(x)
N
N#if !defined(__clang__) && defined(__ARM_FP) && __ARM_FP & 0x8
X#if !0L && 1L && 6 & 0x8
S#define __TI_HAS_BUILTIN_SQRT64 1
N#else
N#define __TI_HAS_BUILTIN_SQRT64 0
N#endif
N
N#define __ti_builtin_sqrt64(x) __sqrt(x)
N
N#pragma diag_pop
N
N#endif /* _DEFS_H_ */
L 33 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/math.h" 2
N
N/*
N * ANSI/POSIX
N */
N
N#if defined(__cplusplus) && \
N   defined(_AEABI_PORTABILITY_LEVEL) && _AEABI_PORTABILITY_LEVEL != 0
X#if 1L &&    0L && _AEABI_PORTABILITY_LEVEL != 0
S  extern "C" {
S    extern const double      __aeabi_HUGE_VAL;
S    extern const long double __aeabi_HUGE_VALL;
S    extern const float       __aeabi_HUGE_VALF;
S    extern const float       __aeabi_INFINITY;
S    extern const float       __aeabi_NAN;
S  }
S#define	HUGE_VAL	__aeabi_HUGE_VAL
S#define	HUGE_VALF	__aeabi_HUGE_VALF
S#define	HUGE_VALL	__aeabi_HUGE_VALL
S#define	INFINITY	__aeabi_INFINITY
S#define	NAN		__aeabi_NAN
S#elif defined(__clang__)
X#elif 0L
S#if __has_builtin(__builtin_inf)
S#define	HUGE_VAL	__builtin_inf()
S#define	HUGE_VALF	__builtin_inff()
S#define	HUGE_VALL	__builtin_infl()
S#define	INFINITY	__builtin_inff()
S#define	NAN		__builtin_nanf("")
S#else
S#error "__builtin_inf is not available"
S#endif
N#else
N#define	HUGE_VAL	((double)__INFINITY__)
N#define	HUGE_VALF	(__INFINITY__)
N#define	HUGE_VALL	((long double)__INFINITY__)
N#define	INFINITY	(__INFINITY__)
N#define	NAN		(__NAN__)
N#endif
N
N#define	FP_ILOGB0	(-__INT_MAX)
N#define	FP_ILOGBNAN	(__INT_MAX)
N
N#define	MATH_ERRNO	1
N#define	MATH_ERREXCEPT	2
N#define	math_errhandling (MATH_ERRNO)
N
N#if defined(__ARM_FP) && defined(__ARM_FEATURE_FMA)
X#if 1L && 1L
N#if __ARM_FP & 0x4
X#if 6 & 0x4
N#define	FP_FAST_FMAF	1
N#endif
N
N#if __ARM_FP & 0x8
X#if 6 & 0x8
S#define	FP_FAST_FMA	1
S#define	FP_FAST_FMAL	1
N#endif
N#endif
N
N/* Symbolic constants to classify floating point numbers. */
N#define	FP_INFINITE	(__FP_INFINITE)
N#define	FP_NAN		(__FP_NAN)
N#define	FP_NORMAL	(__FP_NORMAL)
N#define	FP_SUBNORMAL	(__FP_SUBNORMAL)
N#define	FP_ZERO		(__FP_ZERO)
N
N
N#if (__STDC_VERSION__ >= 201112L)
S#define	__fp_type_select(x, f, d, ld) _Generic((x),			\
S    float: f(x),							\
S    double: d(x),							\
S    long double: ld(x),							\
S    volatile float: f(x),						\
S    volatile double: d(x),						\
S    volatile long double: ld(x),					\
S    volatile const float: f(x),						\
S    volatile const double: d(x),					\
S    volatile const long double: ld(x),					\
S    const float: f(x),							\
S    const double: d(x),							\
S    const long double: ld(x))
X#define	__fp_type_select(x, f, d, ld) _Generic((x),			    float: f(x),							    double: d(x),							    long double: ld(x),							    volatile float: f(x),						    volatile double: d(x),						    volatile long double: ld(x),					    volatile const float: f(x),						    volatile const double: d(x),					    volatile const long double: ld(x),					    const float: f(x),							    const double: d(x),							    const long double: ld(x))
S#elif (__STDC_VERSION__ >= 199901L) && defined(__EDG_VERSION__)
X#elif (__STDC_VERSION__ >= 199901L) && 1L
S#define	__fp_type_select(x, f, d, ld) __generic((x),,, d, f, ld,,,)(x)
N#else
N#define	 __fp_type_select(x, f, d, ld)					\
N    ((sizeof(x) == sizeof(float)) ? (f)(x)				\
N    : (sizeof(x) == sizeof(double)) ? (d)(x)				\
N    : (ld)(x))
X#define	 __fp_type_select(x, f, d, ld)					    ((sizeof(x) == sizeof(float)) ? (f)(x)				    : (sizeof(x) == sizeof(double)) ? (d)(x)				    : (ld)(x))
N#endif
N
N#define	fpclassify(x) (__fp_type_select((x), __fpclassifyf, __fpclassify, __fpclassifyl))
N#define	isfinite(x) (__fp_type_select((x), __isfinitef, __isfinite, __isfinitel))
N#define	isinf(x) (__fp_type_select((x), __isinff, __isinf, __isinfl))
N#define	isnan(x) (__fp_type_select((x), __isnanf, __isnan, __isnanl))
N#define	isnormal(x) (__fp_type_select((x), __isnormalf, __isnormal, __isnormall))
N
N#ifdef __MATH_BUILTIN_RELOPS
S#define	isgreater(x, y)		__builtin_isgreater((x), (y))
S#define	isgreaterequal(x, y)	__builtin_isgreaterequal((x), (y))
S#define	isless(x, y)		__builtin_isless((x), (y))
S#define	islessequal(x, y)	__builtin_islessequal((x), (y))
S#define	islessgreater(x, y)	__builtin_islessgreater((x), (y))
S#define	isunordered(x, y)	__builtin_isunordered((x), (y))
N#else
N#define	isgreater(x, y)		(!isunordered((x), (y)) && (x) > (y))
N#define	isgreaterequal(x, y)	(!isunordered((x), (y)) && (x) >= (y))
N#define	isless(x, y)		(!isunordered((x), (y)) && (x) < (y))
N#define	islessequal(x, y)	(!isunordered((x), (y)) && (x) <= (y))
N#define	islessgreater(x, y)	(!isunordered((x), (y)) && \
N					((x) > (y) || (y) > (x)))
X#define	islessgreater(x, y)	(!isunordered((x), (y)) && 					((x) > (y) || (y) > (x)))
N#define	isunordered(x, y)	(isnan(x) || isnan(y))
N#endif /* __MATH_BUILTIN_RELOPS */
N
N#define	signbit(x) (__fp_type_select((x), __signbitf, __signbit, __signbitl))
N
N/*
N * XOPEN/SVID
N */
N#ifdef __BSD_VISIBLE
N#define	M_E		2.7182818284590452354	/* e */
N#define	M_LOG2E		1.4426950408889634074	/* log 2e */
N#define	M_LOG10E	0.43429448190325182765	/* log 10e */
N#define	M_LN2		0.69314718055994530942	/* log e2 */
N#define	M_LN10		2.30258509299404568402	/* log e10 */
N#define	M_PI		3.14159265358979323846	/* pi */
N#define	M_PI_2		1.57079632679489661923	/* pi/2 */
N#define	M_PI_4		0.78539816339744830962	/* pi/4 */
N#define	M_1_PI		0.31830988618379067154	/* 1/pi */
N#define	M_2_PI		0.63661977236758134308	/* 2/pi */
N#define	M_2_SQRTPI	1.12837916709551257390	/* 2/sqrt(pi) */
N#define	M_SQRT2		1.41421356237309504880	/* sqrt(2) */
N#define	M_SQRT1_2	0.70710678118654752440	/* 1/sqrt(2) */
N#endif /* __BSD_VISIBLE */
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
N/*---------------------------------------------------------------------------*/
N/* If --fp_mode=relaxed is used and VFP is enabled, use the hardware square  */
N/* root directly instead of calling the sqrtx routine. This will not set     */
N/* errno if the argument is negative.                                        */
N/*                                                                           */
N/* This is done by defining sqrt to _relaxed_sqrt to allow other translation */
N/* units to use the normal sqrt routine under strict mode.                   */
N/*---------------------------------------------------------------------------*/
N#if !__TI_STRICT_FP_MODE__
X#if !1
S#if __TI_HAS_BUILTIN_SQRT32
S#pragma CHECK_MISRA("-19.4") /* macro defined to be an identifier is OK */
S#pragma CHECK_MISRA("-8.1") /* function definition with no prototype visible */
S#pragma CHECK_MISRA("-8.5") /* function definitions required */
S#pragma CHECK_MISRA("-8.11") /* non-static function definition OK */
S
S#pragma diag_suppress 1558 /* --float_operations_allowed checks */
S
S#define sqrtf __relaxed_sqrtf
S__inline float __relaxed_sqrtf(float x)
S{
S    return __sqrtf(x);
S}
S#endif
S
S/*---------------------------------------------------------------------------*/
S/* The FPv4SP supported on Cortex-M4 does not have double precision hardware */
S/* so avoid using the intrinsic.                                             */
S/*---------------------------------------------------------------------------*/
S#if __TI_HAS_BUILTIN_SQRT64
S#define sqrt  __relaxed_sqrt
S__inline double __relaxed_sqrt(double x)
S{
S    return __sqrt(x);
S}
S
S#define sqrtl __relaxed_sqrtl
S__inline long double __relaxed_sqrtl(long double x)
S{
S    return __sqrt(x);
S}
S#endif
N#endif
N
N/*---------------------------------------------------------------------------*/
N/* TMU SUPPORT AND RELAXED MODE: USE INSTRINSICS.                            */
N/*---------------------------------------------------------------------------*/
N#if defined(__TMS320C28XX_TMU__)  && !__TI_STRICT_FP_MODE__
X#if 0L  && !1
S#pragma CHECK_MISRA("-19.4") /* macro defined to be an identifier is OK */
S#pragma CHECK_MISRA("-8.1") /* function definition with no prototype visible */
S#pragma CHECK_MISRA("-8.5") /* function definitions required */
S#pragma CHECK_MISRA("-8.11") /* non-static function definition OK */
S#pragma CHECK_MISRA("-10.1") /* use implicit casts */
S
S#pragma diag_suppress 1558 /* --float_operations_allowed checks */
S
S/* Float cases */
S#define sqrtf  __relaxed_sqrtf
S__inline float __relaxed_sqrtf(float x)
S{
S    return __sqrtf(x);
S}
S#define sinf   __relaxed_sinf
S__inline float __relaxed_sinf(float x)
S{
S    return __sin(x);
S}
S#define cosf   __relaxed_cosf
S__inline float __relaxed_cosf(float x)
S{
S    return __cos(x);
S}
S#define atanf  __relaxed_atanf
S__inline float __relaxed_atanf(float x)
S{
S  return __atan2(x, 1.0f);
S}
S#define atan2f __relaxed_atan2f
S__inline float __relaxed_atan2f(float y, float x)
S{
S  return __atan2(y,x);
S}
S
S#if defined(__TMS320C28XX_TMU1__)
S#define log2f __relaxed_log2f
S__inline float __relaxed_log2f(float x)
S{
S    return __log2(x);
S}
S#define exp2f __relaxed_exp2f
S__inline float __relaxed_exp2f(float x)
S{
S    return (1.0f / __iexp2(x));
S}
S#define expf __relaxed_expf
S__inline float __relaxed_expf(float x)
S{
S  float log2ofetimesx = 1.44269 * x;
S  return exp2f(log2ofetimesx);
S}
S#define logf __relaxed_logf
S__inline float __relaxed_logf(float x)
S{
S  const float oneoverlog2ofe = 0.693147;
S  return (__log2(x) * oneoverlog2ofe);
S}
S#define powf __relaxed_powf
S__inline float __relaxed_powf(float x, float y)
S{
S  float log2ofx = __log2(x);
S  float log2ofxtimesy = log2ofx * y;
S
S  float exp2foflog2ofxtimesy = exp2f(log2ofxtimesy);
S
S  return log2ofxtimesy > 0 ? exp2foflog2ofxtimesy : 1.0f / exp2foflog2ofxtimesy;
S}
S#endif
S
S/* Double cases */
S#ifndef __TI_EABI__
S#define sqrt  __relaxed_sqrt
S__inline double __relaxed_sqrt(double x)
S{
S    return __sqrt(x);
S}
S#define sin   __relaxed_sin
S__inline double __relaxed_sin(double x)
S{
S    return __sin(x);
S}
S#define cos   __relaxed_cos
S__inline double __relaxed_cos(double x)
S{
S    return __cos(x);
S}
S#define atan  __relaxed_atan
S__inline double __relaxed_atan(double x)
S{
S  return __atan2(x, 1.0);
S}
S#define atan2 __relaxed_atan2
S__inline double __relaxed_atan2(double y, double x)
S{
S  return __atan2(y,x);
S}
S
S#endif
N#endif /* defined(__TMS320C28XX_TMU__)  && !__TI_STRICT_FP_MODE__ */
N
N/* Disable double_t and float_t for C28x because of Motorware (AY 2015) */
N#ifndef __TMS320C28XX__
N#define __TI_HAS_FLOAT_DBL_T 1
N/* These typedefs depend on the value of FLT_EVAL_METHOD */
Ntypedef	double	double_t;
Ntypedef	float	float_t;
N#endif
N
N_CODE_ACCESS double      acos(double x);
X double      acos(double x);
N_CODE_ACCESS float       acosf(float x);
X float       acosf(float x);
N_CODE_ACCESS long double acosl(long double x);
X long double acosl(long double x);
N_CODE_ACCESS double      asin(double x);
X double      asin(double x);
N_CODE_ACCESS float       asinf(float x);
X float       asinf(float x);
N_CODE_ACCESS long double asinl(long double x);
X long double asinl(long double x);
N_CODE_ACCESS double      atan(double x);
X double      atan(double x);
N_CODE_ACCESS float       atanf(float x);
X float       atanf(float x);
N_CODE_ACCESS long double atanl(long double x);
X long double atanl(long double x);
N_CODE_ACCESS double      atan2(double y, double x);
X double      atan2(double y, double x);
N_CODE_ACCESS float       atan2f(float y, float x);
X float       atan2f(float y, float x);
N_CODE_ACCESS long double atan2l(long double y, long double x);
X long double atan2l(long double y, long double x);
N_CODE_ACCESS double      cos(double x);
X double      cos(double x);
N_CODE_ACCESS float       cosf(float x);
X float       cosf(float x);
N_CODE_ACCESS long double cosl(long double x);
X long double cosl(long double x);
N_CODE_ACCESS double      sin(double x);
X double      sin(double x);
N_CODE_ACCESS float       sinf(float x);
X float       sinf(float x);
N_CODE_ACCESS long double sinl(long double x);
X long double sinl(long double x);
N_CODE_ACCESS double      tan(double x);
X double      tan(double x);
N_CODE_ACCESS float       tanf(float x);
X float       tanf(float x);
N_CODE_ACCESS long double tanl(long double x);
X long double tanl(long double x);
N_CODE_ACCESS double      acosh(double x);
X double      acosh(double x);
N_CODE_ACCESS float       acoshf(float x);
X float       acoshf(float x);
N_CODE_ACCESS long double acoshl(long double x);
X long double acoshl(long double x);
N_CODE_ACCESS double      asinh(double x);
X double      asinh(double x);
N_CODE_ACCESS float       asinhf(float x);
X float       asinhf(float x);
N_CODE_ACCESS long double asinhl(long double x);
X long double asinhl(long double x);
N_CODE_ACCESS double      atanh(double x);
X double      atanh(double x);
N_CODE_ACCESS float       atanhf(float x);
X float       atanhf(float x);
N_CODE_ACCESS long double atanhl(long double x);
X long double atanhl(long double x);
N_CODE_ACCESS double      cosh(double x);
X double      cosh(double x);
N_CODE_ACCESS float       coshf(float x);
X float       coshf(float x);
N_CODE_ACCESS long double coshl(long double x);
X long double coshl(long double x);
N_CODE_ACCESS double      sinh(double x);
X double      sinh(double x);
N_CODE_ACCESS float       sinhf(float x);
X float       sinhf(float x);
N_CODE_ACCESS long double sinhl(long double x);
X long double sinhl(long double x);
N_CODE_ACCESS double      tanh(double x);
X double      tanh(double x);
N_CODE_ACCESS float       tanhf(float x);
X float       tanhf(float x);
N_CODE_ACCESS long double tanhl(long double x);
X long double tanhl(long double x);
N_CODE_ACCESS double      exp(double x);
X double      exp(double x);
N_CODE_ACCESS float       expf(float x);
X float       expf(float x);
N_CODE_ACCESS long double expl(long double x);
X long double expl(long double x);
N_CODE_ACCESS double      exp2(double x);
X double      exp2(double x);
N_CODE_ACCESS float       exp2f(float x);
X float       exp2f(float x);
N_CODE_ACCESS long double exp2l(long double x);
X long double exp2l(long double x);
N_CODE_ACCESS double      expm1(double x);
X double      expm1(double x);
N_CODE_ACCESS float       expm1f(float x);
X float       expm1f(float x);
N_CODE_ACCESS long double expm1l(long double x);
X long double expm1l(long double x);
N_CODE_ACCESS double      frexp(double val, int *e);
X double      frexp(double val, int *e);
N_CODE_ACCESS float       frexpf(float val, int *e);
X float       frexpf(float val, int *e);
N_CODE_ACCESS long double frexpl(long double val, int *e);
X long double frexpl(long double val, int *e);
N_CODE_ACCESS int         ilogb(double x);
X int         ilogb(double x);
N_CODE_ACCESS int         ilogbf(float x);
X int         ilogbf(float x);
N_CODE_ACCESS int         ilogbl(long double x);
X int         ilogbl(long double x);
N_CODE_ACCESS double      ldexp(double x, int e);
X double      ldexp(double x, int e);
N_CODE_ACCESS float       ldexpf(float x, int e);
X float       ldexpf(float x, int e);
N_CODE_ACCESS long double ldexpl(long double x, int e);
X long double ldexpl(long double x, int e);
N_CODE_ACCESS double      log(double x);
X double      log(double x);
N_CODE_ACCESS float       logf(float x);
X float       logf(float x);
N_CODE_ACCESS long double logl(long double x);
X long double logl(long double x);
N_CODE_ACCESS double      log10(double x);
X double      log10(double x);
N_CODE_ACCESS float       log10f(float x);
X float       log10f(float x);
N_CODE_ACCESS long double log10l(long double x);
X long double log10l(long double x);
N_CODE_ACCESS double      log1p(double x);
X double      log1p(double x);
N_CODE_ACCESS float       log1pf(float x);
X float       log1pf(float x);
N_CODE_ACCESS long double log1pl(long double x);
X long double log1pl(long double x);
N_CODE_ACCESS double      log2(double x);
X double      log2(double x);
N_CODE_ACCESS float       log2f(float x);
X float       log2f(float x);
N_CODE_ACCESS long double log2l(long double x);
X long double log2l(long double x);
N_CODE_ACCESS double      logb(double x);
X double      logb(double x);
N_CODE_ACCESS float       logbf(float x);
X float       logbf(float x);
N_CODE_ACCESS long double logbl(long double x);
X long double logbl(long double x);
N_CODE_ACCESS double      modf(double val, double *iptr);
X double      modf(double val, double *iptr);
N_CODE_ACCESS float       modff(float val, float *iptr);
X float       modff(float val, float *iptr);
N_CODE_ACCESS long double modfl(long double val, long double *iptr);
X long double modfl(long double val, long double *iptr);
N_CODE_ACCESS double      scalbn(double x, int n);
X double      scalbn(double x, int n);
N_CODE_ACCESS float       scalbnf(float x, int n);
X float       scalbnf(float x, int n);
N_CODE_ACCESS long double scalbnl(long double x, int n);
X long double scalbnl(long double x, int n);
N_CODE_ACCESS double      scalbln(double x, long n);
X double      scalbln(double x, long n);
N_CODE_ACCESS float       scalblnf(float x, long n);
X float       scalblnf(float x, long n);
N_CODE_ACCESS long double scalblnl(long double x, long n);
X long double scalblnl(long double x, long n);
N_CODE_ACCESS double      cbrt(double x);
X double      cbrt(double x);
N_CODE_ACCESS float       cbrtf(float x);
X float       cbrtf(float x);
N_CODE_ACCESS long double cbrtl(long double x);
X long double cbrtl(long double x);
N_CODE_ACCESS double      fabs(double x);
X double      fabs(double x);
N_CODE_ACCESS float       fabsf(float x);
X float       fabsf(float x);
N_CODE_ACCESS long double fabsl(long double x);
X long double fabsl(long double x);
N_CODE_ACCESS double      hypot(double x, double y);
X double      hypot(double x, double y);
N_CODE_ACCESS float       hypotf(float x, float y);
X float       hypotf(float x, float y);
N_CODE_ACCESS long double hypotl(long double x, long double y);
X long double hypotl(long double x, long double y);
N_CODE_ACCESS double      pow(double x, double y);
X double      pow(double x, double y);
N_CODE_ACCESS float       powf(float x, float y);
X float       powf(float x, float y);
N_CODE_ACCESS long double powl(long double x, long double y);
X long double powl(long double x, long double y);
N_CODE_ACCESS double      sqrt(double x);
X double      sqrt(double x);
N_CODE_ACCESS float       sqrtf(float x);
X float       sqrtf(float x);
N_CODE_ACCESS long double sqrtl(long double x);
X long double sqrtl(long double x);
N_CODE_ACCESS double      erf(double x);
X double      erf(double x);
N_CODE_ACCESS float       erff(float x);
X float       erff(float x);
N_CODE_ACCESS long double erfl(long double x);
X long double erfl(long double x);
N_CODE_ACCESS double      erfc(double x);
X double      erfc(double x);
N_CODE_ACCESS float       erfcf(float x);
X float       erfcf(float x);
N_CODE_ACCESS long double erfcl(long double x);
X long double erfcl(long double x);
N_CODE_ACCESS double      lgamma(double x);
X double      lgamma(double x);
N_CODE_ACCESS float       lgammaf(float x);
X float       lgammaf(float x);
N_CODE_ACCESS long double lgammal(long double x);
X long double lgammal(long double x);
N_CODE_ACCESS double      tgamma(double x);
X double      tgamma(double x);
N_CODE_ACCESS float       tgammaf(float x);
X float       tgammaf(float x);
N_CODE_ACCESS long double tgammal(long double x);
X long double tgammal(long double x);
N_CODE_ACCESS double      ceil(double x);
X double      ceil(double x);
N_CODE_ACCESS float       ceilf(float x);
X float       ceilf(float x);
N_CODE_ACCESS long double ceill(long double x);
X long double ceill(long double x);
N_CODE_ACCESS double      floor(double x);
X double      floor(double x);
N_CODE_ACCESS float       floorf(float x);
X float       floorf(float x);
N_CODE_ACCESS long double floorl(long double x);
X long double floorl(long double x);
N_CODE_ACCESS double      nearbyint(double x);
X double      nearbyint(double x);
N_CODE_ACCESS float       nearbyintf(float x);
X float       nearbyintf(float x);
N_CODE_ACCESS long double nearbyintl(long double x);
X long double nearbyintl(long double x);
N_CODE_ACCESS double      rint(double x);
X double      rint(double x);
N_CODE_ACCESS float       rintf(float x);
X float       rintf(float x);
N_CODE_ACCESS long double rintl(long double x);
X long double rintl(long double x);
N_CODE_ACCESS long        lrint(double x);
X long        lrint(double x);
N_CODE_ACCESS long        lrintf(float x);
X long        lrintf(float x);
N_CODE_ACCESS long        lrintl(long double x);
X long        lrintl(long double x);
N_CODE_ACCESS long long   llrint(double x);
X long long   llrint(double x);
N_CODE_ACCESS long long   llrintf(float x);
X long long   llrintf(float x);
N_CODE_ACCESS long long   llrintl(long double x);
X long long   llrintl(long double x);
N_CODE_ACCESS double      round(double x);
X double      round(double x);
N_CODE_ACCESS float       roundf(float x);
X float       roundf(float x);
N_CODE_ACCESS long double roundl(long double x);
X long double roundl(long double x);
N_CODE_ACCESS long        lround(double x);
X long        lround(double x);
N_CODE_ACCESS long        lroundf(float x);
X long        lroundf(float x);
N_CODE_ACCESS long        lroundl(long double x);
X long        lroundl(long double x);
N_CODE_ACCESS long long   llround(double x);
X long long   llround(double x);
N_CODE_ACCESS long long   llroundf(float x);
X long long   llroundf(float x);
N_CODE_ACCESS long long   llroundl(long double x);
X long long   llroundl(long double x);
N_CODE_ACCESS double      trunc(double x);
X double      trunc(double x);
N_CODE_ACCESS float       truncf(float x);
X float       truncf(float x);
N_CODE_ACCESS long double truncl(long double x);
X long double truncl(long double x);
N_CODE_ACCESS double      fmod(double x, double y);
X double      fmod(double x, double y);
N_CODE_ACCESS float       fmodf(float x, float y);
X float       fmodf(float x, float y);
N_CODE_ACCESS long double fmodl(long double x, long double y);
X long double fmodl(long double x, long double y);
N_CODE_ACCESS double      remainder(double x, double y);
X double      remainder(double x, double y);
N_CODE_ACCESS float       remainderf(float x, float y);
X float       remainderf(float x, float y);
N_CODE_ACCESS long double remainderl(long double x, long double y);
X long double remainderl(long double x, long double y);
N_CODE_ACCESS double      remquo(double x, double y, int *quo);
X double      remquo(double x, double y, int *quo);
N_CODE_ACCESS float       remquof(float x, float y, int *quo);
X float       remquof(float x, float y, int *quo);
N_CODE_ACCESS long double remquol(long double x, long double y, int *quo);
X long double remquol(long double x, long double y, int *quo);
N_CODE_ACCESS double      copysign(double x, double y);
X double      copysign(double x, double y);
N_CODE_ACCESS float       copysignf(float x, float y);
X float       copysignf(float x, float y);
N_CODE_ACCESS long double copysignl(long double x, long double y);
X long double copysignl(long double x, long double y);
N_CODE_ACCESS double      nan(const char *tagp);
X double      nan(const char *tagp);
N_CODE_ACCESS float       nanf(const char *tagp);
X float       nanf(const char *tagp);
N_CODE_ACCESS long double nanl(const char *tagp);
X long double nanl(const char *tagp);
N_CODE_ACCESS double      nextafter(double x, double y);
X double      nextafter(double x, double y);
N_CODE_ACCESS float       nextafterf(float x, float y);
X float       nextafterf(float x, float y);
N_CODE_ACCESS long double nextafterl(long double x, long double y);
X long double nextafterl(long double x, long double y);
N_CODE_ACCESS double      nexttoward(double x, long double y);
X double      nexttoward(double x, long double y);
N_CODE_ACCESS float       nexttowardf(float x, long double y);
X float       nexttowardf(float x, long double y);
N_CODE_ACCESS long double nexttowardl(long double x, long double y);
X long double nexttowardl(long double x, long double y);
N_CODE_ACCESS double      fdim(double x, double y);
X double      fdim(double x, double y);
N_CODE_ACCESS float       fdimf(float x, float y);
X float       fdimf(float x, float y);
N_CODE_ACCESS long double fdiml(long double x, long double y);
X long double fdiml(long double x, long double y);
N_CODE_ACCESS double      fmax(double x, double y);
X double      fmax(double x, double y);
N_CODE_ACCESS float       fmaxf(float x, float y);
X float       fmaxf(float x, float y);
N_CODE_ACCESS long double fmaxl(long double x, long double y);
X long double fmaxl(long double x, long double y);
N_CODE_ACCESS double      fmin(double x, double y);
X double      fmin(double x, double y);
N_CODE_ACCESS float       fminf(float x, float y);
X float       fminf(float x, float y);
N_CODE_ACCESS long double fminl(long double x, long double y);
X long double fminl(long double x, long double y);
N_CODE_ACCESS double      fma(double x, double y, double z);
X double      fma(double x, double y, double z);
N_CODE_ACCESS float       fmaf(float x, float y, float z);
X float       fmaf(float x, float y, float z);
N_CODE_ACCESS long double fmal(long double x, long double y, long double z);
X long double fmal(long double x, long double y, long double z);
N
N#ifdef __cplusplus
N    }
N#endif
N
N#if defined(_AEABI_PORTABILITY_LEVEL) && _AEABI_PORTABILITY_LEVEL != 0 && \
N   !defined(_AEABI_PORTABLE)
X#if 0L && _AEABI_PORTABILITY_LEVEL != 0 &&    !0L
S#define _AEABI_PORTABLE
N#endif
N
N#pragma diag_pop
N
N#endif /* !_MATH_H_ */
L 302 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/math.h" 2
N
N#ifdef __cplusplus
N
N/* We support including .h headers inside 'extern "C"' contexts, so switch */
N/* back to C++ linkage before including these C++ headers. */
Nextern "C++" {
N
N#include <type_traits>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/type_traits" 1
N// -*- C++ -*-
N//===------------------------ type_traits ---------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is dual licensed under the MIT and the University of Illinois Open
N// Source Licenses. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP_TYPE_TRAITS
N#define _LIBCPP_TYPE_TRAITS
N
N/*
N    type_traits synopsis
N
Nnamespace std
N{
N
N    // helper class:
N    template <class T, T v> struct integral_constant;
N    typedef integral_constant<bool, true>  true_type;   // C++11
N    typedef integral_constant<bool, false> false_type;  // C++11
N    
N    template <bool B>                                   // C++14
N    using bool_constant = integral_constant<bool, B>;   // C++14
N    typedef bool_constant<true> true_type;              // C++14
N    typedef bool_constant<false> false_type;            // C++14
N
N    // helper traits
N    template <bool, class T = void> struct enable_if;
N    template <bool, class T, class F> struct conditional;
N
N    // Primary classification traits:
N    template <class T> struct is_void;
N    template <class T> struct is_null_pointer;  // C++14
N    template <class T> struct is_integral;
N    template <class T> struct is_floating_point;
N    template <class T> struct is_array;
N    template <class T> struct is_pointer;
N    template <class T> struct is_lvalue_reference;
N    template <class T> struct is_rvalue_reference;
N    template <class T> struct is_member_object_pointer;
N    template <class T> struct is_member_function_pointer;
N    template <class T> struct is_enum;
N    template <class T> struct is_union;
N    template <class T> struct is_class;
N    template <class T> struct is_function;
N
N    // Secondary classification traits:
N    template <class T> struct is_reference;
N    template <class T> struct is_arithmetic;
N    template <class T> struct is_fundamental;
N    template <class T> struct is_member_pointer;
N    template <class T> struct is_scalar;
N    template <class T> struct is_object;
N    template <class T> struct is_compound;
N
N    // Const-volatile properties and transformations:
N    template <class T> struct is_const;
N    template <class T> struct is_volatile;
N    template <class T> struct remove_const;
N    template <class T> struct remove_volatile;
N    template <class T> struct remove_cv;
N    template <class T> struct add_const;
N    template <class T> struct add_volatile;
N    template <class T> struct add_cv;
N
N    // Reference transformations:
N    template <class T> struct remove_reference;
N    template <class T> struct add_lvalue_reference;
N    template <class T> struct add_rvalue_reference;
N
N    // Pointer transformations:
N    template <class T> struct remove_pointer;
N    template <class T> struct add_pointer;
N
N    // Integral properties:
N    template <class T> struct is_signed;
N    template <class T> struct is_unsigned;
N    template <class T> struct make_signed;
N    template <class T> struct make_unsigned;
N
N    // Array properties and transformations:
N    template <class T> struct rank;
N    template <class T, unsigned I = 0> struct extent;
N    template <class T> struct remove_extent;
N    template <class T> struct remove_all_extents;
N
N    // Member introspection:
N    template <class T> struct is_pod;
N    template <class T> struct is_trivial;
N    template <class T> struct is_trivially_copyable;
N    template <class T> struct is_standard_layout;
N    template <class T> struct is_literal_type;
N    template <class T> struct is_empty;
N    template <class T> struct is_polymorphic;
N    template <class T> struct is_abstract;
N    template <class T> struct is_final; // C++14
N    template <class T> struct is_aggregate; // C++17
N
N    template <class T, class... Args> struct is_constructible;
N    template <class T>                struct is_default_constructible;
N    template <class T>                struct is_copy_constructible;
N    template <class T>                struct is_move_constructible;
N    template <class T, class U>       struct is_assignable;
N    template <class T>                struct is_copy_assignable;
N    template <class T>                struct is_move_assignable;
N    template <class T, class U>       struct is_swappable_with;       // C++17
N    template <class T>                struct is_swappable;            // C++17
N    template <class T>                struct is_destructible;
N
N    template <class T, class... Args> struct is_trivially_constructible;
N    template <class T>                struct is_trivially_default_constructible;
N    template <class T>                struct is_trivially_copy_constructible;
N    template <class T>                struct is_trivially_move_constructible;
N    template <class T, class U>       struct is_trivially_assignable;
N    template <class T>                struct is_trivially_copy_assignable;
N    template <class T>                struct is_trivially_move_assignable;
N    template <class T>                struct is_trivially_destructible;
N
N    template <class T, class... Args> struct is_nothrow_constructible;
N    template <class T>                struct is_nothrow_default_constructible;
N    template <class T>                struct is_nothrow_copy_constructible;
N    template <class T>                struct is_nothrow_move_constructible;
N    template <class T, class U>       struct is_nothrow_assignable;
N    template <class T>                struct is_nothrow_copy_assignable;
N    template <class T>                struct is_nothrow_move_assignable;
N    template <class T, class U>       struct is_nothrow_swappable_with; // C++17
N    template <class T>                struct is_nothrow_swappable;      // C++17
N    template <class T>                struct is_nothrow_destructible;
N
N    template <class T> struct has_virtual_destructor;
N
N    // Relationships between types:
N    template <class T, class U> struct is_same;
N    template <class Base, class Derived> struct is_base_of;
N    template <class From, class To> struct is_convertible;
N
N    template <class, class R = void> struct is_callable; // not defined
N    template <class Fn, class... ArgTypes, class R>
N      struct is_callable<Fn(ArgTypes...), R>;
N
N    template <class, class R = void> struct is_nothrow_callable; // not defined
N    template <class Fn, class... ArgTypes, class R>
N      struct is_nothrow_callable<Fn(ArgTypes...), R>;
N
N    // Alignment properties and transformations:
N    template <class T> struct alignment_of;
N    template <size_t Len, size_t Align = most_stringent_alignment_requirement>
N        struct aligned_storage;
N    template <size_t Len, class... Types> struct aligned_union;
N
N    template <class T> struct decay;
N    template <class... T> struct common_type;
N    template <class T> struct underlying_type;
N    template <class> class result_of; // undefined
N    template <class Fn, class... ArgTypes> class result_of<Fn(ArgTypes...)>;
N
N    // const-volatile modifications:
N    template <class T>
N      using remove_const_t    = typename remove_const<T>::type;  // C++14
N    template <class T>
N      using remove_volatile_t = typename remove_volatile<T>::type;  // C++14
N    template <class T>
N      using remove_cv_t       = typename remove_cv<T>::type;  // C++14
N    template <class T>
N      using add_const_t       = typename add_const<T>::type;  // C++14
N    template <class T>
N      using add_volatile_t    = typename add_volatile<T>::type;  // C++14
N    template <class T>
N      using add_cv_t          = typename add_cv<T>::type;  // C++14
N  
N    // reference modifications:
N    template <class T>
N      using remove_reference_t     = typename remove_reference<T>::type;  // C++14
N    template <class T>
N      using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;  // C++14
N    template <class T>
N      using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;  // C++14
N  
N    // sign modifications:
N    template <class T>
N      using make_signed_t   = typename make_signed<T>::type;  // C++14
N    template <class T>
N      using make_unsigned_t = typename make_unsigned<T>::type;  // C++14
N  
N    // array modifications:
N    template <class T>
N      using remove_extent_t      = typename remove_extent<T>::type;  // C++14
N    template <class T>
N      using remove_all_extents_t = typename remove_all_extents<T>::type;  // C++14
N
N    // pointer modifications:
N    template <class T>
N      using remove_pointer_t = typename remove_pointer<T>::type;  // C++14
N    template <class T>
N      using add_pointer_t    = typename add_pointer<T>::type;  // C++14
N
N    // other transformations:
N    template <size_t Len, std::size_t Align=default-alignment>
N      using aligned_storage_t = typename aligned_storage<Len,Align>::type;  // C++14
N    template <std::size_t Len, class... Types>
N      using aligned_union_t   = typename aligned_union<Len,Types...>::type;  // C++14
N    template <class T>
N      using decay_t           = typename decay<T>::type;  // C++14
N    template <bool b, class T=void>
N      using enable_if_t       = typename enable_if<b,T>::type;  // C++14
N    template <bool b, class T, class F>
N      using conditional_t     = typename conditional<b,T,F>::type;  // C++14
N    template <class... T>
N      using common_type_t     = typename common_type<T...>::type;  // C++14
N    template <class T>
N      using underlying_type_t = typename underlying_type<T>::type;  // C++14
N    template <class F, class... ArgTypes>
N      using result_of_t       = typename result_of<F(ArgTypes...)>::type;  // C++14
N
N    template <class...>
N      using void_t = void;   // C++17
N      
N      // See C++14 20.10.4.1, primary type categories
N      template <class T> constexpr bool is_void_v
N        = is_void<T>::value;                                             // C++17
N      template <class T> constexpr bool is_null_pointer_v
N        = is_null_pointer<T>::value;                                     // C++17
N      template <class T> constexpr bool is_integral_v
N        = is_integral<T>::value;                                         // C++17
N      template <class T> constexpr bool is_floating_point_v
N        = is_floating_point<T>::value;                                   // C++17
N      template <class T> constexpr bool is_array_v
N        = is_array<T>::value;                                            // C++17
N      template <class T> constexpr bool is_pointer_v
N        = is_pointer<T>::value;                                          // C++17
N      template <class T> constexpr bool is_lvalue_reference_v
N        = is_lvalue_reference<T>::value;                                 // C++17
N      template <class T> constexpr bool is_rvalue_reference_v
N        = is_rvalue_reference<T>::value;                                 // C++17
N      template <class T> constexpr bool is_member_object_pointer_v
N        = is_member_object_pointer<T>::value;                            // C++17
N      template <class T> constexpr bool is_member_function_pointer_v
N        = is_member_function_pointer<T>::value;                          // C++17
N      template <class T> constexpr bool is_enum_v
N        = is_enum<T>::value;                                             // C++17
N      template <class T> constexpr bool is_union_v
N        = is_union<T>::value;                                            // C++17
N      template <class T> constexpr bool is_class_v
N        = is_class<T>::value;                                            // C++17
N      template <class T> constexpr bool is_function_v
N        = is_function<T>::value;                                         // C++17
N
N      // See C++14 20.10.4.2, composite type categories
N      template <class T> constexpr bool is_reference_v
N        = is_reference<T>::value;                                        // C++17
N      template <class T> constexpr bool is_arithmetic_v
N        = is_arithmetic<T>::value;                                       // C++17
N      template <class T> constexpr bool is_fundamental_v
N        = is_fundamental<T>::value;                                      // C++17
N      template <class T> constexpr bool is_object_v
N        = is_object<T>::value;                                           // C++17
N      template <class T> constexpr bool is_scalar_v
N        = is_scalar<T>::value;                                           // C++17
N      template <class T> constexpr bool is_compound_v
N        = is_compound<T>::value;                                         // C++17
N      template <class T> constexpr bool is_member_pointer_v
N        = is_member_pointer<T>::value;                                   // C++17
N
N      // See C++14 20.10.4.3, type properties
N      template <class T> constexpr bool is_const_v
N        = is_const<T>::value;                                            // C++17
N      template <class T> constexpr bool is_volatile_v
N        = is_volatile<T>::value;                                         // C++17
N      template <class T> constexpr bool is_trivial_v
N        = is_trivial<T>::value;                                          // C++17
N      template <class T> constexpr bool is_trivially_copyable_v
N        = is_trivially_copyable<T>::value;                               // C++17
N      template <class T> constexpr bool is_standard_layout_v
N        = is_standard_layout<T>::value;                                  // C++17
N      template <class T> constexpr bool is_pod_v
N        = is_pod<T>::value;                                              // C++17
N      template <class T> constexpr bool is_literal_type_v
N        = is_literal_type<T>::value;                                     // C++17
N      template <class T> constexpr bool is_empty_v
N        = is_empty<T>::value;                                            // C++17
N      template <class T> constexpr bool is_polymorphic_v
N        = is_polymorphic<T>::value;                                      // C++17
N      template <class T> constexpr bool is_abstract_v
N        = is_abstract<T>::value;                                         // C++17
N      template <class T> constexpr bool is_final_v
N        = is_final<T>::value;                                            // C++17
N      template <class T> constexpr bool is_aggregate_v
N        = is_aggregate<T>::value;                                        // C++17
N      template <class T> constexpr bool is_signed_v
N        = is_signed<T>::value;                                           // C++17
N      template <class T> constexpr bool is_unsigned_v
N        = is_unsigned<T>::value;                                         // C++17
N      template <class T, class... Args> constexpr bool is_constructible_v
N        = is_constructible<T, Args...>::value;                           // C++17
N      template <class T> constexpr bool is_default_constructible_v
N        = is_default_constructible<T>::value;                            // C++17
N      template <class T> constexpr bool is_copy_constructible_v
N        = is_copy_constructible<T>::value;                               // C++17
N      template <class T> constexpr bool is_move_constructible_v
N        = is_move_constructible<T>::value;                               // C++17
N      template <class T, class U> constexpr bool is_assignable_v
N        = is_assignable<T, U>::value;                                    // C++17
N      template <class T> constexpr bool is_copy_assignable_v
N        = is_copy_assignable<T>::value;                                  // C++17
N      template <class T> constexpr bool is_move_assignable_v
N        = is_move_assignable<T>::value;                                  // C++17
N      template <class T, class U> constexpr bool is_swappable_with_v
N        = is_swappable_with<T, U>::value;                                // C++17
N      template <class T> constexpr bool is_swappable_v
N        = is_swappable<T>::value;                                        // C++17
N      template <class T> constexpr bool is_destructible_v
N        = is_destructible<T>::value;                                     // C++17
N      template <class T, class... Args> constexpr bool is_trivially_constructible_v
N        = is_trivially_constructible<T, Args...>::value;                 // C++17
N      template <class T> constexpr bool is_trivially_default_constructible_v
N        = is_trivially_default_constructible<T>::value;                  // C++17
N      template <class T> constexpr bool is_trivially_copy_constructible_v
N        = is_trivially_copy_constructible<T>::value;                     // C++17
N      template <class T> constexpr bool is_trivially_move_constructible_v
N        = is_trivially_move_constructible<T>::value;                     // C++17
N      template <class T, class U> constexpr bool is_trivially_assignable_v
N        = is_trivially_assignable<T, U>::value;                          // C++17
N      template <class T> constexpr bool is_trivially_copy_assignable_v
N        = is_trivially_copy_assignable<T>::value;                        // C++17
N      template <class T> constexpr bool is_trivially_move_assignable_v
N        = is_trivially_move_assignable<T>::value;                        // C++17
N      template <class T> constexpr bool is_trivially_destructible_v
N        = is_trivially_destructible<T>::value;                           // C++17
N      template <class T, class... Args> constexpr bool is_nothrow_constructible_v
N        = is_nothrow_constructible<T, Args...>::value;                   // C++17
N      template <class T> constexpr bool is_nothrow_default_constructible_v
N        = is_nothrow_default_constructible<T>::value;                    // C++17
N      template <class T> constexpr bool is_nothrow_copy_constructible_v
N        = is_nothrow_copy_constructible<T>::value;                       // C++17
N      template <class T> constexpr bool is_nothrow_move_constructible_v
N        = is_nothrow_move_constructible<T>::value;                       // C++17
N      template <class T, class U> constexpr bool is_nothrow_assignable_v
N        = is_nothrow_assignable<T, U>::value;                            // C++17
N      template <class T> constexpr bool is_nothrow_copy_assignable_v
N        = is_nothrow_copy_assignable<T>::value;                          // C++17
N      template <class T> constexpr bool is_nothrow_move_assignable_v
N        = is_nothrow_move_assignable<T>::value;                          // C++17
N      template <class T, class U> constexpr bool is_nothrow_swappable_with_v
N        = is_nothrow_swappable_with<T, U>::value;                       // C++17
N      template <class T> constexpr bool is_nothrow_swappable_v
N        = is_nothrow_swappable<T>::value;                               // C++17
N      template <class T> constexpr bool is_nothrow_destructible_v
N        = is_nothrow_destructible<T>::value;                             // C++17
N      template <class T> constexpr bool has_virtual_destructor_v
N        = has_virtual_destructor<T>::value;                              // C++17
N
N      // See C++14 20.10.5, type property queries
N      template <class T> constexpr size_t alignment_of_v
N        = alignment_of<T>::value;                                        // C++17
N      template <class T> constexpr size_t rank_v
N        = rank<T>::value;                                                // C++17
N      template <class T, unsigned I = 0> constexpr size_t extent_v
N        = extent<T, I>::value;                                           // C++17
N
N      // See C++14 20.10.6, type relations
N      template <class T, class U> constexpr bool is_same_v
N        = is_same<T, U>::value;                                          // C++17
N      template <class Base, class Derived> constexpr bool is_base_of_v
N        = is_base_of<Base, Derived>::value;                              // C++17
N      template <class From, class To> constexpr bool is_convertible_v
N        = is_convertible<From, To>::value;                               // C++17
N      template <class T, class R = void> constexpr bool is_callable_v
N        = is_callable<T, R>::value;                                      // C++17
N      template <class T, class R = void> constexpr bool is_nothrow_callable_v
N        = is_nothrow_callable<T, R>::value;                              // C++17
N
N      // [meta.logical], logical operator traits:
N      template<class... B> struct conjunction;                           // C++17
N      template<class... B> 
N        constexpr bool conjunction_v = conjunction<B...>::value;         // C++17
N      template<class... B> struct disjunction;                           // C++17
N      template<class... B>
N        constexpr bool disjunction_v = disjunction<B...>::value;         // C++17
N      template<class B> struct negation;                                 // C++17
N      template<class B> 
N        constexpr bool negation_v = negation<B>::value;                  // C++17
N
N}
N
N*/
N#include <__config>
N#include <cstddef>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/cstddef" 1
N// -*- C++ -*-
N//===--------------------------- cstddef ----------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is dual licensed under the MIT and the University of Illinois Open
N// Source Licenses. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP_CSTDDEF
N#define _LIBCPP_CSTDDEF
N
N/*
N    cstddef synopsis
N
NMacros:
N
N    offsetof(type,member-designator)
N    NULL
N
Nnamespace std
N{
N
NTypes:
N
N    ptrdiff_t
N    size_t
N    max_align_t
N    nullptr_t
N    byte // C++17
N
N}  // std
N
N*/
N
N#include <__config>
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N// Don't include our own <stddef.h>; we don't want to declare ::nullptr_t.
N#include_next <stddef.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/stddef.h" 1
N/*****************************************************************************/
N/* stddef.h                                                                  */
N/*                                                                           */
N/* Copyright (c) 1993 Texas Instruments Incorporated                         */
N/* http://www.ti.com/                                                        */
N/*                                                                           */
N/*  Redistribution and  use in source  and binary forms, with  or without    */
N/*  modification,  are permitted provided  that the  following conditions    */
N/*  are met:                                                                 */
N/*                                                                           */
N/*     Redistributions  of source  code must  retain the  above copyright    */
N/*     notice, this list of conditions and the following disclaimer.         */
N/*                                                                           */
N/*     Redistributions in binary form  must reproduce the above copyright    */
N/*     notice, this  list of conditions  and the following  disclaimer in    */
N/*     the  documentation  and/or   other  materials  provided  with  the    */
N/*     distribution.                                                         */
N/*                                                                           */
N/*     Neither the  name of Texas Instruments Incorporated  nor the names    */
N/*     of its  contributors may  be used to  endorse or  promote products    */
N/*     derived  from   this  software  without   specific  prior  written    */
N/*     permission.                                                           */
N/*                                                                           */
N/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS    */
N/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT    */
N/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    */
N/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT    */
N/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    */
N/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT    */
N/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    */
N/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    */
N/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT    */
N/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    */
N/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     */
N/*                                                                           */
N/*****************************************************************************/
N
N#ifndef _STDDEF
N#define _STDDEF
N
N#include <_ti_config.h>
N
N#pragma diag_push
N#pragma CHECK_MISRA("-19.7") /* macros required for implementation */
N#pragma CHECK_MISRA("-20.1") /* standard headers must define standard names */
N#pragma CHECK_MISRA("-20.2") /* standard headers must define standard names */
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
N#ifndef NULL
S#define NULL 0
N#endif
N
Ntypedef __PTRDIFF_T_TYPE__ ptrdiff_t;
Xtypedef int ptrdiff_t;
N
N#ifndef _SIZE_T_DECLARED
S#define _SIZE_T_DECLARED
S# ifdef __clang__
Stypedef __SIZE_TYPE__ __SIZE_T_TYPE__;
S# endif
S
Stypedef __SIZE_T_TYPE__ size_t;
N#endif
N
N#ifndef __cplusplus
S#ifndef _WCHAR_T_DECLARED
S#define _WCHAR_T_DECLARED
S#ifdef __clang__
Stypedef __WCHAR_TYPE__ __WCHAR_T_TYPE__;
S#endif
S
Stypedef __WCHAR_T_TYPE__ wchar_t;
S
S#endif /* _WCHAR_T */
N#endif /* ! __cplusplus */
N
N/*----------------------------------------------------------------------------*/
N/* C++11 and C11 required max_align_t to be defined. The libc++ cstddef       */
N/* header expects the macro __DEFINED_max_align_t to be defined if it is to   */
N/* use the definintion of max_align_t from stddef.h. Only define it if        */
N/* compiling for C11 or we're in non strict ansi mode.                        */
N/*----------------------------------------------------------------------------*/
N#if defined(_TI_C11LIB) || __TI_STRICT_ANSI_MODE__ == 0
X#if 1L || 0 == 0
N#ifndef __DEFINED_max_align_t
N#define __DEFINED_max_align_t
Ntypedef long double max_align_t;
N#endif /*__DEFINED_max_align_t */
N#endif /* defined(_TI_C11LIB) || __TI_STRICT_ANSI_MODE__ == 0 */
N
N#pragma diag_push
N#pragma CHECK_MISRA("-19.10") /* need types as macro arguments */
N
N#ifdef __TI_LLVM__
S#  define offsetof(_type, _ident) __builtin_offsetof(_type, _ident)
N#else
N#  ifndef __TMS320C55X__
N#      define offsetof(_type, _ident) \
N         ((size_t)__intaddr__(&(((_type *)0)->_ident)))
X#      define offsetof(_type, _ident)          ((size_t)__intaddr__(&(((_type *)0)->_ident)))
N#  else /* __TMS320C55X__ */
S#    define offsetof(_type, _ident) \
S    (__intaddr__( ((char *) &((_type *)0)->_ident) - ((char *) 0) ))
X#    define offsetof(_type, _ident)     (__intaddr__( ((char *) &((_type *)0)->_ident) - ((char *) 0) ))
N#  endif /* __TMS320C55X__ */
N#endif
N
N#pragma diag_pop
N
N#ifdef __cplusplus
N} /* extern "C" */
N#endif  /* __cplusplus */
N
N#pragma diag_pop
N
N#endif  /* _STDDEF */
L 45 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/cstddef" 2
N#include <__nullptr>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/__nullptr" 1
N// -*- C++ -*-
N//===--------------------------- __nullptr --------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is dual licensed under the MIT and the University of Illinois Open
N// Source Licenses. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP_NULLPTR
N#define _LIBCPP_NULLPTR
N
N#include <__config>
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N#ifdef _LIBCPP_HAS_NO_NULLPTR
S
S_LIBCPP_BEGIN_NAMESPACE_STD
S
Sstruct _LIBCPP_TEMPLATE_VIS nullptr_t
S{
S    void* __lx;
S
S    struct __nat {int __for_bool_;};
S
S    _LIBCPP_ALWAYS_INLINE _LIBCPP_CONSTEXPR nullptr_t() : __lx(0) {}
S    _LIBCPP_ALWAYS_INLINE _LIBCPP_CONSTEXPR nullptr_t(int __nat::*) : __lx(0) {}
S
S    _LIBCPP_ALWAYS_INLINE _LIBCPP_CONSTEXPR operator int __nat::*() const {return 0;}
S
S    template <class _Tp>
S        _LIBCPP_ALWAYS_INLINE _LIBCPP_CONSTEXPR
S        operator _Tp* () const {return 0;}
S
S    template <class _Tp, class _Up>
S        _LIBCPP_ALWAYS_INLINE
S        operator _Tp _Up::* () const {return 0;}
S
S    friend _LIBCPP_ALWAYS_INLINE _LIBCPP_CONSTEXPR bool operator==(nullptr_t, nullptr_t) {return true;}
S    friend _LIBCPP_ALWAYS_INLINE _LIBCPP_CONSTEXPR bool operator!=(nullptr_t, nullptr_t) {return false;}
S};
S
Sinline _LIBCPP_ALWAYS_INLINE _LIBCPP_CONSTEXPR nullptr_t __get_nullptr_t() {return nullptr_t(0);}
S
S#define nullptr _VSTD::__get_nullptr_t()
S
S_LIBCPP_END_NAMESPACE_STD
S
N#else  // _LIBCPP_HAS_NO_NULLPTR
N
Nnamespace std
N{
N    typedef decltype(nullptr) nullptr_t;
N}
N
N#endif  // _LIBCPP_HAS_NO_NULLPTR
N
N#endif  // _LIBCPP_NULLPTR
L 46 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/cstddef" 2
N
N_LIBCPP_BEGIN_NAMESPACE_STD
Xnamespace std { inline namespace __2 {
N
Nusing ::ptrdiff_t;
Nusing ::size_t;
N
N#if defined(__CLANG_MAX_ALIGN_T_DEFINED) || defined(_GCC_MAX_ALIGN_T) || \
N    defined(__DEFINED_max_align_t)
X#if 0L || 0L ||     1L
N// Re-use the compiler's <stddef.h> max_align_t where possible.
Nusing ::max_align_t;
N#else
Stypedef long double max_align_t;
N#endif
N
N_LIBCPP_END_NAMESPACE_STD
X} }
N
N#if _LIBCPP_STD_VER > 14
X#if 14 > 14
Snamespace std  // purposefully not versioned
S{
Senum class byte : unsigned char {};
S
Sconstexpr byte& operator|=(byte& __lhs, byte __rhs) noexcept
S{ return __lhs = byte(static_cast<unsigned char>(__lhs) | static_cast<unsigned char>(__rhs)); }
Sconstexpr byte  operator| (byte  __lhs, byte __rhs) noexcept
S{ return         byte(static_cast<unsigned char>(__lhs) | static_cast<unsigned char>(__rhs)); }
S
Sconstexpr byte& operator&=(byte& __lhs, byte __rhs) noexcept
S{ return __lhs = byte(static_cast<unsigned char>(__lhs) & static_cast<unsigned char>(__rhs)); }
Sconstexpr byte  operator& (byte  __lhs, byte __rhs) noexcept
S{ return         byte(static_cast<unsigned char>(__lhs) & static_cast<unsigned char>(__rhs)); }
S
Sconstexpr byte& operator^=(byte& __lhs, byte __rhs) noexcept 
S{ return __lhs = byte(static_cast<unsigned char>(__lhs) ^ static_cast<unsigned char>(__rhs)); }
Sconstexpr byte  operator^ (byte  __lhs, byte __rhs) noexcept
S{ return         byte(static_cast<unsigned char>(__lhs) ^ static_cast<unsigned char>(__rhs)); }
S
Sconstexpr byte  operator~ (byte __b) noexcept
S{ return  byte(~static_cast<unsigned char>(__b)); }
S
S}
S
S#include <type_traits>  // rest of byte
N#endif
N
N#endif  // _LIBCPP_CSTDDEF
L 391 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/type_traits" 2
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N_LIBCPP_BEGIN_NAMESPACE_STD
Xnamespace std { inline namespace __2 {
N
Ntemplate <class _T1, class _T2> struct _LIBCPP_TEMPLATE_VIS pair;
Xtemplate <class _T1, class _T2> struct  pair;
Ntemplate <class _Tp> class _LIBCPP_TEMPLATE_VIS reference_wrapper;
Xtemplate <class _Tp> class  reference_wrapper;
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS hash;
Xtemplate <class _Tp> struct  hash;
N
Ntemplate <class>
Nstruct __void_t { typedef void type; };
N
Ntemplate <class _Tp>
Nstruct __identity { typedef _Tp type; };
N
Ntemplate <class _Tp, bool>
Nstruct _LIBCPP_TEMPLATE_VIS __dependent_type : public _Tp {};
Xstruct  __dependent_type : public _Tp {};
N
Ntemplate <bool _Bp, class _If, class _Then>
N    struct _LIBCPP_TEMPLATE_VIS conditional {typedef _If type;};
X    struct  conditional {typedef _If type;};
Ntemplate <class _If, class _Then>
N    struct _LIBCPP_TEMPLATE_VIS conditional<false, _If, _Then> {typedef _Then type;};
X    struct  conditional<false, _If, _Then> {typedef _Then type;};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <bool _Bp, class _If, class _Then> using conditional_t = typename conditional<_Bp, _If, _Then>::type;
N#endif
N
Ntemplate <bool, class _Tp> struct _LIBCPP_TEMPLATE_VIS __lazy_enable_if {};
Xtemplate <bool, class _Tp> struct  __lazy_enable_if {};
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS __lazy_enable_if<true, _Tp> {typedef typename _Tp::type type;};
Xtemplate <class _Tp> struct  __lazy_enable_if<true, _Tp> {typedef typename _Tp::type type;};
N
Ntemplate <bool, class _Tp = void> struct _LIBCPP_TEMPLATE_VIS enable_if {};
Xtemplate <bool, class _Tp = void> struct  enable_if {};
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS enable_if<true, _Tp> {typedef _Tp type;};
Xtemplate <class _Tp> struct  enable_if<true, _Tp> {typedef _Tp type;};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <bool _Bp, class _Tp = void> using enable_if_t = typename enable_if<_Bp, _Tp>::type;
N#endif
N
N// addressof
N#ifndef _LIBCPP_HAS_NO_BUILTIN_ADDRESSOF
N
Ntemplate <class _Tp>
Ninline _LIBCPP_CONSTEXPR_AFTER_CXX14
Xinline 
N_LIBCPP_NO_CFI _LIBCPP_INLINE_VISIBILITY
X __attribute__ ((__always_inline__))
N_Tp*
Naddressof(_Tp& __x) _NOEXCEPT
Xaddressof(_Tp& __x) noexcept
N{
N    return __builtin_addressof(__x);
N}
N
N#else
S
Stemplate <class _Tp>
Sinline _LIBCPP_NO_CFI _LIBCPP_INLINE_VISIBILITY
S_Tp*
Saddressof(_Tp& __x) _NOEXCEPT
S{
S  return reinterpret_cast<_Tp *>(
S      const_cast<char *>(&reinterpret_cast<const volatile char &>(__x)));
S}
S
N#endif // _LIBCPP_HAS_NO_BUILTIN_ADDRESSOF
N
N#if defined(_LIBCPP_HAS_OBJC_ARC) && !defined(_LIBCPP_PREDEFINED_OBJC_ARC_ADDRESSOF)
X#if 0L && !0L
S// Objective-C++ Automatic Reference Counting uses qualified pointers
S// that require special addressof() signatures. When
S// _LIBCPP_PREDEFINED_OBJC_ARC_ADDRESSOF is defined, the compiler
S// itself is providing these definitions. Otherwise, we provide them.
Stemplate <class _Tp>
Sinline _LIBCPP_INLINE_VISIBILITY
S__strong _Tp*
Saddressof(__strong _Tp& __x) _NOEXCEPT
S{
S  return &__x;
S}
S
S#ifdef _LIBCPP_HAS_OBJC_ARC_WEAK
Stemplate <class _Tp>
Sinline _LIBCPP_INLINE_VISIBILITY
S__weak _Tp*
Saddressof(__weak _Tp& __x) _NOEXCEPT
S{
S  return &__x;
S}
S#endif
S
Stemplate <class _Tp>
Sinline _LIBCPP_INLINE_VISIBILITY
S__autoreleasing _Tp*
Saddressof(__autoreleasing _Tp& __x) _NOEXCEPT
S{
S  return &__x;
S}
S
Stemplate <class _Tp>
Sinline _LIBCPP_INLINE_VISIBILITY
S__unsafe_unretained _Tp*
Saddressof(__unsafe_unretained _Tp& __x) _NOEXCEPT
S{
S  return &__x;
S}
N#endif
N
N#if !defined(_LIBCPP_CXX03_LANG)
X#if !0L
Ntemplate <class _Tp> _Tp* addressof(const _Tp&&) noexcept = delete;
N#endif
N
Nstruct __two {char __lx[2];};
N
N// helper class:
N
Ntemplate <class _Tp, _Tp __v>
Nstruct _LIBCPP_TEMPLATE_VIS integral_constant
Xstruct  integral_constant
N{
N    static _LIBCPP_CONSTEXPR const _Tp      value = __v;
X    static constexpr const _Tp      value = __v;
N    typedef _Tp               value_type;
N    typedef integral_constant type;
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N        _LIBCPP_CONSTEXPR operator value_type() const _NOEXCEPT {return value;}
X        constexpr operator value_type() const noexcept {return value;}
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
N    _LIBCPP_INLINE_VISIBILITY
X    __attribute__ ((__always_inline__))
N         constexpr value_type operator ()() const _NOEXCEPT {return value;}
X         constexpr value_type operator ()() const noexcept {return value;}
N#endif
N};
N
Ntemplate <class _Tp, _Tp __v>
N_LIBCPP_CONSTEXPR const _Tp integral_constant<_Tp, __v>::value;
Xconstexpr const _Tp integral_constant<_Tp, __v>::value;
N
N#if _LIBCPP_STD_VER > 14
X#if 14 > 14
Stemplate <bool __b>
Susing bool_constant = integral_constant<bool, __b>;
S#define _LIBCPP_BOOL_CONSTANT(__b) bool_constant<(__b)>
N#else
N#define _LIBCPP_BOOL_CONSTANT(__b) integral_constant<bool,(__b)>
N#endif
N
Ntypedef _LIBCPP_BOOL_CONSTANT(true)  true_type;
Xtypedef integral_constant<bool,(true)>  true_type;
Ntypedef _LIBCPP_BOOL_CONSTANT(false) false_type;
Xtypedef integral_constant<bool,(false)> false_type;
N
N#if !defined(_LIBCPP_CXX03_LANG)
X#if !0L
N
N// __lazy_and
N
Ntemplate <bool _Last, class ..._Preds>
Nstruct __lazy_and_impl;
N
Ntemplate <class ..._Preds>
Nstruct __lazy_and_impl<false, _Preds...> : false_type {};
N
Ntemplate <>
Nstruct __lazy_and_impl<true> : true_type {};
N
Ntemplate <class _Pred>
Nstruct __lazy_and_impl<true, _Pred> : integral_constant<bool, _Pred::type::value> {};
N
Ntemplate <class _Hp, class ..._Tp>
Nstruct __lazy_and_impl<true, _Hp, _Tp...> : __lazy_and_impl<_Hp::type::value, _Tp...> {};
N
Ntemplate <class _P1, class ..._Pr>
Nstruct __lazy_and : __lazy_and_impl<_P1::type::value, _Pr...> {};
N
N// __lazy_or
N
Ntemplate <bool _List, class ..._Preds>
Nstruct __lazy_or_impl;
N
Ntemplate <class ..._Preds>
Nstruct __lazy_or_impl<true, _Preds...> : true_type {};
N
Ntemplate <>
Nstruct __lazy_or_impl<false> : false_type {};
N
Ntemplate <class _Hp, class ..._Tp>
Nstruct __lazy_or_impl<false, _Hp, _Tp...>
N        : __lazy_or_impl<_Hp::type::value, _Tp...> {};
N
Ntemplate <class _P1, class ..._Pr>
Nstruct __lazy_or : __lazy_or_impl<_P1::type::value, _Pr...> {};
N
N// __lazy_not
N
Ntemplate <class _Pred>
Nstruct __lazy_not : integral_constant<bool, !_Pred::type::value> {};
N
N// __and_
Ntemplate<class...> struct __and_;
Ntemplate<> struct __and_<> : true_type {};
N
Ntemplate<class _B0> struct __and_<_B0> : _B0 {};
N
Ntemplate<class _B0, class _B1>
Nstruct __and_<_B0, _B1> : conditional<_B0::value, _B1, _B0>::type {};
N
Ntemplate<class _B0, class _B1, class _B2, class... _Bn>
Nstruct __and_<_B0, _B1, _B2, _Bn...> 
N        : conditional<_B0::value, __and_<_B1, _B2, _Bn...>, _B0>::type {};
N
N// __or_
Ntemplate<class...> struct __or_;
Ntemplate<> struct __or_<> : false_type {};
N
Ntemplate<class _B0> struct __or_<_B0> : _B0 {};
N
Ntemplate<class _B0, class _B1>
Nstruct __or_<_B0, _B1> : conditional<_B0::value, _B0, _B1>::type {};
N
Ntemplate<class _B0, class _B1, class _B2, class... _Bn>
Nstruct __or_<_B0, _B1, _B2, _Bn...> 
N        : conditional<_B0::value, _B0, __or_<_B1, _B2, _Bn...> >::type {};
N
N// __not_
Ntemplate<class _Tp> 
Nstruct __not_ : conditional<_Tp::value, false_type, true_type>::type {};
N
N#endif // !defined(_LIBCPP_CXX03_LANG)
N
N// is_const
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_const            : public false_type {};
Xtemplate <class _Tp> struct  is_const            : public false_type {};
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_const<_Tp const> : public true_type {};
Xtemplate <class _Tp> struct  is_const<_Tp const> : public true_type {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_const_v
S    = is_const<_Tp>::value;
N#endif
N
N// is_volatile
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_volatile               : public false_type {};
Xtemplate <class _Tp> struct  is_volatile               : public false_type {};
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_volatile<_Tp volatile> : public true_type {};
Xtemplate <class _Tp> struct  is_volatile<_Tp volatile> : public true_type {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_volatile_v
S    = is_volatile<_Tp>::value;
N#endif
N
N// remove_const
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_const            {typedef _Tp type;};
Xtemplate <class _Tp> struct  remove_const            {typedef _Tp type;};
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_const<const _Tp> {typedef _Tp type;};
Xtemplate <class _Tp> struct  remove_const<const _Tp> {typedef _Tp type;};
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _Tp> using remove_const_t = typename remove_const<_Tp>::type;
N#endif
N
N// remove_volatile
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_volatile               {typedef _Tp type;};
Xtemplate <class _Tp> struct  remove_volatile               {typedef _Tp type;};
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_volatile<volatile _Tp> {typedef _Tp type;};
Xtemplate <class _Tp> struct  remove_volatile<volatile _Tp> {typedef _Tp type;};
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _Tp> using remove_volatile_t = typename remove_volatile<_Tp>::type;
N#endif
N
N// remove_cv
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_cv
Xtemplate <class _Tp> struct  remove_cv
N{typedef typename remove_volatile<typename remove_const<_Tp>::type>::type type;};
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _Tp> using remove_cv_t = typename remove_cv<_Tp>::type;
N#endif
N
N// is_void
N
Ntemplate <class _Tp> struct __libcpp_is_void       : public false_type {};
Ntemplate <>          struct __libcpp_is_void<void> : public true_type {};
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_void
Xtemplate <class _Tp> struct  is_void
N    : public __libcpp_is_void<typename remove_cv<_Tp>::type> {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_void_v
S    = is_void<_Tp>::value;
N#endif
N
N// __is_nullptr_t
N
Ntemplate <class _Tp> struct __is_nullptr_t_impl       : public false_type {};
Ntemplate <>          struct __is_nullptr_t_impl<nullptr_t> : public true_type {};
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS __is_nullptr_t
Xtemplate <class _Tp> struct  __is_nullptr_t
N    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_null_pointer
Xtemplate <class _Tp> struct  is_null_pointer
N    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_null_pointer_v
S    = is_null_pointer<_Tp>::value;
N#endif
N#endif
N
N// is_integral
N
Ntemplate <class _Tp> struct __libcpp_is_integral                     : public false_type {};
Ntemplate <>          struct __libcpp_is_integral<bool>               : public true_type {};
Ntemplate <>          struct __libcpp_is_integral<char>               : public true_type {};
Ntemplate <>          struct __libcpp_is_integral<signed char>        : public true_type {};
Ntemplate <>          struct __libcpp_is_integral<unsigned char>      : public true_type {};
Ntemplate <>          struct __libcpp_is_integral<wchar_t>            : public true_type {};
N#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
Ntemplate <>          struct __libcpp_is_integral<char16_t>           : public true_type {};
Ntemplate <>          struct __libcpp_is_integral<char32_t>           : public true_type {};
N#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS
Ntemplate <>          struct __libcpp_is_integral<short>              : public true_type {};
Ntemplate <>          struct __libcpp_is_integral<unsigned short>     : public true_type {};
Ntemplate <>          struct __libcpp_is_integral<int>                : public true_type {};
Ntemplate <>          struct __libcpp_is_integral<unsigned int>       : public true_type {};
Ntemplate <>          struct __libcpp_is_integral<long>               : public true_type {};
Ntemplate <>          struct __libcpp_is_integral<unsigned long>      : public true_type {};
Ntemplate <>          struct __libcpp_is_integral<long long>          : public true_type {};
Ntemplate <>          struct __libcpp_is_integral<unsigned long long> : public true_type {};
N#ifndef _LIBCPP_HAS_NO_INT128
Stemplate <>          struct __libcpp_is_integral<__int128_t>         : public true_type {};
Stemplate <>          struct __libcpp_is_integral<__uint128_t>        : public true_type {};
N#endif
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_integral
Xtemplate <class _Tp> struct  is_integral
N    : public __libcpp_is_integral<typename remove_cv<_Tp>::type> {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_integral_v
S    = is_integral<_Tp>::value;
N#endif
N
N// is_floating_point
N
Ntemplate <class _Tp> struct __libcpp_is_floating_point              : public false_type {};
Ntemplate <>          struct __libcpp_is_floating_point<float>       : public true_type {};
Ntemplate <>          struct __libcpp_is_floating_point<double>      : public true_type {};
Ntemplate <>          struct __libcpp_is_floating_point<long double> : public true_type {};
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_floating_point
Xtemplate <class _Tp> struct  is_floating_point
N    : public __libcpp_is_floating_point<typename remove_cv<_Tp>::type> {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_floating_point_v
S    = is_floating_point<_Tp>::value;
N#endif
N
N// is_array
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_array
Xtemplate <class _Tp> struct  is_array
N    : public false_type {};
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_array<_Tp[]>
Xtemplate <class _Tp> struct  is_array<_Tp[]>
N    : public true_type {};
Ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS is_array<_Tp[_Np]>
Xtemplate <class _Tp, size_t _Np> struct  is_array<_Tp[_Np]>
N    : public true_type {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_array_v
S    = is_array<_Tp>::value;
N#endif
N
N// is_pointer
N
Ntemplate <class _Tp> struct __libcpp_is_pointer       : public false_type {};
Ntemplate <class _Tp> struct __libcpp_is_pointer<_Tp*> : public true_type {};
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_pointer
Xtemplate <class _Tp> struct  is_pointer
N    : public __libcpp_is_pointer<typename remove_cv<_Tp>::type> {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_pointer_v
S    = is_pointer<_Tp>::value;
N#endif
N
N// is_reference
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_lvalue_reference       : public false_type {};
Xtemplate <class _Tp> struct  is_lvalue_reference       : public false_type {};
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_lvalue_reference<_Tp&> : public true_type {};
Xtemplate <class _Tp> struct  is_lvalue_reference<_Tp&> : public true_type {};
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_rvalue_reference        : public false_type {};
Xtemplate <class _Tp> struct  is_rvalue_reference        : public false_type {};
N#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_rvalue_reference<_Tp&&> : public true_type {};
Xtemplate <class _Tp> struct  is_rvalue_reference<_Tp&&> : public true_type {};
N#endif
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_reference        : public false_type {};
Xtemplate <class _Tp> struct  is_reference        : public false_type {};
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_reference<_Tp&>  : public true_type {};
Xtemplate <class _Tp> struct  is_reference<_Tp&>  : public true_type {};
N#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_reference<_Tp&&> : public true_type {};
Xtemplate <class _Tp> struct  is_reference<_Tp&&> : public true_type {};
N#endif
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_reference_v
S    = is_reference<_Tp>::value;
S
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_lvalue_reference_v
S    = is_lvalue_reference<_Tp>::value;
S
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_rvalue_reference_v
S    = is_rvalue_reference<_Tp>::value;
N#endif
N// is_union
N
N#if __has_feature(is_union) || (_GNUC_VER >= 403)
X#if 1 || (0 >= 403)
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_union
Xtemplate <class _Tp> struct  is_union
N    : public integral_constant<bool, __is_union(_Tp)> {};
N
N#else
S
Stemplate <class _Tp> struct __libcpp_union : public false_type {};
Stemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_union
S    : public __libcpp_union<typename remove_cv<_Tp>::type> {};
S
N#endif
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_union_v
S    = is_union<_Tp>::value;
N#endif
N
N// is_class
N
N#if __has_feature(is_class) || (_GNUC_VER >= 403)
X#if 1 || (0 >= 403)
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_class
Xtemplate <class _Tp> struct  is_class
N    : public integral_constant<bool, __is_class(_Tp)> {};
N
N#else
S
Snamespace __is_class_imp
S{
Stemplate <class _Tp> char  __test(int _Tp::*);
Stemplate <class _Tp> __two __test(...);
S}
S
Stemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_class
S    : public integral_constant<bool, sizeof(__is_class_imp::__test<_Tp>(0)) == 1 && !is_union<_Tp>::value> {};
S
N#endif
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_class_v
S    = is_class<_Tp>::value;
N#endif
N
N// is_same
N
Ntemplate <class _Tp, class _Up> struct _LIBCPP_TEMPLATE_VIS is_same           : public false_type {};
Xtemplate <class _Tp, class _Up> struct  is_same           : public false_type {};
Ntemplate <class _Tp>            struct _LIBCPP_TEMPLATE_VIS is_same<_Tp, _Tp> : public true_type {};
Xtemplate <class _Tp>            struct  is_same<_Tp, _Tp> : public true_type {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp, class _Up> _LIBCPP_CONSTEXPR bool is_same_v
S    = is_same<_Tp, _Up>::value;
N#endif
N
N// is_function
N
Nnamespace __libcpp_is_function_imp
N{
Nstruct __dummy_type {};
Ntemplate <class _Tp> char  __test(_Tp*);
Ntemplate <class _Tp> char __test(__dummy_type);
Ntemplate <class _Tp> __two __test(...);
Ntemplate <class _Tp> _Tp&  __source(int);
Ntemplate <class _Tp> __dummy_type __source(...);
N}
N
Ntemplate <class _Tp, bool = is_class<_Tp>::value ||
N                            is_union<_Tp>::value ||
N                            is_void<_Tp>::value  ||
N                            is_reference<_Tp>::value ||
N                            __is_nullptr_t<_Tp>::value >
Nstruct __libcpp_is_function
N    : public integral_constant<bool, sizeof(__libcpp_is_function_imp::__test<_Tp>(__libcpp_is_function_imp::__source<_Tp>(0))) == 1>
N    {};
Ntemplate <class _Tp> struct __libcpp_is_function<_Tp, true> : public false_type {};
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_function
Xtemplate <class _Tp> struct  is_function
N    : public __libcpp_is_function<_Tp> {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_function_v
S    = is_function<_Tp>::value;
N#endif
N
N// is_member_function_pointer
N
N// template <class _Tp> struct            __libcpp_is_member_function_pointer             : public false_type {};
N// template <class _Tp, class _Up> struct __libcpp_is_member_function_pointer<_Tp _Up::*> : public is_function<_Tp> {};
N// 
N
Ntemplate <class _MP, bool _IsMemberFunctionPtr, bool _IsMemberObjectPtr>
Nstruct __member_pointer_traits_imp
N{  // forward declaration; specializations later
N};
N
N
Ntemplate <class _Tp> struct __libcpp_is_member_function_pointer
N    : public false_type {};
N
Ntemplate <class _Ret, class _Class>
Nstruct __libcpp_is_member_function_pointer<_Ret _Class::*>
N    : public is_function<_Ret> {};
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_member_function_pointer
Xtemplate <class _Tp> struct  is_member_function_pointer
N    : public __libcpp_is_member_function_pointer<typename remove_cv<_Tp>::type>::type {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_member_function_pointer_v
S    = is_member_function_pointer<_Tp>::value;
N#endif
N
N// is_member_pointer
N
Ntemplate <class _Tp>            struct __libcpp_is_member_pointer             : public false_type {};
Ntemplate <class _Tp, class _Up> struct __libcpp_is_member_pointer<_Tp _Up::*> : public true_type {};
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_member_pointer
Xtemplate <class _Tp> struct  is_member_pointer
N    : public __libcpp_is_member_pointer<typename remove_cv<_Tp>::type> {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_member_pointer_v
S    = is_member_pointer<_Tp>::value;
N#endif
N
N// is_member_object_pointer
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_member_object_pointer
Xtemplate <class _Tp> struct  is_member_object_pointer
N    : public integral_constant<bool, is_member_pointer<_Tp>::value &&
N                                    !is_member_function_pointer<_Tp>::value> {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_member_object_pointer_v
S    = is_member_object_pointer<_Tp>::value;
N#endif
N
N// is_enum
N
N#if __has_feature(is_enum) || (_GNUC_VER >= 403)
X#if 1 || (0 >= 403)
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_enum
Xtemplate <class _Tp> struct  is_enum
N    : public integral_constant<bool, __is_enum(_Tp)> {};
N
N#else
S
Stemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_enum
S    : public integral_constant<bool, !is_void<_Tp>::value             &&
S                                     !is_integral<_Tp>::value         &&
S                                     !is_floating_point<_Tp>::value   &&
S                                     !is_array<_Tp>::value            &&
S                                     !is_pointer<_Tp>::value          &&
S                                     !is_reference<_Tp>::value        &&
S                                     !is_member_pointer<_Tp>::value   &&
S                                     !is_union<_Tp>::value            &&
S                                     !is_class<_Tp>::value            &&
S                                     !is_function<_Tp>::value         > {};
S
N#endif
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_enum_v
S    = is_enum<_Tp>::value;
N#endif
N
N// is_arithmetic
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_arithmetic
Xtemplate <class _Tp> struct  is_arithmetic
N    : public integral_constant<bool, is_integral<_Tp>::value      ||
N                                     is_floating_point<_Tp>::value> {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_arithmetic_v
S    = is_arithmetic<_Tp>::value;
N#endif
N
N// is_fundamental
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_fundamental
Xtemplate <class _Tp> struct  is_fundamental
N    : public integral_constant<bool, is_void<_Tp>::value        ||
N                                     __is_nullptr_t<_Tp>::value ||
N                                     is_arithmetic<_Tp>::value> {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_fundamental_v
S    = is_fundamental<_Tp>::value;
N#endif
N
N// is_scalar
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_scalar
Xtemplate <class _Tp> struct  is_scalar
N    : public integral_constant<bool, is_arithmetic<_Tp>::value     ||
N                                     is_member_pointer<_Tp>::value ||
N                                     is_pointer<_Tp>::value        ||
N                                     __is_nullptr_t<_Tp>::value    ||
N                                     is_enum<_Tp>::value           > {};
N
Ntemplate <> struct _LIBCPP_TEMPLATE_VIS is_scalar<nullptr_t> : public true_type {};
Xtemplate <> struct  is_scalar<nullptr_t> : public true_type {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_scalar_v
S    = is_scalar<_Tp>::value;
N#endif
N
N// is_object
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_object
Xtemplate <class _Tp> struct  is_object
N    : public integral_constant<bool, is_scalar<_Tp>::value ||
N                                     is_array<_Tp>::value  ||
N                                     is_union<_Tp>::value  ||
N                                     is_class<_Tp>::value  > {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_object_v
S    = is_object<_Tp>::value;
N#endif
N
N// is_compound
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_compound
Xtemplate <class _Tp> struct  is_compound
N    : public integral_constant<bool, !is_fundamental<_Tp>::value> {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_compound_v
S    = is_compound<_Tp>::value;
N#endif
N
N
N// __is_referenceable  [defns.referenceable]
N
Nstruct __is_referenceable_impl {
N    template <class _Tp> static _Tp& __test(int);
N    template <class _Tp> static __two __test(...);
N};
N
Ntemplate <class _Tp>
Nstruct __is_referenceable : integral_constant<bool,
N    !is_same<decltype(__is_referenceable_impl::__test<_Tp>(0)), __two>::value> {};
N
N
N// add_const
N
Ntemplate <class _Tp, bool = is_reference<_Tp>::value ||
N                            is_function<_Tp>::value  ||
N                            is_const<_Tp>::value     >
Nstruct __add_const             {typedef _Tp type;};
N
Ntemplate <class _Tp>
Nstruct __add_const<_Tp, false> {typedef const _Tp type;};
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_const
Xtemplate <class _Tp> struct  add_const
N    {typedef typename __add_const<_Tp>::type type;};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _Tp> using add_const_t = typename add_const<_Tp>::type;
N#endif
N
N// add_volatile
N
Ntemplate <class _Tp, bool = is_reference<_Tp>::value ||
N                            is_function<_Tp>::value  ||
N                            is_volatile<_Tp>::value  >
Nstruct __add_volatile             {typedef _Tp type;};
N
Ntemplate <class _Tp>
Nstruct __add_volatile<_Tp, false> {typedef volatile _Tp type;};
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_volatile
Xtemplate <class _Tp> struct  add_volatile
N    {typedef typename __add_volatile<_Tp>::type type;};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _Tp> using add_volatile_t = typename add_volatile<_Tp>::type;
N#endif
N
N// add_cv
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_cv
Xtemplate <class _Tp> struct  add_cv
N    {typedef typename add_const<typename add_volatile<_Tp>::type>::type type;};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _Tp> using add_cv_t = typename add_cv<_Tp>::type;
N#endif
N
N// remove_reference
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_reference        {typedef _Tp type;};
Xtemplate <class _Tp> struct  remove_reference        {typedef _Tp type;};
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_reference<_Tp&>  {typedef _Tp type;};
Xtemplate <class _Tp> struct  remove_reference<_Tp&>  {typedef _Tp type;};
N#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_reference<_Tp&&> {typedef _Tp type;};
Xtemplate <class _Tp> struct  remove_reference<_Tp&&> {typedef _Tp type;};
N#endif
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _Tp> using remove_reference_t = typename remove_reference<_Tp>::type;
N#endif
N
N// add_lvalue_reference
N
Ntemplate <class _Tp, bool = __is_referenceable<_Tp>::value> struct __add_lvalue_reference_impl            { typedef _Tp  type; };
Ntemplate <class _Tp                                       > struct __add_lvalue_reference_impl<_Tp, true> { typedef _Tp& type; };
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_lvalue_reference
Xtemplate <class _Tp> struct  add_lvalue_reference
N{typedef typename __add_lvalue_reference_impl<_Tp>::type type;};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _Tp> using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;
N#endif
N
N#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
N
Ntemplate <class _Tp, bool = __is_referenceable<_Tp>::value> struct __add_rvalue_reference_impl            { typedef _Tp   type; };
Ntemplate <class _Tp                                       > struct __add_rvalue_reference_impl<_Tp, true> { typedef _Tp&& type; };
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_rvalue_reference
Xtemplate <class _Tp> struct  add_rvalue_reference
N{typedef typename __add_rvalue_reference_impl<_Tp>::type type;};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _Tp> using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;
N#endif
N
N#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
N
N#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
N
Ntemplate <class _Tp> _Tp&& __declval(int);
Ntemplate <class _Tp> _Tp   __declval(long);
N
Ntemplate <class _Tp>
Ndecltype(_VSTD::__declval<_Tp>(0))
Xdecltype(std::__2::__declval<_Tp>(0))
Ndeclval() _NOEXCEPT;
Xdeclval() noexcept;
N
N#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
S
Stemplate <class _Tp>
Stypename add_lvalue_reference<_Tp>::type
Sdeclval();
S
N#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
N
N// __uncvref
N
Ntemplate <class _Tp>
Nstruct __uncvref  {
N    typedef typename remove_cv<typename remove_reference<_Tp>::type>::type type;
N};
N
Ntemplate <class _Tp>
Nstruct __unconstref {
N    typedef typename remove_const<typename remove_reference<_Tp>::type>::type type;
N};
N
N#ifndef _LIBCPP_CXX03_LANG
Ntemplate <class _Tp>
Nusing __uncvref_t = typename __uncvref<_Tp>::type;
N#endif
N
N// __is_same_uncvref
N
Ntemplate <class _Tp, class _Up>
Nstruct __is_same_uncvref : is_same<typename __uncvref<_Tp>::type,
N                                   typename __uncvref<_Up>::type> {};
N
Nstruct __any
N{
N    __any(...);
N};
N
N// remove_pointer
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer                      {typedef _Tp type;};
Xtemplate <class _Tp> struct  remove_pointer                      {typedef _Tp type;};
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer<_Tp*>                {typedef _Tp type;};
Xtemplate <class _Tp> struct  remove_pointer<_Tp*>                {typedef _Tp type;};
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer<_Tp* const>          {typedef _Tp type;};
Xtemplate <class _Tp> struct  remove_pointer<_Tp* const>          {typedef _Tp type;};
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer<_Tp* volatile>       {typedef _Tp type;};
Xtemplate <class _Tp> struct  remove_pointer<_Tp* volatile>       {typedef _Tp type;};
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer<_Tp* const volatile> {typedef _Tp type;};
Xtemplate <class _Tp> struct  remove_pointer<_Tp* const volatile> {typedef _Tp type;};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _Tp> using remove_pointer_t = typename remove_pointer<_Tp>::type;
N#endif
N
N// add_pointer
N
Ntemplate <class _Tp, 
N        bool = __is_referenceable<_Tp>::value || 
N                is_same<typename remove_cv<_Tp>::type, void>::value>
Nstruct __add_pointer_impl
N    {typedef typename remove_reference<_Tp>::type* type;};
Ntemplate <class _Tp> struct __add_pointer_impl<_Tp, false> 
N    {typedef _Tp type;};
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_pointer
Xtemplate <class _Tp> struct  add_pointer
N    {typedef typename __add_pointer_impl<_Tp>::type type;};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _Tp> using add_pointer_t = typename add_pointer<_Tp>::type;
N#endif
N
N// is_signed
N
Ntemplate <class _Tp, bool = is_integral<_Tp>::value>
Nstruct __libcpp_is_signed_impl : public _LIBCPP_BOOL_CONSTANT(_Tp(-1) < _Tp(0)) {};
Xstruct __libcpp_is_signed_impl : public integral_constant<bool,(_Tp(-1) < _Tp(0))> {};
N
Ntemplate <class _Tp>
Nstruct __libcpp_is_signed_impl<_Tp, false> : public true_type {};  // floating point
N
Ntemplate <class _Tp, bool = is_arithmetic<_Tp>::value>
Nstruct __libcpp_is_signed : public __libcpp_is_signed_impl<_Tp> {};
N
Ntemplate <class _Tp> struct __libcpp_is_signed<_Tp, false> : public false_type {};
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_signed : public __libcpp_is_signed<_Tp> {};
Xtemplate <class _Tp> struct  is_signed : public __libcpp_is_signed<_Tp> {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_signed_v
S    = is_signed<_Tp>::value;
N#endif
N
N// is_unsigned
N
Ntemplate <class _Tp, bool = is_integral<_Tp>::value>
Nstruct __libcpp_is_unsigned_impl : public _LIBCPP_BOOL_CONSTANT(_Tp(0) < _Tp(-1)) {};
Xstruct __libcpp_is_unsigned_impl : public integral_constant<bool,(_Tp(0) < _Tp(-1))> {};
N
Ntemplate <class _Tp>
Nstruct __libcpp_is_unsigned_impl<_Tp, false> : public false_type {};  // floating point
N
Ntemplate <class _Tp, bool = is_arithmetic<_Tp>::value>
Nstruct __libcpp_is_unsigned : public __libcpp_is_unsigned_impl<_Tp> {};
N
Ntemplate <class _Tp> struct __libcpp_is_unsigned<_Tp, false> : public false_type {};
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_unsigned : public __libcpp_is_unsigned<_Tp> {};
Xtemplate <class _Tp> struct  is_unsigned : public __libcpp_is_unsigned<_Tp> {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_unsigned_v
S    = is_unsigned<_Tp>::value;
N#endif
N
N// rank
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS rank
Xtemplate <class _Tp> struct  rank
N    : public integral_constant<size_t, 0> {};
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS rank<_Tp[]>
Xtemplate <class _Tp> struct  rank<_Tp[]>
N    : public integral_constant<size_t, rank<_Tp>::value + 1> {};
Ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS rank<_Tp[_Np]>
Xtemplate <class _Tp, size_t _Np> struct  rank<_Tp[_Np]>
N    : public integral_constant<size_t, rank<_Tp>::value + 1> {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR size_t rank_v
S    = rank<_Tp>::value;
N#endif
N
N// extent
N
Ntemplate <class _Tp, unsigned _Ip = 0> struct _LIBCPP_TEMPLATE_VIS extent
Xtemplate <class _Tp, unsigned _Ip = 0> struct  extent
N    : public integral_constant<size_t, 0> {};
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS extent<_Tp[], 0>
Xtemplate <class _Tp> struct  extent<_Tp[], 0>
N    : public integral_constant<size_t, 0> {};
Ntemplate <class _Tp, unsigned _Ip> struct _LIBCPP_TEMPLATE_VIS extent<_Tp[], _Ip>
Xtemplate <class _Tp, unsigned _Ip> struct  extent<_Tp[], _Ip>
N    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};
Ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS extent<_Tp[_Np], 0>
Xtemplate <class _Tp, size_t _Np> struct  extent<_Tp[_Np], 0>
N    : public integral_constant<size_t, _Np> {};
Ntemplate <class _Tp, size_t _Np, unsigned _Ip> struct _LIBCPP_TEMPLATE_VIS extent<_Tp[_Np], _Ip>
Xtemplate <class _Tp, size_t _Np, unsigned _Ip> struct  extent<_Tp[_Np], _Ip>
N    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp, unsigned _Ip = 0> _LIBCPP_CONSTEXPR size_t extent_v
S    = extent<_Tp, _Ip>::value;
N#endif
N
N// remove_extent
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_extent
Xtemplate <class _Tp> struct  remove_extent
N    {typedef _Tp type;};
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_extent<_Tp[]>
Xtemplate <class _Tp> struct  remove_extent<_Tp[]>
N    {typedef _Tp type;};
Ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS remove_extent<_Tp[_Np]>
Xtemplate <class _Tp, size_t _Np> struct  remove_extent<_Tp[_Np]>
N    {typedef _Tp type;};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _Tp> using remove_extent_t = typename remove_extent<_Tp>::type;
N#endif
N
N// remove_all_extents
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_all_extents
Xtemplate <class _Tp> struct  remove_all_extents
N    {typedef _Tp type;};
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_all_extents<_Tp[]>
Xtemplate <class _Tp> struct  remove_all_extents<_Tp[]>
N    {typedef typename remove_all_extents<_Tp>::type type;};
Ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS remove_all_extents<_Tp[_Np]>
Xtemplate <class _Tp, size_t _Np> struct  remove_all_extents<_Tp[_Np]>
N    {typedef typename remove_all_extents<_Tp>::type type;};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _Tp> using remove_all_extents_t = typename remove_all_extents<_Tp>::type;
N#endif
N
N// decay
N
Ntemplate <class _Up, bool>
Nstruct __decay {
N    typedef typename remove_cv<_Up>::type type;
N};
N
Ntemplate <class _Up>
Nstruct __decay<_Up, true> {
Npublic:
N    typedef typename conditional
N                     <
N                         is_array<_Up>::value,
N                         typename remove_extent<_Up>::type*,
N                         typename conditional
N                         <
N                              is_function<_Up>::value,
N                              typename add_pointer<_Up>::type,
N                              typename remove_cv<_Up>::type
N                         >::type
N                     >::type type;
N};
N
Ntemplate <class _Tp>
Nstruct _LIBCPP_TEMPLATE_VIS decay
Xstruct  decay
N{
Nprivate:
N    typedef typename remove_reference<_Tp>::type _Up;
Npublic:
N    typedef typename __decay<_Up, __is_referenceable<_Up>::value>::type type;
N};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _Tp> using decay_t = typename decay<_Tp>::type;
N#endif
N
N// is_abstract
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_abstract
Xtemplate <class _Tp> struct  is_abstract
N    : public integral_constant<bool, __is_abstract(_Tp)> {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_abstract_v
S    = is_abstract<_Tp>::value;
N#endif
N
N// is_final
N
N#if defined(_LIBCPP_HAS_IS_FINAL)
X#if 1L
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS
Xtemplate <class _Tp> struct 
N__libcpp_is_final : public integral_constant<bool, __is_final(_Tp)> {};
N#else
Stemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS
S__libcpp_is_final : public false_type {};
N#endif
N
N#if defined(_LIBCPP_HAS_IS_FINAL) && _LIBCPP_STD_VER > 11
X#if 1L && 14 > 11
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS
Xtemplate <class _Tp> struct 
Nis_final : public integral_constant<bool, __is_final(_Tp)> {};
N#endif
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_final_v
S    = is_final<_Tp>::value;
N#endif
N
N// is_aggregate
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_IS_AGGREGATE)
X#if 14 > 14 && !1L
S
Stemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS
Sis_aggregate : public integral_constant<bool, __is_aggregate(_Tp)> {};
S
S#if !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
Stemplate <class _Tp>
Sconstexpr bool is_aggregate_v = is_aggregate<_Tp>::value;
S#endif
S
N#endif // _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_IS_AGGREGATE)
N
N// is_base_of
N
N#ifdef _LIBCPP_HAS_IS_BASE_OF
N
Ntemplate <class _Bp, class _Dp>
Nstruct _LIBCPP_TEMPLATE_VIS is_base_of
Xstruct  is_base_of
N    : public integral_constant<bool, __is_base_of(_Bp, _Dp)> {};
N
N#else  // _LIBCPP_HAS_IS_BASE_OF
S
Snamespace __is_base_of_imp
S{
Stemplate <class _Tp>
Sstruct _Dst
S{
S    _Dst(const volatile _Tp &);
S};
Stemplate <class _Tp>
Sstruct _Src
S{
S    operator const volatile _Tp &();
S    template <class _Up> operator const _Dst<_Up> &();
S};
Stemplate <size_t> struct __one { typedef char type; };
Stemplate <class _Bp, class _Dp> typename __one<sizeof(_Dst<_Bp>(declval<_Src<_Dp> >()))>::type __test(int);
Stemplate <class _Bp, class _Dp> __two __test(...);
S}
S
Stemplate <class _Bp, class _Dp>
Sstruct _LIBCPP_TEMPLATE_VIS is_base_of
S    : public integral_constant<bool, is_class<_Bp>::value &&
S                                     sizeof(__is_base_of_imp::__test<_Bp, _Dp>(0)) == 2> {};
S
N#endif  // _LIBCPP_HAS_IS_BASE_OF
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Bp, class _Dp> _LIBCPP_CONSTEXPR bool is_base_of_v
S    = is_base_of<_Bp, _Dp>::value;
N#endif
N
N// is_convertible
N
N#if __has_feature(is_convertible_to) && !defined(_LIBCPP_USE_IS_CONVERTIBLE_FALLBACK)
X#if 1 && !0L
N
Ntemplate <class _T1, class _T2> struct _LIBCPP_TEMPLATE_VIS is_convertible
Xtemplate <class _T1, class _T2> struct  is_convertible
N    : public integral_constant<bool, __is_convertible_to(_T1, _T2) &&
N                                     !is_abstract<_T2>::value> {};
N
N#else  // __has_feature(is_convertible_to)
S
Snamespace __is_convertible_imp
S{
Stemplate <class _Tp> void  __test_convert(_Tp);
S
Stemplate <class _From, class _To, class = void>
Sstruct __is_convertible_test : public false_type {};
S
Stemplate <class _From, class _To>
Sstruct __is_convertible_test<_From, _To,
S    decltype(_VSTD::__is_convertible_imp::__test_convert<_To>(_VSTD::declval<_From>()))> : public true_type
S{};
S
Stemplate <class _Tp, bool _IsArray =    is_array<_Tp>::value,
S                     bool _IsFunction = is_function<_Tp>::value,
S                     bool _IsVoid =     is_void<_Tp>::value>
S                     struct __is_array_function_or_void                          {enum __attribute__((packed)) {value = 0};};
Stemplate <class _Tp> struct __is_array_function_or_void<_Tp, true, false, false> {enum __attribute__((packed)) {value = 1};};
Stemplate <class _Tp> struct __is_array_function_or_void<_Tp, false, true, false> {enum __attribute__((packed)) {value = 2};};
Stemplate <class _Tp> struct __is_array_function_or_void<_Tp, false, false, true> {enum __attribute__((packed)) {value = 3};};
S}
S
Stemplate <class _Tp,
S    unsigned = __is_convertible_imp::__is_array_function_or_void<typename remove_reference<_Tp>::type>::value>
Sstruct __is_convertible_check
S{
S    static const size_t __v = 0;
S};
S
Stemplate <class _Tp>
Sstruct __is_convertible_check<_Tp, 0>
S{
S    static const size_t __v = sizeof(_Tp);
S};
S
Stemplate <class _T1, class _T2,
S    unsigned _T1_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T1>::value,
S    unsigned _T2_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T2>::value>
Sstruct __is_convertible
S    : public integral_constant<bool,
S        __is_convertible_imp::__is_convertible_test<_T1, _T2>::value
S#if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)
S         && !(!is_function<_T1>::value && !is_reference<_T1>::value && is_reference<_T2>::value
S              && (!is_const<typename remove_reference<_T2>::type>::value
S                  || is_volatile<typename remove_reference<_T2>::type>::value)
S                  && (is_same<typename remove_cv<_T1>::type,
S                              typename remove_cv<typename remove_reference<_T2>::type>::type>::value
S                      || is_base_of<typename remove_reference<_T2>::type, _T1>::value))
S#endif
S    >
S{};
S
Stemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 1> : public false_type {};
Stemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 1> : public false_type {};
Stemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 1> : public false_type {};
Stemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 1> : public false_type {};
S
Stemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 2> : public false_type {};
Stemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 2> : public false_type {};
Stemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 2> : public false_type {};
Stemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 2> : public false_type {};
S
Stemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 3> : public false_type {};
Stemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 3> : public false_type {};
Stemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 3> : public false_type {};
Stemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 3> : public true_type {};
S
Stemplate <class _T1, class _T2> struct _LIBCPP_TEMPLATE_VIS is_convertible
S    : public __is_convertible<_T1, _T2>
S{
S    static const size_t __complete_check1 = __is_convertible_check<_T1>::__v;
S    static const size_t __complete_check2 = __is_convertible_check<_T2>::__v;
S};
S
N#endif  // __has_feature(is_convertible_to)
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _From, class _To> _LIBCPP_CONSTEXPR bool is_convertible_v
S    = is_convertible<_From, _To>::value;
N#endif
N
N// is_empty
N
N#if __has_feature(is_empty) || (_GNUC_VER >= 407)
X#if 1 || (0 >= 407)
N
Ntemplate <class _Tp>
Nstruct _LIBCPP_TEMPLATE_VIS is_empty
Xstruct  is_empty
N    : public integral_constant<bool, __is_empty(_Tp)> {};
N
N#else  // __has_feature(is_empty)
S
Stemplate <class _Tp>
Sstruct __is_empty1
S    : public _Tp
S{
S    double __lx;
S};
S
Sstruct __is_empty2
S{
S    double __lx;
S};
S
Stemplate <class _Tp, bool = is_class<_Tp>::value>
Sstruct __libcpp_empty : public integral_constant<bool, sizeof(__is_empty1<_Tp>) == sizeof(__is_empty2)> {};
S
Stemplate <class _Tp> struct __libcpp_empty<_Tp, false> : public false_type {};
S
Stemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_empty : public __libcpp_empty<_Tp> {};
S
N#endif  // __has_feature(is_empty)
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_empty_v
S    = is_empty<_Tp>::value;
N#endif
N
N// is_polymorphic
N
N#if __has_feature(is_polymorphic) || defined(_LIBCPP_COMPILER_MSVC)
X#if 1 || 0L
N
Ntemplate <class _Tp>
Nstruct _LIBCPP_TEMPLATE_VIS is_polymorphic
Xstruct  is_polymorphic
N    : public integral_constant<bool, __is_polymorphic(_Tp)> {};
N
N#else
S
Stemplate<typename _Tp> char &__is_polymorphic_impl(
S    typename enable_if<sizeof((_Tp*)dynamic_cast<const volatile void*>(declval<_Tp*>())) != 0,
S                       int>::type);
Stemplate<typename _Tp> __two &__is_polymorphic_impl(...);
S
Stemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_polymorphic
S    : public integral_constant<bool, sizeof(__is_polymorphic_impl<_Tp>(0)) == 1> {};
S
N#endif // __has_feature(is_polymorphic)
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_polymorphic_v
S    = is_polymorphic<_Tp>::value;
N#endif
N
N// has_virtual_destructor
N
N#if __has_feature(has_virtual_destructor) || (_GNUC_VER >= 403)
X#if 1 || (0 >= 403)
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS has_virtual_destructor
Xtemplate <class _Tp> struct  has_virtual_destructor
N    : public integral_constant<bool, __has_virtual_destructor(_Tp)> {};
N
N#else
S
Stemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS has_virtual_destructor
S    : public false_type {};
S
N#endif
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool has_virtual_destructor_v
S    = has_virtual_destructor<_Tp>::value;
N#endif
N
N// alignment_of
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS alignment_of
Xtemplate <class _Tp> struct  alignment_of
N    : public integral_constant<size_t, __alignof__(_Tp)> {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR size_t alignment_of_v
S    = alignment_of<_Tp>::value;
N#endif
N
N// aligned_storage
N
Ntemplate <class _Hp, class _Tp>
Nstruct __type_list
N{
N    typedef _Hp _Head;
N    typedef _Tp _Tail;
N};
N
Nstruct __nat
N{
N#ifndef _LIBCPP_CXX03_LANG
N    __nat() = delete;
N    __nat(const __nat&) = delete;
N    __nat& operator=(const __nat&) = delete;
N    ~__nat() = delete;
N#endif
N};
N
Ntemplate <class _Tp>
Nstruct __align_type
N{
N    static const size_t value = alignment_of<_Tp>::value;
N    typedef _Tp type;
N};
N
Nstruct __struct_double {long double __lx;};
Nstruct __struct_double4 {double __lx[4];};
N
Ntypedef
N    __type_list<__align_type<unsigned char>,
N    __type_list<__align_type<unsigned short>,
N    __type_list<__align_type<unsigned int>,
N    __type_list<__align_type<unsigned long>,
N    __type_list<__align_type<unsigned long long>,
N    __type_list<__align_type<double>,
N    __type_list<__align_type<long double>,
N    __type_list<__align_type<__struct_double>,
N    __type_list<__align_type<__struct_double4>,
N    __type_list<__align_type<int*>,
N    __nat
N    > > > > > > > > > > __all_types;
N
Ntemplate <class _TL, size_t _Align> struct __find_pod;
N
Ntemplate <class _Hp, size_t _Align>
Nstruct __find_pod<__type_list<_Hp, __nat>, _Align>
N{
N    typedef typename conditional<
N                             _Align == _Hp::value,
N                             typename _Hp::type,
N                             void
N                         >::type type;
N};
N
Ntemplate <class _Hp, class _Tp, size_t _Align>
Nstruct __find_pod<__type_list<_Hp, _Tp>, _Align>
N{
N    typedef typename conditional<
N                             _Align == _Hp::value,
N                             typename _Hp::type,
N                             typename __find_pod<_Tp, _Align>::type
N                         >::type type;
N};
N
Ntemplate <class _TL, size_t _Len> struct __find_max_align;
N
Ntemplate <class _Hp, size_t _Len>
Nstruct __find_max_align<__type_list<_Hp, __nat>, _Len> : public integral_constant<size_t, _Hp::value> {};
N
Ntemplate <size_t _Len, size_t _A1, size_t _A2>
Nstruct __select_align
N{
Nprivate:
N    static const size_t __min = _A2 < _A1 ? _A2 : _A1;
N    static const size_t __max = _A1 < _A2 ? _A2 : _A1;
Npublic:
N    static const size_t value = _Len < __max ? __min : __max;
N};
N
Ntemplate <class _Hp, class _Tp, size_t _Len>
Nstruct __find_max_align<__type_list<_Hp, _Tp>, _Len>
N    : public integral_constant<size_t, __select_align<_Len, _Hp::value, __find_max_align<_Tp, _Len>::value>::value> {};
N
Ntemplate <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>
Nstruct _LIBCPP_TEMPLATE_VIS aligned_storage
Xstruct  aligned_storage
N{
N    typedef typename __find_pod<__all_types, _Align>::type _Aligner;
N    static_assert(!is_void<_Aligner>::value, "");
N    union type
N    {
N        _Aligner __align;
N        unsigned char __data[(_Len + _Align - 1)/_Align * _Align];
N    };
N};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>
N    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;
N#endif
N
N#define _CREATE_ALIGNED_STORAGE_SPECIALIZATION(n) \
Ntemplate <size_t _Len>\
Nstruct _LIBCPP_TEMPLATE_VIS aligned_storage<_Len, n>\
N{\
N    struct _ALIGNAS(n) type\
N    {\
N        unsigned char __lx[(_Len + n - 1)/n * n];\
N    };\
N}
X#define _CREATE_ALIGNED_STORAGE_SPECIALIZATION(n) template <size_t _Len>struct _LIBCPP_TEMPLATE_VIS aligned_storage<_Len, n>{    struct _ALIGNAS(n) type    {        unsigned char __lx[(_Len + n - 1)/n * n];    };}
N
N_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x1);
Xtemplate <size_t _Len>struct  aligned_storage<_Len, 0x1>{ struct alignas(0x1) type { unsigned char __lx[(_Len + 0x1 - 1)/0x1 * 0x1]; };};
N_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x2);
Xtemplate <size_t _Len>struct  aligned_storage<_Len, 0x2>{ struct alignas(0x2) type { unsigned char __lx[(_Len + 0x2 - 1)/0x2 * 0x2]; };};
N_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x4);
Xtemplate <size_t _Len>struct  aligned_storage<_Len, 0x4>{ struct alignas(0x4) type { unsigned char __lx[(_Len + 0x4 - 1)/0x4 * 0x4]; };};
N_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x8);
Xtemplate <size_t _Len>struct  aligned_storage<_Len, 0x8>{ struct alignas(0x8) type { unsigned char __lx[(_Len + 0x8 - 1)/0x8 * 0x8]; };};
N_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x10);
Xtemplate <size_t _Len>struct  aligned_storage<_Len, 0x10>{ struct alignas(0x10) type { unsigned char __lx[(_Len + 0x10 - 1)/0x10 * 0x10]; };};
N_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x20);
Xtemplate <size_t _Len>struct  aligned_storage<_Len, 0x20>{ struct alignas(0x20) type { unsigned char __lx[(_Len + 0x20 - 1)/0x20 * 0x20]; };};
N_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x40);
Xtemplate <size_t _Len>struct  aligned_storage<_Len, 0x40>{ struct alignas(0x40) type { unsigned char __lx[(_Len + 0x40 - 1)/0x40 * 0x40]; };};
N_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x80);
Xtemplate <size_t _Len>struct  aligned_storage<_Len, 0x80>{ struct alignas(0x80) type { unsigned char __lx[(_Len + 0x80 - 1)/0x80 * 0x80]; };};
N_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x100);
Xtemplate <size_t _Len>struct  aligned_storage<_Len, 0x100>{ struct alignas(0x100) type { unsigned char __lx[(_Len + 0x100 - 1)/0x100 * 0x100]; };};
N_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x200);
Xtemplate <size_t _Len>struct  aligned_storage<_Len, 0x200>{ struct alignas(0x200) type { unsigned char __lx[(_Len + 0x200 - 1)/0x200 * 0x200]; };};
N_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x400);
Xtemplate <size_t _Len>struct  aligned_storage<_Len, 0x400>{ struct alignas(0x400) type { unsigned char __lx[(_Len + 0x400 - 1)/0x400 * 0x400]; };};
N_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x800);
Xtemplate <size_t _Len>struct  aligned_storage<_Len, 0x800>{ struct alignas(0x800) type { unsigned char __lx[(_Len + 0x800 - 1)/0x800 * 0x800]; };};
N_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x1000);
Xtemplate <size_t _Len>struct  aligned_storage<_Len, 0x1000>{ struct alignas(0x1000) type { unsigned char __lx[(_Len + 0x1000 - 1)/0x1000 * 0x1000]; };};
N_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x2000);
Xtemplate <size_t _Len>struct  aligned_storage<_Len, 0x2000>{ struct alignas(0x2000) type { unsigned char __lx[(_Len + 0x2000 - 1)/0x2000 * 0x2000]; };};
N// PE/COFF does not support alignment beyond 8192 (=0x2000)
N#if !defined(_LIBCPP_OBJECT_FORMAT_COFF)
X#if !0L
N_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x4000);
Xtemplate <size_t _Len>struct  aligned_storage<_Len, 0x4000>{ struct alignas(0x4000) type { unsigned char __lx[(_Len + 0x4000 - 1)/0x4000 * 0x4000]; };};
N#endif // !defined(_LIBCPP_OBJECT_FORMAT_COFF)
N
N#undef _CREATE_ALIGNED_STORAGE_SPECIALIZATION
N
N#ifndef _LIBCPP_HAS_NO_VARIADICS
N
N// aligned_union
N
Ntemplate <size_t _I0, size_t ..._In>
Nstruct __static_max;
N
Ntemplate <size_t _I0>
Nstruct __static_max<_I0>
N{
N    static const size_t value = _I0;
N};
N
Ntemplate <size_t _I0, size_t _I1, size_t ..._In>
Nstruct __static_max<_I0, _I1, _In...>
N{
N    static const size_t value = _I0 >= _I1 ? __static_max<_I0, _In...>::value :
N                                             __static_max<_I1, _In...>::value;
N};
N
Ntemplate <size_t _Len, class _Type0, class ..._Types>
Nstruct aligned_union
N{
N    static const size_t alignment_value = __static_max<__alignof__(_Type0),
N                                                       __alignof__(_Types)...>::value;
N    static const size_t __len = __static_max<_Len, sizeof(_Type0),
N                                             sizeof(_Types)...>::value;
N    typedef typename aligned_storage<__len, alignment_value>::type type;
N};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <size_t _Len, class ..._Types> using aligned_union_t = typename aligned_union<_Len, _Types...>::type;
N#endif
N
N#endif  // _LIBCPP_HAS_NO_VARIADICS
N
Ntemplate <class _Tp>
Nstruct __numeric_type
N{
N   static void __test(...);
N   static float __test(float);
N   static double __test(char);
N   static double __test(int);
N   static double __test(unsigned);
N   static double __test(long);
N   static double __test(unsigned long);
N   static double __test(long long);
N   static double __test(unsigned long long);
N   static double __test(double);
N   static long double __test(long double);
N
N   typedef decltype(__test(declval<_Tp>())) type;
N   static const bool value = !is_same<type, void>::value;
N};
N
Ntemplate <>
Nstruct __numeric_type<void>
N{
N   static const bool value = true;
N};
N
N// __promote
N
Ntemplate <class _A1, class _A2 = void, class _A3 = void,
N          bool = __numeric_type<_A1>::value &&
N                 __numeric_type<_A2>::value &&
N                 __numeric_type<_A3>::value>
Nclass __promote_imp
N{
Npublic:
N    static const bool value = false;
N};
N
Ntemplate <class _A1, class _A2, class _A3>
Nclass __promote_imp<_A1, _A2, _A3, true>
N{
Nprivate:
N    typedef typename __promote_imp<_A1>::type __type1;
N    typedef typename __promote_imp<_A2>::type __type2;
N    typedef typename __promote_imp<_A3>::type __type3;
Npublic:
N    typedef decltype(__type1() + __type2() + __type3()) type;
N    static const bool value = true;
N};
N
Ntemplate <class _A1, class _A2>
Nclass __promote_imp<_A1, _A2, void, true>
N{
Nprivate:
N    typedef typename __promote_imp<_A1>::type __type1;
N    typedef typename __promote_imp<_A2>::type __type2;
Npublic:
N    typedef decltype(__type1() + __type2()) type;
N    static const bool value = true;
N};
N
Ntemplate <class _A1>
Nclass __promote_imp<_A1, void, void, true>
N{
Npublic:
N    typedef typename __numeric_type<_A1>::type type;
N    static const bool value = true;
N};
N
Ntemplate <class _A1, class _A2 = void, class _A3 = void>
Nclass __promote : public __promote_imp<_A1, _A2, _A3> {};
N
N// make_signed / make_unsigned
N
Ntypedef
N    __type_list<signed char,
N    __type_list<signed short,
N    __type_list<signed int,
N    __type_list<signed long,
N    __type_list<signed long long,
N#ifndef _LIBCPP_HAS_NO_INT128
S    __type_list<__int128_t,
N#endif
N    __nat
N#ifndef _LIBCPP_HAS_NO_INT128
S    >
N#endif
N    > > > > > __signed_types;
N
Ntypedef
N    __type_list<unsigned char,
N    __type_list<unsigned short,
N    __type_list<unsigned int,
N    __type_list<unsigned long,
N    __type_list<unsigned long long,
N#ifndef _LIBCPP_HAS_NO_INT128
S    __type_list<__uint128_t,
N#endif
N    __nat
N#ifndef _LIBCPP_HAS_NO_INT128
S    >
N#endif
N    > > > > > __unsigned_types;
N
Ntemplate <class _TypeList, size_t _Size, bool = _Size <= sizeof(typename _TypeList::_Head)> struct __find_first;
N
Ntemplate <class _Hp, class _Tp, size_t _Size>
Nstruct __find_first<__type_list<_Hp, _Tp>, _Size, true>
N{
N    typedef _Hp type;
N};
N
Ntemplate <class _Hp, class _Tp, size_t _Size>
Nstruct __find_first<__type_list<_Hp, _Tp>, _Size, false>
N{
N    typedef typename __find_first<_Tp, _Size>::type type;
N};
N
Ntemplate <class _Tp, class _Up, bool = is_const<typename remove_reference<_Tp>::type>::value,
N                             bool = is_volatile<typename remove_reference<_Tp>::type>::value>
Nstruct __apply_cv
N{
N    typedef _Up type;
N};
N
Ntemplate <class _Tp, class _Up>
Nstruct __apply_cv<_Tp, _Up, true, false>
N{
N    typedef const _Up type;
N};
N
Ntemplate <class _Tp, class _Up>
Nstruct __apply_cv<_Tp, _Up, false, true>
N{
N    typedef volatile _Up type;
N};
N
Ntemplate <class _Tp, class _Up>
Nstruct __apply_cv<_Tp, _Up, true, true>
N{
N    typedef const volatile _Up type;
N};
N
Ntemplate <class _Tp, class _Up>
Nstruct __apply_cv<_Tp&, _Up, false, false>
N{
N    typedef _Up& type;
N};
N
Ntemplate <class _Tp, class _Up>
Nstruct __apply_cv<_Tp&, _Up, true, false>
N{
N    typedef const _Up& type;
N};
N
Ntemplate <class _Tp, class _Up>
Nstruct __apply_cv<_Tp&, _Up, false, true>
N{
N    typedef volatile _Up& type;
N};
N
Ntemplate <class _Tp, class _Up>
Nstruct __apply_cv<_Tp&, _Up, true, true>
N{
N    typedef const volatile _Up& type;
N};
N
Ntemplate <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>
Nstruct __make_signed {};
N
Ntemplate <class _Tp>
Nstruct __make_signed<_Tp, true>
N{
N    typedef typename __find_first<__signed_types, sizeof(_Tp)>::type type;
N};
N
Ntemplate <> struct __make_signed<bool,               true> {};
Ntemplate <> struct __make_signed<  signed short,     true> {typedef short     type;};
Ntemplate <> struct __make_signed<unsigned short,     true> {typedef short     type;};
Ntemplate <> struct __make_signed<  signed int,       true> {typedef int       type;};
Ntemplate <> struct __make_signed<unsigned int,       true> {typedef int       type;};
Ntemplate <> struct __make_signed<  signed long,      true> {typedef long      type;};
Ntemplate <> struct __make_signed<unsigned long,      true> {typedef long      type;};
Ntemplate <> struct __make_signed<  signed long long, true> {typedef long long type;};
Ntemplate <> struct __make_signed<unsigned long long, true> {typedef long long type;};
N#ifndef _LIBCPP_HAS_NO_INT128
Stemplate <> struct __make_signed<__int128_t,         true> {typedef __int128_t type;};
Stemplate <> struct __make_signed<__uint128_t,        true> {typedef __int128_t type;};
N#endif
N
Ntemplate <class _Tp>
Nstruct _LIBCPP_TEMPLATE_VIS make_signed
Xstruct  make_signed
N{
N    typedef typename __apply_cv<_Tp, typename __make_signed<typename remove_cv<_Tp>::type>::type>::type type;
N};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _Tp> using make_signed_t = typename make_signed<_Tp>::type;
N#endif
N
Ntemplate <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>
Nstruct __make_unsigned {};
N
Ntemplate <class _Tp>
Nstruct __make_unsigned<_Tp, true>
N{
N    typedef typename __find_first<__unsigned_types, sizeof(_Tp)>::type type;
N};
N
Ntemplate <> struct __make_unsigned<bool,               true> {};
Ntemplate <> struct __make_unsigned<  signed short,     true> {typedef unsigned short     type;};
Ntemplate <> struct __make_unsigned<unsigned short,     true> {typedef unsigned short     type;};
Ntemplate <> struct __make_unsigned<  signed int,       true> {typedef unsigned int       type;};
Ntemplate <> struct __make_unsigned<unsigned int,       true> {typedef unsigned int       type;};
Ntemplate <> struct __make_unsigned<  signed long,      true> {typedef unsigned long      type;};
Ntemplate <> struct __make_unsigned<unsigned long,      true> {typedef unsigned long      type;};
Ntemplate <> struct __make_unsigned<  signed long long, true> {typedef unsigned long long type;};
Ntemplate <> struct __make_unsigned<unsigned long long, true> {typedef unsigned long long type;};
N#ifndef _LIBCPP_HAS_NO_INT128
Stemplate <> struct __make_unsigned<__int128_t,         true> {typedef __uint128_t        type;};
Stemplate <> struct __make_unsigned<__uint128_t,        true> {typedef __uint128_t        type;};
N#endif
N
Ntemplate <class _Tp>
Nstruct _LIBCPP_TEMPLATE_VIS make_unsigned
Xstruct  make_unsigned
N{
N    typedef typename __apply_cv<_Tp, typename __make_unsigned<typename remove_cv<_Tp>::type>::type>::type type;
N};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _Tp> using make_unsigned_t = typename make_unsigned<_Tp>::type;
N#endif
N
N#ifdef _LIBCPP_HAS_NO_VARIADICS
S
Stemplate <class _Tp, class _Up = void, class _Vp = void>
Sstruct _LIBCPP_TEMPLATE_VIS common_type
S{
Spublic:
S    typedef typename common_type<typename common_type<_Tp, _Up>::type, _Vp>::type type;
S};
S
Stemplate <>
Sstruct _LIBCPP_TEMPLATE_VIS common_type<void, void, void>
S{
Spublic:
S    typedef void type;
S};
S
Stemplate <class _Tp>
Sstruct _LIBCPP_TEMPLATE_VIS common_type<_Tp, void, void>
S{
Spublic:
S    typedef typename common_type<_Tp, _Tp>::type type;
S};
S
Stemplate <class _Tp, class _Up>
Sstruct _LIBCPP_TEMPLATE_VIS common_type<_Tp, _Up, void>
S{
S    typedef typename decay<decltype(
S        true ? _VSTD::declval<_Tp>() : _VSTD::declval<_Up>()
S      )>::type type;
S};
S
N#else  // _LIBCPP_HAS_NO_VARIADICS
N
N// bullet 1 - sizeof...(Tp) == 0
N
Ntemplate <class ..._Tp>
Nstruct _LIBCPP_TEMPLATE_VIS common_type {};
Xstruct  common_type {};
N
N// bullet 2 - sizeof...(Tp) == 1
N
Ntemplate <class _Tp>
Nstruct _LIBCPP_TEMPLATE_VIS common_type<_Tp>
Xstruct  common_type<_Tp>
N    : public common_type<_Tp, _Tp> {};
N
N// bullet 3 - sizeof...(Tp) == 2
N
Ntemplate <class _Tp, class _Up, class = void>
Nstruct __common_type2_imp {};
N
Ntemplate <class _Tp, class _Up>
Nstruct __common_type2_imp<_Tp, _Up,
N    typename __void_t<decltype(
N        true ? _VSTD::declval<_Tp>() : _VSTD::declval<_Up>()
X        true ? std::__2::declval<_Tp>() : std::__2::declval<_Up>()
N    )>::type>
N{
N    typedef typename decay<decltype(
N        true ? _VSTD::declval<_Tp>() : _VSTD::declval<_Up>()
X        true ? std::__2::declval<_Tp>() : std::__2::declval<_Up>()
N    )>::type type;
N};
N
Ntemplate <class _Tp, class _Up,
N          class _DTp = typename decay<_Tp>::type,
N          class _DUp = typename decay<_Up>::type>
Nusing __common_type2 =
N  typename conditional<
N    is_same<_Tp, _DTp>::value && is_same<_Up, _DUp>::value,
N    __common_type2_imp<_Tp, _Up>,
N    common_type<_DTp, _DUp>
N  >::type;
N
Ntemplate <class _Tp, class _Up>
Nstruct _LIBCPP_TEMPLATE_VIS common_type<_Tp, _Up>
Xstruct  common_type<_Tp, _Up>
N    : __common_type2<_Tp, _Up> {};
N
N// bullet 4 - sizeof...(Tp) > 2
N
Ntemplate <class ...Tp> struct __common_types;
N
Ntemplate <class, class = void>
Nstruct __common_type_impl {};
N
Ntemplate <class _Tp, class _Up>
Nstruct __common_type_impl<
N    __common_types<_Tp, _Up>,
N    typename __void_t<typename common_type<_Tp, _Up>::type>::type>
N{
N  typedef typename common_type<_Tp, _Up>::type type;
N};
N
Ntemplate <class _Tp, class _Up, class ..._Vp>
Nstruct __common_type_impl<__common_types<_Tp, _Up, _Vp...>,
N    typename __void_t<typename common_type<_Tp, _Up>::type>::type>
N  : __common_type_impl<
N      __common_types<typename common_type<_Tp, _Up>::type, _Vp...> >
N{
N
N};
N
Ntemplate <class _Tp, class _Up, class ..._Vp>
Nstruct _LIBCPP_TEMPLATE_VIS common_type<_Tp, _Up, _Vp...>
Xstruct  common_type<_Tp, _Up, _Vp...>
N    : __common_type_impl<__common_types<_Tp, _Up, _Vp...> > {};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class ..._Tp> using common_type_t = typename common_type<_Tp...>::type;
N#endif
N
N#endif  // _LIBCPP_HAS_NO_VARIADICS
N
N// is_assignable
N
Ntemplate<typename, typename _Tp> struct __select_2nd { typedef _Tp type; };
N
Ntemplate <class _Tp, class _Arg>
Ntypename __select_2nd<decltype((_VSTD::declval<_Tp>() = _VSTD::declval<_Arg>())), true_type>::type
Xtypename __select_2nd<decltype((std::__2::declval<_Tp>() = std::__2::declval<_Arg>())), true_type>::type
N__is_assignable_test(int);
N
Ntemplate <class, class>
Nfalse_type __is_assignable_test(...);
N
N
Ntemplate <class _Tp, class _Arg, bool = is_void<_Tp>::value || is_void<_Arg>::value>
Nstruct __is_assignable_imp
N    : public decltype((_VSTD::__is_assignable_test<_Tp, _Arg>(0))) {};
X    : public decltype((std::__2::__is_assignable_test<_Tp, _Arg>(0))) {};
N
Ntemplate <class _Tp, class _Arg>
Nstruct __is_assignable_imp<_Tp, _Arg, true>
N    : public false_type
N{
N};
N
Ntemplate <class _Tp, class _Arg>
Nstruct is_assignable
N    : public __is_assignable_imp<_Tp, _Arg> {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp, class _Arg> _LIBCPP_CONSTEXPR bool is_assignable_v
S    = is_assignable<_Tp, _Arg>::value;
N#endif
N
N// is_copy_assignable
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_copy_assignable
Xtemplate <class _Tp> struct  is_copy_assignable
N    : public is_assignable<typename add_lvalue_reference<_Tp>::type,
N                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_copy_assignable_v
S    = is_copy_assignable<_Tp>::value;
N#endif
N
N// is_move_assignable
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_move_assignable
Xtemplate <class _Tp> struct  is_move_assignable
N#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
N    : public is_assignable<typename add_lvalue_reference<_Tp>::type,
N                           typename add_rvalue_reference<_Tp>::type> {};
N#else
S    : public is_copy_assignable<_Tp> {};
N#endif
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_move_assignable_v
S    = is_move_assignable<_Tp>::value;
N#endif
N
N// is_destructible
N
N//  if it's a reference, return true
N//  if it's a function, return false
N//  if it's   void,     return false
N//  if it's an array of unknown bound, return false
N//  Otherwise, return "std::declval<_Up&>().~_Up()" is well-formed
N//    where _Up is remove_all_extents<_Tp>::type
N
Ntemplate <class>
Nstruct __is_destructible_apply { typedef int type; };
N
Ntemplate <typename _Tp>
Nstruct __is_destructor_wellformed {
N    template <typename _Tp1>
N    static char  __test (
N        typename __is_destructible_apply<decltype(_VSTD::declval<_Tp1&>().~_Tp1())>::type
X        typename __is_destructible_apply<decltype(std::__2::declval<_Tp1&>().~_Tp1())>::type
N    );
N
N    template <typename _Tp1>
N    static __two __test (...);
N    
N    static const bool value = sizeof(__test<_Tp>(12)) == sizeof(char);
N};
N
Ntemplate <class _Tp, bool>
Nstruct __destructible_imp;
N
Ntemplate <class _Tp>
Nstruct __destructible_imp<_Tp, false> 
N   : public _VSTD::integral_constant<bool, 
X   : public std::__2::integral_constant<bool, 
N        __is_destructor_wellformed<typename _VSTD::remove_all_extents<_Tp>::type>::value> {};
X        __is_destructor_wellformed<typename std::__2::remove_all_extents<_Tp>::type>::value> {};
N
Ntemplate <class _Tp>
Nstruct __destructible_imp<_Tp, true>
N    : public _VSTD::true_type {};
X    : public std::__2::true_type {};
N
Ntemplate <class _Tp, bool>
Nstruct __destructible_false;
N
Ntemplate <class _Tp>
Nstruct __destructible_false<_Tp, false> : public __destructible_imp<_Tp, _VSTD::is_reference<_Tp>::value> {};
Xstruct __destructible_false<_Tp, false> : public __destructible_imp<_Tp, std::__2::is_reference<_Tp>::value> {};
N
Ntemplate <class _Tp>
Nstruct __destructible_false<_Tp, true> : public _VSTD::false_type {};
Xstruct __destructible_false<_Tp, true> : public std::__2::false_type {};
N
Ntemplate <class _Tp>
Nstruct is_destructible
N    : public __destructible_false<_Tp, _VSTD::is_function<_Tp>::value> {};
X    : public __destructible_false<_Tp, std::__2::is_function<_Tp>::value> {};
N
Ntemplate <class _Tp>
Nstruct is_destructible<_Tp[]>
N    : public _VSTD::false_type {};
X    : public std::__2::false_type {};
N
Ntemplate <>
Nstruct is_destructible<void>
N    : public _VSTD::false_type {};
X    : public std::__2::false_type {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_destructible_v
S    = is_destructible<_Tp>::value;
N#endif
N
N// move
N
N#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
Xinline __attribute__ ((__always_inline__)) constexpr
Ntypename remove_reference<_Tp>::type&&
Nmove(_Tp&& __t) _NOEXCEPT
Xmove(_Tp&& __t) noexcept
N{
N    typedef typename remove_reference<_Tp>::type _Up;
N    return static_cast<_Up&&>(__t);
N}
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
Xinline __attribute__ ((__always_inline__)) constexpr
N_Tp&&
Nforward(typename remove_reference<_Tp>::type& __t) _NOEXCEPT
Xforward(typename remove_reference<_Tp>::type& __t) noexcept
N{
N    return static_cast<_Tp&&>(__t);
N}
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
Xinline __attribute__ ((__always_inline__)) constexpr
N_Tp&&
Nforward(typename remove_reference<_Tp>::type&& __t) _NOEXCEPT
Xforward(typename remove_reference<_Tp>::type&& __t) noexcept
N{
N    static_assert(!is_lvalue_reference<_Tp>::value,
N                  "can not forward an rvalue as an lvalue");
N    return static_cast<_Tp&&>(__t);
N}
N
N#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
S
Stemplate <class _Tp>
Sinline _LIBCPP_INLINE_VISIBILITY
S_Tp&
Smove(_Tp& __t)
S{
S    return __t;
S}
S
Stemplate <class _Tp>
Sinline _LIBCPP_INLINE_VISIBILITY
Sconst _Tp&
Smove(const _Tp& __t)
S{
S    return __t;
S}
S
Stemplate <class _Tp>
Sinline _LIBCPP_INLINE_VISIBILITY
S_Tp&
Sforward(typename remove_reference<_Tp>::type& __t) _NOEXCEPT
S{
S    return __t;
S}
S
S
Stemplate <class _Tp>
Sclass __rv
S{
S    typedef typename remove_reference<_Tp>::type _Trr;
S    _Trr& t_;
Spublic:
S    _LIBCPP_INLINE_VISIBILITY
S    _Trr* operator->() {return &t_;}
S    _LIBCPP_INLINE_VISIBILITY
S    explicit __rv(_Trr& __t) : t_(__t) {}
S};
S
N#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
N
N#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename decay<_Tp>::type
N__decay_copy(_Tp&& __t)
N{
N    return _VSTD::forward<_Tp>(__t);
X    return std::__2::forward<_Tp>(__t);
N}
N
N#else
S
Stemplate <class _Tp>
Sinline _LIBCPP_INLINE_VISIBILITY
Stypename decay<_Tp>::type
S__decay_copy(const _Tp& __t)
S{
S    return _VSTD::forward<_Tp>(__t);
S}
S
N#endif
N
N#ifndef _LIBCPP_HAS_NO_VARIADICS
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...), true, false>
N{
N    typedef _Class _ClassType;
N    typedef _Rp _ReturnType;
N    typedef _Rp (_FnType) (_Param...);
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...), true, false>
N{
N    typedef _Class _ClassType;
N    typedef _Rp _ReturnType;
N    typedef _Rp (_FnType) (_Param..., ...);
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const, true, false>
N{
N    typedef _Class const _ClassType;
N    typedef _Rp _ReturnType;
N    typedef _Rp (_FnType) (_Param...);
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const, true, false>
N{
N    typedef _Class const _ClassType;
N    typedef _Rp _ReturnType;
N    typedef _Rp (_FnType) (_Param..., ...);
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile, true, false>
N{
N    typedef _Class volatile _ClassType;
N    typedef _Rp _ReturnType;
N    typedef _Rp (_FnType) (_Param...);
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile, true, false>
N{
N    typedef _Class volatile _ClassType;
N    typedef _Rp _ReturnType;
N    typedef _Rp (_FnType) (_Param..., ...);
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile, true, false>
N{
N    typedef _Class const volatile _ClassType;
N    typedef _Rp _ReturnType;
N    typedef _Rp (_FnType) (_Param...);
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile, true, false>
N{
N    typedef _Class const volatile _ClassType;
N    typedef _Rp _ReturnType;
N    typedef _Rp (_FnType) (_Param..., ...);
N};
N
N#if __has_feature(cxx_reference_qualified_functions) || \
N    (defined(_GNUC_VER) && _GNUC_VER >= 409)
X#if 1 ||     (1L && 0 >= 409)
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &, true, false>
N{
N    typedef _Class& _ClassType;
N    typedef _Rp _ReturnType;
N    typedef _Rp (_FnType) (_Param...);
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &, true, false>
N{
N    typedef _Class& _ClassType;
N    typedef _Rp _ReturnType;
N    typedef _Rp (_FnType) (_Param..., ...);
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&, true, false>
N{
N    typedef _Class const& _ClassType;
N    typedef _Rp _ReturnType;
N    typedef _Rp (_FnType) (_Param...);
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&, true, false>
N{
N    typedef _Class const& _ClassType;
N    typedef _Rp _ReturnType;
N    typedef _Rp (_FnType) (_Param..., ...);
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&, true, false>
N{
N    typedef _Class volatile& _ClassType;
N    typedef _Rp _ReturnType;
N    typedef _Rp (_FnType) (_Param...);
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&, true, false>
N{
N    typedef _Class volatile& _ClassType;
N    typedef _Rp _ReturnType;
N    typedef _Rp (_FnType) (_Param..., ...);
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&, true, false>
N{
N    typedef _Class const volatile& _ClassType;
N    typedef _Rp _ReturnType;
N    typedef _Rp (_FnType) (_Param...);
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&, true, false>
N{
N    typedef _Class const volatile& _ClassType;
N    typedef _Rp _ReturnType;
N    typedef _Rp (_FnType) (_Param..., ...);
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &&, true, false>
N{
N    typedef _Class&& _ClassType;
N    typedef _Rp _ReturnType;
N    typedef _Rp (_FnType) (_Param...);
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &&, true, false>
N{
N    typedef _Class&& _ClassType;
N    typedef _Rp _ReturnType;
N    typedef _Rp (_FnType) (_Param..., ...);
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&&, true, false>
N{
N    typedef _Class const&& _ClassType;
N    typedef _Rp _ReturnType;
N    typedef _Rp (_FnType) (_Param...);
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&&, true, false>
N{
N    typedef _Class const&& _ClassType;
N    typedef _Rp _ReturnType;
N    typedef _Rp (_FnType) (_Param..., ...);
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&&, true, false>
N{
N    typedef _Class volatile&& _ClassType;
N    typedef _Rp _ReturnType;
N    typedef _Rp (_FnType) (_Param...);
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&&, true, false>
N{
N    typedef _Class volatile&& _ClassType;
N    typedef _Rp _ReturnType;
N    typedef _Rp (_FnType) (_Param..., ...);
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&&, true, false>
N{
N    typedef _Class const volatile&& _ClassType;
N    typedef _Rp _ReturnType;
N    typedef _Rp (_FnType) (_Param...);
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&&, true, false>
N{
N    typedef _Class const volatile&& _ClassType;
N    typedef _Rp _ReturnType;
N    typedef _Rp (_FnType) (_Param..., ...);
N};
N
N#endif  // __has_feature(cxx_reference_qualified_functions) || _GNUC_VER >= 409
N
N#else  // _LIBCPP_HAS_NO_VARIADICS
S
Stemplate <class _Rp, class _Class>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)(), true, false>
S{
S    typedef _Class _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) ();
S};
S
Stemplate <class _Rp, class _Class>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)(...), true, false>
S{
S    typedef _Class _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) (...);
S};
S
Stemplate <class _Rp, class _Class, class _P0>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0), true, false>
S{
S    typedef _Class _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) (_P0);
S};
S
Stemplate <class _Rp, class _Class, class _P0>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...), true, false>
S{
S    typedef _Class _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) (_P0, ...);
S};
S
Stemplate <class _Rp, class _Class, class _P0, class _P1>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1), true, false>
S{
S    typedef _Class _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) (_P0, _P1);
S};
S
Stemplate <class _Rp, class _Class, class _P0, class _P1>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...), true, false>
S{
S    typedef _Class _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) (_P0, _P1, ...);
S};
S
Stemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2), true, false>
S{
S    typedef _Class _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) (_P0, _P1, _P2);
S};
S
Stemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...), true, false>
S{
S    typedef _Class _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);
S};
S
Stemplate <class _Rp, class _Class>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)() const, true, false>
S{
S    typedef _Class const _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) ();
S};
S
Stemplate <class _Rp, class _Class>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)(...) const, true, false>
S{
S    typedef _Class const _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) (...);
S};
S
Stemplate <class _Rp, class _Class, class _P0>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const, true, false>
S{
S    typedef _Class const _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) (_P0);
S};
S
Stemplate <class _Rp, class _Class, class _P0>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) const, true, false>
S{
S    typedef _Class const _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) (_P0, ...);
S};
S
Stemplate <class _Rp, class _Class, class _P0, class _P1>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const, true, false>
S{
S    typedef _Class const _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) (_P0, _P1);
S};
S
Stemplate <class _Rp, class _Class, class _P0, class _P1>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) const, true, false>
S{
S    typedef _Class const _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) (_P0, _P1, ...);
S};
S
Stemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const, true, false>
S{
S    typedef _Class const _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) (_P0, _P1, _P2);
S};
S
Stemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) const, true, false>
S{
S    typedef _Class const _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);
S};
S
Stemplate <class _Rp, class _Class>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)() volatile, true, false>
S{
S    typedef _Class volatile _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) ();
S};
S
Stemplate <class _Rp, class _Class>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)(...) volatile, true, false>
S{
S    typedef _Class volatile _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) (...);
S};
S
Stemplate <class _Rp, class _Class, class _P0>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) volatile, true, false>
S{
S    typedef _Class volatile _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) (_P0);
S};
S
Stemplate <class _Rp, class _Class, class _P0>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) volatile, true, false>
S{
S    typedef _Class volatile _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) (_P0, ...);
S};
S
Stemplate <class _Rp, class _Class, class _P0, class _P1>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) volatile, true, false>
S{
S    typedef _Class volatile _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) (_P0, _P1);
S};
S
Stemplate <class _Rp, class _Class, class _P0, class _P1>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) volatile, true, false>
S{
S    typedef _Class volatile _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) (_P0, _P1, ...);
S};
S
Stemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) volatile, true, false>
S{
S    typedef _Class volatile _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) (_P0, _P1, _P2);
S};
S
Stemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) volatile, true, false>
S{
S    typedef _Class volatile _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);
S};
S
Stemplate <class _Rp, class _Class>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)() const volatile, true, false>
S{
S    typedef _Class const volatile _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) ();
S};
S
Stemplate <class _Rp, class _Class>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)(...) const volatile, true, false>
S{
S    typedef _Class const volatile _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) (...);
S};
S
Stemplate <class _Rp, class _Class, class _P0>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const volatile, true, false>
S{
S    typedef _Class const volatile _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) (_P0);
S};
S
Stemplate <class _Rp, class _Class, class _P0>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) const volatile, true, false>
S{
S    typedef _Class const volatile _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) (_P0, ...);
S};
S
Stemplate <class _Rp, class _Class, class _P0, class _P1>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const volatile, true, false>
S{
S    typedef _Class const volatile _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) (_P0, _P1);
S};
S
Stemplate <class _Rp, class _Class, class _P0, class _P1>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) const volatile, true, false>
S{
S    typedef _Class const volatile _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) (_P0, _P1, ...);
S};
S
Stemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const volatile, true, false>
S{
S    typedef _Class const volatile _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) (_P0, _P1, _P2);
S};
S
Stemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>
Sstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) const volatile, true, false>
S{
S    typedef _Class const volatile _ClassType;
S    typedef _Rp _ReturnType;
S    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);
S};
S
N#endif  // _LIBCPP_HAS_NO_VARIADICS
N
Ntemplate <class _Rp, class _Class>
Nstruct __member_pointer_traits_imp<_Rp _Class::*, false, true>
N{
N    typedef _Class _ClassType;
N    typedef _Rp _ReturnType;
N};
N
Ntemplate <class _MP>
Nstruct __member_pointer_traits
N    : public __member_pointer_traits_imp<typename remove_cv<_MP>::type,
N                    is_member_function_pointer<_MP>::value,
N                    is_member_object_pointer<_MP>::value>
N{
N//     typedef ... _ClassType;
N//     typedef ... _ReturnType;
N//     typedef ... _FnType;
N};
N
N
Ntemplate <class _DecayedFp>
Nstruct __member_pointer_class_type {};
N
Ntemplate <class _Ret, class _ClassType>
Nstruct __member_pointer_class_type<_Ret _ClassType::*> {
N  typedef _ClassType type;
N};
N
N// result_of
N
Ntemplate <class _Callable> class result_of;
N
N#ifdef _LIBCPP_HAS_NO_VARIADICS
S
Stemplate <class _Fn, bool, bool>
Sclass __result_of
S{
S};
S
Stemplate <class _Fn>
Sclass __result_of<_Fn(), true, false>
S{
Spublic:
S    typedef decltype(declval<_Fn>()()) type;
S};
S
Stemplate <class _Fn, class _A0>
Sclass __result_of<_Fn(_A0), true, false>
S{
Spublic:
S    typedef decltype(declval<_Fn>()(declval<_A0>())) type;
S};
S
Stemplate <class _Fn, class _A0, class _A1>
Sclass __result_of<_Fn(_A0, _A1), true, false>
S{
Spublic:
S    typedef decltype(declval<_Fn>()(declval<_A0>(), declval<_A1>())) type;
S};
S
Stemplate <class _Fn, class _A0, class _A1, class _A2>
Sclass __result_of<_Fn(_A0, _A1, _A2), true, false>
S{
Spublic:
S    typedef decltype(declval<_Fn>()(declval<_A0>(), declval<_A1>(), declval<_A2>())) type;
S};
S
Stemplate <class _MP, class _Tp, bool _IsMemberFunctionPtr>
Sstruct __result_of_mp;
S
S// member function pointer
S
Stemplate <class _MP, class _Tp>
Sstruct __result_of_mp<_MP, _Tp, true>
S    : public __identity<typename __member_pointer_traits<_MP>::_ReturnType>
S{
S};
S
S// member data pointer
S
Stemplate <class _MP, class _Tp, bool>
Sstruct __result_of_mdp;
S
Stemplate <class _Rp, class _Class, class _Tp>
Sstruct __result_of_mdp<_Rp _Class::*, _Tp, false>
S{
S    typedef typename __apply_cv<decltype(*_VSTD::declval<_Tp>()), _Rp>::type& type;
S};
S
Stemplate <class _Rp, class _Class, class _Tp>
Sstruct __result_of_mdp<_Rp _Class::*, _Tp, true>
S{
S    typedef typename __apply_cv<_Tp, _Rp>::type& type;
S};
S
Stemplate <class _Rp, class _Class, class _Tp>
Sstruct __result_of_mp<_Rp _Class::*, _Tp, false>
S    : public __result_of_mdp<_Rp _Class::*, _Tp,
S            is_base_of<_Class, typename remove_reference<_Tp>::type>::value>
S{
S};
S
S
S
Stemplate <class _Fn, class _Tp>
Sclass __result_of<_Fn(_Tp), false, true>  // _Fn must be member pointer
S    : public __result_of_mp<typename remove_reference<_Fn>::type,
S                            _Tp,
S                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>
S{
S};
S
Stemplate <class _Fn, class _Tp, class _A0>
Sclass __result_of<_Fn(_Tp, _A0), false, true>  // _Fn must be member pointer
S    : public __result_of_mp<typename remove_reference<_Fn>::type,
S                            _Tp,
S                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>
S{
S};
S
Stemplate <class _Fn, class _Tp, class _A0, class _A1>
Sclass __result_of<_Fn(_Tp, _A0, _A1), false, true>  // _Fn must be member pointer
S    : public __result_of_mp<typename remove_reference<_Fn>::type,
S                            _Tp,
S                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>
S{
S};
S
Stemplate <class _Fn, class _Tp, class _A0, class _A1, class _A2>
Sclass __result_of<_Fn(_Tp, _A0, _A1, _A2), false, true>  // _Fn must be member pointer
S    : public __result_of_mp<typename remove_reference<_Fn>::type,
S                            _Tp,
S                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>
S{
S};
S
S// result_of
S
Stemplate <class _Fn>
Sclass _LIBCPP_TEMPLATE_VIS result_of<_Fn()>
S    : public __result_of<_Fn(),
S                         is_class<typename remove_reference<_Fn>::type>::value ||
S                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,
S                         is_member_pointer<typename remove_reference<_Fn>::type>::value
S                        >
S{
S};
S
Stemplate <class _Fn, class _A0>
Sclass _LIBCPP_TEMPLATE_VIS result_of<_Fn(_A0)>
S    : public __result_of<_Fn(_A0),
S                         is_class<typename remove_reference<_Fn>::type>::value ||
S                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,
S                         is_member_pointer<typename remove_reference<_Fn>::type>::value
S                        >
S{
S};
S
Stemplate <class _Fn, class _A0, class _A1>
Sclass _LIBCPP_TEMPLATE_VIS result_of<_Fn(_A0, _A1)>
S    : public __result_of<_Fn(_A0, _A1),
S                         is_class<typename remove_reference<_Fn>::type>::value ||
S                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,
S                         is_member_pointer<typename remove_reference<_Fn>::type>::value
S                        >
S{
S};
S
Stemplate <class _Fn, class _A0, class _A1, class _A2>
Sclass _LIBCPP_TEMPLATE_VIS result_of<_Fn(_A0, _A1, _A2)>
S    : public __result_of<_Fn(_A0, _A1, _A2),
S                         is_class<typename remove_reference<_Fn>::type>::value ||
S                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,
S                         is_member_pointer<typename remove_reference<_Fn>::type>::value
S                        >
S{
S};
S
N#endif  // _LIBCPP_HAS_NO_VARIADICS
N
N// template <class T, class... Args> struct is_constructible;
N
Nnamespace __is_construct
N{
Nstruct __nat {};
N}
N
N#if !defined(_LIBCPP_CXX03_LANG) && (!__has_feature(is_constructible) || \
N    defined(_LIBCPP_TESTING_FALLBACK_IS_CONSTRUCTIBLE))
X#if !0L && (!0 ||     0L)
N
Ntemplate <class _Tp, class... _Args>
Nstruct __libcpp_is_constructible;
N
Ntemplate <class _To, class _From>
Nstruct __is_invalid_base_to_derived_cast {
N  static_assert(is_reference<_To>::value, "Wrong specialization");
N  using _RawFrom = __uncvref_t<_From>;
N  using _RawTo = __uncvref_t<_To>;
N  static const bool value = __lazy_and<
N        __lazy_not<is_same<_RawFrom, _RawTo>>,
N        is_base_of<_RawFrom, _RawTo>,
N        __lazy_not<__libcpp_is_constructible<_RawTo, _From>>
N  >::value;
N};
N
Ntemplate <class _To, class _From>
Nstruct __is_invalid_lvalue_to_rvalue_cast : false_type {
N  static_assert(is_reference<_To>::value, "Wrong specialization");
N};
N
Ntemplate <class _ToRef, class _FromRef>
Nstruct __is_invalid_lvalue_to_rvalue_cast<_ToRef&&, _FromRef&> {
N  using _RawFrom = __uncvref_t<_FromRef>;
N  using _RawTo = __uncvref_t<_ToRef>;
N  static const bool value = __lazy_and<
N      __lazy_not<is_function<_RawTo>>,
N      __lazy_or<
N        is_same<_RawFrom, _RawTo>,
N        is_base_of<_RawTo, _RawFrom>>
N    >::value;
N};
N
Nstruct __is_constructible_helper
N{
N    template <class _To>
N    static void __eat(_To);
N
N    // This overload is needed to work around a Clang bug that disallows
N    // static_cast<T&&>(e) for non-reference-compatible types.
N    // Example: static_cast<int&&>(declval<double>());
N    // NOTE: The static_cast implementation below is required to support
N    //  classes with explicit conversion operators.
N    template <class _To, class _From,
N              class = decltype(__eat<_To>(_VSTD::declval<_From>()))>
X              class = decltype(__eat<_To>(std::__2::declval<_From>()))>
N    static true_type __test_cast(int);
N
N    template <class _To, class _From,
N              class = decltype(static_cast<_To>(_VSTD::declval<_From>()))>
X              class = decltype(static_cast<_To>(std::__2::declval<_From>()))>
N    static integral_constant<bool,
N        !__is_invalid_base_to_derived_cast<_To, _From>::value &&
N        !__is_invalid_lvalue_to_rvalue_cast<_To, _From>::value
N    > __test_cast(long);
N
N    template <class, class>
N    static false_type __test_cast(...);
N
N    template <class _Tp, class ..._Args,
N        class = decltype(_Tp(_VSTD::declval<_Args>()...))>
X        class = decltype(_Tp(std::__2::declval<_Args>()...))>
N    static true_type __test_nary(int);
N    template <class _Tp, class...>
N    static false_type __test_nary(...);
N
N    template <class _Tp, class _A0, class = decltype(::new _Tp(_VSTD::declval<_A0>()))>
X    template <class _Tp, class _A0, class = decltype(::new _Tp(std::__2::declval<_A0>()))>
N    static is_destructible<_Tp> __test_unary(int);
N    template <class, class>
N    static false_type __test_unary(...);
N};
N
Ntemplate <class _Tp, bool = is_void<_Tp>::value>
Nstruct __is_default_constructible
N    : decltype(__is_constructible_helper::__test_nary<_Tp>(0))
N{};
N
Ntemplate <class _Tp>
Nstruct __is_default_constructible<_Tp, true> : false_type {};
N
Ntemplate <class _Tp>
Nstruct __is_default_constructible<_Tp[], false> : false_type {};
N
Ntemplate <class _Tp, size_t _Nx>
Nstruct __is_default_constructible<_Tp[_Nx], false>
N    : __is_default_constructible<typename remove_all_extents<_Tp>::type>  {};
N
Ntemplate <class _Tp, class... _Args>
Nstruct __libcpp_is_constructible
N{
N  static_assert(sizeof...(_Args) > 1, "Wrong specialization");
N  typedef decltype(__is_constructible_helper::__test_nary<_Tp, _Args...>(0))
N      type;
N};
N
Ntemplate <class _Tp>
Nstruct __libcpp_is_constructible<_Tp> : __is_default_constructible<_Tp> {};
N
Ntemplate <class _Tp, class _A0>
Nstruct __libcpp_is_constructible<_Tp, _A0>
N    : public decltype(__is_constructible_helper::__test_unary<_Tp, _A0>(0))
N{};
N
Ntemplate <class _Tp, class _A0>
Nstruct __libcpp_is_constructible<_Tp&, _A0>
N    : public decltype(__is_constructible_helper::
N    __test_cast<_Tp&, _A0>(0))
N{};
N
Ntemplate <class _Tp, class _A0>
Nstruct __libcpp_is_constructible<_Tp&&, _A0>
N    : public decltype(__is_constructible_helper::
N    __test_cast<_Tp&&, _A0>(0))
N{};
N
N#endif
N
N#if __has_feature(is_constructible)
X#if 0
Stemplate <class _Tp, class ..._Args>
Sstruct _LIBCPP_TEMPLATE_VIS is_constructible
S    : public integral_constant<bool, __is_constructible(_Tp, _Args...)>
S    {};
N#elif !defined(_LIBCPP_CXX03_LANG)
X#elif !0L
Ntemplate <class _Tp, class... _Args>
Nstruct _LIBCPP_TEMPLATE_VIS is_constructible
Xstruct  is_constructible
N    : public __libcpp_is_constructible<_Tp, _Args...>::type {};
N#else
S// template <class T> struct is_constructible0;
S
S//      main is_constructible0 test
S
Stemplate <class _Tp>
Sdecltype((_Tp(), true_type()))
S__is_constructible0_test(_Tp&);
S
Sfalse_type
S__is_constructible0_test(__any);
S
Stemplate <class _Tp, class _A0>
Sdecltype((_Tp(_VSTD::declval<_A0>()), true_type()))
S__is_constructible1_test(_Tp&, _A0&);
S
Stemplate <class _A0>
Sfalse_type
S__is_constructible1_test(__any, _A0&);
S
Stemplate <class _Tp, class _A0, class _A1>
Sdecltype((_Tp(_VSTD::declval<_A0>(), _VSTD::declval<_A1>()), true_type()))
S__is_constructible2_test(_Tp&, _A0&, _A1&);
S
Stemplate <class _A0, class _A1>
Sfalse_type
S__is_constructible2_test(__any, _A0&, _A1&);
S
Stemplate <bool, class _Tp>
Sstruct __is_constructible0_imp // false, _Tp is not a scalar
S    : public common_type
S             <
S                 decltype(__is_constructible0_test(declval<_Tp&>()))
S             >::type
S    {};
S
Stemplate <bool, class _Tp, class _A0>
Sstruct __is_constructible1_imp // false, _Tp is not a scalar
S    : public common_type
S             <
S                 decltype(__is_constructible1_test(declval<_Tp&>(), declval<_A0&>()))
S             >::type
S    {};
S
Stemplate <bool, class _Tp, class _A0, class _A1>
Sstruct __is_constructible2_imp // false, _Tp is not a scalar
S    : public common_type
S             <
S                 decltype(__is_constructible2_test(declval<_Tp&>(), declval<_A0>(), declval<_A1>()))
S             >::type
S    {};
S
S//      handle scalars and reference types
S
S//      Scalars are default constructible, references are not
S
Stemplate <class _Tp>
Sstruct __is_constructible0_imp<true, _Tp>
S    : public is_scalar<_Tp>
S    {};
S
Stemplate <class _Tp, class _A0>
Sstruct __is_constructible1_imp<true, _Tp, _A0>
S    : public is_convertible<_A0, _Tp>
S    {};
S
Stemplate <class _Tp, class _A0, class _A1>
Sstruct __is_constructible2_imp<true, _Tp, _A0, _A1>
S    : public false_type
S    {};
S
S//      Treat scalars and reference types separately
S
Stemplate <bool, class _Tp>
Sstruct __is_constructible0_void_check
S    : public __is_constructible0_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,
S                                _Tp>
S    {};
S
Stemplate <bool, class _Tp, class _A0>
Sstruct __is_constructible1_void_check
S    : public __is_constructible1_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,
S                                _Tp, _A0>
S    {};
S
Stemplate <bool, class _Tp, class _A0, class _A1>
Sstruct __is_constructible2_void_check
S    : public __is_constructible2_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,
S                                _Tp, _A0, _A1>
S    {};
S
S//      If any of T or Args is void, is_constructible should be false
S
Stemplate <class _Tp>
Sstruct __is_constructible0_void_check<true, _Tp>
S    : public false_type
S    {};
S
Stemplate <class _Tp, class _A0>
Sstruct __is_constructible1_void_check<true, _Tp, _A0>
S    : public false_type
S    {};
S
Stemplate <class _Tp, class _A0, class _A1>
Sstruct __is_constructible2_void_check<true, _Tp, _A0, _A1>
S    : public false_type
S    {};
S
S//      is_constructible entry point
S
Stemplate <class _Tp, class _A0 = __is_construct::__nat,
S                     class _A1 = __is_construct::__nat>
Sstruct _LIBCPP_TEMPLATE_VIS is_constructible
S    : public __is_constructible2_void_check<is_void<_Tp>::value
S                                        || is_abstract<_Tp>::value
S                                        || is_function<_Tp>::value
S                                        || is_void<_A0>::value
S                                        || is_void<_A1>::value,
S                                           _Tp, _A0, _A1>
S    {};
S
Stemplate <class _Tp>
Sstruct _LIBCPP_TEMPLATE_VIS is_constructible<_Tp, __is_construct::__nat, __is_construct::__nat>
S    : public __is_constructible0_void_check<is_void<_Tp>::value
S                                        || is_abstract<_Tp>::value
S                                        || is_function<_Tp>::value,
S                                           _Tp>
S    {};
S
Stemplate <class _Tp, class _A0>
Sstruct _LIBCPP_TEMPLATE_VIS is_constructible<_Tp, _A0, __is_construct::__nat>
S    : public __is_constructible1_void_check<is_void<_Tp>::value
S                                        || is_abstract<_Tp>::value
S                                        || is_function<_Tp>::value
S                                        || is_void<_A0>::value,
S                                           _Tp, _A0>
S    {};
S
S//      Array types are default constructible if their element type
S//      is default constructible
S
Stemplate <class _Ap, size_t _Np>
Sstruct __is_constructible0_imp<false, _Ap[_Np]>
S    : public is_constructible<typename remove_all_extents<_Ap>::type>
S    {};
S
Stemplate <class _Ap, size_t _Np, class _A0>
Sstruct __is_constructible1_imp<false, _Ap[_Np], _A0>
S    : public false_type
S    {};
S
Stemplate <class _Ap, size_t _Np, class _A0, class _A1>
Sstruct __is_constructible2_imp<false, _Ap[_Np], _A0, _A1>
S    : public false_type
S    {};
S
S//      Incomplete array types are not constructible
S
Stemplate <class _Ap>
Sstruct __is_constructible0_imp<false, _Ap[]>
S    : public false_type
S    {};
S
Stemplate <class _Ap, class _A0>
Sstruct __is_constructible1_imp<false, _Ap[], _A0>
S    : public false_type
S    {};
S
Stemplate <class _Ap, class _A0, class _A1>
Sstruct __is_constructible2_imp<false, _Ap[], _A0, _A1>
S    : public false_type
S    {};
S
N#endif // __has_feature(is_constructible)
N
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES) && !defined(_LIBCPP_HAS_NO_VARIADICS)
X#if 14 > 14 && !0L && !0L
Stemplate <class _Tp, class ..._Args> _LIBCPP_CONSTEXPR bool is_constructible_v
S    = is_constructible<_Tp, _Args...>::value;
N#endif
N
N// is_default_constructible
N
Ntemplate <class _Tp>
Nstruct _LIBCPP_TEMPLATE_VIS is_default_constructible
Xstruct  is_default_constructible
N    : public is_constructible<_Tp>
N    {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_default_constructible_v
S    = is_default_constructible<_Tp>::value;
N#endif
N
N// is_copy_constructible
N
Ntemplate <class _Tp>
Nstruct _LIBCPP_TEMPLATE_VIS is_copy_constructible
Xstruct  is_copy_constructible
N    : public is_constructible<_Tp, 
N                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_copy_constructible_v
S    = is_copy_constructible<_Tp>::value;
N#endif
N
N// is_move_constructible
N
Ntemplate <class _Tp>
Nstruct _LIBCPP_TEMPLATE_VIS is_move_constructible
Xstruct  is_move_constructible
N#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
N    : public is_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>
N#else
S    : public is_copy_constructible<_Tp>
N#endif
N    {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_move_constructible_v
S    = is_move_constructible<_Tp>::value;
N#endif
N
N// is_trivially_constructible
N
N#ifndef _LIBCPP_HAS_NO_VARIADICS
N
N#if __has_feature(is_trivially_constructible) || _GNUC_VER >= 501
X#if 1 || 0 >= 501
N
Ntemplate <class _Tp, class... _Args>
Nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible
Xstruct  is_trivially_constructible
N    : integral_constant<bool, __is_trivially_constructible(_Tp, _Args...)>
N{
N};
N
N#else  // !__has_feature(is_trivially_constructible)
S
Stemplate <class _Tp, class... _Args>
Sstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible
S    : false_type
S{
S};
S
Stemplate <class _Tp>
Sstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp>
S#if __has_feature(has_trivial_constructor) || (_GNUC_VER >= 403)
S    : integral_constant<bool, __has_trivial_constructor(_Tp)>
S#else
S    : integral_constant<bool, is_scalar<_Tp>::value>
S#endif
S{
S};
S
Stemplate <class _Tp>
S#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
Sstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp&&>
S#else
Sstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp>
S#endif
S    : integral_constant<bool, is_scalar<_Tp>::value>
S{
S};
S
Stemplate <class _Tp>
Sstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, const _Tp&>
S    : integral_constant<bool, is_scalar<_Tp>::value>
S{
S};
S
Stemplate <class _Tp>
Sstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp&>
S    : integral_constant<bool, is_scalar<_Tp>::value>
S{
S};
S
N#endif  // !__has_feature(is_trivially_constructible)
N
N#else  // _LIBCPP_HAS_NO_VARIADICS
S
Stemplate <class _Tp, class _A0 = __is_construct::__nat,
S                     class _A1 = __is_construct::__nat>
Sstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible
S    : false_type
S{
S};
S
S#if __has_feature(is_trivially_constructible) || _GNUC_VER >= 501
S
Stemplate <class _Tp>
Sstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, __is_construct::__nat,
S                                                       __is_construct::__nat>
S    : integral_constant<bool, __is_trivially_constructible(_Tp)>
S{
S};
S
Stemplate <class _Tp>
Sstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp,
S                                                       __is_construct::__nat>
S    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp)>
S{
S};
S
Stemplate <class _Tp>
Sstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, const _Tp&,
S                                                       __is_construct::__nat>
S    : integral_constant<bool, __is_trivially_constructible(_Tp, const _Tp&)>
S{
S};
S
Stemplate <class _Tp>
Sstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp&,
S                                                       __is_construct::__nat>
S    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp&)>
S{
S};
S
S#else  // !__has_feature(is_trivially_constructible)
S
Stemplate <class _Tp>
Sstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, __is_construct::__nat,
S                                                       __is_construct::__nat>
S    : integral_constant<bool, is_scalar<_Tp>::value>
S{
S};
S
Stemplate <class _Tp>
Sstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp,
S                                                       __is_construct::__nat>
S    : integral_constant<bool, is_scalar<_Tp>::value>
S{
S};
S
Stemplate <class _Tp>
Sstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, const _Tp&,
S                                                       __is_construct::__nat>
S    : integral_constant<bool, is_scalar<_Tp>::value>
S{
S};
S
Stemplate <class _Tp>
Sstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp&,
S                                                       __is_construct::__nat>
S    : integral_constant<bool, is_scalar<_Tp>::value>
S{
S};
S
S#endif  // !__has_feature(is_trivially_constructible)
S
N#endif  // _LIBCPP_HAS_NO_VARIADICS
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES) && !defined(_LIBCPP_HAS_NO_VARIADICS)
X#if 14 > 14 && !0L && !0L
Stemplate <class _Tp, class... _Args> _LIBCPP_CONSTEXPR bool is_trivially_constructible_v
S    = is_trivially_constructible<_Tp, _Args...>::value;
N#endif
N
N// is_trivially_default_constructible
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_default_constructible
Xtemplate <class _Tp> struct  is_trivially_default_constructible
N    : public is_trivially_constructible<_Tp>
N    {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_default_constructible_v
S    = is_trivially_default_constructible<_Tp>::value;
N#endif
N
N// is_trivially_copy_constructible
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_copy_constructible
Xtemplate <class _Tp> struct  is_trivially_copy_constructible
N    : public is_trivially_constructible<_Tp, typename add_lvalue_reference<const _Tp>::type>
N    {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_copy_constructible_v
S    = is_trivially_copy_constructible<_Tp>::value;
N#endif
N
N// is_trivially_move_constructible
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_move_constructible
Xtemplate <class _Tp> struct  is_trivially_move_constructible
N#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
N    : public is_trivially_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>
N#else
S    : public is_trivially_copy_constructible<_Tp>
N#endif
N    {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_move_constructible_v
S    = is_trivially_move_constructible<_Tp>::value;
N#endif
N
N// is_trivially_assignable
N
N#if __has_feature(is_trivially_assignable) || _GNUC_VER >= 501
X#if 1 || 0 >= 501
N
Ntemplate <class _Tp, class _Arg>
Nstruct is_trivially_assignable
N    : integral_constant<bool, __is_trivially_assignable(_Tp, _Arg)>
N{
N};
N
N#else  // !__has_feature(is_trivially_assignable)
S
Stemplate <class _Tp, class _Arg>
Sstruct is_trivially_assignable
S    : public false_type {};
S
Stemplate <class _Tp>
Sstruct is_trivially_assignable<_Tp&, _Tp>
S    : integral_constant<bool, is_scalar<_Tp>::value> {};
S
Stemplate <class _Tp>
Sstruct is_trivially_assignable<_Tp&, _Tp&>
S    : integral_constant<bool, is_scalar<_Tp>::value> {};
S
Stemplate <class _Tp>
Sstruct is_trivially_assignable<_Tp&, const _Tp&>
S    : integral_constant<bool, is_scalar<_Tp>::value> {};
S
S#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
S
Stemplate <class _Tp>
Sstruct is_trivially_assignable<_Tp&, _Tp&&>
S    : integral_constant<bool, is_scalar<_Tp>::value> {};
S
S#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
S
N#endif  // !__has_feature(is_trivially_assignable)
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp, class _Arg> _LIBCPP_CONSTEXPR bool is_trivially_assignable_v
S    = is_trivially_assignable<_Tp, _Arg>::value;
N#endif
N
N// is_trivially_copy_assignable
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_copy_assignable
Xtemplate <class _Tp> struct  is_trivially_copy_assignable
N    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,
N                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_copy_assignable_v
S    = is_trivially_copy_assignable<_Tp>::value;
N#endif
N
N// is_trivially_move_assignable
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_move_assignable
Xtemplate <class _Tp> struct  is_trivially_move_assignable
N    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,
N#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
N                                     typename add_rvalue_reference<_Tp>::type>
N#else
S                                     typename add_lvalue_reference<_Tp>::type>
N#endif
N    {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_move_assignable_v
S    = is_trivially_move_assignable<_Tp>::value;
N#endif
N
N// is_trivially_destructible
N
N#if __has_feature(has_trivial_destructor) || (_GNUC_VER >= 403)
X#if 1 || (0 >= 403)
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_destructible
Xtemplate <class _Tp> struct  is_trivially_destructible
N    : public integral_constant<bool, is_destructible<_Tp>::value && __has_trivial_destructor(_Tp)> {};
N
N#else
S
Stemplate <class _Tp> struct __libcpp_trivial_destructor
S    : public integral_constant<bool, is_scalar<_Tp>::value ||
S                                     is_reference<_Tp>::value> {};
S
Stemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_destructible
S    : public __libcpp_trivial_destructor<typename remove_all_extents<_Tp>::type> {};
S
Stemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_destructible<_Tp[]>
S    : public false_type {};
S
N#endif
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_destructible_v
S    = is_trivially_destructible<_Tp>::value;
N#endif
N
N// is_nothrow_constructible
N
N#if 0
Stemplate <class _Tp, class... _Args>
Sstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible
S    : public integral_constant<bool, __is_nothrow_constructible(_Tp(_Args...))>
S{
S};
S
N#else
N
N#ifndef _LIBCPP_HAS_NO_VARIADICS
N
N#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)
X#if 1 || (0 >= 407 && 201402L >= 201103L)
N
Ntemplate <bool, bool, class _Tp, class... _Args> struct __libcpp_is_nothrow_constructible;
N
Ntemplate <class _Tp, class... _Args>
Nstruct __libcpp_is_nothrow_constructible</*is constructible*/true, /*is reference*/false, _Tp, _Args...>
N    : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>
N{
N};
N
Ntemplate <class _Tp>
Nvoid __implicit_conversion_to(_Tp) noexcept { }
N
Ntemplate <class _Tp, class _Arg>
Nstruct __libcpp_is_nothrow_constructible</*is constructible*/true, /*is reference*/true, _Tp, _Arg>
N    : public integral_constant<bool, noexcept(__implicit_conversion_to<_Tp>(declval<_Arg>()))>
N{
N};
N
Ntemplate <class _Tp, bool _IsReference, class... _Args>
Nstruct __libcpp_is_nothrow_constructible</*is constructible*/false, _IsReference, _Tp, _Args...>
N    : public false_type
N{
N};
N
Ntemplate <class _Tp, class... _Args>
Nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible
Xstruct  is_nothrow_constructible
N    : __libcpp_is_nothrow_constructible<is_constructible<_Tp, _Args...>::value, is_reference<_Tp>::value, _Tp, _Args...>
N{
N};
N
Ntemplate <class _Tp, size_t _Ns>
Nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp[_Ns]>
Xstruct  is_nothrow_constructible<_Tp[_Ns]>
N    : __libcpp_is_nothrow_constructible<is_constructible<_Tp>::value, is_reference<_Tp>::value, _Tp>
N{
N};
N
N#else  // __has_feature(cxx_noexcept)
S
Stemplate <class _Tp, class... _Args>
Sstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible
S    : false_type
S{
S};
S
Stemplate <class _Tp>
Sstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp>
S#if __has_feature(has_nothrow_constructor) || (_GNUC_VER >= 403)
S    : integral_constant<bool, __has_nothrow_constructor(_Tp)>
S#else
S    : integral_constant<bool, is_scalar<_Tp>::value>
S#endif
S{
S};
S
Stemplate <class _Tp>
S#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
Sstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp&&>
S#else
Sstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp>
S#endif
S#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)
S    : integral_constant<bool, __has_nothrow_copy(_Tp)>
S#else
S    : integral_constant<bool, is_scalar<_Tp>::value>
S#endif
S{
S};
S
Stemplate <class _Tp>
Sstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, const _Tp&>
S#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)
S    : integral_constant<bool, __has_nothrow_copy(_Tp)>
S#else
S    : integral_constant<bool, is_scalar<_Tp>::value>
S#endif
S{
S};
S
Stemplate <class _Tp>
Sstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp&>
S#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)
S    : integral_constant<bool, __has_nothrow_copy(_Tp)>
S#else
S    : integral_constant<bool, is_scalar<_Tp>::value>
S#endif
S{
S};
S
N#endif  // __has_feature(cxx_noexcept)
N
N#else  // _LIBCPP_HAS_NO_VARIADICS
S
Stemplate <class _Tp, class _A0 = __is_construct::__nat,
S                     class _A1 = __is_construct::__nat>
Sstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible
S    : false_type
S{
S};
S
Stemplate <class _Tp>
Sstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, __is_construct::__nat,
S                                                       __is_construct::__nat>
S#if __has_feature(has_nothrow_constructor) || (_GNUC_VER >= 403)
S    : integral_constant<bool, __has_nothrow_constructor(_Tp)>
S#else
S    : integral_constant<bool, is_scalar<_Tp>::value>
S#endif
S{
S};
S
Stemplate <class _Tp>
Sstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp,
S                                                       __is_construct::__nat>
S#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)
S    : integral_constant<bool, __has_nothrow_copy(_Tp)>
S#else
S    : integral_constant<bool, is_scalar<_Tp>::value>
S#endif
S{
S};
S
Stemplate <class _Tp>
Sstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, const _Tp&,
S                                                       __is_construct::__nat>
S#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)
S    : integral_constant<bool, __has_nothrow_copy(_Tp)>
S#else
S    : integral_constant<bool, is_scalar<_Tp>::value>
S#endif
S{
S};
S
Stemplate <class _Tp>
Sstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp&,
S                                                       __is_construct::__nat>
S#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)
S    : integral_constant<bool, __has_nothrow_copy(_Tp)>
S#else
S    : integral_constant<bool, is_scalar<_Tp>::value>
S#endif
S{
S};
S
N#endif  // _LIBCPP_HAS_NO_VARIADICS
N#endif  // __has_feature(is_nothrow_constructible)
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES) && !defined(_LIBCPP_HAS_NO_VARIADICS)
X#if 14 > 14 && !0L && !0L
Stemplate <class _Tp, class ..._Args> _LIBCPP_CONSTEXPR bool is_nothrow_constructible_v
S    = is_nothrow_constructible<_Tp, _Args...>::value;
N#endif
N
N// is_nothrow_default_constructible
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_default_constructible
Xtemplate <class _Tp> struct  is_nothrow_default_constructible
N    : public is_nothrow_constructible<_Tp>
N    {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_default_constructible_v
S    = is_nothrow_default_constructible<_Tp>::value;
N#endif
N
N// is_nothrow_copy_constructible
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_copy_constructible
Xtemplate <class _Tp> struct  is_nothrow_copy_constructible
N    : public is_nothrow_constructible<_Tp,
N                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_copy_constructible_v
S    = is_nothrow_copy_constructible<_Tp>::value;
N#endif
N
N// is_nothrow_move_constructible
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_move_constructible
Xtemplate <class _Tp> struct  is_nothrow_move_constructible
N#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
N    : public is_nothrow_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>
N#else
S    : public is_nothrow_copy_constructible<_Tp>
N#endif
N    {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_move_constructible_v
S    = is_nothrow_move_constructible<_Tp>::value;
N#endif
N
N// is_nothrow_assignable
N
N#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)
X#if 1 || (0 >= 407 && 201402L >= 201103L)
N
Ntemplate <bool, class _Tp, class _Arg> struct __libcpp_is_nothrow_assignable;
N
Ntemplate <class _Tp, class _Arg>
Nstruct __libcpp_is_nothrow_assignable<false, _Tp, _Arg>
N    : public false_type
N{
N};
N
Ntemplate <class _Tp, class _Arg>
Nstruct __libcpp_is_nothrow_assignable<true, _Tp, _Arg>
N    : public integral_constant<bool, noexcept(_VSTD::declval<_Tp>() = _VSTD::declval<_Arg>()) >
X    : public integral_constant<bool, noexcept(std::__2::declval<_Tp>() = std::__2::declval<_Arg>()) >
N{
N};
N
Ntemplate <class _Tp, class _Arg>
Nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable
Xstruct  is_nothrow_assignable
N    : public __libcpp_is_nothrow_assignable<is_assignable<_Tp, _Arg>::value, _Tp, _Arg>
N{
N};
N
N#else  // __has_feature(cxx_noexcept)
S
Stemplate <class _Tp, class _Arg>
Sstruct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable
S    : public false_type {};
S
Stemplate <class _Tp>
Sstruct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable<_Tp&, _Tp>
S#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)
S    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};
S#else
S    : integral_constant<bool, is_scalar<_Tp>::value> {};
S#endif
S
Stemplate <class _Tp>
Sstruct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable<_Tp&, _Tp&>
S#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)
S    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};
S#else
S    : integral_constant<bool, is_scalar<_Tp>::value> {};
S#endif
S
Stemplate <class _Tp>
Sstruct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable<_Tp&, const _Tp&>
S#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)
S    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};
S#else
S    : integral_constant<bool, is_scalar<_Tp>::value> {};
S#endif
S
S#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
S
Stemplate <class _Tp>
Sstruct is_nothrow_assignable<_Tp&, _Tp&&>
S#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)
S    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};
S#else
S    : integral_constant<bool, is_scalar<_Tp>::value> {};
S#endif
S
S#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
S
N#endif  // __has_feature(cxx_noexcept)
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp, class _Arg> _LIBCPP_CONSTEXPR bool is_nothrow_assignable_v
S    = is_nothrow_assignable<_Tp, _Arg>::value;
N#endif
N
N// is_nothrow_copy_assignable
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_copy_assignable
Xtemplate <class _Tp> struct  is_nothrow_copy_assignable
N    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,
N                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_copy_assignable_v
S    = is_nothrow_copy_assignable<_Tp>::value;
N#endif
N
N// is_nothrow_move_assignable
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_move_assignable
Xtemplate <class _Tp> struct  is_nothrow_move_assignable
N    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,
N#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
N                                     typename add_rvalue_reference<_Tp>::type>
N#else
S                                     typename add_lvalue_reference<_Tp>::type>
N#endif
N    {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_move_assignable_v
S    = is_nothrow_move_assignable<_Tp>::value;
N#endif
N
N// is_nothrow_destructible
N
N#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)
X#if 1 || (0 >= 407 && 201402L >= 201103L)
N
Ntemplate <bool, class _Tp> struct __libcpp_is_nothrow_destructible;
N
Ntemplate <class _Tp>
Nstruct __libcpp_is_nothrow_destructible<false, _Tp>
N    : public false_type
N{
N};
N
Ntemplate <class _Tp>
Nstruct __libcpp_is_nothrow_destructible<true, _Tp>
N    : public integral_constant<bool, noexcept(_VSTD::declval<_Tp>().~_Tp()) >
X    : public integral_constant<bool, noexcept(std::__2::declval<_Tp>().~_Tp()) >
N{
N};
N
Ntemplate <class _Tp>
Nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible
Xstruct  is_nothrow_destructible
N    : public __libcpp_is_nothrow_destructible<is_destructible<_Tp>::value, _Tp>
N{
N};
N
Ntemplate <class _Tp, size_t _Ns>
Nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible<_Tp[_Ns]>
Xstruct  is_nothrow_destructible<_Tp[_Ns]>
N    : public is_nothrow_destructible<_Tp>
N{
N};
N
Ntemplate <class _Tp>
Nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible<_Tp&>
Xstruct  is_nothrow_destructible<_Tp&>
N    : public true_type
N{
N};
N
N#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
N
Ntemplate <class _Tp>
Nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible<_Tp&&>
Xstruct  is_nothrow_destructible<_Tp&&>
N    : public true_type
N{
N};
N
N#endif
N
N#else
S
Stemplate <class _Tp> struct __libcpp_nothrow_destructor
S    : public integral_constant<bool, is_scalar<_Tp>::value ||
S                                     is_reference<_Tp>::value> {};
S
Stemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible
S    : public __libcpp_nothrow_destructor<typename remove_all_extents<_Tp>::type> {};
S
Stemplate <class _Tp>
Sstruct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible<_Tp[]>
S    : public false_type {};
S
N#endif
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_destructible_v
S    = is_nothrow_destructible<_Tp>::value;
N#endif
N
N// is_pod
N
N#if __has_feature(is_pod) || (_GNUC_VER >= 403)
X#if 1 || (0 >= 403)
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_pod
Xtemplate <class _Tp> struct  is_pod
N    : public integral_constant<bool, __is_pod(_Tp)> {};
N
N#else
S
Stemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_pod
S    : public integral_constant<bool, is_trivially_default_constructible<_Tp>::value   &&
S                                     is_trivially_copy_constructible<_Tp>::value      &&
S                                     is_trivially_copy_assignable<_Tp>::value    &&
S                                     is_trivially_destructible<_Tp>::value> {};
S
N#endif
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_pod_v
S    = is_pod<_Tp>::value;
N#endif
N
N// is_literal_type;
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_literal_type
Xtemplate <class _Tp> struct  is_literal_type
N#ifdef _LIBCPP_IS_LITERAL
N    : public integral_constant<bool, _LIBCPP_IS_LITERAL(_Tp)>
X    : public integral_constant<bool, __is_literal_type(_Tp)>
N#else
S    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value ||
S                              is_reference<typename remove_all_extents<_Tp>::type>::value>
N#endif
N    {};
N    
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_literal_type_v
S    = is_literal_type<_Tp>::value;
N#endif
N
N// is_standard_layout;
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_standard_layout
Xtemplate <class _Tp> struct  is_standard_layout
N#if __has_feature(is_standard_layout) || (_GNUC_VER >= 407)
X#if 1 || (0 >= 407)
N    : public integral_constant<bool, __is_standard_layout(_Tp)>
N#else
S    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value>
N#endif
N    {};
N    
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_standard_layout_v
S    = is_standard_layout<_Tp>::value;
N#endif
N
N// is_trivially_copyable;
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_copyable
Xtemplate <class _Tp> struct  is_trivially_copyable
N#if __has_feature(is_trivially_copyable)
X#if 1
N    : public integral_constant<bool, __is_trivially_copyable(_Tp)>
N#elif _GNUC_VER >= 501
S    : public integral_constant<bool, !is_volatile<_Tp>::value && __is_trivially_copyable(_Tp)>
S#else
S    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value>
N#endif
N    {};
N    
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_copyable_v
S    = is_trivially_copyable<_Tp>::value;
N#endif
N
N// is_trivial;
N
Ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivial
Xtemplate <class _Tp> struct  is_trivial
N#if __has_feature(is_trivial) || _GNUC_VER >= 407
X#if 1 || 0 >= 407
N    : public integral_constant<bool, __is_trivial(_Tp)>
N#else
S    : integral_constant<bool, is_trivially_copyable<_Tp>::value &&
S                                 is_trivially_default_constructible<_Tp>::value>
N#endif
N    {};
N
N#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
X#if 14 > 14 && !0L
Stemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivial_v
S    = is_trivial<_Tp>::value;
N#endif
N
Ntemplate <class _Tp> struct __is_reference_wrapper_impl : public false_type {};
Ntemplate <class _Tp> struct __is_reference_wrapper_impl<reference_wrapper<_Tp> > : public true_type {};
Ntemplate <class _Tp> struct __is_reference_wrapper
N    : public __is_reference_wrapper_impl<typename remove_cv<_Tp>::type> {};
N
N#ifndef _LIBCPP_CXX03_LANG
N
N// Check for complete types
N
Ntemplate <class ..._Tp> struct __check_complete;
N
Ntemplate <>
Nstruct __check_complete<>
N{
N};
N
Ntemplate <class _Hp, class _T0, class ..._Tp>
Nstruct __check_complete<_Hp, _T0, _Tp...>
N    : private __check_complete<_Hp>,
N      private __check_complete<_T0, _Tp...>
N{
N};
N
Ntemplate <class _Hp>
Nstruct __check_complete<_Hp, _Hp>
N    : private __check_complete<_Hp>
N{
N};
N
Ntemplate <class _Tp>
Nstruct __check_complete<_Tp>
N{
N    static_assert(sizeof(_Tp) > 0, "Type must be complete.");
N};
N
Ntemplate <class _Tp>
Nstruct __check_complete<_Tp&>
N    : private __check_complete<_Tp>
N{
N};
N
Ntemplate <class _Tp>
Nstruct __check_complete<_Tp&&>
N    : private __check_complete<_Tp>
N{
N};
N
Ntemplate <class _Rp, class ..._Param>
Nstruct __check_complete<_Rp (*)(_Param...)>
N    : private __check_complete<_Rp>
N{
N};
N
Ntemplate <class ..._Param>
Nstruct __check_complete<void (*)(_Param...)>
N{
N};
N
Ntemplate <class _Rp, class ..._Param>
Nstruct __check_complete<_Rp (_Param...)>
N    : private __check_complete<_Rp>
N{
N};
N
Ntemplate <class ..._Param>
Nstruct __check_complete<void (_Param...)>
N{
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __check_complete<_Rp (_Class::*)(_Param...)>
N    : private __check_complete<_Class>
N{
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __check_complete<_Rp (_Class::*)(_Param...) const>
N    : private __check_complete<_Class>
N{
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile>
N    : private __check_complete<_Class>
N{
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile>
N    : private __check_complete<_Class>
N{
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __check_complete<_Rp (_Class::*)(_Param...) &>
N    : private __check_complete<_Class>
N{
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __check_complete<_Rp (_Class::*)(_Param...) const&>
N    : private __check_complete<_Class>
N{
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile&>
N    : private __check_complete<_Class>
N{
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile&>
N    : private __check_complete<_Class>
N{
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __check_complete<_Rp (_Class::*)(_Param...) &&>
N    : private __check_complete<_Class>
N{
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __check_complete<_Rp (_Class::*)(_Param...) const&&>
N    : private __check_complete<_Class>
N{
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile&&>
N    : private __check_complete<_Class>
N{
N};
N
Ntemplate <class _Rp, class _Class, class ..._Param>
Nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile&&>
N    : private __check_complete<_Class>
N{
N};
N
Ntemplate <class _Rp, class _Class>
Nstruct __check_complete<_Rp _Class::*>
N    : private __check_complete<_Class>
N{
N};
N
N
Ntemplate <class _Fp, class _A0,
N         class _DecayFp = typename decay<_Fp>::type,
N         class _DecayA0 = typename decay<_A0>::type,
N         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
Nusing __enable_if_bullet1 = typename enable_if
N    <
N        is_member_function_pointer<_DecayFp>::value
N        && is_base_of<_ClassT, _DecayA0>::value
N    >::type;
N
Ntemplate <class _Fp, class _A0,
N         class _DecayFp = typename decay<_Fp>::type,
N         class _DecayA0 = typename decay<_A0>::type>
Nusing __enable_if_bullet2 = typename enable_if
N    <
N        is_member_function_pointer<_DecayFp>::value
N        && __is_reference_wrapper<_DecayA0>::value
N    >::type;
N
Ntemplate <class _Fp, class _A0,
N         class _DecayFp = typename decay<_Fp>::type,
N         class _DecayA0 = typename decay<_A0>::type,
N         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
Nusing __enable_if_bullet3 = typename enable_if
N    <
N        is_member_function_pointer<_DecayFp>::value
N        && !is_base_of<_ClassT, _DecayA0>::value
N        && !__is_reference_wrapper<_DecayA0>::value
N    >::type;
N
Ntemplate <class _Fp, class _A0,
N         class _DecayFp = typename decay<_Fp>::type,
N         class _DecayA0 = typename decay<_A0>::type,
N         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
Nusing __enable_if_bullet4 = typename enable_if
N    <
N        is_member_object_pointer<_DecayFp>::value
N        && is_base_of<_ClassT, _DecayA0>::value
N    >::type;
N
Ntemplate <class _Fp, class _A0,
N         class _DecayFp = typename decay<_Fp>::type,
N         class _DecayA0 = typename decay<_A0>::type>
Nusing __enable_if_bullet5 = typename enable_if
N    <
N        is_member_object_pointer<_DecayFp>::value
N        && __is_reference_wrapper<_DecayA0>::value
N    >::type;
N
Ntemplate <class _Fp, class _A0,
N         class _DecayFp = typename decay<_Fp>::type,
N         class _DecayA0 = typename decay<_A0>::type,
N         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
Nusing __enable_if_bullet6 = typename enable_if
N    <
N        is_member_object_pointer<_DecayFp>::value
N        && !is_base_of<_ClassT, _DecayA0>::value
N        && !__is_reference_wrapper<_DecayA0>::value
N    >::type;
N
N// __invoke forward declarations
N
N// fall back - none of the bullets
N
N#define _LIBCPP_INVOKE_RETURN(...) \
N    noexcept(noexcept(__VA_ARGS__)) -> decltype(__VA_ARGS__) \
N    { return __VA_ARGS__; }
X#define _LIBCPP_INVOKE_RETURN(...)     noexcept(noexcept(__VA_ARGS__)) -> decltype(__VA_ARGS__)     { return __VA_ARGS__; }
N
Ntemplate <class ..._Args>
Nauto __invoke(__any, _Args&& ...__args) -> __nat;
N
Ntemplate <class ..._Args>
Nauto __invoke_constexpr(__any, _Args&& ...__args) -> __nat;
N
N// bullets 1, 2 and 3
N
Ntemplate <class _Fp, class _A0, class ..._Args,
N          class = __enable_if_bullet1<_Fp, _A0>>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nauto
N__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
N_LIBCPP_INVOKE_RETURN((_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...))
Xnoexcept(noexcept((std::__2::forward<_A0>(__a0).*__f)(std::__2::forward<_Args>(__args)...))) -> decltype((std::__2::forward<_A0>(__a0).*__f)(std::__2::forward<_Args>(__args)...)) { return (std::__2::forward<_A0>(__a0).*__f)(std::__2::forward<_Args>(__args)...); }
N
Ntemplate <class _Fp, class _A0, class ..._Args,
N          class = __enable_if_bullet1<_Fp, _A0>>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_LIBCPP_CONSTEXPR auto
Xconstexpr auto
N__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
N_LIBCPP_INVOKE_RETURN((_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...))
Xnoexcept(noexcept((std::__2::forward<_A0>(__a0).*__f)(std::__2::forward<_Args>(__args)...))) -> decltype((std::__2::forward<_A0>(__a0).*__f)(std::__2::forward<_Args>(__args)...)) { return (std::__2::forward<_A0>(__a0).*__f)(std::__2::forward<_Args>(__args)...); }
N
Ntemplate <class _Fp, class _A0, class ..._Args,
N          class = __enable_if_bullet2<_Fp, _A0>>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nauto
N__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
N_LIBCPP_INVOKE_RETURN((__a0.get().*__f)(_VSTD::forward<_Args>(__args)...))
Xnoexcept(noexcept((__a0 . get().*__f)(std::__2::forward<_Args>(__args)...))) -> decltype((__a0 . get().*__f)(std::__2::forward<_Args>(__args)...)) { return (__a0 . get().*__f)(std::__2::forward<_Args>(__args)...); }
N
Ntemplate <class _Fp, class _A0, class ..._Args,
N          class = __enable_if_bullet2<_Fp, _A0>>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_LIBCPP_CONSTEXPR auto
Xconstexpr auto
N__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
N_LIBCPP_INVOKE_RETURN((__a0.get().*__f)(_VSTD::forward<_Args>(__args)...))
Xnoexcept(noexcept((__a0 . get().*__f)(std::__2::forward<_Args>(__args)...))) -> decltype((__a0 . get().*__f)(std::__2::forward<_Args>(__args)...)) { return (__a0 . get().*__f)(std::__2::forward<_Args>(__args)...); }
N
Ntemplate <class _Fp, class _A0, class ..._Args,
N          class = __enable_if_bullet3<_Fp, _A0>>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nauto
N__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
N_LIBCPP_INVOKE_RETURN(((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...))
Xnoexcept(noexcept(((*std::__2::forward<_A0>(__a0)).*__f)(std::__2::forward<_Args>(__args)...))) -> decltype(((*std::__2::forward<_A0>(__a0)).*__f)(std::__2::forward<_Args>(__args)...)) { return ((*std::__2::forward<_A0>(__a0)).*__f)(std::__2::forward<_Args>(__args)...); }
N
Ntemplate <class _Fp, class _A0, class ..._Args,
N          class = __enable_if_bullet3<_Fp, _A0>>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_LIBCPP_CONSTEXPR auto
Xconstexpr auto
N__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
N_LIBCPP_INVOKE_RETURN(((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...))
Xnoexcept(noexcept(((*std::__2::forward<_A0>(__a0)).*__f)(std::__2::forward<_Args>(__args)...))) -> decltype(((*std::__2::forward<_A0>(__a0)).*__f)(std::__2::forward<_Args>(__args)...)) { return ((*std::__2::forward<_A0>(__a0)).*__f)(std::__2::forward<_Args>(__args)...); }
N
N// bullets 4, 5 and 6
N
Ntemplate <class _Fp, class _A0,
N          class = __enable_if_bullet4<_Fp, _A0>>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nauto
N__invoke(_Fp&& __f, _A0&& __a0)
N_LIBCPP_INVOKE_RETURN(_VSTD::forward<_A0>(__a0).*__f)
Xnoexcept(noexcept(std::__2::forward<_A0>(__a0).*__f)) -> decltype(std::__2::forward<_A0>(__a0).*__f) { return std::__2::forward<_A0>(__a0).*__f; }
N
Ntemplate <class _Fp, class _A0,
N          class = __enable_if_bullet4<_Fp, _A0>>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_LIBCPP_CONSTEXPR auto
Xconstexpr auto
N__invoke_constexpr(_Fp&& __f, _A0&& __a0)
N_LIBCPP_INVOKE_RETURN(_VSTD::forward<_A0>(__a0).*__f)
Xnoexcept(noexcept(std::__2::forward<_A0>(__a0).*__f)) -> decltype(std::__2::forward<_A0>(__a0).*__f) { return std::__2::forward<_A0>(__a0).*__f; }
N
Ntemplate <class _Fp, class _A0,
N          class = __enable_if_bullet5<_Fp, _A0>>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nauto
N__invoke(_Fp&& __f, _A0&& __a0)
N_LIBCPP_INVOKE_RETURN(__a0.get().*__f)
Xnoexcept(noexcept(__a0 . get().*__f)) -> decltype(__a0 . get().*__f) { return __a0 . get().*__f; }
N
Ntemplate <class _Fp, class _A0,
N          class = __enable_if_bullet5<_Fp, _A0>>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_LIBCPP_CONSTEXPR auto
Xconstexpr auto
N__invoke_constexpr(_Fp&& __f, _A0&& __a0)
N_LIBCPP_INVOKE_RETURN(__a0.get().*__f)
Xnoexcept(noexcept(__a0 . get().*__f)) -> decltype(__a0 . get().*__f) { return __a0 . get().*__f; }
N
Ntemplate <class _Fp, class _A0,
N          class = __enable_if_bullet6<_Fp, _A0>>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nauto
N__invoke(_Fp&& __f, _A0&& __a0)
N_LIBCPP_INVOKE_RETURN((*_VSTD::forward<_A0>(__a0)).*__f)
Xnoexcept(noexcept((*std::__2::forward<_A0>(__a0)).*__f)) -> decltype((*std::__2::forward<_A0>(__a0)).*__f) { return (*std::__2::forward<_A0>(__a0)).*__f; }
N
Ntemplate <class _Fp, class _A0,
N          class = __enable_if_bullet6<_Fp, _A0>>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_LIBCPP_CONSTEXPR auto
Xconstexpr auto
N__invoke_constexpr(_Fp&& __f, _A0&& __a0)
N_LIBCPP_INVOKE_RETURN((*_VSTD::forward<_A0>(__a0)).*__f)
Xnoexcept(noexcept((*std::__2::forward<_A0>(__a0)).*__f)) -> decltype((*std::__2::forward<_A0>(__a0)).*__f) { return (*std::__2::forward<_A0>(__a0)).*__f; }
N
N// bullet 7
N
Ntemplate <class _Fp, class ..._Args>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nauto
N__invoke(_Fp&& __f, _Args&& ...__args)
N_LIBCPP_INVOKE_RETURN(_VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...))
Xnoexcept(noexcept(std::__2::forward<_Fp>(__f)(std::__2::forward<_Args>(__args)...))) -> decltype(std::__2::forward<_Fp>(__f)(std::__2::forward<_Args>(__args)...)) { return std::__2::forward<_Fp>(__f)(std::__2::forward<_Args>(__args)...); }
N
Ntemplate <class _Fp, class ..._Args>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N_LIBCPP_CONSTEXPR auto
Xconstexpr auto
N__invoke_constexpr(_Fp&& __f, _Args&& ...__args)
N_LIBCPP_INVOKE_RETURN(_VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...))
Xnoexcept(noexcept(std::__2::forward<_Fp>(__f)(std::__2::forward<_Args>(__args)...))) -> decltype(std::__2::forward<_Fp>(__f)(std::__2::forward<_Args>(__args)...)) { return std::__2::forward<_Fp>(__f)(std::__2::forward<_Args>(__args)...); }
N
N#undef _LIBCPP_INVOKE_RETURN
N
N// __invokable
N
Ntemplate <class _Ret, class _Fp, class ..._Args>
Nstruct __invokable_r
N    : private __check_complete<_Fp>
N{
N    using _Result = decltype(
N        _VSTD::__invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...));
X        std::__2::__invoke(std::__2::declval<_Fp>(), std::__2::declval<_Args>()...));
N
N    using type =
N        typename conditional<
N            !is_same<_Result, __nat>::value,
N            typename conditional<
N                is_void<_Ret>::value,
N                true_type,
N                is_convertible<_Result, _Ret>
N            >::type,
N            false_type
N        >::type;
N    static const bool value = type::value;
N};
N
Ntemplate <class _Fp, class ..._Args>
Nusing __invokable = __invokable_r<void, _Fp, _Args...>;
N
Ntemplate <bool _IsInvokable, bool _IsCVVoid, class _Ret, class _Fp, class ..._Args>
Nstruct __nothrow_invokable_r_imp {
N  static const bool value = false;
N};
N
Ntemplate <class _Ret, class _Fp, class ..._Args>
Nstruct __nothrow_invokable_r_imp<true, false, _Ret, _Fp, _Args...>
N{
N    typedef __nothrow_invokable_r_imp _ThisT;
N
N    template <class _Tp>
N    static void __test_noexcept(_Tp) noexcept;
N
N    static const bool value = noexcept(_ThisT::__test_noexcept<_Ret>(
N        _VSTD::__invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...)));
X        std::__2::__invoke(std::__2::declval<_Fp>(), std::__2::declval<_Args>()...)));
N};
N
Ntemplate <class _Ret, class _Fp, class ..._Args>
Nstruct __nothrow_invokable_r_imp<true, true, _Ret, _Fp, _Args...>
N{
N    static const bool value = noexcept(
N        _VSTD::__invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...));
X        std::__2::__invoke(std::__2::declval<_Fp>(), std::__2::declval<_Args>()...));
N};
N
Ntemplate <class _Ret, class _Fp, class ..._Args>
Nusing __nothrow_invokable_r =
N    __nothrow_invokable_r_imp<
N            __invokable_r<_Ret, _Fp, _Args...>::value,
N            is_void<_Ret>::value,
N            _Ret, _Fp, _Args...
N    >;
N
Ntemplate <class _Fp, class ..._Args>
Nstruct __invoke_of
N    : public enable_if<
N        __invokable<_Fp, _Args...>::value,
N        typename __invokable_r<void, _Fp, _Args...>::_Result>
N{
N};
N
N// result_of
N
Ntemplate <class _Fp, class ..._Args>
Nclass _LIBCPP_TEMPLATE_VIS result_of<_Fp(_Args...)>
Xclass  result_of<_Fp(_Args...)>
N    : public __invoke_of<_Fp, _Args...>
N{
N};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _Tp> using result_of_t = typename result_of<_Tp>::type;
N#endif
N
N#if _LIBCPP_STD_VER > 14
X#if 14 > 14
S
S// is_callable
S
Stemplate <class _Fn, class _Ret = void>
Sstruct _LIBCPP_TEMPLATE_VIS is_callable;
S
Stemplate <class _Fn, class ..._Args, class _Ret>
Sstruct _LIBCPP_TEMPLATE_VIS is_callable<_Fn(_Args...), _Ret>
S    : integral_constant<bool, __invokable_r<_Ret, _Fn, _Args...>::value> {};
S
Stemplate <class _Fn, class _Ret = void>
Sconstexpr bool is_callable_v = is_callable<_Fn, _Ret>::value;
S
S// is_nothrow_callable
S
Stemplate <class _Fn, class _Ret = void>
Sstruct _LIBCPP_TEMPLATE_VIS is_nothrow_callable;
S
Stemplate <class _Fn, class ..._Args, class _Ret>
Sstruct _LIBCPP_TEMPLATE_VIS is_nothrow_callable<_Fn(_Args...), _Ret>
S    : integral_constant<bool, __nothrow_invokable_r<_Ret, _Fn, _Args...>::value>
S{};
S
Stemplate <class _Fn, class _Ret = void>
Sconstexpr bool is_nothrow_callable_v = is_nothrow_callable<_Fn, _Ret>::value;
S
N#endif // _LIBCPP_STD_VER > 14
N
N#endif  // !defined(_LIBCPP_CXX03_LANG)
N
Ntemplate <class _Tp> struct __is_swappable;
Ntemplate <class _Tp> struct __is_nothrow_swappable;
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
N#ifndef _LIBCPP_CXX03_LANG
Ntypename enable_if
N<
N    is_move_constructible<_Tp>::value &&
N    is_move_assignable<_Tp>::value
N>::type
N#else
Svoid
N#endif
Nswap(_Tp& __x, _Tp& __y) _NOEXCEPT_(is_nothrow_move_constructible<_Tp>::value &&
N                                    is_nothrow_move_assignable<_Tp>::value)
Xswap(_Tp& __x, _Tp& __y) noexcept(is_nothrow_move_constructible<_Tp> ::value && is_nothrow_move_assignable<_Tp> ::value)
N{
N    _Tp __t(_VSTD::move(__x));
X    _Tp __t(std::__2::move(__x));
N    __x = _VSTD::move(__y);
X    __x = std::__2::move(__y);
N    __y = _VSTD::move(__t);
X    __y = std::__2::move(__t);
N}
N
Ntemplate<class _Tp, size_t _Np>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename enable_if<
N    __is_swappable<_Tp>::value
N>::type
Nswap(_Tp (&__a)[_Np], _Tp (&__b)[_Np]) _NOEXCEPT_(__is_nothrow_swappable<_Tp>::value);
Xswap(_Tp (&__a)[_Np], _Tp (&__b)[_Np]) noexcept(__is_nothrow_swappable<_Tp> ::value);
N
Ntemplate <class _ForwardIterator1, class _ForwardIterator2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nvoid
Niter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
N    //                                  _NOEXCEPT_(_NOEXCEPT_(swap(*__a, *__b)))
N               _NOEXCEPT_(_NOEXCEPT_(swap(*_VSTD::declval<_ForwardIterator1>(),
N                                          *_VSTD::declval<_ForwardIterator2>())))
X               noexcept(noexcept(swap(*std::__2::declval<_ForwardIterator1>(), *std::__2::declval<_ForwardIterator2>())))
N{
N    swap(*__a, *__b);
N}
N
N// __swappable
N
Nnamespace __detail
N{
N// ALL generic swap overloads MUST already have a declaration available at this point.
N
Ntemplate <class _Tp, class _Up = _Tp,
N          bool _NotVoid = !is_void<_Tp>::value && !is_void<_Up>::value>
Nstruct __swappable_with
N{
N    template <class _LHS, class _RHS>
N    static decltype(swap(_VSTD::declval<_LHS>(), _VSTD::declval<_RHS>()))
X    static decltype(swap(std::__2::declval<_LHS>(), std::__2::declval<_RHS>()))
N    __test_swap(int);
N    template <class, class>
N    static __nat __test_swap(long);
N
N    // Extra parens are needed for the C++03 definition of decltype.
N    typedef decltype((__test_swap<_Tp, _Up>(0))) __swap1;
N    typedef decltype((__test_swap<_Up, _Tp>(0))) __swap2;
N
N    static const bool value = !is_same<__swap1, __nat>::value
N                           && !is_same<__swap2, __nat>::value;
N};
N
Ntemplate <class _Tp, class _Up>
Nstruct __swappable_with<_Tp, _Up,  false> : false_type {};
N
Ntemplate <class _Tp, class _Up = _Tp, bool _Swappable = __swappable_with<_Tp, _Up>::value>
Nstruct __nothrow_swappable_with {
N  static const bool value =
N#ifndef _LIBCPP_HAS_NO_NOEXCEPT
N      noexcept(swap(_VSTD::declval<_Tp>(), _VSTD::declval<_Up>()))
X      noexcept(swap(std::__2::declval<_Tp>(), std::__2::declval<_Up>()))
N  &&  noexcept(swap(_VSTD::declval<_Up>(), _VSTD::declval<_Tp>()));
X  &&  noexcept(swap(std::__2::declval<_Up>(), std::__2::declval<_Tp>()));
N#else
S      false;
N#endif
N};
N
Ntemplate <class _Tp, class _Up>
Nstruct __nothrow_swappable_with<_Tp, _Up, false> : false_type {};
N
N}  // __detail
N
Ntemplate <class _Tp>
Nstruct __is_swappable
N    : public integral_constant<bool, __detail::__swappable_with<_Tp&>::value>
N{
N};
N
Ntemplate <class _Tp>
Nstruct __is_nothrow_swappable
N    : public integral_constant<bool, __detail::__nothrow_swappable_with<_Tp&>::value>
N{
N};
N
N#if _LIBCPP_STD_VER > 14
X#if 14 > 14
S
Stemplate <class _Tp, class _Up>
Sstruct _LIBCPP_TEMPLATE_VIS is_swappable_with
S    : public integral_constant<bool, __detail::__swappable_with<_Tp, _Up>::value>
S{
S};
S
Stemplate <class _Tp>
Sstruct _LIBCPP_TEMPLATE_VIS is_swappable
S    : public conditional<
S        __is_referenceable<_Tp>::value,
S        is_swappable_with<
S            typename add_lvalue_reference<_Tp>::type,
S            typename add_lvalue_reference<_Tp>::type>,
S        false_type
S    >::type
S{
S};
S
Stemplate <class _Tp, class _Up>
Sstruct _LIBCPP_TEMPLATE_VIS is_nothrow_swappable_with
S    : public integral_constant<bool, __detail::__nothrow_swappable_with<_Tp, _Up>::value>
S{
S};
S
Stemplate <class _Tp>
Sstruct _LIBCPP_TEMPLATE_VIS is_nothrow_swappable
S    : public conditional<
S        __is_referenceable<_Tp>::value,
S        is_nothrow_swappable_with<
S            typename add_lvalue_reference<_Tp>::type,
S            typename add_lvalue_reference<_Tp>::type>,
S        false_type
S    >::type
S{
S};
S
Stemplate <class _Tp, class _Up>
Sconstexpr bool is_swappable_with_v = is_swappable_with<_Tp, _Up>::value;
S
Stemplate <class _Tp>
Sconstexpr bool is_swappable_v = is_swappable<_Tp>::value;
S
Stemplate <class _Tp, class _Up>
Sconstexpr bool is_nothrow_swappable_with_v = is_nothrow_swappable_with<_Tp, _Up>::value;
S
Stemplate <class _Tp>
Sconstexpr bool is_nothrow_swappable_v = is_nothrow_swappable<_Tp>::value;
S
N#endif // _LIBCPP_STD_VER > 14
N
N#ifdef _LIBCPP_UNDERLYING_TYPE
N
Ntemplate <class _Tp>
Nstruct underlying_type
N{
N    typedef _LIBCPP_UNDERLYING_TYPE(_Tp) type;
X    typedef __underlying_type(_Tp) type;
N};
N
N#if _LIBCPP_STD_VER > 11
X#if 14 > 11
Ntemplate <class _Tp> using underlying_type_t = typename underlying_type<_Tp>::type;
N#endif
N
N#else  // _LIBCPP_UNDERLYING_TYPE
S
Stemplate <class _Tp, bool _Support = false>
Sstruct underlying_type
S{
S    static_assert(_Support, "The underyling_type trait requires compiler "
S                            "support. Either no such support exists or "
S                            "libc++ does not know how to use it.");
S};
S
N#endif // _LIBCPP_UNDERLYING_TYPE
N
N
Ntemplate <class _Tp, bool = is_enum<_Tp>::value>
Nstruct __sfinae_underlying_type
N{
N    typedef typename underlying_type<_Tp>::type type;
N    typedef decltype(((type)1) + 0) __promoted_type;
N};
N
Ntemplate <class _Tp>
Nstruct __sfinae_underlying_type<_Tp, false> {};
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nint __convert_to_integral(int __val) { return __val; }
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nunsigned __convert_to_integral(unsigned __val) { return __val; }
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nlong __convert_to_integral(long __val) { return __val; }
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nunsigned long __convert_to_integral(unsigned long __val) { return __val; }
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nlong long __convert_to_integral(long long __val) { return __val; }
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nunsigned long long __convert_to_integral(unsigned long long __val) {return __val; }
N
N#ifndef _LIBCPP_HAS_NO_INT128
Sinline _LIBCPP_INLINE_VISIBILITY
S__int128_t __convert_to_integral(__int128_t __val) { return __val; }
S
Sinline _LIBCPP_INLINE_VISIBILITY
S__uint128_t __convert_to_integral(__uint128_t __val) { return __val; }
N#endif
N
Ntemplate <class _Tp>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename __sfinae_underlying_type<_Tp>::__promoted_type
N__convert_to_integral(_Tp __val) { return __val; }
N
N#ifndef _LIBCPP_CXX03_LANG
N
Ntemplate <class _Tp>
Nstruct __has_operator_addressof_member_imp
N{
N    template <class _Up>
N        static auto __test(int)
N            -> typename __select_2nd<decltype(_VSTD::declval<_Up>().operator&()), true_type>::type;
X            -> typename __select_2nd<decltype(std::__2::declval<_Up>().operator&()), true_type>::type;
N    template <class>
N        static auto __test(long) -> false_type;
N
N    static const bool value = decltype(__test<_Tp>(0))::value;
N};
N
Ntemplate <class _Tp>
Nstruct __has_operator_addressof_free_imp
N{
N    template <class _Up>
N        static auto __test(int)
N            -> typename __select_2nd<decltype(operator&(_VSTD::declval<_Up>())), true_type>::type;
X            -> typename __select_2nd<decltype(operator&(std::__2::declval<_Up>())), true_type>::type;
N    template <class>
N        static auto __test(long) -> false_type;
N
N    static const bool value = decltype(__test<_Tp>(0))::value;
N};
N
Ntemplate <class _Tp>
Nstruct __has_operator_addressof
N    : public integral_constant<bool, __has_operator_addressof_member_imp<_Tp>::value
N                                  || __has_operator_addressof_free_imp<_Tp>::value>
N{};
N
N#endif  // _LIBCPP_CXX03_LANG
N
N#if _LIBCPP_STD_VER > 14
X#if 14 > 14
S
S#define __cpp_lib_void_t 201411
Stemplate <class...> using void_t = void;
S
S# ifndef _LIBCPP_HAS_NO_VARIADICS
Stemplate <class... _Args>
Sstruct conjunction : __and_<_Args...> {};
Stemplate<class... _Args> constexpr bool conjunction_v = conjunction<_Args...>::value;
S
Stemplate <class... _Args>
Sstruct disjunction : __or_<_Args...> {};
Stemplate<class... _Args> constexpr bool disjunction_v = disjunction<_Args...>::value;
S
Stemplate <class _Tp>
Sstruct negation : __not_<_Tp> {};
Stemplate<class _Tp> constexpr bool negation_v = negation<_Tp>::value;
S# endif // _LIBCPP_HAS_NO_VARIADICS
N#endif  // _LIBCPP_STD_VER > 14
N
N// These traits are used in __tree and __hash_table
N#ifndef _LIBCPP_CXX03_LANG
Nstruct __extract_key_fail_tag {};
Nstruct __extract_key_self_tag {};
Nstruct __extract_key_first_tag {};
N
Ntemplate <class _ValTy, class _Key,
N          class _RawValTy = typename __unconstref<_ValTy>::type>
Nstruct __can_extract_key
N    : conditional<is_same<_RawValTy, _Key>::value, __extract_key_self_tag,
N                  __extract_key_fail_tag>::type {};
N
Ntemplate <class _Pair, class _Key, class _First, class _Second>
Nstruct __can_extract_key<_Pair, _Key, pair<_First, _Second>>
N    : conditional<is_same<typename remove_const<_First>::type, _Key>::value,
N                  __extract_key_first_tag, __extract_key_fail_tag>::type {};
N
N// __can_extract_map_key uses true_type/false_type instead of the tags.
N// It returns true if _Key != _ContainerValueTy (the container is a map not a set)
N// and _ValTy == _Key.
Ntemplate <class _ValTy, class _Key, class _ContainerValueTy,
N          class _RawValTy = typename __unconstref<_ValTy>::type>
Nstruct __can_extract_map_key
N    : integral_constant<bool, is_same<_RawValTy, _Key>::value> {};
N
N// This specialization returns __extract_key_fail_tag for non-map containers
N// because _Key == _ContainerValueTy
Ntemplate <class _ValTy, class _Key, class _RawValTy>
Nstruct __can_extract_map_key<_ValTy, _Key, _Key, _RawValTy>
N    : false_type {};
N
N#endif
N
N_LIBCPP_END_NAMESPACE_STD
X} }
N
N#if _LIBCPP_STD_VER > 14
X#if 14 > 14
S// std::byte
Snamespace std  // purposefully not versioned
S{
Stemplate <class _Integer>
S  constexpr typename enable_if<is_integral_v<_Integer>, byte>::type &
S  operator<<=(byte& __lhs, _Integer __shift) noexcept
S  { return __lhs = byte(static_cast<unsigned char>(__lhs) << __shift); }
S  
Stemplate <class _Integer>
S  constexpr typename enable_if<is_integral_v<_Integer>, byte>::type
S  operator<< (byte  __lhs, _Integer __shift) noexcept
S  { return         byte(static_cast<unsigned char>(__lhs) << __shift); }
S
Stemplate <class _Integer>
S  constexpr typename enable_if<is_integral_v<_Integer>, byte>::type &
S  operator>>=(byte& __lhs, _Integer __shift) noexcept
S  { return __lhs = byte(static_cast<unsigned char>(__lhs) >> __shift); }
S
Stemplate <class _Integer>
S  constexpr typename enable_if<is_integral_v<_Integer>, byte>::type
S  operator>> (byte  __lhs, _Integer __shift) noexcept
S  { return         byte(static_cast<unsigned char>(__lhs) >> __shift); }
S  
Stemplate <class _Integer>
S  constexpr typename enable_if<is_integral_v<_Integer>, _Integer>::type
S  to_integer(byte __b) noexcept { return _Integer(__b); }
S
S}
N#endif
N
N#endif  // _LIBCPP_TYPE_TRAITS
L 310 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/math.h" 2
N#include <limits>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/limits" 1
N// -*- C++ -*-
N//===---------------------------- limits ----------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is dual licensed under the MIT and the University of Illinois Open
N// Source Licenses. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP_LIMITS
N#define _LIBCPP_LIMITS
N
N/*
N    limits synopsis
N
Nnamespace std
N{
N
Ntemplate<class T>
Nclass numeric_limits
N{
Npublic:
N    static constexpr bool is_specialized = false;
N    static constexpr T min() noexcept;
N    static constexpr T max() noexcept;
N    static constexpr T lowest() noexcept;
N
N    static constexpr int  digits = 0;
N    static constexpr int  digits10 = 0;
N    static constexpr int  max_digits10 = 0;
N    static constexpr bool is_signed = false;
N    static constexpr bool is_integer = false;
N    static constexpr bool is_exact = false;
N    static constexpr int  radix = 0;
N    static constexpr T epsilon() noexcept;
N    static constexpr T round_error() noexcept;
N
N    static constexpr int  min_exponent = 0;
N    static constexpr int  min_exponent10 = 0;
N    static constexpr int  max_exponent = 0;
N    static constexpr int  max_exponent10 = 0;
N
N    static constexpr bool has_infinity = false;
N    static constexpr bool has_quiet_NaN = false;
N    static constexpr bool has_signaling_NaN = false;
N    static constexpr float_denorm_style has_denorm = denorm_absent;
N    static constexpr bool has_denorm_loss = false;
N    static constexpr T infinity() noexcept;
N    static constexpr T quiet_NaN() noexcept;
N    static constexpr T signaling_NaN() noexcept;
N    static constexpr T denorm_min() noexcept;
N
N    static constexpr bool is_iec559 = false;
N    static constexpr bool is_bounded = false;
N    static constexpr bool is_modulo = false;
N
N    static constexpr bool traps = false;
N    static constexpr bool tinyness_before = false;
N    static constexpr float_round_style round_style = round_toward_zero;
N};
N
Nenum __attribute__((packed)) float_round_style
N{
N    round_indeterminate       = -1,
N    round_toward_zero         =  0,
N    round_to_nearest          =  1,
N    round_toward_infinity     =  2,
N    round_toward_neg_infinity =  3
N};
N
Nenum __attribute__((packed)) float_denorm_style
N{
N    denorm_indeterminate = -1,
N    denorm_absent = 0,
N    denorm_present = 1
N};
N
Ntemplate<> class numeric_limits<cv bool>;
N
Ntemplate<> class numeric_limits<cv char>;
Ntemplate<> class numeric_limits<cv signed char>;
Ntemplate<> class numeric_limits<cv unsigned char>;
Ntemplate<> class numeric_limits<cv wchar_t>;
Ntemplate<> class numeric_limits<cv char16_t>;
Ntemplate<> class numeric_limits<cv char32_t>;
N
Ntemplate<> class numeric_limits<cv short>;
Ntemplate<> class numeric_limits<cv int>;
Ntemplate<> class numeric_limits<cv long>;
Ntemplate<> class numeric_limits<cv long long>;
Ntemplate<> class numeric_limits<cv unsigned short>;
Ntemplate<> class numeric_limits<cv unsigned int>;
Ntemplate<> class numeric_limits<cv unsigned long>;
Ntemplate<> class numeric_limits<cv unsigned long long>;
N
Ntemplate<> class numeric_limits<cv float>;
Ntemplate<> class numeric_limits<cv double>;
Ntemplate<> class numeric_limits<cv long double>;
N
N}  // std
N
N*/
N#include <__config>
N#include <type_traits>
N
N#if defined(_LIBCPP_COMPILER_MSVC)
X#if 0L
S#include "support/win32/limits_msvc_win32.h"
N#elif defined(_LIBCPP_COMPILER_TI)
X#elif 1L
N#include "support/ti/__limit_defs.h"
L 1 "C:\ti\ccs930\ccs\tools\compiler\ti-cgt-arm_18.12.5.LTS\include\libcxx\support/ti/__limit_defs.h" 1
N// -*- C++ -*-
N//===--------------------- support/ti/limits.h ----------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is dual licensed under the MIT and the University of Illinois Open
N// Source Licenses. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N#ifndef _LIBCPP_SUPPORT_TI_LIMIT_DEFS_H
N#define _LIBCPP_SUPPORT_TI_LIMIT_DEFS_H
N
N#include <__config>
N#include <float.h>  // FP Limits
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/float.h" 1
N/* -*- C++ -*- */
N/*===--------------------------- complex.h --------------------------------===*/
N/*                                                                            */
N/*                     The LLVM Compiler Infrastructure                       */
N/*                                                                            */
N/* This file is dual licensed under the MIT and the University of Illinois Open
N** Source Licenses. See LICENSE.TXT for details.
N*/
N/*===----------------------------------------------------------------------===*/
N
N#ifndef _LIBCPP_FLOAT_H
N#define _LIBCPP_FLOAT_H
N
N/*
N    float.h synopsis
N
NMacros:
N
N    FLT_ROUNDS
N    FLT_EVAL_METHOD     // C99
N    FLT_RADIX
N
N    FLT_MANT_DIG
N    DBL_MANT_DIG
N    LDBL_MANT_DIG
N
N    DECIMAL_DIG         // C99
N
N    FLT_DIG
N    DBL_DIG
N    LDBL_DIG
N
N    FLT_MIN_EXP
N    DBL_MIN_EXP
N    LDBL_MIN_EXP
N
N    FLT_MIN_10_EXP
N    DBL_MIN_10_EXP
N    LDBL_MIN_10_EXP
N
N    FLT_MAX_EXP
N    DBL_MAX_EXP
N    LDBL_MAX_EXP
N
N    FLT_MAX_10_EXP
N    DBL_MAX_10_EXP
N    LDBL_MAX_10_EXP
N
N    FLT_MAX
N    DBL_MAX
N    LDBL_MAX
N
N    FLT_EPSILON
N    DBL_EPSILON
N    LDBL_EPSILON
N
N    FLT_MIN
N    DBL_MIN
N    LDBL_MIN
N
N*/
N
N#include <__config>
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N#include_next <float.h>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/float.h" 1
N/*****************************************************************************/
N/* float.h                                                                   */
N/*                                                                           */
N/* Copyright (c) 1993 Texas Instruments Incorporated                         */
N/* http://www.ti.com/                                                        */
N/*                                                                           */
N/*  Redistribution and  use in source  and binary forms, with  or without    */
N/*  modification,  are permitted provided  that the  following conditions    */
N/*  are met:                                                                 */
N/*                                                                           */
N/*     Redistributions  of source  code must  retain the  above copyright    */
N/*     notice, this list of conditions and the following disclaimer.         */
N/*                                                                           */
N/*     Redistributions in binary form  must reproduce the above copyright    */
N/*     notice, this  list of conditions  and the following  disclaimer in    */
N/*     the  documentation  and/or   other  materials  provided  with  the    */
N/*     distribution.                                                         */
N/*                                                                           */
N/*     Neither the  name of Texas Instruments Incorporated  nor the names    */
N/*     of its  contributors may  be used to  endorse or  promote products    */
N/*     derived  from   this  software  without   specific  prior  written    */
N/*     permission.                                                           */
N/*                                                                           */
N/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS    */
N/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT    */
N/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    */
N/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT    */
N/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    */
N/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT    */
N/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    */
N/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    */
N/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT    */
N/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    */
N/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     */
N/*                                                                           */
N/*****************************************************************************/
N
N/********************************************************************/
N/*    KEY:  FLT_     - APPLIES TO TYPE FLOAT                        */
N/*          DBL_     - APPLIES TO TYPE DOUBLE                       */
N/*          LDBL_    - APPLIES TO TYPE LONG DOUBLE                  */
N/********************************************************************/
N#ifndef _FLOAT_H_
N#define _FLOAT_H_
N
N#include <_ti_config.h>
N
N#pragma diag_push
N#pragma CHECK_MISRA("-20.1") /* standard headers must define standard names */
N
N#define FLT_RADIX                         2   /* RADIX OF EXPONENT         */
N#define FLT_ROUNDS                        1   /* ROUND TO NEAREST          */
N#define FLT_EVAL_METHOD                 (-1)  /* INDETERMINABLE            */
N
N#define FLT_DIG                           6   /* DECIMAL PRECISION         */
N#define FLT_DECIMAL_DIG                    9  /* DECIMAL PRECISION         */
N#define FLT_MANT_DIG                     24   /* BITS IN MANTISSA          */
N#define FLT_MIN_EXP                   (-125)  /* SMALLEST EXPONENT         */
N#define FLT_MAX_EXP                     128   /* LARGEST EXPONENT          */
N#define FLT_MIN_10_EXP                 (-37)  /* MIN POWER OF 10           */
N#define FLT_MAX_10_EXP                   38   /* MAX POWER OF 10           */
N#define FLT_EPSILON         1.192092896E-07F  /* SMALLEST X WHERE 1+X != 1 */
N#define FLT_MIN             1.175494351E-38F  /* MIN NORMALIZED POS VALUE  */
N#define FLT_MAX             3.402823466E+38F  /* MAX POSITIVE VALUE        */
N#if defined(_TI_C11LIB) || __TI_STRICT_ANSI_MODE__ == 0
X#if 1L || 0 == 0
N#define FLT_TRUE_MIN        1.401298464E-45F  /* MIN POSITIVE VALUE        */
N#define FLT_HAS_SUBNORM                    0  /* SUPPORTS SUBNORMAL        */
N#endif
N
N#if defined(__TMS320C2000__) && !defined(__TI_EABI__) || defined(__MSP430__) && !defined(__TI_EABI__)
X#if 0L && !1L || 0L && !1L
S
S#define DBL_DIG             (FLT_DIG)         /* DECIMAL PRECISION         */
S#define DBL_DECIMAL_DIG     (FLT_DECIMAL_DIG) /* DECIMAL PRECISION         */
S#define DBL_MANT_DIG        (FLT_MANT_DIG)    /* BITS IN MANTISSA          */
S#define DBL_MIN_EXP         (FLT_MIN_EXP)     /* SMALLEST EXPONENT         */
S#define DBL_MAX_EXP         (FLT_MAX_EXP)     /* LARGEST EXPONENT          */
S#define DBL_MIN_10_EXP      (FLT_MIN_10_EXP)  /* MIN POWER OF 10           */
S#define DBL_MAX_10_EXP      (FLT_MAX_10_EXP)  /* MAX POWER OF 10           */
S#define DBL_EPSILON         1.192092896E-07   /* SMALLEST X WHERE 1+X != 1 */
S#define DBL_MIN             1.175494351E-38   /* MIN NORMALIZED POS VALUE  */
S#define DBL_MAX             3.402823466E+38   /* MAX POSITIVE VALUE        */
S#if defined(_TI_C11LIB) || __TI_STRICT_ANSI_MODE__ == 0
S#define DBL_TRUE_MIN        ((double)(FLT_TRUE_MIN))
S#define DBL_HAS_SUBNORM     (FLT_HAS_SUBNORM)
S#endif /* C11 IS VISIBLE */
S
N#else
N
N#define DBL_DIG                          15   /* DECIMAL PRECISION         */
N#define DBL_DECIMAL_DIG                  17   /* DECIMAL PRECISION         */
N#define DBL_MANT_DIG                     53   /* BITS IN MANTISSA          */
N#define DBL_MIN_EXP                  (-1021)  /* SMALLEST EXPONENT         */
N#define DBL_MAX_EXP                    1024   /* LARGEST EXPONENT          */
N#define DBL_MIN_10_EXP                (-307)  /* MIN POWER OF 10           */
N#define DBL_MAX_10_EXP                  308   /* MAX POWER OF 10           */
N#define DBL_EPSILON  2.2204460492503131E-16   /* SMALLEST X WHERE 1+X != 1 */
N#define DBL_MIN     2.2250738585072014E-308   /* MIN NORMALIZED POS VALUE  */
N#define DBL_MAX     1.7976931348623157E+308   /* MAX POSITIVE VALUE        */
N#if defined(_TI_C11LIB) || __TI_STRICT_ANSI_MODE__ == 0
X#if 1L || 0 == 0
N#define DBL_TRUE_MIN 4.9406564584124654E-324
N#define DBL_HAS_SUBNORM                   0
N#endif
N
N#endif
N
N#if defined(__MSP430__) && !defined(__TI_EABI__)
X#if 0L && !1L
S
S#define LDBL_DIG            (FLT_DIG)         /* DECIMAL PRECISION         */
S#define LDBL_DECIMAL_DIG    (FLT_DECIMAL_DIGIT)/* DECIMAL PRECISION        */
S#define LDBL_MANT_DIG       (FLT_MANT_DIG)    /* BITS IN MANTISSA          */
S#define LDBL_MIN_EXP        (FLT_MIN_EXP)     /* SMALLEST EXPONENT         */
S#define LDBL_MAX_EXP        (FLT_MAX_EXP)     /* LARGEST EXPONENT          */
S#define LDBL_MIN_10_EXP     (FLT_MIN_10_EXP)  /* MIN POWER OF 10           */
S#define LDBL_MAX_10_EXP     (FLT_MAX_10_EXP)  /* MAX POWER OF 10           */
S#define LDBL_EPSILON        1.192092896E-07L  /* SMALLEST X WHERE 1+X != 1 */
S#define LDBL_MIN            1.175494351E-38L  /* MIN NORMALIZED POS VALUE  */
S#define LDBL_MAX            3.402823466E+38L  /* MAX POSITIVE VALUE        */
S#if defined(_TI_C11LIB) || __TI_STRICT_ANSI_MODE__ == 0
S#define LDBL_TRUE_MIN       ((long double)FLT_TRUE_MIN)
S#define LDBL_HAS_SUBNORM    (FLT_HAS_SUBNORM)              1
S#endif
S
N#else
N
N#define LDBL_DIG                         15   /* DECIMAL PRECISION         */
N#define LDBL_DECIMAL_DIG                 17   /* DECIMAL PRECISION         */
N#define LDBL_MANT_DIG                    53   /* BITS IN MANTISSA          */
N#define LDBL_MIN_EXP                 (-1021)  /* SMALLEST EXPONENT         */
N#define LDBL_MAX_EXP                   1024   /* LARGEST EXPONENT          */
N#define LDBL_MIN_10_EXP               (-307)  /* MIN POWER OF 10           */
N#define LDBL_MAX_10_EXP                 308   /* MAX POWER OF 10           */
N#define LDBL_EPSILON 2.2204460492503131E-16L  /* SMALLEST X WHERE 1+X != 1 */
N#define LDBL_MIN    2.2250738585072014E-308L  /* MIN NORMALIZED POS VALUE  */
N#define LDBL_MAX    1.7976931348623157E+308L  /* MAX POSITIVE VALUE        */
N#if defined(_TI_C11LIB) || __TI_STRICT_ANSI_MODE__ == 0
X#if 1L || 0 == 0
N#define LDBL_TRUE_MIN 4.9406564584124654E-324L
N#define LDBL_HAS_SUBNORM                  0
N#endif
N
N#endif
N
N#define DECIMAL_DIG        (LDBL_DECIMAL_DIG) /* LARGEST DECIMAL PRECISION */
N
N#pragma diag_pop
N
N#endif /* _FLOAT_H_ */
L 70 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/float.h" 2
N
N#ifdef __cplusplus
N
N#ifndef FLT_EVAL_METHOD
S#define FLT_EVAL_METHOD __FLT_EVAL_METHOD__
N#endif
N
N#ifndef DECIMAL_DIG
S#define DECIMAL_DIG __DECIMAL_DIG__
N#endif
N
N#endif /* __cplusplus */
N
N#endif  /* _LIBCPP_FLOAT_H */
L 16 "C:\ti\ccs930\ccs\tools\compiler\ti-cgt-arm_18.12.5.LTS\include\libcxx\support/ti/__limit_defs.h" 2
N
N#define __DBL_DENORM_MIN__ (0.0)
N#define __DBL_DIG__ DBL_DIG
N#define __DBL_EPSILON__ DBL_EPSILON
N#define __DBL_MANT_DIG__ DBL_MANT_DIG
N#define __DBL_MAX__ DBL_MAX
N#define __DBL_MAX_10_EXP__ DBL_MAX_10_EXP
N#define __DBL_MAX_EXP__ DBL_MAX_EXP
N#define __DBL_MIN__ DBL_MIN
N#define __DBL_MIN_10_EXP__ DBL_MIN_10_EXP
N#define __DBL_MIN_EXP__ DBL_MIN_EXP
N
N#define __FLT_DENORM_MIN__ (0.0f)
N#define __FLT_DIG__ FLT_DIG
N#define __FLT_EPSILON__ FLT_EPSILON
N#define __FLT_MANT_DIG__ FLT_MANT_DIG
N#define __FLT_MAX__ FLT_MAX
N#define __FLT_MAX_10_EXP__ FLT_MAX_10_EXP
N#define __FLT_MAX_EXP__ FLT_MAX_EXP
N#define __FLT_MIN__ FLT_MIN
N#define __FLT_MIN_10_EXP__ FLT_MIN_10_EXP
N#define __FLT_MIN_EXP__ FLT_MIN_EXP
N#define __FLT_RADIX__ FLT_RADIX
N
N#define __LDBL_DENORM_MIN__ (0.0l)
N#define __LDBL_DIG__ LDBL_DIG
N#define __LDBL_EPSILON__ LDBL_EPSILON
N#define __LDBL_MANT_DIG__ LDBL_MANT_DIG
N#define __LDBL_MAX__ LDBL_MAX
N#define __LDBL_MAX_10_EXP__ LDBL_MAX_10_EXP
N#define __LDBL_MAX_EXP__ LDBL_MAX_EXP
N#define __LDBL_MIN__ LDBL_MIN
N#define __LDBL_MIN_10_EXP__ LDBL_MIN_10_EXP
N#define __LDBL_MIN_EXP__ LDBL_MIN_EXP
N
N#endif // _LIBCPP_SUPPORT_TI_LIMITS_H
L 111 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/limits" 2
N#endif // _LIBCPP_MSVCRT
N
N#if defined(__IBMCPP__)
X#if 0L
S#include "support/ibm/limits.h"
N#endif // __IBMCPP__
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N_LIBCPP_PUSH_MACROS
X_Pragma("push_macro(\"min\")") _Pragma("push_macro(\"max\")")
N#include <__undef_macros>
L 1 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/__undef_macros" 1
N// -*- C++ -*-
N//===------------------------ __undef_macros ------------------------------===//
N//
N//                     The LLVM Compiler Infrastructure
N//
N// This file is distributed under the University of Illinois Open Source
N// License. See LICENSE.TXT for details.
N//
N//===----------------------------------------------------------------------===//
N
N
N#ifdef min
S#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
S#if defined(_LIBCPP_WARNING)
S_LIBCPP_WARNING("macro min is incompatible with C++.  Try #define NOMINMAX "
S                "before any Windows header. #undefing min")
S#else
S#warning: macro min is incompatible with C++.  #undefing min
S#endif
S#endif
S#undef min
N#endif
N
N#ifdef max
S#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
S#if defined(_LIBCPP_WARNING)
S_LIBCPP_WARNING("macro max is incompatible with C++.  Try #define NOMINMAX "
S                "before any Windows header. #undefing max")
S#else
S#warning: macro max is incompatible with C++.  #undefing max
S#endif
S#endif
S#undef max
N#endif
L 123 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/limits" 2
N
N
N_LIBCPP_BEGIN_NAMESPACE_STD
Xnamespace std { inline namespace __2 {
N
Nenum __attribute__((packed)) float_round_style
N{
N    round_indeterminate       = -1,
N    round_toward_zero         =  0,
N    round_to_nearest          =  1,
N    round_toward_infinity     =  2,
N    round_toward_neg_infinity =  3
N};
N
Nenum __attribute__((packed)) float_denorm_style
N{
N    denorm_indeterminate = -1,
N    denorm_absent = 0,
N    denorm_present = 1
N};
N
Ntemplate <class _Tp, bool = is_arithmetic<_Tp>::value>
Nclass __libcpp_numeric_limits
N{
Nprotected:
N    typedef _Tp type;
N
N    static _LIBCPP_CONSTEXPR const  bool is_specialized = false;
X    static constexpr const  bool is_specialized = false;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type min() _NOEXCEPT {return type();}
X    __attribute__ ((__always_inline__)) static constexpr type min() noexcept {return type();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type max() _NOEXCEPT {return type();}
X    __attribute__ ((__always_inline__)) static constexpr type max() noexcept {return type();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type lowest() _NOEXCEPT {return type();}
X    __attribute__ ((__always_inline__)) static constexpr type lowest() noexcept {return type();}
N
N    static _LIBCPP_CONSTEXPR const int  digits = 0;
X    static constexpr const int  digits = 0;
N    static _LIBCPP_CONSTEXPR const int  digits10 = 0;
X    static constexpr const int  digits10 = 0;
N    static _LIBCPP_CONSTEXPR const int  max_digits10 = 0;
X    static constexpr const int  max_digits10 = 0;
N    static _LIBCPP_CONSTEXPR const bool is_signed = false;
X    static constexpr const bool is_signed = false;
N    static _LIBCPP_CONSTEXPR const bool is_integer = false;
X    static constexpr const bool is_integer = false;
N    static _LIBCPP_CONSTEXPR const bool is_exact = false;
X    static constexpr const bool is_exact = false;
N    static _LIBCPP_CONSTEXPR const int  radix = 0;
X    static constexpr const int  radix = 0;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type epsilon() _NOEXCEPT {return type();}
X    __attribute__ ((__always_inline__)) static constexpr type epsilon() noexcept {return type();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type round_error() _NOEXCEPT {return type();}
X    __attribute__ ((__always_inline__)) static constexpr type round_error() noexcept {return type();}
N
N    static _LIBCPP_CONSTEXPR const int  min_exponent = 0;
X    static constexpr const int  min_exponent = 0;
N    static _LIBCPP_CONSTEXPR const int  min_exponent10 = 0;
X    static constexpr const int  min_exponent10 = 0;
N    static _LIBCPP_CONSTEXPR const int  max_exponent = 0;
X    static constexpr const int  max_exponent = 0;
N    static _LIBCPP_CONSTEXPR const int  max_exponent10 = 0;
X    static constexpr const int  max_exponent10 = 0;
N
N    static _LIBCPP_CONSTEXPR const bool has_infinity = false;
X    static constexpr const bool has_infinity = false;
N    static _LIBCPP_CONSTEXPR const bool has_quiet_NaN = false;
X    static constexpr const bool has_quiet_NaN = false;
N    static _LIBCPP_CONSTEXPR const bool has_signaling_NaN = false;
X    static constexpr const bool has_signaling_NaN = false;
N    static _LIBCPP_CONSTEXPR const float_denorm_style has_denorm = denorm_absent;
X    static constexpr const float_denorm_style has_denorm = denorm_absent;
N    static _LIBCPP_CONSTEXPR const bool has_denorm_loss = false;
X    static constexpr const bool has_denorm_loss = false;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type infinity() _NOEXCEPT {return type();}
X    __attribute__ ((__always_inline__)) static constexpr type infinity() noexcept {return type();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return type();}
X    __attribute__ ((__always_inline__)) static constexpr type quiet_NaN() noexcept {return type();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return type();}
X    __attribute__ ((__always_inline__)) static constexpr type signaling_NaN() noexcept {return type();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return type();}
X    __attribute__ ((__always_inline__)) static constexpr type denorm_min() noexcept {return type();}
N
N    static _LIBCPP_CONSTEXPR const bool is_iec559 = false;
X    static constexpr const bool is_iec559 = false;
N    static _LIBCPP_CONSTEXPR const bool is_bounded = false;
X    static constexpr const bool is_bounded = false;
N    static _LIBCPP_CONSTEXPR const bool is_modulo = false;
X    static constexpr const bool is_modulo = false;
N
N    static _LIBCPP_CONSTEXPR const bool traps = false;
X    static constexpr const bool traps = false;
N    static _LIBCPP_CONSTEXPR const bool tinyness_before = false;
X    static constexpr const bool tinyness_before = false;
N    static _LIBCPP_CONSTEXPR const float_round_style round_style = round_toward_zero;
X    static constexpr const float_round_style round_style = round_toward_zero;
N};
N
Ntemplate <class _Tp, int __digits, bool _IsSigned>
Nstruct __libcpp_compute_min
N{
N    static _LIBCPP_CONSTEXPR const _Tp value = _Tp(_Tp(1) << __digits);
X    static constexpr const _Tp value = _Tp(_Tp(1) << __digits);
N};
N
Ntemplate <class _Tp, int __digits>
Nstruct __libcpp_compute_min<_Tp, __digits, false>
N{
N    static _LIBCPP_CONSTEXPR const _Tp value = _Tp(0);
X    static constexpr const _Tp value = _Tp(0);
N};
N
Ntemplate <class _Tp>
Nclass __libcpp_numeric_limits<_Tp, true>
N{
Nprotected:
N    typedef _Tp type;
N
N    static _LIBCPP_CONSTEXPR const bool is_specialized = true;
X    static constexpr const bool is_specialized = true;
N
N    static _LIBCPP_CONSTEXPR const bool is_signed = type(-1) < type(0);
X    static constexpr const bool is_signed = type(-1) < type(0);
N    static _LIBCPP_CONSTEXPR const int  digits = static_cast<int>(sizeof(type) * __CHAR_BIT__ - is_signed);
X    static constexpr const int  digits = static_cast<int>(sizeof(type) * 8 - is_signed);
N    static _LIBCPP_CONSTEXPR const int  digits10 = digits * 3 / 10;
X    static constexpr const int  digits10 = digits * 3 / 10;
N    static _LIBCPP_CONSTEXPR const int  max_digits10 = 0;
X    static constexpr const int  max_digits10 = 0;
N    static _LIBCPP_CONSTEXPR const type __min = __libcpp_compute_min<type, digits, is_signed>::value;
X    static constexpr const type __min = __libcpp_compute_min<type, digits, is_signed>::value;
N    static _LIBCPP_CONSTEXPR const type __max = is_signed ? type(type(~0) ^ __min) : type(~0);
X    static constexpr const type __max = is_signed ? type(type(~0) ^ __min) : type(~0);
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type min() _NOEXCEPT {return __min;}
X    __attribute__ ((__always_inline__)) static constexpr type min() noexcept {return __min;}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type max() _NOEXCEPT {return __max;}
X    __attribute__ ((__always_inline__)) static constexpr type max() noexcept {return __max;}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type lowest() _NOEXCEPT {return min();}
X    __attribute__ ((__always_inline__)) static constexpr type lowest() noexcept {return min();}
N
N    static _LIBCPP_CONSTEXPR const bool is_integer = true;
X    static constexpr const bool is_integer = true;
N    static _LIBCPP_CONSTEXPR const bool is_exact = true;
X    static constexpr const bool is_exact = true;
N    static _LIBCPP_CONSTEXPR const int  radix = 2;
X    static constexpr const int  radix = 2;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type epsilon() _NOEXCEPT {return type(0);}
X    __attribute__ ((__always_inline__)) static constexpr type epsilon() noexcept {return type(0);}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type round_error() _NOEXCEPT {return type(0);}
X    __attribute__ ((__always_inline__)) static constexpr type round_error() noexcept {return type(0);}
N
N    static _LIBCPP_CONSTEXPR const int  min_exponent = 0;
X    static constexpr const int  min_exponent = 0;
N    static _LIBCPP_CONSTEXPR const int  min_exponent10 = 0;
X    static constexpr const int  min_exponent10 = 0;
N    static _LIBCPP_CONSTEXPR const int  max_exponent = 0;
X    static constexpr const int  max_exponent = 0;
N    static _LIBCPP_CONSTEXPR const int  max_exponent10 = 0;
X    static constexpr const int  max_exponent10 = 0;
N
N    static _LIBCPP_CONSTEXPR const bool has_infinity = false;
X    static constexpr const bool has_infinity = false;
N    static _LIBCPP_CONSTEXPR const bool has_quiet_NaN = false;
X    static constexpr const bool has_quiet_NaN = false;
N    static _LIBCPP_CONSTEXPR const bool has_signaling_NaN = false;
X    static constexpr const bool has_signaling_NaN = false;
N    static _LIBCPP_CONSTEXPR const float_denorm_style has_denorm = denorm_absent;
X    static constexpr const float_denorm_style has_denorm = denorm_absent;
N    static _LIBCPP_CONSTEXPR const bool has_denorm_loss = false;
X    static constexpr const bool has_denorm_loss = false;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type infinity() _NOEXCEPT {return type(0);}
X    __attribute__ ((__always_inline__)) static constexpr type infinity() noexcept {return type(0);}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return type(0);}
X    __attribute__ ((__always_inline__)) static constexpr type quiet_NaN() noexcept {return type(0);}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return type(0);}
X    __attribute__ ((__always_inline__)) static constexpr type signaling_NaN() noexcept {return type(0);}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return type(0);}
X    __attribute__ ((__always_inline__)) static constexpr type denorm_min() noexcept {return type(0);}
N
N    static _LIBCPP_CONSTEXPR const bool is_iec559 = false;
X    static constexpr const bool is_iec559 = false;
N    static _LIBCPP_CONSTEXPR const bool is_bounded = true;
X    static constexpr const bool is_bounded = true;
N    static _LIBCPP_CONSTEXPR const bool is_modulo = !_VSTD::is_signed<_Tp>::value;
X    static constexpr const bool is_modulo = !std::__2::is_signed<_Tp>::value;
N
N#if defined(__i386__) || defined(__x86_64__) || defined(__pnacl__) || \
N    defined(__wasm__)
X#if 0L || 0L || 0L ||     0L
S    static _LIBCPP_CONSTEXPR const bool traps = true;
N#else
N    static _LIBCPP_CONSTEXPR const bool traps = false;
X    static constexpr const bool traps = false;
N#endif
N    static _LIBCPP_CONSTEXPR const bool tinyness_before = false;
X    static constexpr const bool tinyness_before = false;
N    static _LIBCPP_CONSTEXPR const float_round_style round_style = round_toward_zero;
X    static constexpr const float_round_style round_style = round_toward_zero;
N};
N
Ntemplate <>
Nclass __libcpp_numeric_limits<bool, true>
N{
Nprotected:
N    typedef bool type;
N
N    static _LIBCPP_CONSTEXPR const bool is_specialized = true;
X    static constexpr const bool is_specialized = true;
N
N    static _LIBCPP_CONSTEXPR const bool is_signed = false;
X    static constexpr const bool is_signed = false;
N    static _LIBCPP_CONSTEXPR const int  digits = 1;
X    static constexpr const int  digits = 1;
N    static _LIBCPP_CONSTEXPR const int  digits10 = 0;
X    static constexpr const int  digits10 = 0;
N    static _LIBCPP_CONSTEXPR const int  max_digits10 = 0;
X    static constexpr const int  max_digits10 = 0;
N    static _LIBCPP_CONSTEXPR const type __min = false;
X    static constexpr const type __min = false;
N    static _LIBCPP_CONSTEXPR const type __max = true;
X    static constexpr const type __max = true;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type min() _NOEXCEPT {return __min;}
X    __attribute__ ((__always_inline__)) static constexpr type min() noexcept {return __min;}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type max() _NOEXCEPT {return __max;}
X    __attribute__ ((__always_inline__)) static constexpr type max() noexcept {return __max;}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type lowest() _NOEXCEPT {return min();}
X    __attribute__ ((__always_inline__)) static constexpr type lowest() noexcept {return min();}
N
N    static _LIBCPP_CONSTEXPR const bool is_integer = true;
X    static constexpr const bool is_integer = true;
N    static _LIBCPP_CONSTEXPR const bool is_exact = true;
X    static constexpr const bool is_exact = true;
N    static _LIBCPP_CONSTEXPR const int  radix = 2;
X    static constexpr const int  radix = 2;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type epsilon() _NOEXCEPT {return type(0);}
X    __attribute__ ((__always_inline__)) static constexpr type epsilon() noexcept {return type(0);}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type round_error() _NOEXCEPT {return type(0);}
X    __attribute__ ((__always_inline__)) static constexpr type round_error() noexcept {return type(0);}
N
N    static _LIBCPP_CONSTEXPR const int  min_exponent = 0;
X    static constexpr const int  min_exponent = 0;
N    static _LIBCPP_CONSTEXPR const int  min_exponent10 = 0;
X    static constexpr const int  min_exponent10 = 0;
N    static _LIBCPP_CONSTEXPR const int  max_exponent = 0;
X    static constexpr const int  max_exponent = 0;
N    static _LIBCPP_CONSTEXPR const int  max_exponent10 = 0;
X    static constexpr const int  max_exponent10 = 0;
N
N    static _LIBCPP_CONSTEXPR const bool has_infinity = false;
X    static constexpr const bool has_infinity = false;
N    static _LIBCPP_CONSTEXPR const bool has_quiet_NaN = false;
X    static constexpr const bool has_quiet_NaN = false;
N    static _LIBCPP_CONSTEXPR const bool has_signaling_NaN = false;
X    static constexpr const bool has_signaling_NaN = false;
N    static _LIBCPP_CONSTEXPR const float_denorm_style has_denorm = denorm_absent;
X    static constexpr const float_denorm_style has_denorm = denorm_absent;
N    static _LIBCPP_CONSTEXPR const bool has_denorm_loss = false;
X    static constexpr const bool has_denorm_loss = false;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type infinity() _NOEXCEPT {return type(0);}
X    __attribute__ ((__always_inline__)) static constexpr type infinity() noexcept {return type(0);}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return type(0);}
X    __attribute__ ((__always_inline__)) static constexpr type quiet_NaN() noexcept {return type(0);}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return type(0);}
X    __attribute__ ((__always_inline__)) static constexpr type signaling_NaN() noexcept {return type(0);}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return type(0);}
X    __attribute__ ((__always_inline__)) static constexpr type denorm_min() noexcept {return type(0);}
N
N    static _LIBCPP_CONSTEXPR const bool is_iec559 = false;
X    static constexpr const bool is_iec559 = false;
N    static _LIBCPP_CONSTEXPR const bool is_bounded = true;
X    static constexpr const bool is_bounded = true;
N    static _LIBCPP_CONSTEXPR const bool is_modulo = false;
X    static constexpr const bool is_modulo = false;
N
N    static _LIBCPP_CONSTEXPR const bool traps = false;
X    static constexpr const bool traps = false;
N    static _LIBCPP_CONSTEXPR const bool tinyness_before = false;
X    static constexpr const bool tinyness_before = false;
N    static _LIBCPP_CONSTEXPR const float_round_style round_style = round_toward_zero;
X    static constexpr const float_round_style round_style = round_toward_zero;
N};
N
Ntemplate <>
Nclass __libcpp_numeric_limits<float, true>
N{
Nprotected:
N    typedef float type;
N
N    static _LIBCPP_CONSTEXPR const bool is_specialized = true;
X    static constexpr const bool is_specialized = true;
N
N    static _LIBCPP_CONSTEXPR const bool is_signed = true;
X    static constexpr const bool is_signed = true;
N    static _LIBCPP_CONSTEXPR const int  digits = __FLT_MANT_DIG__;
X    static constexpr const int  digits = 24;
N    static _LIBCPP_CONSTEXPR const int  digits10 = __FLT_DIG__;
X    static constexpr const int  digits10 = 6;
N    static _LIBCPP_CONSTEXPR const int  max_digits10 = 2+(digits * 30103l)/100000l;
X    static constexpr const int  max_digits10 = 2+(digits * 30103l)/100000l;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type min() _NOEXCEPT {return __FLT_MIN__;}
X    __attribute__ ((__always_inline__)) static constexpr type min() noexcept {return 1.175494351E-38F;}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type max() _NOEXCEPT {return __FLT_MAX__;}
X    __attribute__ ((__always_inline__)) static constexpr type max() noexcept {return 3.402823466E+38F;}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type lowest() _NOEXCEPT {return -max();}
X    __attribute__ ((__always_inline__)) static constexpr type lowest() noexcept {return -max();}
N
N    static _LIBCPP_CONSTEXPR const bool is_integer = false;
X    static constexpr const bool is_integer = false;
N    static _LIBCPP_CONSTEXPR const bool is_exact = false;
X    static constexpr const bool is_exact = false;
N    static _LIBCPP_CONSTEXPR const int  radix = __FLT_RADIX__;
X    static constexpr const int  radix = 2;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type epsilon() _NOEXCEPT {return __FLT_EPSILON__;}
X    __attribute__ ((__always_inline__)) static constexpr type epsilon() noexcept {return 1.192092896E-07F;}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type round_error() _NOEXCEPT {return 0.5F;}
X    __attribute__ ((__always_inline__)) static constexpr type round_error() noexcept {return 0.5F;}
N
N    static _LIBCPP_CONSTEXPR const int  min_exponent = __FLT_MIN_EXP__;
X    static constexpr const int  min_exponent = (-125);
N    static _LIBCPP_CONSTEXPR const int  min_exponent10 = __FLT_MIN_10_EXP__;
X    static constexpr const int  min_exponent10 = (-37);
N    static _LIBCPP_CONSTEXPR const int  max_exponent = __FLT_MAX_EXP__;
X    static constexpr const int  max_exponent = 128;
N    static _LIBCPP_CONSTEXPR const int  max_exponent10 = __FLT_MAX_10_EXP__;
X    static constexpr const int  max_exponent10 = 38;
N
N    static _LIBCPP_CONSTEXPR const bool has_infinity = true;
X    static constexpr const bool has_infinity = true;
N    static _LIBCPP_CONSTEXPR const bool has_quiet_NaN = true;
X    static constexpr const bool has_quiet_NaN = true;
N    static _LIBCPP_CONSTEXPR const bool has_signaling_NaN = false;
X    static constexpr const bool has_signaling_NaN = false;
N    static _LIBCPP_CONSTEXPR const float_denorm_style has_denorm = denorm_absent;
X    static constexpr const float_denorm_style has_denorm = denorm_absent;
N    static _LIBCPP_CONSTEXPR const bool has_denorm_loss = false;
X    static constexpr const bool has_denorm_loss = false;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type infinity() _NOEXCEPT {return __builtin_huge_valf();}
X    __attribute__ ((__always_inline__)) static constexpr type infinity() noexcept {return __builtin_huge_valf();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return __builtin_nanf("");}
X    __attribute__ ((__always_inline__)) static constexpr type quiet_NaN() noexcept {return __builtin_nanf("");}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return __builtin_nansf("");}
X    __attribute__ ((__always_inline__)) static constexpr type signaling_NaN() noexcept {return __builtin_nansf("");}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return has_denorm == denorm_absent ? min() : __FLT_DENORM_MIN__;}
X    __attribute__ ((__always_inline__)) static constexpr type denorm_min() noexcept {return has_denorm == denorm_absent ? min() : (0.0f);}
N
N    static _LIBCPP_CONSTEXPR const bool is_iec559 = false; // Because has_signaling_NaN is false
X    static constexpr const bool is_iec559 = false; 
N    static _LIBCPP_CONSTEXPR const bool is_bounded = true;
X    static constexpr const bool is_bounded = true;
N    static _LIBCPP_CONSTEXPR const bool is_modulo = false;
X    static constexpr const bool is_modulo = false;
N
N    static _LIBCPP_CONSTEXPR const bool traps = false;
X    static constexpr const bool traps = false;
N    static _LIBCPP_CONSTEXPR const bool tinyness_before = false;
X    static constexpr const bool tinyness_before = false;
N    static _LIBCPP_CONSTEXPR const float_round_style round_style = round_to_nearest;
X    static constexpr const float_round_style round_style = round_to_nearest;
N};
N
Ntemplate <>
Nclass __libcpp_numeric_limits<double, true>
N{
Nprotected:
N    typedef double type;
N
N    static _LIBCPP_CONSTEXPR const bool is_specialized = true;
X    static constexpr const bool is_specialized = true;
N
N    static _LIBCPP_CONSTEXPR const bool is_signed = true;
X    static constexpr const bool is_signed = true;
N    static _LIBCPP_CONSTEXPR const int  digits = __DBL_MANT_DIG__;
X    static constexpr const int  digits = 53;
N    static _LIBCPP_CONSTEXPR const int  digits10 = __DBL_DIG__;
X    static constexpr const int  digits10 = 15;
N    static _LIBCPP_CONSTEXPR const int  max_digits10 = 2+(digits * 30103l)/100000l;
X    static constexpr const int  max_digits10 = 2+(digits * 30103l)/100000l;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type min() _NOEXCEPT {return __DBL_MIN__;}
X    __attribute__ ((__always_inline__)) static constexpr type min() noexcept {return 2.2250738585072014E-308;}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type max() _NOEXCEPT {return __DBL_MAX__;}
X    __attribute__ ((__always_inline__)) static constexpr type max() noexcept {return 1.7976931348623157E+308;}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type lowest() _NOEXCEPT {return -max();}
X    __attribute__ ((__always_inline__)) static constexpr type lowest() noexcept {return -max();}
N
N    static _LIBCPP_CONSTEXPR const bool is_integer = false;
X    static constexpr const bool is_integer = false;
N    static _LIBCPP_CONSTEXPR const bool is_exact = false;
X    static constexpr const bool is_exact = false;
N    static _LIBCPP_CONSTEXPR const int  radix = __FLT_RADIX__;
X    static constexpr const int  radix = 2;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type epsilon() _NOEXCEPT {return __DBL_EPSILON__;}
X    __attribute__ ((__always_inline__)) static constexpr type epsilon() noexcept {return 2.2204460492503131E-16;}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type round_error() _NOEXCEPT {return 0.5;}
X    __attribute__ ((__always_inline__)) static constexpr type round_error() noexcept {return 0.5;}
N
N    static _LIBCPP_CONSTEXPR const int  min_exponent = __DBL_MIN_EXP__;
X    static constexpr const int  min_exponent = (-1021);
N    static _LIBCPP_CONSTEXPR const int  min_exponent10 = __DBL_MIN_10_EXP__;
X    static constexpr const int  min_exponent10 = (-307);
N    static _LIBCPP_CONSTEXPR const int  max_exponent = __DBL_MAX_EXP__;
X    static constexpr const int  max_exponent = 1024;
N    static _LIBCPP_CONSTEXPR const int  max_exponent10 = __DBL_MAX_10_EXP__;
X    static constexpr const int  max_exponent10 = 308;
N
N    static _LIBCPP_CONSTEXPR const bool has_infinity = true;
X    static constexpr const bool has_infinity = true;
N    static _LIBCPP_CONSTEXPR const bool has_quiet_NaN = true;
X    static constexpr const bool has_quiet_NaN = true;
N    static _LIBCPP_CONSTEXPR const bool has_signaling_NaN = false;
X    static constexpr const bool has_signaling_NaN = false;
N    static _LIBCPP_CONSTEXPR const float_denorm_style has_denorm = denorm_absent;
X    static constexpr const float_denorm_style has_denorm = denorm_absent;
N    static _LIBCPP_CONSTEXPR const bool has_denorm_loss = false;
X    static constexpr const bool has_denorm_loss = false;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type infinity() _NOEXCEPT {return __builtin_huge_val();}
X    __attribute__ ((__always_inline__)) static constexpr type infinity() noexcept {return __builtin_huge_val();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return __builtin_nan("");}
X    __attribute__ ((__always_inline__)) static constexpr type quiet_NaN() noexcept {return __builtin_nan("");}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return __builtin_nans("");}
X    __attribute__ ((__always_inline__)) static constexpr type signaling_NaN() noexcept {return __builtin_nans("");}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return has_denorm == denorm_absent ? min() : __DBL_DENORM_MIN__;}
X    __attribute__ ((__always_inline__)) static constexpr type denorm_min() noexcept {return has_denorm == denorm_absent ? min() : (0.0);}
N
N    static _LIBCPP_CONSTEXPR const bool is_iec559 = false; // Because has_signaling_NaN is false
X    static constexpr const bool is_iec559 = false; 
N    static _LIBCPP_CONSTEXPR const bool is_bounded = true;
X    static constexpr const bool is_bounded = true;
N    static _LIBCPP_CONSTEXPR const bool is_modulo = false;
X    static constexpr const bool is_modulo = false;
N
N    static _LIBCPP_CONSTEXPR const bool traps = false;
X    static constexpr const bool traps = false;
N    static _LIBCPP_CONSTEXPR const bool tinyness_before = false;
X    static constexpr const bool tinyness_before = false;
N    static _LIBCPP_CONSTEXPR const float_round_style round_style = round_to_nearest;
X    static constexpr const float_round_style round_style = round_to_nearest;
N};
N
Ntemplate <>
Nclass __libcpp_numeric_limits<long double, true>
N{
Nprotected:
N    typedef long double type;
N
N    static _LIBCPP_CONSTEXPR const bool is_specialized = true;
X    static constexpr const bool is_specialized = true;
N
N    static _LIBCPP_CONSTEXPR const bool is_signed = true;
X    static constexpr const bool is_signed = true;
N    static _LIBCPP_CONSTEXPR const int  digits = __LDBL_MANT_DIG__;
X    static constexpr const int  digits = 53;
N    static _LIBCPP_CONSTEXPR const int  digits10 = __LDBL_DIG__;
X    static constexpr const int  digits10 = 15;
N    static _LIBCPP_CONSTEXPR const int  max_digits10 = 2+(digits * 30103l)/100000l;
X    static constexpr const int  max_digits10 = 2+(digits * 30103l)/100000l;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type min() _NOEXCEPT {return __LDBL_MIN__;}
X    __attribute__ ((__always_inline__)) static constexpr type min() noexcept {return 2.2250738585072014E-308L;}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type max() _NOEXCEPT {return __LDBL_MAX__;}
X    __attribute__ ((__always_inline__)) static constexpr type max() noexcept {return 1.7976931348623157E+308L;}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type lowest() _NOEXCEPT {return -max();}
X    __attribute__ ((__always_inline__)) static constexpr type lowest() noexcept {return -max();}
N
N    static _LIBCPP_CONSTEXPR const bool is_integer = false;
X    static constexpr const bool is_integer = false;
N    static _LIBCPP_CONSTEXPR const bool is_exact = false;
X    static constexpr const bool is_exact = false;
N    static _LIBCPP_CONSTEXPR const int  radix = __FLT_RADIX__;
X    static constexpr const int  radix = 2;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type epsilon() _NOEXCEPT {return __LDBL_EPSILON__;}
X    __attribute__ ((__always_inline__)) static constexpr type epsilon() noexcept {return 2.2204460492503131E-16L;}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type round_error() _NOEXCEPT {return 0.5;}
X    __attribute__ ((__always_inline__)) static constexpr type round_error() noexcept {return 0.5;}
N
N    static _LIBCPP_CONSTEXPR const int  min_exponent = __LDBL_MIN_EXP__;
X    static constexpr const int  min_exponent = (-1021);
N    static _LIBCPP_CONSTEXPR const int  min_exponent10 = __LDBL_MIN_10_EXP__;
X    static constexpr const int  min_exponent10 = (-307);
N    static _LIBCPP_CONSTEXPR const int  max_exponent = __LDBL_MAX_EXP__;
X    static constexpr const int  max_exponent = 1024;
N    static _LIBCPP_CONSTEXPR const int  max_exponent10 = __LDBL_MAX_10_EXP__;
X    static constexpr const int  max_exponent10 = 308;
N
N    static _LIBCPP_CONSTEXPR const bool has_infinity = true;
X    static constexpr const bool has_infinity = true;
N    static _LIBCPP_CONSTEXPR const bool has_quiet_NaN = true;
X    static constexpr const bool has_quiet_NaN = true;
N    static _LIBCPP_CONSTEXPR const bool has_signaling_NaN = false;
X    static constexpr const bool has_signaling_NaN = false;
N    static _LIBCPP_CONSTEXPR const float_denorm_style has_denorm = denorm_absent;
X    static constexpr const float_denorm_style has_denorm = denorm_absent;
N    static _LIBCPP_CONSTEXPR const bool has_denorm_loss = false;
X    static constexpr const bool has_denorm_loss = false;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type infinity() _NOEXCEPT {return __builtin_huge_vall();}
X    __attribute__ ((__always_inline__)) static constexpr type infinity() noexcept {return __builtin_huge_vall();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return __builtin_nanl("");}
X    __attribute__ ((__always_inline__)) static constexpr type quiet_NaN() noexcept {return __builtin_nanl("");}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return __builtin_nansl("");}
X    __attribute__ ((__always_inline__)) static constexpr type signaling_NaN() noexcept {return __builtin_nansl("");}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return has_denorm == denorm_absent ? min() : __LDBL_DENORM_MIN__;}
X    __attribute__ ((__always_inline__)) static constexpr type denorm_min() noexcept {return has_denorm == denorm_absent ? min() : (0.0l);}
N
N#if (defined(__ppc__) || defined(__ppc64__))
X#if (0L || 0L)
S    static _LIBCPP_CONSTEXPR const bool is_iec559 = false;
N#else
N    static _LIBCPP_CONSTEXPR const bool is_iec559 = false; // Because has_signaling_NaN is false
X    static constexpr const bool is_iec559 = false; 
N#endif
N    static _LIBCPP_CONSTEXPR const bool is_bounded = true;
X    static constexpr const bool is_bounded = true;
N    static _LIBCPP_CONSTEXPR const bool is_modulo = false;
X    static constexpr const bool is_modulo = false;
N
N    static _LIBCPP_CONSTEXPR const bool traps = false;
X    static constexpr const bool traps = false;
N    static _LIBCPP_CONSTEXPR const bool tinyness_before = false;
X    static constexpr const bool tinyness_before = false;
N    static _LIBCPP_CONSTEXPR const float_round_style round_style = round_to_nearest;
X    static constexpr const float_round_style round_style = round_to_nearest;
N};
N
Ntemplate <class _Tp>
Nclass _LIBCPP_TEMPLATE_VIS numeric_limits
Xclass  numeric_limits
N    : private __libcpp_numeric_limits<typename remove_cv<_Tp>::type>
N{
N    typedef __libcpp_numeric_limits<typename remove_cv<_Tp>::type> __base;
N    typedef typename __base::type type;
Npublic:
N    static _LIBCPP_CONSTEXPR const bool is_specialized = __base::is_specialized;
X    static constexpr const bool is_specialized = __base::is_specialized;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type min() _NOEXCEPT {return __base::min();}
X    __attribute__ ((__always_inline__)) static constexpr type min() noexcept {return __base::min();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type max() _NOEXCEPT {return __base::max();}
X    __attribute__ ((__always_inline__)) static constexpr type max() noexcept {return __base::max();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type lowest() _NOEXCEPT {return __base::lowest();}
X    __attribute__ ((__always_inline__)) static constexpr type lowest() noexcept {return __base::lowest();}
N
N    static _LIBCPP_CONSTEXPR const int  digits = __base::digits;
X    static constexpr const int  digits = __base::digits;
N    static _LIBCPP_CONSTEXPR const int  digits10 = __base::digits10;
X    static constexpr const int  digits10 = __base::digits10;
N    static _LIBCPP_CONSTEXPR const int  max_digits10 = __base::max_digits10;
X    static constexpr const int  max_digits10 = __base::max_digits10;
N    static _LIBCPP_CONSTEXPR const bool is_signed = __base::is_signed;
X    static constexpr const bool is_signed = __base::is_signed;
N    static _LIBCPP_CONSTEXPR const bool is_integer = __base::is_integer;
X    static constexpr const bool is_integer = __base::is_integer;
N    static _LIBCPP_CONSTEXPR const bool is_exact = __base::is_exact;
X    static constexpr const bool is_exact = __base::is_exact;
N    static _LIBCPP_CONSTEXPR const int  radix = __base::radix;
X    static constexpr const int  radix = __base::radix;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type epsilon() _NOEXCEPT {return __base::epsilon();}
X    __attribute__ ((__always_inline__)) static constexpr type epsilon() noexcept {return __base::epsilon();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type round_error() _NOEXCEPT {return __base::round_error();}
X    __attribute__ ((__always_inline__)) static constexpr type round_error() noexcept {return __base::round_error();}
N
N    static _LIBCPP_CONSTEXPR const int  min_exponent = __base::min_exponent;
X    static constexpr const int  min_exponent = __base::min_exponent;
N    static _LIBCPP_CONSTEXPR const int  min_exponent10 = __base::min_exponent10;
X    static constexpr const int  min_exponent10 = __base::min_exponent10;
N    static _LIBCPP_CONSTEXPR const int  max_exponent = __base::max_exponent;
X    static constexpr const int  max_exponent = __base::max_exponent;
N    static _LIBCPP_CONSTEXPR const int  max_exponent10 = __base::max_exponent10;
X    static constexpr const int  max_exponent10 = __base::max_exponent10;
N
N    static _LIBCPP_CONSTEXPR const bool has_infinity = __base::has_infinity;
X    static constexpr const bool has_infinity = __base::has_infinity;
N    static _LIBCPP_CONSTEXPR const bool has_quiet_NaN = __base::has_quiet_NaN;
X    static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
N    static _LIBCPP_CONSTEXPR const bool has_signaling_NaN = __base::has_signaling_NaN;
X    static constexpr const bool has_signaling_NaN = __base::has_signaling_NaN;
N    static _LIBCPP_CONSTEXPR const float_denorm_style has_denorm = __base::has_denorm;
X    static constexpr const float_denorm_style has_denorm = __base::has_denorm;
N    static _LIBCPP_CONSTEXPR const bool has_denorm_loss = __base::has_denorm_loss;
X    static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type infinity() _NOEXCEPT {return __base::infinity();}
X    __attribute__ ((__always_inline__)) static constexpr type infinity() noexcept {return __base::infinity();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return __base::quiet_NaN();}
X    __attribute__ ((__always_inline__)) static constexpr type quiet_NaN() noexcept {return __base::quiet_NaN();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return __base::signaling_NaN();}
X    __attribute__ ((__always_inline__)) static constexpr type signaling_NaN() noexcept {return __base::signaling_NaN();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return __base::denorm_min();}
X    __attribute__ ((__always_inline__)) static constexpr type denorm_min() noexcept {return __base::denorm_min();}
N
N    static _LIBCPP_CONSTEXPR const bool is_iec559 = __base::is_iec559;
X    static constexpr const bool is_iec559 = __base::is_iec559;
N    static _LIBCPP_CONSTEXPR const bool is_bounded = __base::is_bounded;
X    static constexpr const bool is_bounded = __base::is_bounded;
N    static _LIBCPP_CONSTEXPR const bool is_modulo = __base::is_modulo;
X    static constexpr const bool is_modulo = __base::is_modulo;
N
N    static _LIBCPP_CONSTEXPR const bool traps = __base::traps;
X    static constexpr const bool traps = __base::traps;
N    static _LIBCPP_CONSTEXPR const bool tinyness_before = __base::tinyness_before;
X    static constexpr const bool tinyness_before = __base::tinyness_before;
N    static _LIBCPP_CONSTEXPR const float_round_style round_style = __base::round_style;
X    static constexpr const float_round_style round_style = __base::round_style;
N};
N
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::is_specialized;
X    constexpr const bool numeric_limits<_Tp>::is_specialized;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<_Tp>::digits;
X    constexpr const int numeric_limits<_Tp>::digits;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<_Tp>::digits10;
X    constexpr const int numeric_limits<_Tp>::digits10;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<_Tp>::max_digits10;
X    constexpr const int numeric_limits<_Tp>::max_digits10;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::is_signed;
X    constexpr const bool numeric_limits<_Tp>::is_signed;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::is_integer;
X    constexpr const bool numeric_limits<_Tp>::is_integer;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::is_exact;
X    constexpr const bool numeric_limits<_Tp>::is_exact;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<_Tp>::radix;
X    constexpr const int numeric_limits<_Tp>::radix;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<_Tp>::min_exponent;
X    constexpr const int numeric_limits<_Tp>::min_exponent;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<_Tp>::min_exponent10;
X    constexpr const int numeric_limits<_Tp>::min_exponent10;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<_Tp>::max_exponent;
X    constexpr const int numeric_limits<_Tp>::max_exponent;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<_Tp>::max_exponent10;
X    constexpr const int numeric_limits<_Tp>::max_exponent10;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::has_infinity;
X    constexpr const bool numeric_limits<_Tp>::has_infinity;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::has_quiet_NaN;
X    constexpr const bool numeric_limits<_Tp>::has_quiet_NaN;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::has_signaling_NaN;
X    constexpr const bool numeric_limits<_Tp>::has_signaling_NaN;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const float_denorm_style numeric_limits<_Tp>::has_denorm;
X    constexpr const float_denorm_style numeric_limits<_Tp>::has_denorm;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::has_denorm_loss;
X    constexpr const bool numeric_limits<_Tp>::has_denorm_loss;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::is_iec559;
X    constexpr const bool numeric_limits<_Tp>::is_iec559;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::is_bounded;
X    constexpr const bool numeric_limits<_Tp>::is_bounded;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::is_modulo;
X    constexpr const bool numeric_limits<_Tp>::is_modulo;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::traps;
X    constexpr const bool numeric_limits<_Tp>::traps;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::tinyness_before;
X    constexpr const bool numeric_limits<_Tp>::tinyness_before;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const float_round_style numeric_limits<_Tp>::round_style;
X    constexpr const float_round_style numeric_limits<_Tp>::round_style;
N
Ntemplate <class _Tp>
Nclass _LIBCPP_TEMPLATE_VIS numeric_limits<const _Tp>
Xclass  numeric_limits<const _Tp>
N    : private numeric_limits<_Tp>
N{
N    typedef numeric_limits<_Tp> __base;
N    typedef _Tp type;
Npublic:
N    static _LIBCPP_CONSTEXPR const bool is_specialized = __base::is_specialized;
X    static constexpr const bool is_specialized = __base::is_specialized;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type min() _NOEXCEPT {return __base::min();}
X    __attribute__ ((__always_inline__)) static constexpr type min() noexcept {return __base::min();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type max() _NOEXCEPT {return __base::max();}
X    __attribute__ ((__always_inline__)) static constexpr type max() noexcept {return __base::max();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type lowest() _NOEXCEPT {return __base::lowest();}
X    __attribute__ ((__always_inline__)) static constexpr type lowest() noexcept {return __base::lowest();}
N
N    static _LIBCPP_CONSTEXPR const int  digits = __base::digits;
X    static constexpr const int  digits = __base::digits;
N    static _LIBCPP_CONSTEXPR const int  digits10 = __base::digits10;
X    static constexpr const int  digits10 = __base::digits10;
N    static _LIBCPP_CONSTEXPR const int  max_digits10 = __base::max_digits10;
X    static constexpr const int  max_digits10 = __base::max_digits10;
N    static _LIBCPP_CONSTEXPR const bool is_signed = __base::is_signed;
X    static constexpr const bool is_signed = __base::is_signed;
N    static _LIBCPP_CONSTEXPR const bool is_integer = __base::is_integer;
X    static constexpr const bool is_integer = __base::is_integer;
N    static _LIBCPP_CONSTEXPR const bool is_exact = __base::is_exact;
X    static constexpr const bool is_exact = __base::is_exact;
N    static _LIBCPP_CONSTEXPR const int  radix = __base::radix;
X    static constexpr const int  radix = __base::radix;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type epsilon() _NOEXCEPT {return __base::epsilon();}
X    __attribute__ ((__always_inline__)) static constexpr type epsilon() noexcept {return __base::epsilon();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type round_error() _NOEXCEPT {return __base::round_error();}
X    __attribute__ ((__always_inline__)) static constexpr type round_error() noexcept {return __base::round_error();}
N
N    static _LIBCPP_CONSTEXPR const int  min_exponent = __base::min_exponent;
X    static constexpr const int  min_exponent = __base::min_exponent;
N    static _LIBCPP_CONSTEXPR const int  min_exponent10 = __base::min_exponent10;
X    static constexpr const int  min_exponent10 = __base::min_exponent10;
N    static _LIBCPP_CONSTEXPR const int  max_exponent = __base::max_exponent;
X    static constexpr const int  max_exponent = __base::max_exponent;
N    static _LIBCPP_CONSTEXPR const int  max_exponent10 = __base::max_exponent10;
X    static constexpr const int  max_exponent10 = __base::max_exponent10;
N
N    static _LIBCPP_CONSTEXPR const bool has_infinity = __base::has_infinity;
X    static constexpr const bool has_infinity = __base::has_infinity;
N    static _LIBCPP_CONSTEXPR const bool has_quiet_NaN = __base::has_quiet_NaN;
X    static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
N    static _LIBCPP_CONSTEXPR const bool has_signaling_NaN = __base::has_signaling_NaN;
X    static constexpr const bool has_signaling_NaN = __base::has_signaling_NaN;
N    static _LIBCPP_CONSTEXPR const float_denorm_style has_denorm = __base::has_denorm;
X    static constexpr const float_denorm_style has_denorm = __base::has_denorm;
N    static _LIBCPP_CONSTEXPR const bool has_denorm_loss = __base::has_denorm_loss;
X    static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type infinity() _NOEXCEPT {return __base::infinity();}
X    __attribute__ ((__always_inline__)) static constexpr type infinity() noexcept {return __base::infinity();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return __base::quiet_NaN();}
X    __attribute__ ((__always_inline__)) static constexpr type quiet_NaN() noexcept {return __base::quiet_NaN();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return __base::signaling_NaN();}
X    __attribute__ ((__always_inline__)) static constexpr type signaling_NaN() noexcept {return __base::signaling_NaN();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return __base::denorm_min();}
X    __attribute__ ((__always_inline__)) static constexpr type denorm_min() noexcept {return __base::denorm_min();}
N
N    static _LIBCPP_CONSTEXPR const bool is_iec559 = __base::is_iec559;
X    static constexpr const bool is_iec559 = __base::is_iec559;
N    static _LIBCPP_CONSTEXPR const bool is_bounded = __base::is_bounded;
X    static constexpr const bool is_bounded = __base::is_bounded;
N    static _LIBCPP_CONSTEXPR const bool is_modulo = __base::is_modulo;
X    static constexpr const bool is_modulo = __base::is_modulo;
N
N    static _LIBCPP_CONSTEXPR const bool traps = __base::traps;
X    static constexpr const bool traps = __base::traps;
N    static _LIBCPP_CONSTEXPR const bool tinyness_before = __base::tinyness_before;
X    static constexpr const bool tinyness_before = __base::tinyness_before;
N    static _LIBCPP_CONSTEXPR const float_round_style round_style = __base::round_style;
X    static constexpr const float_round_style round_style = __base::round_style;
N};
N
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::is_specialized;
X    constexpr const bool numeric_limits<const _Tp>::is_specialized;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<const _Tp>::digits;
X    constexpr const int numeric_limits<const _Tp>::digits;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<const _Tp>::digits10;
X    constexpr const int numeric_limits<const _Tp>::digits10;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<const _Tp>::max_digits10;
X    constexpr const int numeric_limits<const _Tp>::max_digits10;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::is_signed;
X    constexpr const bool numeric_limits<const _Tp>::is_signed;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::is_integer;
X    constexpr const bool numeric_limits<const _Tp>::is_integer;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::is_exact;
X    constexpr const bool numeric_limits<const _Tp>::is_exact;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<const _Tp>::radix;
X    constexpr const int numeric_limits<const _Tp>::radix;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<const _Tp>::min_exponent;
X    constexpr const int numeric_limits<const _Tp>::min_exponent;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<const _Tp>::min_exponent10;
X    constexpr const int numeric_limits<const _Tp>::min_exponent10;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<const _Tp>::max_exponent;
X    constexpr const int numeric_limits<const _Tp>::max_exponent;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<const _Tp>::max_exponent10;
X    constexpr const int numeric_limits<const _Tp>::max_exponent10;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::has_infinity;
X    constexpr const bool numeric_limits<const _Tp>::has_infinity;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::has_quiet_NaN;
X    constexpr const bool numeric_limits<const _Tp>::has_quiet_NaN;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::has_signaling_NaN;
X    constexpr const bool numeric_limits<const _Tp>::has_signaling_NaN;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const float_denorm_style numeric_limits<const _Tp>::has_denorm;
X    constexpr const float_denorm_style numeric_limits<const _Tp>::has_denorm;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::has_denorm_loss;
X    constexpr const bool numeric_limits<const _Tp>::has_denorm_loss;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::is_iec559;
X    constexpr const bool numeric_limits<const _Tp>::is_iec559;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::is_bounded;
X    constexpr const bool numeric_limits<const _Tp>::is_bounded;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::is_modulo;
X    constexpr const bool numeric_limits<const _Tp>::is_modulo;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::traps;
X    constexpr const bool numeric_limits<const _Tp>::traps;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::tinyness_before;
X    constexpr const bool numeric_limits<const _Tp>::tinyness_before;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const float_round_style numeric_limits<const _Tp>::round_style;
X    constexpr const float_round_style numeric_limits<const _Tp>::round_style;
N
Ntemplate <class _Tp>
Nclass _LIBCPP_TEMPLATE_VIS numeric_limits<volatile _Tp>
Xclass  numeric_limits<volatile _Tp>
N    : private numeric_limits<_Tp>
N{
N    typedef numeric_limits<_Tp> __base;
N    typedef _Tp type;
Npublic:
N    static _LIBCPP_CONSTEXPR const bool is_specialized = __base::is_specialized;
X    static constexpr const bool is_specialized = __base::is_specialized;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type min() _NOEXCEPT {return __base::min();}
X    __attribute__ ((__always_inline__)) static constexpr type min() noexcept {return __base::min();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type max() _NOEXCEPT {return __base::max();}
X    __attribute__ ((__always_inline__)) static constexpr type max() noexcept {return __base::max();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type lowest() _NOEXCEPT {return __base::lowest();}
X    __attribute__ ((__always_inline__)) static constexpr type lowest() noexcept {return __base::lowest();}
N
N    static _LIBCPP_CONSTEXPR const int  digits = __base::digits;
X    static constexpr const int  digits = __base::digits;
N    static _LIBCPP_CONSTEXPR const int  digits10 = __base::digits10;
X    static constexpr const int  digits10 = __base::digits10;
N    static _LIBCPP_CONSTEXPR const int  max_digits10 = __base::max_digits10;
X    static constexpr const int  max_digits10 = __base::max_digits10;
N    static _LIBCPP_CONSTEXPR const bool is_signed = __base::is_signed;
X    static constexpr const bool is_signed = __base::is_signed;
N    static _LIBCPP_CONSTEXPR const bool is_integer = __base::is_integer;
X    static constexpr const bool is_integer = __base::is_integer;
N    static _LIBCPP_CONSTEXPR const bool is_exact = __base::is_exact;
X    static constexpr const bool is_exact = __base::is_exact;
N    static _LIBCPP_CONSTEXPR const int  radix = __base::radix;
X    static constexpr const int  radix = __base::radix;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type epsilon() _NOEXCEPT {return __base::epsilon();}
X    __attribute__ ((__always_inline__)) static constexpr type epsilon() noexcept {return __base::epsilon();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type round_error() _NOEXCEPT {return __base::round_error();}
X    __attribute__ ((__always_inline__)) static constexpr type round_error() noexcept {return __base::round_error();}
N
N    static _LIBCPP_CONSTEXPR const int  min_exponent = __base::min_exponent;
X    static constexpr const int  min_exponent = __base::min_exponent;
N    static _LIBCPP_CONSTEXPR const int  min_exponent10 = __base::min_exponent10;
X    static constexpr const int  min_exponent10 = __base::min_exponent10;
N    static _LIBCPP_CONSTEXPR const int  max_exponent = __base::max_exponent;
X    static constexpr const int  max_exponent = __base::max_exponent;
N    static _LIBCPP_CONSTEXPR const int  max_exponent10 = __base::max_exponent10;
X    static constexpr const int  max_exponent10 = __base::max_exponent10;
N
N    static _LIBCPP_CONSTEXPR const bool has_infinity = __base::has_infinity;
X    static constexpr const bool has_infinity = __base::has_infinity;
N    static _LIBCPP_CONSTEXPR const bool has_quiet_NaN = __base::has_quiet_NaN;
X    static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
N    static _LIBCPP_CONSTEXPR const bool has_signaling_NaN = __base::has_signaling_NaN;
X    static constexpr const bool has_signaling_NaN = __base::has_signaling_NaN;
N    static _LIBCPP_CONSTEXPR const float_denorm_style has_denorm = __base::has_denorm;
X    static constexpr const float_denorm_style has_denorm = __base::has_denorm;
N    static _LIBCPP_CONSTEXPR const bool has_denorm_loss = __base::has_denorm_loss;
X    static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type infinity() _NOEXCEPT {return __base::infinity();}
X    __attribute__ ((__always_inline__)) static constexpr type infinity() noexcept {return __base::infinity();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return __base::quiet_NaN();}
X    __attribute__ ((__always_inline__)) static constexpr type quiet_NaN() noexcept {return __base::quiet_NaN();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return __base::signaling_NaN();}
X    __attribute__ ((__always_inline__)) static constexpr type signaling_NaN() noexcept {return __base::signaling_NaN();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return __base::denorm_min();}
X    __attribute__ ((__always_inline__)) static constexpr type denorm_min() noexcept {return __base::denorm_min();}
N
N    static _LIBCPP_CONSTEXPR const bool is_iec559 = __base::is_iec559;
X    static constexpr const bool is_iec559 = __base::is_iec559;
N    static _LIBCPP_CONSTEXPR const bool is_bounded = __base::is_bounded;
X    static constexpr const bool is_bounded = __base::is_bounded;
N    static _LIBCPP_CONSTEXPR const bool is_modulo = __base::is_modulo;
X    static constexpr const bool is_modulo = __base::is_modulo;
N
N    static _LIBCPP_CONSTEXPR const bool traps = __base::traps;
X    static constexpr const bool traps = __base::traps;
N    static _LIBCPP_CONSTEXPR const bool tinyness_before = __base::tinyness_before;
X    static constexpr const bool tinyness_before = __base::tinyness_before;
N    static _LIBCPP_CONSTEXPR const float_round_style round_style = __base::round_style;
X    static constexpr const float_round_style round_style = __base::round_style;
N};
N
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::is_specialized;
X    constexpr const bool numeric_limits<volatile _Tp>::is_specialized;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<volatile _Tp>::digits;
X    constexpr const int numeric_limits<volatile _Tp>::digits;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<volatile _Tp>::digits10;
X    constexpr const int numeric_limits<volatile _Tp>::digits10;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<volatile _Tp>::max_digits10;
X    constexpr const int numeric_limits<volatile _Tp>::max_digits10;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::is_signed;
X    constexpr const bool numeric_limits<volatile _Tp>::is_signed;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::is_integer;
X    constexpr const bool numeric_limits<volatile _Tp>::is_integer;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::is_exact;
X    constexpr const bool numeric_limits<volatile _Tp>::is_exact;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<volatile _Tp>::radix;
X    constexpr const int numeric_limits<volatile _Tp>::radix;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<volatile _Tp>::min_exponent;
X    constexpr const int numeric_limits<volatile _Tp>::min_exponent;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<volatile _Tp>::min_exponent10;
X    constexpr const int numeric_limits<volatile _Tp>::min_exponent10;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<volatile _Tp>::max_exponent;
X    constexpr const int numeric_limits<volatile _Tp>::max_exponent;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<volatile _Tp>::max_exponent10;
X    constexpr const int numeric_limits<volatile _Tp>::max_exponent10;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::has_infinity;
X    constexpr const bool numeric_limits<volatile _Tp>::has_infinity;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::has_quiet_NaN;
X    constexpr const bool numeric_limits<volatile _Tp>::has_quiet_NaN;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::has_signaling_NaN;
X    constexpr const bool numeric_limits<volatile _Tp>::has_signaling_NaN;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const float_denorm_style numeric_limits<volatile _Tp>::has_denorm;
X    constexpr const float_denorm_style numeric_limits<volatile _Tp>::has_denorm;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::has_denorm_loss;
X    constexpr const bool numeric_limits<volatile _Tp>::has_denorm_loss;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::is_iec559;
X    constexpr const bool numeric_limits<volatile _Tp>::is_iec559;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::is_bounded;
X    constexpr const bool numeric_limits<volatile _Tp>::is_bounded;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::is_modulo;
X    constexpr const bool numeric_limits<volatile _Tp>::is_modulo;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::traps;
X    constexpr const bool numeric_limits<volatile _Tp>::traps;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::tinyness_before;
X    constexpr const bool numeric_limits<volatile _Tp>::tinyness_before;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const float_round_style numeric_limits<volatile _Tp>::round_style;
X    constexpr const float_round_style numeric_limits<volatile _Tp>::round_style;
N
Ntemplate <class _Tp>
Nclass _LIBCPP_TEMPLATE_VIS numeric_limits<const volatile _Tp>
Xclass  numeric_limits<const volatile _Tp>
N    : private numeric_limits<_Tp>
N{
N    typedef numeric_limits<_Tp> __base;
N    typedef _Tp type;
Npublic:
N    static _LIBCPP_CONSTEXPR const bool is_specialized = __base::is_specialized;
X    static constexpr const bool is_specialized = __base::is_specialized;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type min() _NOEXCEPT {return __base::min();}
X    __attribute__ ((__always_inline__)) static constexpr type min() noexcept {return __base::min();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type max() _NOEXCEPT {return __base::max();}
X    __attribute__ ((__always_inline__)) static constexpr type max() noexcept {return __base::max();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type lowest() _NOEXCEPT {return __base::lowest();}
X    __attribute__ ((__always_inline__)) static constexpr type lowest() noexcept {return __base::lowest();}
N
N    static _LIBCPP_CONSTEXPR const int  digits = __base::digits;
X    static constexpr const int  digits = __base::digits;
N    static _LIBCPP_CONSTEXPR const int  digits10 = __base::digits10;
X    static constexpr const int  digits10 = __base::digits10;
N    static _LIBCPP_CONSTEXPR const int  max_digits10 = __base::max_digits10;
X    static constexpr const int  max_digits10 = __base::max_digits10;
N    static _LIBCPP_CONSTEXPR const bool is_signed = __base::is_signed;
X    static constexpr const bool is_signed = __base::is_signed;
N    static _LIBCPP_CONSTEXPR const bool is_integer = __base::is_integer;
X    static constexpr const bool is_integer = __base::is_integer;
N    static _LIBCPP_CONSTEXPR const bool is_exact = __base::is_exact;
X    static constexpr const bool is_exact = __base::is_exact;
N    static _LIBCPP_CONSTEXPR const int  radix = __base::radix;
X    static constexpr const int  radix = __base::radix;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type epsilon() _NOEXCEPT {return __base::epsilon();}
X    __attribute__ ((__always_inline__)) static constexpr type epsilon() noexcept {return __base::epsilon();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type round_error() _NOEXCEPT {return __base::round_error();}
X    __attribute__ ((__always_inline__)) static constexpr type round_error() noexcept {return __base::round_error();}
N
N    static _LIBCPP_CONSTEXPR const int  min_exponent = __base::min_exponent;
X    static constexpr const int  min_exponent = __base::min_exponent;
N    static _LIBCPP_CONSTEXPR const int  min_exponent10 = __base::min_exponent10;
X    static constexpr const int  min_exponent10 = __base::min_exponent10;
N    static _LIBCPP_CONSTEXPR const int  max_exponent = __base::max_exponent;
X    static constexpr const int  max_exponent = __base::max_exponent;
N    static _LIBCPP_CONSTEXPR const int  max_exponent10 = __base::max_exponent10;
X    static constexpr const int  max_exponent10 = __base::max_exponent10;
N
N    static _LIBCPP_CONSTEXPR const bool has_infinity = __base::has_infinity;
X    static constexpr const bool has_infinity = __base::has_infinity;
N    static _LIBCPP_CONSTEXPR const bool has_quiet_NaN = __base::has_quiet_NaN;
X    static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
N    static _LIBCPP_CONSTEXPR const bool has_signaling_NaN = __base::has_signaling_NaN;
X    static constexpr const bool has_signaling_NaN = __base::has_signaling_NaN;
N    static _LIBCPP_CONSTEXPR const float_denorm_style has_denorm = __base::has_denorm;
X    static constexpr const float_denorm_style has_denorm = __base::has_denorm;
N    static _LIBCPP_CONSTEXPR const bool has_denorm_loss = __base::has_denorm_loss;
X    static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type infinity() _NOEXCEPT {return __base::infinity();}
X    __attribute__ ((__always_inline__)) static constexpr type infinity() noexcept {return __base::infinity();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return __base::quiet_NaN();}
X    __attribute__ ((__always_inline__)) static constexpr type quiet_NaN() noexcept {return __base::quiet_NaN();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return __base::signaling_NaN();}
X    __attribute__ ((__always_inline__)) static constexpr type signaling_NaN() noexcept {return __base::signaling_NaN();}
N    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return __base::denorm_min();}
X    __attribute__ ((__always_inline__)) static constexpr type denorm_min() noexcept {return __base::denorm_min();}
N
N    static _LIBCPP_CONSTEXPR const bool is_iec559 = __base::is_iec559;
X    static constexpr const bool is_iec559 = __base::is_iec559;
N    static _LIBCPP_CONSTEXPR const bool is_bounded = __base::is_bounded;
X    static constexpr const bool is_bounded = __base::is_bounded;
N    static _LIBCPP_CONSTEXPR const bool is_modulo = __base::is_modulo;
X    static constexpr const bool is_modulo = __base::is_modulo;
N
N    static _LIBCPP_CONSTEXPR const bool traps = __base::traps;
X    static constexpr const bool traps = __base::traps;
N    static _LIBCPP_CONSTEXPR const bool tinyness_before = __base::tinyness_before;
X    static constexpr const bool tinyness_before = __base::tinyness_before;
N    static _LIBCPP_CONSTEXPR const float_round_style round_style = __base::round_style;
X    static constexpr const float_round_style round_style = __base::round_style;
N};
N
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::is_specialized;
X    constexpr const bool numeric_limits<const volatile _Tp>::is_specialized;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<const volatile _Tp>::digits;
X    constexpr const int numeric_limits<const volatile _Tp>::digits;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<const volatile _Tp>::digits10;
X    constexpr const int numeric_limits<const volatile _Tp>::digits10;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<const volatile _Tp>::max_digits10;
X    constexpr const int numeric_limits<const volatile _Tp>::max_digits10;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::is_signed;
X    constexpr const bool numeric_limits<const volatile _Tp>::is_signed;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::is_integer;
X    constexpr const bool numeric_limits<const volatile _Tp>::is_integer;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::is_exact;
X    constexpr const bool numeric_limits<const volatile _Tp>::is_exact;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<const volatile _Tp>::radix;
X    constexpr const int numeric_limits<const volatile _Tp>::radix;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<const volatile _Tp>::min_exponent;
X    constexpr const int numeric_limits<const volatile _Tp>::min_exponent;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<const volatile _Tp>::min_exponent10;
X    constexpr const int numeric_limits<const volatile _Tp>::min_exponent10;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<const volatile _Tp>::max_exponent;
X    constexpr const int numeric_limits<const volatile _Tp>::max_exponent;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const int numeric_limits<const volatile _Tp>::max_exponent10;
X    constexpr const int numeric_limits<const volatile _Tp>::max_exponent10;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::has_infinity;
X    constexpr const bool numeric_limits<const volatile _Tp>::has_infinity;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::has_quiet_NaN;
X    constexpr const bool numeric_limits<const volatile _Tp>::has_quiet_NaN;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::has_signaling_NaN;
X    constexpr const bool numeric_limits<const volatile _Tp>::has_signaling_NaN;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const float_denorm_style numeric_limits<const volatile _Tp>::has_denorm;
X    constexpr const float_denorm_style numeric_limits<const volatile _Tp>::has_denorm;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::has_denorm_loss;
X    constexpr const bool numeric_limits<const volatile _Tp>::has_denorm_loss;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::is_iec559;
X    constexpr const bool numeric_limits<const volatile _Tp>::is_iec559;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::is_bounded;
X    constexpr const bool numeric_limits<const volatile _Tp>::is_bounded;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::is_modulo;
X    constexpr const bool numeric_limits<const volatile _Tp>::is_modulo;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::traps;
X    constexpr const bool numeric_limits<const volatile _Tp>::traps;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::tinyness_before;
X    constexpr const bool numeric_limits<const volatile _Tp>::tinyness_before;
Ntemplate <class _Tp>
N    _LIBCPP_CONSTEXPR const float_round_style numeric_limits<const volatile _Tp>::round_style;
X    constexpr const float_round_style numeric_limits<const volatile _Tp>::round_style;
N
N_LIBCPP_END_NAMESPACE_STD
X} }
N
N_LIBCPP_POP_MACROS
X_Pragma("pop_macro(\"min\")") _Pragma("pop_macro(\"max\")")
N
N#endif  // _LIBCPP_LIMITS
L 311 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/math.h" 2
N
N/* signbit */
N
N#ifdef signbit
N
Ntemplate <class _A1>
N_LIBCPP_ALWAYS_INLINE
X__attribute__ ((__always_inline__))
Nbool
N__libcpp_signbit(_A1 __lcpp_x) _NOEXCEPT
X__libcpp_signbit(_A1 __lcpp_x) noexcept
N{
N    return signbit(__lcpp_x);
X    return (((sizeof((__lcpp_x)) == sizeof(float)) ? (__signbitf)((__lcpp_x)) : (sizeof((__lcpp_x)) == sizeof(double)) ? (__signbit)((__lcpp_x)) : (__signbitl)((__lcpp_x))));
N}
N
N#undef signbit
N
Ntemplate <class _A1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if<std::is_floating_point<_A1>::value, bool>::type
Nsignbit(_A1 __lcpp_x) _NOEXCEPT
Xsignbit(_A1 __lcpp_x) noexcept
N{
N    return __libcpp_signbit((typename std::__promote<_A1>::type)__lcpp_x);
N}
N
Ntemplate <class _A1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if<
N    std::is_integral<_A1>::value && std::is_signed<_A1>::value, bool>::type
Nsignbit(_A1 __lcpp_x) _NOEXCEPT
Xsignbit(_A1 __lcpp_x) noexcept
N{ return __lcpp_x < 0; }
N
Ntemplate <class _A1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if<
N    std::is_integral<_A1>::value && !std::is_signed<_A1>::value, bool>::type
Nsignbit(_A1) _NOEXCEPT
Xsignbit(_A1) noexcept
N{ return false; }
N
N#elif defined(_LIBCPP_MSVCRT)
S
Stemplate <typename _A1>
Sinline _LIBCPP_INLINE_VISIBILITY
Stypename std::enable_if<std::is_floating_point<_A1>::value, bool>::type
Ssignbit(_A1 __lcpp_x) _NOEXCEPT
S{
S  return ::signbit(static_cast<typename std::__promote<_A1>::type>(__lcpp_x));
S}
S
Stemplate <class _A1>
Sinline _LIBCPP_INLINE_VISIBILITY
Stypename std::enable_if<
S    std::is_integral<_A1>::value && std::is_signed<_A1>::value, bool>::type
Ssignbit(_A1 __lcpp_x) _NOEXCEPT
S{ return __lcpp_x < 0; }
S
Stemplate <class _A1>
Sinline _LIBCPP_INLINE_VISIBILITY
Stypename std::enable_if<
S    std::is_integral<_A1>::value && !std::is_signed<_A1>::value, bool>::type
Ssignbit(_A1) _NOEXCEPT
S{ return false; }
S
N#endif  /* signbit */
N
N/* fpclassify */
N
N#ifdef fpclassify
N
Ntemplate <class _A1>
N_LIBCPP_ALWAYS_INLINE
X__attribute__ ((__always_inline__))
Nint
N__libcpp_fpclassify(_A1 __lcpp_x) _NOEXCEPT
X__libcpp_fpclassify(_A1 __lcpp_x) noexcept
N{
N    return fpclassify(__lcpp_x);
X    return (((sizeof((__lcpp_x)) == sizeof(float)) ? (__fpclassifyf)((__lcpp_x)) : (sizeof((__lcpp_x)) == sizeof(double)) ? (__fpclassify)((__lcpp_x)) : (__fpclassifyl)((__lcpp_x))));
N}
N
N#undef fpclassify
N
Ntemplate <class _A1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if<std::is_floating_point<_A1>::value, int>::type
Nfpclassify(_A1 __lcpp_x) _NOEXCEPT
Xfpclassify(_A1 __lcpp_x) noexcept
N{
N    return __libcpp_fpclassify((typename std::__promote<_A1>::type)__lcpp_x);
N}
N
Ntemplate <class _A1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if<std::is_integral<_A1>::value, int>::type
Nfpclassify(_A1 __lcpp_x) _NOEXCEPT
Xfpclassify(_A1 __lcpp_x) noexcept
N{ return __lcpp_x == 0 ? FP_ZERO : FP_NORMAL; }
X{ return __lcpp_x == 0 ? (0) : ((-1)); }
N
N#elif defined(_LIBCPP_MSVCRT)
S
Stemplate <typename _A1>
Sinline _LIBCPP_INLINE_VISIBILITY
Stypename std::enable_if<std::is_floating_point<_A1>::value, bool>::type
Sfpclassify(_A1 __lcpp_x) _NOEXCEPT
S{
S  return ::fpclassify(static_cast<typename std::__promote<_A1>::type>(__lcpp_x));
S}
S
Stemplate <class _A1>
Sinline _LIBCPP_INLINE_VISIBILITY
Stypename std::enable_if<std::is_integral<_A1>::value, int>::type
Sfpclassify(_A1 __lcpp_x) _NOEXCEPT
S{ return __lcpp_x == 0 ? FP_ZERO : FP_NORMAL; }
S
N#endif  /* fpclassify */
N
N/* isfinite */
N
N#ifdef isfinite
N
Ntemplate <class _A1>
N_LIBCPP_ALWAYS_INLINE
X__attribute__ ((__always_inline__))
Nbool
N__libcpp_isfinite(_A1 __lcpp_x) _NOEXCEPT
X__libcpp_isfinite(_A1 __lcpp_x) noexcept
N{
N    return isfinite(__lcpp_x);
X    return (((sizeof((__lcpp_x)) == sizeof(float)) ? (__isfinitef)((__lcpp_x)) : (sizeof((__lcpp_x)) == sizeof(double)) ? (__isfinite)((__lcpp_x)) : (__isfinitel)((__lcpp_x))));
N}
N
N#undef isfinite
N
Ntemplate <class _A1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if<
N    std::is_arithmetic<_A1>::value && std::numeric_limits<_A1>::has_infinity,
N    bool>::type
Nisfinite(_A1 __lcpp_x) _NOEXCEPT
Xisfinite(_A1 __lcpp_x) noexcept
N{
N    return __libcpp_isfinite((typename std::__promote<_A1>::type)__lcpp_x);
N}
N
Ntemplate <class _A1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if<
N    std::is_arithmetic<_A1>::value && !std::numeric_limits<_A1>::has_infinity,
N    bool>::type
Nisfinite(_A1) _NOEXCEPT
Xisfinite(_A1) noexcept
N{ return true; }
N
N#endif  /* isfinite */
N
N/* isinf */
N
N#ifdef isinf
N
Ntemplate <class _A1>
N_LIBCPP_ALWAYS_INLINE
X__attribute__ ((__always_inline__))
Nbool
N__libcpp_isinf(_A1 __lcpp_x) _NOEXCEPT
X__libcpp_isinf(_A1 __lcpp_x) noexcept
N{
N    return isinf(__lcpp_x);
X    return (((sizeof((__lcpp_x)) == sizeof(float)) ? (__isinff)((__lcpp_x)) : (sizeof((__lcpp_x)) == sizeof(double)) ? (__isinf)((__lcpp_x)) : (__isinfl)((__lcpp_x))));
N}
N
N#undef isinf
N
Ntemplate <class _A1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if<
N    std::is_arithmetic<_A1>::value && std::numeric_limits<_A1>::has_infinity,
N    bool>::type
Nisinf(_A1 __lcpp_x) _NOEXCEPT
Xisinf(_A1 __lcpp_x) noexcept
N{
N    return __libcpp_isinf((typename std::__promote<_A1>::type)__lcpp_x);
N}
N
Ntemplate <class _A1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if<
N    std::is_arithmetic<_A1>::value && !std::numeric_limits<_A1>::has_infinity,
N    bool>::type
Nisinf(_A1) _NOEXCEPT
Xisinf(_A1) noexcept
N{ return false; }
N
N#endif  /* isinf */
N
N/* isnan */
N
N#ifdef isnan
N
Ntemplate <class _A1>
N_LIBCPP_ALWAYS_INLINE
X__attribute__ ((__always_inline__))
Nbool
N__libcpp_isnan(_A1 __lcpp_x) _NOEXCEPT
X__libcpp_isnan(_A1 __lcpp_x) noexcept
N{
N    return isnan(__lcpp_x);
X    return (((sizeof((__lcpp_x)) == sizeof(float)) ? (__isnanf)((__lcpp_x)) : (sizeof((__lcpp_x)) == sizeof(double)) ? (__isnan)((__lcpp_x)) : (__isnanl)((__lcpp_x))));
N}
N
N#undef isnan
N
Ntemplate <class _A1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if<std::is_floating_point<_A1>::value, bool>::type
Nisnan(_A1 __lcpp_x) _NOEXCEPT
Xisnan(_A1 __lcpp_x) noexcept
N{
N    return __libcpp_isnan((typename std::__promote<_A1>::type)__lcpp_x);
N}
N
Ntemplate <class _A1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if<std::is_integral<_A1>::value, bool>::type
Nisnan(_A1) _NOEXCEPT
Xisnan(_A1) noexcept
N{ return false; }
N
N#endif  /* isnan */
N
N/* isnormal */
N
N#ifdef isnormal
N
Ntemplate <class _A1>
N_LIBCPP_ALWAYS_INLINE
X__attribute__ ((__always_inline__))
Nbool
N__libcpp_isnormal(_A1 __lcpp_x) _NOEXCEPT
X__libcpp_isnormal(_A1 __lcpp_x) noexcept
N{
N    return isnormal(__lcpp_x);
X    return (((sizeof((__lcpp_x)) == sizeof(float)) ? (__isnormalf)((__lcpp_x)) : (sizeof((__lcpp_x)) == sizeof(double)) ? (__isnormal)((__lcpp_x)) : (__isnormall)((__lcpp_x))));
N}
N
N#undef isnormal
N
Ntemplate <class _A1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if<std::is_floating_point<_A1>::value, bool>::type
Nisnormal(_A1 __lcpp_x) _NOEXCEPT
Xisnormal(_A1 __lcpp_x) noexcept
N{
N    return __libcpp_isnormal((typename std::__promote<_A1>::type)__lcpp_x);
N}
N
Ntemplate <class _A1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if<std::is_integral<_A1>::value, bool>::type
Nisnormal(_A1 __lcpp_x) _NOEXCEPT
Xisnormal(_A1 __lcpp_x) noexcept
N{ return __lcpp_x != 0; }
N
N#endif  /* isnormal */
N
N/* isgreater */
N
N#ifdef isgreater
N
Ntemplate <class _A1, class _A2>
N_LIBCPP_ALWAYS_INLINE
X__attribute__ ((__always_inline__))
Nbool
N__libcpp_isgreater(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT
X__libcpp_isgreater(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
N{
N    return isgreater(__lcpp_x, __lcpp_y);
X    return (!(isnan((__lcpp_x)) || isnan((__lcpp_y))) && (__lcpp_x) > (__lcpp_y));
N}
N
N#undef isgreater
N
Ntemplate <class _A1, class _A2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if
N<
N    std::is_arithmetic<_A1>::value &&
N    std::is_arithmetic<_A2>::value,
N    bool
N>::type
Nisgreater(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT
Xisgreater(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
N{
N    typedef typename std::__promote<_A1, _A2>::type type;
N    return __libcpp_isgreater((type)__lcpp_x, (type)__lcpp_y);
N}
N
N#endif  /* isgreater */
N
N/* isgreaterequal */
N
N#ifdef isgreaterequal
N
Ntemplate <class _A1, class _A2>
N_LIBCPP_ALWAYS_INLINE
X__attribute__ ((__always_inline__))
Nbool
N__libcpp_isgreaterequal(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT
X__libcpp_isgreaterequal(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
N{
N    return isgreaterequal(__lcpp_x, __lcpp_y);
X    return (!(isnan((__lcpp_x)) || isnan((__lcpp_y))) && (__lcpp_x) >= (__lcpp_y));
N}
N
N#undef isgreaterequal
N
Ntemplate <class _A1, class _A2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if
N<
N    std::is_arithmetic<_A1>::value &&
N    std::is_arithmetic<_A2>::value,
N    bool
N>::type
Nisgreaterequal(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT
Xisgreaterequal(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
N{
N    typedef typename std::__promote<_A1, _A2>::type type;
N    return __libcpp_isgreaterequal((type)__lcpp_x, (type)__lcpp_y);
N}
N
N#endif  /* isgreaterequal */
N
N/* isless */
N
N#ifdef isless
N
Ntemplate <class _A1, class _A2>
N_LIBCPP_ALWAYS_INLINE
X__attribute__ ((__always_inline__))
Nbool
N__libcpp_isless(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT
X__libcpp_isless(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
N{
N    return isless(__lcpp_x, __lcpp_y);
X    return (!(isnan((__lcpp_x)) || isnan((__lcpp_y))) && (__lcpp_x) < (__lcpp_y));
N}
N
N#undef isless
N
Ntemplate <class _A1, class _A2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if
N<
N    std::is_arithmetic<_A1>::value &&
N    std::is_arithmetic<_A2>::value,
N    bool
N>::type
Nisless(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT
Xisless(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
N{
N    typedef typename std::__promote<_A1, _A2>::type type;
N    return __libcpp_isless((type)__lcpp_x, (type)__lcpp_y);
N}
N
N#endif  /* isless */
N
N/* islessequal */
N
N#ifdef islessequal
N
Ntemplate <class _A1, class _A2>
N_LIBCPP_ALWAYS_INLINE
X__attribute__ ((__always_inline__))
Nbool
N__libcpp_islessequal(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT
X__libcpp_islessequal(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
N{
N    return islessequal(__lcpp_x, __lcpp_y);
X    return (!(isnan((__lcpp_x)) || isnan((__lcpp_y))) && (__lcpp_x) <= (__lcpp_y));
N}
N
N#undef islessequal
N
Ntemplate <class _A1, class _A2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if
N<
N    std::is_arithmetic<_A1>::value &&
N    std::is_arithmetic<_A2>::value,
N    bool
N>::type
Nislessequal(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT
Xislessequal(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
N{
N    typedef typename std::__promote<_A1, _A2>::type type;
N    return __libcpp_islessequal((type)__lcpp_x, (type)__lcpp_y);
N}
N
N#endif  /* islessequal */
N
N/* islessgreater */
N
N#ifdef islessgreater
N
Ntemplate <class _A1, class _A2>
N_LIBCPP_ALWAYS_INLINE
X__attribute__ ((__always_inline__))
Nbool
N__libcpp_islessgreater(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT
X__libcpp_islessgreater(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
N{
N    return islessgreater(__lcpp_x, __lcpp_y);
X    return (!(isnan((__lcpp_x)) || isnan((__lcpp_y))) && ((__lcpp_x) > (__lcpp_y) || (__lcpp_y) > (__lcpp_x)));
N}
N
N#undef islessgreater
N
Ntemplate <class _A1, class _A2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if
N<
N    std::is_arithmetic<_A1>::value &&
N    std::is_arithmetic<_A2>::value,
N    bool
N>::type
Nislessgreater(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT
Xislessgreater(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
N{
N    typedef typename std::__promote<_A1, _A2>::type type;
N    return __libcpp_islessgreater((type)__lcpp_x, (type)__lcpp_y);
N}
N
N#endif  /* islessgreater */
N
N/* isunordered */
N
N#ifdef isunordered
N
Ntemplate <class _A1, class _A2>
N_LIBCPP_ALWAYS_INLINE
X__attribute__ ((__always_inline__))
Nbool
N__libcpp_isunordered(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT
X__libcpp_isunordered(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
N{
N    return isunordered(__lcpp_x, __lcpp_y);
X    return (isnan(__lcpp_x) || isnan(__lcpp_y));
N}
N
N#undef isunordered
N
Ntemplate <class _A1, class _A2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if
N<
N    std::is_arithmetic<_A1>::value &&
N    std::is_arithmetic<_A2>::value,
N    bool
N>::type
Nisunordered(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT
Xisunordered(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
N{
N    typedef typename std::__promote<_A1, _A2>::type type;
N    return __libcpp_isunordered((type)__lcpp_x, (type)__lcpp_y);
N}
N
N#endif  /* isunordered */
N
N/* abs */
N
N#if !(defined(_AIX) || defined(__sun__))
X#if !(0L || 0L)
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nfloat
Nabs(float __lcpp_x) _NOEXCEPT {return ::fabsf(__lcpp_x);}
Xabs(float __lcpp_x) noexcept {return ::fabsf(__lcpp_x);}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ndouble
Nabs(double __lcpp_x) _NOEXCEPT {return ::fabs(__lcpp_x);}
Xabs(double __lcpp_x) noexcept {return ::fabs(__lcpp_x);}
N
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Nlong double
Nabs(long double __lcpp_x) _NOEXCEPT {return ::fabsl(__lcpp_x);}
Xabs(long double __lcpp_x) noexcept {return ::fabsl(__lcpp_x);}
N#endif /* !(defined(_AIX) || defined(__sun__)) */
N
N/* acos */
N
N#if !(defined(_AIX) || defined(__sun__))
X#if !(0L || 0L)
Ninline _LIBCPP_INLINE_VISIBILITY float       acos(float __lcpp_x) _NOEXCEPT       {return ::acosf(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) float       acos(float __lcpp_x) noexcept       {return ::acosf(__lcpp_x);}
Ninline _LIBCPP_INLINE_VISIBILITY long double acos(long double __lcpp_x) _NOEXCEPT {return ::acosl(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) long double acos(long double __lcpp_x) noexcept {return ::acosl(__lcpp_x);}
N#endif
N
Ntemplate <class _A1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if<std::is_integral<_A1>::value, double>::type
Nacos(_A1 __lcpp_x) _NOEXCEPT {return ::acos((double)__lcpp_x);}
Xacos(_A1 __lcpp_x) noexcept {return ::acos((double)__lcpp_x);}
N
N/* asin */
N
N#if !(defined(_AIX) || defined(__sun__))
X#if !(0L || 0L)
Ninline _LIBCPP_INLINE_VISIBILITY float       asin(float __lcpp_x) _NOEXCEPT       {return ::asinf(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) float       asin(float __lcpp_x) noexcept       {return ::asinf(__lcpp_x);}
Ninline _LIBCPP_INLINE_VISIBILITY long double asin(long double __lcpp_x) _NOEXCEPT {return ::asinl(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) long double asin(long double __lcpp_x) noexcept {return ::asinl(__lcpp_x);}
N#endif
N
Ntemplate <class _A1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if<std::is_integral<_A1>::value, double>::type
Nasin(_A1 __lcpp_x) _NOEXCEPT {return ::asin((double)__lcpp_x);}
Xasin(_A1 __lcpp_x) noexcept {return ::asin((double)__lcpp_x);}
N
N/* atan */
N
N#if !(defined(_AIX) || defined(__sun__))
X#if !(0L || 0L)
Ninline _LIBCPP_INLINE_VISIBILITY float       atan(float __lcpp_x) _NOEXCEPT       {return ::atanf(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) float       atan(float __lcpp_x) noexcept       {return ::atanf(__lcpp_x);}
Ninline _LIBCPP_INLINE_VISIBILITY long double atan(long double __lcpp_x) _NOEXCEPT {return ::atanl(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) long double atan(long double __lcpp_x) noexcept {return ::atanl(__lcpp_x);}
N#endif
N
Ntemplate <class _A1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if<std::is_integral<_A1>::value, double>::type
Natan(_A1 __lcpp_x) _NOEXCEPT {return ::atan((double)__lcpp_x);}
Xatan(_A1 __lcpp_x) noexcept {return ::atan((double)__lcpp_x);}
N
N/* atan2 */
N
N#if !(defined(_AIX) || defined(__sun__))
X#if !(0L || 0L)
Ninline _LIBCPP_INLINE_VISIBILITY float       atan2(float __lcpp_y, float __lcpp_x) _NOEXCEPT             {return ::atan2f(__lcpp_y, __lcpp_x);}
Xinline __attribute__ ((__always_inline__)) float       atan2(float __lcpp_y, float __lcpp_x) noexcept             {return ::atan2f(__lcpp_y, __lcpp_x);}
Ninline _LIBCPP_INLINE_VISIBILITY long double atan2(long double __lcpp_y, long double __lcpp_x) _NOEXCEPT {return ::atan2l(__lcpp_y, __lcpp_x);}
Xinline __attribute__ ((__always_inline__)) long double atan2(long double __lcpp_y, long double __lcpp_x) noexcept {return ::atan2l(__lcpp_y, __lcpp_x);}
N#endif
N
Ntemplate <class _A1, class _A2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::__lazy_enable_if
N<
N    std::is_arithmetic<_A1>::value &&
N    std::is_arithmetic<_A2>::value,
N    std::__promote<_A1, _A2>
N>::type
Natan2(_A1 __lcpp_y, _A2 __lcpp_x) _NOEXCEPT
Xatan2(_A1 __lcpp_y, _A2 __lcpp_x) noexcept
N{
N    typedef typename std::__promote<_A1, _A2>::type __result_type;
N    static_assert((!(std::is_same<_A1, __result_type>::value &&
N                     std::is_same<_A2, __result_type>::value)), "");
N    return ::atan2((__result_type)__lcpp_y, (__result_type)__lcpp_x);
N}
N
N/* ceil */
N
N#if !(defined(_AIX) || defined(__sun__))
X#if !(0L || 0L)
Ninline _LIBCPP_INLINE_VISIBILITY float       ceil(float __lcpp_x) _NOEXCEPT       {return ::ceilf(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) float       ceil(float __lcpp_x) noexcept       {return ::ceilf(__lcpp_x);}
Ninline _LIBCPP_INLINE_VISIBILITY long double ceil(long double __lcpp_x) _NOEXCEPT {return ::ceill(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) long double ceil(long double __lcpp_x) noexcept {return ::ceill(__lcpp_x);}
N#endif
N
Ntemplate <class _A1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if<std::is_integral<_A1>::value, double>::type
Nceil(_A1 __lcpp_x) _NOEXCEPT {return ::ceil((double)__lcpp_x);}
Xceil(_A1 __lcpp_x) noexcept {return ::ceil((double)__lcpp_x);}
N
N/* cos */
N
N#if !(defined(_AIX) || defined(__sun__))
X#if !(0L || 0L)
Ninline _LIBCPP_INLINE_VISIBILITY float       cos(float __lcpp_x) _NOEXCEPT       {return ::cosf(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) float       cos(float __lcpp_x) noexcept       {return ::cosf(__lcpp_x);}
Ninline _LIBCPP_INLINE_VISIBILITY long double cos(long double __lcpp_x) _NOEXCEPT {return ::cosl(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) long double cos(long double __lcpp_x) noexcept {return ::cosl(__lcpp_x);}
N#endif
N
Ntemplate <class _A1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if<std::is_integral<_A1>::value, double>::type
Ncos(_A1 __lcpp_x) _NOEXCEPT {return ::cos((double)__lcpp_x);}
Xcos(_A1 __lcpp_x) noexcept {return ::cos((double)__lcpp_x);}
N
N/* cosh */
N
N#if !(defined(_AIX) || defined(__sun__))
X#if !(0L || 0L)
Ninline _LIBCPP_INLINE_VISIBILITY float       cosh(float __lcpp_x) _NOEXCEPT       {return ::coshf(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) float       cosh(float __lcpp_x) noexcept       {return ::coshf(__lcpp_x);}
Ninline _LIBCPP_INLINE_VISIBILITY long double cosh(long double __lcpp_x) _NOEXCEPT {return ::coshl(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) long double cosh(long double __lcpp_x) noexcept {return ::coshl(__lcpp_x);}
N#endif
N
Ntemplate <class _A1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if<std::is_integral<_A1>::value, double>::type
Ncosh(_A1 __lcpp_x) _NOEXCEPT {return ::cosh((double)__lcpp_x);}
Xcosh(_A1 __lcpp_x) noexcept {return ::cosh((double)__lcpp_x);}
N
N/* exp */
N
N#if !(defined(_AIX) || defined(__sun__))
X#if !(0L || 0L)
Ninline _LIBCPP_INLINE_VISIBILITY float       exp(float __lcpp_x) _NOEXCEPT       {return ::expf(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) float       exp(float __lcpp_x) noexcept       {return ::expf(__lcpp_x);}
Ninline _LIBCPP_INLINE_VISIBILITY long double exp(long double __lcpp_x) _NOEXCEPT {return ::expl(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) long double exp(long double __lcpp_x) noexcept {return ::expl(__lcpp_x);}
N#endif
N
Ntemplate <class _A1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if<std::is_integral<_A1>::value, double>::type
Nexp(_A1 __lcpp_x) _NOEXCEPT {return ::exp((double)__lcpp_x);}
Xexp(_A1 __lcpp_x) noexcept {return ::exp((double)__lcpp_x);}
N
N/* fabs */
N
N#if !(defined(_AIX) || defined(__sun__))
X#if !(0L || 0L)
Ninline _LIBCPP_INLINE_VISIBILITY float       fabs(float __lcpp_x) _NOEXCEPT       {return ::fabsf(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) float       fabs(float __lcpp_x) noexcept       {return ::fabsf(__lcpp_x);}
Ninline _LIBCPP_INLINE_VISIBILITY long double fabs(long double __lcpp_x) _NOEXCEPT {return ::fabsl(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) long double fabs(long double __lcpp_x) noexcept {return ::fabsl(__lcpp_x);}
N#endif
N
Ntemplate <class _A1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if<std::is_integral<_A1>::value, double>::type
Nfabs(_A1 __lcpp_x) _NOEXCEPT {return ::fabs((double)__lcpp_x);}
Xfabs(_A1 __lcpp_x) noexcept {return ::fabs((double)__lcpp_x);}
N
N/* floor */
N
N#if !(defined(_AIX) || defined(__sun__))
X#if !(0L || 0L)
Ninline _LIBCPP_INLINE_VISIBILITY float       floor(float __lcpp_x) _NOEXCEPT       {return ::floorf(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) float       floor(float __lcpp_x) noexcept       {return ::floorf(__lcpp_x);}
Ninline _LIBCPP_INLINE_VISIBILITY long double floor(long double __lcpp_x) _NOEXCEPT {return ::floorl(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) long double floor(long double __lcpp_x) noexcept {return ::floorl(__lcpp_x);}
N#endif
N
Ntemplate <class _A1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if<std::is_integral<_A1>::value, double>::type
Nfloor(_A1 __lcpp_x) _NOEXCEPT {return ::floor((double)__lcpp_x);}
Xfloor(_A1 __lcpp_x) noexcept {return ::floor((double)__lcpp_x);}
N
N/* fmod */
N
N#if !(defined(_AIX) || defined(__sun__))
X#if !(0L || 0L)
Ninline _LIBCPP_INLINE_VISIBILITY float       fmod(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return ::fmodf(__lcpp_x, __lcpp_y);}
Xinline __attribute__ ((__always_inline__)) float       fmod(float __lcpp_x, float __lcpp_y) noexcept             {return ::fmodf(__lcpp_x, __lcpp_y);}
Ninline _LIBCPP_INLINE_VISIBILITY long double fmod(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return ::fmodl(__lcpp_x, __lcpp_y);}
Xinline __attribute__ ((__always_inline__)) long double fmod(long double __lcpp_x, long double __lcpp_y) noexcept {return ::fmodl(__lcpp_x, __lcpp_y);}
N#endif
N
Ntemplate <class _A1, class _A2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::__lazy_enable_if
N<
N    std::is_arithmetic<_A1>::value &&
N    std::is_arithmetic<_A2>::value,
N    std::__promote<_A1, _A2>
N>::type
Nfmod(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT
Xfmod(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
N{
N    typedef typename std::__promote<_A1, _A2>::type __result_type;
N    static_assert((!(std::is_same<_A1, __result_type>::value &&
N                     std::is_same<_A2, __result_type>::value)), "");
N    return ::fmod((__result_type)__lcpp_x, (__result_type)__lcpp_y);
N}
N
N/* frexp */
N
N#if !(defined(_AIX) || defined(__sun__))
X#if !(0L || 0L)
Ninline _LIBCPP_INLINE_VISIBILITY float       frexp(float __lcpp_x, int* __lcpp_e) _NOEXCEPT       {return ::frexpf(__lcpp_x, __lcpp_e);}
Xinline __attribute__ ((__always_inline__)) float       frexp(float __lcpp_x, int* __lcpp_e) noexcept       {return ::frexpf(__lcpp_x, __lcpp_e);}
Ninline _LIBCPP_INLINE_VISIBILITY long double frexp(long double __lcpp_x, int* __lcpp_e) _NOEXCEPT {return ::frexpl(__lcpp_x, __lcpp_e);}
Xinline __attribute__ ((__always_inline__)) long double frexp(long double __lcpp_x, int* __lcpp_e) noexcept {return ::frexpl(__lcpp_x, __lcpp_e);}
N#endif
N
Ntemplate <class _A1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if<std::is_integral<_A1>::value, double>::type
Nfrexp(_A1 __lcpp_x, int* __lcpp_e) _NOEXCEPT {return ::frexp((double)__lcpp_x, __lcpp_e);}
Xfrexp(_A1 __lcpp_x, int* __lcpp_e) noexcept {return ::frexp((double)__lcpp_x, __lcpp_e);}
N
N/* ldexp */
N
N#if !(defined(_AIX) || defined(__sun__))
X#if !(0L || 0L)
Ninline _LIBCPP_INLINE_VISIBILITY float       ldexp(float __lcpp_x, int __lcpp_e) _NOEXCEPT       {return ::ldexpf(__lcpp_x, __lcpp_e);}
Xinline __attribute__ ((__always_inline__)) float       ldexp(float __lcpp_x, int __lcpp_e) noexcept       {return ::ldexpf(__lcpp_x, __lcpp_e);}
Ninline _LIBCPP_INLINE_VISIBILITY long double ldexp(long double __lcpp_x, int __lcpp_e) _NOEXCEPT {return ::ldexpl(__lcpp_x, __lcpp_e);}
Xinline __attribute__ ((__always_inline__)) long double ldexp(long double __lcpp_x, int __lcpp_e) noexcept {return ::ldexpl(__lcpp_x, __lcpp_e);}
N#endif
N
Ntemplate <class _A1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if<std::is_integral<_A1>::value, double>::type
Nldexp(_A1 __lcpp_x, int __lcpp_e) _NOEXCEPT {return ::ldexp((double)__lcpp_x, __lcpp_e);}
Xldexp(_A1 __lcpp_x, int __lcpp_e) noexcept {return ::ldexp((double)__lcpp_x, __lcpp_e);}
N
N/* log */
N
N#if !(defined(_AIX) || defined(__sun__))
X#if !(0L || 0L)
Ninline _LIBCPP_INLINE_VISIBILITY float       log(float __lcpp_x) _NOEXCEPT       {return ::logf(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) float       log(float __lcpp_x) noexcept       {return ::logf(__lcpp_x);}
Ninline _LIBCPP_INLINE_VISIBILITY long double log(long double __lcpp_x) _NOEXCEPT {return ::logl(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) long double log(long double __lcpp_x) noexcept {return ::logl(__lcpp_x);}
N#endif
N
Ntemplate <class _A1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if<std::is_integral<_A1>::value, double>::type
Nlog(_A1 __lcpp_x) _NOEXCEPT {return ::log((double)__lcpp_x);}
Xlog(_A1 __lcpp_x) noexcept {return ::log((double)__lcpp_x);}
N
N/* log10 */
N
N#if !(defined(_AIX) || defined(__sun__))
X#if !(0L || 0L)
Ninline _LIBCPP_INLINE_VISIBILITY float       log10(float __lcpp_x) _NOEXCEPT       {return ::log10f(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) float       log10(float __lcpp_x) noexcept       {return ::log10f(__lcpp_x);}
Ninline _LIBCPP_INLINE_VISIBILITY long double log10(long double __lcpp_x) _NOEXCEPT {return ::log10l(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) long double log10(long double __lcpp_x) noexcept {return ::log10l(__lcpp_x);}
N#endif
N
Ntemplate <class _A1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if<std::is_integral<_A1>::value, double>::type
Nlog10(_A1 __lcpp_x) _NOEXCEPT {return ::log10((double)__lcpp_x);}
Xlog10(_A1 __lcpp_x) noexcept {return ::log10((double)__lcpp_x);}
N
N/* modf */
N
N#if !(defined(_AIX) || defined(__sun__))
X#if !(0L || 0L)
Ninline _LIBCPP_INLINE_VISIBILITY float       modf(float __lcpp_x, float* __lcpp_y) _NOEXCEPT             {return ::modff(__lcpp_x, __lcpp_y);}
Xinline __attribute__ ((__always_inline__)) float       modf(float __lcpp_x, float* __lcpp_y) noexcept             {return ::modff(__lcpp_x, __lcpp_y);}
Ninline _LIBCPP_INLINE_VISIBILITY long double modf(long double __lcpp_x, long double* __lcpp_y) _NOEXCEPT {return ::modfl(__lcpp_x, __lcpp_y);}
Xinline __attribute__ ((__always_inline__)) long double modf(long double __lcpp_x, long double* __lcpp_y) noexcept {return ::modfl(__lcpp_x, __lcpp_y);}
N#endif
N
N/* pow */
N
N#if !(defined(_AIX) || defined(__sun__))
X#if !(0L || 0L)
Ninline _LIBCPP_INLINE_VISIBILITY float       pow(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return ::powf(__lcpp_x, __lcpp_y);}
Xinline __attribute__ ((__always_inline__)) float       pow(float __lcpp_x, float __lcpp_y) noexcept             {return ::powf(__lcpp_x, __lcpp_y);}
Ninline _LIBCPP_INLINE_VISIBILITY long double pow(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return ::powl(__lcpp_x, __lcpp_y);}
Xinline __attribute__ ((__always_inline__)) long double pow(long double __lcpp_x, long double __lcpp_y) noexcept {return ::powl(__lcpp_x, __lcpp_y);}
N#endif
N
Ntemplate <class _A1, class _A2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::__lazy_enable_if
N<
N    std::is_arithmetic<_A1>::value &&
N    std::is_arithmetic<_A2>::value,
N    std::__promote<_A1, _A2>
N>::type
Npow(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT
Xpow(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
N{
N    typedef typename std::__promote<_A1, _A2>::type __result_type;
N    static_assert((!(std::is_same<_A1, __result_type>::value &&
N                     std::is_same<_A2, __result_type>::value)), "");
N    return ::pow((__result_type)__lcpp_x, (__result_type)__lcpp_y);
N}
N
N/* sin */
N
N#if !(defined(_AIX) || defined(__sun__))
X#if !(0L || 0L)
Ninline _LIBCPP_INLINE_VISIBILITY float       sin(float __lcpp_x) _NOEXCEPT       {return ::sinf(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) float       sin(float __lcpp_x) noexcept       {return ::sinf(__lcpp_x);}
Ninline _LIBCPP_INLINE_VISIBILITY long double sin(long double __lcpp_x) _NOEXCEPT {return ::sinl(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) long double sin(long double __lcpp_x) noexcept {return ::sinl(__lcpp_x);}
N#endif
N
Ntemplate <class _A1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if<std::is_integral<_A1>::value, double>::type
Nsin(_A1 __lcpp_x) _NOEXCEPT {return ::sin((double)__lcpp_x);}
Xsin(_A1 __lcpp_x) noexcept {return ::sin((double)__lcpp_x);}
N
N/* sinh */
N
N#if !(defined(_AIX) || defined(__sun__))
X#if !(0L || 0L)
Ninline _LIBCPP_INLINE_VISIBILITY float       sinh(float __lcpp_x) _NOEXCEPT       {return ::sinhf(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) float       sinh(float __lcpp_x) noexcept       {return ::sinhf(__lcpp_x);}
Ninline _LIBCPP_INLINE_VISIBILITY long double sinh(long double __lcpp_x) _NOEXCEPT {return ::sinhl(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) long double sinh(long double __lcpp_x) noexcept {return ::sinhl(__lcpp_x);}
N#endif
N
Ntemplate <class _A1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if<std::is_integral<_A1>::value, double>::type
Nsinh(_A1 __lcpp_x) _NOEXCEPT {return ::sinh((double)__lcpp_x);}
Xsinh(_A1 __lcpp_x) noexcept {return ::sinh((double)__lcpp_x);}
N
N/* sqrt */
N
N#if !(defined(_AIX) || defined(__sun__))
X#if !(0L || 0L)
Ninline _LIBCPP_INLINE_VISIBILITY float       sqrt(float __lcpp_x) _NOEXCEPT       {return ::sqrtf(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) float       sqrt(float __lcpp_x) noexcept       {return ::sqrtf(__lcpp_x);}
Ninline _LIBCPP_INLINE_VISIBILITY long double sqrt(long double __lcpp_x) _NOEXCEPT {return ::sqrtl(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) long double sqrt(long double __lcpp_x) noexcept {return ::sqrtl(__lcpp_x);}
N#endif
N
Ntemplate <class _A1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if<std::is_integral<_A1>::value, double>::type
Nsqrt(_A1 __lcpp_x) _NOEXCEPT {return ::sqrt((double)__lcpp_x);}
Xsqrt(_A1 __lcpp_x) noexcept {return ::sqrt((double)__lcpp_x);}
N
N/* tan */
N
N#if !(defined(_AIX) || defined(__sun__))
X#if !(0L || 0L)
Ninline _LIBCPP_INLINE_VISIBILITY float       tan(float __lcpp_x) _NOEXCEPT       {return ::tanf(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) float       tan(float __lcpp_x) noexcept       {return ::tanf(__lcpp_x);}
Ninline _LIBCPP_INLINE_VISIBILITY long double tan(long double __lcpp_x) _NOEXCEPT {return ::tanl(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) long double tan(long double __lcpp_x) noexcept {return ::tanl(__lcpp_x);}
N#endif
N
Ntemplate <class _A1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if<std::is_integral<_A1>::value, double>::type
Ntan(_A1 __lcpp_x) _NOEXCEPT {return ::tan((double)__lcpp_x);}
Xtan(_A1 __lcpp_x) noexcept {return ::tan((double)__lcpp_x);}
N
N/* tanh */
N
N#if !(defined(_AIX) || defined(__sun__))
X#if !(0L || 0L)
Ninline _LIBCPP_INLINE_VISIBILITY float       tanh(float __lcpp_x) _NOEXCEPT       {return ::tanhf(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) float       tanh(float __lcpp_x) noexcept       {return ::tanhf(__lcpp_x);}
Ninline _LIBCPP_INLINE_VISIBILITY long double tanh(long double __lcpp_x) _NOEXCEPT {return ::tanhl(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) long double tanh(long double __lcpp_x) noexcept {return ::tanhl(__lcpp_x);}
N#endif
N
Ntemplate <class _A1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if<std::is_integral<_A1>::value, double>::type
Ntanh(_A1 __lcpp_x) _NOEXCEPT {return ::tanh((double)__lcpp_x);}
Xtanh(_A1 __lcpp_x) noexcept {return ::tanh((double)__lcpp_x);}
N
N/* acosh */
N
Ninline _LIBCPP_INLINE_VISIBILITY float       acosh(float __lcpp_x) _NOEXCEPT       {return ::acoshf(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) float       acosh(float __lcpp_x) noexcept       {return ::acoshf(__lcpp_x);}
Ninline _LIBCPP_INLINE_VISIBILITY long double acosh(long double __lcpp_x) _NOEXCEPT {return ::acoshl(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) long double acosh(long double __lcpp_x) noexcept {return ::acoshl(__lcpp_x);}
N
Ntemplate <class _A1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if<std::is_integral<_A1>::value, double>::type
Nacosh(_A1 __lcpp_x) _NOEXCEPT {return ::acosh((double)__lcpp_x);}
Xacosh(_A1 __lcpp_x) noexcept {return ::acosh((double)__lcpp_x);}
N
N/* asinh */
N
Ninline _LIBCPP_INLINE_VISIBILITY float       asinh(float __lcpp_x) _NOEXCEPT       {return ::asinhf(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) float       asinh(float __lcpp_x) noexcept       {return ::asinhf(__lcpp_x);}
Ninline _LIBCPP_INLINE_VISIBILITY long double asinh(long double __lcpp_x) _NOEXCEPT {return ::asinhl(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) long double asinh(long double __lcpp_x) noexcept {return ::asinhl(__lcpp_x);}
N
Ntemplate <class _A1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if<std::is_integral<_A1>::value, double>::type
Nasinh(_A1 __lcpp_x) _NOEXCEPT {return ::asinh((double)__lcpp_x);}
Xasinh(_A1 __lcpp_x) noexcept {return ::asinh((double)__lcpp_x);}
N
N/* atanh */
N
Ninline _LIBCPP_INLINE_VISIBILITY float       atanh(float __lcpp_x) _NOEXCEPT       {return ::atanhf(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) float       atanh(float __lcpp_x) noexcept       {return ::atanhf(__lcpp_x);}
Ninline _LIBCPP_INLINE_VISIBILITY long double atanh(long double __lcpp_x) _NOEXCEPT {return ::atanhl(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) long double atanh(long double __lcpp_x) noexcept {return ::atanhl(__lcpp_x);}
N
Ntemplate <class _A1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if<std::is_integral<_A1>::value, double>::type
Natanh(_A1 __lcpp_x) _NOEXCEPT {return ::atanh((double)__lcpp_x);}
Xatanh(_A1 __lcpp_x) noexcept {return ::atanh((double)__lcpp_x);}
N
N/* cbrt */
N
Ninline _LIBCPP_INLINE_VISIBILITY float       cbrt(float __lcpp_x) _NOEXCEPT       {return ::cbrtf(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) float       cbrt(float __lcpp_x) noexcept       {return ::cbrtf(__lcpp_x);}
Ninline _LIBCPP_INLINE_VISIBILITY long double cbrt(long double __lcpp_x) _NOEXCEPT {return ::cbrtl(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) long double cbrt(long double __lcpp_x) noexcept {return ::cbrtl(__lcpp_x);}
N
Ntemplate <class _A1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if<std::is_integral<_A1>::value, double>::type
Ncbrt(_A1 __lcpp_x) _NOEXCEPT {return ::cbrt((double)__lcpp_x);}
Xcbrt(_A1 __lcpp_x) noexcept {return ::cbrt((double)__lcpp_x);}
N
N/* copysign */
N
Ninline _LIBCPP_INLINE_VISIBILITY float copysign(float __lcpp_x,
Xinline __attribute__ ((__always_inline__)) float copysign(float __lcpp_x,
N                                                float __lcpp_y) _NOEXCEPT {
X                                                float __lcpp_y) noexcept {
N  return ::copysignf(__lcpp_x, __lcpp_y);
N}
Ninline _LIBCPP_INLINE_VISIBILITY long double
Xinline __attribute__ ((__always_inline__)) long double
Ncopysign(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {
Xcopysign(long double __lcpp_x, long double __lcpp_y) noexcept {
N  return ::copysignl(__lcpp_x, __lcpp_y);
N}
N
Ntemplate <class _A1, class _A2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::__lazy_enable_if
N<
N    std::is_arithmetic<_A1>::value &&
N    std::is_arithmetic<_A2>::value,
N    std::__promote<_A1, _A2>
N>::type
Ncopysign(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT
Xcopysign(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
N{
N    typedef typename std::__promote<_A1, _A2>::type __result_type;
N    static_assert((!(std::is_same<_A1, __result_type>::value &&
N                     std::is_same<_A2, __result_type>::value)), "");
N    return ::copysign((__result_type)__lcpp_x, (__result_type)__lcpp_y);
N}
N
N/* erf */
N
Ninline _LIBCPP_INLINE_VISIBILITY float       erf(float __lcpp_x) _NOEXCEPT       {return ::erff(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) float       erf(float __lcpp_x) noexcept       {return ::erff(__lcpp_x);}
Ninline _LIBCPP_INLINE_VISIBILITY long double erf(long double __lcpp_x) _NOEXCEPT {return ::erfl(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) long double erf(long double __lcpp_x) noexcept {return ::erfl(__lcpp_x);}
N
Ntemplate <class _A1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if<std::is_integral<_A1>::value, double>::type
Nerf(_A1 __lcpp_x) _NOEXCEPT {return ::erf((double)__lcpp_x);}
Xerf(_A1 __lcpp_x) noexcept {return ::erf((double)__lcpp_x);}
N
N/* erfc */
N
Ninline _LIBCPP_INLINE_VISIBILITY float       erfc(float __lcpp_x) _NOEXCEPT       {return ::erfcf(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) float       erfc(float __lcpp_x) noexcept       {return ::erfcf(__lcpp_x);}
Ninline _LIBCPP_INLINE_VISIBILITY long double erfc(long double __lcpp_x) _NOEXCEPT {return ::erfcl(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) long double erfc(long double __lcpp_x) noexcept {return ::erfcl(__lcpp_x);}
N
Ntemplate <class _A1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if<std::is_integral<_A1>::value, double>::type
Nerfc(_A1 __lcpp_x) _NOEXCEPT {return ::erfc((double)__lcpp_x);}
Xerfc(_A1 __lcpp_x) noexcept {return ::erfc((double)__lcpp_x);}
N
N/* exp2 */
N
Ninline _LIBCPP_INLINE_VISIBILITY float       exp2(float __lcpp_x) _NOEXCEPT       {return ::exp2f(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) float       exp2(float __lcpp_x) noexcept       {return ::exp2f(__lcpp_x);}
Ninline _LIBCPP_INLINE_VISIBILITY long double exp2(long double __lcpp_x) _NOEXCEPT {return ::exp2l(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) long double exp2(long double __lcpp_x) noexcept {return ::exp2l(__lcpp_x);}
N
Ntemplate <class _A1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if<std::is_integral<_A1>::value, double>::type
Nexp2(_A1 __lcpp_x) _NOEXCEPT {return ::exp2((double)__lcpp_x);}
Xexp2(_A1 __lcpp_x) noexcept {return ::exp2((double)__lcpp_x);}
N
N/* expm1 */
N
Ninline _LIBCPP_INLINE_VISIBILITY float       expm1(float __lcpp_x) _NOEXCEPT       {return ::expm1f(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) float       expm1(float __lcpp_x) noexcept       {return ::expm1f(__lcpp_x);}
Ninline _LIBCPP_INLINE_VISIBILITY long double expm1(long double __lcpp_x) _NOEXCEPT {return ::expm1l(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) long double expm1(long double __lcpp_x) noexcept {return ::expm1l(__lcpp_x);}
N
Ntemplate <class _A1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if<std::is_integral<_A1>::value, double>::type
Nexpm1(_A1 __lcpp_x) _NOEXCEPT {return ::expm1((double)__lcpp_x);}
Xexpm1(_A1 __lcpp_x) noexcept {return ::expm1((double)__lcpp_x);}
N
N/* fdim */
N
Ninline _LIBCPP_INLINE_VISIBILITY float       fdim(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return ::fdimf(__lcpp_x, __lcpp_y);}
Xinline __attribute__ ((__always_inline__)) float       fdim(float __lcpp_x, float __lcpp_y) noexcept             {return ::fdimf(__lcpp_x, __lcpp_y);}
Ninline _LIBCPP_INLINE_VISIBILITY long double fdim(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return ::fdiml(__lcpp_x, __lcpp_y);}
Xinline __attribute__ ((__always_inline__)) long double fdim(long double __lcpp_x, long double __lcpp_y) noexcept {return ::fdiml(__lcpp_x, __lcpp_y);}
N
Ntemplate <class _A1, class _A2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::__lazy_enable_if
N<
N    std::is_arithmetic<_A1>::value &&
N    std::is_arithmetic<_A2>::value,
N    std::__promote<_A1, _A2>
N>::type
Nfdim(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT
Xfdim(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
N{
N    typedef typename std::__promote<_A1, _A2>::type __result_type;
N    static_assert((!(std::is_same<_A1, __result_type>::value &&
N                     std::is_same<_A2, __result_type>::value)), "");
N    return ::fdim((__result_type)__lcpp_x, (__result_type)__lcpp_y);
N}
N
N/* fma */
N
Ninline _LIBCPP_INLINE_VISIBILITY float       fma(float __lcpp_x, float __lcpp_y, float __lcpp_z) _NOEXCEPT                   {return ::fmaf(__lcpp_x, __lcpp_y, __lcpp_z);}
Xinline __attribute__ ((__always_inline__)) float       fma(float __lcpp_x, float __lcpp_y, float __lcpp_z) noexcept                   {return ::fmaf(__lcpp_x, __lcpp_y, __lcpp_z);}
Ninline _LIBCPP_INLINE_VISIBILITY long double fma(long double __lcpp_x, long double __lcpp_y, long double __lcpp_z) _NOEXCEPT {return ::fmal(__lcpp_x, __lcpp_y, __lcpp_z);}
Xinline __attribute__ ((__always_inline__)) long double fma(long double __lcpp_x, long double __lcpp_y, long double __lcpp_z) noexcept {return ::fmal(__lcpp_x, __lcpp_y, __lcpp_z);}
N
Ntemplate <class _A1, class _A2, class _A3>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::__lazy_enable_if
N<
N    std::is_arithmetic<_A1>::value &&
N    std::is_arithmetic<_A2>::value &&
N    std::is_arithmetic<_A3>::value,
N    std::__promote<_A1, _A2, _A3>
N>::type
Nfma(_A1 __lcpp_x, _A2 __lcpp_y, _A3 __lcpp_z) _NOEXCEPT
Xfma(_A1 __lcpp_x, _A2 __lcpp_y, _A3 __lcpp_z) noexcept
N{
N    typedef typename std::__promote<_A1, _A2, _A3>::type __result_type;
N    static_assert((!(std::is_same<_A1, __result_type>::value &&
N                     std::is_same<_A2, __result_type>::value &&
N                     std::is_same<_A3, __result_type>::value)), "");
N    return ::fma((__result_type)__lcpp_x, (__result_type)__lcpp_y, (__result_type)__lcpp_z);
N}
N
N/* fmax */
N
Ninline _LIBCPP_INLINE_VISIBILITY float       fmax(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return ::fmaxf(__lcpp_x, __lcpp_y);}
Xinline __attribute__ ((__always_inline__)) float       fmax(float __lcpp_x, float __lcpp_y) noexcept             {return ::fmaxf(__lcpp_x, __lcpp_y);}
Ninline _LIBCPP_INLINE_VISIBILITY long double fmax(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return ::fmaxl(__lcpp_x, __lcpp_y);}
Xinline __attribute__ ((__always_inline__)) long double fmax(long double __lcpp_x, long double __lcpp_y) noexcept {return ::fmaxl(__lcpp_x, __lcpp_y);}
N
Ntemplate <class _A1, class _A2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::__lazy_enable_if
N<
N    std::is_arithmetic<_A1>::value &&
N    std::is_arithmetic<_A2>::value,
N    std::__promote<_A1, _A2>
N>::type
Nfmax(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT
Xfmax(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
N{
N    typedef typename std::__promote<_A1, _A2>::type __result_type;
N    static_assert((!(std::is_same<_A1, __result_type>::value &&
N                     std::is_same<_A2, __result_type>::value)), "");
N    return ::fmax((__result_type)__lcpp_x, (__result_type)__lcpp_y);
N}
N
N/* fmin */
N
Ninline _LIBCPP_INLINE_VISIBILITY float       fmin(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return ::fminf(__lcpp_x, __lcpp_y);}
Xinline __attribute__ ((__always_inline__)) float       fmin(float __lcpp_x, float __lcpp_y) noexcept             {return ::fminf(__lcpp_x, __lcpp_y);}
Ninline _LIBCPP_INLINE_VISIBILITY long double fmin(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return ::fminl(__lcpp_x, __lcpp_y);}
Xinline __attribute__ ((__always_inline__)) long double fmin(long double __lcpp_x, long double __lcpp_y) noexcept {return ::fminl(__lcpp_x, __lcpp_y);}
N
Ntemplate <class _A1, class _A2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::__lazy_enable_if
N<
N    std::is_arithmetic<_A1>::value &&
N    std::is_arithmetic<_A2>::value,
N    std::__promote<_A1, _A2>
N>::type
Nfmin(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT
Xfmin(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
N{
N    typedef typename std::__promote<_A1, _A2>::type __result_type;
N    static_assert((!(std::is_same<_A1, __result_type>::value &&
N                     std::is_same<_A2, __result_type>::value)), "");
N    return ::fmin((__result_type)__lcpp_x, (__result_type)__lcpp_y);
N}
N
N/* hypot */
N
Ninline _LIBCPP_INLINE_VISIBILITY float       hypot(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return ::hypotf(__lcpp_x, __lcpp_y);}
Xinline __attribute__ ((__always_inline__)) float       hypot(float __lcpp_x, float __lcpp_y) noexcept             {return ::hypotf(__lcpp_x, __lcpp_y);}
Ninline _LIBCPP_INLINE_VISIBILITY long double hypot(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return ::hypotl(__lcpp_x, __lcpp_y);}
Xinline __attribute__ ((__always_inline__)) long double hypot(long double __lcpp_x, long double __lcpp_y) noexcept {return ::hypotl(__lcpp_x, __lcpp_y);}
N
Ntemplate <class _A1, class _A2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::__lazy_enable_if
N<
N    std::is_arithmetic<_A1>::value &&
N    std::is_arithmetic<_A2>::value,
N    std::__promote<_A1, _A2>
N>::type
Nhypot(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT
Xhypot(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
N{
N    typedef typename std::__promote<_A1, _A2>::type __result_type;
N    static_assert((!(std::is_same<_A1, __result_type>::value &&
N                     std::is_same<_A2, __result_type>::value)), "");
N    return ::hypot((__result_type)__lcpp_x, (__result_type)__lcpp_y);
N}
N
N/* ilogb */
N
Ninline _LIBCPP_INLINE_VISIBILITY int ilogb(float __lcpp_x) _NOEXCEPT       {return ::ilogbf(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) int ilogb(float __lcpp_x) noexcept       {return ::ilogbf(__lcpp_x);}
Ninline _LIBCPP_INLINE_VISIBILITY int ilogb(long double __lcpp_x) _NOEXCEPT {return ::ilogbl(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) int ilogb(long double __lcpp_x) noexcept {return ::ilogbl(__lcpp_x);}
N
Ntemplate <class _A1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if<std::is_integral<_A1>::value, int>::type
Nilogb(_A1 __lcpp_x) _NOEXCEPT {return ::ilogb((double)__lcpp_x);}
Xilogb(_A1 __lcpp_x) noexcept {return ::ilogb((double)__lcpp_x);}
N
N/* lgamma */
N
Ninline _LIBCPP_INLINE_VISIBILITY float       lgamma(float __lcpp_x) _NOEXCEPT       {return ::lgammaf(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) float       lgamma(float __lcpp_x) noexcept       {return ::lgammaf(__lcpp_x);}
Ninline _LIBCPP_INLINE_VISIBILITY long double lgamma(long double __lcpp_x) _NOEXCEPT {return ::lgammal(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) long double lgamma(long double __lcpp_x) noexcept {return ::lgammal(__lcpp_x);}
N
Ntemplate <class _A1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if<std::is_integral<_A1>::value, double>::type
Nlgamma(_A1 __lcpp_x) _NOEXCEPT {return ::lgamma((double)__lcpp_x);}
Xlgamma(_A1 __lcpp_x) noexcept {return ::lgamma((double)__lcpp_x);}
N
N/* llrint */
N
Ninline _LIBCPP_INLINE_VISIBILITY long long llrint(float __lcpp_x) _NOEXCEPT       {return ::llrintf(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) long long llrint(float __lcpp_x) noexcept       {return ::llrintf(__lcpp_x);}
Ninline _LIBCPP_INLINE_VISIBILITY long long llrint(long double __lcpp_x) _NOEXCEPT {return ::llrintl(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) long long llrint(long double __lcpp_x) noexcept {return ::llrintl(__lcpp_x);}
N
Ntemplate <class _A1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if<std::is_integral<_A1>::value, long long>::type
Nllrint(_A1 __lcpp_x) _NOEXCEPT {return ::llrint((double)__lcpp_x);}
Xllrint(_A1 __lcpp_x) noexcept {return ::llrint((double)__lcpp_x);}
N
N/* llround */
N
Ninline _LIBCPP_INLINE_VISIBILITY long long llround(float __lcpp_x) _NOEXCEPT       {return ::llroundf(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) long long llround(float __lcpp_x) noexcept       {return ::llroundf(__lcpp_x);}
Ninline _LIBCPP_INLINE_VISIBILITY long long llround(long double __lcpp_x) _NOEXCEPT {return ::llroundl(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) long long llround(long double __lcpp_x) noexcept {return ::llroundl(__lcpp_x);}
N
Ntemplate <class _A1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if<std::is_integral<_A1>::value, long long>::type
Nllround(_A1 __lcpp_x) _NOEXCEPT {return ::llround((double)__lcpp_x);}
Xllround(_A1 __lcpp_x) noexcept {return ::llround((double)__lcpp_x);}
N
N/* log1p */
N
Ninline _LIBCPP_INLINE_VISIBILITY float       log1p(float __lcpp_x) _NOEXCEPT       {return ::log1pf(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) float       log1p(float __lcpp_x) noexcept       {return ::log1pf(__lcpp_x);}
Ninline _LIBCPP_INLINE_VISIBILITY long double log1p(long double __lcpp_x) _NOEXCEPT {return ::log1pl(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) long double log1p(long double __lcpp_x) noexcept {return ::log1pl(__lcpp_x);}
N
Ntemplate <class _A1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if<std::is_integral<_A1>::value, double>::type
Nlog1p(_A1 __lcpp_x) _NOEXCEPT {return ::log1p((double)__lcpp_x);}
Xlog1p(_A1 __lcpp_x) noexcept {return ::log1p((double)__lcpp_x);}
N
N/* log2 */
N
Ninline _LIBCPP_INLINE_VISIBILITY float       log2(float __lcpp_x) _NOEXCEPT       {return ::log2f(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) float       log2(float __lcpp_x) noexcept       {return ::log2f(__lcpp_x);}
Ninline _LIBCPP_INLINE_VISIBILITY long double log2(long double __lcpp_x) _NOEXCEPT {return ::log2l(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) long double log2(long double __lcpp_x) noexcept {return ::log2l(__lcpp_x);}
N
Ntemplate <class _A1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if<std::is_integral<_A1>::value, double>::type
Nlog2(_A1 __lcpp_x) _NOEXCEPT {return ::log2((double)__lcpp_x);}
Xlog2(_A1 __lcpp_x) noexcept {return ::log2((double)__lcpp_x);}
N
N/* logb */
N
Ninline _LIBCPP_INLINE_VISIBILITY float       logb(float __lcpp_x) _NOEXCEPT       {return ::logbf(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) float       logb(float __lcpp_x) noexcept       {return ::logbf(__lcpp_x);}
Ninline _LIBCPP_INLINE_VISIBILITY long double logb(long double __lcpp_x) _NOEXCEPT {return ::logbl(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) long double logb(long double __lcpp_x) noexcept {return ::logbl(__lcpp_x);}
N
Ntemplate <class _A1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if<std::is_integral<_A1>::value, double>::type
Nlogb(_A1 __lcpp_x) _NOEXCEPT {return ::logb((double)__lcpp_x);}
Xlogb(_A1 __lcpp_x) noexcept {return ::logb((double)__lcpp_x);}
N
N/* lrint */
N
Ninline _LIBCPP_INLINE_VISIBILITY long lrint(float __lcpp_x) _NOEXCEPT       {return ::lrintf(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) long lrint(float __lcpp_x) noexcept       {return ::lrintf(__lcpp_x);}
Ninline _LIBCPP_INLINE_VISIBILITY long lrint(long double __lcpp_x) _NOEXCEPT {return ::lrintl(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) long lrint(long double __lcpp_x) noexcept {return ::lrintl(__lcpp_x);}
N
Ntemplate <class _A1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if<std::is_integral<_A1>::value, long>::type
Nlrint(_A1 __lcpp_x) _NOEXCEPT {return ::lrint((double)__lcpp_x);}
Xlrint(_A1 __lcpp_x) noexcept {return ::lrint((double)__lcpp_x);}
N
N/* lround */
N
Ninline _LIBCPP_INLINE_VISIBILITY long lround(float __lcpp_x) _NOEXCEPT       {return ::lroundf(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) long lround(float __lcpp_x) noexcept       {return ::lroundf(__lcpp_x);}
Ninline _LIBCPP_INLINE_VISIBILITY long lround(long double __lcpp_x) _NOEXCEPT {return ::lroundl(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) long lround(long double __lcpp_x) noexcept {return ::lroundl(__lcpp_x);}
N
Ntemplate <class _A1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if<std::is_integral<_A1>::value, long>::type
Nlround(_A1 __lcpp_x) _NOEXCEPT {return ::lround((double)__lcpp_x);}
Xlround(_A1 __lcpp_x) noexcept {return ::lround((double)__lcpp_x);}
N
N/* nan */
N
N/* nearbyint */
N
Ninline _LIBCPP_INLINE_VISIBILITY float       nearbyint(float __lcpp_x) _NOEXCEPT       {return ::nearbyintf(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) float       nearbyint(float __lcpp_x) noexcept       {return ::nearbyintf(__lcpp_x);}
Ninline _LIBCPP_INLINE_VISIBILITY long double nearbyint(long double __lcpp_x) _NOEXCEPT {return ::nearbyintl(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) long double nearbyint(long double __lcpp_x) noexcept {return ::nearbyintl(__lcpp_x);}
N
Ntemplate <class _A1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if<std::is_integral<_A1>::value, double>::type
Nnearbyint(_A1 __lcpp_x) _NOEXCEPT {return ::nearbyint((double)__lcpp_x);}
Xnearbyint(_A1 __lcpp_x) noexcept {return ::nearbyint((double)__lcpp_x);}
N
N/* nextafter */
N
Ninline _LIBCPP_INLINE_VISIBILITY float       nextafter(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return ::nextafterf(__lcpp_x, __lcpp_y);}
Xinline __attribute__ ((__always_inline__)) float       nextafter(float __lcpp_x, float __lcpp_y) noexcept             {return ::nextafterf(__lcpp_x, __lcpp_y);}
Ninline _LIBCPP_INLINE_VISIBILITY long double nextafter(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return ::nextafterl(__lcpp_x, __lcpp_y);}
Xinline __attribute__ ((__always_inline__)) long double nextafter(long double __lcpp_x, long double __lcpp_y) noexcept {return ::nextafterl(__lcpp_x, __lcpp_y);}
N
Ntemplate <class _A1, class _A2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::__lazy_enable_if
N<
N    std::is_arithmetic<_A1>::value &&
N    std::is_arithmetic<_A2>::value,
N    std::__promote<_A1, _A2>
N>::type
Nnextafter(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT
Xnextafter(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
N{
N    typedef typename std::__promote<_A1, _A2>::type __result_type;
N    static_assert((!(std::is_same<_A1, __result_type>::value &&
N                     std::is_same<_A2, __result_type>::value)), "");
N    return ::nextafter((__result_type)__lcpp_x, (__result_type)__lcpp_y);
N}
N
N/* nexttoward */
N
Ninline _LIBCPP_INLINE_VISIBILITY float       nexttoward(float __lcpp_x, long double __lcpp_y) _NOEXCEPT       {return ::nexttowardf(__lcpp_x, __lcpp_y);}
Xinline __attribute__ ((__always_inline__)) float       nexttoward(float __lcpp_x, long double __lcpp_y) noexcept       {return ::nexttowardf(__lcpp_x, __lcpp_y);}
Ninline _LIBCPP_INLINE_VISIBILITY long double nexttoward(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return ::nexttowardl(__lcpp_x, __lcpp_y);}
Xinline __attribute__ ((__always_inline__)) long double nexttoward(long double __lcpp_x, long double __lcpp_y) noexcept {return ::nexttowardl(__lcpp_x, __lcpp_y);}
N
Ntemplate <class _A1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if<std::is_integral<_A1>::value, double>::type
Nnexttoward(_A1 __lcpp_x, long double __lcpp_y) _NOEXCEPT {return ::nexttoward((double)__lcpp_x, __lcpp_y);}
Xnexttoward(_A1 __lcpp_x, long double __lcpp_y) noexcept {return ::nexttoward((double)__lcpp_x, __lcpp_y);}
N
N/* remainder */
N
Ninline _LIBCPP_INLINE_VISIBILITY float       remainder(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return ::remainderf(__lcpp_x, __lcpp_y);}
Xinline __attribute__ ((__always_inline__)) float       remainder(float __lcpp_x, float __lcpp_y) noexcept             {return ::remainderf(__lcpp_x, __lcpp_y);}
Ninline _LIBCPP_INLINE_VISIBILITY long double remainder(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return ::remainderl(__lcpp_x, __lcpp_y);}
Xinline __attribute__ ((__always_inline__)) long double remainder(long double __lcpp_x, long double __lcpp_y) noexcept {return ::remainderl(__lcpp_x, __lcpp_y);}
N
Ntemplate <class _A1, class _A2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::__lazy_enable_if
N<
N    std::is_arithmetic<_A1>::value &&
N    std::is_arithmetic<_A2>::value,
N    std::__promote<_A1, _A2>
N>::type
Nremainder(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT
Xremainder(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
N{
N    typedef typename std::__promote<_A1, _A2>::type __result_type;
N    static_assert((!(std::is_same<_A1, __result_type>::value &&
N                     std::is_same<_A2, __result_type>::value)), "");
N    return ::remainder((__result_type)__lcpp_x, (__result_type)__lcpp_y);
N}
N
N/* remquo */
N
Ninline _LIBCPP_INLINE_VISIBILITY float       remquo(float __lcpp_x, float __lcpp_y, int* __lcpp_z) _NOEXCEPT             {return ::remquof(__lcpp_x, __lcpp_y, __lcpp_z);}
Xinline __attribute__ ((__always_inline__)) float       remquo(float __lcpp_x, float __lcpp_y, int* __lcpp_z) noexcept             {return ::remquof(__lcpp_x, __lcpp_y, __lcpp_z);}
Ninline _LIBCPP_INLINE_VISIBILITY long double remquo(long double __lcpp_x, long double __lcpp_y, int* __lcpp_z) _NOEXCEPT {return ::remquol(__lcpp_x, __lcpp_y, __lcpp_z);}
Xinline __attribute__ ((__always_inline__)) long double remquo(long double __lcpp_x, long double __lcpp_y, int* __lcpp_z) noexcept {return ::remquol(__lcpp_x, __lcpp_y, __lcpp_z);}
N
Ntemplate <class _A1, class _A2>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::__lazy_enable_if
N<
N    std::is_arithmetic<_A1>::value &&
N    std::is_arithmetic<_A2>::value,
N    std::__promote<_A1, _A2>
N>::type
Nremquo(_A1 __lcpp_x, _A2 __lcpp_y, int* __lcpp_z) _NOEXCEPT
Xremquo(_A1 __lcpp_x, _A2 __lcpp_y, int* __lcpp_z) noexcept
N{
N    typedef typename std::__promote<_A1, _A2>::type __result_type;
N    static_assert((!(std::is_same<_A1, __result_type>::value &&
N                     std::is_same<_A2, __result_type>::value)), "");
N    return ::remquo((__result_type)__lcpp_x, (__result_type)__lcpp_y, __lcpp_z);
N}
N
N/* rint */
N
Ninline _LIBCPP_INLINE_VISIBILITY float       rint(float __lcpp_x) _NOEXCEPT       {return ::rintf(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) float       rint(float __lcpp_x) noexcept       {return ::rintf(__lcpp_x);}
Ninline _LIBCPP_INLINE_VISIBILITY long double rint(long double __lcpp_x) _NOEXCEPT {return ::rintl(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) long double rint(long double __lcpp_x) noexcept {return ::rintl(__lcpp_x);}
N
Ntemplate <class _A1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if<std::is_integral<_A1>::value, double>::type
Nrint(_A1 __lcpp_x) _NOEXCEPT {return ::rint((double)__lcpp_x);}
Xrint(_A1 __lcpp_x) noexcept {return ::rint((double)__lcpp_x);}
N
N/* round */
N
Ninline _LIBCPP_INLINE_VISIBILITY float       round(float __lcpp_x) _NOEXCEPT       {return ::roundf(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) float       round(float __lcpp_x) noexcept       {return ::roundf(__lcpp_x);}
Ninline _LIBCPP_INLINE_VISIBILITY long double round(long double __lcpp_x) _NOEXCEPT {return ::roundl(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) long double round(long double __lcpp_x) noexcept {return ::roundl(__lcpp_x);}
N
Ntemplate <class _A1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if<std::is_integral<_A1>::value, double>::type
Nround(_A1 __lcpp_x) _NOEXCEPT {return ::round((double)__lcpp_x);}
Xround(_A1 __lcpp_x) noexcept {return ::round((double)__lcpp_x);}
N
N/* scalbln */
N
Ninline _LIBCPP_INLINE_VISIBILITY float       scalbln(float __lcpp_x, long __lcpp_y) _NOEXCEPT       {return ::scalblnf(__lcpp_x, __lcpp_y);}
Xinline __attribute__ ((__always_inline__)) float       scalbln(float __lcpp_x, long __lcpp_y) noexcept       {return ::scalblnf(__lcpp_x, __lcpp_y);}
Ninline _LIBCPP_INLINE_VISIBILITY long double scalbln(long double __lcpp_x, long __lcpp_y) _NOEXCEPT {return ::scalblnl(__lcpp_x, __lcpp_y);}
Xinline __attribute__ ((__always_inline__)) long double scalbln(long double __lcpp_x, long __lcpp_y) noexcept {return ::scalblnl(__lcpp_x, __lcpp_y);}
N
Ntemplate <class _A1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if<std::is_integral<_A1>::value, double>::type
Nscalbln(_A1 __lcpp_x, long __lcpp_y) _NOEXCEPT {return ::scalbln((double)__lcpp_x, __lcpp_y);}
Xscalbln(_A1 __lcpp_x, long __lcpp_y) noexcept {return ::scalbln((double)__lcpp_x, __lcpp_y);}
N
N/* scalbn */
N
Ninline _LIBCPP_INLINE_VISIBILITY float       scalbn(float __lcpp_x, int __lcpp_y) _NOEXCEPT       {return ::scalbnf(__lcpp_x, __lcpp_y);}
Xinline __attribute__ ((__always_inline__)) float       scalbn(float __lcpp_x, int __lcpp_y) noexcept       {return ::scalbnf(__lcpp_x, __lcpp_y);}
Ninline _LIBCPP_INLINE_VISIBILITY long double scalbn(long double __lcpp_x, int __lcpp_y) _NOEXCEPT {return ::scalbnl(__lcpp_x, __lcpp_y);}
Xinline __attribute__ ((__always_inline__)) long double scalbn(long double __lcpp_x, int __lcpp_y) noexcept {return ::scalbnl(__lcpp_x, __lcpp_y);}
N
Ntemplate <class _A1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if<std::is_integral<_A1>::value, double>::type
Nscalbn(_A1 __lcpp_x, int __lcpp_y) _NOEXCEPT {return ::scalbn((double)__lcpp_x, __lcpp_y);}
Xscalbn(_A1 __lcpp_x, int __lcpp_y) noexcept {return ::scalbn((double)__lcpp_x, __lcpp_y);}
N
N/* tgamma */
N
Ninline _LIBCPP_INLINE_VISIBILITY float       tgamma(float __lcpp_x) _NOEXCEPT       {return ::tgammaf(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) float       tgamma(float __lcpp_x) noexcept       {return ::tgammaf(__lcpp_x);}
Ninline _LIBCPP_INLINE_VISIBILITY long double tgamma(long double __lcpp_x) _NOEXCEPT {return ::tgammal(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) long double tgamma(long double __lcpp_x) noexcept {return ::tgammal(__lcpp_x);}
N
Ntemplate <class _A1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if<std::is_integral<_A1>::value, double>::type
Ntgamma(_A1 __lcpp_x) _NOEXCEPT {return ::tgamma((double)__lcpp_x);}
Xtgamma(_A1 __lcpp_x) noexcept {return ::tgamma((double)__lcpp_x);}
N
N/* trunc */
N
Ninline _LIBCPP_INLINE_VISIBILITY float       trunc(float __lcpp_x) _NOEXCEPT       {return ::truncf(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) float       trunc(float __lcpp_x) noexcept       {return ::truncf(__lcpp_x);}
Ninline _LIBCPP_INLINE_VISIBILITY long double trunc(long double __lcpp_x) _NOEXCEPT {return ::truncl(__lcpp_x);}
Xinline __attribute__ ((__always_inline__)) long double trunc(long double __lcpp_x) noexcept {return ::truncl(__lcpp_x);}
N
Ntemplate <class _A1>
Ninline _LIBCPP_INLINE_VISIBILITY
Xinline __attribute__ ((__always_inline__))
Ntypename std::enable_if<std::is_integral<_A1>::value, double>::type
Ntrunc(_A1 __lcpp_x) _NOEXCEPT {return ::trunc((double)__lcpp_x);}
Xtrunc(_A1 __lcpp_x) noexcept {return ::trunc((double)__lcpp_x);}
N
N} /* extern "C++" */
N
N#endif /* __cplusplus */
N
N#endif  /* _LIBCPP_MATH_H */
L 306 "C:/ti/ccs930/ccs/tools/compiler/ti-cgt-arm_18.12.5.LTS/include/libcxx/cmath" 2
N
N#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
X#if !0L
N#pragma GCC system_header
N#endif
N
N_LIBCPP_BEGIN_NAMESPACE_STD
Xnamespace std { inline namespace __2 {
N
Nusing ::signbit;
Nusing ::fpclassify;
Nusing ::isfinite;
Nusing ::isinf;
Nusing ::isnan;
Nusing ::isnormal;
Nusing ::isgreater;
Nusing ::isgreaterequal;
Nusing ::isless;
Nusing ::islessequal;
Nusing ::islessgreater;
Nusing ::isunordered;
Nusing ::isunordered;
N
Nusing ::float_t;
Nusing ::double_t;
N
N#ifndef _AIX
Nusing ::abs;
N#endif
N
Nusing ::acos;
Nusing ::acosf;
Nusing ::asin;
Nusing ::asinf;
Nusing ::atan;
Nusing ::atanf;
Nusing ::atan2;
Nusing ::atan2f;
Nusing ::ceil;
Nusing ::ceilf;
Nusing ::cos;
Nusing ::cosf;
Nusing ::cosh;
Nusing ::coshf;
N
Nusing ::exp;
Nusing ::expf;
N
Nusing ::fabs;
Nusing ::fabsf;
Nusing ::floor;
Nusing ::floorf;
N
Nusing ::fmod;
Nusing ::fmodf;
N
Nusing ::frexp;
Nusing ::frexpf;
Nusing ::ldexp;
Nusing ::ldexpf;
N
Nusing ::log;
Nusing ::logf;
N
Nusing ::log10;
Nusing ::log10f;
Nusing ::modf;
Nusing ::modff;
N
Nusing ::pow;
Nusing ::powf;
N
Nusing ::sin;
Nusing ::sinf;
Nusing ::sinh;
Nusing ::sinhf;
N
Nusing ::sqrt;
Nusing ::sqrtf;
Nusing ::tan;
Nusing ::tanf;
N
Nusing ::tanh;
Nusing ::tanhf;
N
Nusing ::acosh;
Nusing ::acoshf;
Nusing ::asinh;
Nusing ::asinhf;
Nusing ::atanh;
Nusing ::atanhf;
Nusing ::cbrt;
Nusing ::cbrtf;
N
Nusing ::copysign;
Nusing ::copysignf;
N
Nusing ::erf;
Nusing ::erff;
Nusing ::erfc;
Nusing ::erfcf;
Nusing ::exp2;
Nusing ::exp2f;
Nusing ::expm1;
Nusing ::expm1f;
Nusing ::fdim;
Nusing ::fdimf;
Nusing ::fmaf;
Nusing ::fma;
Nusing ::fmax;
Nusing ::fmaxf;
Nusing ::fmin;
Nusing ::fminf;
Nusing ::hypot;
Nusing ::hypotf;
Nusing ::ilogb;
Nusing ::ilogbf;
Nusing ::lgamma;
Nusing ::lgammaf;
Nusing ::llrint;
Nusing ::llrintf;
Nusing ::llround;
Nusing ::llroundf;
Nusing ::log1p;
Nusing ::log1pf;
Nusing ::log2;
Nusing ::log2f;
Nusing ::logb;
Nusing ::logbf;
Nusing ::lrint;
Nusing ::lrintf;
Nusing ::lround;
Nusing ::lroundf;
N
Nusing ::nan;
Nusing ::nanf;
N
Nusing ::nearbyint;
Nusing ::nearbyintf;
Nusing ::nextafter;
Nusing ::nextafterf;
Nusing ::nexttoward;
Nusing ::nexttowardf;
Nusing ::remainder;
Nusing ::remainderf;
Nusing ::remquo;
Nusing ::remquof;
Nusing ::rint;
Nusing ::rintf;
Nusing ::round;
Nusing ::roundf;
Nusing ::scalbln;
Nusing ::scalblnf;
Nusing ::scalbn;
Nusing ::scalbnf;
Nusing ::tgamma;
Nusing ::tgammaf;
Nusing ::trunc;
Nusing ::truncf;
N
Nusing ::acosl;
Nusing ::asinl;
Nusing ::atanl;
Nusing ::atan2l;
Nusing ::ceill;
Nusing ::cosl;
Nusing ::coshl;
Nusing ::expl;
Nusing ::fabsl;
Nusing ::floorl;
Nusing ::fmodl;
Nusing ::frexpl;
Nusing ::ldexpl;
Nusing ::logl;
Nusing ::log10l;
Nusing ::modfl;
Nusing ::powl;
Nusing ::sinl;
Nusing ::sinhl;
Nusing ::sqrtl;
Nusing ::tanl;
N
Nusing ::tanhl;
Nusing ::acoshl;
Nusing ::asinhl;
Nusing ::atanhl;
Nusing ::cbrtl;
N
Nusing ::copysignl;
N
Nusing ::erfl;
Nusing ::erfcl;
Nusing ::exp2l;
Nusing ::expm1l;
Nusing ::fdiml;
Nusing ::fmal;
Nusing ::fmaxl;
Nusing ::fminl;
Nusing ::hypotl;
Nusing ::ilogbl;
Nusing ::lgammal;
Nusing ::llrintl;
Nusing ::llroundl;
Nusing ::log1pl;
Nusing ::log2l;
Nusing ::logbl;
Nusing ::lrintl;
Nusing ::lroundl;
Nusing ::nanl;
Nusing ::nearbyintl;
Nusing ::nextafterl;
Nusing ::nexttowardl;
Nusing ::remainderl;
Nusing ::remquol;
Nusing ::rintl;
Nusing ::roundl;
Nusing ::scalblnl;
Nusing ::scalbnl;
Nusing ::tgammal;
Nusing ::truncl;
N
N#if _LIBCPP_STD_VER > 14
X#if 14 > 14
Sinline _LIBCPP_INLINE_VISIBILITY float       hypot(       float x,       float y,       float z ) { return sqrt(x*x + y*y + z*z); }
Sinline _LIBCPP_INLINE_VISIBILITY double      hypot(      double x,      double y,      double z ) { return sqrt(x*x + y*y + z*z); }
Sinline _LIBCPP_INLINE_VISIBILITY long double hypot( long double x, long double y, long double z ) { return sqrt(x*x + y*y + z*z); }
S
Stemplate <class _A1, class _A2, class _A3>
Sinline _LIBCPP_INLINE_VISIBILITY
Stypename __lazy_enable_if
S<
S    is_arithmetic<_A1>::value &&
S    is_arithmetic<_A2>::value &&
S    is_arithmetic<_A3>::value,
S    __promote<_A1, _A2, _A3>
S>::type
Shypot(_A1 __lcpp_x, _A2 __lcpp_y, _A3 __lcpp_z) _NOEXCEPT
S{
S    typedef typename __promote<_A1, _A2, _A3>::type __result_type;
S    static_assert((!(is_same<_A1, __result_type>::value &&
S                     is_same<_A2, __result_type>::value &&
S                     is_same<_A3, __result_type>::value)), "");
S    return hypot((__result_type)__lcpp_x, (__result_type)__lcpp_y, (__result_type)__lcpp_z);
S}
N#endif
N
Ntemplate <class _A1>
N_LIBCPP_ALWAYS_INLINE
X__attribute__ ((__always_inline__))
N_LIBCPP_CONSTEXPR typename enable_if<is_floating_point<_A1>::value, bool>::type
Xconstexpr typename enable_if<is_floating_point<_A1>::value, bool>::type
N__libcpp_isnan_or_builtin(_A1 __lcpp_x) _NOEXCEPT
X__libcpp_isnan_or_builtin(_A1 __lcpp_x) noexcept
N{
N#if __has_builtin(__builtin_isnan)
X#if 0
S    return __builtin_isnan(__lcpp_x);
N#else
N    return isnan(__lcpp_x);
N#endif
N}
N
Ntemplate <class _A1>
N_LIBCPP_ALWAYS_INLINE
X__attribute__ ((__always_inline__))
N_LIBCPP_CONSTEXPR typename enable_if<!is_floating_point<_A1>::value, bool>::type
Xconstexpr typename enable_if<!is_floating_point<_A1>::value, bool>::type
N__libcpp_isnan_or_builtin(_A1 __lcpp_x) _NOEXCEPT
X__libcpp_isnan_or_builtin(_A1 __lcpp_x) noexcept
N{
N    return isnan(__lcpp_x);
N}
N
Ntemplate <class _A1>
N_LIBCPP_ALWAYS_INLINE
X__attribute__ ((__always_inline__))
N_LIBCPP_CONSTEXPR typename enable_if<is_floating_point<_A1>::value, bool>::type
Xconstexpr typename enable_if<is_floating_point<_A1>::value, bool>::type
N__libcpp_isinf_or_builtin(_A1 __lcpp_x) _NOEXCEPT
X__libcpp_isinf_or_builtin(_A1 __lcpp_x) noexcept
N{
N#if __has_builtin(__builtin_isinf)
X#if 0
S    return __builtin_isinf(__lcpp_x);
N#else
N    return isinf(__lcpp_x);
N#endif
N}
N
Ntemplate <class _A1>
N_LIBCPP_ALWAYS_INLINE
X__attribute__ ((__always_inline__))
N_LIBCPP_CONSTEXPR typename enable_if<!is_floating_point<_A1>::value, bool>::type
Xconstexpr typename enable_if<!is_floating_point<_A1>::value, bool>::type
N__libcpp_isinf_or_builtin(_A1 __lcpp_x) _NOEXCEPT
X__libcpp_isinf_or_builtin(_A1 __lcpp_x) noexcept
N{
N    return isinf(__lcpp_x);
N}
N
Ntemplate <class _A1>
N_LIBCPP_ALWAYS_INLINE
X__attribute__ ((__always_inline__))
N_LIBCPP_CONSTEXPR typename enable_if<is_floating_point<_A1>::value, bool>::type
Xconstexpr typename enable_if<is_floating_point<_A1>::value, bool>::type
N__libcpp_isfinite_or_builtin(_A1 __lcpp_x) _NOEXCEPT
X__libcpp_isfinite_or_builtin(_A1 __lcpp_x) noexcept
N{
N#if __has_builtin(__builtin_isfinite)
X#if 0
S    return __builtin_isfinite(__lcpp_x);
N#else
N    return isfinite(__lcpp_x);
N#endif
N}
N
Ntemplate <class _A1>
N_LIBCPP_ALWAYS_INLINE
X__attribute__ ((__always_inline__))
N_LIBCPP_CONSTEXPR typename enable_if<!is_floating_point<_A1>::value, bool>::type
Xconstexpr typename enable_if<!is_floating_point<_A1>::value, bool>::type
N__libcpp_isfinite_or_builtin(_A1 __lcpp_x) _NOEXCEPT
X__libcpp_isfinite_or_builtin(_A1 __lcpp_x) noexcept
N{
N    return isfinite(__lcpp_x);
N}
N
N_LIBCPP_END_NAMESPACE_STD
X} }
N
N#endif  // _LIBCPP_CMATH
L 15 "..\Odometry.h" 2
N#include "LPF.h"
N
N
Nclass Odometry
N{
Nprivate:
N    double wheelBase;
N    double wheelRadius;
N    double ticksPerRev;
N    double dt;
N    double alpha;
N
Npublic:
N    double turningRate = 0;
N    double speed = 0;
N    double x = 0;
N    double y = 0;
N    double theta = 0;
N    double rightAngRate[2] = {};
N    double leftAngRate[2] = {};
N    double prevRightCount = 0;
N    double prevLeftCount = 0;
N    Motor* rightMotor;
N    Motor* leftMotor;
N
N
N    Odometry(double wheelBase, double wheelRadius, double ticksPerRev, Motor* rightMotor, Motor* leftMotor, double dt, double alpha);
N
N
N    void updateOdometry();
N};
N
N#endif /* ODOMETRY_H_ */
L 14 "..\UART_Wrapper.h" 2
N#include "IMU.h"
L 1 "..\IMU.h" 1
N/*
N * IMU.h
N *
N *  Created on: Jun 18, 2020
N *      Author: Juan Francisco Vallejo
N */
N
N#ifndef IMU_H_
N#define IMU_H_
N
N#include "LSM6DSOX.h"
L 1 "..\LSM6DSOX.h" 1
N/*
N * LSM6DSOX.h
N *
N *  Created on: Feb 20, 2020
N *      Author: Juan Francisco Vallejo
N */
N
N#ifndef LSM6DSOX_H_
N#define LSM6DSOX_H_
N
N#define LSM6DS3_ADDRESS            0x6A
N
N#define LSM6DS3_WHO_AM_I_REG       0X0F
N#define LSM6DS3_CTRL1_XL           0X10
N#define LSM6DS3_CTRL2_G            0X11
N
N#define LSM6DS3_STATUS_REG         0X1E
N
N#define LSM6DS3_CTRL6_C            0X15
N#define LSM6DS3_CTRL7_G            0X16
N#define LSM6DS3_CTRL8_XL           0X17
N
N#define LSM6DS3_OUTX_L_G           0X22
N#define LSM6DS3_OUTX_H_G           0X23
N#define LSM6DS3_OUTY_L_G           0X24
N#define LSM6DS3_OUTY_H_G           0X25
N#define LSM6DS3_OUTZ_L_G           0X26
N#define LSM6DS3_OUTZ_H_G           0X27
N
N#define LSM6DS3_OUTX_L_XL          0X28
N#define LSM6DS3_OUTX_H_XL          0X29
N#define LSM6DS3_OUTY_L_XL          0X2A
N#define LSM6DS3_OUTY_H_XL          0X2B
N#define LSM6DS3_OUTZ_L_XL          0X2C
N#define LSM6DS3_OUTZ_H_XL          0X2D
N
N
N
N#endif /* LSM6DSOX_H_ */
L 12 "..\IMU.h" 2
N#include <cmath>
N#include "driverlib.h"
N#include "msp.h"
N#include "SPI.h"
L 1 "..\SPI.h" 1
N/*
N * SPI.h
N *
N *  Created on: Jun 18, 2020
N *      Author: Juan Francisco Valle
N */
N
N#ifndef SPI_dot_H_
N#define SPI_dot_H_
N
N#include "msp.h"
N#include "driverlib.h"
N
Nvoid configSPI();
N
Nvoid SPI_Read(uint8_t byteCount, uint8_t* rx_buffer, uint8_t* tx_buffer);
N
Nvoid SPI_Write(uint8_t byteCount, uint8_t* buffer);
N
N
N
N
N#endif /* SPI_H_ */
L 16 "..\IMU.h" 2
N#include "MiniSegway.h"
N
Nclass IMU{
Npublic:
N    double acceleration[3] = {};
N    double angularRate[3] = {};
N    double accelerationZero[3] = {};
N    double angularRateZero[3] = {};
N    double angle = 0;
N    double angleRate = 0;
N    double angleAccel = 0;
N    double alpha = 0.98;
N    double dt = 0.01;
N    double accelOffset = 4.5;
N    uint8_t TXDataBuffer[10];
N    uint8_t RXDataBuffer[10];
N
N    IMU();
N    void configModule();
N    void calibrate();
N    void readAccelerometer();
N    void readGyroscope();
N    double getFilteredAngle();
N};
N
N#endif /* IMU_H_ */
L 15 "..\UART_Wrapper.h" 2
N#include "MiniSegway.h"
N
Nclass Odometry;
Nclass IMU;
Nclass PID;
N
Nclass UART{
Nprivate:
N    eUSCI_UART_Config UART_init;
N    Odometry* odom;
N    IMU* imu;
N
Npublic:
N    char buffer[200] = {};// Set to 200, should be large enough
N    int messageSize = 0;
N    volatile int bufferIndex = 0;
N    uint32_t UARTModule;
N    bool finishedTransmission = 1;
N
N    UART(eUSCI_UART_Config init, uint32_t UARTModule, Odometry* odom, IMU* imu);
N
N    void printEncoders();
N
N    void UARTSetup();
N
N    void printOdometry();
N
N    void printIMU();
N
N    void printPWM();
N
N    void printPID(PID& pid);
N
N};
N
N#endif /* UART_WRAPPER_H_ */
L 18 "..\MiniSegway.h" 2
N#include "initConfigs.h"
L 1 "..\initConfigs.h" 1
N/*
N * initConfigs.h
N *
N *  Created on: Jun 17, 2020
N *      Author: Juan Francisco Valle
N */
N
N#ifndef INITCONFIGS_H_
S#define INITCONFIGS_H_
S
S#include "MiniSegway.h"
S
Svoid configPWM();
Svoid setupEncoderInterrupts();
Svoid setupClocks();
Svoid setupPins();
Svoid setupSystick();
S
S
N#endif /* INITCONFIGS_H_ */
L 19 "..\MiniSegway.h" 2
N#include "IMU.h"
N#include "SPI.h"
N#include "PID.h"
L 1 "..\PID.h" 1
N/*
N * PID.h
N *
N *  Created on: Jun 21, 2020
N *      Author: Juan Francisco Vallejo
N */
N
N#ifndef PID_H_
N#define PID_H_
N
Nclass PID{
Npublic:
N    double Kp = 0;
N    double Ki = 0;
N    double Kd = 0;
N
N    double setpoint;
N    double measuredState;
N    double error;
N    double prevError = 0;
N    double acumError = 0;
N    double errorRate;
N    double dt;
N    double antiWindup;
N
N    double out_d;
N    double out_p;
N    double out_i;
N    double output;
N
N    PID(double Kp, double Ki, double Kd, double dt, double antiWindup = 225);
N
N    double updatePID(double setpoint, double input);
N
N    double updatePID(double setpoint, double input, double inputRate);
N
N
N};
N
N
N
N
N#endif /* PID_H_ */
L 22 "..\MiniSegway.h" 2
N#include "OuterPID.h"
L 1 "..\OuterPID.h" 1
N/*
N * OuterPID.h
N *
N *  Created on: Jun 21, 2020
N *      Author: Juan Francisco Valle
N */
N
N#ifndef OUTERPID_H_
N#define OUTERPID_H_
N
N#include "PID.h"
N#include "LPF.h"
N
Nclass OuterPID : public PID{
Npublic:
N    PID* innerPID;
N    double alpha;
N    double filteredOutput[2] = {};
N
N    OuterPID(double Kp, double Ki, double Kd, double dt, PID* innerPID, double alpha,double antiWindup = 225);
N
N    double updatePID(double setpoint, double input, double innerInput,double innerInputRate);
N
N};
N
N
N
N#endif /* OUTERPID_H_ */
L 23 "..\MiniSegway.h" 2
N#include "RFInterface.h"
L 1 "..\RFInterface.h" 1
N/*
N * RFInterface.h
N *
N *  Created on: Jun 21, 2020
N *      Author: Juan Francisco Valle
N */
N
N#ifndef RFINTERFACE_H_
N#define RFINTERFACE_H_
N
N#include "MiniSegway.h"
N
Nclass RFInterface{
Npublic:
N    int mode = 0;
N
N    double filteredVelocitySetpoint[2] = {};
N    double filteredOrientationSetpoint[2] = {};
N
N    double alphaVelocitySetpoint = 0.05;
N    double alphaOrientationSetpoint = 0.05;
N
N    void pollrfReceiver();
N};
N
N
N
N#endif /* RFINTERFACE_H_ */
L 24 "..\MiniSegway.h" 2
N
N// Global definitions
N#define DCO_Freq 16E+6
N#define MAX_PWM 225
Nconst double dt = 0.01;
N
Nconst double Kp_tilt = 15;//18
Nconst double Kd_tilt = 0.03;//0.05
Nconst double Ki_tilt = 0.1;//0.1;
Nconst double windup_tilt = 225;
Nconst double alpha_PWM = 1;
N
Nconst double Kp_turning = 20;//17;
Nconst double Kd_turning = 0.03;
Nconst double Ki_turning = 0;
Nconst double windup_turning = 225;
N
Nconst double Kp_velocity = 0.006;//0.006;
Nconst double Kd_velocity = 0;//0;
Nconst double Ki_velocity = 0.003;//0.001;
Nconst double windup_velocity = 225;
Nconst double alpha_velocity = 0.4;
N
Nconst double odom_velocity_alpha = 0.2;
Nconst double wheelRadius = 50.25;
Nconst double wheelBase = 167.5;
Nconst double ticksPerRev = 240;
N
N
N// Motor pins
N#define CW_1_PORT GPIO_PORT_P3
N#define CW_1_PIN GPIO_PIN7
N#define CCW_1_PORT GPIO_PORT_P3
N#define CCW_1_PIN GPIO_PIN6
N
N#define CW_2_PORT GPIO_PORT_P3
N#define CW_2_PIN GPIO_PIN5
N#define CCW_2_PORT GPIO_PORT_P5
N#define CCW_2_PIN GPIO_PIN2
N
N// Encoder Pins
N// Right Wheel
N#define RIGHT_ENC_PORT GPIO_PORT_P4
N#define RIGHT_ENC_PIN_A GPIO_PIN0
N#define RIGHT_ENC_PIN_B GPIO_PIN2
N// Left Wheel
N#define LEFT_ENC_PORT GPIO_PORT_P5
N#define LEFT_ENC_PIN_A GPIO_PIN4
N#define LEFT_ENC_PIN_B GPIO_PIN7 // On Port 4, 5.5 is fried
N
Nclass Motor;
Nclass Odometry;
Nclass UART;
Nclass IMU;
Nclass PID;
Nclass OuterPID;
Nclass RFInterface;
N
N// Global variables
Nextern Motor rightMotor;
Nextern Motor leftMotor;
Nextern UART UARTHandler;
Nextern Odometry odom;
Nextern IMU imu;
Nextern PID tiltController;
Nextern PID turningController;
Nextern OuterPID velocityController;
Nextern RFInterface commandInterface;
N
Nextern long ms; // Counts number of ms since program started
Nextern long last_ms;
N
N#endif /* MINISEGWAY_H_ */
L 12 "..\initConfigs.h" 2
N
Nvoid configPWM();
Nvoid setupEncoderInterrupts();
Nvoid setupClocks();
Nvoid setupPins();
Nvoid setupSystick();
N
N
N#endif /* INITCONFIGS_H_ */
L 9 "../initConfigs.cpp" 2
N
Nvoid configPWM() {
N    // Pinout PWMA: 6.6, PWMB 6.7
N    P6SEL0 |= 0b11<<6 ; // Set bit 6 and 7 of P6SEL0 to enable TA2.3 and TA2.4 functionality on P6.6, P6.7
X    ((*((volatile uint8_t *)(0x40004C4B)))) |= 0b11<<6 ; 
N    P6SEL1 &= ~0b11<<6 ; // Clear bit 6 and 7 of P6SEL1 to enable TA2.3 and TA2.4 functionality on P6.6, P6.7
X    ((*((volatile uint8_t *)(0x40004C4D)))) &= ~0b11<<6 ; 
N    P6DIR |= 0b11<<6 ; // Set pins 6.6 and 6.7 as output pins
X    ((*((volatile uint8_t *)(0x40004C45)))) |= 0b11<<6 ; 
N    // Set Timer A period equivalent to 17.77kHz (PWM signal period)
N    TA2CCR0 = MAX_PWM;
X    ((*((volatile uint16_t *)(0x40000812)))) = 225;
N    // Set Duty cycle
N    TA2CCR3 = 0;
X    ((*((volatile uint16_t *)(0x40000818)))) = 0;
N    TA2CCR4 = 0;
X    ((*((volatile uint16_t *)(0x4000081A)))) = 0;
N    // Set output mode to Reset/Set
N    TA2CCTL3 = OUTMOD_7 ; // Macro which is equal to 0x00e0, defined in msp432p401r.h
X    ((*((volatile uint16_t *)(0x40000808)))) = ((uint16_t)0x00E0) ; 
N    TA2CCTL4 = OUTMOD_7 ; // Macro which is equal to 0x00e0, defined in msp432p401r.h
X    ((*((volatile uint16_t *)(0x4000080A)))) = ((uint16_t)0x00E0) ; 
N    // Initialize Timer A
N    TA2CTL = TASSEL__SMCLK | MC__UP | TACLR ; // Tie Timer A to SMCLK, use Up mode, and clear TA2R
X    ((*((volatile uint16_t *)(0x40000800)))) = ((uint16_t)0x0200) | ((uint16_t)0x0010) | ((uint16_t)0x0004) ; 
N    // PWM signal will now be available
N}
N
Nvoid setupClocks(){
N    // Set the DCO to DCO_Freq MHZ and set the sub master clock
N    CS_setDCOFrequency(DCO_Freq);
X    CS_setDCOFrequency(16E+6);
N    // Init the submaster clock
N    CS_initClockSignal(CS_SMCLK, CS_DCOCLK_SELECT, CS_CLOCK_DIVIDER_4);
X    CS_initClockSignal(((uint32_t)0x00000008), ((uint32_t)0x00000003), ((uint32_t)0x20000000));
N}
N
Nvoid setupEncoderInterrupts(){
N    //Interrupt declarations
N    Interrupt_disableMaster();
N    GPIO_interruptEdgeSelect(RIGHT_ENC_PORT, RIGHT_ENC_PIN_A, GPIO_LOW_TO_HIGH_TRANSITION);
X    GPIO_interruptEdgeSelect(4, (0x0001), (0x00));
N    GPIO_interruptEdgeSelect(LEFT_ENC_PORT, LEFT_ENC_PIN_A, GPIO_LOW_TO_HIGH_TRANSITION);
X    GPIO_interruptEdgeSelect(5, (0x0010), (0x00));
N    GPIO_clearInterruptFlag(RIGHT_ENC_PORT, RIGHT_ENC_PIN_A);
X    GPIO_clearInterruptFlag(4, (0x0001));
N    GPIO_clearInterruptFlag(LEFT_ENC_PORT, LEFT_ENC_PIN_A);
X    GPIO_clearInterruptFlag(5, (0x0010));
N    GPIO_enableInterrupt(RIGHT_ENC_PORT, RIGHT_ENC_PIN_A);
X    GPIO_enableInterrupt(4, (0x0001));
N    GPIO_enableInterrupt(LEFT_ENC_PORT, LEFT_ENC_PIN_A);
X    GPIO_enableInterrupt(5, (0x0010));
N    Interrupt_enableInterrupt(INT_PORT4);
X    Interrupt_enableInterrupt((54));
N    Interrupt_enableInterrupt(INT_PORT5);
X    Interrupt_enableInterrupt((55));
N}
N
Nvoid setupPins(){
N    // Pinout: D3: P6.0, D2: P3.2, D1: P3.3, D0: P4.1, BIN2: P5.2, AIN2: P3.6, AIN1: P3.7, BIN1: P3.5
N    GPIO_setAsOutputPin(CCW_1_PORT, CW_1_PIN|CW_2_PIN|CCW_1_PIN);
X    GPIO_setAsOutputPin(3, (0x0080)|(0x0020)|(0x0040));
N    GPIO_setAsOutputPin(CCW_2_PORT, CCW_2_PIN);
X    GPIO_setAsOutputPin(5, (0x0004));
N    GPIO_setAsInputPinWithPullDownResistor(GPIO_PORT_P3, GPIO_PIN2|GPIO_PIN3);
X    GPIO_setAsInputPinWithPullDownResistor(3, (0x0004)|(0x0008));
N    GPIO_setAsInputPinWithPullDownResistor(GPIO_PORT_P6, GPIO_PIN0);
X    GPIO_setAsInputPinWithPullDownResistor(6, (0x0001));
N    GPIO_setAsInputPinWithPullDownResistor(GPIO_PORT_P4, GPIO_PIN1);
X    GPIO_setAsInputPinWithPullDownResistor(4, (0x0002));
N    // Encoder Pins as input R_PIN_A: 4.0, R_PIN_B: 4.2, L_PIN_A: 5.4, L_PIN_B: 4.7
N    GPIO_setAsInputPinWithPullUpResistor(RIGHT_ENC_PORT,RIGHT_ENC_PIN_A | RIGHT_ENC_PIN_B);
X    GPIO_setAsInputPinWithPullUpResistor(4,(0x0001) | (0x0004));
N    GPIO_setAsInputPinWithPullUpResistor(LEFT_ENC_PORT,LEFT_ENC_PIN_A);
X    GPIO_setAsInputPinWithPullUpResistor(5,(0x0010));
N    GPIO_setAsInputPinWithPullUpResistor(GPIO_PORT_P4, LEFT_ENC_PIN_B);
X    GPIO_setAsInputPinWithPullUpResistor(4, (0x0080));
N    //LED 1 to indicate once calibration is done
N    GPIO_setAsOutputPin(GPIO_PORT_P1, GPIO_PIN0);
X    GPIO_setAsOutputPin(1, (0x0001));
N    GPIO_setOutputLowOnPin(GPIO_PORT_P1, GPIO_PIN0);
X    GPIO_setOutputLowOnPin(1, (0x0001));
N    //Led 2 Blue p2.2 as indicator
N    GPIO_setAsOutputPin(GPIO_PORT_P2, GPIO_PIN2);
X    GPIO_setAsOutputPin(2, (0x0004));
N    GPIO_setOutputLowOnPin(GPIO_PORT_P2, GPIO_PIN2);
X    GPIO_setOutputLowOnPin(2, (0x0004));
N}
N
Nvoid setupSystick(){
N    SysTick_enableModule();
N    //Interrupt every ms
N    SysTick_setPeriod(DCO_Freq/1000);
X    SysTick_setPeriod(16E+6/1000);
N    //Enable Interrupts
N    SysTick_enableInterrupt();
N}
N
N
